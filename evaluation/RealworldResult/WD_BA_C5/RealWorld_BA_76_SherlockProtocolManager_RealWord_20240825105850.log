[2024-25-08 10:58:50 INFO] **[Preprocessing]**

**ChatDev Starts** (20240825105850)

**Timestamp**: 20240825105850

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import './Manager.sol';
import '../interfaces/managers/ISherlockProtocolManager.sol';

/// @title Sherlock core interface for protocols
/// @author Evert Kors
// This is the contract that manages covered protocols

contract SherlockProtocolManager is ISherlockProtocolManager, Manager {
  using SafeERC20 for IERC20;

  // Represents the token that protocols pay with (currently USDC)
  IERC20 public immutable token;

  // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed
  uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc

  // A removed protocol is still able to make a claim for this amount of time after its removal
  uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days;

  // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance
  uint256 public constant MIN_SECONDS_LEFT = 7 days;

  // Convenient for percentage calculations
  uint256 internal constant HUNDRED_PERCENT = 10**18;

  // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage
  // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying
  uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours;

  // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)
  mapping(bytes32 => address) internal protocolAgent_;

  // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)
  mapping(bytes32 => uint256) internal nonStakersPercentage;

  // The premium per second paid by each protocol is stored in this mapping
  mapping(bytes32 => uint256) internal premiums_;

  // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.
  // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not
  mapping(bytes32 => uint256) internal activeBalances;

  // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol
  mapping(bytes32 => uint256) internal lastAccountedEachProtocol;

  // The amount that can be claimed by nonstakers for each protocol
  // We need this value so we can track how much payment is coming from each protocol
  mapping(bytes32 => uint256) internal nonStakersClaimableByProtocol;

  // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)
  uint256 internal lastAccountedGlobal;

  // This is the total amount of premiums paid (per second) by all the covered protocols (added up)
  uint256 internal allPremiumsPerSecToStakers;

  // This is the amount that was claimable by stakers the last time the accounting was run
  // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date
  uint256 internal lastClaimablePremiumsForStakers;

  // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage
  // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)
  uint256 public override minActiveBalance;

  // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)
  mapping(bytes32 => uint256) internal removedProtocolClaimDeadline;

  // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)
  mapping(bytes32 => address) internal removedProtocolAgent;

  // Current amount of coverage (i.e. 20M USDC) for a protocol
  mapping(bytes32 => uint256) internal currentCoverage;

  // Previous amount of coverage for a protocol
  // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount
  mapping(bytes32 => uint256) internal previousCoverage;

  // Setting the token to USDC
  constructor(IERC20 _token) {
    if (address(_token) == address(0)) revert ZeroArgument();
    token = _token;
  }

  // Modifier used to ensure a protocol exists (has been instantiated and not removed)
  modifier protocolExists(bytes32 _protocol) {
    _verifyProtocolExists(_protocol);
    _;
  }

  /// @notice View current protocolAgent of `_protocol`
  /// @param _protocol Protocol identifier
  /// @return Address able to submit claims
  function protocolAgent(bytes32 _protocol) external view override returns (address) {
    address agent = protocolAgent_[_protocol];
    if (agent != address(0)) return agent;

    // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned
    // Note: Old protocol agent will never be address(0)
    if (block.timestamp <= removedProtocolClaimDeadline[_protocol]) {
      return removedProtocolAgent[_protocol];
    }

    // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned
    revert ProtocolNotExists(_protocol);
  }

  // Checks if the protocol exists, then returns the current premium per second being charged
  /// @notice View current premium of protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of premium `_protocol` pays per second
  function premium(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return premiums_[_protocol];
  }

  // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)
  // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)
  function _verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {
    _protocolAgent = protocolAgent_[_protocol];
    if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);
  }

  //
  // View methods
  //

  // Calcs the debt accrued by the protocol since it last had an accounting update
  // This is the amount that needs to be removed from a protocol's active balance
  function _calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {
    return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums_[_protocol];
  }

  /// @notice View the amount nonstakers can claim from this protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of tokens claimable by nonstakers
  /// @dev this reads from a storage variable + (now-lastsettled) * premiums
  // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]
  // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed
  function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {
    // Calcs the debt of a protocol since the last accounting update
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // Gets the active balance of the protocol
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) debt = balance;

    // Adds the incremental claimable amount owed to nonstakers to the total claimable amount
    return
      nonStakersClaimableByProtocol[_protocol] +
      (nonStakersPercentage[_protocol] * debt) /
      HUNDRED_PERCENT;
  }

  /// @notice View current amount of all premiums that are owed to stakers
  /// @return Premiums claimable
  /// @dev Will increase every block
  /// @dev base + (now - last_settled) * ps
  function claimablePremiums() public view override returns (uint256) {
    // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)
    return
      lastClaimablePremiumsForStakers +
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
  }

  /// @notice View seconds of coverage left for `_protocol` before it runs out of active balance
  /// @param _protocol Protocol identifier
  /// @return Seconds of coverage left
  function secondsOfCoverageLeft(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _secondsOfCoverageLeft(_protocol);
  }

  // Helper function to return seconds of coverage left for a protocol
  // Gets the current active balance of the protocol and divides by the premium per second for the protocol
  function _secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {
    uint256 premium = premiums_[_protocol];
    if (premium == 0) return 0;
    return _activeBalance(_protocol) / premium;
  }

  /// @notice View current active balance of covered protocol
  /// @param _protocol Protocol identifier
  /// @return Active balance
  /// @dev Accrued debt is subtracted from the stored active balance
  function activeBalance(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _activeBalance(_protocol);
  }

  // Helper function to calc the active balance of a protocol at current time
  function _activeBalance(bytes32 _protocol) internal view returns (uint256) {
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) return 0;
    return balance - debt;
  }

  //
  // State methods
  //

  /// @notice Helps set the premium per second for an individual protocol
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function
  function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)
    internal
    returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)
  {
    // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers
    // Also updates the last accounted timestamp for this protocol
    // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings
    // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol
    nonStakerPercentage = _settleProtocolDebt(_protocol);
    // Stores the old premium before it gets updated
    oldPremiumPerSecond = premiums_[_protocol];

    if (oldPremiumPerSecond != _premium) {
      // Sets the protocol's premium per second to the new value
      premiums_[_protocol] = _premium;
      emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium);
    }
    // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing
    // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes
    // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point
    // Where arbs would no longer be incentivized to remove the protocol
    // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems
    if (_premium != 0 && _secondsOfCoverageLeft(_protocol) < MIN_SECONDS_OF_COVERAGE) {
      revert InsufficientBalance(_protocol);
    }
  }

  /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {
    // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings
    (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
      _protocol,
      _premium
    );
    // Settling the total amount of premiums owed to stakers before a new premium per second gets set
    _settleTotalDebt();
    // This calculates the new global premium per second that gets paid to stakers
    // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      oldPremiumPerSecond,
      _premium,
      nonStakerPercentage,
      nonStakerPercentage,
      allPremiumsPerSecToStakers
    );
  }

  // Internal function to set a new protocolAgent for a specific protocol
  // _oldAgent is only included as part of emitting an event
  function _setProtocolAgent(
    bytes32 _protocol,
    address _oldAgent,
    address _protocolAgent
  ) internal {
    protocolAgent_[_protocol] = _protocolAgent;
    emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);
  }

  // Subtracts the accrued debt from a protocol's active balance
  // Credits the amount that can be claimed by nonstakers for this protocol
  // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings
  // Most of this function is dealing with an edge case related to a protocol not being removed by arbs
  function _settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {
    // This calcs the accrued debt of the protocol since it was last updated
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // This pulls the percentage that is sent to nonstakers
    _nonStakerPercentage = nonStakersPercentage[_protocol];
    // In case the protocol has accrued debt, this code block will ensure the debt is settled properly
    if (debt != 0) {
      // Pulls the stored active balance of the protocol
      uint256 balance = activeBalances[_protocol];
      // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance
      // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point
      // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage
      // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up
      if (debt > balance) {
        // This error amount represents the magnitude of the mistake
        uint256 error = debt - balance;
        // Gets the latest value of claimable premiums for stakers
        _settleTotalDebt();
        // @note to production, set premium first to zero before solving accounting issue.
        // otherwise the accounting error keeps increasing
        uint256 lastClaimablePremiumsForStakers_ = lastClaimablePremiumsForStakers;

        // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%
        uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /
          HUNDRED_PERCENT;

        // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short
        uint256 insufficientTokens;

        // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally
        // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error
        // This first line can be true if claimPremiumsForStakers() has been called and
        // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be >0 still
        if (claimablePremiumError > lastClaimablePremiumsForStakers_) {
          insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;
          lastClaimablePremiumsForStakers = 0;
        } else {
          // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums
          // By the amount that was added in error (error) and insufficientTokens = 0
          lastClaimablePremiumsForStakers =
            lastClaimablePremiumsForStakers_ -
            claimablePremiumError;
        }

        // If two events are thrown, the values need to be summed up for the actual state.
        // This means an error of this type will continue until it is handled
        emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);
        // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case
        debt = balance;
      }
      // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance
      activeBalances[_protocol] = balance - debt;
      // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol
      nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT;
    }
    // Updates the last accounted timestamp for this protocol
    lastAccountedEachProtocol[_protocol] = block.timestamp;
  }

  // Multiplies the total premium per second * number of seconds since the last global accounting update
  // And adds it to the total claimable amount for stakers
  function _settleTotalDebt() internal {
    lastClaimablePremiumsForStakers +=
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
    lastAccountedGlobal = block.timestamp;
  }

  // Calculates the global premium per second for stakers
  // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers
  // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones
  function _calcGlobalPremiumPerSecForStakers(
    uint256 _premiumOld,
    uint256 _premiumNew,
    uint256 _nonStakerPercentageOld,
    uint256 _nonStakerPercentageNew,
    uint256 _inMemAllPremiumsPerSecToStakers
  ) internal pure returns (uint256) {
    return
      _inMemAllPremiumsPerSecToStakers +
      ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /
      HUNDRED_PERCENT -
      ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /
      HUNDRED_PERCENT;
  }

  // Helper function to remove and clean up a protocol from Sherlock
  // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made
  function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {
    // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol
    _setSingleAndGlobalProtocolPremium(_protocol, 0);

    // Grabs the protocol's active balance
    uint256 balance = activeBalances[_protocol];

    // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent
    if (balance != 0) {
      delete activeBalances[_protocol];
      token.safeTransfer(_agent, balance);

      emit ProtocolBalanceWithdrawn(_protocol, balance);
    }

    // Sets the protocol agent to zero address (as part of clean up)
    _setProtocolAgent(_protocol, _agent, address(0));

    // Cleans up other mappings for this protocol
    delete nonStakersPercentage[_protocol];
    delete lastAccountedEachProtocol[_protocol];
    // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above

    // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol
    removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;

    // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed
    // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked
    removedProtocolAgent[_protocol] = _agent;

    emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0));
    emit ProtocolRemoved(_protocol);
  }

  /// @notice Sets the minimum active balance before an arb can remove a protocol
  /// @param _minActiveBalance Minimum balance needed (in USDC)
  /// @dev Only gov
  function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {
    // New value cannot be the same as current value
    if (minActiveBalance == _minActiveBalance) revert InvalidArgument();
    // Can't set a value that is too high to be reasonable
    if (_minActiveBalance >= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions();

    emit MinBalance(minActiveBalance, _minActiveBalance);
    minActiveBalance = _minActiveBalance;
  }

  // This function allows the nonstakers role to claim tokens owed to them by a specific protocol
  /// @notice Choose an `_amount` of tokens that nonstakers (`_receiver` address) will receive from `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens
  /// @param _receiver Address to receive tokens
  /// @dev Only callable by nonstakers role
  function nonStakersClaim(
    bytes32 _protocol,
    uint256 _amount,
    address _receiver
  ) external override whenNotPaused {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_amount == uint256(0)) revert ZeroArgument();
    if (_receiver == address(0)) revert ZeroArgument();
    // Only the nonstakers role (multisig or contract) can pull the funds
    if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized();

    // Call can't be executed on protocol that is removed
    if (protocolAgent_[_protocol] != address(0)) {
      // Updates the amount that nonstakers can claim from this protocol
      _settleProtocolDebt(_protocol);
    }

    // Sets balance to the amount that is claimable by nonstakers for this specific protocol
    uint256 balance = nonStakersClaimableByProtocol[_protocol];
    // If the amount requested is more than what's owed to nonstakers, revert
    if (_amount > balance) revert InsufficientBalance(_protocol);

    // Sets the claimable amount to whatever is left over after this amount is pulled
    nonStakersClaimableByProtocol[_protocol] = balance - _amount;
    // Transfers the amount requested to the `_receiver` address
    token.safeTransfer(_receiver, _amount);
  }

  // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)
  /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address
  /// @dev Callable by everyone
  /// @dev Funds will be transferred to Sherlock core contract
  function claimPremiumsForStakers() external override whenNotPaused {
    // Gets address of core Sherlock contract
    address sherlock = address(sherlockCore);
    // Revert if core Sherlock contract not initialized yet
    if (sherlock == address(0)) revert InvalidConditions();

    // claimablePremiums is different from _settleTotalDebt() because it does not change state
    // Retrieves current amount of all premiums that are owed to stakers
    uint256 amount = claimablePremiums();

    // Transfers all the premiums owed to stakers to the Sherlock core contract
    if (amount != 0) {
      // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out
      lastClaimablePremiumsForStakers = 0;
      lastAccountedGlobal = block.timestamp;
      token.safeTransfer(sherlock, amount);
    }
  }

  // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts
  /// @param _protocol Protocol identifier
  /// @return current and previous are the current and previous coverage amounts for this protocol
  // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)
  function coverageAmounts(bytes32 _protocol)
    external
    view
    override
    returns (uint256 current, uint256 previous)
  {
    // Checks to see if the protocol has an active protocolAgent (protocol not removed)
    // OR checks to see if the removed protocol is still within the claim window
    // If so, gives the current and previous coverage, otherwise throws an error
    if (
      protocolAgent_[_protocol] != address(0) ||
      block.timestamp <= removedProtocolClaimDeadline[_protocol]
    ) {
      return (currentCoverage[_protocol], previousCoverage[_protocol]);
    }

    revert ProtocolNotExists(_protocol);
  }

  /// @notice Add a new protocol to Sherlock
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Address able to submit a claim on behalf of the protocol
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Adding a protocol allows the `_protocolAgent` to submit a claim
  /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point
  /// @dev `_nonStakers` is scaled by 10**18
  /// @dev Only callable by governance
  function protocolAdd(
    bytes32 _protocol,
    address _protocolAgent,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) external override onlyOwner {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Checks to make sure the protocol doesn't exist already
    if (protocolAgent_[_protocol] != address(0)) revert InvalidConditions();

    // Updates the protocol agent and passes in the old agent which is 0 address in this case
    _setProtocolAgent(_protocol, address(0), _protocolAgent);

    // Delete mappings that are potentially non default values
    // From previous time protocol was added/removed
    delete removedProtocolClaimDeadline[_protocol];
    delete removedProtocolAgent[_protocol];
    delete currentCoverage[_protocol];
    delete previousCoverage[_protocol];

    emit ProtocolAdded(_protocol);

    // Most of the logic for actually adding a protocol in this function
    protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Update info regarding a protocol
  /// @param _protocol Protocol identifier
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Only callable by governance
  /// @dev `_nonStakers` can be 0
  function protocolUpdate(
    bytes32 _protocol,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) public override onlyOwner {
    if (_coverage == bytes32(0)) revert ZeroArgument();
    if (_nonStakers > HUNDRED_PERCENT) revert InvalidArgument();
    if (_coverageAmount == uint256(0)) revert ZeroArgument();

    // Checks to make sure the protocol has been assigned a protocol agent
    _verifyProtocolExists(_protocol);

    // Subtracts the accrued debt from a protocol's active balance (if any)
    // Updates the amount that can be claimed by nonstakers
    _settleProtocolDebt(_protocol);

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    // Gets the premium per second for this protocol
    uint256 premium = premiums_[_protocol];

    // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be)
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      premium,
      premium,
      nonStakersPercentage[_protocol],
      _nonStakers,
      allPremiumsPerSecToStakers
    );

    // Updates the stored value of percentage of premiums that go to nonstakers
    nonStakersPercentage[_protocol] = _nonStakers;

    // Updates previous coverage and current coverage amounts
    previousCoverage[_protocol] = currentCoverage[_protocol];
    currentCoverage[_protocol] = _coverageAmount;

    emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Remove a protocol from coverage
  /// @param _protocol Protocol identifier
  /// @dev Before removing a protocol the premium must be 0
  /// @dev Removing a protocol basically stops the `_protocolAgent` from being active (can still submit claims until claim deadline though)
  /// @dev Pays off debt + sends remaining balance to protocol agent
  /// @dev This call should be subject to a timelock
  /// @dev Only callable by governance
  function protocolRemove(bytes32 _protocol) external override onlyOwner {
    // checks to make sure the protocol actually has a protocol agent
    address agent = _verifyProtocolExists(_protocol);

    // Removes a protocol from Sherlock and cleans up its data
    // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made
    _forceRemoveProtocol(_protocol, agent);
  }

  /// @notice Remove a protocol with insufficient active balance
  /// @param _protocol Protocol identifier
  // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function
  function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {
    address agent = _verifyProtocolExists(_protocol);

    // Gets the latest value of the active balance at this protocol
    _settleProtocolDebt(_protocol);
    // Sets latest value of active balance to remainingBalance variable
    uint256 remainingBalance = activeBalances[_protocol];

    // This means the protocol still has adequate active balance and thus cannot be removed
    if (remainingBalance >= minActiveBalance) revert InvalidConditions();

    // Sets the protocol's active balance to 0
    delete activeBalances[_protocol];
    // Removes the protocol from coverage
    _forceRemoveProtocol(_protocol, agent);

    if (remainingBalance != 0) {
      // sends the remaining balance to msg.sender
      token.safeTransfer(msg.sender, remainingBalance);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);
  }

  /// @notice Calculate if arb is possible and what the reward would be
  /// @param _protocol Protocol identifier
  /// @return arbAmount Amount reward for arbing
  /// @return able Indicator if arb call is even possible
  /// @dev Doesn't subtract the current protocol debt from the active balance
  function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)
    internal
    view
    returns (uint256 arbAmount, bool able)
  {
    uint256 secondsLeft = _secondsOfCoverageLeft(_protocol);

    // If arb is not possible return false
    if (secondsLeft >= MIN_SECONDS_OF_COVERAGE) return (0, false);

    // This percentage scales over time
    // Reaches 100% on 0 seconds of coverage left
    uint256 percentageScaled = HUNDRED_PERCENT -
      (secondsLeft * HUNDRED_PERCENT) /
      MIN_SECONDS_OF_COVERAGE;

    able = true;
    arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;
  }

  /// @notice Removes a protocol with insufficent seconds of coverage left
  /// @param _protocol Protocol identifier
  // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second
  function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {
    // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings
    address agent = _verifyProtocolExists(_protocol);

    // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance()
    // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance()
    // But when removing based on seconds of coverage left, the remainingBalance could still be quite large
    // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance
    // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%)
    _settleProtocolDebt(_protocol);
    (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol);
    if (able == false) revert InvalidConditions();

    if (arbAmount != 0) {
      // subtracts the amount that will be paid to the arb from the active balance
      activeBalances[_protocol] -= arbAmount;
    }

    // Removes the protocol from coverage
    // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above
    _forceRemoveProtocol(_protocol, agent);

    // Done after removing protocol to mitigate reentrency pattern
    // (In case token allows callback)
    if (arbAmount != 0) {
      token.safeTransfer(msg.sender, arbAmount);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);
  }

  /// @notice Set premium of `_protocol` to `_premium`
  /// @param _protocol Protocol identifier
  /// @param _premium Amount of premium `_protocol` pays per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {
    // Checks to see if protocol has a protocol agent
    _verifyProtocolExists(_protocol);

    // Updates individual protocol's premium and allPremiumsPerSecToStakers
    _setSingleAndGlobalProtocolPremium(_protocol, _premium);
  }

  /// @notice Set premium of multiple protocols
  /// @param _protocol Array of protocol identifiers
  /// @param _premium Array of premium amounts protocols pay per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)
    external
    override
    onlyOwner
  {
    // Checks to make sure there are an equal amount of entries in each array
    if (_protocol.length != _premium.length) revert UnequalArrayLength();
    if (_protocol.length == 0) revert InvalidArgument();

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;

    // Loops through the array of protocols and checks to make sure each has a protocol agent assigned
    for (uint256 i; i < _protocol.length; i++) {
      _verifyProtocolExists(_protocol[i]);

      // Sets the protocol premium for that specific protocol
      // Function returns the old premium and nonStakerPercentage for that specific protocol
      (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
        _protocol[i],
        _premium[i]
      );

      // Calculates the new global premium which adds up all premiums paid by all protocols
      allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(
        oldPremiumPerSecond,
        _premium[i],
        nonStakerPercentage,
        nonStakerPercentage,
        allPremiumsPerSecToStakers_
      );
    }

    // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value
    allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;
  }

  // This is how protocols pay for coverage by increasing their active balance
  /// @notice Deposits `_amount` of token to the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to deposit
  /// @dev Approval should be made before calling
  function depositToActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    _verifyProtocolExists(_protocol);

    // Transfers _amount to this contract
    token.safeTransferFrom(msg.sender, address(this), _amount);
    // Increases the active balance of the protocol by _amount
    activeBalances[_protocol] += _amount;

    emit ProtocolBalanceDeposited(_protocol, _amount);
  }

  // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)
  // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)
  /// @notice Withdraws `_amount` of token from the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to withdraw
  /// @dev Only protocol agent is able to withdraw
  /// @dev Balance can be withdrawn up until 7 days worth of active balance
  function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    // Only the protocol agent can call this function
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Updates the active balance of the protocol
    _settleProtocolDebt(_protocol);

    // Sets currentBalance to the active balance of the protocol
    uint256 currentBalance = activeBalances[_protocol];
    // Reverts if trying to withdraw more than the active balance
    if (_amount > currentBalance) revert InsufficientBalance(_protocol);

    // Removes the _amount to be withdrawn from the active balance
    activeBalances[_protocol] = currentBalance - _amount;
    // Reverts if a protocol has less than 7 days worth of active balance left
    if (_secondsOfCoverageLeft(_protocol) < MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);

    // Transfers the amount to the msg.sender (protocol agent)
    token.safeTransfer(msg.sender, _amount);
    emit ProtocolBalanceWithdrawn(_protocol, _amount);
  }

  /// @notice Transfer protocol agent role
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Account able to submit a claim on behalf of the protocol
  /// @dev Only the active protocolAgent is able to transfer the role
  function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)
    external
    override
    whenNotPaused
  {
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Can't set the new protocol agent to the caller address
    if (msg.sender == _protocolAgent) revert InvalidArgument();
    // Because the caller must be the current protocol agent
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Sets the protocol agent to the new address
    _setProtocolAgent(_protocol, msg.sender, _protocolAgent);
  }

  /// @notice Function used to check if this is the current active protocol manager
  /// @return Boolean indicating it's active
  /// @dev If inactive the owner can pull all ERC20s and ETH
  /// @dev Will be checked by calling the sherlock contract
  function isActive() public view returns (bool) {
    return address(sherlockCore.sherlockProtocolManager()) == address(this);
  }

  // Only contract owner can call this
  // Sends all specified tokens in this contract to the receiver's address (as well as ETH)
  function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {
    if (_receiver == address(0)) revert ZeroArgument();
    // This contract must NOT be the current assigned protocol manager contract
    if (isActive()) revert InvalidConditions();
    // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH
    _sweep(_receiver, _extraTokens);
  }
}


**project_name**: RealWorld_BA_76_SherlockProtocolManager

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_76_SherlockProtocolManager_RealWord_20240825105850.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-25-08 10:58:50 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import './Manager.sol'; import '../interfaces/managers/ISherlockProtocolManager.sol'; /// @title Sherlock core interface for protocols /// @author Evert Kors // This is the contract that manages covered protocols contract SherlockProtocolManager is ISherlockProtocolManager, Manager {   using SafeERC20 for IERC20; // Represents the token that protocols pay with (currently USDC)   IERC20 public immutable token; // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed   uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc // A removed protocol is still able to make a claim for this amount of time after its removal   uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days; // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance   uint256 public constant MIN_SECONDS_LEFT = 7 days; // Convenient for percentage calculations   uint256 internal constant HUNDRED_PERCENT = 10**18; // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage   // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying   uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours; // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)   mapping(bytes32 =&gt; address) internal protocolAgent_; // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)   mapping(bytes32 =&gt; uint256) internal nonStakersPercentage; // The premium per second paid by each protocol is stored in this mapping   mapping(bytes32 =&gt; uint256) internal premiums_; // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.   // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not   mapping(bytes32 =&gt; uint256) internal activeBalances; // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol   mapping(bytes32 =&gt; uint256) internal lastAccountedEachProtocol; // The amount that can be claimed by nonstakers for each protocol   // We need this value so we can track how much payment is coming from each protocol   mapping(bytes32 =&gt; uint256) internal nonStakersClaimableByProtocol; // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)   uint256 internal lastAccountedGlobal; // This is the total amount of premiums paid (per second) by all the covered protocols (added up)   uint256 internal allPremiumsPerSecToStakers; // This is the amount that was claimable by stakers the last time the accounting was run   // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date   uint256 internal lastClaimablePremiumsForStakers; // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage   // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)   uint256 public override minActiveBalance; // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)   mapping(bytes32 =&gt; uint256) internal removedProtocolClaimDeadline; // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)   mapping(bytes32 =&gt; address) internal removedProtocolAgent; // Current amount of coverage (i.e. 20M USDC) for a protocol   mapping(bytes32 =&gt; uint256) internal currentCoverage; // Previous amount of coverage for a protocol   // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount   mapping(bytes32 =&gt; uint256) internal previousCoverage; // Setting the token to USDC   constructor(IERC20 _token) {     if (address(_token) == address(0)) revert ZeroArgument();     token = _token;   } // Modifier used to ensure a protocol exists (has been instantiated and not removed)   modifier protocolExists(bytes32 protocol) {     _verifyProtocolExists(_protocol);     ;   } /// @notice View current protocolAgent of _protocol   /// @param protocol Protocol identifier   /// @return Address able to submit claims   function protocolAgent(bytes32 _protocol) external view override returns (address) {     address agent = protocolAgent[_protocol];     if (agent != address(0)) return agent; // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned // Note: Old protocol agent will never be address(0) if (block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]) {   return removedProtocolAgent[_protocol]; }  // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned revert ProtocolNotExists(_protocol);  } // Checks if the protocol exists, then returns the current premium per second being charged   /// @notice View current premium of protocol   /// @param protocol Protocol identifier   /// @return Amount of premium _protocol pays per second   function premium(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return premiums[_protocol];   } // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)   // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)   function verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {     _protocolAgent = protocolAgent[_protocol];     if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);   } //   // View methods   // // Calcs the debt accrued by the protocol since it last had an accounting update   // This is the amount that needs to be removed from a protocol's active balance   function calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {     return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums[_protocol];   } /// @notice View the amount nonstakers can claim from this protocol   /// @param _protocol Protocol identifier   /// @return Amount of tokens claimable by nonstakers   /// @dev this reads from a storage variable + (now-lastsettled) * premiums   // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]   // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed   function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {     // Calcs the debt of a protocol since the last accounting update     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     // Gets the active balance of the protocol     uint256 balance = activeBalances[_protocol];     // The debt should never be higher than the balance (only happens if the arbitrages fail)     if (debt &gt; balance) debt = balance; // Adds the incremental claimable amount owed to nonstakers to the total claimable amount return   nonStakersClaimableByProtocol[_protocol] +   (nonStakersPercentage[_protocol] * debt) /   HUNDRED_PERCENT;  } /// @notice View current amount of all premiums that are owed to stakers   /// @return Premiums claimable   /// @dev Will increase every block   /// @dev base + (now - last_settled) * ps   function claimablePremiums() public view override returns (uint256) {     // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)     return       lastClaimablePremiumsForStakers +       (block.timestamp - lastAccountedGlobal) *       allPremiumsPerSecToStakers;   } /// @notice View seconds of coverage left for _protocol before it runs out of active balance   /// @param _protocol Protocol identifier   /// @return Seconds of coverage left   function secondsOfCoverageLeft(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return _secondsOfCoverageLeft(_protocol);   } // Helper function to return seconds of coverage left for a protocol   // Gets the current active balance of the protocol and divides by the premium per second for the protocol   function secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {     uint256 premium = premiums[_protocol];     if (premium == 0) return 0;     return _activeBalance(_protocol) / premium;   } /// @notice View current active balance of covered protocol   /// @param _protocol Protocol identifier   /// @return Active balance   /// @dev Accrued debt is subtracted from the stored active balance   function activeBalance(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return _activeBalance(_protocol);   } // Helper function to calc the active balance of a protocol at current time   function _activeBalance(bytes32 _protocol) internal view returns (uint256) {     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     uint256 balance = activeBalances[_protocol];     // The debt should never be higher than the balance (only happens if the arbitrages fail)     if (debt &gt; balance) return 0;     return balance - debt;   } //   // State methods   // /// @notice Helps set the premium per second for an individual protocol   /// @param protocol Protocol identifier   /// @param _premium New premium per second   /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function   function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)     internal     returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)   {     // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers     // Also updates the last accounted timestamp for this protocol     // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings     // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol     nonStakerPercentage = _settleProtocolDebt(_protocol);     // Stores the old premium before it gets updated     oldPremiumPerSecond = premiums[_protocol]; if (oldPremiumPerSecond != _premium) {   // Sets the protocol's premium per second to the new value   premiums_[_protocol] = _premium;   emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium); } // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point // Where arbs would no longer be incentivized to remove the protocol // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems if (_premium != 0 &amp;&amp; _secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_OF_COVERAGE) {   revert InsufficientBalance(_protocol); }  } /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second   /// @param _protocol Protocol identifier   /// @param _premium New premium per second   function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {     // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings     (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(       _protocol,       _premium     );     // Settling the total amount of premiums owed to stakers before a new premium per second gets set     _settleTotalDebt();     // This calculates the new global premium per second that gets paid to stakers     // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function     allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(       oldPremiumPerSecond,       _premium,       nonStakerPercentage,       nonStakerPercentage,       allPremiumsPerSecToStakers     );   } // Internal function to set a new protocolAgent for a specific protocol   // oldAgent is only included as part of emitting an event   function _setProtocolAgent(     bytes32 _protocol,     address _oldAgent,     address _protocolAgent   ) internal {     protocolAgent[_protocol] = _protocolAgent;     emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);   } // Subtracts the accrued debt from a protocol's active balance   // Credits the amount that can be claimed by nonstakers for this protocol   // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings   // Most of this function is dealing with an edge case related to a protocol not being removed by arbs   function settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {     // This calcs the accrued debt of the protocol since it was last updated     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     // This pulls the percentage that is sent to nonstakers     _nonStakerPercentage = nonStakersPercentage[_protocol];     // In case the protocol has accrued debt, this code block will ensure the debt is settled properly     if (debt != 0) {       // Pulls the stored active balance of the protocol       uint256 balance = activeBalances[_protocol];       // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance       // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point       // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage       // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up       if (debt &gt; balance) {         // This error amount represents the magnitude of the mistake         uint256 error = debt - balance;         // Gets the latest value of claimable premiums for stakers         _settleTotalDebt();         // @note to production, set premium first to zero before solving accounting issue.         // otherwise the accounting error keeps increasing         uint256 lastClaimablePremiumsForStakers = lastClaimablePremiumsForStakers;     // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%     uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /       HUNDRED_PERCENT;      // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short     uint256 insufficientTokens;      // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally     // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error     // This first line can be true if claimPremiumsForStakers() has been called and     // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be &gt;0 still     if (claimablePremiumError &gt; lastClaimablePremiumsForStakers_) {       insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;       lastClaimablePremiumsForStakers = 0;     } else {       // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums       // By the amount that was added in error (error) and insufficientTokens = 0       lastClaimablePremiumsForStakers =         lastClaimablePremiumsForStakers_ -         claimablePremiumError;     }      // If two events are thrown, the values need to be summed up for the actual state.     // This means an error of this type will continue until it is handled     emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);     // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case     debt = balance;   }   // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance   activeBalances[_protocol] = balance - debt;   // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol   nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT; } // Updates the last accounted timestamp for this protocol lastAccountedEachProtocol[_protocol] = block.timestamp;  } // Multiplies the total premium per second * number of seconds since the last global accounting update   // And adds it to the total claimable amount for stakers   function _settleTotalDebt() internal {     lastClaimablePremiumsForStakers +=       (block.timestamp - lastAccountedGlobal) *       allPremiumsPerSecToStakers;     lastAccountedGlobal = block.timestamp;   } // Calculates the global premium per second for stakers   // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers   // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones   function _calcGlobalPremiumPerSecForStakers(     uint256 _premiumOld,     uint256 _premiumNew,     uint256 _nonStakerPercentageOld,     uint256 _nonStakerPercentageNew,     uint256 _inMemAllPremiumsPerSecToStakers   ) internal pure returns (uint256) {     return       _inMemAllPremiumsPerSecToStakers +       ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /       HUNDRED_PERCENT -       ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /       HUNDRED_PERCENT;   } // Helper function to remove and clean up a protocol from Sherlock   // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made   function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {     // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol     _setSingleAndGlobalProtocolPremium(_protocol, 0); // Grabs the protocol's active balance uint256 balance = activeBalances[_protocol];  // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent if (balance != 0) {   delete activeBalances[_protocol];   token.safeTransfer(_agent, balance);    emit ProtocolBalanceWithdrawn(_protocol, balance); }  // Sets the protocol agent to zero address (as part of clean up) _setProtocolAgent(_protocol, _agent, address(0));  // Cleans up other mappings for this protocol delete nonStakersPercentage[_protocol]; delete lastAccountedEachProtocol[_protocol]; // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above  // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;  // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked removedProtocolAgent[_protocol] = _agent;  emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0)); emit ProtocolRemoved(_protocol);  } /// @notice Sets the minimum active balance before an arb can remove a protocol   /// @param _minActiveBalance Minimum balance needed (in USDC)   /// @dev Only gov   function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {     // New value cannot be the same as current value     if (minActiveBalance == _minActiveBalance) revert InvalidArgument();     // Can't set a value that is too high to be reasonable     if (_minActiveBalance &gt;= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions(); emit MinBalance(minActiveBalance, _minActiveBalance); minActiveBalance = _minActiveBalance;  } // This function allows the nonstakers role to claim tokens owed to them by a specific protocol   /// @notice Choose an _amount of tokens that nonstakers (_receiver address) will receive from _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens   /// @param _receiver Address to receive tokens   /// @dev Only callable by nonstakers role   function nonStakersClaim(     bytes32 _protocol,     uint256 _amount,     address _receiver   ) external override whenNotPaused {     if (_protocol == bytes32(0)) revert ZeroArgument();     if (_amount == uint256(0)) revert ZeroArgument();     if (_receiver == address(0)) revert ZeroArgument();     // Only the nonstakers role (multisig or contract) can pull the funds     if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized(); // Call can't be executed on protocol that is removed if (protocolAgent_[_protocol] != address(0)) {   // Updates the amount that nonstakers can claim from this protocol   _settleProtocolDebt(_protocol); }  // Sets balance to the amount that is claimable by nonstakers for this specific protocol uint256 balance = nonStakersClaimableByProtocol[_protocol]; // If the amount requested is more than what's owed to nonstakers, revert if (_amount &gt; balance) revert InsufficientBalance(_protocol);  // Sets the claimable amount to whatever is left over after this amount is pulled nonStakersClaimableByProtocol[_protocol] = balance - _amount; // Transfers the amount requested to the `_receiver` address token.safeTransfer(_receiver, _amount);  } // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)   /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address   /// @dev Callable by everyone   /// @dev Funds will be transferred to Sherlock core contract   function claimPremiumsForStakers() external override whenNotPaused {     // Gets address of core Sherlock contract     address sherlock = address(sherlockCore);     // Revert if core Sherlock contract not initialized yet     if (sherlock == address(0)) revert InvalidConditions(); // claimablePremiums is different from _settleTotalDebt() because it does not change state // Retrieves current amount of all premiums that are owed to stakers uint256 amount = claimablePremiums();  // Transfers all the premiums owed to stakers to the Sherlock core contract if (amount != 0) {   // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out   lastClaimablePremiumsForStakers = 0;   lastAccountedGlobal = block.timestamp;   token.safeTransfer(sherlock, amount); }  } // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts   /// @param protocol Protocol identifier   /// @return current and previous are the current and previous coverage amounts for this protocol   // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)   function coverageAmounts(bytes32 _protocol)     external     view     override     returns (uint256 current, uint256 previous)   {     // Checks to see if the protocol has an active protocolAgent (protocol not removed)     // OR checks to see if the removed protocol is still within the claim window     // If so, gives the current and previous coverage, otherwise throws an error     if (       protocolAgent[_protocol] != address(0) ||       block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]     ) {       return (currentCoverage[_protocol], previousCoverage[_protocol]);     } revert ProtocolNotExists(_protocol);  } /// @notice Add a new protocol to Sherlock   /// @param protocol Protocol identifier   /// @param _protocolAgent Address able to submit a claim on behalf of the protocol   /// @param _coverage Hash referencing the active coverage agreement   /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 1018   /// @param _coverageAmount Max amount claimable by this protocol   /// @dev Adding a protocol allows the _protocolAgent to submit a claim   /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point   /// @dev _nonStakers is scaled by 1018   /// @dev Only callable by governance   function protocolAdd(     bytes32 _protocol,     address _protocolAgent,     bytes32 _coverage,     uint256 _nonStakers,     uint256 _coverageAmount   ) external override onlyOwner {     if (_protocol == bytes32(0)) revert ZeroArgument();     if (_protocolAgent == address(0)) revert ZeroArgument();     // Checks to make sure the protocol doesn't exist already     if (protocolAgent[_protocol] != address(0)) revert InvalidConditions(); // Updates the protocol agent and passes in the old agent which is 0 address in this case _setProtocolAgent(_protocol, address(0), _protocolAgent);  // Delete mappings that are potentially non default values // From previous time protocol was added/removed delete removedProtocolClaimDeadline[_protocol]; delete removedProtocolAgent[_protocol]; delete currentCoverage[_protocol]; delete previousCoverage[_protocol];  emit ProtocolAdded(_protocol);  // Most of the logic for actually adding a protocol in this function protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);  } /// @notice Update info regarding a protocol   /// @param _protocol Protocol identifier   /// @param _coverage Hash referencing the active coverage agreement   /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18   /// @param _coverageAmount Max amount claimable by this protocol   /// @dev Only callable by governance   /// @dev _nonStakers can be 0   function protocolUpdate(     bytes32 _protocol,     bytes32 _coverage,     uint256 _nonStakers,     uint256 _coverageAmount   ) public override onlyOwner {     if (_coverage == bytes32(0)) revert ZeroArgument();     if (_nonStakers &gt; HUNDRED_PERCENT) revert InvalidArgument();     if (_coverageAmount == uint256(0)) revert ZeroArgument(); // Checks to make sure the protocol has been assigned a protocol agent _verifyProtocolExists(_protocol);  // Subtracts the accrued debt from a protocol's active balance (if any) // Updates the amount that can be claimed by nonstakers _settleProtocolDebt(_protocol);  // Updates the global claimable amount for stakers _settleTotalDebt();  // Gets the premium per second for this protocol uint256 premium = premiums_[_protocol];  // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be) allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(   premium,   premium,   nonStakersPercentage[_protocol],   _nonStakers,   allPremiumsPerSecToStakers );  // Updates the stored value of percentage of premiums that go to nonstakers nonStakersPercentage[_protocol] = _nonStakers;  // Updates previous coverage and current coverage amounts previousCoverage[_protocol] = currentCoverage[_protocol]; currentCoverage[_protocol] = _coverageAmount;  emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);  } /// @notice Remove a protocol from coverage   /// @param _protocol Protocol identifier   /// @dev Before removing a protocol the premium must be 0   /// @dev Removing a protocol basically stops the _protocolAgent from being active (can still submit claims until claim deadline though)   /// @dev Pays off debt + sends remaining balance to protocol agent   /// @dev This call should be subject to a timelock   /// @dev Only callable by governance   function protocolRemove(bytes32 _protocol) external override onlyOwner {     // checks to make sure the protocol actually has a protocol agent     address agent = _verifyProtocolExists(_protocol); // Removes a protocol from Sherlock and cleans up its data // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made _forceRemoveProtocol(_protocol, agent);  } /// @notice Remove a protocol with insufficient active balance   /// @param _protocol Protocol identifier   // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function   function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {     address agent = _verifyProtocolExists(_protocol); // Gets the latest value of the active balance at this protocol _settleProtocolDebt(_protocol); // Sets latest value of active balance to remainingBalance variable uint256 remainingBalance = activeBalances[_protocol];  // This means the protocol still has adequate active balance and thus cannot be removed if (remainingBalance &gt;= minActiveBalance) revert InvalidConditions();  // Sets the protocol's active balance to 0 delete activeBalances[_protocol]; // Removes the protocol from coverage _forceRemoveProtocol(_protocol, agent);  if (remainingBalance != 0) {   // sends the remaining balance to msg.sender   token.safeTransfer(msg.sender, remainingBalance); } emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);  } /// @notice Calculate if arb is possible and what the reward would be   /// @param _protocol Protocol identifier   /// @return arbAmount Amount reward for arbing   /// @return able Indicator if arb call is even possible   /// @dev Doesn't subtract the current protocol debt from the active balance   function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)     internal     view     returns (uint256 arbAmount, bool able)   {     uint256 secondsLeft = _secondsOfCoverageLeft(_protocol); // If arb is not possible return false if (secondsLeft &gt;= MIN_SECONDS_OF_COVERAGE) return (0, false);  // This percentage scales over time // Reaches 100% on 0 seconds of coverage left uint256 percentageScaled = HUNDRED_PERCENT -   (secondsLeft * HUNDRED_PERCENT) /   MIN_SECONDS_OF_COVERAGE;  able = true; arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;  } /// @notice Removes a protocol with insufficent seconds of coverage left   /// @param _protocol Protocol identifier   // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second   function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {     // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings     address agent = _verifyProtocolExists(_protocol); // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance() // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance() // But when removing based on seconds of coverage left, the remainingBalance could still be quite large // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%) _settleProtocolDebt(_protocol); (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol); if (able == false) revert InvalidConditions();  if (arbAmount != 0) {   // subtracts the amount that will be paid to the arb from the active balance   activeBalances[_protocol] -= arbAmount; }  // Removes the protocol from coverage // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above _forceRemoveProtocol(_protocol, agent);  // Done after removing protocol to mitigate reentrency pattern // (In case token allows callback) if (arbAmount != 0) {   token.safeTransfer(msg.sender, arbAmount); } emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);  } /// @notice Set premium of _protocol to _premium   /// @param _protocol Protocol identifier   /// @param _premium Amount of premium _protocol pays per second   /// @dev The value 0 would mean inactive coverage   /// @dev Only callable by governance   function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {     // Checks to see if protocol has a protocol agent     _verifyProtocolExists(_protocol); // Updates individual protocol's premium and allPremiumsPerSecToStakers _setSingleAndGlobalProtocolPremium(_protocol, _premium);  } /// @notice Set premium of multiple protocols   /// @param _protocol Array of protocol identifiers   /// @param _premium Array of premium amounts protocols pay per second   /// @dev The value 0 would mean inactive coverage   /// @dev Only callable by governance   function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)     external     override     onlyOwner   {     // Checks to make sure there are an equal amount of entries in each array     if (_protocol.length != _premium.length) revert UnequalArrayLength();     if (_protocol.length == 0) revert InvalidArgument(); // Updates the global claimable amount for stakers _settleTotalDebt();  uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;  // Loops through the array of protocols and checks to make sure each has a protocol agent assigned for (uint256 i; i &lt; _protocol.length; i++) {   _verifyProtocolExists(_protocol[i]);    // Sets the protocol premium for that specific protocol   // Function returns the old premium and nonStakerPercentage for that specific protocol   (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(     _protocol[i],     _premium[i]   );    // Calculates the new global premium which adds up all premiums paid by all protocols   allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(     oldPremiumPerSecond,     _premium[i],     nonStakerPercentage,     nonStakerPercentage,     allPremiumsPerSecToStakers_   ); }  // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;  } // This is how protocols pay for coverage by increasing their active balance   /// @notice Deposits _amount of token to the active balance of _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens to deposit   /// @dev Approval should be made before calling   function depositToActiveBalance(bytes32 _protocol, uint256 _amount)     external     override     whenNotPaused   {     if (_amount == uint256(0)) revert ZeroArgument();     _verifyProtocolExists(_protocol); // Transfers _amount to this contract token.safeTransferFrom(msg.sender, address(this), _amount); // Increases the active balance of the protocol by _amount activeBalances[_protocol] += _amount;  emit ProtocolBalanceDeposited(_protocol, _amount);  } // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)   // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)   /// @notice Withdraws _amount of token from the active balance of _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens to withdraw   /// @dev Only protocol agent is able to withdraw   /// @dev Balance can be withdrawn up until 7 days worth of active balance   function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)     external     override     whenNotPaused   {     if (_amount == uint256(0)) revert ZeroArgument();     // Only the protocol agent can call this function     if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized(); // Updates the active balance of the protocol _settleProtocolDebt(_protocol);  // Sets currentBalance to the active balance of the protocol uint256 currentBalance = activeBalances[_protocol]; // Reverts if trying to withdraw more than the active balance if (_amount &gt; currentBalance) revert InsufficientBalance(_protocol);  // Removes the _amount to be withdrawn from the active balance activeBalances[_protocol] = currentBalance - _amount; // Reverts if a protocol has less than 7 days worth of active balance left if (_secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);  // Transfers the amount to the msg.sender (protocol agent) token.safeTransfer(msg.sender, _amount); emit ProtocolBalanceWithdrawn(_protocol, _amount);  } /// @notice Transfer protocol agent role   /// @param _protocol Protocol identifier   /// @param _protocolAgent Account able to submit a claim on behalf of the protocol   /// @dev Only the active protocolAgent is able to transfer the role   function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)     external     override     whenNotPaused   {     if (_protocolAgent == address(0)) revert ZeroArgument();     // Can't set the new protocol agent to the caller address     if (msg.sender == _protocolAgent) revert InvalidArgument();     // Because the caller must be the current protocol agent     if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized(); // Sets the protocol agent to the new address _setProtocolAgent(_protocol, msg.sender, _protocolAgent);  } /// @notice Function used to check if this is the current active protocol manager   /// @return Boolean indicating it's active   /// @dev If inactive the owner can pull all ERC20s and ETH   /// @dev Will be checked by calling the sherlock contract   function isActive() public view returns (bool) {     return address(sherlockCore.sherlockProtocolManager()) == address(this);   } // Only contract owner can call this   // Sends all specified tokens in this contract to the receiver's address (as well as ETH)   function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {     if (_receiver == address(0)) revert ZeroArgument();     // This contract must NOT be the current assigned protocol manager contract     if (isActive()) revert InvalidConditions();     // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH     _sweep(_receiver, _extraTokens);   } } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/***********\\n Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x)\n Sherlock Protocol: https://sherlock.xyz\n/***********/\n\nimport \'./Manager.sol\';\nimport \'../interfaces/managers/ISherlockProtocolManager.sol\';\n\n/// @title Sherlock core interface for protocols\n/// @author Evert Kors\n// This is the contract that manages covered protocols\n\ncontract SherlockProtocolManager is ISherlockProtocolManager, Manager {\n  using SafeERC20 for IERC20;\n\n  // Represents the token that protocols pay with (currently USDC)\n  IERC20 public immutable token;\n\n  // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed\n  uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 106; // 30k usdc\n\n  // A removed protocol is still able to make a claim for this amount of time after its removal\n  uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days;\n\n  // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance\n  uint256 public constant MIN_SECONDS_LEFT = 7 days;\n\n  // Convenient for percentage calculations\n  uint256 internal constant HUNDRED_PERCENT = 1018;\n\n  // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage\n  // This value is calculated from a protocol\'s active balance divided by the premium per second the protocol is paying\n  uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours;\n\n  // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)\n  mapping(bytes32 =&gt; address) internal protocolAgent_;\n\n  // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)\n  mapping(bytes32 =&gt; uint256) internal nonStakersPercentage;\n\n  // The premium per second paid by each protocol is stored in this mapping\n  mapping(bytes32 =&gt; uint256) internal premiums_;\n\n  // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.\n  // This "active balance" is really just an accounting concept, doesn\'t mean tokens have been transferred or not\n  mapping(bytes32 =&gt; uint256) internal activeBalances;\n\n  // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol\n  mapping(bytes32 =&gt; uint256) internal lastAccountedEachProtocol;\n\n  // The amount that can be claimed by nonstakers for each protocol\n  // We need this value so we can track how much payment is coming from each protocol\n  mapping(bytes32 =&gt; uint256) internal nonStakersClaimableByProtocol;\n\n  // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)\n  uint256 internal lastAccountedGlobal;\n\n  // This is the total amount of premiums paid (per second) by all the covered protocols (added up)\n  uint256 internal allPremiumsPerSecToStakers;\n\n  // This is the amount that was claimable by stakers the last time the accounting was run\n  // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date\n  uint256 internal lastClaimablePremiumsForStakers;\n\n  // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage\n  // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)\n  uint256 public override minActiveBalance;\n\n  // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)\n  mapping(bytes32 =&gt; uint256) internal removedProtocolClaimDeadline;\n\n  // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)\n  mapping(bytes32 =&gt; address) internal removedProtocolAgent;\n\n  // Current amount of coverage (i.e. 20M USDC) for a protocol\n  mapping(bytes32 =&gt; uint256) internal currentCoverage;\n\n  // Previous amount of coverage for a protocol\n  // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount\n  mapping(bytes32 =&gt; uint256) internal previousCoverage;\n\n  // Setting the token to USDC\n  constructor(IERC20 token) {\n    if (address(_token) == address(0)) revert ZeroArgument();\n    token = _token;\n  }\n\n  // Modifier used to ensure a protocol exists (has been instantiated and not removed)\n  modifier protocolExists(bytes32 _protocol) {\n    _verifyProtocolExists(_protocol);\n    ;\n  }\n\n  /// @notice View current protocolAgent of _protocol\n  /// @param protocol Protocol identifier\n  /// @return Address able to submit claims\n  function protocolAgent(bytes32 _protocol) external view override returns (address) {\n    address agent = protocolAgent[protocol];\n    if (agent != address(0)) return agent;\n\n    // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned\n    // Note: Old protocol agent will never be address(0)\n    if (block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]) {\n      return removedProtocolAgent[_protocol];\n    }\n\n    // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned\n    revert ProtocolNotExists(_protocol);\n  }\n\n  // Checks if the protocol exists, then returns the current premium per second being charged\n  /// @notice View current premium of protocol\n  /// @param _protocol Protocol identifier\n  /// @return Amount of premium _protocol pays per second\n  function premium(bytes32 _protocol)\n    external\n    view\n    override\n    protocolExists(_protocol)\n    returns (uint256)\n  {\n    return premiums[protocol];\n  }\n\n  // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)\n  // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)\n  function _verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {\n    _protocolAgent = protocolAgent[protocol];\n    if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);\n  }\n\n  //\n  // View methods\n  //\n\n  // Calcs the debt accrued by the protocol since it last had an accounting update\n  // This is the amount that needs to be removed from a protocol\'s active balance\n  function _calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {\n    return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums[protocol];\n  }\n\n  /// @notice View the amount nonstakers can claim from this protocol\n  /// @param _protocol Protocol identifier\n  /// @return Amount of tokens claimable by nonstakers\n  /// @dev this reads from a storage variable + (now-lastsettled) * premiums\n  // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]\n  // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn\'t change since the protocol has been removed\n  function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {\n    // Calcs the debt of a protocol since the last accounting update\n    uint256 debt = _calcIncrementalProtocolDebt(_protocol);\n    // Gets the active balance of the protocol\n    uint256 balance = activeBalances[_protocol];\n    // The debt should never be higher than the balance (only happens if the arbitrages fail)\n    if (debt &gt; balance) debt = balance;\n\n    // Adds the incremental claimable amount owed to nonstakers to the total claimable amount\n    return\n      nonStakersClaimableByProtocol[_protocol] +\n      (nonStakersPercentage[_protocol] * debt) /\n      HUNDRED_PERCENT;\n  }\n\n  /// @notice View current amount of all premiums that are owed to stakers\n  /// @return Premiums claimable\n  /// @dev Will increase every block\n  /// @dev base + (now - last_settled) * ps\n  function claimablePremiums() public view override returns (uint256) {\n    // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)\n    return\n      lastClaimablePremiumsForStakers +\n      (block.timestamp - lastAccountedGlobal) \n      allPremiumsPerSecToStakers;\n  }\n\n  /// @notice View seconds of coverage left for _protocol before it runs out of active balance\n  /// @param protocol Protocol identifier\n  /// @return Seconds of coverage left\n  function secondsOfCoverageLeft(bytes32 _protocol)\n    external\n    view\n    override\n    protocolExists(_protocol)\n    returns (uint256)\n  {\n    return _secondsOfCoverageLeft(_protocol);\n  }\n\n  // Helper function to return seconds of coverage left for a protocol\n  // Gets the current active balance of the protocol and divides by the premium per second for the protocol\n  function _secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {\n    uint256 premium = premiums[protocol];\n    if (premium == 0) return 0;\n    return _activeBalance(_protocol) / premium;\n  }\n\n  /// @notice View current active balance of covered protocol\n  /// @param _protocol Protocol identifier\n  /// @return Active balance\n  /// @dev Accrued debt is subtracted from the stored active balance\n  function activeBalance(bytes32 _protocol)\n    external\n    view\n    override\n    protocolExists(_protocol)\n    returns (uint256)\n  {\n    return _activeBalance(_protocol);\n  }\n\n  // Helper function to calc the active balance of a protocol at current time\n  function _activeBalance(bytes32 _protocol) internal view returns (uint256) {\n    uint256 debt = _calcIncrementalProtocolDebt(_protocol);\n    uint256 balance = activeBalances[_protocol];\n    // The debt should never be higher than the balance (only happens if the arbitrages fail)\n    if (debt &gt; balance) return 0;\n    return balance - debt;\n  }\n\n  //\n  // State methods\n  //\n\n  /// @notice Helps set the premium per second for an individual protocol\n  /// @param _protocol Protocol identifier\n  /// @param _premium New premium per second\n  /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function\n  function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)\n    internal\n    returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)\n  {\n    // _settleProtocolDebt() subtracts debt from the protocol\'s active balance and updates the % due to nonstakers\n    // Also updates the last accounted timestamp for this protocol\n    // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings\n    // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol\n    nonStakerPercentage = _settleProtocolDebt(_protocol);\n    // Stores the old premium before it gets updated\n    oldPremiumPerSecond = premiums[protocol];\n\n    if (oldPremiumPerSecond != _premium) {\n      // Sets the protocol\'s premium per second to the new value\n      premiums[protocol] = _premium;\n      emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium);\n    }\n    // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing\n    // We don\'t need to check the min balance requirement for arbs because that value doesn\'t change like secondsOfCoverageLeft changes\n    // Effectively we just need to make sure we don\'t accidentally run a protocol\'s active balance down below the point\n    // Where arbs would no longer be incentivized to remove the protocol\n    // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems\n    if (_premium != 0 &amp;&amp; _secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_OF_COVERAGE) {\n      revert InsufficientBalance(_protocol);\n    }\n  }\n\n  /// @notice Sets a single protocol\'s premium per second and also updates the global total of premiums per second\n  /// @param _protocol Protocol identifier\n  /// @param _premium New premium per second\n  function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {\n    // Sets the individual protocol\'s premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings\n    (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(\n      _protocol,\n      _premium\n    );\n    // Settling the total amount of premiums owed to stakers before a new premium per second gets set\n    _settleTotalDebt();\n    // This calculates the new global premium per second that gets paid to stakers\n    // We input the same nonStakerPercentage twice because we simply aren\'t updating that value in this function\n    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(\n      oldPremiumPerSecond,\n      _premium,\n      nonStakerPercentage,\n      nonStakerPercentage,\n      allPremiumsPerSecToStakers\n    );\n  }\n\n  // Internal function to set a new protocolAgent for a specific protocol\n  // _oldAgent is only included as part of emitting an event\n  function _setProtocolAgent(\n    bytes32 _protocol,\n    address _oldAgent,\n    address _protocolAgent\n  ) internal {\n    protocolAgent[protocol] = _protocolAgent;\n    emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);\n  }\n\n  // Subtracts the accrued debt from a protocol\'s active balance\n  // Credits the amount that can be claimed by nonstakers for this protocol\n  // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings\n  // Most of this function is dealing with an edge case related to a protocol not being removed by arbs\n  function _settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {\n    // This calcs the accrued debt of the protocol since it was last updated\n    uint256 debt = _calcIncrementalProtocolDebt(_protocol);\n    // This pulls the percentage that is sent to nonstakers\n    _nonStakerPercentage = nonStakersPercentage[_protocol];\n    // In case the protocol has accrued debt, this code block will ensure the debt is settled properly\n    if (debt != 0) {\n      // Pulls the stored active balance of the protocol\n      uint256 balance = activeBalances[_protocol];\n      // This is the start of handling an edge case where arbitragers don\'t remove this protocol before debt becomes greater than active balance\n      // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point\n      // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage\n      // However, if arbs don\'t come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up\n      if (debt &gt; balance) {\n        // This error amount represents the magnitude of the mistake\n        uint256 error = debt - balance;\n        // Gets the latest value of claimable premiums for stakers\n        _settleTotalDebt();\n        // @note to production, set premium first to zero before solving accounting issue.\n        // otherwise the accounting error keeps increasing\n        uint256 lastClaimablePremiumsForStakers = lastClaimablePremiumsForStakers;\n\n        // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%\n        uint256 claimablePremiumError = ((HUNDRED_PERCENT - nonStakerPercentage) * error) /\n          HUNDRED_PERCENT;\n\n        // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short\n        uint256 insufficientTokens;\n\n        // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally\n        // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error\n        // This first line can be true if claimPremiumsForStakers() has been called and\n        // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be &gt;0 still\n        if (claimablePremiumError &gt; lastClaimablePremiumsForStakers) {\n          insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;\n          lastClaimablePremiumsForStakers = 0;\n        } else {\n          // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums\n          // By the amount that was added in error (error) and insufficientTokens = 0\n          lastClaimablePremiumsForStakers =\n            lastClaimablePremiumsForStakers_ -\n            claimablePremiumError;\n        }\n\n        // If two events are thrown, the values need to be summed up for the actual state.\n        // This means an error of this type will continue until it is handled\n        emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);\n        // We set the debt equal to the balance, and in the next line we effectively set the protocol\'s active balance to 0 in this case\n        debt = balance;\n      }\n      // Subtracts the accrued debt (since last update) from the protocol\'s active balance and updates active balance\n      activeBalances[_protocol] = balance - debt;\n      // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol\n      nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT;\n    }\n    // Updates the last accounted timestamp for this protocol\n    lastAccountedEachProtocol[_protocol] = block.timestamp;\n  }\n\n  // Multiplies the total premium per second * number of seconds since the last global accounting update\n  // And adds it to the total claimable amount for stakers\n  function _settleTotalDebt() internal {\n    lastClaimablePremiumsForStakers +=\n      (block.timestamp - lastAccountedGlobal) \n      allPremiumsPerSecToStakers;\n    lastAccountedGlobal = block.timestamp;\n  }\n\n  // Calculates the global premium per second for stakers\n  // Takes a specific protocol\'s old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers\n  // Subtracts out the old values of a protocol\'s premium per second and nonstaker percentage and adds the new ones\n  function _calcGlobalPremiumPerSecForStakers(\n    uint256 _premiumOld,\n    uint256 _premiumNew,\n    uint256 _nonStakerPercentageOld,\n    uint256 _nonStakerPercentageNew,\n    uint256 _inMemAllPremiumsPerSecToStakers\n  ) internal pure returns (uint256) {\n    return\n      _inMemAllPremiumsPerSecToStakers +\n      ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /\n      HUNDRED_PERCENT -\n      ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /\n      HUNDRED_PERCENT;\n  }\n\n  // Helper function to remove and clean up a protocol from Sherlock\n  // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made\n  function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {\n    // Sets the individual protocol\'s premium to zero and updates the global premium variable for a zero premium at this protocol\n    _setSingleAndGlobalProtocolPremium(_protocol, 0);\n\n    // Grabs the protocol\'s active balance\n    uint256 balance = activeBalances[_protocol];\n\n    // If there\'s still some active balance, delete the entry and send the remaining balance to the protocol agent\n    if (balance != 0) {\n      delete activeBalances[_protocol];\n      token.safeTransfer(_agent, balance);\n\n      emit ProtocolBalanceWithdrawn(_protocol, balance);\n    }\n\n    // Sets the protocol agent to zero address (as part of clean up)\n    _setProtocolAgent(_protocol, _agent, address(0));\n\n    // Cleans up other mappings for this protocol\n    delete nonStakersPercentage[_protocol];\n    delete lastAccountedEachProtocol[_protocol];\n    // premiums_ mapping is not deleted here as it\'s already 0 because of the _setSingleAndGlobalProtocolPremium call above\n\n    // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol\n    removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;\n\n    // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed\n    // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked\n    removedProtocolAgent[_protocol] = _agent;\n\n    emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0));\n    emit ProtocolRemoved(_protocol);\n  }\n\n  /// @notice Sets the minimum active balance before an arb can remove a protocol\n  /// @param _minActiveBalance Minimum balance needed (in USDC)\n  /// @dev Only gov\n  function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {\n    // New value cannot be the same as current value\n    if (minActiveBalance == _minActiveBalance) revert InvalidArgument();\n    // Can\'t set a value that is too high to be reasonable\n    if (_minActiveBalance &gt;= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions();\n\n    emit MinBalance(minActiveBalance, _minActiveBalance);\n    minActiveBalance = _minActiveBalance;\n  }\n\n  // This function allows the nonstakers role to claim tokens owed to them by a specific protocol\n  /// @notice Choose an _amount of tokens that nonstakers (_receiver address) will receive from _protocol\n  /// @param _protocol Protocol identifier\n  /// @param _amount Amount of tokens\n  /// @param _receiver Address to receive tokens\n  /// @dev Only callable by nonstakers role\n  function nonStakersClaim(\n    bytes32 _protocol,\n    uint256 _amount,\n    address _receiver\n  ) external override whenNotPaused {\n    if (_protocol == bytes32(0)) revert ZeroArgument();\n    if (_amount == uint256(0)) revert ZeroArgument();\n    if (_receiver == address(0)) revert ZeroArgument();\n    // Only the nonstakers role (multisig or contract) can pull the funds\n    if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized();\n\n    // Call can\'t be executed on protocol that is removed\n    if (protocolAgent[protocol] != address(0)) {\n      // Updates the amount that nonstakers can claim from this protocol\n      _settleProtocolDebt(_protocol);\n    }\n\n    // Sets balance to the amount that is claimable by nonstakers for this specific protocol\n    uint256 balance = nonStakersClaimableByProtocol[_protocol];\n    // If the amount requested is more than what\'s owed to nonstakers, revert\n    if (_amount &gt; balance) revert InsufficientBalance(_protocol);\n\n    // Sets the claimable amount to whatever is left over after this amount is pulled\n    nonStakersClaimableByProtocol[_protocol] = balance - _amount;\n    // Transfers the amount requested to the _receiver address\n    token.safeTransfer(_receiver, _amount);\n  }\n\n  // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)\n  /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address\n  /// @dev Callable by everyone\n  /// @dev Funds will be transferred to Sherlock core contract\n  function claimPremiumsForStakers() external override whenNotPaused {\n    // Gets address of core Sherlock contract\n    address sherlock = address(sherlockCore);\n    // Revert if core Sherlock contract not initialized yet\n    if (sherlock == address(0)) revert InvalidConditions();\n\n    // claimablePremiums is different from _settleTotalDebt() because it does not change state\n    // Retrieves current amount of all premiums that are owed to stakers\n    uint256 amount = claimablePremiums();\n\n    // Transfers all the premiums owed to stakers to the Sherlock core contract\n    if (amount != 0) {\n      // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out\n      lastClaimablePremiumsForStakers = 0;\n      lastAccountedGlobal = block.timestamp;\n      token.safeTransfer(sherlock, amount);\n    }\n  }\n\n  // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts\n  /// @param _protocol Protocol identifier\n  /// @return current and previous are the current and previous coverage amounts for this protocol\n  // Note For this process to work, a protocol\'s coverage amount should not be set more than once in the span of claim delay period (7 days or something)\n  function coverageAmounts(bytes32 _protocol)\n    external\n    view\n    override\n    returns (uint256 current, uint256 previous)\n  {\n    // Checks to see if the protocol has an active protocolAgent (protocol not removed)\n    // OR checks to see if the removed protocol is still within the claim window\n    // If so, gives the current and previous coverage, otherwise throws an error\n    if (\n      protocolAgent[protocol] != address(0) ||\n      block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]\n    ) {\n      return (currentCoverage[_protocol], previousCoverage[_protocol]);\n    }\n\n    revert ProtocolNotExists(_protocol);\n  }\n\n  /// @notice Add a new protocol to Sherlock\n  /// @param _protocol Protocol identifier\n  /// @param _protocolAgent Address able to submit a claim on behalf of the protocol\n  /// @param _coverage Hash referencing the active coverage agreement\n  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 1018\n  /// @param _coverageAmount Max amount claimable by this protocol\n  /// @dev Adding a protocol allows the _protocolAgent to submit a claim\n  /// @dev Coverage is not started yet as the protocol doesn\'t pay a premium at this point\n  /// @dev _nonStakers is scaled by 1018\n  /// @dev Only callable by governance\n  function protocolAdd(\n    bytes32 _protocol,\n    address _protocolAgent,\n    bytes32 _coverage,\n    uint256 _nonStakers,\n    uint256 _coverageAmount\n  ) external override onlyOwner {\n    if (_protocol == bytes32(0)) revert ZeroArgument();\n    if (_protocolAgent == address(0)) revert ZeroArgument();\n    // Checks to make sure the protocol doesn\'t exist already\n    if (protocolAgent[protocol] != address(0)) revert InvalidConditions();\n\n    // Updates the protocol agent and passes in the old agent which is 0 address in this case\n    _setProtocolAgent(_protocol, address(0), _protocolAgent);\n\n    // Delete mappings that are potentially non default values\n    // From previous time protocol was added/removed\n    delete removedProtocolClaimDeadline[_protocol];\n    delete removedProtocolAgent[_protocol];\n    delete currentCoverage[_protocol];\n    delete previousCoverage[_protocol];\n\n    emit ProtocolAdded(_protocol);\n\n    // Most of the logic for actually adding a protocol in this function\n    protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);\n  }\n\n  /// @notice Update info regarding a protocol\n  /// @param _protocol Protocol identifier\n  /// @param _coverage Hash referencing the active coverage agreement\n  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18\n  /// @param _coverageAmount Max amount claimable by this protocol\n  /// @dev Only callable by governance\n  /// @dev _nonStakers can be 0\n  function protocolUpdate(\n    bytes32 _protocol,\n    bytes32 _coverage,\n    uint256 _nonStakers,\n    uint256 _coverageAmount\n  ) public override onlyOwner {\n    if (_coverage == bytes32(0)) revert ZeroArgument();\n    if (_nonStakers &gt; HUNDRED_PERCENT) revert InvalidArgument();\n    if (_coverageAmount == uint256(0)) revert ZeroArgument();\n\n    // Checks to make sure the protocol has been assigned a protocol agent\n    _verifyProtocolExists(_protocol);\n\n    // Subtracts the accrued debt from a protocol\'s active balance (if any)\n    // Updates the amount that can be claimed by nonstakers\n    _settleProtocolDebt(_protocol);\n\n    // Updates the global claimable amount for stakers\n    _settleTotalDebt();\n\n    // Gets the premium per second for this protocol\n    uint256 premium = premiums[protocol];\n\n    // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be)\n    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(\n      premium,\n      premium,\n      nonStakersPercentage[_protocol],\n      _nonStakers,\n      allPremiumsPerSecToStakers\n    );\n\n    // Updates the stored value of percentage of premiums that go to nonstakers\n    nonStakersPercentage[_protocol] = _nonStakers;\n\n    // Updates previous coverage and current coverage amounts\n    previousCoverage[_protocol] = currentCoverage[_protocol];\n    currentCoverage[_protocol] = _coverageAmount;\n\n    emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);\n  }\n\n  /// @notice Remove a protocol from coverage\n  /// @param _protocol Protocol identifier\n  /// @dev Before removing a protocol the premium must be 0\n  /// @dev Removing a protocol basically stops the _protocolAgent from being active (can still submit claims until claim deadline though)\n  /// @dev Pays off debt + sends remaining balance to protocol agent\n  /// @dev This call should be subject to a timelock\n  /// @dev Only callable by governance\n  function protocolRemove(bytes32 _protocol) external override onlyOwner {\n    // checks to make sure the protocol actually has a protocol agent\n    address agent = _verifyProtocolExists(_protocol);\n\n    // Removes a protocol from Sherlock and cleans up its data\n    // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made\n    _forceRemoveProtocol(_protocol, agent);\n  }\n\n  /// @notice Remove a protocol with insufficient active balance\n  /// @param _protocol Protocol identifier\n  // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function\n  function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {\n    address agent = _verifyProtocolExists(_protocol);\n\n    // Gets the latest value of the active balance at this protocol\n    _settleProtocolDebt(_protocol);\n    // Sets latest value of active balance to remainingBalance variable\n    uint256 remainingBalance = activeBalances[_protocol];\n\n    // This means the protocol still has adequate active balance and thus cannot be removed\n    if (remainingBalance &gt;= minActiveBalance) revert InvalidConditions();\n\n    // Sets the protocol\'s active balance to 0\n    delete activeBalances[_protocol];\n    // Removes the protocol from coverage\n    _forceRemoveProtocol(_protocol, agent);\n\n    if (remainingBalance != 0) {\n      // sends the remaining balance to msg.sender\n      token.safeTransfer(msg.sender, remainingBalance);\n    }\n    emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);\n  }\n\n  /// @notice Calculate if arb is possible and what the reward would be\n  /// @param _protocol Protocol identifier\n  /// @return arbAmount Amount reward for arbing\n  /// @return able Indicator if arb call is even possible\n  /// @dev Doesn\'t subtract the current protocol debt from the active balance\n  function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)\n    internal\n    view\n    returns (uint256 arbAmount, bool able)\n  {\n    uint256 secondsLeft = _secondsOfCoverageLeft(_protocol);\n\n    // If arb is not possible return false\n    if (secondsLeft &gt;= MIN_SECONDS_OF_COVERAGE) return (0, false);\n\n    // This percentage scales over time\n    // Reaches 100% on 0 seconds of coverage left\n    uint256 percentageScaled = HUNDRED_PERCENT -\n      (secondsLeft * HUNDRED_PERCENT) /\n      MIN_SECONDS_OF_COVERAGE;\n\n    able = true;\n    arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;\n  }\n\n  /// @notice Removes a protocol with insufficent seconds of coverage left\n  /// @param _protocol Protocol identifier\n  // Seconds of coverage is defined by the active balance of the protocol divided by the protocol\'s premium per second\n  function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {\n    // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings\n    address agent = _verifyProtocolExists(_protocol);\n\n    // NOTE: We don\'t give the arb the full remaining balance like we do in forceRemoveByActiveBalance()\n    // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance()\n    // But when removing based on seconds of coverage left, the remainingBalance could still be quite large\n    // So it\'s better to scale the arb reward over time. It\'s a little complex because the remainingBalance\n    // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%)\n    _settleProtocolDebt(_protocol);\n    (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol);\n    if (able == false) revert InvalidConditions();\n\n    if (arbAmount != 0) {\n      // subtracts the amount that will be paid to the arb from the active balance\n      activeBalances[_protocol] -= arbAmount;\n    }\n\n    // Removes the protocol from coverage\n    // This function also pays the active balance to the protocol agent, so it\'s good we do this after subtracting arb amount above\n    _forceRemoveProtocol(_protocol, agent);\n\n    // Done after removing protocol to mitigate reentrency pattern\n    // (In case token allows callback)\n    if (arbAmount != 0) {\n      token.safeTransfer(msg.sender, arbAmount);\n    }\n    emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);\n  }\n\n  /// @notice Set premium of _protocol to _premium\n  /// @param _protocol Protocol identifier\n  /// @param _premium Amount of premium _protocol pays per second\n  /// @dev The value 0 would mean inactive coverage\n  /// @dev Only callable by governance\n  function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {\n    // Checks to see if protocol has a protocol agent\n    _verifyProtocolExists(_protocol);\n\n    // Updates individual protocol\'s premium and allPremiumsPerSecToStakers\n    _setSingleAndGlobalProtocolPremium(_protocol, _premium);\n  }\n\n  /// @notice Set premium of multiple protocols\n  /// @param _protocol Array of protocol identifiers\n  /// @param _premium Array of premium amounts protocols pay per second\n  /// @dev The value 0 would mean inactive coverage\n  /// @dev Only callable by governance\n  function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)\n    external\n    override\n    onlyOwner\n  {\n    // Checks to make sure there are an equal amount of entries in each array\n    if (_protocol.length != _premium.length) revert UnequalArrayLength();\n    if (_protocol.length == 0) revert InvalidArgument();\n\n    // Updates the global claimable amount for stakers\n    _settleTotalDebt();\n\n    uint256 allPremiumsPerSecToStakers = allPremiumsPerSecToStakers;\n\n    // Loops through the array of protocols and checks to make sure each has a protocol agent assigned\n    for (uint256 i; i &lt; protocol.length; i++) {\n      _verifyProtocolExists(_protocol[i]);\n\n      // Sets the protocol premium for that specific protocol\n      // Function returns the old premium and nonStakerPercentage for that specific protocol\n      (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(\n        _protocol[i],\n        _premium[i]\n      );\n\n      // Calculates the new global premium which adds up all premiums paid by all protocols\n      allPremiumsPerSecToStakers = calcGlobalPremiumPerSecForStakers(\n        oldPremiumPerSecond,\n        _premium[i],\n        nonStakerPercentage,\n        nonStakerPercentage,\n        allPremiumsPerSecToStakers\n      );\n    }\n\n    // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value\n    allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;\n  }\n\n  // This is how protocols pay for coverage by increasing their active balance\n  /// @notice Deposits _amount of token to the active balance of _protocol\n  /// @param _protocol Protocol identifier\n  /// @param _amount Amount of tokens to deposit\n  /// @dev Approval should be made before calling\n  function depositToActiveBalance(bytes32 _protocol, uint256 _amount)\n    external\n    override\n    whenNotPaused\n  {\n    if (_amount == uint256(0)) revert ZeroArgument();\n    _verifyProtocolExists(_protocol);\n\n    // Transfers _amount to this contract\n    token.safeTransferFrom(msg.sender, address(this), _amount);\n    // Increases the active balance of the protocol by _amount\n    activeBalances[_protocol] += _amount;\n\n    emit ProtocolBalanceDeposited(_protocol, _amount);\n  }\n\n  // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)\n  // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)\n  /// @notice Withdraws _amount of token from the active balance of _protocol\n  /// @param _protocol Protocol identifier\n  /// @param _amount Amount of tokens to withdraw\n  /// @dev Only protocol agent is able to withdraw\n  /// @dev Balance can be withdrawn up until 7 days worth of active balance\n  function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)\n    external\n    override\n    whenNotPaused\n  {\n    if (_amount == uint256(0)) revert ZeroArgument();\n    // Only the protocol agent can call this function\n    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();\n\n    // Updates the active balance of the protocol\n    _settleProtocolDebt(_protocol);\n\n    // Sets currentBalance to the active balance of the protocol\n    uint256 currentBalance = activeBalances[_protocol];\n    // Reverts if trying to withdraw more than the active balance\n    if (_amount &gt; currentBalance) revert InsufficientBalance(_protocol);\n\n    // Removes the _amount to be withdrawn from the active balance\n    activeBalances[_protocol] = currentBalance - _amount;\n    // Reverts if a protocol has less than 7 days worth of active balance left\n    if (_secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);\n\n    // Transfers the amount to the msg.sender (protocol agent)\n    token.safeTransfer(msg.sender, _amount);\n    emit ProtocolBalanceWithdrawn(_protocol, _amount);\n  }\n\n  /// @notice Transfer protocol agent role\n  /// @param _protocol Protocol identifier\n  /// @param _protocolAgent Account able to submit a claim on behalf of the protocol\n  /// @dev Only the active protocolAgent is able to transfer the role\n  function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)\n    external\n    override\n    whenNotPaused\n  {\n    if (_protocolAgent == address(0)) revert ZeroArgument();\n    // Can\'t set the new protocol agent to the caller address\n    if (msg.sender == _protocolAgent) revert InvalidArgument();\n    // Because the caller must be the current protocol agent\n    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();\n\n    // Sets the protocol agent to the new address\n    _setProtocolAgent(_protocol, msg.sender, _protocolAgent);\n  }\n\n  /// @notice Function used to check if this is the current active protocol manager\n  /// @return Boolean indicating it\'s active\n  /// @dev If inactive the owner can pull all ERC20s and ETH\n  /// @dev Will be checked by calling the sherlock contract\n  function isActive() public view returns (bool) {\n    return address(sherlockCore.sherlockProtocolManager()) == address(this);\n  }\n\n  // Only contract owner can call this\n  // Sends all specified tokens in this contract to the receiver\'s address (as well as ETH)\n  function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {\n    if (_receiver == address(0)) revert ZeroArgument();\n    // This contract must NOT be the current assigned protocol manager contract\n    if (isActive()) revert InvalidConditions();\n    // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH\n    _sweep(_receiver, _extraTokens);\n  }\n}\n'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-25-08 10:58:50 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import './Manager.sol'; import '../interfaces/managers/ISherlockProtocolManager.sol'; /// @title Sherlock core interface for protocols /// @author Evert Kors // This is the contract that manages covered protocols contract SherlockProtocolManager is ISherlockProtocolManager, Manager {   using SafeERC20 for IERC20; // Represents the token that protocols pay with (currently USDC)   IERC20 public immutable token; // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed   uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc // A removed protocol is still able to make a claim for this amount of time after its removal   uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days; // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance   uint256 public constant MIN_SECONDS_LEFT = 7 days; // Convenient for percentage calculations   uint256 internal constant HUNDRED_PERCENT = 10**18; // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage   // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying   uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours; // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)   mapping(bytes32 =&gt; address) internal protocolAgent_; // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)   mapping(bytes32 =&gt; uint256) internal nonStakersPercentage; // The premium per second paid by each protocol is stored in this mapping   mapping(bytes32 =&gt; uint256) internal premiums_; // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.   // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not   mapping(bytes32 =&gt; uint256) internal activeBalances; // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol   mapping(bytes32 =&gt; uint256) internal lastAccountedEachProtocol; // The amount that can be claimed by nonstakers for each protocol   // We need this value so we can track how much payment is coming from each protocol   mapping(bytes32 =&gt; uint256) internal nonStakersClaimableByProtocol; // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)   uint256 internal lastAccountedGlobal; // This is the total amount of premiums paid (per second) by all the covered protocols (added up)   uint256 internal allPremiumsPerSecToStakers; // This is the amount that was claimable by stakers the last time the accounting was run   // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date   uint256 internal lastClaimablePremiumsForStakers; // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage   // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)   uint256 public override minActiveBalance; // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)   mapping(bytes32 =&gt; uint256) internal removedProtocolClaimDeadline; // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)   mapping(bytes32 =&gt; address) internal removedProtocolAgent; // Current amount of coverage (i.e. 20M USDC) for a protocol   mapping(bytes32 =&gt; uint256) internal currentCoverage; // Previous amount of coverage for a protocol   // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount   mapping(bytes32 =&gt; uint256) internal previousCoverage; // Setting the token to USDC   constructor(IERC20 _token) {     if (address(_token) == address(0)) revert ZeroArgument();     token = _token;   } // Modifier used to ensure a protocol exists (has been instantiated and not removed)   modifier protocolExists(bytes32 protocol) {     _verifyProtocolExists(_protocol);     ;   } /// @notice View current protocolAgent of _protocol   /// @param protocol Protocol identifier   /// @return Address able to submit claims   function protocolAgent(bytes32 _protocol) external view override returns (address) {     address agent = protocolAgent[_protocol];     if (agent != address(0)) return agent; // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned // Note: Old protocol agent will never be address(0) if (block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]) {   return removedProtocolAgent[_protocol]; }  // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned revert ProtocolNotExists(_protocol);  } // Checks if the protocol exists, then returns the current premium per second being charged   /// @notice View current premium of protocol   /// @param protocol Protocol identifier   /// @return Amount of premium _protocol pays per second   function premium(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return premiums[_protocol];   } // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)   // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)   function verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {     _protocolAgent = protocolAgent[_protocol];     if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);   } //   // View methods   // // Calcs the debt accrued by the protocol since it last had an accounting update   // This is the amount that needs to be removed from a protocol's active balance   function calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {     return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums[_protocol];   } /// @notice View the amount nonstakers can claim from this protocol   /// @param _protocol Protocol identifier   /// @return Amount of tokens claimable by nonstakers   /// @dev this reads from a storage variable + (now-lastsettled) * premiums   // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]   // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed   function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {     // Calcs the debt of a protocol since the last accounting update     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     // Gets the active balance of the protocol     uint256 balance = activeBalances[_protocol];     // The debt should never be higher than the balance (only happens if the arbitrages fail)     if (debt &gt; balance) debt = balance; // Adds the incremental claimable amount owed to nonstakers to the total claimable amount return   nonStakersClaimableByProtocol[_protocol] +   (nonStakersPercentage[_protocol] * debt) /   HUNDRED_PERCENT;  } /// @notice View current amount of all premiums that are owed to stakers   /// @return Premiums claimable   /// @dev Will increase every block   /// @dev base + (now - last_settled) * ps   function claimablePremiums() public view override returns (uint256) {     // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)     return       lastClaimablePremiumsForStakers +       (block.timestamp - lastAccountedGlobal) *       allPremiumsPerSecToStakers;   } /// @notice View seconds of coverage left for _protocol before it runs out of active balance   /// @param _protocol Protocol identifier   /// @return Seconds of coverage left   function secondsOfCoverageLeft(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return _secondsOfCoverageLeft(_protocol);   } // Helper function to return seconds of coverage left for a protocol   // Gets the current active balance of the protocol and divides by the premium per second for the protocol   function secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {     uint256 premium = premiums[_protocol];     if (premium == 0) return 0;     return _activeBalance(_protocol) / premium;   } /// @notice View current active balance of covered protocol   /// @param _protocol Protocol identifier   /// @return Active balance   /// @dev Accrued debt is subtracted from the stored active balance   function activeBalance(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return _activeBalance(_protocol);   } // Helper function to calc the active balance of a protocol at current time   function _activeBalance(bytes32 _protocol) internal view returns (uint256) {     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     uint256 balance = activeBalances[_protocol];     // The debt should never be higher than the balance (only happens if the arbitrages fail)     if (debt &gt; balance) return 0;     return balance - debt;   } //   // State methods   // /// @notice Helps set the premium per second for an individual protocol   /// @param protocol Protocol identifier   /// @param _premium New premium per second   /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function   function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)     internal     returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)   {     // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers     // Also updates the last accounted timestamp for this protocol     // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings     // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol     nonStakerPercentage = _settleProtocolDebt(_protocol);     // Stores the old premium before it gets updated     oldPremiumPerSecond = premiums[_protocol]; if (oldPremiumPerSecond != _premium) {   // Sets the protocol's premium per second to the new value   premiums_[_protocol] = _premium;   emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium); } // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point // Where arbs would no longer be incentivized to remove the protocol // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems if (_premium != 0 &amp;&amp; _secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_OF_COVERAGE) {   revert InsufficientBalance(_protocol); }  } /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second   /// @param _protocol Protocol identifier   /// @param _premium New premium per second   function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {     // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings     (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(       _protocol,       _premium     );     // Settling the total amount of premiums owed to stakers before a new premium per second gets set     _settleTotalDebt();     // This calculates the new global premium per second that gets paid to stakers     // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function     allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(       oldPremiumPerSecond,       _premium,       nonStakerPercentage,       nonStakerPercentage,       allPremiumsPerSecToStakers     );   } // Internal function to set a new protocolAgent for a specific protocol   // oldAgent is only included as part of emitting an event   function _setProtocolAgent(     bytes32 _protocol,     address _oldAgent,     address _protocolAgent   ) internal {     protocolAgent[_protocol] = _protocolAgent;     emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);   } // Subtracts the accrued debt from a protocol's active balance   // Credits the amount that can be claimed by nonstakers for this protocol   // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings   // Most of this function is dealing with an edge case related to a protocol not being removed by arbs   function settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {     // This calcs the accrued debt of the protocol since it was last updated     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     // This pulls the percentage that is sent to nonstakers     _nonStakerPercentage = nonStakersPercentage[_protocol];     // In case the protocol has accrued debt, this code block will ensure the debt is settled properly     if (debt != 0) {       // Pulls the stored active balance of the protocol       uint256 balance = activeBalances[_protocol];       // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance       // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point       // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage       // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up       if (debt &gt; balance) {         // This error amount represents the magnitude of the mistake         uint256 error = debt - balance;         // Gets the latest value of claimable premiums for stakers         _settleTotalDebt();         // @note to production, set premium first to zero before solving accounting issue.         // otherwise the accounting error keeps increasing         uint256 lastClaimablePremiumsForStakers = lastClaimablePremiumsForStakers;     // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%     uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /       HUNDRED_PERCENT;      // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short     uint256 insufficientTokens;      // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally     // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error     // This first line can be true if claimPremiumsForStakers() has been called and     // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be &gt;0 still     if (claimablePremiumError &gt; lastClaimablePremiumsForStakers_) {       insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;       lastClaimablePremiumsForStakers = 0;     } else {       // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums       // By the amount that was added in error (error) and insufficientTokens = 0       lastClaimablePremiumsForStakers =         lastClaimablePremiumsForStakers_ -         claimablePremiumError;     }      // If two events are thrown, the values need to be summed up for the actual state.     // This means an error of this type will continue until it is handled     emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);     // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case     debt = balance;   }   // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance   activeBalances[_protocol] = balance - debt;   // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol   nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT; } // Updates the last accounted timestamp for this protocol lastAccountedEachProtocol[_protocol] = block.timestamp;  } // Multiplies the total premium per second * number of seconds since the last global accounting update   // And adds it to the total claimable amount for stakers   function _settleTotalDebt() internal {     lastClaimablePremiumsForStakers +=       (block.timestamp - lastAccountedGlobal) *       allPremiumsPerSecToStakers;     lastAccountedGlobal = block.timestamp;   } // Calculates the global premium per second for stakers   // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers   // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones   function _calcGlobalPremiumPerSecForStakers(     uint256 _premiumOld,     uint256 _premiumNew,     uint256 _nonStakerPercentageOld,     uint256 _nonStakerPercentageNew,     uint256 _inMemAllPremiumsPerSecToStakers   ) internal pure returns (uint256) {     return       _inMemAllPremiumsPerSecToStakers +       ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /       HUNDRED_PERCENT -       ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /       HUNDRED_PERCENT;   } // Helper function to remove and clean up a protocol from Sherlock   // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made   function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {     // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol     _setSingleAndGlobalProtocolPremium(_protocol, 0); // Grabs the protocol's active balance uint256 balance = activeBalances[_protocol];  // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent if (balance != 0) {   delete activeBalances[_protocol];   token.safeTransfer(_agent, balance);    emit ProtocolBalanceWithdrawn(_protocol, balance); }  // Sets the protocol agent to zero address (as part of clean up) _setProtocolAgent(_protocol, _agent, address(0));  // Cleans up other mappings for this protocol delete nonStakersPercentage[_protocol]; delete lastAccountedEachProtocol[_protocol]; // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above  // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;  // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked removedProtocolAgent[_protocol] = _agent;  emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0)); emit ProtocolRemoved(_protocol);  } /// @notice Sets the minimum active balance before an arb can remove a protocol   /// @param _minActiveBalance Minimum balance needed (in USDC)   /// @dev Only gov   function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {     // New value cannot be the same as current value     if (minActiveBalance == _minActiveBalance) revert InvalidArgument();     // Can't set a value that is too high to be reasonable     if (_minActiveBalance &gt;= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions(); emit MinBalance(minActiveBalance, _minActiveBalance); minActiveBalance = _minActiveBalance;  } // This function allows the nonstakers role to claim tokens owed to them by a specific protocol   /// @notice Choose an _amount of tokens that nonstakers (_receiver address) will receive from _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens   /// @param _receiver Address to receive tokens   /// @dev Only callable by nonstakers role   function nonStakersClaim(     bytes32 _protocol,     uint256 _amount,     address _receiver   ) external override whenNotPaused {     if (_protocol == bytes32(0)) revert ZeroArgument();     if (_amount == uint256(0)) revert ZeroArgument();     if (_receiver == address(0)) revert ZeroArgument();     // Only the nonstakers role (multisig or contract) can pull the funds     if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized(); // Call can't be executed on protocol that is removed if (protocolAgent_[_protocol] != address(0)) {   // Updates the amount that nonstakers can claim from this protocol   _settleProtocolDebt(_protocol); }  // Sets balance to the amount that is claimable by nonstakers for this specific protocol uint256 balance = nonStakersClaimableByProtocol[_protocol]; // If the amount requested is more than what's owed to nonstakers, revert if (_amount &gt; balance) revert InsufficientBalance(_protocol);  // Sets the claimable amount to whatever is left over after this amount is pulled nonStakersClaimableByProtocol[_protocol] = balance - _amount; // Transfers the amount requested to the `_receiver` address token.safeTransfer(_receiver, _amount);  } // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)   /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address   /// @dev Callable by everyone   /// @dev Funds will be transferred to Sherlock core contract   function claimPremiumsForStakers() external override whenNotPaused {     // Gets address of core Sherlock contract     address sherlock = address(sherlockCore);     // Revert if core Sherlock contract not initialized yet     if (sherlock == address(0)) revert InvalidConditions(); // claimablePremiums is different from _settleTotalDebt() because it does not change state // Retrieves current amount of all premiums that are owed to stakers uint256 amount = claimablePremiums();  // Transfers all the premiums owed to stakers to the Sherlock core contract if (amount != 0) {   // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out   lastClaimablePremiumsForStakers = 0;   lastAccountedGlobal = block.timestamp;   token.safeTransfer(sherlock, amount); }  } // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts   /// @param protocol Protocol identifier   /// @return current and previous are the current and previous coverage amounts for this protocol   // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)   function coverageAmounts(bytes32 _protocol)     external     view     override     returns (uint256 current, uint256 previous)   {     // Checks to see if the protocol has an active protocolAgent (protocol not removed)     // OR checks to see if the removed protocol is still within the claim window     // If so, gives the current and previous coverage, otherwise throws an error     if (       protocolAgent[_protocol] != address(0) ||       block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]     ) {       return (currentCoverage[_protocol], previousCoverage[_protocol]);     } revert ProtocolNotExists(_protocol);  } /// @notice Add a new protocol to Sherlock   /// @param protocol Protocol identifier   /// @param _protocolAgent Address able to submit a claim on behalf of the protocol   /// @param _coverage Hash referencing the active coverage agreement   /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 1018   /// @param _coverageAmount Max amount claimable by this protocol   /// @dev Adding a protocol allows the _protocolAgent to submit a claim   /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point   /// @dev _nonStakers is scaled by 1018   /// @dev Only callable by governance   function protocolAdd(     bytes32 _protocol,     address _protocolAgent,     bytes32 _coverage,     uint256 _nonStakers,     uint256 _coverageAmount   ) external override onlyOwner {     if (_protocol == bytes32(0)) revert ZeroArgument();     if (_protocolAgent == address(0)) revert ZeroArgument();     // Checks to make sure the protocol doesn't exist already     if (protocolAgent[_protocol] != address(0)) revert InvalidConditions(); // Updates the protocol agent and passes in the old agent which is 0 address in this case _setProtocolAgent(_protocol, address(0), _protocolAgent);  // Delete mappings that are potentially non default values // From previous time protocol was added/removed delete removedProtocolClaimDeadline[_protocol]; delete removedProtocolAgent[_protocol]; delete currentCoverage[_protocol]; delete previousCoverage[_protocol];  emit ProtocolAdded(_protocol);  // Most of the logic for actually adding a protocol in this function protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);  } /// @notice Update info regarding a protocol   /// @param _protocol Protocol identifier   /// @param _coverage Hash referencing the active coverage agreement   /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18   /// @param _coverageAmount Max amount claimable by this protocol   /// @dev Only callable by governance   /// @dev _nonStakers can be 0   function protocolUpdate(     bytes32 _protocol,     bytes32 _coverage,     uint256 _nonStakers,     uint256 _coverageAmount   ) public override onlyOwner {     if (_coverage == bytes32(0)) revert ZeroArgument();     if (_nonStakers &gt; HUNDRED_PERCENT) revert InvalidArgument();     if (_coverageAmount == uint256(0)) revert ZeroArgument(); // Checks to make sure the protocol has been assigned a protocol agent _verifyProtocolExists(_protocol);  // Subtracts the accrued debt from a protocol's active balance (if any) // Updates the amount that can be claimed by nonstakers _settleProtocolDebt(_protocol);  // Updates the global claimable amount for stakers _settleTotalDebt();  // Gets the premium per second for this protocol uint256 premium = premiums_[_protocol];  // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be) allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(   premium,   premium,   nonStakersPercentage[_protocol],   _nonStakers,   allPremiumsPerSecToStakers );  // Updates the stored value of percentage of premiums that go to nonstakers nonStakersPercentage[_protocol] = _nonStakers;  // Updates previous coverage and current coverage amounts previousCoverage[_protocol] = currentCoverage[_protocol]; currentCoverage[_protocol] = _coverageAmount;  emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);  } /// @notice Remove a protocol from coverage   /// @param _protocol Protocol identifier   /// @dev Before removing a protocol the premium must be 0   /// @dev Removing a protocol basically stops the _protocolAgent from being active (can still submit claims until claim deadline though)   /// @dev Pays off debt + sends remaining balance to protocol agent   /// @dev This call should be subject to a timelock   /// @dev Only callable by governance   function protocolRemove(bytes32 _protocol) external override onlyOwner {     // checks to make sure the protocol actually has a protocol agent     address agent = _verifyProtocolExists(_protocol); // Removes a protocol from Sherlock and cleans up its data // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made _forceRemoveProtocol(_protocol, agent);  } /// @notice Remove a protocol with insufficient active balance   /// @param _protocol Protocol identifier   // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function   function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {     address agent = _verifyProtocolExists(_protocol); // Gets the latest value of the active balance at this protocol _settleProtocolDebt(_protocol); // Sets latest value of active balance to remainingBalance variable uint256 remainingBalance = activeBalances[_protocol];  // This means the protocol still has adequate active balance and thus cannot be removed if (remainingBalance &gt;= minActiveBalance) revert InvalidConditions();  // Sets the protocol's active balance to 0 delete activeBalances[_protocol]; // Removes the protocol from coverage _forceRemoveProtocol(_protocol, agent);  if (remainingBalance != 0) {   // sends the remaining balance to msg.sender   token.safeTransfer(msg.sender, remainingBalance); } emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);  } /// @notice Calculate if arb is possible and what the reward would be   /// @param _protocol Protocol identifier   /// @return arbAmount Amount reward for arbing   /// @return able Indicator if arb call is even possible   /// @dev Doesn't subtract the current protocol debt from the active balance   function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)     internal     view     returns (uint256 arbAmount, bool able)   {     uint256 secondsLeft = _secondsOfCoverageLeft(_protocol); // If arb is not possible return false if (secondsLeft &gt;= MIN_SECONDS_OF_COVERAGE) return (0, false);  // This percentage scales over time // Reaches 100% on 0 seconds of coverage left uint256 percentageScaled = HUNDRED_PERCENT -   (secondsLeft * HUNDRED_PERCENT) /   MIN_SECONDS_OF_COVERAGE;  able = true; arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;  } /// @notice Removes a protocol with insufficent seconds of coverage left   /// @param _protocol Protocol identifier   // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second   function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {     // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings     address agent = _verifyProtocolExists(_protocol); // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance() // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance() // But when removing based on seconds of coverage left, the remainingBalance could still be quite large // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%) _settleProtocolDebt(_protocol); (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol); if (able == false) revert InvalidConditions();  if (arbAmount != 0) {   // subtracts the amount that will be paid to the arb from the active balance   activeBalances[_protocol] -= arbAmount; }  // Removes the protocol from coverage // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above _forceRemoveProtocol(_protocol, agent);  // Done after removing protocol to mitigate reentrency pattern // (In case token allows callback) if (arbAmount != 0) {   token.safeTransfer(msg.sender, arbAmount); } emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);  } /// @notice Set premium of _protocol to _premium   /// @param _protocol Protocol identifier   /// @param _premium Amount of premium _protocol pays per second   /// @dev The value 0 would mean inactive coverage   /// @dev Only callable by governance   function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {     // Checks to see if protocol has a protocol agent     _verifyProtocolExists(_protocol); // Updates individual protocol's premium and allPremiumsPerSecToStakers _setSingleAndGlobalProtocolPremium(_protocol, _premium);  } /// @notice Set premium of multiple protocols   /// @param _protocol Array of protocol identifiers   /// @param _premium Array of premium amounts protocols pay per second   /// @dev The value 0 would mean inactive coverage   /// @dev Only callable by governance   function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)     external     override     onlyOwner   {     // Checks to make sure there are an equal amount of entries in each array     if (_protocol.length != _premium.length) revert UnequalArrayLength();     if (_protocol.length == 0) revert InvalidArgument(); // Updates the global claimable amount for stakers _settleTotalDebt();  uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;  // Loops through the array of protocols and checks to make sure each has a protocol agent assigned for (uint256 i; i &lt; _protocol.length; i++) {   _verifyProtocolExists(_protocol[i]);    // Sets the protocol premium for that specific protocol   // Function returns the old premium and nonStakerPercentage for that specific protocol   (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(     _protocol[i],     _premium[i]   );    // Calculates the new global premium which adds up all premiums paid by all protocols   allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(     oldPremiumPerSecond,     _premium[i],     nonStakerPercentage,     nonStakerPercentage,     allPremiumsPerSecToStakers_   ); }  // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;  } // This is how protocols pay for coverage by increasing their active balance   /// @notice Deposits _amount of token to the active balance of _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens to deposit   /// @dev Approval should be made before calling   function depositToActiveBalance(bytes32 _protocol, uint256 _amount)     external     override     whenNotPaused   {     if (_amount == uint256(0)) revert ZeroArgument();     _verifyProtocolExists(_protocol); // Transfers _amount to this contract token.safeTransferFrom(msg.sender, address(this), _amount); // Increases the active balance of the protocol by _amount activeBalances[_protocol] += _amount;  emit ProtocolBalanceDeposited(_protocol, _amount);  } // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)   // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)   /// @notice Withdraws _amount of token from the active balance of _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens to withdraw   /// @dev Only protocol agent is able to withdraw   /// @dev Balance can be withdrawn up until 7 days worth of active balance   function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)     external     override     whenNotPaused   {     if (_amount == uint256(0)) revert ZeroArgument();     // Only the protocol agent can call this function     if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized(); // Updates the active balance of the protocol _settleProtocolDebt(_protocol);  // Sets currentBalance to the active balance of the protocol uint256 currentBalance = activeBalances[_protocol]; // Reverts if trying to withdraw more than the active balance if (_amount &gt; currentBalance) revert InsufficientBalance(_protocol);  // Removes the _amount to be withdrawn from the active balance activeBalances[_protocol] = currentBalance - _amount; // Reverts if a protocol has less than 7 days worth of active balance left if (_secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);  // Transfers the amount to the msg.sender (protocol agent) token.safeTransfer(msg.sender, _amount); emit ProtocolBalanceWithdrawn(_protocol, _amount);  } /// @notice Transfer protocol agent role   /// @param _protocol Protocol identifier   /// @param _protocolAgent Account able to submit a claim on behalf of the protocol   /// @dev Only the active protocolAgent is able to transfer the role   function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)     external     override     whenNotPaused   {     if (_protocolAgent == address(0)) revert ZeroArgument();     // Can't set the new protocol agent to the caller address     if (msg.sender == _protocolAgent) revert InvalidArgument();     // Because the caller must be the current protocol agent     if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized(); // Sets the protocol agent to the new address _setProtocolAgent(_protocol, msg.sender, _protocolAgent);  } /// @notice Function used to check if this is the current active protocol manager   /// @return Boolean indicating it's active   /// @dev If inactive the owner can pull all ERC20s and ETH   /// @dev Will be checked by calling the sherlock contract   function isActive() public view returns (bool) {     return address(sherlockCore.sherlockProtocolManager()) == address(this);   } // Only contract owner can call this   // Sends all specified tokens in this contract to the receiver's address (as well as ETH)   function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {     if (_receiver == address(0)) revert ZeroArgument();     // This contract must NOT be the current assigned protocol manager contract     if (isActive()) revert InvalidConditions();     // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH     _sweep(_receiver, _extraTokens);   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-25-08 10:58:50 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import './Manager.sol';
import '../interfaces/managers/ISherlockProtocolManager.sol';

/// @title Sherlock core interface for protocols
/// @author Evert Kors
// This is the contract that manages covered protocols

contract SherlockProtocolManager is ISherlockProtocolManager, Manager {
  using SafeERC20 for IERC20;

  // Represents the token that protocols pay with (currently USDC)
  IERC20 public immutable token;

  // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed
  uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc

  // A removed protocol is still able to make a claim for this amount of time after its removal
  uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days;

  // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance
  uint256 public constant MIN_SECONDS_LEFT = 7 days;

  // Convenient for percentage calculations
  uint256 internal constant HUNDRED_PERCENT = 10**18;

  // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage
  // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying
  uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours;

  // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)
  mapping(bytes32 => address) internal protocolAgent_;

  // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)
  mapping(bytes32 => uint256) internal nonStakersPercentage;

  // The premium per second paid by each protocol is stored in this mapping
  mapping(bytes32 => uint256) internal premiums_;

  // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.
  // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not
  mapping(bytes32 => uint256) internal activeBalances;

  // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol
  mapping(bytes32 => uint256) internal lastAccountedEachProtocol;

  // The amount that can be claimed by nonstakers for each protocol
  // We need this value so we can track how much payment is coming from each protocol
  mapping(bytes32 => uint256) internal nonStakersClaimableByProtocol;

  // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)
  uint256 internal lastAccountedGlobal;

  // This is the total amount of premiums paid (per second) by all the covered protocols (added up)
  uint256 internal allPremiumsPerSecToStakers;

  // This is the amount that was claimable by stakers the last time the accounting was run
  // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date
  uint256 internal lastClaimablePremiumsForStakers;

  // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage
  // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)
  uint256 public override minActiveBalance;

  // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)
  mapping(bytes32 => uint256) internal removedProtocolClaimDeadline;

  // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)
  mapping(bytes32 => address) internal removedProtocolAgent;

  // Current amount of coverage (i.e. 20M USDC) for a protocol
  mapping(bytes32 => uint256) internal currentCoverage;

  // Previous amount of coverage for a protocol
  // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount
  mapping(bytes32 => uint256) internal previousCoverage;

  // Setting the token to USDC
  constructor(IERC20 _token) {
    if (address(_token) == address(0)) revert ZeroArgument();
    token = _token;
  }

  // Modifier used to ensure a protocol exists (has been instantiated and not removed)
  modifier protocolExists(bytes32 _protocol) {
    _verifyProtocolExists(_protocol);
    _;
  }

  /// @notice View current protocolAgent of `_protocol`
  /// @param _protocol Protocol identifier
  /// @return Address able to submit claims
  function protocolAgent(bytes32 _protocol) external view override returns (address) {
    address agent = protocolAgent_[_protocol];
    if (agent != address(0)) return agent;

    // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned
    // Note: Old protocol agent will never be address(0)
    if (block.timestamp <= removedProtocolClaimDeadline[_protocol]) {
      return removedProtocolAgent[_protocol];
    }

    // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned
    revert ProtocolNotExists(_protocol);
  }

  // Checks if the protocol exists, then returns the current premium per second being charged
  /// @notice View current premium of protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of premium `_protocol` pays per second
  function premium(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return premiums_[_protocol];
  }

  // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)
  // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)
  function _verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {
    _protocolAgent = protocolAgent_[_protocol];
    if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);
  }

  //
  // View methods
  //

  // Calcs the debt accrued by the protocol since it last had an accounting update
  // This is the amount that needs to be removed from a protocol's active balance
  function _calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {
    return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums_[_protocol];
  }

  /// @notice View the amount nonstakers can claim from this protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of tokens claimable by nonstakers
  /// @dev this reads from a storage variable + (now-lastsettled) * premiums
  // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]
  // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed
  function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {
    // Calcs the debt of a protocol since the last accounting update
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // Gets the active balance of the protocol
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) debt = balance;

    // Adds the incremental claimable amount owed to nonstakers to the total claimable amount
    return
      nonStakersClaimableByProtocol[_protocol] +
      (nonStakersPercentage[_protocol] * debt) /
      HUNDRED_PERCENT;
  }

  /// @notice View current amount of all premiums that are owed to stakers
  /// @return Premiums claimable
  /// @dev Will increase every block
  /// @dev base + (now - last_settled) * ps
  function claimablePremiums() public view override returns (uint256) {
    // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)
    return
      lastClaimablePremiumsForStakers +
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
  }

  /// @notice View seconds of coverage left for `_protocol` before it runs out of active balance
  /// @param _protocol Protocol identifier
  /// @return Seconds of coverage left
  function secondsOfCoverageLeft(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _secondsOfCoverageLeft(_protocol);
  }

  // Helper function to return seconds of coverage left for a protocol
  // Gets the current active balance of the protocol and divides by the premium per second for the protocol
  function _secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {
    uint256 premium = premiums_[_protocol];
    if (premium == 0) return 0;
    return _activeBalance(_protocol) / premium;
  }

  /// @notice View current active balance of covered protocol
  /// @param _protocol Protocol identifier
  /// @return Active balance
  /// @dev Accrued debt is subtracted from the stored active balance
  function activeBalance(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _activeBalance(_protocol);
  }

  // Helper function to calc the active balance of a protocol at current time
  function _activeBalance(bytes32 _protocol) internal view returns (uint256) {
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) return 0;
    return balance - debt;
  }

  //
  // State methods
  //

  /// @notice Helps set the premium per second for an individual protocol
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function
  function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)
    internal
    returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)
  {
    // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers
    // Also updates the last accounted timestamp for this protocol
    // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings
    // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol
    nonStakerPercentage = _settleProtocolDebt(_protocol);
    // Stores the old premium before it gets updated
    oldPremiumPerSecond = premiums_[_protocol];

    if (oldPremiumPerSecond != _premium) {
      // Sets the protocol's premium per second to the new value
      premiums_[_protocol] = _premium;
      emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium);
    }
    // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing
    // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes
    // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point
    // Where arbs would no longer be incentivized to remove the protocol
    // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems
    if (_premium != 0 && _secondsOfCoverageLeft(_protocol) < MIN_SECONDS_OF_COVERAGE) {
      revert InsufficientBalance(_protocol);
    }
  }

  /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {
    // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings
    (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
      _protocol,
      _premium
    );
    // Settling the total amount of premiums owed to stakers before a new premium per second gets set
    _settleTotalDebt();
    // This calculates the new global premium per second that gets paid to stakers
    // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      oldPremiumPerSecond,
      _premium,
      nonStakerPercentage,
      nonStakerPercentage,
      allPremiumsPerSecToStakers
    );
  }

  // Internal function to set a new protocolAgent for a specific protocol
  // _oldAgent is only included as part of emitting an event
  function _setProtocolAgent(
    bytes32 _protocol,
    address _oldAgent,
    address _protocolAgent
  ) internal {
    protocolAgent_[_protocol] = _protocolAgent;
    emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);
  }

  // Subtracts the accrued debt from a protocol's active balance
  // Credits the amount that can be claimed by nonstakers for this protocol
  // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings
  // Most of this function is dealing with an edge case related to a protocol not being removed by arbs
  function _settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {
    // This calcs the accrued debt of the protocol since it was last updated
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // This pulls the percentage that is sent to nonstakers
    _nonStakerPercentage = nonStakersPercentage[_protocol];
    // In case the protocol has accrued debt, this code block will ensure the debt is settled properly
    if (debt != 0) {
      // Pulls the stored active balance of the protocol
      uint256 balance = activeBalances[_protocol];
      // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance
      // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point
      // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage
      // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up
      if (debt > balance) {
        // This error amount represents the magnitude of the mistake
        uint256 error = debt - balance;
        // Gets the latest value of claimable premiums for stakers
        _settleTotalDebt();
        // @note to production, set premium first to zero before solving accounting issue.
        // otherwise the accounting error keeps increasing
        uint256 lastClaimablePremiumsForStakers_ = lastClaimablePremiumsForStakers;

        // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%
        uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /
          HUNDRED_PERCENT;

        // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short
        uint256 insufficientTokens;

        // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally
        // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error
        // This first line can be true if claimPremiumsForStakers() has been called and
        // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be >0 still
        if (claimablePremiumError > lastClaimablePremiumsForStakers_) {
          insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;
          lastClaimablePremiumsForStakers = 0;
        } else {
          // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums
          // By the amount that was added in error (error) and insufficientTokens = 0
          lastClaimablePremiumsForStakers =
            lastClaimablePremiumsForStakers_ -
            claimablePremiumError;
        }

        // If two events are thrown, the values need to be summed up for the actual state.
        // This means an error of this type will continue until it is handled
        emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);
        // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case
        debt = balance;
      }
      // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance
      activeBalances[_protocol] = balance - debt;
      // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol
      nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT;
    }
    // Updates the last accounted timestamp for this protocol
    lastAccountedEachProtocol[_protocol] = block.timestamp;
  }

  // Multiplies the total premium per second * number of seconds since the last global accounting update
  // And adds it to the total claimable amount for stakers
  function _settleTotalDebt() internal {
    lastClaimablePremiumsForStakers +=
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
    lastAccountedGlobal = block.timestamp;
  }

  // Calculates the global premium per second for stakers
  // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers
  // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones
  function _calcGlobalPremiumPerSecForStakers(
    uint256 _premiumOld,
    uint256 _premiumNew,
    uint256 _nonStakerPercentageOld,
    uint256 _nonStakerPercentageNew,
    uint256 _inMemAllPremiumsPerSecToStakers
  ) internal pure returns (uint256) {
    return
      _inMemAllPremiumsPerSecToStakers +
      ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /
      HUNDRED_PERCENT -
      ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /
      HUNDRED_PERCENT;
  }

  // Helper function to remove and clean up a protocol from Sherlock
  // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made
  function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {
    // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol
    _setSingleAndGlobalProtocolPremium(_protocol, 0);

    // Grabs the protocol's active balance
    uint256 balance = activeBalances[_protocol];

    // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent
    if (balance != 0) {
      delete activeBalances[_protocol];
      token.safeTransfer(_agent, balance);

      emit ProtocolBalanceWithdrawn(_protocol, balance);
    }

    // Sets the protocol agent to zero address (as part of clean up)
    _setProtocolAgent(_protocol, _agent, address(0));

    // Cleans up other mappings for this protocol
    delete nonStakersPercentage[_protocol];
    delete lastAccountedEachProtocol[_protocol];
    // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above

    // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol
    removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;

    // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed
    // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked
    removedProtocolAgent[_protocol] = _agent;

    emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0));
    emit ProtocolRemoved(_protocol);
  }

  /// @notice Sets the minimum active balance before an arb can remove a protocol
  /// @param _minActiveBalance Minimum balance needed (in USDC)
  /// @dev Only gov
  function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {
    // New value cannot be the same as current value
    if (minActiveBalance == _minActiveBalance) revert InvalidArgument();
    // Can't set a value that is too high to be reasonable
    if (_minActiveBalance >= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions();

    emit MinBalance(minActiveBalance, _minActiveBalance);
    minActiveBalance = _minActiveBalance;
  }

  // This function allows the nonstakers role to claim tokens owed to them by a specific protocol
  /// @notice Choose an `_amount` of tokens that nonstakers (`_receiver` address) will receive from `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens
  /// @param _receiver Address to receive tokens
  /// @dev Only callable by nonstakers role
  function nonStakersClaim(
    bytes32 _protocol,
    uint256 _amount,
    address _receiver
  ) external override whenNotPaused {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_amount == uint256(0)) revert ZeroArgument();
    if (_receiver == address(0)) revert ZeroArgument();
    // Only the nonstakers role (multisig or contract) can pull the funds
    if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized();

    // Call can't be executed on protocol that is removed
    if (protocolAgent_[_protocol] != address(0)) {
      // Updates the amount that nonstakers can claim from this protocol
      _settleProtocolDebt(_protocol);
    }

    // Sets balance to the amount that is claimable by nonstakers for this specific protocol
    uint256 balance = nonStakersClaimableByProtocol[_protocol];
    // If the amount requested is more than what's owed to nonstakers, revert
    if (_amount > balance) revert InsufficientBalance(_protocol);

    // Sets the claimable amount to whatever is left over after this amount is pulled
    nonStakersClaimableByProtocol[_protocol] = balance - _amount;
    // Transfers the amount requested to the `_receiver` address
    token.safeTransfer(_receiver, _amount);
  }

  // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)
  /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address
  /// @dev Callable by everyone
  /// @dev Funds will be transferred to Sherlock core contract
  function claimPremiumsForStakers() external override whenNotPaused {
    // Gets address of core Sherlock contract
    address sherlock = address(sherlockCore);
    // Revert if core Sherlock contract not initialized yet
    if (sherlock == address(0)) revert InvalidConditions();

    // claimablePremiums is different from _settleTotalDebt() because it does not change state
    // Retrieves current amount of all premiums that are owed to stakers
    uint256 amount = claimablePremiums();

    // Transfers all the premiums owed to stakers to the Sherlock core contract
    if (amount != 0) {
      // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out
      lastClaimablePremiumsForStakers = 0;
      lastAccountedGlobal = block.timestamp;
      token.safeTransfer(sherlock, amount);
    }
  }

  // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts
  /// @param _protocol Protocol identifier
  /// @return current and previous are the current and previous coverage amounts for this protocol
  // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)
  function coverageAmounts(bytes32 _protocol)
    external
    view
    override
    returns (uint256 current, uint256 previous)
  {
    // Checks to see if the protocol has an active protocolAgent (protocol not removed)
    // OR checks to see if the removed protocol is still within the claim window
    // If so, gives the current and previous coverage, otherwise throws an error
    if (
      protocolAgent_[_protocol] != address(0) ||
      block.timestamp <= removedProtocolClaimDeadline[_protocol]
    ) {
      return (currentCoverage[_protocol], previousCoverage[_protocol]);
    }

    revert ProtocolNotExists(_protocol);
  }

  /// @notice Add a new protocol to Sherlock
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Address able to submit a claim on behalf of the protocol
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Adding a protocol allows the `_protocolAgent` to submit a claim
  /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point
  /// @dev `_nonStakers` is scaled by 10**18
  /// @dev Only callable by governance
  function protocolAdd(
    bytes32 _protocol,
    address _protocolAgent,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) external override onlyOwner {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Checks to make sure the protocol doesn't exist already
    if (protocolAgent_[_protocol] != address(0)) revert InvalidConditions();

    // Updates the protocol agent and passes in the old agent which is 0 address in this case
    _setProtocolAgent(_protocol, address(0), _protocolAgent);

    // Delete mappings that are potentially non default values
    // From previous time protocol was added/removed
    delete removedProtocolClaimDeadline[_protocol];
    delete removedProtocolAgent[_protocol];
    delete currentCoverage[_protocol];
    delete previousCoverage[_protocol];

    emit ProtocolAdded(_protocol);

    // Most of the logic for actually adding a protocol in this function
    protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Update info regarding a protocol
  /// @param _protocol Protocol identifier
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Only callable by governance
  /// @dev `_nonStakers` can be 0
  function protocolUpdate(
    bytes32 _protocol,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) public override onlyOwner {
    if (_coverage == bytes32(0)) revert ZeroArgument();
    if (_nonStakers > HUNDRED_PERCENT) revert InvalidArgument();
    if (_coverageAmount == uint256(0)) revert ZeroArgument();

    // Checks to make sure the protocol has been assigned a protocol agent
    _verifyProtocolExists(_protocol);

    // Subtracts the accrued debt from a protocol's active balance (if any)
    // Updates the amount that can be claimed by nonstakers
    _settleProtocolDebt(_protocol);

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    // Gets the premium per second for this protocol
    uint256 premium = premiums_[_protocol];

    // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be)
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      premium,
      premium,
      nonStakersPercentage[_protocol],
      _nonStakers,
      allPremiumsPerSecToStakers
    );

    // Updates the stored value of percentage of premiums that go to nonstakers
    nonStakersPercentage[_protocol] = _nonStakers;

    // Updates previous coverage and current coverage amounts
    previousCoverage[_protocol] = currentCoverage[_protocol];
    currentCoverage[_protocol] = _coverageAmount;

    emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Remove a protocol from coverage
  /// @param _protocol Protocol identifier
  /// @dev Before removing a protocol the premium must be 0
  /// @dev Removing a protocol basically stops the `_protocolAgent` from being active (can still submit claims until claim deadline though)
  /// @dev Pays off debt + sends remaining balance to protocol agent
  /// @dev This call should be subject to a timelock
  /// @dev Only callable by governance
  function protocolRemove(bytes32 _protocol) external override onlyOwner {
    // checks to make sure the protocol actually has a protocol agent
    address agent = _verifyProtocolExists(_protocol);

    // Removes a protocol from Sherlock and cleans up its data
    // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made
    _forceRemoveProtocol(_protocol, agent);
  }

  /// @notice Remove a protocol with insufficient active balance
  /// @param _protocol Protocol identifier
  // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function
  function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {
    address agent = _verifyProtocolExists(_protocol);

    // Gets the latest value of the active balance at this protocol
    _settleProtocolDebt(_protocol);
    // Sets latest value of active balance to remainingBalance variable
    uint256 remainingBalance = activeBalances[_protocol];

    // This means the protocol still has adequate active balance and thus cannot be removed
    if (remainingBalance >= minActiveBalance) revert InvalidConditions();

    // Sets the protocol's active balance to 0
    delete activeBalances[_protocol];
    // Removes the protocol from coverage
    _forceRemoveProtocol(_protocol, agent);

    if (remainingBalance != 0) {
      // sends the remaining balance to msg.sender
      token.safeTransfer(msg.sender, remainingBalance);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);
  }

  /// @notice Calculate if arb is possible and what the reward would be
  /// @param _protocol Protocol identifier
  /// @return arbAmount Amount reward for arbing
  /// @return able Indicator if arb call is even possible
  /// @dev Doesn't subtract the current protocol debt from the active balance
  function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)
    internal
    view
    returns (uint256 arbAmount, bool able)
  {
    uint256 secondsLeft = _secondsOfCoverageLeft(_protocol);

    // If arb is not possible return false
    if (secondsLeft >= MIN_SECONDS_OF_COVERAGE) return (0, false);

    // This percentage scales over time
    // Reaches 100% on 0 seconds of coverage left
    uint256 percentageScaled = HUNDRED_PERCENT -
      (secondsLeft * HUNDRED_PERCENT) /
      MIN_SECONDS_OF_COVERAGE;

    able = true;
    arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;
  }

  /// @notice Removes a protocol with insufficent seconds of coverage left
  /// @param _protocol Protocol identifier
  // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second
  function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {
    // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings
    address agent = _verifyProtocolExists(_protocol);

    // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance()
    // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance()
    // But when removing based on seconds of coverage left, the remainingBalance could still be quite large
    // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance
    // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%)
    _settleProtocolDebt(_protocol);
    (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol);
    if (able == false) revert InvalidConditions();

    if (arbAmount != 0) {
      // subtracts the amount that will be paid to the arb from the active balance
      activeBalances[_protocol] -= arbAmount;
    }

    // Removes the protocol from coverage
    // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above
    _forceRemoveProtocol(_protocol, agent);

    // Done after removing protocol to mitigate reentrency pattern
    // (In case token allows callback)
    if (arbAmount != 0) {
      token.safeTransfer(msg.sender, arbAmount);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);
  }

  /// @notice Set premium of `_protocol` to `_premium`
  /// @param _protocol Protocol identifier
  /// @param _premium Amount of premium `_protocol` pays per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {
    // Checks to see if protocol has a protocol agent
    _verifyProtocolExists(_protocol);

    // Updates individual protocol's premium and allPremiumsPerSecToStakers
    _setSingleAndGlobalProtocolPremium(_protocol, _premium);
  }

  /// @notice Set premium of multiple protocols
  /// @param _protocol Array of protocol identifiers
  /// @param _premium Array of premium amounts protocols pay per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)
    external
    override
    onlyOwner
  {
    // Checks to make sure there are an equal amount of entries in each array
    if (_protocol.length != _premium.length) revert UnequalArrayLength();
    if (_protocol.length == 0) revert InvalidArgument();

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;

    // Loops through the array of protocols and checks to make sure each has a protocol agent assigned
    for (uint256 i; i < _protocol.length; i++) {
      _verifyProtocolExists(_protocol[i]);

      // Sets the protocol premium for that specific protocol
      // Function returns the old premium and nonStakerPercentage for that specific protocol
      (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
        _protocol[i],
        _premium[i]
      );

      // Calculates the new global premium which adds up all premiums paid by all protocols
      allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(
        oldPremiumPerSecond,
        _premium[i],
        nonStakerPercentage,
        nonStakerPercentage,
        allPremiumsPerSecToStakers_
      );
    }

    // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value
    allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;
  }

  // This is how protocols pay for coverage by increasing their active balance
  /// @notice Deposits `_amount` of token to the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to deposit
  /// @dev Approval should be made before calling
  function depositToActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    _verifyProtocolExists(_protocol);

    // Transfers _amount to this contract
    token.safeTransferFrom(msg.sender, address(this), _amount);
    // Increases the active balance of the protocol by _amount
    activeBalances[_protocol] += _amount;

    emit ProtocolBalanceDeposited(_protocol, _amount);
  }

  // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)
  // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)
  /// @notice Withdraws `_amount` of token from the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to withdraw
  /// @dev Only protocol agent is able to withdraw
  /// @dev Balance can be withdrawn up until 7 days worth of active balance
  function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    // Only the protocol agent can call this function
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Updates the active balance of the protocol
    _settleProtocolDebt(_protocol);

    // Sets currentBalance to the active balance of the protocol
    uint256 currentBalance = activeBalances[_protocol];
    // Reverts if trying to withdraw more than the active balance
    if (_amount > currentBalance) revert InsufficientBalance(_protocol);

    // Removes the _amount to be withdrawn from the active balance
    activeBalances[_protocol] = currentBalance - _amount;
    // Reverts if a protocol has less than 7 days worth of active balance left
    if (_secondsOfCoverageLeft(_protocol) < MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);

    // Transfers the amount to the msg.sender (protocol agent)
    token.safeTransfer(msg.sender, _amount);
    emit ProtocolBalanceWithdrawn(_protocol, _amount);
  }

  /// @notice Transfer protocol agent role
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Account able to submit a claim on behalf of the protocol
  /// @dev Only the active protocolAgent is able to transfer the role
  function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)
    external
    override
    whenNotPaused
  {
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Can't set the new protocol agent to the caller address
    if (msg.sender == _protocolAgent) revert InvalidArgument();
    // Because the caller must be the current protocol agent
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Sets the protocol agent to the new address
    _setProtocolAgent(_protocol, msg.sender, _protocolAgent);
  }

  /// @notice Function used to check if this is the current active protocol manager
  /// @return Boolean indicating it's active
  /// @dev If inactive the owner can pull all ERC20s and ETH
  /// @dev Will be checked by calling the sherlock contract
  function isActive() public view returns (bool) {
    return address(sherlockCore.sherlockProtocolManager()) == address(this);
  }

  // Only contract owner can call this
  // Sends all specified tokens in this contract to the receiver's address (as well as ETH)
  function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {
    if (_receiver == address(0)) revert ZeroArgument();
    // This contract must NOT be the current assigned protocol manager contract
    if (isActive()) revert InvalidConditions();
    // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH
    _sweep(_receiver, _extraTokens);
  }
}
.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import './Manager.sol';
import '../interfaces/managers/ISherlockProtocolManager.sol';

/// @title Sherlock core interface for protocols
/// @author Evert Kors
// This is the contract that manages covered protocols

contract SherlockProtocolManager is ISherlockProtocolManager, Manager {
  using SafeERC20 for IERC20;

  // Represents the token that protocols pay with (currently USDC)
  IERC20 public immutable token;

  // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed
  uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc

  // A removed protocol is still able to make a claim for this amount of time after its removal
  uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days;

  // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance
  uint256 public constant MIN_SECONDS_LEFT = 7 days;

  // Convenient for percentage calculations
  uint256 internal constant HUNDRED_PERCENT = 10**18;

  // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage
  // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying
  uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours;

  // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)
  mapping(bytes32 => address) internal protocolAgent_;

  // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)
  mapping(bytes32 => uint256) internal nonStakersPercentage;

  // The premium per second paid by each protocol is stored in this mapping
  mapping(bytes32 => uint256) internal premiums_;

  // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.
  // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not
  mapping(bytes32 => uint256) internal activeBalances;

  // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol
  mapping(bytes32 => uint256) internal lastAccountedEachProtocol;

  // The amount that can be claimed by nonstakers for each protocol
  // We need this value so we can track how much payment is coming from each protocol
  mapping(bytes32 => uint256) internal nonStakersClaimableByProtocol;

  // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)
  uint256 internal lastAccountedGlobal;

  // This is the total amount of premiums paid (per second) by all the covered protocols (added up)
  uint256 internal allPremiumsPerSecToStakers;

  // This is the amount that was claimable by stakers the last time the accounting was run
  // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date
  uint256 internal lastClaimablePremiumsForStakers;

  // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage
  // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)
  uint256 public override minActiveBalance;

  // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)
  mapping(bytes32 => uint256) internal removedProtocolClaimDeadline;

  // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)
  mapping(bytes32 => address) internal removedProtocolAgent;

  // Current amount of coverage (i.e. 20M USDC) for a protocol
  mapping(bytes32 => uint256) internal currentCoverage;

  // Previous amount of coverage for a protocol
  // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount
  mapping(bytes32 => uint256) internal previousCoverage;

  // Setting the token to USDC
  constructor(IERC20 _token) {
    if (address(_token) == address(0)) revert ZeroArgument();
    token = _token;
  }

  // Modifier used to ensure a protocol exists (has been instantiated and not removed)
  modifier protocolExists(bytes32 _protocol) {
    _verifyProtocolExists(_protocol);
    _;
  }

  /// @notice View current protocolAgent of `_protocol`
  /// @param _protocol Protocol identifier
  /// @return Address able to submit claims
  function protocolAgent(bytes32 _protocol) external view override returns (address) {
    address agent = protocolAgent_[_protocol];
    if (agent != address(0)) return agent;

    // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned
    // Note: Old protocol agent will never be address(0)
    if (block.timestamp <= removedProtocolClaimDeadline[_protocol]) {
      return removedProtocolAgent[_protocol];
    }

    // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned
    revert ProtocolNotExists(_protocol);
  }

  // Checks if the protocol exists, then returns the current premium per second being charged
  /// @notice View current premium of protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of premium `_protocol` pays per second
  function premium(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return premiums_[_protocol];
  }

  // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)
  // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)
  function _verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {
    _protocolAgent = protocolAgent_[_protocol];
    if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);
  }

  //
  // View methods
  //

  // Calcs the debt accrued by the protocol since it last had an accounting update
  // This is the amount that needs to be removed from a protocol's active balance
  function _calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {
    return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums_[_protocol];
  }

  /// @notice View the amount nonstakers can claim from this protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of tokens claimable by nonstakers
  /// @dev this reads from a storage variable + (now-lastsettled) * premiums
  // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]
  // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed
  function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {
    // Calcs the debt of a protocol since the last accounting update
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // Gets the active balance of the protocol
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) debt = balance;

    // Adds the incremental claimable amount owed to nonstakers to the total claimable amount
    return
      nonStakersClaimableByProtocol[_protocol] +
      (nonStakersPercentage[_protocol] * debt) /
      HUNDRED_PERCENT;
  }

  /// @notice View current amount of all premiums that are owed to stakers
  /// @return Premiums claimable
  /// @dev Will increase every block
  /// @dev base + (now - last_settled) * ps
  function claimablePremiums() public view override returns (uint256) {
    // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)
    return
      lastClaimablePremiumsForStakers +
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
  }

  /// @notice View seconds of coverage left for `_protocol` before it runs out of active balance
  /// @param _protocol Protocol identifier
  /// @return Seconds of coverage left
  function secondsOfCoverageLeft(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _secondsOfCoverageLeft(_protocol);
  }

  // Helper function to return seconds of coverage left for a protocol
  // Gets the current active balance of the protocol and divides by the premium per second for the protocol
  function _secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {
    uint256 premium = premiums_[_protocol];
    if (premium == 0) return 0;
    return _activeBalance(_protocol) / premium;
  }

  /// @notice View current active balance of covered protocol
  /// @param _protocol Protocol identifier
  /// @return Active balance
  /// @dev Accrued debt is subtracted from the stored active balance
  function activeBalance(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _activeBalance(_protocol);
  }

  // Helper function to calc the active balance of a protocol at current time
  function _activeBalance(bytes32 _protocol) internal view returns (uint256) {
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) return 0;
    return balance - debt;
  }

  //
  // State methods
  //

  /// @notice Helps set the premium per second for an individual protocol
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function
  function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)
    internal
    returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)
  {
    // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers
    // Also updates the last accounted timestamp for this protocol
    // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings
    // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol
    nonStakerPercentage = _settleProtocolDebt(_protocol);
    // Stores the old premium before it gets updated
    oldPremiumPerSecond = premiums_[_protocol];

    if (oldPremiumPerSecond != _premium) {
      // Sets the protocol's premium per second to the new value
      premiums_[_protocol] = _premium;
      emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium);
    }
    // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing
    // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes
    // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point
    // Where arbs would no longer be incentivized to remove the protocol
    // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems
    if (_premium != 0 && _secondsOfCoverageLeft(_protocol) < MIN_SECONDS_OF_COVERAGE) {
      revert InsufficientBalance(_protocol);
    }
  }

  /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {
    // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings
    (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
      _protocol,
      _premium
    );
    // Settling the total amount of premiums owed to stakers before a new premium per second gets set
    _settleTotalDebt();
    // This calculates the new global premium per second that gets paid to stakers
    // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      oldPremiumPerSecond,
      _premium,
      nonStakerPercentage,
      nonStakerPercentage,
      allPremiumsPerSecToStakers
    );
  }

  // Internal function to set a new protocolAgent for a specific protocol
  // _oldAgent is only included as part of emitting an event
  function _setProtocolAgent(
    bytes32 _protocol,
    address _oldAgent,
    address _protocolAgent
  ) internal {
    protocolAgent_[_protocol] = _protocolAgent;
    emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);
  }

  // Subtracts the accrued debt from a protocol's active balance
  // Credits the amount that can be claimed by nonstakers for this protocol
  // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings
  // Most of this function is dealing with an edge case related to a protocol not being removed by arbs
  function _settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {
    // This calcs the accrued debt of the protocol since it was last updated
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // This pulls the percentage that is sent to nonstakers
    _nonStakerPercentage = nonStakersPercentage[_protocol];
    // In case the protocol has accrued debt, this code block will ensure the debt is settled properly
    if (debt != 0) {
      // Pulls the stored active balance of the protocol
      uint256 balance = activeBalances[_protocol];
      // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance
      // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point
      // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage
      // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up
      if (debt > balance) {
        // This error amount represents the magnitude of the mistake
        uint256 error = debt - balance;
        // Gets the latest value of claimable premiums for stakers
        _settleTotalDebt();
        // @note to production, set premium first to zero before solving accounting issue.
        // otherwise the accounting error keeps increasing
        uint256 lastClaimablePremiumsForStakers_ = lastClaimablePremiumsForStakers;

        // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%
        uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /
          HUNDRED_PERCENT;

        // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short
        uint256 insufficientTokens;

        // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally
        // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error
        // This first line can be true if claimPremiumsForStakers() has been called and
        // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be >0 still
        if (claimablePremiumError > lastClaimablePremiumsForStakers_) {
          insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;
          lastClaimablePremiumsForStakers = 0;
        } else {
          // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums
          // By the amount that was added in error (error) and insufficientTokens = 0
          lastClaimablePremiumsForStakers =
            lastClaimablePremiumsForStakers_ -
            claimablePremiumError;
        }

        // If two events are thrown, the values need to be summed up for the actual state.
        // This means an error of this type will continue until it is handled
        emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);
        // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case
        debt = balance;
      }
      // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance
      activeBalances[_protocol] = balance - debt;
      // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol
      nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT;
    }
    // Updates the last accounted timestamp for this protocol
    lastAccountedEachProtocol[_protocol] = block.timestamp;
  }

  // Multiplies the total premium per second * number of seconds since the last global accounting update
  // And adds it to the total claimable amount for stakers
  function _settleTotalDebt() internal {
    lastClaimablePremiumsForStakers +=
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
    lastAccountedGlobal = block.timestamp;
  }

  // Calculates the global premium per second for stakers
  // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers
  // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones
  function _calcGlobalPremiumPerSecForStakers(
    uint256 _premiumOld,
    uint256 _premiumNew,
    uint256 _nonStakerPercentageOld,
    uint256 _nonStakerPercentageNew,
    uint256 _inMemAllPremiumsPerSecToStakers
  ) internal pure returns (uint256) {
    return
      _inMemAllPremiumsPerSecToStakers +
      ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /
      HUNDRED_PERCENT -
      ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /
      HUNDRED_PERCENT;
  }

  // Helper function to remove and clean up a protocol from Sherlock
  // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made
  function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {
    // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol
    _setSingleAndGlobalProtocolPremium(_protocol, 0);

    // Grabs the protocol's active balance
    uint256 balance = activeBalances[_protocol];

    // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent
    if (balance != 0) {
      delete activeBalances[_protocol];
      token.safeTransfer(_agent, balance);

      emit ProtocolBalanceWithdrawn(_protocol, balance);
    }

    // Sets the protocol agent to zero address (as part of clean up)
    _setProtocolAgent(_protocol, _agent, address(0));

    // Cleans up other mappings for this protocol
    delete nonStakersPercentage[_protocol];
    delete lastAccountedEachProtocol[_protocol];
    // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above

    // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol
    removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;

    // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed
    // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked
    removedProtocolAgent[_protocol] = _agent;

    emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0));
    emit ProtocolRemoved(_protocol);
  }

  /// @notice Sets the minimum active balance before an arb can remove a protocol
  /// @param _minActiveBalance Minimum balance needed (in USDC)
  /// @dev Only gov
  function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {
    // New value cannot be the same as current value
    if (minActiveBalance == _minActiveBalance) revert InvalidArgument();
    // Can't set a value that is too high to be reasonable
    if (_minActiveBalance >= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions();

    emit MinBalance(minActiveBalance, _minActiveBalance);
    minActiveBalance = _minActiveBalance;
  }

  // This function allows the nonstakers role to claim tokens owed to them by a specific protocol
  /// @notice Choose an `_amount` of tokens that nonstakers (`_receiver` address) will receive from `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens
  /// @param _receiver Address to receive tokens
  /// @dev Only callable by nonstakers role
  function nonStakersClaim(
    bytes32 _protocol,
    uint256 _amount,
    address _receiver
  ) external override whenNotPaused {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_amount == uint256(0)) revert ZeroArgument();
    if (_receiver == address(0)) revert ZeroArgument();
    // Only the nonstakers role (multisig or contract) can pull the funds
    if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized();

    // Call can't be executed on protocol that is removed
    if (protocolAgent_[_protocol] != address(0)) {
      // Updates the amount that nonstakers can claim from this protocol
      _settleProtocolDebt(_protocol);
    }

    // Sets balance to the amount that is claimable by nonstakers for this specific protocol
    uint256 balance = nonStakersClaimableByProtocol[_protocol];
    // If the amount requested is more than what's owed to nonstakers, revert
    if (_amount > balance) revert InsufficientBalance(_protocol);

    // Sets the claimable amount to whatever is left over after this amount is pulled
    nonStakersClaimableByProtocol[_protocol] = balance - _amount;
    // Transfers the amount requested to the `_receiver` address
    token.safeTransfer(_receiver, _amount);
  }

  // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)
  /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address
  /// @dev Callable by everyone
  /// @dev Funds will be transferred to Sherlock core contract
  function claimPremiumsForStakers() external override whenNotPaused {
    // Gets address of core Sherlock contract
    address sherlock = address(sherlockCore);
    // Revert if core Sherlock contract not initialized yet
    if (sherlock == address(0)) revert InvalidConditions();

    // claimablePremiums is different from _settleTotalDebt() because it does not change state
    // Retrieves current amount of all premiums that are owed to stakers
    uint256 amount = claimablePremiums();

    // Transfers all the premiums owed to stakers to the Sherlock core contract
    if (amount != 0) {
      // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out
      lastClaimablePremiumsForStakers = 0;
      lastAccountedGlobal = block.timestamp;
      token.safeTransfer(sherlock, amount);
    }
  }

  // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts
  /// @param _protocol Protocol identifier
  /// @return current and previous are the current and previous coverage amounts for this protocol
  // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)
  function coverageAmounts(bytes32 _protocol)
    external
    view
    override
    returns (uint256 current, uint256 previous)
  {
    // Checks to see if the protocol has an active protocolAgent (protocol not removed)
    // OR checks to see if the removed protocol is still within the claim window
    // If so, gives the current and previous coverage, otherwise throws an error
    if (
      protocolAgent_[_protocol] != address(0) ||
      block.timestamp <= removedProtocolClaimDeadline[_protocol]
    ) {
      return (currentCoverage[_protocol], previousCoverage[_protocol]);
    }

    revert ProtocolNotExists(_protocol);
  }

  /// @notice Add a new protocol to Sherlock
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Address able to submit a claim on behalf of the protocol
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Adding a protocol allows the `_protocolAgent` to submit a claim
  /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point
  /// @dev `_nonStakers` is scaled by 10**18
  /// @dev Only callable by governance
  function protocolAdd(
    bytes32 _protocol,
    address _protocolAgent,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) external override onlyOwner {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Checks to make sure the protocol doesn't exist already
    if (protocolAgent_[_protocol] != address(0)) revert InvalidConditions();

    // Updates the protocol agent and passes in the old agent which is 0 address in this case
    _setProtocolAgent(_protocol, address(0), _protocolAgent);

    // Delete mappings that are potentially non default values
    // From previous time protocol was added/removed
    delete removedProtocolClaimDeadline[_protocol];
    delete removedProtocolAgent[_protocol];
    delete currentCoverage[_protocol];
    delete previousCoverage[_protocol];

    emit ProtocolAdded(_protocol);

    // Most of the logic for actually adding a protocol in this function
    protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Update info regarding a protocol
  /// @param _protocol Protocol identifier
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Only callable by governance
  /// @dev `_nonStakers` can be 0
  function protocolUpdate(
    bytes32 _protocol,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) public override onlyOwner {
    if (_coverage == bytes32(0)) revert ZeroArgument();
    if (_nonStakers > HUNDRED_PERCENT) revert InvalidArgument();
    if (_coverageAmount == uint256(0)) revert ZeroArgument();

    // Checks to make sure the protocol has been assigned a protocol agent
    _verifyProtocolExists(_protocol);

    // Subtracts the accrued debt from a protocol's active balance (if any)
    // Updates the amount that can be claimed by nonstakers
    _settleProtocolDebt(_protocol);

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    // Gets the premium per second for this protocol
    uint256 premium = premiums_[_protocol];

    // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be)
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      premium,
      premium,
      nonStakersPercentage[_protocol],
      _nonStakers,
      allPremiumsPerSecToStakers
    );

    // Updates the stored value of percentage of premiums that go to nonstakers
    nonStakersPercentage[_protocol] = _nonStakers;

    // Updates previous coverage and current coverage amounts
    previousCoverage[_protocol] = currentCoverage[_protocol];
    currentCoverage[_protocol] = _coverageAmount;

    emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Remove a protocol from coverage
  /// @param _protocol Protocol identifier
  /// @dev Before removing a protocol the premium must be 0
  /// @dev Removing a protocol basically stops the `_protocolAgent` from being active (can still submit claims until claim deadline though)
  /// @dev Pays off debt + sends remaining balance to protocol agent
  /// @dev This call should be subject to a timelock
  /// @dev Only callable by governance
  function protocolRemove(bytes32 _protocol) external override onlyOwner {
    // checks to make sure the protocol actually has a protocol agent
    address agent = _verifyProtocolExists(_protocol);

    // Removes a protocol from Sherlock and cleans up its data
    // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made
    _forceRemoveProtocol(_protocol, agent);
  }

  /// @notice Remove a protocol with insufficient active balance
  /// @param _protocol Protocol identifier
  // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function
  function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {
    address agent = _verifyProtocolExists(_protocol);

    // Gets the latest value of the active balance at this protocol
    _settleProtocolDebt(_protocol);
    // Sets latest value of active balance to remainingBalance variable
    uint256 remainingBalance = activeBalances[_protocol];

    // This means the protocol still has adequate active balance and thus cannot be removed
    if (remainingBalance >= minActiveBalance) revert InvalidConditions();

    // Sets the protocol's active balance to 0
    delete activeBalances[_protocol];
    // Removes the protocol from coverage
    _forceRemoveProtocol(_protocol, agent);

    if (remainingBalance != 0) {
      // sends the remaining balance to msg.sender
      token.safeTransfer(msg.sender, remainingBalance);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);
  }

  /// @notice Calculate if arb is possible and what the reward would be
  /// @param _protocol Protocol identifier
  /// @return arbAmount Amount reward for arbing
  /// @return able Indicator if arb call is even possible
  /// @dev Doesn't subtract the current protocol debt from the active balance
  function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)
    internal
    view
    returns (uint256 arbAmount, bool able)
  {
    uint256 secondsLeft = _secondsOfCoverageLeft(_protocol);

    // If arb is not possible return false
    if (secondsLeft >= MIN_SECONDS_OF_COVERAGE) return (0, false);

    // This percentage scales over time
    // Reaches 100% on 0 seconds of coverage left
    uint256 percentageScaled = HUNDRED_PERCENT -
      (secondsLeft * HUNDRED_PERCENT) /
      MIN_SECONDS_OF_COVERAGE;

    able = true;
    arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;
  }

  /// @notice Removes a protocol with insufficent seconds of coverage left
  /// @param _protocol Protocol identifier
  // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second
  function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {
    // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings
    address agent = _verifyProtocolExists(_protocol);

    // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance()
    // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance()
    // But when removing based on seconds of coverage left, the remainingBalance could still be quite large
    // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance
    // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%)
    _settleProtocolDebt(_protocol);
    (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol);
    if (able == false) revert InvalidConditions();

    if (arbAmount != 0) {
      // subtracts the amount that will be paid to the arb from the active balance
      activeBalances[_protocol] -= arbAmount;
    }

    // Removes the protocol from coverage
    // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above
    _forceRemoveProtocol(_protocol, agent);

    // Done after removing protocol to mitigate reentrency pattern
    // (In case token allows callback)
    if (arbAmount != 0) {
      token.safeTransfer(msg.sender, arbAmount);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);
  }

  /// @notice Set premium of `_protocol` to `_premium`
  /// @param _protocol Protocol identifier
  /// @param _premium Amount of premium `_protocol` pays per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {
    // Checks to see if protocol has a protocol agent
    _verifyProtocolExists(_protocol);

    // Updates individual protocol's premium and allPremiumsPerSecToStakers
    _setSingleAndGlobalProtocolPremium(_protocol, _premium);
  }

  /// @notice Set premium of multiple protocols
  /// @param _protocol Array of protocol identifiers
  /// @param _premium Array of premium amounts protocols pay per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)
    external
    override
    onlyOwner
  {
    // Checks to make sure there are an equal amount of entries in each array
    if (_protocol.length != _premium.length) revert UnequalArrayLength();
    if (_protocol.length == 0) revert InvalidArgument();

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;

    // Loops through the array of protocols and checks to make sure each has a protocol agent assigned
    for (uint256 i; i < _protocol.length; i++) {
      _verifyProtocolExists(_protocol[i]);

      // Sets the protocol premium for that specific protocol
      // Function returns the old premium and nonStakerPercentage for that specific protocol
      (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
        _protocol[i],
        _premium[i]
      );

      // Calculates the new global premium which adds up all premiums paid by all protocols
      allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(
        oldPremiumPerSecond,
        _premium[i],
        nonStakerPercentage,
        nonStakerPercentage,
        allPremiumsPerSecToStakers_
      );
    }

    // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value
    allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;
  }

  // This is how protocols pay for coverage by increasing their active balance
  /// @notice Deposits `_amount` of token to the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to deposit
  /// @dev Approval should be made before calling
  function depositToActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    _verifyProtocolExists(_protocol);

    // Transfers _amount to this contract
    token.safeTransferFrom(msg.sender, address(this), _amount);
    // Increases the active balance of the protocol by _amount
    activeBalances[_protocol] += _amount;

    emit ProtocolBalanceDeposited(_protocol, _amount);
  }

  // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)
  // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)
  /// @notice Withdraws `_amount` of token from the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to withdraw
  /// @dev Only protocol agent is able to withdraw
  /// @dev Balance can be withdrawn up until 7 days worth of active balance
  function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    // Only the protocol agent can call this function
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Updates the active balance of the protocol
    _settleProtocolDebt(_protocol);

    // Sets currentBalance to the active balance of the protocol
    uint256 currentBalance = activeBalances[_protocol];
    // Reverts if trying to withdraw more than the active balance
    if (_amount > currentBalance) revert InsufficientBalance(_protocol);

    // Removes the _amount to be withdrawn from the active balance
    activeBalances[_protocol] = currentBalance - _amount;
    // Reverts if a protocol has less than 7 days worth of active balance left
    if (_secondsOfCoverageLeft(_protocol) < MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);

    // Transfers the amount to the msg.sender (protocol agent)
    token.safeTransfer(msg.sender, _amount);
    emit ProtocolBalanceWithdrawn(_protocol, _amount);
  }

  /// @notice Transfer protocol agent role
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Account able to submit a claim on behalf of the protocol
  /// @dev Only the active protocolAgent is able to transfer the role
  function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)
    external
    override
    whenNotPaused
  {
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Can't set the new protocol agent to the caller address
    if (msg.sender == _protocolAgent) revert InvalidArgument();
    // Because the caller must be the current protocol agent
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Sets the protocol agent to the new address
    _setProtocolAgent(_protocol, msg.sender, _protocolAgent);
  }

  /// @notice Function used to check if this is the current active protocol manager
  /// @return Boolean indicating it's active
  /// @dev If inactive the owner can pull all ERC20s and ETH
  /// @dev Will be checked by calling the sherlock contract
  function isActive() public view returns (bool) {
    return address(sherlockCore.sherlockProtocolManager()) == address(this);
  }

  // Only contract owner can call this
  // Sends all specified tokens in this contract to the receiver's address (as well as ETH)
  function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {
    if (_receiver == address(0)) revert ZeroArgument();
    // This contract must NOT be the current assigned protocol manager contract
    if (isActive()) revert InvalidConditions();
    // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH
    _sweep(_receiver, _extraTokens);
  }
}
".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-25-08 10:58:53 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-25-08 10:58:53 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 18302
completion_tokens: 1
total_tokens: 18303
cost: $-1.000000


[2024-25-08 10:58:53 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import './Manager.sol';
import '../interfaces/managers/ISherlockProtocolManager.sol';

/// @title Sherlock core interface for protocols
/// @author Evert Kors
// This is the contract that manages covered protocols

contract SherlockProtocolManager is ISherlockProtocolManager, Manager {
  using SafeERC20 for IERC20;

  // Represents the token that protocols pay with (currently USDC)
  IERC20 public immutable token;

  // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed
  uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc

  // A removed protocol is still able to make a claim for this amount of time after its removal
  uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days;

  // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance
  uint256 public constant MIN_SECONDS_LEFT = 7 days;

  // Convenient for percentage calculations
  uint256 internal constant HUNDRED_PERCENT = 10**18;

  // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage
  // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying
  uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours;

  // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)
  mapping(bytes32 => address) internal protocolAgent_;

  // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)
  mapping(bytes32 => uint256) internal nonStakersPercentage;

  // The premium per second paid by each protocol is stored in this mapping
  mapping(bytes32 => uint256) internal premiums_;

  // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.
  // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not
  mapping(bytes32 => uint256) internal activeBalances;

  // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol
  mapping(bytes32 => uint256) internal lastAccountedEachProtocol;

  // The amount that can be claimed by nonstakers for each protocol
  // We need this value so we can track how much payment is coming from each protocol
  mapping(bytes32 => uint256) internal nonStakersClaimableByProtocol;

  // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)
  uint256 internal lastAccountedGlobal;

  // This is the total amount of premiums paid (per second) by all the covered protocols (added up)
  uint256 internal allPremiumsPerSecToStakers;

  // This is the amount that was claimable by stakers the last time the accounting was run
  // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date
  uint256 internal lastClaimablePremiumsForStakers;

  // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage
  // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)
  uint256 public override minActiveBalance;

  // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)
  mapping(bytes32 => uint256) internal removedProtocolClaimDeadline;

  // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)
  mapping(bytes32 => address) internal removedProtocolAgent;

  // Current amount of coverage (i.e. 20M USDC) for a protocol
  mapping(bytes32 => uint256) internal currentCoverage;

  // Previous amount of coverage for a protocol
  // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount
  mapping(bytes32 => uint256) internal previousCoverage;

  // Setting the token to USDC
  constructor(IERC20 _token) {
    if (address(_token) == address(0)) revert ZeroArgument();
    token = _token;
  }

  // Modifier used to ensure a protocol exists (has been instantiated and not removed)
  modifier protocolExists(bytes32 _protocol) {
    _verifyProtocolExists(_protocol);
    _;
  }

  /// @notice View current protocolAgent of `_protocol`
  /// @param _protocol Protocol identifier
  /// @return Address able to submit claims
  function protocolAgent(bytes32 _protocol) external view override returns (address) {
    address agent = protocolAgent_[_protocol];
    if (agent != address(0)) return agent;

    // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned
    // Note: Old protocol agent will never be address(0)
    if (block.timestamp <= removedProtocolClaimDeadline[_protocol]) {
      return removedProtocolAgent[_protocol];
    }

    // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned
    revert ProtocolNotExists(_protocol);
  }

  // Checks if the protocol exists, then returns the current premium per second being charged
  /// @notice View current premium of protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of premium `_protocol` pays per second
  function premium(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return premiums_[_protocol];
  }

  // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)
  // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)
  function _verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {
    _protocolAgent = protocolAgent_[_protocol];
    if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);
  }

  //
  // View methods
  //

  // Calcs the debt accrued by the protocol since it last had an accounting update
  // This is the amount that needs to be removed from a protocol's active balance
  function _calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {
    return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums_[_protocol];
  }

  /// @notice View the amount nonstakers can claim from this protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of tokens claimable by nonstakers
  /// @dev this reads from a storage variable + (now-lastsettled) * premiums
  // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]
  // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed
  function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {
    // Calcs the debt of a protocol since the last accounting update
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // Gets the active balance of the protocol
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) debt = balance;

    // Adds the incremental claimable amount owed to nonstakers to the total claimable amount
    return
      nonStakersClaimableByProtocol[_protocol] +
      (nonStakersPercentage[_protocol] * debt) /
      HUNDRED_PERCENT;
  }

  /// @notice View current amount of all premiums that are owed to stakers
  /// @return Premiums claimable
  /// @dev Will increase every block
  /// @dev base + (now - last_settled) * ps
  function claimablePremiums() public view override returns (uint256) {
    // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)
    return
      lastClaimablePremiumsForStakers +
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
  }

  /// @notice View seconds of coverage left for `_protocol` before it runs out of active balance
  /// @param _protocol Protocol identifier
  /// @return Seconds of coverage left
  function secondsOfCoverageLeft(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _secondsOfCoverageLeft(_protocol);
  }

  // Helper function to return seconds of coverage left for a protocol
  // Gets the current active balance of the protocol and divides by the premium per second for the protocol
  function _secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {
    uint256 premium = premiums_[_protocol];
    if (premium == 0) return 0;
    return _activeBalance(_protocol) / premium;
  }

  /// @notice View current active balance of covered protocol
  /// @param _protocol Protocol identifier
  /// @return Active balance
  /// @dev Accrued debt is subtracted from the stored active balance
  function activeBalance(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _activeBalance(_protocol);
  }

  // Helper function to calc the active balance of a protocol at current time
  function _activeBalance(bytes32 _protocol) internal view returns (uint256) {
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) return 0;
    return balance - debt;
  }

  //
  // State methods
  //

  /// @notice Helps set the premium per second for an individual protocol
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function
  function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)
    internal
    returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)
  {
    // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers
    // Also updates the last accounted timestamp for this protocol
    // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings
    // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol
    nonStakerPercentage = _settleProtocolDebt(_protocol);
    // Stores the old premium before it gets updated
    oldPremiumPerSecond = premiums_[_protocol];

    if (oldPremiumPerSecond != _premium) {
      // Sets the protocol's premium per second to the new value
      premiums_[_protocol] = _premium;
      emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium);
    }
    // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing
    // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes
    // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point
    // Where arbs would no longer be incentivized to remove the protocol
    // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems
    if (_premium != 0 && _secondsOfCoverageLeft(_protocol) < MIN_SECONDS_OF_COVERAGE) {
      revert InsufficientBalance(_protocol);
    }
  }

  /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {
    // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings
    (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
      _protocol,
      _premium
    );
    // Settling the total amount of premiums owed to stakers before a new premium per second gets set
    _settleTotalDebt();
    // This calculates the new global premium per second that gets paid to stakers
    // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      oldPremiumPerSecond,
      _premium,
      nonStakerPercentage,
      nonStakerPercentage,
      allPremiumsPerSecToStakers
    );
  }

  // Internal function to set a new protocolAgent for a specific protocol
  // _oldAgent is only included as part of emitting an event
  function _setProtocolAgent(
    bytes32 _protocol,
    address _oldAgent,
    address _protocolAgent
  ) internal {
    protocolAgent_[_protocol] = _protocolAgent;
    emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);
  }

  // Subtracts the accrued debt from a protocol's active balance
  // Credits the amount that can be claimed by nonstakers for this protocol
  // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings
  // Most of this function is dealing with an edge case related to a protocol not being removed by arbs
  function _settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {
    // This calcs the accrued debt of the protocol since it was last updated
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // This pulls the percentage that is sent to nonstakers
    _nonStakerPercentage = nonStakersPercentage[_protocol];
    // In case the protocol has accrued debt, this code block will ensure the debt is settled properly
    if (debt != 0) {
      // Pulls the stored active balance of the protocol
      uint256 balance = activeBalances[_protocol];
      // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance
      // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point
      // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage
      // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up
      if (debt > balance) {
        // This error amount represents the magnitude of the mistake
        uint256 error = debt - balance;
        // Gets the latest value of claimable premiums for stakers
        _settleTotalDebt();
        // @note to production, set premium first to zero before solving accounting issue.
        // otherwise the accounting error keeps increasing
        uint256 lastClaimablePremiumsForStakers_ = lastClaimablePremiumsForStakers;

        // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%
        uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /
          HUNDRED_PERCENT;

        // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short
        uint256 insufficientTokens;

        // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally
        // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error
        // This first line can be true if claimPremiumsForStakers() has been called and
        // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be >0 still
        if (claimablePremiumError > lastClaimablePremiumsForStakers_) {
          insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;
          lastClaimablePremiumsForStakers = 0;
        } else {
          // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums
          // By the amount that was added in error (error) and insufficientTokens = 0
          lastClaimablePremiumsForStakers =
            lastClaimablePremiumsForStakers_ -
            claimablePremiumError;
        }

        // If two events are thrown, the values need to be summed up for the actual state.
        // This means an error of this type will continue until it is handled
        emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);
        // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case
        debt = balance;
      }
      // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance
      activeBalances[_protocol] = balance - debt;
      // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol
      nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT;
    }
    // Updates the last accounted timestamp for this protocol
    lastAccountedEachProtocol[_protocol] = block.timestamp;
  }

  // Multiplies the total premium per second * number of seconds since the last global accounting update
  // And adds it to the total claimable amount for stakers
  function _settleTotalDebt() internal {
    lastClaimablePremiumsForStakers +=
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
    lastAccountedGlobal = block.timestamp;
  }

  // Calculates the global premium per second for stakers
  // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers
  // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones
  function _calcGlobalPremiumPerSecForStakers(
    uint256 _premiumOld,
    uint256 _premiumNew,
    uint256 _nonStakerPercentageOld,
    uint256 _nonStakerPercentageNew,
    uint256 _inMemAllPremiumsPerSecToStakers
  ) internal pure returns (uint256) {
    return
      _inMemAllPremiumsPerSecToStakers +
      ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /
      HUNDRED_PERCENT -
      ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /
      HUNDRED_PERCENT;
  }

  // Helper function to remove and clean up a protocol from Sherlock
  // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made
  function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {
    // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol
    _setSingleAndGlobalProtocolPremium(_protocol, 0);

    // Grabs the protocol's active balance
    uint256 balance = activeBalances[_protocol];

    // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent
    if (balance != 0) {
      delete activeBalances[_protocol];
      token.safeTransfer(_agent, balance);

      emit ProtocolBalanceWithdrawn(_protocol, balance);
    }

    // Sets the protocol agent to zero address (as part of clean up)
    _setProtocolAgent(_protocol, _agent, address(0));

    // Cleans up other mappings for this protocol
    delete nonStakersPercentage[_protocol];
    delete lastAccountedEachProtocol[_protocol];
    // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above

    // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol
    removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;

    // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed
    // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked
    removedProtocolAgent[_protocol] = _agent;

    emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0));
    emit ProtocolRemoved(_protocol);
  }

  /// @notice Sets the minimum active balance before an arb can remove a protocol
  /// @param _minActiveBalance Minimum balance needed (in USDC)
  /// @dev Only gov
  function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {
    // New value cannot be the same as current value
    if (minActiveBalance == _minActiveBalance) revert InvalidArgument();
    // Can't set a value that is too high to be reasonable
    if (_minActiveBalance >= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions();

    emit MinBalance(minActiveBalance, _minActiveBalance);
    minActiveBalance = _minActiveBalance;
  }

  // This function allows the nonstakers role to claim tokens owed to them by a specific protocol
  /// @notice Choose an `_amount` of tokens that nonstakers (`_receiver` address) will receive from `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens
  /// @param _receiver Address to receive tokens
  /// @dev Only callable by nonstakers role
  function nonStakersClaim(
    bytes32 _protocol,
    uint256 _amount,
    address _receiver
  ) external override whenNotPaused {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_amount == uint256(0)) revert ZeroArgument();
    if (_receiver == address(0)) revert ZeroArgument();
    // Only the nonstakers role (multisig or contract) can pull the funds
    if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized();

    // Call can't be executed on protocol that is removed
    if (protocolAgent_[_protocol] != address(0)) {
      // Updates the amount that nonstakers can claim from this protocol
      _settleProtocolDebt(_protocol);
    }

    // Sets balance to the amount that is claimable by nonstakers for this specific protocol
    uint256 balance = nonStakersClaimableByProtocol[_protocol];
    // If the amount requested is more than what's owed to nonstakers, revert
    if (_amount > balance) revert InsufficientBalance(_protocol);

    // Sets the claimable amount to whatever is left over after this amount is pulled
    nonStakersClaimableByProtocol[_protocol] = balance - _amount;
    // Transfers the amount requested to the `_receiver` address
    token.safeTransfer(_receiver, _amount);
  }

  // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)
  /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address
  /// @dev Callable by everyone
  /// @dev Funds will be transferred to Sherlock core contract
  function claimPremiumsForStakers() external override whenNotPaused {
    // Gets address of core Sherlock contract
    address sherlock = address(sherlockCore);
    // Revert if core Sherlock contract not initialized yet
    if (sherlock == address(0)) revert InvalidConditions();

    // claimablePremiums is different from _settleTotalDebt() because it does not change state
    // Retrieves current amount of all premiums that are owed to stakers
    uint256 amount = claimablePremiums();

    // Transfers all the premiums owed to stakers to the Sherlock core contract
    if (amount != 0) {
      // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out
      lastClaimablePremiumsForStakers = 0;
      lastAccountedGlobal = block.timestamp;
      token.safeTransfer(sherlock, amount);
    }
  }

  // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts
  /// @param _protocol Protocol identifier
  /// @return current and previous are the current and previous coverage amounts for this protocol
  // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)
  function coverageAmounts(bytes32 _protocol)
    external
    view
    override
    returns (uint256 current, uint256 previous)
  {
    // Checks to see if the protocol has an active protocolAgent (protocol not removed)
    // OR checks to see if the removed protocol is still within the claim window
    // If so, gives the current and previous coverage, otherwise throws an error
    if (
      protocolAgent_[_protocol] != address(0) ||
      block.timestamp <= removedProtocolClaimDeadline[_protocol]
    ) {
      return (currentCoverage[_protocol], previousCoverage[_protocol]);
    }

    revert ProtocolNotExists(_protocol);
  }

  /// @notice Add a new protocol to Sherlock
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Address able to submit a claim on behalf of the protocol
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Adding a protocol allows the `_protocolAgent` to submit a claim
  /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point
  /// @dev `_nonStakers` is scaled by 10**18
  /// @dev Only callable by governance
  function protocolAdd(
    bytes32 _protocol,
    address _protocolAgent,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) external override onlyOwner {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Checks to make sure the protocol doesn't exist already
    if (protocolAgent_[_protocol] != address(0)) revert InvalidConditions();

    // Updates the protocol agent and passes in the old agent which is 0 address in this case
    _setProtocolAgent(_protocol, address(0), _protocolAgent);

    // Delete mappings that are potentially non default values
    // From previous time protocol was added/removed
    delete removedProtocolClaimDeadline[_protocol];
    delete removedProtocolAgent[_protocol];
    delete currentCoverage[_protocol];
    delete previousCoverage[_protocol];

    emit ProtocolAdded(_protocol);

    // Most of the logic for actually adding a protocol in this function
    protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Update info regarding a protocol
  /// @param _protocol Protocol identifier
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Only callable by governance
  /// @dev `_nonStakers` can be 0
  function protocolUpdate(
    bytes32 _protocol,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) public override onlyOwner {
    if (_coverage == bytes32(0)) revert ZeroArgument();
    if (_nonStakers > HUNDRED_PERCENT) revert InvalidArgument();
    if (_coverageAmount == uint256(0)) revert ZeroArgument();

    // Checks to make sure the protocol has been assigned a protocol agent
    _verifyProtocolExists(_protocol);

    // Subtracts the accrued debt from a protocol's active balance (if any)
    // Updates the amount that can be claimed by nonstakers
    _settleProtocolDebt(_protocol);

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    // Gets the premium per second for this protocol
    uint256 premium = premiums_[_protocol];

    // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be)
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      premium,
      premium,
      nonStakersPercentage[_protocol],
      _nonStakers,
      allPremiumsPerSecToStakers
    );

    // Updates the stored value of percentage of premiums that go to nonstakers
    nonStakersPercentage[_protocol] = _nonStakers;

    // Updates previous coverage and current coverage amounts
    previousCoverage[_protocol] = currentCoverage[_protocol];
    currentCoverage[_protocol] = _coverageAmount;

    emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Remove a protocol from coverage
  /// @param _protocol Protocol identifier
  /// @dev Before removing a protocol the premium must be 0
  /// @dev Removing a protocol basically stops the `_protocolAgent` from being active (can still submit claims until claim deadline though)
  /// @dev Pays off debt + sends remaining balance to protocol agent
  /// @dev This call should be subject to a timelock
  /// @dev Only callable by governance
  function protocolRemove(bytes32 _protocol) external override onlyOwner {
    // checks to make sure the protocol actually has a protocol agent
    address agent = _verifyProtocolExists(_protocol);

    // Removes a protocol from Sherlock and cleans up its data
    // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made
    _forceRemoveProtocol(_protocol, agent);
  }

  /// @notice Remove a protocol with insufficient active balance
  /// @param _protocol Protocol identifier
  // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function
  function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {
    address agent = _verifyProtocolExists(_protocol);

    // Gets the latest value of the active balance at this protocol
    _settleProtocolDebt(_protocol);
    // Sets latest value of active balance to remainingBalance variable
    uint256 remainingBalance = activeBalances[_protocol];

    // This means the protocol still has adequate active balance and thus cannot be removed
    if (remainingBalance >= minActiveBalance) revert InvalidConditions();

    // Sets the protocol's active balance to 0
    delete activeBalances[_protocol];
    // Removes the protocol from coverage
    _forceRemoveProtocol(_protocol, agent);

    if (remainingBalance != 0) {
      // sends the remaining balance to msg.sender
      token.safeTransfer(msg.sender, remainingBalance);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);
  }

  /// @notice Calculate if arb is possible and what the reward would be
  /// @param _protocol Protocol identifier
  /// @return arbAmount Amount reward for arbing
  /// @return able Indicator if arb call is even possible
  /// @dev Doesn't subtract the current protocol debt from the active balance
  function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)
    internal
    view
    returns (uint256 arbAmount, bool able)
  {
    uint256 secondsLeft = _secondsOfCoverageLeft(_protocol);

    // If arb is not possible return false
    if (secondsLeft >= MIN_SECONDS_OF_COVERAGE) return (0, false);

    // This percentage scales over time
    // Reaches 100% on 0 seconds of coverage left
    uint256 percentageScaled = HUNDRED_PERCENT -
      (secondsLeft * HUNDRED_PERCENT) /
      MIN_SECONDS_OF_COVERAGE;

    able = true;
    arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;
  }

  /// @notice Removes a protocol with insufficent seconds of coverage left
  /// @param _protocol Protocol identifier
  // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second
  function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {
    // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings
    address agent = _verifyProtocolExists(_protocol);

    // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance()
    // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance()
    // But when removing based on seconds of coverage left, the remainingBalance could still be quite large
    // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance
    // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%)
    _settleProtocolDebt(_protocol);
    (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol);
    if (able == false) revert InvalidConditions();

    if (arbAmount != 0) {
      // subtracts the amount that will be paid to the arb from the active balance
      activeBalances[_protocol] -= arbAmount;
    }

    // Removes the protocol from coverage
    // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above
    _forceRemoveProtocol(_protocol, agent);

    // Done after removing protocol to mitigate reentrency pattern
    // (In case token allows callback)
    if (arbAmount != 0) {
      token.safeTransfer(msg.sender, arbAmount);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);
  }

  /// @notice Set premium of `_protocol` to `_premium`
  /// @param _protocol Protocol identifier
  /// @param _premium Amount of premium `_protocol` pays per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {
    // Checks to see if protocol has a protocol agent
    _verifyProtocolExists(_protocol);

    // Updates individual protocol's premium and allPremiumsPerSecToStakers
    _setSingleAndGlobalProtocolPremium(_protocol, _premium);
  }

  /// @notice Set premium of multiple protocols
  /// @param _protocol Array of protocol identifiers
  /// @param _premium Array of premium amounts protocols pay per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)
    external
    override
    onlyOwner
  {
    // Checks to make sure there are an equal amount of entries in each array
    if (_protocol.length != _premium.length) revert UnequalArrayLength();
    if (_protocol.length == 0) revert InvalidArgument();

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;

    // Loops through the array of protocols and checks to make sure each has a protocol agent assigned
    for (uint256 i; i < _protocol.length; i++) {
      _verifyProtocolExists(_protocol[i]);

      // Sets the protocol premium for that specific protocol
      // Function returns the old premium and nonStakerPercentage for that specific protocol
      (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
        _protocol[i],
        _premium[i]
      );

      // Calculates the new global premium which adds up all premiums paid by all protocols
      allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(
        oldPremiumPerSecond,
        _premium[i],
        nonStakerPercentage,
        nonStakerPercentage,
        allPremiumsPerSecToStakers_
      );
    }

    // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value
    allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;
  }

  // This is how protocols pay for coverage by increasing their active balance
  /// @notice Deposits `_amount` of token to the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to deposit
  /// @dev Approval should be made before calling
  function depositToActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    _verifyProtocolExists(_protocol);

    // Transfers _amount to this contract
    token.safeTransferFrom(msg.sender, address(this), _amount);
    // Increases the active balance of the protocol by _amount
    activeBalances[_protocol] += _amount;

    emit ProtocolBalanceDeposited(_protocol, _amount);
  }

  // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)
  // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)
  /// @notice Withdraws `_amount` of token from the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to withdraw
  /// @dev Only protocol agent is able to withdraw
  /// @dev Balance can be withdrawn up until 7 days worth of active balance
  function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    // Only the protocol agent can call this function
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Updates the active balance of the protocol
    _settleProtocolDebt(_protocol);

    // Sets currentBalance to the active balance of the protocol
    uint256 currentBalance = activeBalances[_protocol];
    // Reverts if trying to withdraw more than the active balance
    if (_amount > currentBalance) revert InsufficientBalance(_protocol);

    // Removes the _amount to be withdrawn from the active balance
    activeBalances[_protocol] = currentBalance - _amount;
    // Reverts if a protocol has less than 7 days worth of active balance left
    if (_secondsOfCoverageLeft(_protocol) < MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);

    // Transfers the amount to the msg.sender (protocol agent)
    token.safeTransfer(msg.sender, _amount);
    emit ProtocolBalanceWithdrawn(_protocol, _amount);
  }

  /// @notice Transfer protocol agent role
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Account able to submit a claim on behalf of the protocol
  /// @dev Only the active protocolAgent is able to transfer the role
  function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)
    external
    override
    whenNotPaused
  {
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Can't set the new protocol agent to the caller address
    if (msg.sender == _protocolAgent) revert InvalidArgument();
    // Because the caller must be the current protocol agent
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Sets the protocol agent to the new address
    _setProtocolAgent(_protocol, msg.sender, _protocolAgent);
  }

  /// @notice Function used to check if this is the current active protocol manager
  /// @return Boolean indicating it's active
  /// @dev If inactive the owner can pull all ERC20s and ETH
  /// @dev Will be checked by calling the sherlock contract
  function isActive() public view returns (bool) {
    return address(sherlockCore.sherlockProtocolManager()) == address(this);
  }

  // Only contract owner can call this
  // Sends all specified tokens in this contract to the receiver's address (as well as ETH)
  function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {
    if (_receiver == address(0)) revert ZeroArgument();
    // This contract must NOT be the current assigned protocol manager contract
    if (isActive()) revert InvalidConditions();
    // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH
    _sweep(_receiver, _extraTokens);
  }
}
.]

Let's

[2024-25-08 10:58:53 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import './Manager.sol'; import '../interfaces/managers/ISherlockProtocolManager.sol'; /// @title Sherlock core interface for protocols /// @author Evert Kors // This is the contract that manages covered protocols contract SherlockProtocolManager is ISherlockProtocolManager, Manager {   using SafeERC20 for IERC20; // Represents the token that protocols pay with (currently USDC)   IERC20 public immutable token; // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed   uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc // A removed protocol is still able to make a claim for this amount of time after its removal   uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days; // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance   uint256 public constant MIN_SECONDS_LEFT = 7 days; // Convenient for percentage calculations   uint256 internal constant HUNDRED_PERCENT = 10**18; // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage   // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying   uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours; // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)   mapping(bytes32 =&gt; address) internal protocolAgent_; // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)   mapping(bytes32 =&gt; uint256) internal nonStakersPercentage; // The premium per second paid by each protocol is stored in this mapping   mapping(bytes32 =&gt; uint256) internal premiums_; // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.   // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not   mapping(bytes32 =&gt; uint256) internal activeBalances; // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol   mapping(bytes32 =&gt; uint256) internal lastAccountedEachProtocol; // The amount that can be claimed by nonstakers for each protocol   // We need this value so we can track how much payment is coming from each protocol   mapping(bytes32 =&gt; uint256) internal nonStakersClaimableByProtocol; // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)   uint256 internal lastAccountedGlobal; // This is the total amount of premiums paid (per second) by all the covered protocols (added up)   uint256 internal allPremiumsPerSecToStakers; // This is the amount that was claimable by stakers the last time the accounting was run   // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date   uint256 internal lastClaimablePremiumsForStakers; // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage   // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)   uint256 public override minActiveBalance; // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)   mapping(bytes32 =&gt; uint256) internal removedProtocolClaimDeadline; // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)   mapping(bytes32 =&gt; address) internal removedProtocolAgent; // Current amount of coverage (i.e. 20M USDC) for a protocol   mapping(bytes32 =&gt; uint256) internal currentCoverage; // Previous amount of coverage for a protocol   // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount   mapping(bytes32 =&gt; uint256) internal previousCoverage; // Setting the token to USDC   constructor(IERC20 _token) {     if (address(_token) == address(0)) revert ZeroArgument();     token = _token;   } // Modifier used to ensure a protocol exists (has been instantiated and not removed)   modifier protocolExists(bytes32 protocol) {     _verifyProtocolExists(_protocol);     ;   } /// @notice View current protocolAgent of _protocol   /// @param protocol Protocol identifier   /// @return Address able to submit claims   function protocolAgent(bytes32 _protocol) external view override returns (address) {     address agent = protocolAgent[_protocol];     if (agent != address(0)) return agent; // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned // Note: Old protocol agent will never be address(0) if (block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]) {   return removedProtocolAgent[_protocol]; }  // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned revert ProtocolNotExists(_protocol);  } // Checks if the protocol exists, then returns the current premium per second being charged   /// @notice View current premium of protocol   /// @param protocol Protocol identifier   /// @return Amount of premium _protocol pays per second   function premium(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return premiums[_protocol];   } // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)   // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)   function verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {     _protocolAgent = protocolAgent[_protocol];     if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);   } //   // View methods   // // Calcs the debt accrued by the protocol since it last had an accounting update   // This is the amount that needs to be removed from a protocol's active balance   function calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {     return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums[_protocol];   } /// @notice View the amount nonstakers can claim from this protocol   /// @param _protocol Protocol identifier   /// @return Amount of tokens claimable by nonstakers   /// @dev this reads from a storage variable + (now-lastsettled) * premiums   // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]   // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed   function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {     // Calcs the debt of a protocol since the last accounting update     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     // Gets the active balance of the protocol     uint256 balance = activeBalances[_protocol];     // The debt should never be higher than the balance (only happens if the arbitrages fail)     if (debt &gt; balance) debt = balance; // Adds the incremental claimable amount owed to nonstakers to the total claimable amount return   nonStakersClaimableByProtocol[_protocol] +   (nonStakersPercentage[_protocol] * debt) /   HUNDRED_PERCENT;  } /// @notice View current amount of all premiums that are owed to stakers   /// @return Premiums claimable   /// @dev Will increase every block   /// @dev base + (now - last_settled) * ps   function claimablePremiums() public view override returns (uint256) {     // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)     return       lastClaimablePremiumsForStakers +       (block.timestamp - lastAccountedGlobal) *       allPremiumsPerSecToStakers;   } /// @notice View seconds of coverage left for _protocol before it runs out of active balance   /// @param _protocol Protocol identifier   /// @return Seconds of coverage left   function secondsOfCoverageLeft(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return _secondsOfCoverageLeft(_protocol);   } // Helper function to return seconds of coverage left for a protocol   // Gets the current active balance of the protocol and divides by the premium per second for the protocol   function secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {     uint256 premium = premiums[_protocol];     if (premium == 0) return 0;     return _activeBalance(_protocol) / premium;   } /// @notice View current active balance of covered protocol   /// @param _protocol Protocol identifier   /// @return Active balance   /// @dev Accrued debt is subtracted from the stored active balance   function activeBalance(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return _activeBalance(_protocol);   } // Helper function to calc the active balance of a protocol at current time   function _activeBalance(bytes32 _protocol) internal view returns (uint256) {     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     uint256 balance = activeBalances[_protocol];     // The debt should never be higher than the balance (only happens if the arbitrages fail)     if (debt &gt; balance) return 0;     return balance - debt;   } //   // State methods   // /// @notice Helps set the premium per second for an individual protocol   /// @param protocol Protocol identifier   /// @param _premium New premium per second   /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function   function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)     internal     returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)   {     // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers     // Also updates the last accounted timestamp for this protocol     // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings     // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol     nonStakerPercentage = _settleProtocolDebt(_protocol);     // Stores the old premium before it gets updated     oldPremiumPerSecond = premiums[_protocol]; if (oldPremiumPerSecond != _premium) {   // Sets the protocol's premium per second to the new value   premiums_[_protocol] = _premium;   emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium); } // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point // Where arbs would no longer be incentivized to remove the protocol // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems if (_premium != 0 &amp;&amp; _secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_OF_COVERAGE) {   revert InsufficientBalance(_protocol); }  } /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second   /// @param _protocol Protocol identifier   /// @param _premium New premium per second   function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {     // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings     (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(       _protocol,       _premium     );     // Settling the total amount of premiums owed to stakers before a new premium per second gets set     _settleTotalDebt();     // This calculates the new global premium per second that gets paid to stakers     // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function     allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(       oldPremiumPerSecond,       _premium,       nonStakerPercentage,       nonStakerPercentage,       allPremiumsPerSecToStakers     );   } // Internal function to set a new protocolAgent for a specific protocol   // oldAgent is only included as part of emitting an event   function _setProtocolAgent(     bytes32 _protocol,     address _oldAgent,     address _protocolAgent   ) internal {     protocolAgent[_protocol] = _protocolAgent;     emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);   } // Subtracts the accrued debt from a protocol's active balance   // Credits the amount that can be claimed by nonstakers for this protocol   // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings   // Most of this function is dealing with an edge case related to a protocol not being removed by arbs   function settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {     // This calcs the accrued debt of the protocol since it was last updated     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     // This pulls the percentage that is sent to nonstakers     _nonStakerPercentage = nonStakersPercentage[_protocol];     // In case the protocol has accrued debt, this code block will ensure the debt is settled properly     if (debt != 0) {       // Pulls the stored active balance of the protocol       uint256 balance = activeBalances[_protocol];       // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance       // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point       // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage       // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up       if (debt &gt; balance) {         // This error amount represents the magnitude of the mistake         uint256 error = debt - balance;         // Gets the latest value of claimable premiums for stakers         _settleTotalDebt();         // @note to production, set premium first to zero before solving accounting issue.         // otherwise the accounting error keeps increasing         uint256 lastClaimablePremiumsForStakers = lastClaimablePremiumsForStakers;     // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%     uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /       HUNDRED_PERCENT;      // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short     uint256 insufficientTokens;      // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally     // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error     // This first line can be true if claimPremiumsForStakers() has been called and     // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be &gt;0 still     if (claimablePremiumError &gt; lastClaimablePremiumsForStakers_) {       insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;       lastClaimablePremiumsForStakers = 0;     } else {       // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums       // By the amount that was added in error (error) and insufficientTokens = 0       lastClaimablePremiumsForStakers =         lastClaimablePremiumsForStakers_ -         claimablePremiumError;     }      // If two events are thrown, the values need to be summed up for the actual state.     // This means an error of this type will continue until it is handled     emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);     // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case     debt = balance;   }   // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance   activeBalances[_protocol] = balance - debt;   // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol   nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT; } // Updates the last accounted timestamp for this protocol lastAccountedEachProtocol[_protocol] = block.timestamp;  } // Multiplies the total premium per second * number of seconds since the last global accounting update   // And adds it to the total claimable amount for stakers   function _settleTotalDebt() internal {     lastClaimablePremiumsForStakers +=       (block.timestamp - lastAccountedGlobal) *       allPremiumsPerSecToStakers;     lastAccountedGlobal = block.timestamp;   } // Calculates the global premium per second for stakers   // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers   // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones   function _calcGlobalPremiumPerSecForStakers(     uint256 _premiumOld,     uint256 _premiumNew,     uint256 _nonStakerPercentageOld,     uint256 _nonStakerPercentageNew,     uint256 _inMemAllPremiumsPerSecToStakers   ) internal pure returns (uint256) {     return       _inMemAllPremiumsPerSecToStakers +       ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /       HUNDRED_PERCENT -       ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /       HUNDRED_PERCENT;   } // Helper function to remove and clean up a protocol from Sherlock   // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made   function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {     // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol     _setSingleAndGlobalProtocolPremium(_protocol, 0); // Grabs the protocol's active balance uint256 balance = activeBalances[_protocol];  // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent if (balance != 0) {   delete activeBalances[_protocol];   token.safeTransfer(_agent, balance);    emit ProtocolBalanceWithdrawn(_protocol, balance); }  // Sets the protocol agent to zero address (as part of clean up) _setProtocolAgent(_protocol, _agent, address(0));  // Cleans up other mappings for this protocol delete nonStakersPercentage[_protocol]; delete lastAccountedEachProtocol[_protocol]; // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above  // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;  // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked removedProtocolAgent[_protocol] = _agent;  emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0)); emit ProtocolRemoved(_protocol);  } /// @notice Sets the minimum active balance before an arb can remove a protocol   /// @param _minActiveBalance Minimum balance needed (in USDC)   /// @dev Only gov   function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {     // New value cannot be the same as current value     if (minActiveBalance == _minActiveBalance) revert InvalidArgument();     // Can't set a value that is too high to be reasonable     if (_minActiveBalance &gt;= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions(); emit MinBalance(minActiveBalance, _minActiveBalance); minActiveBalance = _minActiveBalance;  } // This function allows the nonstakers role to claim tokens owed to them by a specific protocol   /// @notice Choose an _amount of tokens that nonstakers (_receiver address) will receive from _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens   /// @param _receiver Address to receive tokens   /// @dev Only callable by nonstakers role   function nonStakersClaim(     bytes32 _protocol,     uint256 _amount,     address _receiver   ) external override whenNotPaused {     if (_protocol == bytes32(0)) revert ZeroArgument();     if (_amount == uint256(0)) revert ZeroArgument();     if (_receiver == address(0)) revert ZeroArgument();     // Only the nonstakers role (multisig or contract) can pull the funds     if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized(); // Call can't be executed on protocol that is removed if (protocolAgent_[_protocol] != address(0)) {   // Updates the amount that nonstakers can claim from this protocol   _settleProtocolDebt(_protocol); }  // Sets balance to the amount that is claimable by nonstakers for this specific protocol uint256 balance = nonStakersClaimableByProtocol[_protocol]; // If the amount requested is more than what's owed to nonstakers, revert if (_amount &gt; balance) revert InsufficientBalance(_protocol);  // Sets the claimable amount to whatever is left over after this amount is pulled nonStakersClaimableByProtocol[_protocol] = balance - _amount; // Transfers the amount requested to the `_receiver` address token.safeTransfer(_receiver, _amount);  } // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)   /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address   /// @dev Callable by everyone   /// @dev Funds will be transferred to Sherlock core contract   function claimPremiumsForStakers() external override whenNotPaused {     // Gets address of core Sherlock contract     address sherlock = address(sherlockCore);     // Revert if core Sherlock contract not initialized yet     if (sherlock == address(0)) revert InvalidConditions(); // claimablePremiums is different from _settleTotalDebt() because it does not change state // Retrieves current amount of all premiums that are owed to stakers uint256 amount = claimablePremiums();  // Transfers all the premiums owed to stakers to the Sherlock core contract if (amount != 0) {   // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out   lastClaimablePremiumsForStakers = 0;   lastAccountedGlobal = block.timestamp;   token.safeTransfer(sherlock, amount); }  } // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts   /// @param protocol Protocol identifier   /// @return current and previous are the current and previous coverage amounts for this protocol   // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)   function coverageAmounts(bytes32 _protocol)     external     view     override     returns (uint256 current, uint256 previous)   {     // Checks to see if the protocol has an active protocolAgent (protocol not removed)     // OR checks to see if the removed protocol is still within the claim window     // If so, gives the current and previous coverage, otherwise throws an error     if (       protocolAgent[_protocol] != address(0) ||       block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]     ) {       return (currentCoverage[_protocol], previousCoverage[_protocol]);     } revert ProtocolNotExists(_protocol);  } /// @notice Add a new protocol to Sherlock   /// @param protocol Protocol identifier   /// @param _protocolAgent Address able to submit a claim on behalf of the protocol   /// @param _coverage Hash referencing the active coverage agreement   /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 1018   /// @param _coverageAmount Max amount claimable by this protocol   /// @dev Adding a protocol allows the _protocolAgent to submit a claim   /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point   /// @dev _nonStakers is scaled by 1018   /// @dev Only callable by governance   function protocolAdd(     bytes32 _protocol,     address _protocolAgent,     bytes32 _coverage,     uint256 _nonStakers,     uint256 _coverageAmount   ) external override onlyOwner {     if (_protocol == bytes32(0)) revert ZeroArgument();     if (_protocolAgent == address(0)) revert ZeroArgument();     // Checks to make sure the protocol doesn't exist already     if (protocolAgent[_protocol] != address(0)) revert InvalidConditions(); // Updates the protocol agent and passes in the old agent which is 0 address in this case _setProtocolAgent(_protocol, address(0), _protocolAgent);  // Delete mappings that are potentially non default values // From previous time protocol was added/removed delete removedProtocolClaimDeadline[_protocol]; delete removedProtocolAgent[_protocol]; delete currentCoverage[_protocol]; delete previousCoverage[_protocol];  emit ProtocolAdded(_protocol);  // Most of the logic for actually adding a protocol in this function protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);  } /// @notice Update info regarding a protocol   /// @param _protocol Protocol identifier   /// @param _coverage Hash referencing the active coverage agreement   /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18   /// @param _coverageAmount Max amount claimable by this protocol   /// @dev Only callable by governance   /// @dev _nonStakers can be 0   function protocolUpdate(     bytes32 _protocol,     bytes32 _coverage,     uint256 _nonStakers,     uint256 _coverageAmount   ) public override onlyOwner {     if (_coverage == bytes32(0)) revert ZeroArgument();     if (_nonStakers &gt; HUNDRED_PERCENT) revert InvalidArgument();     if (_coverageAmount == uint256(0)) revert ZeroArgument(); // Checks to make sure the protocol has been assigned a protocol agent _verifyProtocolExists(_protocol);  // Subtracts the accrued debt from a protocol's active balance (if any) // Updates the amount that can be claimed by nonstakers _settleProtocolDebt(_protocol);  // Updates the global claimable amount for stakers _settleTotalDebt();  // Gets the premium per second for this protocol uint256 premium = premiums_[_protocol];  // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be) allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(   premium,   premium,   nonStakersPercentage[_protocol],   _nonStakers,   allPremiumsPerSecToStakers );  // Updates the stored value of percentage of premiums that go to nonstakers nonStakersPercentage[_protocol] = _nonStakers;  // Updates previous coverage and current coverage amounts previousCoverage[_protocol] = currentCoverage[_protocol]; currentCoverage[_protocol] = _coverageAmount;  emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);  } /// @notice Remove a protocol from coverage   /// @param _protocol Protocol identifier   /// @dev Before removing a protocol the premium must be 0   /// @dev Removing a protocol basically stops the _protocolAgent from being active (can still submit claims until claim deadline though)   /// @dev Pays off debt + sends remaining balance to protocol agent   /// @dev This call should be subject to a timelock   /// @dev Only callable by governance   function protocolRemove(bytes32 _protocol) external override onlyOwner {     // checks to make sure the protocol actually has a protocol agent     address agent = _verifyProtocolExists(_protocol); // Removes a protocol from Sherlock and cleans up its data // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made _forceRemoveProtocol(_protocol, agent);  } /// @notice Remove a protocol with insufficient active balance   /// @param _protocol Protocol identifier   // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function   function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {     address agent = _verifyProtocolExists(_protocol); // Gets the latest value of the active balance at this protocol _settleProtocolDebt(_protocol); // Sets latest value of active balance to remainingBalance variable uint256 remainingBalance = activeBalances[_protocol];  // This means the protocol still has adequate active balance and thus cannot be removed if (remainingBalance &gt;= minActiveBalance) revert InvalidConditions();  // Sets the protocol's active balance to 0 delete activeBalances[_protocol]; // Removes the protocol from coverage _forceRemoveProtocol(_protocol, agent);  if (remainingBalance != 0) {   // sends the remaining balance to msg.sender   token.safeTransfer(msg.sender, remainingBalance); } emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);  } /// @notice Calculate if arb is possible and what the reward would be   /// @param _protocol Protocol identifier   /// @return arbAmount Amount reward for arbing   /// @return able Indicator if arb call is even possible   /// @dev Doesn't subtract the current protocol debt from the active balance   function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)     internal     view     returns (uint256 arbAmount, bool able)   {     uint256 secondsLeft = _secondsOfCoverageLeft(_protocol); // If arb is not possible return false if (secondsLeft &gt;= MIN_SECONDS_OF_COVERAGE) return (0, false);  // This percentage scales over time // Reaches 100% on 0 seconds of coverage left uint256 percentageScaled = HUNDRED_PERCENT -   (secondsLeft * HUNDRED_PERCENT) /   MIN_SECONDS_OF_COVERAGE;  able = true; arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;  } /// @notice Removes a protocol with insufficent seconds of coverage left   /// @param _protocol Protocol identifier   // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second   function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {     // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings     address agent = _verifyProtocolExists(_protocol); // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance() // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance() // But when removing based on seconds of coverage left, the remainingBalance could still be quite large // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%) _settleProtocolDebt(_protocol); (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol); if (able == false) revert InvalidConditions();  if (arbAmount != 0) {   // subtracts the amount that will be paid to the arb from the active balance   activeBalances[_protocol] -= arbAmount; }  // Removes the protocol from coverage // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above _forceRemoveProtocol(_protocol, agent);  // Done after removing protocol to mitigate reentrency pattern // (In case token allows callback) if (arbAmount != 0) {   token.safeTransfer(msg.sender, arbAmount); } emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);  } /// @notice Set premium of _protocol to _premium   /// @param _protocol Protocol identifier   /// @param _premium Amount of premium _protocol pays per second   /// @dev The value 0 would mean inactive coverage   /// @dev Only callable by governance   function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {     // Checks to see if protocol has a protocol agent     _verifyProtocolExists(_protocol); // Updates individual protocol's premium and allPremiumsPerSecToStakers _setSingleAndGlobalProtocolPremium(_protocol, _premium);  } /// @notice Set premium of multiple protocols   /// @param _protocol Array of protocol identifiers   /// @param _premium Array of premium amounts protocols pay per second   /// @dev The value 0 would mean inactive coverage   /// @dev Only callable by governance   function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)     external     override     onlyOwner   {     // Checks to make sure there are an equal amount of entries in each array     if (_protocol.length != _premium.length) revert UnequalArrayLength();     if (_protocol.length == 0) revert InvalidArgument(); // Updates the global claimable amount for stakers _settleTotalDebt();  uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;  // Loops through the array of protocols and checks to make sure each has a protocol agent assigned for (uint256 i; i &lt; _protocol.length; i++) {   _verifyProtocolExists(_protocol[i]);    // Sets the protocol premium for that specific protocol   // Function returns the old premium and nonStakerPercentage for that specific protocol   (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(     _protocol[i],     _premium[i]   );    // Calculates the new global premium which adds up all premiums paid by all protocols   allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(     oldPremiumPerSecond,     _premium[i],     nonStakerPercentage,     nonStakerPercentage,     allPremiumsPerSecToStakers_   ); }  // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;  } // This is how protocols pay for coverage by increasing their active balance   /// @notice Deposits _amount of token to the active balance of _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens to deposit   /// @dev Approval should be made before calling   function depositToActiveBalance(bytes32 _protocol, uint256 _amount)     external     override     whenNotPaused   {     if (_amount == uint256(0)) revert ZeroArgument();     _verifyProtocolExists(_protocol); // Transfers _amount to this contract token.safeTransferFrom(msg.sender, address(this), _amount); // Increases the active balance of the protocol by _amount activeBalances[_protocol] += _amount;  emit ProtocolBalanceDeposited(_protocol, _amount);  } // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)   // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)   /// @notice Withdraws _amount of token from the active balance of _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens to withdraw   /// @dev Only protocol agent is able to withdraw   /// @dev Balance can be withdrawn up until 7 days worth of active balance   function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)     external     override     whenNotPaused   {     if (_amount == uint256(0)) revert ZeroArgument();     // Only the protocol agent can call this function     if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized(); // Updates the active balance of the protocol _settleProtocolDebt(_protocol);  // Sets currentBalance to the active balance of the protocol uint256 currentBalance = activeBalances[_protocol]; // Reverts if trying to withdraw more than the active balance if (_amount &gt; currentBalance) revert InsufficientBalance(_protocol);  // Removes the _amount to be withdrawn from the active balance activeBalances[_protocol] = currentBalance - _amount; // Reverts if a protocol has less than 7 days worth of active balance left if (_secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);  // Transfers the amount to the msg.sender (protocol agent) token.safeTransfer(msg.sender, _amount); emit ProtocolBalanceWithdrawn(_protocol, _amount);  } /// @notice Transfer protocol agent role   /// @param _protocol Protocol identifier   /// @param _protocolAgent Account able to submit a claim on behalf of the protocol   /// @dev Only the active protocolAgent is able to transfer the role   function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)     external     override     whenNotPaused   {     if (_protocolAgent == address(0)) revert ZeroArgument();     // Can't set the new protocol agent to the caller address     if (msg.sender == _protocolAgent) revert InvalidArgument();     // Because the caller must be the current protocol agent     if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized(); // Sets the protocol agent to the new address _setProtocolAgent(_protocol, msg.sender, _protocolAgent);  } /// @notice Function used to check if this is the current active protocol manager   /// @return Boolean indicating it's active   /// @dev If inactive the owner can pull all ERC20s and ETH   /// @dev Will be checked by calling the sherlock contract   function isActive() public view returns (bool) {     return address(sherlockCore.sherlockProtocolManager()) == address(this);   } // Only contract owner can call this   // Sends all specified tokens in this contract to the receiver's address (as well as ETH)   function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {     if (_receiver == address(0)) revert ZeroArgument();     // This contract must NOT be the current assigned protocol manager contract     if (isActive()) revert InvalidConditions();     // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH     _sweep(_receiver, _extraTokens);   } } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: // SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n/***********\\n Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x)\n Sherlock Protocol: https://sherlock.xyz\n/***********/\nimport \'./Manager.sol\';\nimport \'../interfaces/managers/ISherlockProtocolManager.sol\';\n/// @title Sherlock core interface for protocols\n/// @author Evert Kors\n// This is the contract that manages covered protocols\ncontract SherlockProtocolManager is ISherlockProtocolManager, Manager {\n  using SafeERC20 for IERC20;\n  // Represents the token that protocols pay with (currently USDC)\n  IERC20 public immutable token;\n  // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed\n  uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 106; // 30k usdc\n  // A removed protocol is still able to make a claim for this amount of time after its removal\n  uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days;\n  // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance\n  uint256 public constant MIN_SECONDS_LEFT = 7 days;\n  // Convenient for percentage calculations\n  uint256 internal constant HUNDRED_PERCENT = 1018;\n  // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage\n  // This value is calculated from a protocol\'s active balance divided by the premium per second the protocol is paying\n  uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours;\n  // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)\n  mapping(bytes32 =&gt; address) internal protocolAgent_;\n  // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)\n  mapping(bytes32 =&gt; uint256) internal nonStakersPercentage;\n  // The premium per second paid by each protocol is stored in this mapping\n  mapping(bytes32 =&gt; uint256) internal premiums_;\n  // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.\n  // This "active balance" is really just an accounting concept, doesn\'t mean tokens have been transferred or not\n  mapping(bytes32 =&gt; uint256) internal activeBalances;\n  // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol\n  mapping(bytes32 =&gt; uint256) internal lastAccountedEachProtocol;\n  // The amount that can be claimed by nonstakers for each protocol\n  // We need this value so we can track how much payment is coming from each protocol\n  mapping(bytes32 =&gt; uint256) internal nonStakersClaimableByProtocol;\n  // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)\n  uint256 internal lastAccountedGlobal;\n  // This is the total amount of premiums paid (per second) by all the covered protocols (added up)\n  uint256 internal allPremiumsPerSecToStakers;\n  // This is the amount that was claimable by stakers the last time the accounting was run\n  // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date\n  uint256 internal lastClaimablePremiumsForStakers;\n  // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage\n  // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)\n  uint256 public override minActiveBalance;\n  // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)\n  mapping(bytes32 =&gt; uint256) internal removedProtocolClaimDeadline;\n  // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)\n  mapping(bytes32 =&gt; address) internal removedProtocolAgent;\n  // Current amount of coverage (i.e. 20M USDC) for a protocol\n  mapping(bytes32 =&gt; uint256) internal currentCoverage;\n  // Previous amount of coverage for a protocol\n  // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount\n  mapping(bytes32 =&gt; uint256) internal previousCoverage;\n  // Setting the token to USDC\n  constructor(IERC20 token) {\n    if (address(_token) == address(0)) revert ZeroArgument();\n    token = _token;\n  }\n  // Modifier used to ensure a protocol exists (has been instantiated and not removed)\n  modifier protocolExists(bytes32 _protocol) {\n    _verifyProtocolExists(_protocol);\n    ;\n  }\n  /// @notice View current protocolAgent of _protocol\n  /// @param protocol Protocol identifier\n  /// @return Address able to submit claims\n  function protocolAgent(bytes32 _protocol) external view override returns (address) {\n    address agent = protocolAgent[protocol];\n    if (agent != address(0)) return agent;\n    // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned\n    // Note: Old protocol agent will never be address(0)\n    if (block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]) {\n      return removedProtocolAgent[_protocol];\n    }\n    // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned\n    revert ProtocolNotExists(_protocol);\n  }\n  // Checks if the protocol exists, then returns the current premium per second being charged\n  /// @notice View current premium of protocol\n  /// @param _protocol Protocol identifier\n  /// @return Amount of premium _protocol pays per second\n  function premium(bytes32 _protocol)\n    external\n    view\n    override\n    protocolExists(_protocol)\n    returns (uint256)\n  {\n    return premiums[protocol];\n  }\n  // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)\n  // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)\n  function _verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {\n    _protocolAgent = protocolAgent[protocol];\n    if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);\n  }\n  //\n  // View methods\n  //\n  // Calcs the debt accrued by the protocol since it last had an accounting update\n  // This is the amount that needs to be removed from a protocol\'s active balance\n  function _calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {\n    return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums[protocol];\n  }\n  /// @notice View the amount nonstakers can claim from this protocol\n  /// @param _protocol Protocol identifier\n  /// @return Amount of tokens claimable by nonstakers\n  /// @dev this reads from a storage variable + (now-lastsettled) * premiums\n  // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]\n  // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn\'t change since the protocol has been removed\n  function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {\n    // Calcs the debt of a protocol since the last accounting update\n    uint256 debt = _calcIncrementalProtocolDebt(_protocol);\n    // Gets the active balance of the protocol\n    uint256 balance = activeBalances[_protocol];\n    // The debt should never be higher than the balance (only happens if the arbitrages fail)\n    if (debt &gt; balance) debt = balance;\n    // Adds the incremental claimable amount owed to nonstakers to the total claimable amount\n    return\n      nonStakersClaimableByProtocol[_protocol] +\n      (nonStakersPercentage[_protocol] * debt) /\n      HUNDRED_PERCENT;\n  }\n  /// @notice View current amount of all premiums that are owed to stakers\n  /// @return Premiums claimable\n  /// @dev Will increase every block\n  /// @dev base + (now - last_settled) * ps\n  function claimablePremiums() public view override returns (uint256) {\n    // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)\n    return\n      lastClaimablePremiumsForStakers +\n      (block.timestamp - lastAccountedGlobal) \n      allPremiumsPerSecToStakers;\n  }\n  /// @notice View seconds of coverage left for _protocol before it runs out of active balance\n  /// @param protocol Protocol identifier\n  /// @return Seconds of coverage left\n  function secondsOfCoverageLeft(bytes32 _protocol)\n    external\n    view\n    override\n    protocolExists(_protocol)\n    returns (uint256)\n  {\n    return _secondsOfCoverageLeft(_protocol);\n  }\n  // Helper function to return seconds of coverage left for a protocol\n  // Gets the current active balance of the protocol and divides by the premium per second for the protocol\n  function _secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {\n    uint256 premium = premiums[protocol];\n    if (premium == 0) return 0;\n    return _activeBalance(_protocol) / premium;\n  }\n  /// @notice View current active balance of covered protocol\n  /// @param _protocol Protocol identifier\n  /// @return Active balance\n  /// @dev Accrued debt is subtracted from the stored active balance\n  function activeBalance(bytes32 _protocol)\n    external\n    view\n    override\n    protocolExists(_protocol)\n    returns (uint256)\n  {\n    return _activeBalance(_protocol);\n  }\n  // Helper function to calc the active balance of a protocol at current time\n  function _activeBalance(bytes32 _protocol) internal view returns (uint256) {\n    uint256 debt = _calcIncrementalProtocolDebt(_protocol);\n    uint256 balance = activeBalances[_protocol];\n    // The debt should never be higher than the balance (only happens if the arbitrages fail)\n    if (debt &gt; balance) return 0;\n    return balance - debt;\n  }\n  //\n  // State methods\n  //\n  /// @notice Helps set the premium per second for an individual protocol\n  /// @param _protocol Protocol identifier\n  /// @param _premium New premium per second\n  /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function\n  function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)\n    internal\n    returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)\n  {\n    // _settleProtocolDebt() subtracts debt from the protocol\'s active balance and updates the % due to nonstakers\n    // Also updates the last accounted timestamp for this protocol\n    // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings\n    // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol\n    nonStakerPercentage = _settleProtocolDebt(_protocol);\n    // Stores the old premium before it gets updated\n    oldPremiumPerSecond = premiums[protocol];\n    if (oldPremiumPerSecond != _premium) {\n      // Sets the protocol\'s premium per second to the new value\n      premiums[protocol] = _premium;\n      emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium);\n    }\n    // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing\n    // We don\'t need to check the min balance requirement for arbs because that value doesn\'t change like secondsOfCoverageLeft changes\n    // Effectively we just need to make sure we don\'t accidentally run a protocol\'s active balance down below the point\n    // Where arbs would no longer be incentivized to remove the protocol\n    // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems\n    if (_premium != 0 &amp;&amp; _secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_OF_COVERAGE) {\n      revert InsufficientBalance(_protocol);\n    }\n  }\n  /// @notice Sets a single protocol\'s premium per second and also updates the global total of premiums per second\n  /// @param _protocol Protocol identifier\n  /// @param _premium New premium per second\n  function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {\n    // Sets the individual protocol\'s premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings\n    (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(\n      _protocol,\n      _premium\n    );\n    // Settling the total amount of premiums owed to stakers before a new premium per second gets set\n    _settleTotalDebt();\n    // This calculates the new global premium per second that gets paid to stakers\n    // We input the same nonStakerPercentage twice because we simply aren\'t updating that value in this function\n    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(\n      oldPremiumPerSecond,\n      _premium,\n      nonStakerPercentage,\n      nonStakerPercentage,\n      allPremiumsPerSecToStakers\n    );\n  }\n  // Internal function to set a new protocolAgent for a specific protocol\n  // _oldAgent is only included as part of emitting an event\n  function _setProtocolAgent(\n    bytes32 _protocol,\n    address _oldAgent,\n    address _protocolAgent\n  ) internal {\n    protocolAgent[protocol] = _protocolAgent;\n    emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);\n  }\n  // Subtracts the accrued debt from a protocol\'s active balance\n  // Credits the amount that can be claimed by nonstakers for this protocol\n  // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings\n  // Most of this function is dealing with an edge case related to a protocol not being removed by arbs\n  function _settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {\n    // This calcs the accrued debt of the protocol since it was last updated\n    uint256 debt = _calcIncrementalProtocolDebt(_protocol);\n    // This pulls the percentage that is sent to nonstakers\n    _nonStakerPercentage = nonStakersPercentage[_protocol];\n    // In case the protocol has accrued debt, this code block will ensure the debt is settled properly\n    if (debt != 0) {\n      // Pulls the stored active balance of the protocol\n      uint256 balance = activeBalances[_protocol];\n      // This is the start of handling an edge case where arbitragers don\'t remove this protocol before debt becomes greater than active balance\n      // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point\n      // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage\n      // However, if arbs don\'t come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up\n      if (debt &gt; balance) {\n        // This error amount represents the magnitude of the mistake\n        uint256 error = debt - balance;\n        // Gets the latest value of claimable premiums for stakers\n        _settleTotalDebt();\n        // @note to production, set premium first to zero before solving accounting issue.\n        // otherwise the accounting error keeps increasing\n        uint256 lastClaimablePremiumsForStakers = lastClaimablePremiumsForStakers;\n        // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%\n        uint256 claimablePremiumError = ((HUNDRED_PERCENT - nonStakerPercentage) * error) /\n          HUNDRED_PERCENT;\n        // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short\n        uint256 insufficientTokens;\n        // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally\n        // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error\n        // This first line can be true if claimPremiumsForStakers() has been called and\n        // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be &gt;0 still\n        if (claimablePremiumError &gt; lastClaimablePremiumsForStakers) {\n          insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;\n          lastClaimablePremiumsForStakers = 0;\n        } else {\n          // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums\n          // By the amount that was added in error (error) and insufficientTokens = 0\n          lastClaimablePremiumsForStakers =\n            lastClaimablePremiumsForStakers_ -\n            claimablePremiumError;\n        }\n        // If two events are thrown, the values need to be summed up for the actual state.\n        // This means an error of this type will continue until it is handled\n        emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);\n        // We set the debt equal to the balance, and in the next line we effectively set the protocol\'s active balance to 0 in this case\n        debt = balance;\n      }\n      // Subtracts the accrued debt (since last update) from the protocol\'s active balance and updates active balance\n      activeBalances[_protocol] = balance - debt;\n      // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol\n      nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT;\n    }\n    // Updates the last accounted timestamp for this protocol\n    lastAccountedEachProtocol[_protocol] = block.timestamp;\n  }\n  // Multiplies the total premium per second * number of seconds since the last global accounting update\n  // And adds it to the total claimable amount for stakers\n  function _settleTotalDebt() internal {\n    lastClaimablePremiumsForStakers +=\n      (block.timestamp - lastAccountedGlobal) \n      allPremiumsPerSecToStakers;\n    lastAccountedGlobal = block.timestamp;\n  }\n  // Calculates the global premium per second for stakers\n  // Takes a specific protocol\'s old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers\n  // Subtracts out the old values of a protocol\'s premium per second and nonstaker percentage and adds the new ones\n  function _calcGlobalPremiumPerSecForStakers(\n    uint256 _premiumOld,\n    uint256 _premiumNew,\n    uint256 _nonStakerPercentageOld,\n    uint256 _nonStakerPercentageNew,\n    uint256 _inMemAllPremiumsPerSecToStakers\n  ) internal pure returns (uint256) {\n    return\n      _inMemAllPremiumsPerSecToStakers +\n      ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /\n      HUNDRED_PERCENT -\n      ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /\n      HUNDRED_PERCENT;\n  }\n  // Helper function to remove and clean up a protocol from Sherlock\n  // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made\n  function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {\n    // Sets the individual protocol\'s premium to zero and updates the global premium variable for a zero premium at this protocol\n    _setSingleAndGlobalProtocolPremium(_protocol, 0);\n    // Grabs the protocol\'s active balance\n    uint256 balance = activeBalances[_protocol];\n    // If there\'s still some active balance, delete the entry and send the remaining balance to the protocol agent\n    if (balance != 0) {\n      delete activeBalances[_protocol];\n      token.safeTransfer(_agent, balance);\n      emit ProtocolBalanceWithdrawn(_protocol, balance);\n    }\n    // Sets the protocol agent to zero address (as part of clean up)\n    _setProtocolAgent(_protocol, _agent, address(0));\n    // Cleans up other mappings for this protocol\n    delete nonStakersPercentage[_protocol];\n    delete lastAccountedEachProtocol[_protocol];\n    // premiums_ mapping is not deleted here as it\'s already 0 because of the _setSingleAndGlobalProtocolPremium call above\n    // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol\n    removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;\n    // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed\n    // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked\n    removedProtocolAgent[_protocol] = _agent;\n    emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0));\n    emit ProtocolRemoved(_protocol);\n  }\n  /// @notice Sets the minimum active balance before an arb can remove a protocol\n  /// @param _minActiveBalance Minimum balance needed (in USDC)\n  /// @dev Only gov\n  function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {\n    // New value cannot be the same as current value\n    if (minActiveBalance == _minActiveBalance) revert InvalidArgument();\n    // Can\'t set a value that is too high to be reasonable\n    if (_minActiveBalance &gt;= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions();\n    emit MinBalance(minActiveBalance, _minActiveBalance);\n    minActiveBalance = _minActiveBalance;\n  }\n  // This function allows the nonstakers role to claim tokens owed to them by a specific protocol\n  /// @notice Choose an _amount of tokens that nonstakers (_receiver address) will receive from _protocol\n  /// @param _protocol Protocol identifier\n  /// @param _amount Amount of tokens\n  /// @param _receiver Address to receive tokens\n  /// @dev Only callable by nonstakers role\n  function nonStakersClaim(\n    bytes32 _protocol,\n    uint256 _amount,\n    address _receiver\n  ) external override whenNotPaused {\n    if (_protocol == bytes32(0)) revert ZeroArgument();\n    if (_amount == uint256(0)) revert ZeroArgument();\n    if (_receiver == address(0)) revert ZeroArgument();\n    // Only the nonstakers role (multisig or contract) can pull the funds\n    if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized();\n    // Call can\'t be executed on protocol that is removed\n    if (protocolAgent[protocol] != address(0)) {\n      // Updates the amount that nonstakers can claim from this protocol\n      _settleProtocolDebt(_protocol);\n    }\n    // Sets balance to the amount that is claimable by nonstakers for this specific protocol\n    uint256 balance = nonStakersClaimableByProtocol[_protocol];\n    // If the amount requested is more than what\'s owed to nonstakers, revert\n    if (_amount &gt; balance) revert InsufficientBalance(_protocol);\n    // Sets the claimable amount to whatever is left over after this amount is pulled\n    nonStakersClaimableByProtocol[_protocol] = balance - _amount;\n    // Transfers the amount requested to the _receiver address\n    token.safeTransfer(_receiver, _amount);\n  }\n  // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)\n  /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address\n  /// @dev Callable by everyone\n  /// @dev Funds will be transferred to Sherlock core contract\n  function claimPremiumsForStakers() external override whenNotPaused {\n    // Gets address of core Sherlock contract\n    address sherlock = address(sherlockCore);\n    // Revert if core Sherlock contract not initialized yet\n    if (sherlock == address(0)) revert InvalidConditions();\n    // claimablePremiums is different from _settleTotalDebt() because it does not change state\n    // Retrieves current amount of all premiums that are owed to stakers\n    uint256 amount = claimablePremiums();\n    // Transfers all the premiums owed to stakers to the Sherlock core contract\n    if (amount != 0) {\n      // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out\n      lastClaimablePremiumsForStakers = 0;\n      lastAccountedGlobal = block.timestamp;\n      token.safeTransfer(sherlock, amount);\n    }\n  }\n  // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts\n  /// @param _protocol Protocol identifier\n  /// @return current and previous are the current and previous coverage amounts for this protocol\n  // Note For this process to work, a protocol\'s coverage amount should not be set more than once in the span of claim delay period (7 days or something)\n  function coverageAmounts(bytes32 _protocol)\n    external\n    view\n    override\n    returns (uint256 current, uint256 previous)\n  {\n    // Checks to see if the protocol has an active protocolAgent (protocol not removed)\n    // OR checks to see if the removed protocol is still within the claim window\n    // If so, gives the current and previous coverage, otherwise throws an error\n    if (\n      protocolAgent[protocol] != address(0) ||\n      block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]\n    ) {\n      return (currentCoverage[_protocol], previousCoverage[_protocol]);\n    }\n    revert ProtocolNotExists(_protocol);\n  }\n  /// @notice Add a new protocol to Sherlock\n  /// @param _protocol Protocol identifier\n  /// @param _protocolAgent Address able to submit a claim on behalf of the protocol\n  /// @param _coverage Hash referencing the active coverage agreement\n  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 1018\n  /// @param _coverageAmount Max amount claimable by this protocol\n  /// @dev Adding a protocol allows the _protocolAgent to submit a claim\n  /// @dev Coverage is not started yet as the protocol doesn\'t pay a premium at this point\n  /// @dev _nonStakers is scaled by 1018\n  /// @dev Only callable by governance\n  function protocolAdd(\n    bytes32 _protocol,\n    address _protocolAgent,\n    bytes32 _coverage,\n    uint256 _nonStakers,\n    uint256 _coverageAmount\n  ) external override onlyOwner {\n    if (_protocol == bytes32(0)) revert ZeroArgument();\n    if (_protocolAgent == address(0)) revert ZeroArgument();\n    // Checks to make sure the protocol doesn\'t exist already\n    if (protocolAgent[protocol] != address(0)) revert InvalidConditions();\n    // Updates the protocol agent and passes in the old agent which is 0 address in this case\n    _setProtocolAgent(_protocol, address(0), _protocolAgent);\n    // Delete mappings that are potentially non default values\n    // From previous time protocol was added/removed\n    delete removedProtocolClaimDeadline[_protocol];\n    delete removedProtocolAgent[_protocol];\n    delete currentCoverage[_protocol];\n    delete previousCoverage[_protocol];\n    emit ProtocolAdded(_protocol);\n    // Most of the logic for actually adding a protocol in this function\n    protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);\n  }\n  /// @notice Update info regarding a protocol\n  /// @param _protocol Protocol identifier\n  /// @param _coverage Hash referencing the active coverage agreement\n  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 1018\n  /// @param coverageAmount Max amount claimable by this protocol\n  /// @dev Only callable by governance\n  /// @dev _nonStakers can be 0\n  function protocolUpdate(\n    bytes32 _protocol,\n    bytes32 _coverage,\n    uint256 _nonStakers,\n    uint256 _coverageAmount\n  ) public override onlyOwner {\n    if (_coverage == bytes32(0)) revert ZeroArgument();\n    if (_nonStakers &gt; HUNDRED_PERCENT) revert InvalidArgument();\n    if (_coverageAmount == uint256(0)) revert ZeroArgument();\n    // Checks to make sure the protocol has been assigned a protocol agent\n    _verifyProtocolExists(_protocol);\n    // Subtracts the accrued debt from a protocol\'s active balance (if any)\n    // Updates the amount that can be claimed by nonstakers\n    _settleProtocolDebt(_protocol);\n    // Updates the global claimable amount for stakers\n    _settleTotalDebt();\n    // Gets the premium per second for this protocol\n    uint256 premium = premiums[protocol];\n    // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be)\n    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(\n      premium,\n      premium,\n      nonStakersPercentage[_protocol],\n      _nonStakers,\n      allPremiumsPerSecToStakers\n    );\n    // Updates the stored value of percentage of premiums that go to nonstakers\n    nonStakersPercentage[_protocol] = _nonStakers;\n    // Updates previous coverage and current coverage amounts\n    previousCoverage[_protocol] = currentCoverage[_protocol];\n    currentCoverage[_protocol] = _coverageAmount;\n    emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);\n  }\n  /// @notice Remove a protocol from coverage\n  /// @param _protocol Protocol identifier\n  /// @dev Before removing a protocol the premium must be 0\n  /// @dev Removing a protocol basically stops the _protocolAgent from being active (can still submit claims until claim deadline though)\n  /// @dev Pays off debt + sends remaining balance to protocol agent\n  /// @dev This call should be subject to a timelock\n  /// @dev Only callable by governance\n  function protocolRemove(bytes32 _protocol) external override onlyOwner {\n    // checks to make sure the protocol actually has a protocol agent\n    address agent = _verifyProtocolExists(_protocol);\n    // Removes a protocol from Sherlock and cleans up its data\n    // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made\n    _forceRemoveProtocol(_protocol, agent);\n  }\n  /// @notice Remove a protocol with insufficient active balance\n  /// @param _protocol Protocol identifier\n  // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function\n  function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {\n    address agent = _verifyProtocolExists(_protocol);\n    // Gets the latest value of the active balance at this protocol\n    _settleProtocolDebt(_protocol);\n    // Sets latest value of active balance to remainingBalance variable\n    uint256 remainingBalance = activeBalances[_protocol];\n    // This means the protocol still has adequate active balance and thus cannot be removed\n    if (remainingBalance &gt;= minActiveBalance) revert InvalidConditions();\n    // Sets the protocol\'s active balance to 0\n    delete activeBalances[_protocol];\n    // Removes the protocol from coverage\n    _forceRemoveProtocol(_protocol, agent);\n    if (remainingBalance != 0) {\n      // sends the remaining balance to msg.sender\n      token.safeTransfer(msg.sender, remainingBalance);\n    }\n    emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);\n  }\n  /// @notice Calculate if arb is possible and what the reward would be\n  /// @param _protocol Protocol identifier\n  /// @return arbAmount Amount reward for arbing\n  /// @return able Indicator if arb call is even possible\n  /// @dev Doesn\'t subtract the current protocol debt from the active balance\n  function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)\n    internal\n    view\n    returns (uint256 arbAmount, bool able)\n  {\n    uint256 secondsLeft = _secondsOfCoverageLeft(_protocol);\n    // If arb is not possible return false\n    if (secondsLeft &gt;= MIN_SECONDS_OF_COVERAGE) return (0, false);\n    // This percentage scales over time\n    // Reaches 100% on 0 seconds of coverage left\n    uint256 percentageScaled = HUNDRED_PERCENT -\n      (secondsLeft * HUNDRED_PERCENT) /\n      MIN_SECONDS_OF_COVERAGE;\n    able = true;\n    arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;\n  }\n  /// @notice Removes a protocol with insufficent seconds of coverage left\n  /// @param _protocol Protocol identifier\n  // Seconds of coverage is defined by the active balance of the protocol divided by the protocol\'s premium per second\n  function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {\n    // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings\n    address agent = _verifyProtocolExists(_protocol);\n    // NOTE: We don\'t give the arb the full remaining balance like we do in forceRemoveByActiveBalance()\n    // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance()\n    // But when removing based on seconds of coverage left, the remainingBalance could still be quite large\n    // So it\'s better to scale the arb reward over time. It\'s a little complex because the remainingBalance\n    // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%)\n    _settleProtocolDebt(_protocol);\n    (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol);\n    if (able == false) revert InvalidConditions();\n    if (arbAmount != 0) {\n      // subtracts the amount that will be paid to the arb from the active balance\n      activeBalances[_protocol] -= arbAmount;\n    }\n    // Removes the protocol from coverage\n    // This function also pays the active balance to the protocol agent, so it\'s good we do this after subtracting arb amount above\n    _forceRemoveProtocol(_protocol, agent);\n    // Done after removing protocol to mitigate reentrency pattern\n    // (In case token allows callback)\n    if (arbAmount != 0) {\n      token.safeTransfer(msg.sender, arbAmount);\n    }\n    emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);\n  }\n  /// @notice Set premium of _protocol to _premium\n  /// @param _protocol Protocol identifier\n  /// @param _premium Amount of premium _protocol pays per second\n  /// @dev The value 0 would mean inactive coverage\n  /// @dev Only callable by governance\n  function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {\n    // Checks to see if protocol has a protocol agent\n    _verifyProtocolExists(_protocol);\n    // Updates individual protocol\'s premium and allPremiumsPerSecToStakers\n    _setSingleAndGlobalProtocolPremium(_protocol, _premium);\n  }\n  /// @notice Set premium of multiple protocols\n  /// @param _protocol Array of protocol identifiers\n  /// @param _premium Array of premium amounts protocols pay per second\n  /// @dev The value 0 would mean inactive coverage\n  /// @dev Only callable by governance\n  function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)\n    external\n    override\n    onlyOwner\n  {\n    // Checks to make sure there are an equal amount of entries in each array\n    if (_protocol.length != _premium.length) revert UnequalArrayLength();\n    if (_protocol.length == 0) revert InvalidArgument();\n    // Updates the global claimable amount for stakers\n    _settleTotalDebt();\n    uint256 allPremiumsPerSecToStakers = allPremiumsPerSecToStakers;\n    // Loops through the array of protocols and checks to make sure each has a protocol agent assigned\n    for (uint256 i; i &lt; protocol.length; i++) {\n      _verifyProtocolExists(_protocol[i]);\n      // Sets the protocol premium for that specific protocol\n      // Function returns the old premium and nonStakerPercentage for that specific protocol\n      (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(\n        _protocol[i],\n        _premium[i]\n      );\n      // Calculates the new global premium which adds up all premiums paid by all protocols\n      allPremiumsPerSecToStakers = calcGlobalPremiumPerSecForStakers(\n        oldPremiumPerSecond,\n        _premium[i],\n        nonStakerPercentage,\n        nonStakerPercentage,\n        allPremiumsPerSecToStakers\n      );\n    }\n    // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value\n    allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;\n  }\n  // This is how protocols pay for coverage by increasing their active balance\n  /// @notice Deposits _amount of token to the active balance of _protocol\n  /// @param _protocol Protocol identifier\n  /// @param _amount Amount of tokens to deposit\n  /// @dev Approval should be made before calling\n  function depositToActiveBalance(bytes32 _protocol, uint256 _amount)\n    external\n    override\n    whenNotPaused\n  {\n    if (_amount == uint256(0)) revert ZeroArgument();\n    _verifyProtocolExists(_protocol);\n    // Transfers _amount to this contract\n    token.safeTransferFrom(msg.sender, address(this), _amount);\n    // Increases the active balance of the protocol by _amount\n    activeBalances[_protocol] += _amount;\n    emit ProtocolBalanceDeposited(_protocol, _amount);\n  }\n  // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)\n  // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)\n  /// @notice Withdraws _amount of token from the active balance of _protocol\n  /// @param _protocol Protocol identifier\n  /// @param _amount Amount of tokens to withdraw\n  /// @dev Only protocol agent is able to withdraw\n  /// @dev Balance can be withdrawn up until 7 days worth of active balance\n  function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)\n    external\n    override\n    whenNotPaused\n  {\n    if (_amount == uint256(0)) revert ZeroArgument();\n    // Only the protocol agent can call this function\n    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();\n    // Updates the active balance of the protocol\n    _settleProtocolDebt(_protocol);\n    // Sets currentBalance to the active balance of the protocol\n    uint256 currentBalance = activeBalances[_protocol];\n    // Reverts if trying to withdraw more than the active balance\n    if (_amount &gt; currentBalance) revert InsufficientBalance(_protocol);\n    // Removes the _amount to be withdrawn from the active balance\n    activeBalances[_protocol] = currentBalance - _amount;\n    // Reverts if a protocol has less than 7 days worth of active balance left\n    if (_secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);\n    // Transfers the amount to the msg.sender (protocol agent)\n    token.safeTransfer(msg.sender, _amount);\n    emit ProtocolBalanceWithdrawn(_protocol, _amount);\n  }\n  /// @notice Transfer protocol agent role\n  /// @param _protocol Protocol identifier\n  /// @param _protocolAgent Account able to submit a claim on behalf of the protocol\n  /// @dev Only the active protocolAgent is able to transfer the role\n  function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)\n    external\n    override\n    whenNotPaused\n  {\n    if (_protocolAgent == address(0)) revert ZeroArgument();\n    // Can\'t set the new protocol agent to the caller address\n    if (msg.sender == _protocolAgent) revert InvalidArgument();\n    // Because the caller must be the current protocol agent\n    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();\n    // Sets the protocol agent to the new address\n    _setProtocolAgent(_protocol, msg.sender, _protocolAgent);\n  }\n  /// @notice Function used to check if this is the current active protocol manager\n  /// @return Boolean indicating it\'s active\n  /// @dev If inactive the owner can pull all ERC20s and ETH\n  /// @dev Will be checked by calling the sherlock contract\n  function isActive() public view returns (bool) {\n    return address(sherlockCore.sherlockProtocolManager()) == address(this);\n  }\n  // Only contract owner can call this\n  // Sends all specified tokens in this contract to the receiver\'s address (as well as ETH)\n  function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {\n    if (_receiver == address(0)) revert ZeroArgument();\n    // This contract must NOT be the current assigned protocol manager contract\n    if (isActive()) revert InvalidConditions();\n    // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH\n    _sweep(_receiver, _extraTokens);\n  }\n}\n.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n/***********\\n Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/************/\nimport \'./Manager.sol\';\nimport \'../interfaces/managers/ISherlockProtocolManager.sol\';\n/// @title Sherlock core interface for protocols\n/// @author Evert Kors\n// This is the contract that manages covered protocols\ncontract SherlockProtocolManager is ISherlockProtocolManager, Manager {\n  using SafeERC20 for IERC20;\n  // Represents the token that protocols pay with (currently USDC)\n  IERC20 public immutable token;\n  // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed\n  uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 106; // 30k usdc\n  // A removed protocol is still able to make a claim for this amount of time after its removal\n  uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days;\n  // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance\n  uint256 public constant MIN_SECONDS_LEFT = 7 days;\n  // Convenient for percentage calculations\n  uint256 internal constant HUNDRED_PERCENT = 1018;\n  // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage\n  // This value is calculated from a protocol\'s active balance divided by the premium per second the protocol is paying\n  uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours;\n  // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)\n  mapping(bytes32 =&gt; address) internal protocolAgent_;\n  // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)\n  mapping(bytes32 =&gt; uint256) internal nonStakersPercentage;\n  // The premium per second paid by each protocol is stored in this mapping\n  mapping(bytes32 =&gt; uint256) internal premiums_;\n  // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.\n  // This "active balance" is really just an accounting concept, doesn\'t mean tokens have been transferred or not\n  mapping(bytes32 =&gt; uint256) internal activeBalances;\n  // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol\n  mapping(bytes32 =&gt; uint256) internal lastAccountedEachProtocol;\n  // The amount that can be claimed by nonstakers for each protocol\n  // We need this value so we can track how much payment is coming from each protocol\n  mapping(bytes32 =&gt; uint256) internal nonStakersClaimableByProtocol;\n  // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)\n  uint256 internal lastAccountedGlobal;\n  // This is the total amount of premiums paid (per second) by all the covered protocols (added up)\n  uint256 internal allPremiumsPerSecToStakers;\n  // This is the amount that was claimable by stakers the last time the accounting was run\n  // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date\n  uint256 internal lastClaimablePremiumsForStakers;\n  // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage\n  // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)\n  uint256 public override minActiveBalance;\n  // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)\n  mapping(bytes32 =&gt; uint256) internal removedProtocolClaimDeadline;\n  // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)\n  mapping(bytes32 =&gt; address) internal removedProtocolAgent;\n  // Current amount of coverage (i.e. 20M USDC) for a protocol\n  mapping(bytes32 =&gt; uint256) internal currentCoverage;\n  // Previous amount of coverage for a protocol\n  // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount\n  mapping(bytes32 =&gt; uint256) internal previousCoverage;\n  // Setting the token to USDC\n  constructor(IERC20 token) {\n    if (address(_token) == address(0)) revert ZeroArgument();\n    token = _token;\n  }\n  // Modifier used to ensure a protocol exists (has been instantiated and not removed)\n  modifier protocolExists(bytes32 _protocol) {\n    _verifyProtocolExists(_protocol);\n    ;\n  }\n  /// @notice View current protocolAgent of _protocol\n  /// @param protocol Protocol identifier\n  /// @return Address able to submit claims\n  function protocolAgent(bytes32 _protocol) external view override returns (address) {\n    address agent = protocolAgent[protocol];\n    if (agent != address(0)) return agent;\n    // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned\n    // Note: Old protocol agent will never be address(0)\n    if (block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]) {\n      return removedProtocolAgent[_protocol];\n    }\n    // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned\n    revert ProtocolNotExists(_protocol);\n  }\n  // Checks if the protocol exists, then returns the current premium per second being charged\n  /// @notice View current premium of protocol\n  /// @param _protocol Protocol identifier\n  /// @return Amount of premium _protocol pays per second\n  function premium(bytes32 _protocol)\n    external\n    view\n    override\n    protocolExists(_protocol)\n    returns (uint256)\n  {\n    return premiums[protocol];\n  }\n  // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)\n  // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)\n  function _verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {\n    _protocolAgent = protocolAgent[protocol];\n    if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);\n  }\n  //\n  // View methods\n  //\n  // Calcs the debt accrued by the protocol since it last had an accounting update\n  // This is the amount that needs to be removed from a protocol\'s active balance\n  function _calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {\n    return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums[_protocol];\n  }\n  /// @notice View the amount nonstakers can claim from this protocol\n  /// @param _protocol Protocol identifier\n  /// @return Amount of tokens claimable by nonstakers\n  /// @dev this reads from a storage variable + (now-lastsettled) * premiums\n  // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]\n  // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn\'t change since the protocol has been removed\n  function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {\n    // Calcs the debt of a protocol since the last accounting update\n    uint256 debt = _calcIncrementalProtocolDebt(_protocol);\n    // Gets the active balance of the protocol\n    uint256 balance = activeBalances[_protocol];\n    // The debt should never be higher than the balance (only happens if the arbitrages fail)\n    if (debt &gt; balance) debt = balance;\n    // Adds the incremental claimable amount owed to nonstakers to the total claimable amount\n    return\n      nonStakersClaimableByProtocol[_protocol] +\n      (nonStakersPercentage[_protocol] * debt) /\n      HUNDRED_PERCENT;\n  }\n  /// @notice View current amount of all premiums that are owed to stakers\n  /// @return Premiums claimable\n  /// @dev Will increase every block\n  /// @dev base + (now - last_settled) * ps\n  function claimablePremiums() public view override returns (uint256) {\n    // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)\n    return\n      lastClaimablePremiumsForStakers +\n      (block.timestamp - lastAccountedGlobal) \n      allPremiumsPerSecToStakers;\n  }\n  /// @notice View seconds of coverage left for _protocol before it runs out of active balance\n  /// @param protocol Protocol identifier\n  /// @return Seconds of coverage left\n  function secondsOfCoverageLeft(bytes32 _protocol)\n    external\n    view\n    override\n    protocolExists(_protocol)\n    returns (uint256)\n  {\n    return _secondsOfCoverageLeft(_protocol);\n  }\n  // Helper function to return seconds of coverage left for a protocol\n  // Gets the current active balance of the protocol and divides by the premium per second for the protocol\n  function _secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {\n    uint256 premium = premiums[protocol];\n    if (premium == 0) return 0;\n    return _activeBalance(_protocol) / premium;\n  }\n  /// @notice View current active balance of covered protocol\n  /// @param _protocol Protocol identifier\n  /// @return Active balance\n  /// @dev Accrued debt is subtracted from the stored active balance\n  function activeBalance(bytes32 _protocol)\n    external\n    view\n    override\n    protocolExists(_protocol)\n    returns (uint256)\n  {\n    return _activeBalance(_protocol);\n  }\n  // Helper function to calc the active balance of a protocol at current time\n  function _activeBalance(bytes32 _protocol) internal view returns (uint256) {\n    uint256 debt = _calcIncrementalProtocolDebt(_protocol);\n    uint256 balance = activeBalances[_protocol];\n    // The debt should never be higher than the balance (only happens if the arbitrages fail)\n    if (debt &gt; balance) return 0;\n    return balance - debt;\n  }\n  //\n  // State methods\n  //\n  /// @notice Helps set the premium per second for an individual protocol\n  /// @param _protocol Protocol identifier\n  /// @param _premium New premium per second\n  /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function\n  function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)\n    internal\n    returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)\n  {\n    // _settleProtocolDebt() subtracts debt from the protocol\'s active balance and updates the % due to nonstakers\n    // Also updates the last accounted timestamp for this protocol\n    // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings\n    // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol\n    nonStakerPercentage = _settleProtocolDebt(_protocol);\n    // Stores the old premium before it gets updated\n    oldPremiumPerSecond = premiums[protocol];\n    if (oldPremiumPerSecond != _premium) {\n      // Sets the protocol\'s premium per second to the new value\n      premiums[protocol] = _premium;\n      emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium);\n    }\n    // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing\n    // We don\'t need to check the min balance requirement for arbs because that value doesn\'t change like secondsOfCoverageLeft changes\n    // Effectively we just need to make sure we don\'t accidentally run a protocol\'s active balance down below the point\n    // Where arbs would no longer be incentivized to remove the protocol\n    // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems\n    if (_premium != 0 &amp;&amp; _secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_OF_COVERAGE) {\n      revert InsufficientBalance(_protocol);\n    }\n  }\n  /// @notice Sets a single protocol\'s premium per second and also updates the global total of premiums per second\n  /// @param _protocol Protocol identifier\n  /// @param _premium New premium per second\n  function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {\n    // Sets the individual protocol\'s premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings\n    (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(\n      _protocol,\n      _premium\n    );\n    // Settling the total amount of premiums owed to stakers before a new premium per second gets set\n    _settleTotalDebt();\n    // This calculates the new global premium per second that gets paid to stakers\n    // We input the same nonStakerPercentage twice because we simply aren\'t updating that value in this function\n    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(\n      oldPremiumPerSecond,\n      _premium,\n      nonStakerPercentage,\n      nonStakerPercentage,\n      allPremiumsPerSecToStakers\n    );\n  }\n  // Internal function to set a new protocolAgent for a specific protocol\n  // _oldAgent is only included as part of emitting an event\n  function _setProtocolAgent(\n    bytes32 _protocol,\n    address _oldAgent,\n    address _protocolAgent\n  ) internal {\n    protocolAgent[protocol] = _protocolAgent;\n    emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);\n  }\n  // Subtracts the accrued debt from a protocol\'s active balance\n  // Credits the amount that can be claimed by nonstakers for this protocol\n  // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings\n  // Most of this function is dealing with an edge case related to a protocol not being removed by arbs\n  function _settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {\n    // This calcs the accrued debt of the protocol since it was last updated\n    uint256 debt = _calcIncrementalProtocolDebt(_protocol);\n    // This pulls the percentage that is sent to nonstakers\n    _nonStakerPercentage = nonStakersPercentage[_protocol];\n    // In case the protocol has accrued debt, this code block will ensure the debt is settled properly\n    if (debt != 0) {\n      // Pulls the stored active balance of the protocol\n      uint256 balance = activeBalances[_protocol];\n      // This is the start of handling an edge case where arbitragers don\'t remove this protocol before debt becomes greater than active balance\n      // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point\n      // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage\n      // However, if arbs don\'t come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up\n      if (debt &gt; balance) {\n        // This error amount represents the magnitude of the mistake\n        uint256 error = debt - balance;\n        // Gets the latest value of claimable premiums for stakers\n        _settleTotalDebt();\n        // @note to production, set premium first to zero before solving accounting issue.\n        // otherwise the accounting error keeps increasing\n        uint256 lastClaimablePremiumsForStakers = lastClaimablePremiumsForStakers;\n        // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%\n        uint256 claimablePremiumError = ((HUNDRED_PERCENT - nonStakerPercentage) * error) /\n          HUNDRED_PERCENT;\n        // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short\n        uint256 insufficientTokens;\n        // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally\n        // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error\n        // This first line can be true if claimPremiumsForStakers() has been called and\n        // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be &gt;0 still\n        if (claimablePremiumError &gt; lastClaimablePremiumsForStakers) {\n          insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;\n          lastClaimablePremiumsForStakers = 0;\n        } else {\n          // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums\n          // By the amount that was added in error (error) and insufficientTokens = 0\n          lastClaimablePremiumsForStakers =\n            lastClaimablePremiumsForStakers_ -\n            claimablePremiumError;\n        }\n        // If two events are thrown, the values need to be summed up for the actual state.\n        // This means an error of this type will continue until it is handled\n        emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);\n        // We set the debt equal to the balance, and in the next line we effectively set the protocol\'s active balance to 0 in this case\n        debt = balance;\n      }\n      // Subtracts the accrued debt (since last update) from the protocol\'s active balance and updates active balance\n      activeBalances[_protocol] = balance - debt;\n      // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol\n      nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT;\n    }\n    // Updates the last accounted timestamp for this protocol\n    lastAccountedEachProtocol[_protocol] = block.timestamp;\n  }\n  // Multiplies the total premium per second * number of seconds since the last global accounting update\n  // And adds it to the total claimable amount for stakers\n  function _settleTotalDebt() internal {\n    lastClaimablePremiumsForStakers +=\n      (block.timestamp - lastAccountedGlobal) \n      allPremiumsPerSecToStakers;\n    lastAccountedGlobal = block.timestamp;\n  }\n  // Calculates the global premium per second for stakers\n  // Takes a specific protocol\'s old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers\n  // Subtracts out the old values of a protocol\'s premium per second and nonstaker percentage and adds the new ones\n  function calcGlobalPremiumPerSecForStakers(\n    uint256 _premiumOld,\n    uint256 _premiumNew,\n    uint256 _nonStakerPercentageOld,\n    uint256 _nonStakerPercentageNew,\n    uint256 _inMemAllPremiumsPerSecToStakers\n  ) internal pure returns (uint256) {\n    return\n      _inMemAllPremiumsPerSecToStakers +\n      ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /\n      HUNDRED_PERCENT -\n      ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /\n      HUNDRED_PERCENT;\n  }\n  // Helper function to remove and clean up a protocol from Sherlock\n  // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made\n  function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {\n    // Sets the individual protocol\'s premium to zero and updates the global premium variable for a zero premium at this protocol\n    _setSingleAndGlobalProtocolPremium(_protocol, 0);\n    // Grabs the protocol\'s active balance\n    uint256 balance = activeBalances[_protocol];\n    // If there\'s still some active balance, delete the entry and send the remaining balance to the protocol agent\n    if (balance != 0) {\n      delete activeBalances[_protocol];\n      token.safeTransfer(_agent, balance);\n      emit ProtocolBalanceWithdrawn(_protocol, balance);\n    }\n    // Sets the protocol agent to zero address (as part of clean up)\n    _setProtocolAgent(_protocol, _agent, address(0));\n    // Cleans up other mappings for this protocol\n    delete nonStakersPercentage[_protocol];\n    delete lastAccountedEachProtocol[_protocol];\n    // premiums_ mapping is not deleted here as it\'s already 0 because of the _setSingleAndGlobalProtocolPremium call above\n    // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol\n    removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;\n    // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed\n    // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked\n    removedProtocolAgent[_protocol] = _agent;\n    emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0));\n    emit ProtocolRemoved(_protocol);\n  }\n  /// @notice Sets the minimum active balance before an arb can remove a protocol\n  /// @param _minActiveBalance Minimum balance needed (in USDC)\n  /// @dev Only gov\n  function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {\n    // New value cannot be the same as current value\n    if (minActiveBalance == _minActiveBalance) revert InvalidArgument();\n    // Can\'t set a value that is too high to be reasonable\n    if (_minActiveBalance &gt;= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions();\n    emit MinBalance(minActiveBalance, _minActiveBalance);\n    minActiveBalance = _minActiveBalance;\n  }\n  // This function allows the nonstakers role to claim tokens owed to them by a specific protocol\n  /// @notice Choose an _amount of tokens that nonstakers (_receiver address) will receive from _protocol\n  /// @param _protocol Protocol identifier\n  /// @param _amount Amount of tokens\n  /// @param _receiver Address to receive tokens\n  /// @dev Only callable by nonstakers role\n  function nonStakersClaim(\n    bytes32 _protocol,\n    uint256 _amount,\n    address _receiver\n  ) external override whenNotPaused {\n    if (_protocol == bytes32(0)) revert ZeroArgument();\n    if (_amount == uint256(0)) revert ZeroArgument();\n    if (_receiver == address(0)) revert ZeroArgument();\n    // Only the nonstakers role (multisig or contract) can pull the funds\n    if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized();\n    // Call can\'t be executed on protocol that is removed\n    if (protocolAgent[protocol] != address(0)) {\n      // Updates the amount that nonstakers can claim from this protocol\n      _settleProtocolDebt(_protocol);\n    }\n    // Sets balance to the amount that is claimable by nonstakers for this specific protocol\n    uint256 balance = nonStakersClaimableByProtocol[_protocol];\n    // If the amount requested is more than what\'s owed to nonstakers, revert\n    if (_amount &gt; balance) revert InsufficientBalance(_protocol);\n    // Sets the claimable amount to whatever is left over after this amount is pulled\n    nonStakersClaimableByProtocol[_protocol] = balance - _amount;\n    // Transfers the amount requested to the _receiver address\n    token.safeTransfer(_receiver, _amount);\n  }\n  // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)\n  /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address\n  /// @dev Callable by everyone\n  /// @dev Funds will be transferred to Sherlock core contract\n  function claimPremiumsForStakers() external override whenNotPaused {\n    // Gets address of core Sherlock contract\n    address sherlock = address(sherlockCore);\n    // Revert if core Sherlock contract not initialized yet\n    if (sherlock == address(0)) revert InvalidConditions();\n    // claimablePremiums is different from _settleTotalDebt() because it does not change state\n    // Retrieves current amount of all premiums that are owed to stakers\n    uint256 amount = claimablePremiums();\n    // Transfers all the premiums owed to stakers to the Sherlock core contract\n    if (amount != 0) {\n      // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out\n      lastClaimablePremiumsForStakers = 0;\n      lastAccountedGlobal = block.timestamp;\n      token.safeTransfer(sherlock, amount);\n    }\n  }\n  // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts\n  /// @param _protocol Protocol identifier\n  /// @return current and previous are the current and previous coverage amounts for this protocol\n  // Note For this process to work, a protocol\'s coverage amount should not be set more than once in the span of claim delay period (7 days or something)\n  function coverageAmounts(bytes32 _protocol)\n    external\n    view\n    override\n    returns (uint256 current, uint256 previous)\n  {\n    // Checks to see if the protocol has an active protocolAgent (protocol not removed)\n    // OR checks to see if the removed protocol is still within the claim window\n    // If so, gives the current and previous coverage, otherwise throws an error\n    if (\n      protocolAgent[_protocol] != address(0) ||\n      block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]\n    ) {\n      return (currentCoverage[_protocol], previousCoverage[_protocol]);\n    }\n    revert ProtocolNotExists(_protocol);\n  }\n  /// @notice Add a new protocol to Sherlock\n  /// @param _protocol Protocol identifier\n  /// @param _protocolAgent Address able to submit a claim on behalf of the protocol\n  /// @param _coverage Hash referencing the active coverage agreement\n  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 1018\n  /// @param _coverageAmount Max amount claimable by this protocol\n  /// @dev Adding a protocol allows the _protocolAgent to submit a claim\n  /// @dev Coverage is not started yet as the protocol doesn\'t pay a premium at this point\n  /// @dev _nonStakers is scaled by 1018\n  /// @dev Only callable by governance\n  function protocolAdd(\n    bytes32 protocol,\n    address _protocolAgent,\n    bytes32 _coverage,\n    uint256 _nonStakers,\n    uint256 _coverageAmount\n  ) external override onlyOwner {\n    if (_protocol == bytes32(0)) revert ZeroArgument();\n    if (_protocolAgent == address(0)) revert ZeroArgument();\n    // Checks to make sure the protocol doesn\'t exist already\n    if (protocolAgent[_protocol] != address(0)) revert InvalidConditions();\n    // Updates the protocol agent and passes in the old agent which is 0 address in this case\n    _setProtocolAgent(_protocol, address(0), _protocolAgent);\n    // Delete mappings that are potentially non default values\n    // From previous time protocol was added/removed\n    delete removedProtocolClaimDeadline[_protocol];\n    delete removedProtocolAgent[_protocol];\n    delete currentCoverage[_protocol];\n    delete previousCoverage[_protocol];\n    emit ProtocolAdded(_protocol);\n    // Most of the logic for actually adding a protocol in this function\n    protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);\n  }\n  /// @notice Update info regarding a protocol\n  /// @param _protocol Protocol identifier\n  /// @param _coverage Hash referencing the active coverage agreement\n  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 1018\n  /// @param _coverageAmount Max amount claimable by this protocol\n  /// @dev Only callable by governance\n  /// @dev _nonStakers can be 0\n  function protocolUpdate(\n    bytes32 _protocol,\n    bytes32 _coverage,\n    uint256 _nonStakers,\n    uint256 _coverageAmount\n  ) public override onlyOwner {\n    if (_coverage == bytes32(0)) revert ZeroArgument();\n    if (_nonStakers &gt; HUNDRED_PERCENT) revert InvalidArgument();\n    if (_coverageAmount == uint256(0)) revert ZeroArgument();\n    // Checks to make sure the protocol has been assigned a protocol agent\n    _verifyProtocolExists(_protocol);\n    // Subtracts the accrued debt from a protocol\'s active balance (if any)\n    // Updates the amount that can be claimed by nonstakers\n    _settleProtocolDebt(_protocol);\n    // Updates the global claimable amount for stakers\n    _settleTotalDebt();\n    // Gets the premium per second for this protocol\n    uint256 premium = premiums[protocol];\n    // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be)\n    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(\n      premium,\n      premium,\n      nonStakersPercentage[_protocol],\n      _nonStakers,\n      allPremiumsPerSecToStakers\n    );\n    // Updates the stored value of percentage of premiums that go to nonstakers\n    nonStakersPercentage[_protocol] = _nonStakers;\n    // Updates previous coverage and current coverage amounts\n    previousCoverage[_protocol] = currentCoverage[_protocol];\n    currentCoverage[_protocol] = _coverageAmount;\n    emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);\n  }\n  /// @notice Remove a protocol from coverage\n  /// @param _protocol Protocol identifier\n  /// @dev Before removing a protocol the premium must be 0\n  /// @dev Removing a protocol basically stops the _protocolAgent from being active (can still submit claims until claim deadline though)\n  /// @dev Pays off debt + sends remaining balance to protocol agent\n  /// @dev This call should be subject to a timelock\n  /// @dev Only callable by governance\n  function protocolRemove(bytes32 _protocol) external override onlyOwner {\n    // checks to make sure the protocol actually has a protocol agent\n    address agent = _verifyProtocolExists(_protocol);\n    // Removes a protocol from Sherlock and cleans up its data\n    // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made\n    _forceRemoveProtocol(_protocol, agent);\n  }\n  /// @notice Remove a protocol with insufficient active balance\n  /// @param _protocol Protocol identifier\n  // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function\n  function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {\n    address agent = _verifyProtocolExists(_protocol);\n    // Gets the latest value of the active balance at this protocol\n    _settleProtocolDebt(_protocol);\n    // Sets latest value of active balance to remainingBalance variable\n    uint256 remainingBalance = activeBalances[_protocol];\n    // This means the protocol still has adequate active balance and thus cannot be removed\n    if (remainingBalance &gt;= minActiveBalance) revert InvalidConditions();\n    // Sets the protocol\'s active balance to 0\n    delete activeBalances[_protocol];\n    // Removes the protocol from coverage\n    _forceRemoveProtocol(_protocol, agent);\n    if (remainingBalance != 0) {\n      // sends the remaining balance to msg.sender\n      token.safeTransfer(msg.sender, remainingBalance);\n    }\n    emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);\n  }\n  /// @notice Calculate if arb is possible and what the reward would be\n  /// @param _protocol Protocol identifier\n  /// @return arbAmount Amount reward for arbing\n  /// @return able Indicator if arb call is even possible\n  /// @dev Doesn\'t subtract the current protocol debt from the active balance\n  function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)\n    internal\n    view\n    returns (uint256 arbAmount, bool able)\n  {\n    uint256 secondsLeft = _secondsOfCoverageLeft(_protocol);\n    // If arb is not possible return false\n    if (secondsLeft &gt;= MIN_SECONDS_OF_COVERAGE) return (0, false);\n    // This percentage scales over time\n    // Reaches 100% on 0 seconds of coverage left\n    uint256 percentageScaled = HUNDRED_PERCENT -\n      (secondsLeft * HUNDRED_PERCENT) /\n      MIN_SECONDS_OF_COVERAGE;\n    able = true;\n    arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;\n  }\n  /// @notice Removes a protocol with insufficent seconds of coverage left\n  /// @param _protocol Protocol identifier\n  // Seconds of coverage is defined by the active balance of the protocol divided by the protocol\'s premium per second\n  function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {\n    // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings\n    address agent = _verifyProtocolExists(_protocol);\n    // NOTE: We don\'t give the arb the full remaining balance like we do in forceRemoveByActiveBalance()\n    // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance()\n    // But when removing based on seconds of coverage left, the remainingBalance could still be quite large\n    // So it\'s better to scale the arb reward over time. It\'s a little complex because the remainingBalance\n    // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%)\n    _settleProtocolDebt(_protocol);\n    (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol);\n    if (able == false) revert InvalidConditions();\n    if (arbAmount != 0) {\n      // subtracts the amount that will be paid to the arb from the active balance\n      activeBalances[_protocol] -= arbAmount;\n    }\n    // Removes the protocol from coverage\n    // This function also pays the active balance to the protocol agent, so it\'s good we do this after subtracting arb amount above\n    _forceRemoveProtocol(_protocol, agent);\n    // Done after removing protocol to mitigate reentrency pattern\n    // (In case token allows callback)\n    if (arbAmount != 0) {\n      token.safeTransfer(msg.sender, arbAmount);\n    }\n    emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);\n  }\n  /// @notice Set premium of _protocol to _premium\n  /// @param _protocol Protocol identifier\n  /// @param _premium Amount of premium _protocol pays per second\n  /// @dev The value 0 would mean inactive coverage\n  /// @dev Only callable by governance\n  function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {\n    // Checks to see if protocol has a protocol agent\n    _verifyProtocolExists(_protocol);\n    // Updates individual protocol\'s premium and allPremiumsPerSecToStakers\n    _setSingleAndGlobalProtocolPremium(_protocol, _premium);\n  }\n  /// @notice Set premium of multiple protocols\n  /// @param _protocol Array of protocol identifiers\n  /// @param _premium Array of premium amounts protocols pay per second\n  /// @dev The value 0 would mean inactive coverage\n  /// @dev Only callable by governance\n  function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)\n    external\n    override\n    onlyOwner\n  {\n    // Checks to make sure there are an equal amount of entries in each array\n    if (_protocol.length != _premium.length) revert UnequalArrayLength();\n    if (_protocol.length == 0) revert InvalidArgument();\n    // Updates the global claimable amount for stakers\n    _settleTotalDebt();\n    uint256 allPremiumsPerSecToStakers = allPremiumsPerSecToStakers;\n    // Loops through the array of protocols and checks to make sure each has a protocol agent assigned\n    for (uint256 i; i &lt; protocol.length; i++) {\n      _verifyProtocolExists(_protocol[i]);\n      // Sets the protocol premium for that specific protocol\n      // Function returns the old premium and nonStakerPercentage for that specific protocol\n      (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(\n        _protocol[i],\n        _premium[i]\n      );\n      // Calculates the new global premium which adds up all premiums paid by all protocols\n      allPremiumsPerSecToStakers = calcGlobalPremiumPerSecForStakers(\n        oldPremiumPerSecond,\n        _premium[i],\n        nonStakerPercentage,\n        nonStakerPercentage,\n        allPremiumsPerSecToStakers\n      );\n    }\n    // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value\n    allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;\n  }\n  // This is how protocols pay for coverage by increasing their active balance\n  /// @notice Deposits _amount of token to the active balance of _protocol\n  /// @param _protocol Protocol identifier\n  /// @param _amount Amount of tokens to deposit\n  /// @dev Approval should be made before calling\n  function depositToActiveBalance(bytes32 _protocol, uint256 _amount)\n    external\n    override\n    whenNotPaused\n  {\n    if (_amount == uint256(0)) revert ZeroArgument();\n    _verifyProtocolExists(_protocol);\n    // Transfers _amount to this contract\n    token.safeTransferFrom(msg.sender, address(this), _amount);\n    // Increases the active balance of the protocol by _amount\n    activeBalances[_protocol] += _amount;\n    emit ProtocolBalanceDeposited(_protocol, _amount);\n  }\n  // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)\n  // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)\n  /// @notice Withdraws _amount of token from the active balance of _protocol\n  /// @param _protocol Protocol identifier\n  /// @param _amount Amount of tokens to withdraw\n  /// @dev Only protocol agent is able to withdraw\n  /// @dev Balance can be withdrawn up until 7 days worth of active balance\n  function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)\n    external\n    override\n    whenNotPaused\n  {\n    if (_amount == uint256(0)) revert ZeroArgument();\n    // Only the protocol agent can call this function\n    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();\n    // Updates the active balance of the protocol\n    _settleProtocolDebt(_protocol);\n    // Sets currentBalance to the active balance of the protocol\n    uint256 currentBalance = activeBalances[_protocol];\n    // Reverts if trying to withdraw more than the active balance\n    if (_amount &gt; currentBalance) revert InsufficientBalance(_protocol);\n    // Removes the _amount to be withdrawn from the active balance\n    activeBalances[_protocol] = currentBalance - _amount;\n    // Reverts if a protocol has less than 7 days worth of active balance left\n    if (_secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);\n    // Transfers the amount to the msg.sender (protocol agent)\n    token.safeTransfer(msg.sender, _amount);\n    emit ProtocolBalanceWithdrawn(_protocol, _amount);\n  }\n  /// @notice Transfer protocol agent role\n  /// @param _protocol Protocol identifier\n  /// @param _protocolAgent Account able to submit a claim on behalf of the protocol\n  /// @dev Only the active protocolAgent is able to transfer the role\n  function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)\n    external\n    override\n    whenNotPaused\n  {\n    if (_protocolAgent == address(0)) revert ZeroArgument();\n    // Can\'t set the new protocol agent to the caller address\n    if (msg.sender == _protocolAgent) revert InvalidArgument();\n    // Because the caller must be the current protocol agent\n    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();\n    // Sets the protocol agent to the new address\n    _setProtocolAgent(_protocol, msg.sender, _protocolAgent);\n  }\n  /// @notice Function used to check if this is the current active protocol manager\n  /// @return Boolean indicating it\'s active\n  /// @dev If inactive the owner can pull all ERC20s and ETH\n  /// @dev Will be checked by calling the sherlock contract\n  function isActive() public view returns (bool) {\n    return address(sherlockCore.sherlockProtocolManager()) == address(this);\n  }\n  // Only contract owner can call this\n  // Sends all specified tokens in this contract to the receiver\'s address (as well as ETH)\n  function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {\n    if (_receiver == address(0)) revert ZeroArgument();\n    // This contract must NOT be the current assigned protocol manager contract\n    if (isActive()) revert InvalidConditions();\n    // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH\n    _sweep(_receiver, _extraTokens);\n  }\n}\n".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Let\'s', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-25-08 10:58:53 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import './Manager.sol'; import '../interfaces/managers/ISherlockProtocolManager.sol'; /// @title Sherlock core interface for protocols /// @author Evert Kors // This is the contract that manages covered protocols contract SherlockProtocolManager is ISherlockProtocolManager, Manager {   using SafeERC20 for IERC20; // Represents the token that protocols pay with (currently USDC)   IERC20 public immutable token; // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed   uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc // A removed protocol is still able to make a claim for this amount of time after its removal   uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days; // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance   uint256 public constant MIN_SECONDS_LEFT = 7 days; // Convenient for percentage calculations   uint256 internal constant HUNDRED_PERCENT = 10**18; // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage   // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying   uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours; // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)   mapping(bytes32 =&gt; address) internal protocolAgent_; // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)   mapping(bytes32 =&gt; uint256) internal nonStakersPercentage; // The premium per second paid by each protocol is stored in this mapping   mapping(bytes32 =&gt; uint256) internal premiums_; // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.   // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not   mapping(bytes32 =&gt; uint256) internal activeBalances; // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol   mapping(bytes32 =&gt; uint256) internal lastAccountedEachProtocol; // The amount that can be claimed by nonstakers for each protocol   // We need this value so we can track how much payment is coming from each protocol   mapping(bytes32 =&gt; uint256) internal nonStakersClaimableByProtocol; // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)   uint256 internal lastAccountedGlobal; // This is the total amount of premiums paid (per second) by all the covered protocols (added up)   uint256 internal allPremiumsPerSecToStakers; // This is the amount that was claimable by stakers the last time the accounting was run   // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date   uint256 internal lastClaimablePremiumsForStakers; // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage   // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)   uint256 public override minActiveBalance; // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)   mapping(bytes32 =&gt; uint256) internal removedProtocolClaimDeadline; // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)   mapping(bytes32 =&gt; address) internal removedProtocolAgent; // Current amount of coverage (i.e. 20M USDC) for a protocol   mapping(bytes32 =&gt; uint256) internal currentCoverage; // Previous amount of coverage for a protocol   // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount   mapping(bytes32 =&gt; uint256) internal previousCoverage; // Setting the token to USDC   constructor(IERC20 _token) {     if (address(_token) == address(0)) revert ZeroArgument();     token = _token;   } // Modifier used to ensure a protocol exists (has been instantiated and not removed)   modifier protocolExists(bytes32 protocol) {     _verifyProtocolExists(_protocol);     ;   } /// @notice View current protocolAgent of _protocol   /// @param protocol Protocol identifier   /// @return Address able to submit claims   function protocolAgent(bytes32 _protocol) external view override returns (address) {     address agent = protocolAgent[_protocol];     if (agent != address(0)) return agent; // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned // Note: Old protocol agent will never be address(0) if (block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]) {   return removedProtocolAgent[_protocol]; }  // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned revert ProtocolNotExists(_protocol);  } // Checks if the protocol exists, then returns the current premium per second being charged   /// @notice View current premium of protocol   /// @param protocol Protocol identifier   /// @return Amount of premium _protocol pays per second   function premium(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return premiums[_protocol];   } // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)   // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)   function verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {     _protocolAgent = protocolAgent[_protocol];     if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);   } //   // View methods   // // Calcs the debt accrued by the protocol since it last had an accounting update   // This is the amount that needs to be removed from a protocol's active balance   function calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {     return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums[_protocol];   } /// @notice View the amount nonstakers can claim from this protocol   /// @param _protocol Protocol identifier   /// @return Amount of tokens claimable by nonstakers   /// @dev this reads from a storage variable + (now-lastsettled) * premiums   // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]   // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed   function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {     // Calcs the debt of a protocol since the last accounting update     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     // Gets the active balance of the protocol     uint256 balance = activeBalances[_protocol];     // The debt should never be higher than the balance (only happens if the arbitrages fail)     if (debt &gt; balance) debt = balance; // Adds the incremental claimable amount owed to nonstakers to the total claimable amount return   nonStakersClaimableByProtocol[_protocol] +   (nonStakersPercentage[_protocol] * debt) /   HUNDRED_PERCENT;  } /// @notice View current amount of all premiums that are owed to stakers   /// @return Premiums claimable   /// @dev Will increase every block   /// @dev base + (now - last_settled) * ps   function claimablePremiums() public view override returns (uint256) {     // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)     return       lastClaimablePremiumsForStakers +       (block.timestamp - lastAccountedGlobal) *       allPremiumsPerSecToStakers;   } /// @notice View seconds of coverage left for _protocol before it runs out of active balance   /// @param _protocol Protocol identifier   /// @return Seconds of coverage left   function secondsOfCoverageLeft(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return _secondsOfCoverageLeft(_protocol);   } // Helper function to return seconds of coverage left for a protocol   // Gets the current active balance of the protocol and divides by the premium per second for the protocol   function secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {     uint256 premium = premiums[_protocol];     if (premium == 0) return 0;     return _activeBalance(_protocol) / premium;   } /// @notice View current active balance of covered protocol   /// @param _protocol Protocol identifier   /// @return Active balance   /// @dev Accrued debt is subtracted from the stored active balance   function activeBalance(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return _activeBalance(_protocol);   } // Helper function to calc the active balance of a protocol at current time   function _activeBalance(bytes32 _protocol) internal view returns (uint256) {     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     uint256 balance = activeBalances[_protocol];     // The debt should never be higher than the balance (only happens if the arbitrages fail)     if (debt &gt; balance) return 0;     return balance - debt;   } //   // State methods   // /// @notice Helps set the premium per second for an individual protocol   /// @param protocol Protocol identifier   /// @param _premium New premium per second   /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function   function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)     internal     returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)   {     // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers     // Also updates the last accounted timestamp for this protocol     // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings     // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol     nonStakerPercentage = _settleProtocolDebt(_protocol);     // Stores the old premium before it gets updated     oldPremiumPerSecond = premiums[_protocol]; if (oldPremiumPerSecond != _premium) {   // Sets the protocol's premium per second to the new value   premiums_[_protocol] = _premium;   emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium); } // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point // Where arbs would no longer be incentivized to remove the protocol // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems if (_premium != 0 &amp;&amp; _secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_OF_COVERAGE) {   revert InsufficientBalance(_protocol); }  } /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second   /// @param _protocol Protocol identifier   /// @param _premium New premium per second   function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {     // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings     (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(       _protocol,       _premium     );     // Settling the total amount of premiums owed to stakers before a new premium per second gets set     _settleTotalDebt();     // This calculates the new global premium per second that gets paid to stakers     // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function     allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(       oldPremiumPerSecond,       _premium,       nonStakerPercentage,       nonStakerPercentage,       allPremiumsPerSecToStakers     );   } // Internal function to set a new protocolAgent for a specific protocol   // oldAgent is only included as part of emitting an event   function _setProtocolAgent(     bytes32 _protocol,     address _oldAgent,     address _protocolAgent   ) internal {     protocolAgent[_protocol] = _protocolAgent;     emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);   } // Subtracts the accrued debt from a protocol's active balance   // Credits the amount that can be claimed by nonstakers for this protocol   // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings   // Most of this function is dealing with an edge case related to a protocol not being removed by arbs   function settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {     // This calcs the accrued debt of the protocol since it was last updated     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     // This pulls the percentage that is sent to nonstakers     _nonStakerPercentage = nonStakersPercentage[_protocol];     // In case the protocol has accrued debt, this code block will ensure the debt is settled properly     if (debt != 0) {       // Pulls the stored active balance of the protocol       uint256 balance = activeBalances[_protocol];       // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance       // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point       // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage       // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up       if (debt &gt; balance) {         // This error amount represents the magnitude of the mistake         uint256 error = debt - balance;         // Gets the latest value of claimable premiums for stakers         _settleTotalDebt();         // @note to production, set premium first to zero before solving accounting issue.         // otherwise the accounting error keeps increasing         uint256 lastClaimablePremiumsForStakers = lastClaimablePremiumsForStakers;     // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%     uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /       HUNDRED_PERCENT;      // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short     uint256 insufficientTokens;      // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally     // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error     // This first line can be true if claimPremiumsForStakers() has been called and     // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be &gt;0 still     if (claimablePremiumError &gt; lastClaimablePremiumsForStakers_) {       insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;       lastClaimablePremiumsForStakers = 0;     } else {       // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums       // By the amount that was added in error (error) and insufficientTokens = 0       lastClaimablePremiumsForStakers =         lastClaimablePremiumsForStakers_ -         claimablePremiumError;     }      // If two events are thrown, the values need to be summed up for the actual state.     // This means an error of this type will continue until it is handled     emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);     // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case     debt = balance;   }   // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance   activeBalances[_protocol] = balance - debt;   // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol   nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT; } // Updates the last accounted timestamp for this protocol lastAccountedEachProtocol[_protocol] = block.timestamp;  } // Multiplies the total premium per second * number of seconds since the last global accounting update   // And adds it to the total claimable amount for stakers   function _settleTotalDebt() internal {     lastClaimablePremiumsForStakers +=       (block.timestamp - lastAccountedGlobal) *       allPremiumsPerSecToStakers;     lastAccountedGlobal = block.timestamp;   } // Calculates the global premium per second for stakers   // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers   // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones   function _calcGlobalPremiumPerSecForStakers(     uint256 _premiumOld,     uint256 _premiumNew,     uint256 _nonStakerPercentageOld,     uint256 _nonStakerPercentageNew,     uint256 _inMemAllPremiumsPerSecToStakers   ) internal pure returns (uint256) {     return       _inMemAllPremiumsPerSecToStakers +       ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /       HUNDRED_PERCENT -       ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /       HUNDRED_PERCENT;   } // Helper function to remove and clean up a protocol from Sherlock   // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made   function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {     // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol     _setSingleAndGlobalProtocolPremium(_protocol, 0); // Grabs the protocol's active balance uint256 balance = activeBalances[_protocol];  // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent if (balance != 0) {   delete activeBalances[_protocol];   token.safeTransfer(_agent, balance);    emit ProtocolBalanceWithdrawn(_protocol, balance); }  // Sets the protocol agent to zero address (as part of clean up) _setProtocolAgent(_protocol, _agent, address(0));  // Cleans up other mappings for this protocol delete nonStakersPercentage[_protocol]; delete lastAccountedEachProtocol[_protocol]; // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above  // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;  // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked removedProtocolAgent[_protocol] = _agent;  emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0)); emit ProtocolRemoved(_protocol);  } /// @notice Sets the minimum active balance before an arb can remove a protocol   /// @param _minActiveBalance Minimum balance needed (in USDC)   /// @dev Only gov   function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {     // New value cannot be the same as current value     if (minActiveBalance == _minActiveBalance) revert InvalidArgument();     // Can't set a value that is too high to be reasonable     if (_minActiveBalance &gt;= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions(); emit MinBalance(minActiveBalance, _minActiveBalance); minActiveBalance = _minActiveBalance;  } // This function allows the nonstakers role to claim tokens owed to them by a specific protocol   /// @notice Choose an _amount of tokens that nonstakers (_receiver address) will receive from _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens   /// @param _receiver Address to receive tokens   /// @dev Only callable by nonstakers role   function nonStakersClaim(     bytes32 _protocol,     uint256 _amount,     address _receiver   ) external override whenNotPaused {     if (_protocol == bytes32(0)) revert ZeroArgument();     if (_amount == uint256(0)) revert ZeroArgument();     if (_receiver == address(0)) revert ZeroArgument();     // Only the nonstakers role (multisig or contract) can pull the funds     if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized(); // Call can't be executed on protocol that is removed if (protocolAgent_[_protocol] != address(0)) {   // Updates the amount that nonstakers can claim from this protocol   _settleProtocolDebt(_protocol); }  // Sets balance to the amount that is claimable by nonstakers for this specific protocol uint256 balance = nonStakersClaimableByProtocol[_protocol]; // If the amount requested is more than what's owed to nonstakers, revert if (_amount &gt; balance) revert InsufficientBalance(_protocol);  // Sets the claimable amount to whatever is left over after this amount is pulled nonStakersClaimableByProtocol[_protocol] = balance - _amount; // Transfers the amount requested to the `_receiver` address token.safeTransfer(_receiver, _amount);  } // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)   /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address   /// @dev Callable by everyone   /// @dev Funds will be transferred to Sherlock core contract   function claimPremiumsForStakers() external override whenNotPaused {     // Gets address of core Sherlock contract     address sherlock = address(sherlockCore);     // Revert if core Sherlock contract not initialized yet     if (sherlock == address(0)) revert InvalidConditions(); // claimablePremiums is different from _settleTotalDebt() because it does not change state // Retrieves current amount of all premiums that are owed to stakers uint256 amount = claimablePremiums();  // Transfers all the premiums owed to stakers to the Sherlock core contract if (amount != 0) {   // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out   lastClaimablePremiumsForStakers = 0;   lastAccountedGlobal = block.timestamp;   token.safeTransfer(sherlock, amount); }  } // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts   /// @param protocol Protocol identifier   /// @return current and previous are the current and previous coverage amounts for this protocol   // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)   function coverageAmounts(bytes32 _protocol)     external     view     override     returns (uint256 current, uint256 previous)   {     // Checks to see if the protocol has an active protocolAgent (protocol not removed)     // OR checks to see if the removed protocol is still within the claim window     // If so, gives the current and previous coverage, otherwise throws an error     if (       protocolAgent[_protocol] != address(0) ||       block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]     ) {       return (currentCoverage[_protocol], previousCoverage[_protocol]);     } revert ProtocolNotExists(_protocol);  } /// @notice Add a new protocol to Sherlock   /// @param protocol Protocol identifier   /// @param _protocolAgent Address able to submit a claim on behalf of the protocol   /// @param _coverage Hash referencing the active coverage agreement   /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 1018   /// @param _coverageAmount Max amount claimable by this protocol   /// @dev Adding a protocol allows the _protocolAgent to submit a claim   /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point   /// @dev _nonStakers is scaled by 1018   /// @dev Only callable by governance   function protocolAdd(     bytes32 _protocol,     address _protocolAgent,     bytes32 _coverage,     uint256 _nonStakers,     uint256 _coverageAmount   ) external override onlyOwner {     if (_protocol == bytes32(0)) revert ZeroArgument();     if (_protocolAgent == address(0)) revert ZeroArgument();     // Checks to make sure the protocol doesn't exist already     if (protocolAgent[_protocol] != address(0)) revert InvalidConditions(); // Updates the protocol agent and passes in the old agent which is 0 address in this case _setProtocolAgent(_protocol, address(0), _protocolAgent);  // Delete mappings that are potentially non default values // From previous time protocol was added/removed delete removedProtocolClaimDeadline[_protocol]; delete removedProtocolAgent[_protocol]; delete currentCoverage[_protocol]; delete previousCoverage[_protocol];  emit ProtocolAdded(_protocol);  // Most of the logic for actually adding a protocol in this function protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);  } /// @notice Update info regarding a protocol   /// @param _protocol Protocol identifier   /// @param _coverage Hash referencing the active coverage agreement   /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18   /// @param _coverageAmount Max amount claimable by this protocol   /// @dev Only callable by governance   /// @dev _nonStakers can be 0   function protocolUpdate(     bytes32 _protocol,     bytes32 _coverage,     uint256 _nonStakers,     uint256 _coverageAmount   ) public override onlyOwner {     if (_coverage == bytes32(0)) revert ZeroArgument();     if (_nonStakers &gt; HUNDRED_PERCENT) revert InvalidArgument();     if (_coverageAmount == uint256(0)) revert ZeroArgument(); // Checks to make sure the protocol has been assigned a protocol agent _verifyProtocolExists(_protocol);  // Subtracts the accrued debt from a protocol's active balance (if any) // Updates the amount that can be claimed by nonstakers _settleProtocolDebt(_protocol);  // Updates the global claimable amount for stakers _settleTotalDebt();  // Gets the premium per second for this protocol uint256 premium = premiums_[_protocol];  // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be) allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(   premium,   premium,   nonStakersPercentage[_protocol],   _nonStakers,   allPremiumsPerSecToStakers );  // Updates the stored value of percentage of premiums that go to nonstakers nonStakersPercentage[_protocol] = _nonStakers;  // Updates previous coverage and current coverage amounts previousCoverage[_protocol] = currentCoverage[_protocol]; currentCoverage[_protocol] = _coverageAmount;  emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);  } /// @notice Remove a protocol from coverage   /// @param _protocol Protocol identifier   /// @dev Before removing a protocol the premium must be 0   /// @dev Removing a protocol basically stops the _protocolAgent from being active (can still submit claims until claim deadline though)   /// @dev Pays off debt + sends remaining balance to protocol agent   /// @dev This call should be subject to a timelock   /// @dev Only callable by governance   function protocolRemove(bytes32 _protocol) external override onlyOwner {     // checks to make sure the protocol actually has a protocol agent     address agent = _verifyProtocolExists(_protocol); // Removes a protocol from Sherlock and cleans up its data // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made _forceRemoveProtocol(_protocol, agent);  } /// @notice Remove a protocol with insufficient active balance   /// @param _protocol Protocol identifier   // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function   function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {     address agent = _verifyProtocolExists(_protocol); // Gets the latest value of the active balance at this protocol _settleProtocolDebt(_protocol); // Sets latest value of active balance to remainingBalance variable uint256 remainingBalance = activeBalances[_protocol];  // This means the protocol still has adequate active balance and thus cannot be removed if (remainingBalance &gt;= minActiveBalance) revert InvalidConditions();  // Sets the protocol's active balance to 0 delete activeBalances[_protocol]; // Removes the protocol from coverage _forceRemoveProtocol(_protocol, agent);  if (remainingBalance != 0) {   // sends the remaining balance to msg.sender   token.safeTransfer(msg.sender, remainingBalance); } emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);  } /// @notice Calculate if arb is possible and what the reward would be   /// @param _protocol Protocol identifier   /// @return arbAmount Amount reward for arbing   /// @return able Indicator if arb call is even possible   /// @dev Doesn't subtract the current protocol debt from the active balance   function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)     internal     view     returns (uint256 arbAmount, bool able)   {     uint256 secondsLeft = _secondsOfCoverageLeft(_protocol); // If arb is not possible return false if (secondsLeft &gt;= MIN_SECONDS_OF_COVERAGE) return (0, false);  // This percentage scales over time // Reaches 100% on 0 seconds of coverage left uint256 percentageScaled = HUNDRED_PERCENT -   (secondsLeft * HUNDRED_PERCENT) /   MIN_SECONDS_OF_COVERAGE;  able = true; arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;  } /// @notice Removes a protocol with insufficent seconds of coverage left   /// @param _protocol Protocol identifier   // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second   function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {     // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings     address agent = _verifyProtocolExists(_protocol); // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance() // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance() // But when removing based on seconds of coverage left, the remainingBalance could still be quite large // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%) _settleProtocolDebt(_protocol); (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol); if (able == false) revert InvalidConditions();  if (arbAmount != 0) {   // subtracts the amount that will be paid to the arb from the active balance   activeBalances[_protocol] -= arbAmount; }  // Removes the protocol from coverage // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above _forceRemoveProtocol(_protocol, agent);  // Done after removing protocol to mitigate reentrency pattern // (In case token allows callback) if (arbAmount != 0) {   token.safeTransfer(msg.sender, arbAmount); } emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);  } /// @notice Set premium of _protocol to _premium   /// @param _protocol Protocol identifier   /// @param _premium Amount of premium _protocol pays per second   /// @dev The value 0 would mean inactive coverage   /// @dev Only callable by governance   function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {     // Checks to see if protocol has a protocol agent     _verifyProtocolExists(_protocol); // Updates individual protocol's premium and allPremiumsPerSecToStakers _setSingleAndGlobalProtocolPremium(_protocol, _premium);  } /// @notice Set premium of multiple protocols   /// @param _protocol Array of protocol identifiers   /// @param _premium Array of premium amounts protocols pay per second   /// @dev The value 0 would mean inactive coverage   /// @dev Only callable by governance   function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)     external     override     onlyOwner   {     // Checks to make sure there are an equal amount of entries in each array     if (_protocol.length != _premium.length) revert UnequalArrayLength();     if (_protocol.length == 0) revert InvalidArgument(); // Updates the global claimable amount for stakers _settleTotalDebt();  uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;  // Loops through the array of protocols and checks to make sure each has a protocol agent assigned for (uint256 i; i &lt; _protocol.length; i++) {   _verifyProtocolExists(_protocol[i]);    // Sets the protocol premium for that specific protocol   // Function returns the old premium and nonStakerPercentage for that specific protocol   (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(     _protocol[i],     _premium[i]   );    // Calculates the new global premium which adds up all premiums paid by all protocols   allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(     oldPremiumPerSecond,     _premium[i],     nonStakerPercentage,     nonStakerPercentage,     allPremiumsPerSecToStakers_   ); }  // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;  } // This is how protocols pay for coverage by increasing their active balance   /// @notice Deposits _amount of token to the active balance of _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens to deposit   /// @dev Approval should be made before calling   function depositToActiveBalance(bytes32 _protocol, uint256 _amount)     external     override     whenNotPaused   {     if (_amount == uint256(0)) revert ZeroArgument();     _verifyProtocolExists(_protocol); // Transfers _amount to this contract token.safeTransferFrom(msg.sender, address(this), _amount); // Increases the active balance of the protocol by _amount activeBalances[_protocol] += _amount;  emit ProtocolBalanceDeposited(_protocol, _amount);  } // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)   // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)   /// @notice Withdraws _amount of token from the active balance of _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens to withdraw   /// @dev Only protocol agent is able to withdraw   /// @dev Balance can be withdrawn up until 7 days worth of active balance   function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)     external     override     whenNotPaused   {     if (_amount == uint256(0)) revert ZeroArgument();     // Only the protocol agent can call this function     if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized(); // Updates the active balance of the protocol _settleProtocolDebt(_protocol);  // Sets currentBalance to the active balance of the protocol uint256 currentBalance = activeBalances[_protocol]; // Reverts if trying to withdraw more than the active balance if (_amount &gt; currentBalance) revert InsufficientBalance(_protocol);  // Removes the _amount to be withdrawn from the active balance activeBalances[_protocol] = currentBalance - _amount; // Reverts if a protocol has less than 7 days worth of active balance left if (_secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);  // Transfers the amount to the msg.sender (protocol agent) token.safeTransfer(msg.sender, _amount); emit ProtocolBalanceWithdrawn(_protocol, _amount);  } /// @notice Transfer protocol agent role   /// @param _protocol Protocol identifier   /// @param _protocolAgent Account able to submit a claim on behalf of the protocol   /// @dev Only the active protocolAgent is able to transfer the role   function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)     external     override     whenNotPaused   {     if (_protocolAgent == address(0)) revert ZeroArgument();     // Can't set the new protocol agent to the caller address     if (msg.sender == _protocolAgent) revert InvalidArgument();     // Because the caller must be the current protocol agent     if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized(); // Sets the protocol agent to the new address _setProtocolAgent(_protocol, msg.sender, _protocolAgent);  } /// @notice Function used to check if this is the current active protocol manager   /// @return Boolean indicating it's active   /// @dev If inactive the owner can pull all ERC20s and ETH   /// @dev Will be checked by calling the sherlock contract   function isActive() public view returns (bool) {     return address(sherlockCore.sherlockProtocolManager()) == address(this);   } // Only contract owner can call this   // Sends all specified tokens in this contract to the receiver's address (as well as ETH)   function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {     if (_receiver == address(0)) revert ZeroArgument();     // This contract must NOT be the current assigned protocol manager contract     if (isActive()) revert InvalidConditions();     // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH     _sweep(_receiver, _extraTokens);   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-25-08 10:58:53 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import './Manager.sol';
import '../interfaces/managers/ISherlockProtocolManager.sol';

/// @title Sherlock core interface for protocols
/// @author Evert Kors
// This is the contract that manages covered protocols

contract SherlockProtocolManager is ISherlockProtocolManager, Manager {
  using SafeERC20 for IERC20;

  // Represents the token that protocols pay with (currently USDC)
  IERC20 public immutable token;

  // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed
  uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc

  // A removed protocol is still able to make a claim for this amount of time after its removal
  uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days;

  // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance
  uint256 public constant MIN_SECONDS_LEFT = 7 days;

  // Convenient for percentage calculations
  uint256 internal constant HUNDRED_PERCENT = 10**18;

  // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage
  // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying
  uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours;

  // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)
  mapping(bytes32 => address) internal protocolAgent_;

  // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)
  mapping(bytes32 => uint256) internal nonStakersPercentage;

  // The premium per second paid by each protocol is stored in this mapping
  mapping(bytes32 => uint256) internal premiums_;

  // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.
  // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not
  mapping(bytes32 => uint256) internal activeBalances;

  // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol
  mapping(bytes32 => uint256) internal lastAccountedEachProtocol;

  // The amount that can be claimed by nonstakers for each protocol
  // We need this value so we can track how much payment is coming from each protocol
  mapping(bytes32 => uint256) internal nonStakersClaimableByProtocol;

  // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)
  uint256 internal lastAccountedGlobal;

  // This is the total amount of premiums paid (per second) by all the covered protocols (added up)
  uint256 internal allPremiumsPerSecToStakers;

  // This is the amount that was claimable by stakers the last time the accounting was run
  // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date
  uint256 internal lastClaimablePremiumsForStakers;

  // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage
  // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)
  uint256 public override minActiveBalance;

  // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)
  mapping(bytes32 => uint256) internal removedProtocolClaimDeadline;

  // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)
  mapping(bytes32 => address) internal removedProtocolAgent;

  // Current amount of coverage (i.e. 20M USDC) for a protocol
  mapping(bytes32 => uint256) internal currentCoverage;

  // Previous amount of coverage for a protocol
  // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount
  mapping(bytes32 => uint256) internal previousCoverage;

  // Setting the token to USDC
  constructor(IERC20 _token) {
    if (address(_token) == address(0)) revert ZeroArgument();
    token = _token;
  }

  // Modifier used to ensure a protocol exists (has been instantiated and not removed)
  modifier protocolExists(bytes32 _protocol) {
    _verifyProtocolExists(_protocol);
    _;
  }

  /// @notice View current protocolAgent of `_protocol`
  /// @param _protocol Protocol identifier
  /// @return Address able to submit claims
  function protocolAgent(bytes32 _protocol) external view override returns (address) {
    address agent = protocolAgent_[_protocol];
    if (agent != address(0)) return agent;

    // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned
    // Note: Old protocol agent will never be address(0)
    if (block.timestamp <= removedProtocolClaimDeadline[_protocol]) {
      return removedProtocolAgent[_protocol];
    }

    // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned
    revert ProtocolNotExists(_protocol);
  }

  // Checks if the protocol exists, then returns the current premium per second being charged
  /// @notice View current premium of protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of premium `_protocol` pays per second
  function premium(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return premiums_[_protocol];
  }

  // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)
  // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)
  function _verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {
    _protocolAgent = protocolAgent_[_protocol];
    if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);
  }

  //
  // View methods
  //

  // Calcs the debt accrued by the protocol since it last had an accounting update
  // This is the amount that needs to be removed from a protocol's active balance
  function _calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {
    return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums_[_protocol];
  }

  /// @notice View the amount nonstakers can claim from this protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of tokens claimable by nonstakers
  /// @dev this reads from a storage variable + (now-lastsettled) * premiums
  // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]
  // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed
  function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {
    // Calcs the debt of a protocol since the last accounting update
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // Gets the active balance of the protocol
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) debt = balance;

    // Adds the incremental claimable amount owed to nonstakers to the total claimable amount
    return
      nonStakersClaimableByProtocol[_protocol] +
      (nonStakersPercentage[_protocol] * debt) /
      HUNDRED_PERCENT;
  }

  /// @notice View current amount of all premiums that are owed to stakers
  /// @return Premiums claimable
  /// @dev Will increase every block
  /// @dev base + (now - last_settled) * ps
  function claimablePremiums() public view override returns (uint256) {
    // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)
    return
      lastClaimablePremiumsForStakers +
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
  }

  /// @notice View seconds of coverage left for `_protocol` before it runs out of active balance
  /// @param _protocol Protocol identifier
  /// @return Seconds of coverage left
  function secondsOfCoverageLeft(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _secondsOfCoverageLeft(_protocol);
  }

  // Helper function to return seconds of coverage left for a protocol
  // Gets the current active balance of the protocol and divides by the premium per second for the protocol
  function _secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {
    uint256 premium = premiums_[_protocol];
    if (premium == 0) return 0;
    return _activeBalance(_protocol) / premium;
  }

  /// @notice View current active balance of covered protocol
  /// @param _protocol Protocol identifier
  /// @return Active balance
  /// @dev Accrued debt is subtracted from the stored active balance
  function activeBalance(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _activeBalance(_protocol);
  }

  // Helper function to calc the active balance of a protocol at current time
  function _activeBalance(bytes32 _protocol) internal view returns (uint256) {
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) return 0;
    return balance - debt;
  }

  //
  // State methods
  //

  /// @notice Helps set the premium per second for an individual protocol
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function
  function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)
    internal
    returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)
  {
    // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers
    // Also updates the last accounted timestamp for this protocol
    // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings
    // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol
    nonStakerPercentage = _settleProtocolDebt(_protocol);
    // Stores the old premium before it gets updated
    oldPremiumPerSecond = premiums_[_protocol];

    if (oldPremiumPerSecond != _premium) {
      // Sets the protocol's premium per second to the new value
      premiums_[_protocol] = _premium;
      emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium);
    }
    // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing
    // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes
    // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point
    // Where arbs would no longer be incentivized to remove the protocol
    // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems
    if (_premium != 0 && _secondsOfCoverageLeft(_protocol) < MIN_SECONDS_OF_COVERAGE) {
      revert InsufficientBalance(_protocol);
    }
  }

  /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {
    // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings
    (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
      _protocol,
      _premium
    );
    // Settling the total amount of premiums owed to stakers before a new premium per second gets set
    _settleTotalDebt();
    // This calculates the new global premium per second that gets paid to stakers
    // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      oldPremiumPerSecond,
      _premium,
      nonStakerPercentage,
      nonStakerPercentage,
      allPremiumsPerSecToStakers
    );
  }

  // Internal function to set a new protocolAgent for a specific protocol
  // _oldAgent is only included as part of emitting an event
  function _setProtocolAgent(
    bytes32 _protocol,
    address _oldAgent,
    address _protocolAgent
  ) internal {
    protocolAgent_[_protocol] = _protocolAgent;
    emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);
  }

  // Subtracts the accrued debt from a protocol's active balance
  // Credits the amount that can be claimed by nonstakers for this protocol
  // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings
  // Most of this function is dealing with an edge case related to a protocol not being removed by arbs
  function _settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {
    // This calcs the accrued debt of the protocol since it was last updated
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // This pulls the percentage that is sent to nonstakers
    _nonStakerPercentage = nonStakersPercentage[_protocol];
    // In case the protocol has accrued debt, this code block will ensure the debt is settled properly
    if (debt != 0) {
      // Pulls the stored active balance of the protocol
      uint256 balance = activeBalances[_protocol];
      // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance
      // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point
      // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage
      // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up
      if (debt > balance) {
        // This error amount represents the magnitude of the mistake
        uint256 error = debt - balance;
        // Gets the latest value of claimable premiums for stakers
        _settleTotalDebt();
        // @note to production, set premium first to zero before solving accounting issue.
        // otherwise the accounting error keeps increasing
        uint256 lastClaimablePremiumsForStakers_ = lastClaimablePremiumsForStakers;

        // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%
        uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /
          HUNDRED_PERCENT;

        // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short
        uint256 insufficientTokens;

        // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally
        // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error
        // This first line can be true if claimPremiumsForStakers() has been called and
        // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be >0 still
        if (claimablePremiumError > lastClaimablePremiumsForStakers_) {
          insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;
          lastClaimablePremiumsForStakers = 0;
        } else {
          // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums
          // By the amount that was added in error (error) and insufficientTokens = 0
          lastClaimablePremiumsForStakers =
            lastClaimablePremiumsForStakers_ -
            claimablePremiumError;
        }

        // If two events are thrown, the values need to be summed up for the actual state.
        // This means an error of this type will continue until it is handled
        emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);
        // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case
        debt = balance;
      }
      // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance
      activeBalances[_protocol] = balance - debt;
      // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol
      nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT;
    }
    // Updates the last accounted timestamp for this protocol
    lastAccountedEachProtocol[_protocol] = block.timestamp;
  }

  // Multiplies the total premium per second * number of seconds since the last global accounting update
  // And adds it to the total claimable amount for stakers
  function _settleTotalDebt() internal {
    lastClaimablePremiumsForStakers +=
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
    lastAccountedGlobal = block.timestamp;
  }

  // Calculates the global premium per second for stakers
  // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers
  // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones
  function _calcGlobalPremiumPerSecForStakers(
    uint256 _premiumOld,
    uint256 _premiumNew,
    uint256 _nonStakerPercentageOld,
    uint256 _nonStakerPercentageNew,
    uint256 _inMemAllPremiumsPerSecToStakers
  ) internal pure returns (uint256) {
    return
      _inMemAllPremiumsPerSecToStakers +
      ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /
      HUNDRED_PERCENT -
      ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /
      HUNDRED_PERCENT;
  }

  // Helper function to remove and clean up a protocol from Sherlock
  // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made
  function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {
    // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol
    _setSingleAndGlobalProtocolPremium(_protocol, 0);

    // Grabs the protocol's active balance
    uint256 balance = activeBalances[_protocol];

    // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent
    if (balance != 0) {
      delete activeBalances[_protocol];
      token.safeTransfer(_agent, balance);

      emit ProtocolBalanceWithdrawn(_protocol, balance);
    }

    // Sets the protocol agent to zero address (as part of clean up)
    _setProtocolAgent(_protocol, _agent, address(0));

    // Cleans up other mappings for this protocol
    delete nonStakersPercentage[_protocol];
    delete lastAccountedEachProtocol[_protocol];
    // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above

    // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol
    removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;

    // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed
    // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked
    removedProtocolAgent[_protocol] = _agent;

    emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0));
    emit ProtocolRemoved(_protocol);
  }

  /// @notice Sets the minimum active balance before an arb can remove a protocol
  /// @param _minActiveBalance Minimum balance needed (in USDC)
  /// @dev Only gov
  function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {
    // New value cannot be the same as current value
    if (minActiveBalance == _minActiveBalance) revert InvalidArgument();
    // Can't set a value that is too high to be reasonable
    if (_minActiveBalance >= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions();

    emit MinBalance(minActiveBalance, _minActiveBalance);
    minActiveBalance = _minActiveBalance;
  }

  // This function allows the nonstakers role to claim tokens owed to them by a specific protocol
  /// @notice Choose an `_amount` of tokens that nonstakers (`_receiver` address) will receive from `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens
  /// @param _receiver Address to receive tokens
  /// @dev Only callable by nonstakers role
  function nonStakersClaim(
    bytes32 _protocol,
    uint256 _amount,
    address _receiver
  ) external override whenNotPaused {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_amount == uint256(0)) revert ZeroArgument();
    if (_receiver == address(0)) revert ZeroArgument();
    // Only the nonstakers role (multisig or contract) can pull the funds
    if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized();

    // Call can't be executed on protocol that is removed
    if (protocolAgent_[_protocol] != address(0)) {
      // Updates the amount that nonstakers can claim from this protocol
      _settleProtocolDebt(_protocol);
    }

    // Sets balance to the amount that is claimable by nonstakers for this specific protocol
    uint256 balance = nonStakersClaimableByProtocol[_protocol];
    // If the amount requested is more than what's owed to nonstakers, revert
    if (_amount > balance) revert InsufficientBalance(_protocol);

    // Sets the claimable amount to whatever is left over after this amount is pulled
    nonStakersClaimableByProtocol[_protocol] = balance - _amount;
    // Transfers the amount requested to the `_receiver` address
    token.safeTransfer(_receiver, _amount);
  }

  // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)
  /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address
  /// @dev Callable by everyone
  /// @dev Funds will be transferred to Sherlock core contract
  function claimPremiumsForStakers() external override whenNotPaused {
    // Gets address of core Sherlock contract
    address sherlock = address(sherlockCore);
    // Revert if core Sherlock contract not initialized yet
    if (sherlock == address(0)) revert InvalidConditions();

    // claimablePremiums is different from _settleTotalDebt() because it does not change state
    // Retrieves current amount of all premiums that are owed to stakers
    uint256 amount = claimablePremiums();

    // Transfers all the premiums owed to stakers to the Sherlock core contract
    if (amount != 0) {
      // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out
      lastClaimablePremiumsForStakers = 0;
      lastAccountedGlobal = block.timestamp;
      token.safeTransfer(sherlock, amount);
    }
  }

  // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts
  /// @param _protocol Protocol identifier
  /// @return current and previous are the current and previous coverage amounts for this protocol
  // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)
  function coverageAmounts(bytes32 _protocol)
    external
    view
    override
    returns (uint256 current, uint256 previous)
  {
    // Checks to see if the protocol has an active protocolAgent (protocol not removed)
    // OR checks to see if the removed protocol is still within the claim window
    // If so, gives the current and previous coverage, otherwise throws an error
    if (
      protocolAgent_[_protocol] != address(0) ||
      block.timestamp <= removedProtocolClaimDeadline[_protocol]
    ) {
      return (currentCoverage[_protocol], previousCoverage[_protocol]);
    }

    revert ProtocolNotExists(_protocol);
  }

  /// @notice Add a new protocol to Sherlock
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Address able to submit a claim on behalf of the protocol
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Adding a protocol allows the `_protocolAgent` to submit a claim
  /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point
  /// @dev `_nonStakers` is scaled by 10**18
  /// @dev Only callable by governance
  function protocolAdd(
    bytes32 _protocol,
    address _protocolAgent,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) external override onlyOwner {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Checks to make sure the protocol doesn't exist already
    if (protocolAgent_[_protocol] != address(0)) revert InvalidConditions();

    // Updates the protocol agent and passes in the old agent which is 0 address in this case
    _setProtocolAgent(_protocol, address(0), _protocolAgent);

    // Delete mappings that are potentially non default values
    // From previous time protocol was added/removed
    delete removedProtocolClaimDeadline[_protocol];
    delete removedProtocolAgent[_protocol];
    delete currentCoverage[_protocol];
    delete previousCoverage[_protocol];

    emit ProtocolAdded(_protocol);

    // Most of the logic for actually adding a protocol in this function
    protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Update info regarding a protocol
  /// @param _protocol Protocol identifier
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Only callable by governance
  /// @dev `_nonStakers` can be 0
  function protocolUpdate(
    bytes32 _protocol,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) public override onlyOwner {
    if (_coverage == bytes32(0)) revert ZeroArgument();
    if (_nonStakers > HUNDRED_PERCENT) revert InvalidArgument();
    if (_coverageAmount == uint256(0)) revert ZeroArgument();

    // Checks to make sure the protocol has been assigned a protocol agent
    _verifyProtocolExists(_protocol);

    // Subtracts the accrued debt from a protocol's active balance (if any)
    // Updates the amount that can be claimed by nonstakers
    _settleProtocolDebt(_protocol);

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    // Gets the premium per second for this protocol
    uint256 premium = premiums_[_protocol];

    // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be)
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      premium,
      premium,
      nonStakersPercentage[_protocol],
      _nonStakers,
      allPremiumsPerSecToStakers
    );

    // Updates the stored value of percentage of premiums that go to nonstakers
    nonStakersPercentage[_protocol] = _nonStakers;

    // Updates previous coverage and current coverage amounts
    previousCoverage[_protocol] = currentCoverage[_protocol];
    currentCoverage[_protocol] = _coverageAmount;

    emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Remove a protocol from coverage
  /// @param _protocol Protocol identifier
  /// @dev Before removing a protocol the premium must be 0
  /// @dev Removing a protocol basically stops the `_protocolAgent` from being active (can still submit claims until claim deadline though)
  /// @dev Pays off debt + sends remaining balance to protocol agent
  /// @dev This call should be subject to a timelock
  /// @dev Only callable by governance
  function protocolRemove(bytes32 _protocol) external override onlyOwner {
    // checks to make sure the protocol actually has a protocol agent
    address agent = _verifyProtocolExists(_protocol);

    // Removes a protocol from Sherlock and cleans up its data
    // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made
    _forceRemoveProtocol(_protocol, agent);
  }

  /// @notice Remove a protocol with insufficient active balance
  /// @param _protocol Protocol identifier
  // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function
  function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {
    address agent = _verifyProtocolExists(_protocol);

    // Gets the latest value of the active balance at this protocol
    _settleProtocolDebt(_protocol);
    // Sets latest value of active balance to remainingBalance variable
    uint256 remainingBalance = activeBalances[_protocol];

    // This means the protocol still has adequate active balance and thus cannot be removed
    if (remainingBalance >= minActiveBalance) revert InvalidConditions();

    // Sets the protocol's active balance to 0
    delete activeBalances[_protocol];
    // Removes the protocol from coverage
    _forceRemoveProtocol(_protocol, agent);

    if (remainingBalance != 0) {
      // sends the remaining balance to msg.sender
      token.safeTransfer(msg.sender, remainingBalance);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);
  }

  /// @notice Calculate if arb is possible and what the reward would be
  /// @param _protocol Protocol identifier
  /// @return arbAmount Amount reward for arbing
  /// @return able Indicator if arb call is even possible
  /// @dev Doesn't subtract the current protocol debt from the active balance
  function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)
    internal
    view
    returns (uint256 arbAmount, bool able)
  {
    uint256 secondsLeft = _secondsOfCoverageLeft(_protocol);

    // If arb is not possible return false
    if (secondsLeft >= MIN_SECONDS_OF_COVERAGE) return (0, false);

    // This percentage scales over time
    // Reaches 100% on 0 seconds of coverage left
    uint256 percentageScaled = HUNDRED_PERCENT -
      (secondsLeft * HUNDRED_PERCENT) /
      MIN_SECONDS_OF_COVERAGE;

    able = true;
    arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;
  }

  /// @notice Removes a protocol with insufficent seconds of coverage left
  /// @param _protocol Protocol identifier
  // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second
  function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {
    // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings
    address agent = _verifyProtocolExists(_protocol);

    // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance()
    // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance()
    // But when removing based on seconds of coverage left, the remainingBalance could still be quite large
    // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance
    // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%)
    _settleProtocolDebt(_protocol);
    (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol);
    if (able == false) revert InvalidConditions();

    if (arbAmount != 0) {
      // subtracts the amount that will be paid to the arb from the active balance
      activeBalances[_protocol] -= arbAmount;
    }

    // Removes the protocol from coverage
    // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above
    _forceRemoveProtocol(_protocol, agent);

    // Done after removing protocol to mitigate reentrency pattern
    // (In case token allows callback)
    if (arbAmount != 0) {
      token.safeTransfer(msg.sender, arbAmount);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);
  }

  /// @notice Set premium of `_protocol` to `_premium`
  /// @param _protocol Protocol identifier
  /// @param _premium Amount of premium `_protocol` pays per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {
    // Checks to see if protocol has a protocol agent
    _verifyProtocolExists(_protocol);

    // Updates individual protocol's premium and allPremiumsPerSecToStakers
    _setSingleAndGlobalProtocolPremium(_protocol, _premium);
  }

  /// @notice Set premium of multiple protocols
  /// @param _protocol Array of protocol identifiers
  /// @param _premium Array of premium amounts protocols pay per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)
    external
    override
    onlyOwner
  {
    // Checks to make sure there are an equal amount of entries in each array
    if (_protocol.length != _premium.length) revert UnequalArrayLength();
    if (_protocol.length == 0) revert InvalidArgument();

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;

    // Loops through the array of protocols and checks to make sure each has a protocol agent assigned
    for (uint256 i; i < _protocol.length; i++) {
      _verifyProtocolExists(_protocol[i]);

      // Sets the protocol premium for that specific protocol
      // Function returns the old premium and nonStakerPercentage for that specific protocol
      (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
        _protocol[i],
        _premium[i]
      );

      // Calculates the new global premium which adds up all premiums paid by all protocols
      allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(
        oldPremiumPerSecond,
        _premium[i],
        nonStakerPercentage,
        nonStakerPercentage,
        allPremiumsPerSecToStakers_
      );
    }

    // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value
    allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;
  }

  // This is how protocols pay for coverage by increasing their active balance
  /// @notice Deposits `_amount` of token to the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to deposit
  /// @dev Approval should be made before calling
  function depositToActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    _verifyProtocolExists(_protocol);

    // Transfers _amount to this contract
    token.safeTransferFrom(msg.sender, address(this), _amount);
    // Increases the active balance of the protocol by _amount
    activeBalances[_protocol] += _amount;

    emit ProtocolBalanceDeposited(_protocol, _amount);
  }

  // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)
  // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)
  /// @notice Withdraws `_amount` of token from the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to withdraw
  /// @dev Only protocol agent is able to withdraw
  /// @dev Balance can be withdrawn up until 7 days worth of active balance
  function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    // Only the protocol agent can call this function
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Updates the active balance of the protocol
    _settleProtocolDebt(_protocol);

    // Sets currentBalance to the active balance of the protocol
    uint256 currentBalance = activeBalances[_protocol];
    // Reverts if trying to withdraw more than the active balance
    if (_amount > currentBalance) revert InsufficientBalance(_protocol);

    // Removes the _amount to be withdrawn from the active balance
    activeBalances[_protocol] = currentBalance - _amount;
    // Reverts if a protocol has less than 7 days worth of active balance left
    if (_secondsOfCoverageLeft(_protocol) < MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);

    // Transfers the amount to the msg.sender (protocol agent)
    token.safeTransfer(msg.sender, _amount);
    emit ProtocolBalanceWithdrawn(_protocol, _amount);
  }

  /// @notice Transfer protocol agent role
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Account able to submit a claim on behalf of the protocol
  /// @dev Only the active protocolAgent is able to transfer the role
  function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)
    external
    override
    whenNotPaused
  {
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Can't set the new protocol agent to the caller address
    if (msg.sender == _protocolAgent) revert InvalidArgument();
    // Because the caller must be the current protocol agent
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Sets the protocol agent to the new address
    _setProtocolAgent(_protocol, msg.sender, _protocolAgent);
  }

  /// @notice Function used to check if this is the current active protocol manager
  /// @return Boolean indicating it's active
  /// @dev If inactive the owner can pull all ERC20s and ETH
  /// @dev Will be checked by calling the sherlock contract
  function isActive() public view returns (bool) {
    return address(sherlockCore.sherlockProtocolManager()) == address(this);
  }

  // Only contract owner can call this
  // Sends all specified tokens in this contract to the receiver's address (as well as ETH)
  function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {
    if (_receiver == address(0)) revert ZeroArgument();
    // This contract must NOT be the current assigned protocol manager contract
    if (isActive()) revert InvalidConditions();
    // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH
    _sweep(_receiver, _extraTokens);
  }
}
.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;
/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/
import './Manager.sol';
import '../interfaces/managers/ISherlockProtocolManager.sol';
/// @title Sherlock core interface for protocols
/// @author Evert Kors
// This is the contract that manages covered protocols
contract SherlockProtocolManager is ISherlockProtocolManager, Manager {
  using SafeERC20 for IERC20;
  // Represents the token that protocols pay with (currently USDC)
  IERC20 public immutable token;
  // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed
  uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc
  // A removed protocol is still able to make a claim for this amount of time after its removal
  uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days;
  // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance
  uint256 public constant MIN_SECONDS_LEFT = 7 days;
  // Convenient for percentage calculations
  uint256 internal constant HUNDRED_PERCENT = 10**18;
  // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage
  // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying
  uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours;
  // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)
  mapping(bytes32 => address) internal protocolAgent_;
  // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)
  mapping(bytes32 => uint256) internal nonStakersPercentage;
  // The premium per second paid by each protocol is stored in this mapping
  mapping(bytes32 => uint256) internal premiums_;
  // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.
  // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not
  mapping(bytes32 => uint256) internal activeBalances;
  // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol
  mapping(bytes32 => uint256) internal lastAccountedEachProtocol;
  // The amount that can be claimed by nonstakers for each protocol
  // We need this value so we can track how much payment is coming from each protocol
  mapping(bytes32 => uint256) internal nonStakersClaimableByProtocol;
  // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)
  uint256 internal lastAccountedGlobal;
  // This is the total amount of premiums paid (per second) by all the covered protocols (added up)
  uint256 internal allPremiumsPerSecToStakers;
  // This is the amount that was claimable by stakers the last time the accounting was run
  // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date
  uint256 internal lastClaimablePremiumsForStakers;
  // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage
  // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)
  uint256 public override minActiveBalance;
  // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)
  mapping(bytes32 => uint256) internal removedProtocolClaimDeadline;
  // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)
  mapping(bytes32 => address) internal removedProtocolAgent;
  // Current amount of coverage (i.e. 20M USDC) for a protocol
  mapping(bytes32 => uint256) internal currentCoverage;
  // Previous amount of coverage for a protocol
  // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount
  mapping(bytes32 => uint256) internal previousCoverage;
  // Setting the token to USDC
  constructor(IERC20 _token) {
    if (address(_token) == address(0)) revert ZeroArgument();
    token = _token;
  }
  // Modifier used to ensure a protocol exists (has been instantiated and not removed)
  modifier protocolExists(bytes32 _protocol) {
    _verifyProtocolExists(_protocol);
    _;
  }
  /// @notice View current protocolAgent of `_protocol`
  /// @param _protocol Protocol identifier
  /// @return Address able to submit claims
  function protocolAgent(bytes32 _protocol) external view override returns (address) {
    address agent = protocolAgent_[_protocol];
    if (agent != address(0)) return agent;
    // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned
    // Note: Old protocol agent will never be address(0)
    if (block.timestamp <= removedProtocolClaimDeadline[_protocol]) {
      return removedProtocolAgent[_protocol];
    }
    // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned
    revert ProtocolNotExists(_protocol);
  }
  // Checks if the protocol exists, then returns the current premium per second being charged
  /// @notice View current premium of protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of premium `_protocol` pays per second
  function premium(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return premiums_[_protocol];
  }
  // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)
  // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)
  function _verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {
    _protocolAgent = protocolAgent_[_protocol];
    if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);
  }
  //
  // View methods
  //
  // Calcs the debt accrued by the protocol since it last had an accounting update
  // This is the amount that needs to be removed from a protocol's active balance
  function _calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {
    return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums_[_protocol];
  }
  /// @notice View the amount nonstakers can claim from this protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of tokens claimable by nonstakers
  /// @dev this reads from a storage variable + (now-lastsettled) * premiums
  // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]
  // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed
  function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {
    // Calcs the debt of a protocol since the last accounting update
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // Gets the active balance of the protocol
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) debt = balance;
    // Adds the incremental claimable amount owed to nonstakers to the total claimable amount
    return
      nonStakersClaimableByProtocol[_protocol] +
      (nonStakersPercentage[_protocol] * debt) /
      HUNDRED_PERCENT;
  }
  /// @notice View current amount of all premiums that are owed to stakers
  /// @return Premiums claimable
  /// @dev Will increase every block
  /// @dev base + (now - last_settled) * ps
  function claimablePremiums() public view override returns (uint256) {
    // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)
    return
      lastClaimablePremiumsForStakers +
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
  }
  /// @notice View seconds of coverage left for `_protocol` before it runs out of active balance
  /// @param _protocol Protocol identifier
  /// @return Seconds of coverage left
  function secondsOfCoverageLeft(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _secondsOfCoverageLeft(_protocol);
  }
  // Helper function to return seconds of coverage left for a protocol
  // Gets the current active balance of the protocol and divides by the premium per second for the protocol
  function _secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {
    uint256 premium = premiums_[_protocol];
    if (premium == 0) return 0;
    return _activeBalance(_protocol) / premium;
  }
  /// @notice View current active balance of covered protocol
  /// @param _protocol Protocol identifier
  /// @return Active balance
  /// @dev Accrued debt is subtracted from the stored active balance
  function activeBalance(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _activeBalance(_protocol);
  }
  // Helper function to calc the active balance of a protocol at current time
  function _activeBalance(bytes32 _protocol) internal view returns (uint256) {
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) return 0;
    return balance - debt;
  }
  //
  // State methods
  //
  /// @notice Helps set the premium per second for an individual protocol
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function
  function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)
    internal
    returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)
  {
    // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers
    // Also updates the last accounted timestamp for this protocol
    // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings
    // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol
    nonStakerPercentage = _settleProtocolDebt(_protocol);
    // Stores the old premium before it gets updated
    oldPremiumPerSecond = premiums_[_protocol];
    if (oldPremiumPerSecond != _premium) {
      // Sets the protocol's premium per second to the new value
      premiums_[_protocol] = _premium;
      emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium);
    }
    // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing
    // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes
    // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point
    // Where arbs would no longer be incentivized to remove the protocol
    // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems
    if (_premium != 0 && _secondsOfCoverageLeft(_protocol) < MIN_SECONDS_OF_COVERAGE) {
      revert InsufficientBalance(_protocol);
    }
  }
  /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {
    // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings
    (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
      _protocol,
      _premium
    );
    // Settling the total amount of premiums owed to stakers before a new premium per second gets set
    _settleTotalDebt();
    // This calculates the new global premium per second that gets paid to stakers
    // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      oldPremiumPerSecond,
      _premium,
      nonStakerPercentage,
      nonStakerPercentage,
      allPremiumsPerSecToStakers
    );
  }
  // Internal function to set a new protocolAgent for a specific protocol
  // _oldAgent is only included as part of emitting an event
  function _setProtocolAgent(
    bytes32 _protocol,
    address _oldAgent,
    address _protocolAgent
  ) internal {
    protocolAgent_[_protocol] = _protocolAgent;
    emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);
  }
  // Subtracts the accrued debt from a protocol's active balance
  // Credits the amount that can be claimed by nonstakers for this protocol
  // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings
  // Most of this function is dealing with an edge case related to a protocol not being removed by arbs
  function _settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {
    // This calcs the accrued debt of the protocol since it was last updated
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // This pulls the percentage that is sent to nonstakers
    _nonStakerPercentage = nonStakersPercentage[_protocol];
    // In case the protocol has accrued debt, this code block will ensure the debt is settled properly
    if (debt != 0) {
      // Pulls the stored active balance of the protocol
      uint256 balance = activeBalances[_protocol];
      // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance
      // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point
      // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage
      // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up
      if (debt > balance) {
        // This error amount represents the magnitude of the mistake
        uint256 error = debt - balance;
        // Gets the latest value of claimable premiums for stakers
        _settleTotalDebt();
        // @note to production, set premium first to zero before solving accounting issue.
        // otherwise the accounting error keeps increasing
        uint256 lastClaimablePremiumsForStakers_ = lastClaimablePremiumsForStakers;
        // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%
        uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /
          HUNDRED_PERCENT;
        // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short
        uint256 insufficientTokens;
        // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally
        // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error
        // This first line can be true if claimPremiumsForStakers() has been called and
        // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be >0 still
        if (claimablePremiumError > lastClaimablePremiumsForStakers_) {
          insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;
          lastClaimablePremiumsForStakers = 0;
        } else {
          // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums
          // By the amount that was added in error (error) and insufficientTokens = 0
          lastClaimablePremiumsForStakers =
            lastClaimablePremiumsForStakers_ -
            claimablePremiumError;
        }
        // If two events are thrown, the values need to be summed up for the actual state.
        // This means an error of this type will continue until it is handled
        emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);
        // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case
        debt = balance;
      }
      // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance
      activeBalances[_protocol] = balance - debt;
      // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol
      nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT;
    }
    // Updates the last accounted timestamp for this protocol
    lastAccountedEachProtocol[_protocol] = block.timestamp;
  }
  // Multiplies the total premium per second * number of seconds since the last global accounting update
  // And adds it to the total claimable amount for stakers
  function _settleTotalDebt() internal {
    lastClaimablePremiumsForStakers +=
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
    lastAccountedGlobal = block.timestamp;
  }
  // Calculates the global premium per second for stakers
  // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers
  // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones
  function _calcGlobalPremiumPerSecForStakers(
    uint256 _premiumOld,
    uint256 _premiumNew,
    uint256 _nonStakerPercentageOld,
    uint256 _nonStakerPercentageNew,
    uint256 _inMemAllPremiumsPerSecToStakers
  ) internal pure returns (uint256) {
    return
      _inMemAllPremiumsPerSecToStakers +
      ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /
      HUNDRED_PERCENT -
      ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /
      HUNDRED_PERCENT;
  }
  // Helper function to remove and clean up a protocol from Sherlock
  // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made
  function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {
    // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol
    _setSingleAndGlobalProtocolPremium(_protocol, 0);
    // Grabs the protocol's active balance
    uint256 balance = activeBalances[_protocol];
    // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent
    if (balance != 0) {
      delete activeBalances[_protocol];
      token.safeTransfer(_agent, balance);
      emit ProtocolBalanceWithdrawn(_protocol, balance);
    }
    // Sets the protocol agent to zero address (as part of clean up)
    _setProtocolAgent(_protocol, _agent, address(0));
    // Cleans up other mappings for this protocol
    delete nonStakersPercentage[_protocol];
    delete lastAccountedEachProtocol[_protocol];
    // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above
    // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol
    removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;
    // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed
    // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked
    removedProtocolAgent[_protocol] = _agent;
    emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0));
    emit ProtocolRemoved(_protocol);
  }
  /// @notice Sets the minimum active balance before an arb can remove a protocol
  /// @param _minActiveBalance Minimum balance needed (in USDC)
  /// @dev Only gov
  function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {
    // New value cannot be the same as current value
    if (minActiveBalance == _minActiveBalance) revert InvalidArgument();
    // Can't set a value that is too high to be reasonable
    if (_minActiveBalance >= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions();
    emit MinBalance(minActiveBalance, _minActiveBalance);
    minActiveBalance = _minActiveBalance;
  }
  // This function allows the nonstakers role to claim tokens owed to them by a specific protocol
  /// @notice Choose an `_amount` of tokens that nonstakers (`_receiver` address) will receive from `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens
  /// @param _receiver Address to receive tokens
  /// @dev Only callable by nonstakers role
  function nonStakersClaim(
    bytes32 _protocol,
    uint256 _amount,
    address _receiver
  ) external override whenNotPaused {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_amount == uint256(0)) revert ZeroArgument();
    if (_receiver == address(0)) revert ZeroArgument();
    // Only the nonstakers role (multisig or contract) can pull the funds
    if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized();
    // Call can't be executed on protocol that is removed
    if (protocolAgent_[_protocol] != address(0)) {
      // Updates the amount that nonstakers can claim from this protocol
      _settleProtocolDebt(_protocol);
    }
    // Sets balance to the amount that is claimable by nonstakers for this specific protocol
    uint256 balance = nonStakersClaimableByProtocol[_protocol];
    // If the amount requested is more than what's owed to nonstakers, revert
    if (_amount > balance) revert InsufficientBalance(_protocol);
    // Sets the claimable amount to whatever is left over after this amount is pulled
    nonStakersClaimableByProtocol[_protocol] = balance - _amount;
    // Transfers the amount requested to the `_receiver` address
    token.safeTransfer(_receiver, _amount);
  }
  // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)
  /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address
  /// @dev Callable by everyone
  /// @dev Funds will be transferred to Sherlock core contract
  function claimPremiumsForStakers() external override whenNotPaused {
    // Gets address of core Sherlock contract
    address sherlock = address(sherlockCore);
    // Revert if core Sherlock contract not initialized yet
    if (sherlock == address(0)) revert InvalidConditions();
    // claimablePremiums is different from _settleTotalDebt() because it does not change state
    // Retrieves current amount of all premiums that are owed to stakers
    uint256 amount = claimablePremiums();
    // Transfers all the premiums owed to stakers to the Sherlock core contract
    if (amount != 0) {
      // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out
      lastClaimablePremiumsForStakers = 0;
      lastAccountedGlobal = block.timestamp;
      token.safeTransfer(sherlock, amount);
    }
  }
  // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts
  /// @param _protocol Protocol identifier
  /// @return current and previous are the current and previous coverage amounts for this protocol
  // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)
  function coverageAmounts(bytes32 _protocol)
    external
    view
    override
    returns (uint256 current, uint256 previous)
  {
    // Checks to see if the protocol has an active protocolAgent (protocol not removed)
    // OR checks to see if the removed protocol is still within the claim window
    // If so, gives the current and previous coverage, otherwise throws an error
    if (
      protocolAgent_[_protocol] != address(0) ||
      block.timestamp <= removedProtocolClaimDeadline[_protocol]
    ) {
      return (currentCoverage[_protocol], previousCoverage[_protocol]);
    }
    revert ProtocolNotExists(_protocol);
  }
  /// @notice Add a new protocol to Sherlock
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Address able to submit a claim on behalf of the protocol
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Adding a protocol allows the `_protocolAgent` to submit a claim
  /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point
  /// @dev `_nonStakers` is scaled by 10**18
  /// @dev Only callable by governance
  function protocolAdd(
    bytes32 _protocol,
    address _protocolAgent,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) external override onlyOwner {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Checks to make sure the protocol doesn't exist already
    if (protocolAgent_[_protocol] != address(0)) revert InvalidConditions();
    // Updates the protocol agent and passes in the old agent which is 0 address in this case
    _setProtocolAgent(_protocol, address(0), _protocolAgent);
    // Delete mappings that are potentially non default values
    // From previous time protocol was added/removed
    delete removedProtocolClaimDeadline[_protocol];
    delete removedProtocolAgent[_protocol];
    delete currentCoverage[_protocol];
    delete previousCoverage[_protocol];
    emit ProtocolAdded(_protocol);
    // Most of the logic for actually adding a protocol in this function
    protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);
  }
  /// @notice Update info regarding a protocol
  /// @param _protocol Protocol identifier
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Only callable by governance
  /// @dev `_nonStakers` can be 0
  function protocolUpdate(
    bytes32 _protocol,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) public override onlyOwner {
    if (_coverage == bytes32(0)) revert ZeroArgument();
    if (_nonStakers > HUNDRED_PERCENT) revert InvalidArgument();
    if (_coverageAmount == uint256(0)) revert ZeroArgument();
    // Checks to make sure the protocol has been assigned a protocol agent
    _verifyProtocolExists(_protocol);
    // Subtracts the accrued debt from a protocol's active balance (if any)
    // Updates the amount that can be claimed by nonstakers
    _settleProtocolDebt(_protocol);
    // Updates the global claimable amount for stakers
    _settleTotalDebt();
    // Gets the premium per second for this protocol
    uint256 premium = premiums_[_protocol];
    // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be)
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      premium,
      premium,
      nonStakersPercentage[_protocol],
      _nonStakers,
      allPremiumsPerSecToStakers
    );
    // Updates the stored value of percentage of premiums that go to nonstakers
    nonStakersPercentage[_protocol] = _nonStakers;
    // Updates previous coverage and current coverage amounts
    previousCoverage[_protocol] = currentCoverage[_protocol];
    currentCoverage[_protocol] = _coverageAmount;
    emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);
  }
  /// @notice Remove a protocol from coverage
  /// @param _protocol Protocol identifier
  /// @dev Before removing a protocol the premium must be 0
  /// @dev Removing a protocol basically stops the `_protocolAgent` from being active (can still submit claims until claim deadline though)
  /// @dev Pays off debt + sends remaining balance to protocol agent
  /// @dev This call should be subject to a timelock
  /// @dev Only callable by governance
  function protocolRemove(bytes32 _protocol) external override onlyOwner {
    // checks to make sure the protocol actually has a protocol agent
    address agent = _verifyProtocolExists(_protocol);
    // Removes a protocol from Sherlock and cleans up its data
    // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made
    _forceRemoveProtocol(_protocol, agent);
  }
  /// @notice Remove a protocol with insufficient active balance
  /// @param _protocol Protocol identifier
  // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function
  function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {
    address agent = _verifyProtocolExists(_protocol);
    // Gets the latest value of the active balance at this protocol
    _settleProtocolDebt(_protocol);
    // Sets latest value of active balance to remainingBalance variable
    uint256 remainingBalance = activeBalances[_protocol];
    // This means the protocol still has adequate active balance and thus cannot be removed
    if (remainingBalance >= minActiveBalance) revert InvalidConditions();
    // Sets the protocol's active balance to 0
    delete activeBalances[_protocol];
    // Removes the protocol from coverage
    _forceRemoveProtocol(_protocol, agent);
    if (remainingBalance != 0) {
      // sends the remaining balance to msg.sender
      token.safeTransfer(msg.sender, remainingBalance);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);
  }
  /// @notice Calculate if arb is possible and what the reward would be
  /// @param _protocol Protocol identifier
  /// @return arbAmount Amount reward for arbing
  /// @return able Indicator if arb call is even possible
  /// @dev Doesn't subtract the current protocol debt from the active balance
  function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)
    internal
    view
    returns (uint256 arbAmount, bool able)
  {
    uint256 secondsLeft = _secondsOfCoverageLeft(_protocol);
    // If arb is not possible return false
    if (secondsLeft >= MIN_SECONDS_OF_COVERAGE) return (0, false);
    // This percentage scales over time
    // Reaches 100% on 0 seconds of coverage left
    uint256 percentageScaled = HUNDRED_PERCENT -
      (secondsLeft * HUNDRED_PERCENT) /
      MIN_SECONDS_OF_COVERAGE;
    able = true;
    arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;
  }
  /// @notice Removes a protocol with insufficent seconds of coverage left
  /// @param _protocol Protocol identifier
  // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second
  function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {
    // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings
    address agent = _verifyProtocolExists(_protocol);
    // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance()
    // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance()
    // But when removing based on seconds of coverage left, the remainingBalance could still be quite large
    // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance
    // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%)
    _settleProtocolDebt(_protocol);
    (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol);
    if (able == false) revert InvalidConditions();
    if (arbAmount != 0) {
      // subtracts the amount that will be paid to the arb from the active balance
      activeBalances[_protocol] -= arbAmount;
    }
    // Removes the protocol from coverage
    // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above
    _forceRemoveProtocol(_protocol, agent);
    // Done after removing protocol to mitigate reentrency pattern
    // (In case token allows callback)
    if (arbAmount != 0) {
      token.safeTransfer(msg.sender, arbAmount);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);
  }
  /// @notice Set premium of `_protocol` to `_premium`
  /// @param _protocol Protocol identifier
  /// @param _premium Amount of premium `_protocol` pays per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {
    // Checks to see if protocol has a protocol agent
    _verifyProtocolExists(_protocol);
    // Updates individual protocol's premium and allPremiumsPerSecToStakers
    _setSingleAndGlobalProtocolPremium(_protocol, _premium);
  }
  /// @notice Set premium of multiple protocols
  /// @param _protocol Array of protocol identifiers
  /// @param _premium Array of premium amounts protocols pay per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)
    external
    override
    onlyOwner
  {
    // Checks to make sure there are an equal amount of entries in each array
    if (_protocol.length != _premium.length) revert UnequalArrayLength();
    if (_protocol.length == 0) revert InvalidArgument();
    // Updates the global claimable amount for stakers
    _settleTotalDebt();
    uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;
    // Loops through the array of protocols and checks to make sure each has a protocol agent assigned
    for (uint256 i; i < _protocol.length; i++) {
      _verifyProtocolExists(_protocol[i]);
      // Sets the protocol premium for that specific protocol
      // Function returns the old premium and nonStakerPercentage for that specific protocol
      (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
        _protocol[i],
        _premium[i]
      );
      // Calculates the new global premium which adds up all premiums paid by all protocols
      allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(
        oldPremiumPerSecond,
        _premium[i],
        nonStakerPercentage,
        nonStakerPercentage,
        allPremiumsPerSecToStakers_
      );
    }
    // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value
    allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;
  }
  // This is how protocols pay for coverage by increasing their active balance
  /// @notice Deposits `_amount` of token to the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to deposit
  /// @dev Approval should be made before calling
  function depositToActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    _verifyProtocolExists(_protocol);
    // Transfers _amount to this contract
    token.safeTransferFrom(msg.sender, address(this), _amount);
    // Increases the active balance of the protocol by _amount
    activeBalances[_protocol] += _amount;
    emit ProtocolBalanceDeposited(_protocol, _amount);
  }
  // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)
  // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)
  /// @notice Withdraws `_amount` of token from the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to withdraw
  /// @dev Only protocol agent is able to withdraw
  /// @dev Balance can be withdrawn up until 7 days worth of active balance
  function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    // Only the protocol agent can call this function
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();
    // Updates the active balance of the protocol
    _settleProtocolDebt(_protocol);
    // Sets currentBalance to the active balance of the protocol
    uint256 currentBalance = activeBalances[_protocol];
    // Reverts if trying to withdraw more than the active balance
    if (_amount > currentBalance) revert InsufficientBalance(_protocol);
    // Removes the _amount to be withdrawn from the active balance
    activeBalances[_protocol] = currentBalance - _amount;
    // Reverts if a protocol has less than 7 days worth of active balance left
    if (_secondsOfCoverageLeft(_protocol) < MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);
    // Transfers the amount to the msg.sender (protocol agent)
    token.safeTransfer(msg.sender, _amount);
    emit ProtocolBalanceWithdrawn(_protocol, _amount);
  }
  /// @notice Transfer protocol agent role
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Account able to submit a claim on behalf of the protocol
  /// @dev Only the active protocolAgent is able to transfer the role
  function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)
    external
    override
    whenNotPaused
  {
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Can't set the new protocol agent to the caller address
    if (msg.sender == _protocolAgent) revert InvalidArgument();
    // Because the caller must be the current protocol agent
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();
    // Sets the protocol agent to the new address
    _setProtocolAgent(_protocol, msg.sender, _protocolAgent);
  }
  /// @notice Function used to check if this is the current active protocol manager
  /// @return Boolean indicating it's active
  /// @dev If inactive the owner can pull all ERC20s and ETH
  /// @dev Will be checked by calling the sherlock contract
  function isActive() public view returns (bool) {
    return address(sherlockCore.sherlockProtocolManager()) == address(this);
  }
  // Only contract owner can call this
  // Sends all specified tokens in this contract to the receiver's address (as well as ETH)
  function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {
    if (_receiver == address(0)) revert ZeroArgument();
    // This contract must NOT be the current assigned protocol manager contract
    if (isActive()) revert InvalidConditions();
    // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH
    _sweep(_receiver, _extraTokens);
  }
}
.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;
/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/
import './Manager.sol';
import '../interfaces/managers/ISherlockProtocolManager.sol';
/// @title Sherlock core interface for protocols
/// @author Evert Kors
// This is the contract that manages covered protocols
contract SherlockProtocolManager is ISherlockProtocolManager, Manager {
  using SafeERC20 for IERC20;
  // Represents the token that protocols pay with (currently USDC)
  IERC20 public immutable token;
  // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed
  uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc
  // A removed protocol is still able to make a claim for this amount of time after its removal
  uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days;
  // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance
  uint256 public constant MIN_SECONDS_LEFT = 7 days;
  // Convenient for percentage calculations
  uint256 internal constant HUNDRED_PERCENT = 10**18;
  // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage
  // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying
  uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours;
  // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)
  mapping(bytes32 => address) internal protocolAgent_;
  // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)
  mapping(bytes32 => uint256) internal nonStakersPercentage;
  // The premium per second paid by each protocol is stored in this mapping
  mapping(bytes32 => uint256) internal premiums_;
  // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.
  // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not
  mapping(bytes32 => uint256) internal activeBalances;
  // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol
  mapping(bytes32 => uint256) internal lastAccountedEachProtocol;
  // The amount that can be claimed by nonstakers for each protocol
  // We need this value so we can track how much payment is coming from each protocol
  mapping(bytes32 => uint256) internal nonStakersClaimableByProtocol;
  // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)
  uint256 internal lastAccountedGlobal;
  // This is the total amount of premiums paid (per second) by all the covered protocols (added up)
  uint256 internal allPremiumsPerSecToStakers;
  // This is the amount that was claimable by stakers the last time the accounting was run
  // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date
  uint256 internal lastClaimablePremiumsForStakers;
  // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage
  // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)
  uint256 public override minActiveBalance;
  // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)
  mapping(bytes32 => uint256) internal removedProtocolClaimDeadline;
  // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)
  mapping(bytes32 => address) internal removedProtocolAgent;
  // Current amount of coverage (i.e. 20M USDC) for a protocol
  mapping(bytes32 => uint256) internal currentCoverage;
  // Previous amount of coverage for a protocol
  // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount
  mapping(bytes32 => uint256) internal previousCoverage;
  // Setting the token to USDC
  constructor(IERC20 _token) {
    if (address(_token) == address(0)) revert ZeroArgument();
    token = _token;
  }
  // Modifier used to ensure a protocol exists (has been instantiated and not removed)
  modifier protocolExists(bytes32 _protocol) {
    _verifyProtocolExists(_protocol);
    _;
  }
  /// @notice View current protocolAgent of `_protocol`
  /// @param _protocol Protocol identifier
  /// @return Address able to submit claims
  function protocolAgent(bytes32 _protocol) external view override returns (address) {
    address agent = protocolAgent_[_protocol];
    if (agent != address(0)) return agent;
    // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned
    // Note: Old protocol agent will never be address(0)
    if (block.timestamp <= removedProtocolClaimDeadline[_protocol]) {
      return removedProtocolAgent[_protocol];
    }
    // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned
    revert ProtocolNotExists(_protocol);
  }
  // Checks if the protocol exists, then returns the current premium per second being charged
  /// @notice View current premium of protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of premium `_protocol` pays per second
  function premium(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return premiums_[_protocol];
  }
  // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)
  // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)
  function _verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {
    _protocolAgent = protocolAgent_[_protocol];
    if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);
  }
  //
  // View methods
  //
  // Calcs the debt accrued by the protocol since it last had an accounting update
  // This is the amount that needs to be removed from a protocol's active balance
  function _calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {
    return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums_[_protocol];
  }
  /// @notice View the amount nonstakers can claim from this protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of tokens claimable by nonstakers
  /// @dev this reads from a storage variable + (now-lastsettled) * premiums
  // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]
  // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed
  function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {
    // Calcs the debt of a protocol since the last accounting update
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // Gets the active balance of the protocol
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) debt = balance;
    // Adds the incremental claimable amount owed to nonstakers to the total claimable amount
    return
      nonStakersClaimableByProtocol[_protocol] +
      (nonStakersPercentage[_protocol] * debt) /
      HUNDRED_PERCENT;
  }
  /// @notice View current amount of all premiums that are owed to stakers
  /// @return Premiums claimable
  /// @dev Will increase every block
  /// @dev base + (now - last_settled) * ps
  function claimablePremiums() public view override returns (uint256) {
    // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)
    return
      lastClaimablePremiumsForStakers +
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
  }
  /// @notice View seconds of coverage left for `_protocol` before it runs out of active balance
  /// @param _protocol Protocol identifier
  /// @return Seconds of coverage left
  function secondsOfCoverageLeft(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _secondsOfCoverageLeft(_protocol);
  }
  // Helper function to return seconds of coverage left for a protocol
  // Gets the current active balance of the protocol and divides by the premium per second for the protocol
  function _secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {
    uint256 premium = premiums_[_protocol];
    if (premium == 0) return 0;
    return _activeBalance(_protocol) / premium;
  }
  /// @notice View current active balance of covered protocol
  /// @param _protocol Protocol identifier
  /// @return Active balance
  /// @dev Accrued debt is subtracted from the stored active balance
  function activeBalance(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _activeBalance(_protocol);
  }
  // Helper function to calc the active balance of a protocol at current time
  function _activeBalance(bytes32 _protocol) internal view returns (uint256) {
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) return 0;
    return balance - debt;
  }
  //
  // State methods
  //
  /// @notice Helps set the premium per second for an individual protocol
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function
  function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)
    internal
    returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)
  {
    // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers
    // Also updates the last accounted timestamp for this protocol
    // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings
    // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol
    nonStakerPercentage = _settleProtocolDebt(_protocol);
    // Stores the old premium before it gets updated
    oldPremiumPerSecond = premiums_[_protocol];
    if (oldPremiumPerSecond != _premium) {
      // Sets the protocol's premium per second to the new value
      premiums_[_protocol] = _premium;
      emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium);
    }
    // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing
    // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes
    // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point
    // Where arbs would no longer be incentivized to remove the protocol
    // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems
    if (_premium != 0 && _secondsOfCoverageLeft(_protocol) < MIN_SECONDS_OF_COVERAGE) {
      revert InsufficientBalance(_protocol);
    }
  }
  /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {
    // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings
    (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
      _protocol,
      _premium
    );
    // Settling the total amount of premiums owed to stakers before a new premium per second gets set
    _settleTotalDebt();
    // This calculates the new global premium per second that gets paid to stakers
    // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      oldPremiumPerSecond,
      _premium,
      nonStakerPercentage,
      nonStakerPercentage,
      allPremiumsPerSecToStakers
    );
  }
  // Internal function to set a new protocolAgent for a specific protocol
  // _oldAgent is only included as part of emitting an event
  function _setProtocolAgent(
    bytes32 _protocol,
    address _oldAgent,
    address _protocolAgent
  ) internal {
    protocolAgent_[_protocol] = _protocolAgent;
    emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);
  }
  // Subtracts the accrued debt from a protocol's active balance
  // Credits the amount that can be claimed by nonstakers for this protocol
  // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings
  // Most of this function is dealing with an edge case related to a protocol not being removed by arbs
  function _settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {
    // This calcs the accrued debt of the protocol since it was last updated
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // This pulls the percentage that is sent to nonstakers
    _nonStakerPercentage = nonStakersPercentage[_protocol];
    // In case the protocol has accrued debt, this code block will ensure the debt is settled properly
    if (debt != 0) {
      // Pulls the stored active balance of the protocol
      uint256 balance = activeBalances[_protocol];
      // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance
      // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point
      // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage
      // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up
      if (debt > balance) {
        // This error amount represents the magnitude of the mistake
        uint256 error = debt - balance;
        // Gets the latest value of claimable premiums for stakers
        _settleTotalDebt();
        // @note to production, set premium first to zero before solving accounting issue.
        // otherwise the accounting error keeps increasing
        uint256 lastClaimablePremiumsForStakers_ = lastClaimablePremiumsForStakers;
        // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%
        uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /
          HUNDRED_PERCENT;
        // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short
        uint256 insufficientTokens;
        // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally
        // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error
        // This first line can be true if claimPremiumsForStakers() has been called and
        // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be >0 still
        if (claimablePremiumError > lastClaimablePremiumsForStakers_) {
          insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;
          lastClaimablePremiumsForStakers = 0;
        } else {
          // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums
          // By the amount that was added in error (error) and insufficientTokens = 0
          lastClaimablePremiumsForStakers =
            lastClaimablePremiumsForStakers_ -
            claimablePremiumError;
        }
        // If two events are thrown, the values need to be summed up for the actual state.
        // This means an error of this type will continue until it is handled
        emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);
        // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case
        debt = balance;
      }
      // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance
      activeBalances[_protocol] = balance - debt;
      // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol
      nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT;
    }
    // Updates the last accounted timestamp for this protocol
    lastAccountedEachProtocol[_protocol] = block.timestamp;
  }
  // Multiplies the total premium per second * number of seconds since the last global accounting update
  // And adds it to the total claimable amount for stakers
  function _settleTotalDebt() internal {
    lastClaimablePremiumsForStakers +=
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
    lastAccountedGlobal = block.timestamp;
  }
  // Calculates the global premium per second for stakers
  // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers
  // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones
  function _calcGlobalPremiumPerSecForStakers(
    uint256 _premiumOld,
    uint256 _premiumNew,
    uint256 _nonStakerPercentageOld,
    uint256 _nonStakerPercentageNew,
    uint256 _inMemAllPremiumsPerSecToStakers
  ) internal pure returns (uint256) {
    return
      _inMemAllPremiumsPerSecToStakers +
      ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /
      HUNDRED_PERCENT -
      ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /
      HUNDRED_PERCENT;
  }
  // Helper function to remove and clean up a protocol from Sherlock
  // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made
  function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {
    // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol
    _setSingleAndGlobalProtocolPremium(_protocol, 0);
    // Grabs the protocol's active balance
    uint256 balance = activeBalances[_protocol];
    // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent
    if (balance != 0) {
      delete activeBalances[_protocol];
      token.safeTransfer(_agent, balance);
      emit ProtocolBalanceWithdrawn(_protocol, balance);
    }
    // Sets the protocol agent to zero address (as part of clean up)
    _setProtocolAgent(_protocol, _agent, address(0));
    // Cleans up other mappings for this protocol
    delete nonStakersPercentage[_protocol];
    delete lastAccountedEachProtocol[_protocol];
    // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above
    // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol
    removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;
    // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed
    // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked
    removedProtocolAgent[_protocol] = _agent;
    emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0));
    emit ProtocolRemoved(_protocol);
  }
  /// @notice Sets the minimum active balance before an arb can remove a protocol
  /// @param _minActiveBalance Minimum balance needed (in USDC)
  /// @dev Only gov
  function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {
    // New value cannot be the same as current value
    if (minActiveBalance == _minActiveBalance) revert InvalidArgument();
    // Can't set a value that is too high to be reasonable
    if (_minActiveBalance >= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions();
    emit MinBalance(minActiveBalance, _minActiveBalance);
    minActiveBalance = _minActiveBalance;
  }
  // This function allows the nonstakers role to claim tokens owed to them by a specific protocol
  /// @notice Choose an `_amount` of tokens that nonstakers (`_receiver` address) will receive from `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens
  /// @param _receiver Address to receive tokens
  /// @dev Only callable by nonstakers role
  function nonStakersClaim(
    bytes32 _protocol,
    uint256 _amount,
    address _receiver
  ) external override whenNotPaused {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_amount == uint256(0)) revert ZeroArgument();
    if (_receiver == address(0)) revert ZeroArgument();
    // Only the nonstakers role (multisig or contract) can pull the funds
    if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized();
    // Call can't be executed on protocol that is removed
    if (protocolAgent_[_protocol] != address(0)) {
      // Updates the amount that nonstakers can claim from this protocol
      _settleProtocolDebt(_protocol);
    }
    // Sets balance to the amount that is claimable by nonstakers for this specific protocol
    uint256 balance = nonStakersClaimableByProtocol[_protocol];
    // If the amount requested is more than what's owed to nonstakers, revert
    if (_amount > balance) revert InsufficientBalance(_protocol);
    // Sets the claimable amount to whatever is left over after this amount is pulled
    nonStakersClaimableByProtocol[_protocol] = balance - _amount;
    // Transfers the amount requested to the `_receiver` address
    token.safeTransfer(_receiver, _amount);
  }
  // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)
  /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address
  /// @dev Callable by everyone
  /// @dev Funds will be transferred to Sherlock core contract
  function claimPremiumsForStakers() external override whenNotPaused {
    // Gets address of core Sherlock contract
    address sherlock = address(sherlockCore);
    // Revert if core Sherlock contract not initialized yet
    if (sherlock == address(0)) revert InvalidConditions();
    // claimablePremiums is different from _settleTotalDebt() because it does not change state
    // Retrieves current amount of all premiums that are owed to stakers
    uint256 amount = claimablePremiums();
    // Transfers all the premiums owed to stakers to the Sherlock core contract
    if (amount != 0) {
      // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out
      lastClaimablePremiumsForStakers = 0;
      lastAccountedGlobal = block.timestamp;
      token.safeTransfer(sherlock, amount);
    }
  }
  // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts
  /// @param _protocol Protocol identifier
  /// @return current and previous are the current and previous coverage amounts for this protocol
  // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)
  function coverageAmounts(bytes32 _protocol)
    external
    view
    override
    returns (uint256 current, uint256 previous)
  {
    // Checks to see if the protocol has an active protocolAgent (protocol not removed)
    // OR checks to see if the removed protocol is still within the claim window
    // If so, gives the current and previous coverage, otherwise throws an error
    if (
      protocolAgent_[_protocol] != address(0) ||
      block.timestamp <= removedProtocolClaimDeadline[_protocol]
    ) {
      return (currentCoverage[_protocol], previousCoverage[_protocol]);
    }
    revert ProtocolNotExists(_protocol);
  }
  /// @notice Add a new protocol to Sherlock
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Address able to submit a claim on behalf of the protocol
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Adding a protocol allows the `_protocolAgent` to submit a claim
  /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point
  /// @dev `_nonStakers` is scaled by 10**18
  /// @dev Only callable by governance
  function protocolAdd(
    bytes32 _protocol,
    address _protocolAgent,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) external override onlyOwner {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Checks to make sure the protocol doesn't exist already
    if (protocolAgent_[_protocol] != address(0)) revert InvalidConditions();
    // Updates the protocol agent and passes in the old agent which is 0 address in this case
    _setProtocolAgent(_protocol, address(0), _protocolAgent);
    // Delete mappings that are potentially non default values
    // From previous time protocol was added/removed
    delete removedProtocolClaimDeadline[_protocol];
    delete removedProtocolAgent[_protocol];
    delete currentCoverage[_protocol];
    delete previousCoverage[_protocol];
    emit ProtocolAdded(_protocol);
    // Most of the logic for actually adding a protocol in this function
    protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);
  }
  /// @notice Update info regarding a protocol
  /// @param _protocol Protocol identifier
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Only callable by governance
  /// @dev `_nonStakers` can be 0
  function protocolUpdate(
    bytes32 _protocol,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) public override onlyOwner {
    if (_coverage == bytes32(0)) revert ZeroArgument();
    if (_nonStakers > HUNDRED_PERCENT) revert InvalidArgument();
    if (_coverageAmount == uint256(0)) revert ZeroArgument();
    // Checks to make sure the protocol has been assigned a protocol agent
    _verifyProtocolExists(_protocol);
    // Subtracts the accrued debt from a protocol's active balance (if any)
    // Updates the amount that can be claimed by nonstakers
    _settleProtocolDebt(_protocol);
    // Updates the global claimable amount for stakers
    _settleTotalDebt();
    // Gets the premium per second for this protocol
    uint256 premium = premiums_[_protocol];
    // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be)
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      premium,
      premium,
      nonStakersPercentage[_protocol],
      _nonStakers,
      allPremiumsPerSecToStakers
    );
    // Updates the stored value of percentage of premiums that go to nonstakers
    nonStakersPercentage[_protocol] = _nonStakers;
    // Updates previous coverage and current coverage amounts
    previousCoverage[_protocol] = currentCoverage[_protocol];
    currentCoverage[_protocol] = _coverageAmount;
    emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);
  }
  /// @notice Remove a protocol from coverage
  /// @param _protocol Protocol identifier
  /// @dev Before removing a protocol the premium must be 0
  /// @dev Removing a protocol basically stops the `_protocolAgent` from being active (can still submit claims until claim deadline though)
  /// @dev Pays off debt + sends remaining balance to protocol agent
  /// @dev This call should be subject to a timelock
  /// @dev Only callable by governance
  function protocolRemove(bytes32 _protocol) external override onlyOwner {
    // checks to make sure the protocol actually has a protocol agent
    address agent = _verifyProtocolExists(_protocol);
    // Removes a protocol from Sherlock and cleans up its data
    // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made
    _forceRemoveProtocol(_protocol, agent);
  }
  /// @notice Remove a protocol with insufficient active balance
  /// @param _protocol Protocol identifier
  // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function
  function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {
    address agent = _verifyProtocolExists(_protocol);
    // Gets the latest value of the active balance at this protocol
    _settleProtocolDebt(_protocol);
    // Sets latest value of active balance to remainingBalance variable
    uint256 remainingBalance = activeBalances[_protocol];
    // This means the protocol still has adequate active balance and thus cannot be removed
    if (remainingBalance >= minActiveBalance) revert InvalidConditions();
    // Sets the protocol's active balance to 0
    delete activeBalances[_protocol];
    // Removes the protocol from coverage
    _forceRemoveProtocol(_protocol, agent);
    if (remainingBalance != 0) {
      // sends the remaining balance to msg.sender
      token.safeTransfer(msg.sender, remainingBalance);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);
  }
  /// @notice Calculate if arb is possible and what the reward would be
  /// @param _protocol Protocol identifier
  /// @return arbAmount Amount reward for arbing
  /// @return able Indicator if arb call is even possible
  /// @dev Doesn't subtract the current protocol debt from the active balance
  function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)
    internal
    view
    returns (uint256 arbAmount, bool able)
  {
    uint256 secondsLeft = _secondsOfCoverageLeft(_protocol);
    // If arb is not possible return false
    if (secondsLeft >= MIN_SECONDS_OF_COVERAGE) return (0, false);
    // This percentage scales over time
    // Reaches 100% on 0 seconds of coverage left
    uint256 percentageScaled = HUNDRED_PERCENT -
      (secondsLeft * HUNDRED_PERCENT) /
      MIN_SECONDS_OF_COVERAGE;
    able = true;
    arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;
  }
  /// @notice Removes a protocol with insufficent seconds of coverage left
  /// @param _protocol Protocol identifier
  // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second
  function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {
    // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings
    address agent = _verifyProtocolExists(_protocol);
    // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance()
    // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance()
    // But when removing based on seconds of coverage left, the remainingBalance could still be quite large
    // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance
    // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%)
    _settleProtocolDebt(_protocol);
    (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol);
    if (able == false) revert InvalidConditions();
    if (arbAmount != 0) {
      // subtracts the amount that will be paid to the arb from the active balance
      activeBalances[_protocol] -= arbAmount;
    }
    // Removes the protocol from coverage
    // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above
    _forceRemoveProtocol(_protocol, agent);
    // Done after removing protocol to mitigate reentrency pattern
    // (In case token allows callback)
    if (arbAmount != 0) {
      token.safeTransfer(msg.sender, arbAmount);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);
  }
  /// @notice Set premium of `_protocol` to `_premium`
  /// @param _protocol Protocol identifier
  /// @param _premium Amount of premium `_protocol` pays per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {
    // Checks to see if protocol has a protocol agent
    _verifyProtocolExists(_protocol);
    // Updates individual protocol's premium and allPremiumsPerSecToStakers
    _setSingleAndGlobalProtocolPremium(_protocol, _premium);
  }
  /// @notice Set premium of multiple protocols
  /// @param _protocol Array of protocol identifiers
  /// @param _premium Array of premium amounts protocols pay per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)
    external
    override
    onlyOwner
  {
    // Checks to make sure there are an equal amount of entries in each array
    if (_protocol.length != _premium.length) revert UnequalArrayLength();
    if (_protocol.length == 0) revert InvalidArgument();
    // Updates the global claimable amount for stakers
    _settleTotalDebt();
    uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;
    // Loops through the array of protocols and checks to make sure each has a protocol agent assigned
    for (uint256 i; i < _protocol.length; i++) {
      _verifyProtocolExists(_protocol[i]);
      // Sets the protocol premium for that specific protocol
      // Function returns the old premium and nonStakerPercentage for that specific protocol
      (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
        _protocol[i],
        _premium[i]
      );
      // Calculates the new global premium which adds up all premiums paid by all protocols
      allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(
        oldPremiumPerSecond,
        _premium[i],
        nonStakerPercentage,
        nonStakerPercentage,
        allPremiumsPerSecToStakers_
      );
    }
    // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value
    allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;
  }
  // This is how protocols pay for coverage by increasing their active balance
  /// @notice Deposits `_amount` of token to the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to deposit
  /// @dev Approval should be made before calling
  function depositToActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    _verifyProtocolExists(_protocol);
    // Transfers _amount to this contract
    token.safeTransferFrom(msg.sender, address(this), _amount);
    // Increases the active balance of the protocol by _amount
    activeBalances[_protocol] += _amount;
    emit ProtocolBalanceDeposited(_protocol, _amount);
  }
  // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)
  // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)
  /// @notice Withdraws `_amount` of token from the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to withdraw
  /// @dev Only protocol agent is able to withdraw
  /// @dev Balance can be withdrawn up until 7 days worth of active balance
  function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    // Only the protocol agent can call this function
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();
    // Updates the active balance of the protocol
    _settleProtocolDebt(_protocol);
    // Sets currentBalance to the active balance of the protocol
    uint256 currentBalance = activeBalances[_protocol];
    // Reverts if trying to withdraw more than the active balance
    if (_amount > currentBalance) revert InsufficientBalance(_protocol);
    // Removes the _amount to be withdrawn from the active balance
    activeBalances[_protocol] = currentBalance - _amount;
    // Reverts if a protocol has less than 7 days worth of active balance left
    if (_secondsOfCoverageLeft(_protocol) < MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);
    // Transfers the amount to the msg.sender (protocol agent)
    token.safeTransfer(msg.sender, _amount);
    emit ProtocolBalanceWithdrawn(_protocol, _amount);
  }
  /// @notice Transfer protocol agent role
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Account able to submit a claim on behalf of the protocol
  /// @dev Only the active protocolAgent is able to transfer the role
  function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)
    external
    override
    whenNotPaused
  {
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Can't set the new protocol agent to the caller address
    if (msg.sender == _protocolAgent) revert InvalidArgument();
    // Because the caller must be the current protocol agent
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();
    // Sets the protocol agent to the new address
    _setProtocolAgent(_protocol, msg.sender, _protocolAgent);
  }
  /// @notice Function used to check if this is the current active protocol manager
  /// @return Boolean indicating it's active
  /// @dev If inactive the owner can pull all ERC20s and ETH
  /// @dev Will be checked by calling the sherlock contract
  function isActive() public view returns (bool) {
    return address(sherlockCore.sherlockProtocolManager()) == address(this);
  }
  // Only contract owner can call this
  // Sends all specified tokens in this contract to the receiver's address (as well as ETH)
  function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {
    if (_receiver == address(0)) revert ZeroArgument();
    // This contract must NOT be the current assigned protocol manager contract
    if (isActive()) revert InvalidConditions();
    // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH
    _sweep(_receiver, _extraTokens);
  }
}
".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Let's Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-25-08 10:58:56 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-25-08 10:58:56 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 27508
completion_tokens: 1
total_tokens: 27509
cost: $-1.000000


[2024-25-08 10:58:56 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import './Manager.sol';
import '../interfaces/managers/ISherlockProtocolManager.sol';

/// @title Sherlock core interface for protocols
/// @author Evert Kors
// This is the contract that manages covered protocols

contract SherlockProtocolManager is ISherlockProtocolManager, Manager {
  using SafeERC20 for IERC20;

  // Represents the token that protocols pay with (currently USDC)
  IERC20 public immutable token;

  // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed
  uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc

  // A removed protocol is still able to make a claim for this amount of time after its removal
  uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days;

  // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance
  uint256 public constant MIN_SECONDS_LEFT = 7 days;

  // Convenient for percentage calculations
  uint256 internal constant HUNDRED_PERCENT = 10**18;

  // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage
  // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying
  uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours;

  // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)
  mapping(bytes32 => address) internal protocolAgent_;

  // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)
  mapping(bytes32 => uint256) internal nonStakersPercentage;

  // The premium per second paid by each protocol is stored in this mapping
  mapping(bytes32 => uint256) internal premiums_;

  // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.
  // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not
  mapping(bytes32 => uint256) internal activeBalances;

  // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol
  mapping(bytes32 => uint256) internal lastAccountedEachProtocol;

  // The amount that can be claimed by nonstakers for each protocol
  // We need this value so we can track how much payment is coming from each protocol
  mapping(bytes32 => uint256) internal nonStakersClaimableByProtocol;

  // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)
  uint256 internal lastAccountedGlobal;

  // This is the total amount of premiums paid (per second) by all the covered protocols (added up)
  uint256 internal allPremiumsPerSecToStakers;

  // This is the amount that was claimable by stakers the last time the accounting was run
  // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date
  uint256 internal lastClaimablePremiumsForStakers;

  // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage
  // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)
  uint256 public override minActiveBalance;

  // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)
  mapping(bytes32 => uint256) internal removedProtocolClaimDeadline;

  // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)
  mapping(bytes32 => address) internal removedProtocolAgent;

  // Current amount of coverage (i.e. 20M USDC) for a protocol
  mapping(bytes32 => uint256) internal currentCoverage;

  // Previous amount of coverage for a protocol
  // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount
  mapping(bytes32 => uint256) internal previousCoverage;

  // Setting the token to USDC
  constructor(IERC20 _token) {
    if (address(_token) == address(0)) revert ZeroArgument();
    token = _token;
  }

  // Modifier used to ensure a protocol exists (has been instantiated and not removed)
  modifier protocolExists(bytes32 _protocol) {
    _verifyProtocolExists(_protocol);
    _;
  }

  /// @notice View current protocolAgent of `_protocol`
  /// @param _protocol Protocol identifier
  /// @return Address able to submit claims
  function protocolAgent(bytes32 _protocol) external view override returns (address) {
    address agent = protocolAgent_[_protocol];
    if (agent != address(0)) return agent;

    // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned
    // Note: Old protocol agent will never be address(0)
    if (block.timestamp <= removedProtocolClaimDeadline[_protocol]) {
      return removedProtocolAgent[_protocol];
    }

    // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned
    revert ProtocolNotExists(_protocol);
  }

  // Checks if the protocol exists, then returns the current premium per second being charged
  /// @notice View current premium of protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of premium `_protocol` pays per second
  function premium(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return premiums_[_protocol];
  }

  // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)
  // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)
  function _verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {
    _protocolAgent = protocolAgent_[_protocol];
    if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);
  }

  //
  // View methods
  //

  // Calcs the debt accrued by the protocol since it last had an accounting update
  // This is the amount that needs to be removed from a protocol's active balance
  function _calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {
    return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums_[_protocol];
  }

  /// @notice View the amount nonstakers can claim from this protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of tokens claimable by nonstakers
  /// @dev this reads from a storage variable + (now-lastsettled) * premiums
  // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]
  // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed
  function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {
    // Calcs the debt of a protocol since the last accounting update
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // Gets the active balance of the protocol
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) debt = balance;

    // Adds the incremental claimable amount owed to nonstakers to the total claimable amount
    return
      nonStakersClaimableByProtocol[_protocol] +
      (nonStakersPercentage[_protocol] * debt) /
      HUNDRED_PERCENT;
  }

  /// @notice View current amount of all premiums that are owed to stakers
  /// @return Premiums claimable
  /// @dev Will increase every block
  /// @dev base + (now - last_settled) * ps
  function claimablePremiums() public view override returns (uint256) {
    // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)
    return
      lastClaimablePremiumsForStakers +
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
  }

  /// @notice View seconds of coverage left for `_protocol` before it runs out of active balance
  /// @param _protocol Protocol identifier
  /// @return Seconds of coverage left
  function secondsOfCoverageLeft(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _secondsOfCoverageLeft(_protocol);
  }

  // Helper function to return seconds of coverage left for a protocol
  // Gets the current active balance of the protocol and divides by the premium per second for the protocol
  function _secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {
    uint256 premium = premiums_[_protocol];
    if (premium == 0) return 0;
    return _activeBalance(_protocol) / premium;
  }

  /// @notice View current active balance of covered protocol
  /// @param _protocol Protocol identifier
  /// @return Active balance
  /// @dev Accrued debt is subtracted from the stored active balance
  function activeBalance(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _activeBalance(_protocol);
  }

  // Helper function to calc the active balance of a protocol at current time
  function _activeBalance(bytes32 _protocol) internal view returns (uint256) {
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) return 0;
    return balance - debt;
  }

  //
  // State methods
  //

  /// @notice Helps set the premium per second for an individual protocol
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function
  function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)
    internal
    returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)
  {
    // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers
    // Also updates the last accounted timestamp for this protocol
    // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings
    // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol
    nonStakerPercentage = _settleProtocolDebt(_protocol);
    // Stores the old premium before it gets updated
    oldPremiumPerSecond = premiums_[_protocol];

    if (oldPremiumPerSecond != _premium) {
      // Sets the protocol's premium per second to the new value
      premiums_[_protocol] = _premium;
      emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium);
    }
    // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing
    // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes
    // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point
    // Where arbs would no longer be incentivized to remove the protocol
    // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems
    if (_premium != 0 && _secondsOfCoverageLeft(_protocol) < MIN_SECONDS_OF_COVERAGE) {
      revert InsufficientBalance(_protocol);
    }
  }

  /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {
    // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings
    (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
      _protocol,
      _premium
    );
    // Settling the total amount of premiums owed to stakers before a new premium per second gets set
    _settleTotalDebt();
    // This calculates the new global premium per second that gets paid to stakers
    // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      oldPremiumPerSecond,
      _premium,
      nonStakerPercentage,
      nonStakerPercentage,
      allPremiumsPerSecToStakers
    );
  }

  // Internal function to set a new protocolAgent for a specific protocol
  // _oldAgent is only included as part of emitting an event
  function _setProtocolAgent(
    bytes32 _protocol,
    address _oldAgent,
    address _protocolAgent
  ) internal {
    protocolAgent_[_protocol] = _protocolAgent;
    emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);
  }

  // Subtracts the accrued debt from a protocol's active balance
  // Credits the amount that can be claimed by nonstakers for this protocol
  // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings
  // Most of this function is dealing with an edge case related to a protocol not being removed by arbs
  function _settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {
    // This calcs the accrued debt of the protocol since it was last updated
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // This pulls the percentage that is sent to nonstakers
    _nonStakerPercentage = nonStakersPercentage[_protocol];
    // In case the protocol has accrued debt, this code block will ensure the debt is settled properly
    if (debt != 0) {
      // Pulls the stored active balance of the protocol
      uint256 balance = activeBalances[_protocol];
      // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance
      // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point
      // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage
      // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up
      if (debt > balance) {
        // This error amount represents the magnitude of the mistake
        uint256 error = debt - balance;
        // Gets the latest value of claimable premiums for stakers
        _settleTotalDebt();
        // @note to production, set premium first to zero before solving accounting issue.
        // otherwise the accounting error keeps increasing
        uint256 lastClaimablePremiumsForStakers_ = lastClaimablePremiumsForStakers;

        // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%
        uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /
          HUNDRED_PERCENT;

        // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short
        uint256 insufficientTokens;

        // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally
        // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error
        // This first line can be true if claimPremiumsForStakers() has been called and
        // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be >0 still
        if (claimablePremiumError > lastClaimablePremiumsForStakers_) {
          insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;
          lastClaimablePremiumsForStakers = 0;
        } else {
          // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums
          // By the amount that was added in error (error) and insufficientTokens = 0
          lastClaimablePremiumsForStakers =
            lastClaimablePremiumsForStakers_ -
            claimablePremiumError;
        }

        // If two events are thrown, the values need to be summed up for the actual state.
        // This means an error of this type will continue until it is handled
        emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);
        // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case
        debt = balance;
      }
      // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance
      activeBalances[_protocol] = balance - debt;
      // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol
      nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT;
    }
    // Updates the last accounted timestamp for this protocol
    lastAccountedEachProtocol[_protocol] = block.timestamp;
  }

  // Multiplies the total premium per second * number of seconds since the last global accounting update
  // And adds it to the total claimable amount for stakers
  function _settleTotalDebt() internal {
    lastClaimablePremiumsForStakers +=
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
    lastAccountedGlobal = block.timestamp;
  }

  // Calculates the global premium per second for stakers
  // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers
  // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones
  function _calcGlobalPremiumPerSecForStakers(
    uint256 _premiumOld,
    uint256 _premiumNew,
    uint256 _nonStakerPercentageOld,
    uint256 _nonStakerPercentageNew,
    uint256 _inMemAllPremiumsPerSecToStakers
  ) internal pure returns (uint256) {
    return
      _inMemAllPremiumsPerSecToStakers +
      ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /
      HUNDRED_PERCENT -
      ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /
      HUNDRED_PERCENT;
  }

  // Helper function to remove and clean up a protocol from Sherlock
  // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made
  function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {
    // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol
    _setSingleAndGlobalProtocolPremium(_protocol, 0);

    // Grabs the protocol's active balance
    uint256 balance = activeBalances[_protocol];

    // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent
    if (balance != 0) {
      delete activeBalances[_protocol];
      token.safeTransfer(_agent, balance);

      emit ProtocolBalanceWithdrawn(_protocol, balance);
    }

    // Sets the protocol agent to zero address (as part of clean up)
    _setProtocolAgent(_protocol, _agent, address(0));

    // Cleans up other mappings for this protocol
    delete nonStakersPercentage[_protocol];
    delete lastAccountedEachProtocol[_protocol];
    // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above

    // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol
    removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;

    // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed
    // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked
    removedProtocolAgent[_protocol] = _agent;

    emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0));
    emit ProtocolRemoved(_protocol);
  }

  /// @notice Sets the minimum active balance before an arb can remove a protocol
  /// @param _minActiveBalance Minimum balance needed (in USDC)
  /// @dev Only gov
  function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {
    // New value cannot be the same as current value
    if (minActiveBalance == _minActiveBalance) revert InvalidArgument();
    // Can't set a value that is too high to be reasonable
    if (_minActiveBalance >= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions();

    emit MinBalance(minActiveBalance, _minActiveBalance);
    minActiveBalance = _minActiveBalance;
  }

  // This function allows the nonstakers role to claim tokens owed to them by a specific protocol
  /// @notice Choose an `_amount` of tokens that nonstakers (`_receiver` address) will receive from `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens
  /// @param _receiver Address to receive tokens
  /// @dev Only callable by nonstakers role
  function nonStakersClaim(
    bytes32 _protocol,
    uint256 _amount,
    address _receiver
  ) external override whenNotPaused {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_amount == uint256(0)) revert ZeroArgument();
    if (_receiver == address(0)) revert ZeroArgument();
    // Only the nonstakers role (multisig or contract) can pull the funds
    if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized();

    // Call can't be executed on protocol that is removed
    if (protocolAgent_[_protocol] != address(0)) {
      // Updates the amount that nonstakers can claim from this protocol
      _settleProtocolDebt(_protocol);
    }

    // Sets balance to the amount that is claimable by nonstakers for this specific protocol
    uint256 balance = nonStakersClaimableByProtocol[_protocol];
    // If the amount requested is more than what's owed to nonstakers, revert
    if (_amount > balance) revert InsufficientBalance(_protocol);

    // Sets the claimable amount to whatever is left over after this amount is pulled
    nonStakersClaimableByProtocol[_protocol] = balance - _amount;
    // Transfers the amount requested to the `_receiver` address
    token.safeTransfer(_receiver, _amount);
  }

  // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)
  /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address
  /// @dev Callable by everyone
  /// @dev Funds will be transferred to Sherlock core contract
  function claimPremiumsForStakers() external override whenNotPaused {
    // Gets address of core Sherlock contract
    address sherlock = address(sherlockCore);
    // Revert if core Sherlock contract not initialized yet
    if (sherlock == address(0)) revert InvalidConditions();

    // claimablePremiums is different from _settleTotalDebt() because it does not change state
    // Retrieves current amount of all premiums that are owed to stakers
    uint256 amount = claimablePremiums();

    // Transfers all the premiums owed to stakers to the Sherlock core contract
    if (amount != 0) {
      // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out
      lastClaimablePremiumsForStakers = 0;
      lastAccountedGlobal = block.timestamp;
      token.safeTransfer(sherlock, amount);
    }
  }

  // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts
  /// @param _protocol Protocol identifier
  /// @return current and previous are the current and previous coverage amounts for this protocol
  // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)
  function coverageAmounts(bytes32 _protocol)
    external
    view
    override
    returns (uint256 current, uint256 previous)
  {
    // Checks to see if the protocol has an active protocolAgent (protocol not removed)
    // OR checks to see if the removed protocol is still within the claim window
    // If so, gives the current and previous coverage, otherwise throws an error
    if (
      protocolAgent_[_protocol] != address(0) ||
      block.timestamp <= removedProtocolClaimDeadline[_protocol]
    ) {
      return (currentCoverage[_protocol], previousCoverage[_protocol]);
    }

    revert ProtocolNotExists(_protocol);
  }

  /// @notice Add a new protocol to Sherlock
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Address able to submit a claim on behalf of the protocol
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Adding a protocol allows the `_protocolAgent` to submit a claim
  /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point
  /// @dev `_nonStakers` is scaled by 10**18
  /// @dev Only callable by governance
  function protocolAdd(
    bytes32 _protocol,
    address _protocolAgent,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) external override onlyOwner {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Checks to make sure the protocol doesn't exist already
    if (protocolAgent_[_protocol] != address(0)) revert InvalidConditions();

    // Updates the protocol agent and passes in the old agent which is 0 address in this case
    _setProtocolAgent(_protocol, address(0), _protocolAgent);

    // Delete mappings that are potentially non default values
    // From previous time protocol was added/removed
    delete removedProtocolClaimDeadline[_protocol];
    delete removedProtocolAgent[_protocol];
    delete currentCoverage[_protocol];
    delete previousCoverage[_protocol];

    emit ProtocolAdded(_protocol);

    // Most of the logic for actually adding a protocol in this function
    protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Update info regarding a protocol
  /// @param _protocol Protocol identifier
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Only callable by governance
  /// @dev `_nonStakers` can be 0
  function protocolUpdate(
    bytes32 _protocol,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) public override onlyOwner {
    if (_coverage == bytes32(0)) revert ZeroArgument();
    if (_nonStakers > HUNDRED_PERCENT) revert InvalidArgument();
    if (_coverageAmount == uint256(0)) revert ZeroArgument();

    // Checks to make sure the protocol has been assigned a protocol agent
    _verifyProtocolExists(_protocol);

    // Subtracts the accrued debt from a protocol's active balance (if any)
    // Updates the amount that can be claimed by nonstakers
    _settleProtocolDebt(_protocol);

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    // Gets the premium per second for this protocol
    uint256 premium = premiums_[_protocol];

    // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be)
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      premium,
      premium,
      nonStakersPercentage[_protocol],
      _nonStakers,
      allPremiumsPerSecToStakers
    );

    // Updates the stored value of percentage of premiums that go to nonstakers
    nonStakersPercentage[_protocol] = _nonStakers;

    // Updates previous coverage and current coverage amounts
    previousCoverage[_protocol] = currentCoverage[_protocol];
    currentCoverage[_protocol] = _coverageAmount;

    emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Remove a protocol from coverage
  /// @param _protocol Protocol identifier
  /// @dev Before removing a protocol the premium must be 0
  /// @dev Removing a protocol basically stops the `_protocolAgent` from being active (can still submit claims until claim deadline though)
  /// @dev Pays off debt + sends remaining balance to protocol agent
  /// @dev This call should be subject to a timelock
  /// @dev Only callable by governance
  function protocolRemove(bytes32 _protocol) external override onlyOwner {
    // checks to make sure the protocol actually has a protocol agent
    address agent = _verifyProtocolExists(_protocol);

    // Removes a protocol from Sherlock and cleans up its data
    // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made
    _forceRemoveProtocol(_protocol, agent);
  }

  /// @notice Remove a protocol with insufficient active balance
  /// @param _protocol Protocol identifier
  // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function
  function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {
    address agent = _verifyProtocolExists(_protocol);

    // Gets the latest value of the active balance at this protocol
    _settleProtocolDebt(_protocol);
    // Sets latest value of active balance to remainingBalance variable
    uint256 remainingBalance = activeBalances[_protocol];

    // This means the protocol still has adequate active balance and thus cannot be removed
    if (remainingBalance >= minActiveBalance) revert InvalidConditions();

    // Sets the protocol's active balance to 0
    delete activeBalances[_protocol];
    // Removes the protocol from coverage
    _forceRemoveProtocol(_protocol, agent);

    if (remainingBalance != 0) {
      // sends the remaining balance to msg.sender
      token.safeTransfer(msg.sender, remainingBalance);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);
  }

  /// @notice Calculate if arb is possible and what the reward would be
  /// @param _protocol Protocol identifier
  /// @return arbAmount Amount reward for arbing
  /// @return able Indicator if arb call is even possible
  /// @dev Doesn't subtract the current protocol debt from the active balance
  function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)
    internal
    view
    returns (uint256 arbAmount, bool able)
  {
    uint256 secondsLeft = _secondsOfCoverageLeft(_protocol);

    // If arb is not possible return false
    if (secondsLeft >= MIN_SECONDS_OF_COVERAGE) return (0, false);

    // This percentage scales over time
    // Reaches 100% on 0 seconds of coverage left
    uint256 percentageScaled = HUNDRED_PERCENT -
      (secondsLeft * HUNDRED_PERCENT) /
      MIN_SECONDS_OF_COVERAGE;

    able = true;
    arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;
  }

  /// @notice Removes a protocol with insufficent seconds of coverage left
  /// @param _protocol Protocol identifier
  // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second
  function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {
    // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings
    address agent = _verifyProtocolExists(_protocol);

    // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance()
    // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance()
    // But when removing based on seconds of coverage left, the remainingBalance could still be quite large
    // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance
    // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%)
    _settleProtocolDebt(_protocol);
    (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol);
    if (able == false) revert InvalidConditions();

    if (arbAmount != 0) {
      // subtracts the amount that will be paid to the arb from the active balance
      activeBalances[_protocol] -= arbAmount;
    }

    // Removes the protocol from coverage
    // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above
    _forceRemoveProtocol(_protocol, agent);

    // Done after removing protocol to mitigate reentrency pattern
    // (In case token allows callback)
    if (arbAmount != 0) {
      token.safeTransfer(msg.sender, arbAmount);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);
  }

  /// @notice Set premium of `_protocol` to `_premium`
  /// @param _protocol Protocol identifier
  /// @param _premium Amount of premium `_protocol` pays per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {
    // Checks to see if protocol has a protocol agent
    _verifyProtocolExists(_protocol);

    // Updates individual protocol's premium and allPremiumsPerSecToStakers
    _setSingleAndGlobalProtocolPremium(_protocol, _premium);
  }

  /// @notice Set premium of multiple protocols
  /// @param _protocol Array of protocol identifiers
  /// @param _premium Array of premium amounts protocols pay per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)
    external
    override
    onlyOwner
  {
    // Checks to make sure there are an equal amount of entries in each array
    if (_protocol.length != _premium.length) revert UnequalArrayLength();
    if (_protocol.length == 0) revert InvalidArgument();

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;

    // Loops through the array of protocols and checks to make sure each has a protocol agent assigned
    for (uint256 i; i < _protocol.length; i++) {
      _verifyProtocolExists(_protocol[i]);

      // Sets the protocol premium for that specific protocol
      // Function returns the old premium and nonStakerPercentage for that specific protocol
      (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
        _protocol[i],
        _premium[i]
      );

      // Calculates the new global premium which adds up all premiums paid by all protocols
      allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(
        oldPremiumPerSecond,
        _premium[i],
        nonStakerPercentage,
        nonStakerPercentage,
        allPremiumsPerSecToStakers_
      );
    }

    // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value
    allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;
  }

  // This is how protocols pay for coverage by increasing their active balance
  /// @notice Deposits `_amount` of token to the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to deposit
  /// @dev Approval should be made before calling
  function depositToActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    _verifyProtocolExists(_protocol);

    // Transfers _amount to this contract
    token.safeTransferFrom(msg.sender, address(this), _amount);
    // Increases the active balance of the protocol by _amount
    activeBalances[_protocol] += _amount;

    emit ProtocolBalanceDeposited(_protocol, _amount);
  }

  // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)
  // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)
  /// @notice Withdraws `_amount` of token from the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to withdraw
  /// @dev Only protocol agent is able to withdraw
  /// @dev Balance can be withdrawn up until 7 days worth of active balance
  function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    // Only the protocol agent can call this function
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Updates the active balance of the protocol
    _settleProtocolDebt(_protocol);

    // Sets currentBalance to the active balance of the protocol
    uint256 currentBalance = activeBalances[_protocol];
    // Reverts if trying to withdraw more than the active balance
    if (_amount > currentBalance) revert InsufficientBalance(_protocol);

    // Removes the _amount to be withdrawn from the active balance
    activeBalances[_protocol] = currentBalance - _amount;
    // Reverts if a protocol has less than 7 days worth of active balance left
    if (_secondsOfCoverageLeft(_protocol) < MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);

    // Transfers the amount to the msg.sender (protocol agent)
    token.safeTransfer(msg.sender, _amount);
    emit ProtocolBalanceWithdrawn(_protocol, _amount);
  }

  /// @notice Transfer protocol agent role
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Account able to submit a claim on behalf of the protocol
  /// @dev Only the active protocolAgent is able to transfer the role
  function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)
    external
    override
    whenNotPaused
  {
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Can't set the new protocol agent to the caller address
    if (msg.sender == _protocolAgent) revert InvalidArgument();
    // Because the caller must be the current protocol agent
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Sets the protocol agent to the new address
    _setProtocolAgent(_protocol, msg.sender, _protocolAgent);
  }

  /// @notice Function used to check if this is the current active protocol manager
  /// @return Boolean indicating it's active
  /// @dev If inactive the owner can pull all ERC20s and ETH
  /// @dev Will be checked by calling the sherlock contract
  function isActive() public view returns (bool) {
    return address(sherlockCore.sherlockProtocolManager()) == address(this);
  }

  // Only contract owner can call this
  // Sends all specified tokens in this contract to the receiver's address (as well as ETH)
  function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {
    if (_receiver == address(0)) revert ZeroArgument();
    // This contract must NOT be the current assigned protocol manager contract
    if (isActive()) revert InvalidConditions();
    // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH
    _sweep(_receiver, _extraTokens);
  }
}
.]

Security

[2024-25-08 10:58:56 INFO] **[Seminar Conclusion]**:

 Security

[2024-25-08 10:58:56 INFO] **[Seminar Conclusion]**:

 <INFO> Security

[2024-25-08 10:58:56 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-25-08 10:58:57 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import './Manager.sol'; import '../interfaces/managers/ISherlockProtocolManager.sol'; /// @title Sherlock core interface for protocols /// @author Evert Kors // This is the contract that manages covered protocols contract SherlockProtocolManager is ISherlockProtocolManager, Manager {   using SafeERC20 for IERC20; // Represents the token that protocols pay with (currently USDC)   IERC20 public immutable token; // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed   uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc // A removed protocol is still able to make a claim for this amount of time after its removal   uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days; // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance   uint256 public constant MIN_SECONDS_LEFT = 7 days; // Convenient for percentage calculations   uint256 internal constant HUNDRED_PERCENT = 10**18; // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage   // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying   uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours; // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)   mapping(bytes32 =&gt; address) internal protocolAgent_; // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)   mapping(bytes32 =&gt; uint256) internal nonStakersPercentage; // The premium per second paid by each protocol is stored in this mapping   mapping(bytes32 =&gt; uint256) internal premiums_; // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.   // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not   mapping(bytes32 =&gt; uint256) internal activeBalances; // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol   mapping(bytes32 =&gt; uint256) internal lastAccountedEachProtocol; // The amount that can be claimed by nonstakers for each protocol   // We need this value so we can track how much payment is coming from each protocol   mapping(bytes32 =&gt; uint256) internal nonStakersClaimableByProtocol; // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)   uint256 internal lastAccountedGlobal; // This is the total amount of premiums paid (per second) by all the covered protocols (added up)   uint256 internal allPremiumsPerSecToStakers; // This is the amount that was claimable by stakers the last time the accounting was run   // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date   uint256 internal lastClaimablePremiumsForStakers; // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage   // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)   uint256 public override minActiveBalance; // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)   mapping(bytes32 =&gt; uint256) internal removedProtocolClaimDeadline; // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)   mapping(bytes32 =&gt; address) internal removedProtocolAgent; // Current amount of coverage (i.e. 20M USDC) for a protocol   mapping(bytes32 =&gt; uint256) internal currentCoverage; // Previous amount of coverage for a protocol   // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount   mapping(bytes32 =&gt; uint256) internal previousCoverage; // Setting the token to USDC   constructor(IERC20 _token) {     if (address(_token) == address(0)) revert ZeroArgument();     token = _token;   } // Modifier used to ensure a protocol exists (has been instantiated and not removed)   modifier protocolExists(bytes32 protocol) {     _verifyProtocolExists(_protocol);     ;   } /// @notice View current protocolAgent of _protocol   /// @param protocol Protocol identifier   /// @return Address able to submit claims   function protocolAgent(bytes32 _protocol) external view override returns (address) {     address agent = protocolAgent[_protocol];     if (agent != address(0)) return agent; // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned // Note: Old protocol agent will never be address(0) if (block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]) {   return removedProtocolAgent[_protocol]; }  // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned revert ProtocolNotExists(_protocol);  } // Checks if the protocol exists, then returns the current premium per second being charged   /// @notice View current premium of protocol   /// @param protocol Protocol identifier   /// @return Amount of premium _protocol pays per second   function premium(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return premiums[_protocol];   } // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)   // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)   function verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {     _protocolAgent = protocolAgent[_protocol];     if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);   } //   // View methods   // // Calcs the debt accrued by the protocol since it last had an accounting update   // This is the amount that needs to be removed from a protocol's active balance   function calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {     return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums[_protocol];   } /// @notice View the amount nonstakers can claim from this protocol   /// @param _protocol Protocol identifier   /// @return Amount of tokens claimable by nonstakers   /// @dev this reads from a storage variable + (now-lastsettled) * premiums   // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]   // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed   function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {     // Calcs the debt of a protocol since the last accounting update     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     // Gets the active balance of the protocol     uint256 balance = activeBalances[_protocol];     // The debt should never be higher than the balance (only happens if the arbitrages fail)     if (debt &gt; balance) debt = balance; // Adds the incremental claimable amount owed to nonstakers to the total claimable amount return   nonStakersClaimableByProtocol[_protocol] +   (nonStakersPercentage[_protocol] * debt) /   HUNDRED_PERCENT;  } /// @notice View current amount of all premiums that are owed to stakers   /// @return Premiums claimable   /// @dev Will increase every block   /// @dev base + (now - last_settled) * ps   function claimablePremiums() public view override returns (uint256) {     // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)     return       lastClaimablePremiumsForStakers +       (block.timestamp - lastAccountedGlobal) *       allPremiumsPerSecToStakers;   } /// @notice View seconds of coverage left for _protocol before it runs out of active balance   /// @param _protocol Protocol identifier   /// @return Seconds of coverage left   function secondsOfCoverageLeft(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return _secondsOfCoverageLeft(_protocol);   } // Helper function to return seconds of coverage left for a protocol   // Gets the current active balance of the protocol and divides by the premium per second for the protocol   function secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {     uint256 premium = premiums[_protocol];     if (premium == 0) return 0;     return _activeBalance(_protocol) / premium;   } /// @notice View current active balance of covered protocol   /// @param _protocol Protocol identifier   /// @return Active balance   /// @dev Accrued debt is subtracted from the stored active balance   function activeBalance(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return _activeBalance(_protocol);   } // Helper function to calc the active balance of a protocol at current time   function _activeBalance(bytes32 _protocol) internal view returns (uint256) {     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     uint256 balance = activeBalances[_protocol];     // The debt should never be higher than the balance (only happens if the arbitrages fail)     if (debt &gt; balance) return 0;     return balance - debt;   } //   // State methods   // /// @notice Helps set the premium per second for an individual protocol   /// @param protocol Protocol identifier   /// @param _premium New premium per second   /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function   function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)     internal     returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)   {     // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers     // Also updates the last accounted timestamp for this protocol     // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings     // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol     nonStakerPercentage = _settleProtocolDebt(_protocol);     // Stores the old premium before it gets updated     oldPremiumPerSecond = premiums[_protocol]; if (oldPremiumPerSecond != _premium) {   // Sets the protocol's premium per second to the new value   premiums_[_protocol] = _premium;   emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium); } // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point // Where arbs would no longer be incentivized to remove the protocol // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems if (_premium != 0 &amp;&amp; _secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_OF_COVERAGE) {   revert InsufficientBalance(_protocol); }  } /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second   /// @param _protocol Protocol identifier   /// @param _premium New premium per second   function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {     // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings     (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(       _protocol,       _premium     );     // Settling the total amount of premiums owed to stakers before a new premium per second gets set     _settleTotalDebt();     // This calculates the new global premium per second that gets paid to stakers     // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function     allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(       oldPremiumPerSecond,       _premium,       nonStakerPercentage,       nonStakerPercentage,       allPremiumsPerSecToStakers     );   } // Internal function to set a new protocolAgent for a specific protocol   // oldAgent is only included as part of emitting an event   function _setProtocolAgent(     bytes32 _protocol,     address _oldAgent,     address _protocolAgent   ) internal {     protocolAgent[_protocol] = _protocolAgent;     emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);   } // Subtracts the accrued debt from a protocol's active balance   // Credits the amount that can be claimed by nonstakers for this protocol   // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings   // Most of this function is dealing with an edge case related to a protocol not being removed by arbs   function settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {     // This calcs the accrued debt of the protocol since it was last updated     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     // This pulls the percentage that is sent to nonstakers     _nonStakerPercentage = nonStakersPercentage[_protocol];     // In case the protocol has accrued debt, this code block will ensure the debt is settled properly     if (debt != 0) {       // Pulls the stored active balance of the protocol       uint256 balance = activeBalances[_protocol];       // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance       // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point       // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage       // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up       if (debt &gt; balance) {         // This error amount represents the magnitude of the mistake         uint256 error = debt - balance;         // Gets the latest value of claimable premiums for stakers         _settleTotalDebt();         // @note to production, set premium first to zero before solving accounting issue.         // otherwise the accounting error keeps increasing         uint256 lastClaimablePremiumsForStakers = lastClaimablePremiumsForStakers;     // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%     uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /       HUNDRED_PERCENT;      // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short     uint256 insufficientTokens;      // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally     // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error     // This first line can be true if claimPremiumsForStakers() has been called and     // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be &gt;0 still     if (claimablePremiumError &gt; lastClaimablePremiumsForStakers_) {       insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;       lastClaimablePremiumsForStakers = 0;     } else {       // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums       // By the amount that was added in error (error) and insufficientTokens = 0       lastClaimablePremiumsForStakers =         lastClaimablePremiumsForStakers_ -         claimablePremiumError;     }      // If two events are thrown, the values need to be summed up for the actual state.     // This means an error of this type will continue until it is handled     emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);     // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case     debt = balance;   }   // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance   activeBalances[_protocol] = balance - debt;   // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol   nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT; } // Updates the last accounted timestamp for this protocol lastAccountedEachProtocol[_protocol] = block.timestamp;  } // Multiplies the total premium per second * number of seconds since the last global accounting update   // And adds it to the total claimable amount for stakers   function _settleTotalDebt() internal {     lastClaimablePremiumsForStakers +=       (block.timestamp - lastAccountedGlobal) *       allPremiumsPerSecToStakers;     lastAccountedGlobal = block.timestamp;   } // Calculates the global premium per second for stakers   // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers   // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones   function _calcGlobalPremiumPerSecForStakers(     uint256 _premiumOld,     uint256 _premiumNew,     uint256 _nonStakerPercentageOld,     uint256 _nonStakerPercentageNew,     uint256 _inMemAllPremiumsPerSecToStakers   ) internal pure returns (uint256) {     return       _inMemAllPremiumsPerSecToStakers +       ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /       HUNDRED_PERCENT -       ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /       HUNDRED_PERCENT;   } // Helper function to remove and clean up a protocol from Sherlock   // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made   function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {     // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol     _setSingleAndGlobalProtocolPremium(_protocol, 0); // Grabs the protocol's active balance uint256 balance = activeBalances[_protocol];  // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent if (balance != 0) {   delete activeBalances[_protocol];   token.safeTransfer(_agent, balance);    emit ProtocolBalanceWithdrawn(_protocol, balance); }  // Sets the protocol agent to zero address (as part of clean up) _setProtocolAgent(_protocol, _agent, address(0));  // Cleans up other mappings for this protocol delete nonStakersPercentage[_protocol]; delete lastAccountedEachProtocol[_protocol]; // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above  // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;  // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked removedProtocolAgent[_protocol] = _agent;  emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0)); emit ProtocolRemoved(_protocol);  } /// @notice Sets the minimum active balance before an arb can remove a protocol   /// @param _minActiveBalance Minimum balance needed (in USDC)   /// @dev Only gov   function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {     // New value cannot be the same as current value     if (minActiveBalance == _minActiveBalance) revert InvalidArgument();     // Can't set a value that is too high to be reasonable     if (_minActiveBalance &gt;= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions(); emit MinBalance(minActiveBalance, _minActiveBalance); minActiveBalance = _minActiveBalance;  } // This function allows the nonstakers role to claim tokens owed to them by a specific protocol   /// @notice Choose an _amount of tokens that nonstakers (_receiver address) will receive from _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens   /// @param _receiver Address to receive tokens   /// @dev Only callable by nonstakers role   function nonStakersClaim(     bytes32 _protocol,     uint256 _amount,     address _receiver   ) external override whenNotPaused {     if (_protocol == bytes32(0)) revert ZeroArgument();     if (_amount == uint256(0)) revert ZeroArgument();     if (_receiver == address(0)) revert ZeroArgument();     // Only the nonstakers role (multisig or contract) can pull the funds     if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized(); // Call can't be executed on protocol that is removed if (protocolAgent_[_protocol] != address(0)) {   // Updates the amount that nonstakers can claim from this protocol   _settleProtocolDebt(_protocol); }  // Sets balance to the amount that is claimable by nonstakers for this specific protocol uint256 balance = nonStakersClaimableByProtocol[_protocol]; // If the amount requested is more than what's owed to nonstakers, revert if (_amount &gt; balance) revert InsufficientBalance(_protocol);  // Sets the claimable amount to whatever is left over after this amount is pulled nonStakersClaimableByProtocol[_protocol] = balance - _amount; // Transfers the amount requested to the `_receiver` address token.safeTransfer(_receiver, _amount);  } // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)   /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address   /// @dev Callable by everyone   /// @dev Funds will be transferred to Sherlock core contract   function claimPremiumsForStakers() external override whenNotPaused {     // Gets address of core Sherlock contract     address sherlock = address(sherlockCore);     // Revert if core Sherlock contract not initialized yet     if (sherlock == address(0)) revert InvalidConditions(); // claimablePremiums is different from _settleTotalDebt() because it does not change state // Retrieves current amount of all premiums that are owed to stakers uint256 amount = claimablePremiums();  // Transfers all the premiums owed to stakers to the Sherlock core contract if (amount != 0) {   // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out   lastClaimablePremiumsForStakers = 0;   lastAccountedGlobal = block.timestamp;   token.safeTransfer(sherlock, amount); }  } // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts   /// @param protocol Protocol identifier   /// @return current and previous are the current and previous coverage amounts for this protocol   // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)   function coverageAmounts(bytes32 _protocol)     external     view     override     returns (uint256 current, uint256 previous)   {     // Checks to see if the protocol has an active protocolAgent (protocol not removed)     // OR checks to see if the removed protocol is still within the claim window     // If so, gives the current and previous coverage, otherwise throws an error     if (       protocolAgent[_protocol] != address(0) ||       block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]     ) {       return (currentCoverage[_protocol], previousCoverage[_protocol]);     } revert ProtocolNotExists(_protocol);  } /// @notice Add a new protocol to Sherlock   /// @param protocol Protocol identifier   /// @param _protocolAgent Address able to submit a claim on behalf of the protocol   /// @param _coverage Hash referencing the active coverage agreement   /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 1018   /// @param _coverageAmount Max amount claimable by this protocol   /// @dev Adding a protocol allows the _protocolAgent to submit a claim   /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point   /// @dev _nonStakers is scaled by 1018   /// @dev Only callable by governance   function protocolAdd(     bytes32 _protocol,     address _protocolAgent,     bytes32 _coverage,     uint256 _nonStakers,     uint256 _coverageAmount   ) external override onlyOwner {     if (_protocol == bytes32(0)) revert ZeroArgument();     if (_protocolAgent == address(0)) revert ZeroArgument();     // Checks to make sure the protocol doesn't exist already     if (protocolAgent[_protocol] != address(0)) revert InvalidConditions(); // Updates the protocol agent and passes in the old agent which is 0 address in this case _setProtocolAgent(_protocol, address(0), _protocolAgent);  // Delete mappings that are potentially non default values // From previous time protocol was added/removed delete removedProtocolClaimDeadline[_protocol]; delete removedProtocolAgent[_protocol]; delete currentCoverage[_protocol]; delete previousCoverage[_protocol];  emit ProtocolAdded(_protocol);  // Most of the logic for actually adding a protocol in this function protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);  } /// @notice Update info regarding a protocol   /// @param _protocol Protocol identifier   /// @param _coverage Hash referencing the active coverage agreement   /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18   /// @param _coverageAmount Max amount claimable by this protocol   /// @dev Only callable by governance   /// @dev _nonStakers can be 0   function protocolUpdate(     bytes32 _protocol,     bytes32 _coverage,     uint256 _nonStakers,     uint256 _coverageAmount   ) public override onlyOwner {     if (_coverage == bytes32(0)) revert ZeroArgument();     if (_nonStakers &gt; HUNDRED_PERCENT) revert InvalidArgument();     if (_coverageAmount == uint256(0)) revert ZeroArgument(); // Checks to make sure the protocol has been assigned a protocol agent _verifyProtocolExists(_protocol);  // Subtracts the accrued debt from a protocol's active balance (if any) // Updates the amount that can be claimed by nonstakers _settleProtocolDebt(_protocol);  // Updates the global claimable amount for stakers _settleTotalDebt();  // Gets the premium per second for this protocol uint256 premium = premiums_[_protocol];  // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be) allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(   premium,   premium,   nonStakersPercentage[_protocol],   _nonStakers,   allPremiumsPerSecToStakers );  // Updates the stored value of percentage of premiums that go to nonstakers nonStakersPercentage[_protocol] = _nonStakers;  // Updates previous coverage and current coverage amounts previousCoverage[_protocol] = currentCoverage[_protocol]; currentCoverage[_protocol] = _coverageAmount;  emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);  } /// @notice Remove a protocol from coverage   /// @param _protocol Protocol identifier   /// @dev Before removing a protocol the premium must be 0   /// @dev Removing a protocol basically stops the _protocolAgent from being active (can still submit claims until claim deadline though)   /// @dev Pays off debt + sends remaining balance to protocol agent   /// @dev This call should be subject to a timelock   /// @dev Only callable by governance   function protocolRemove(bytes32 _protocol) external override onlyOwner {     // checks to make sure the protocol actually has a protocol agent     address agent = _verifyProtocolExists(_protocol); // Removes a protocol from Sherlock and cleans up its data // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made _forceRemoveProtocol(_protocol, agent);  } /// @notice Remove a protocol with insufficient active balance   /// @param _protocol Protocol identifier   // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function   function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {     address agent = _verifyProtocolExists(_protocol); // Gets the latest value of the active balance at this protocol _settleProtocolDebt(_protocol); // Sets latest value of active balance to remainingBalance variable uint256 remainingBalance = activeBalances[_protocol];  // This means the protocol still has adequate active balance and thus cannot be removed if (remainingBalance &gt;= minActiveBalance) revert InvalidConditions();  // Sets the protocol's active balance to 0 delete activeBalances[_protocol]; // Removes the protocol from coverage _forceRemoveProtocol(_protocol, agent);  if (remainingBalance != 0) {   // sends the remaining balance to msg.sender   token.safeTransfer(msg.sender, remainingBalance); } emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);  } /// @notice Calculate if arb is possible and what the reward would be   /// @param _protocol Protocol identifier   /// @return arbAmount Amount reward for arbing   /// @return able Indicator if arb call is even possible   /// @dev Doesn't subtract the current protocol debt from the active balance   function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)     internal     view     returns (uint256 arbAmount, bool able)   {     uint256 secondsLeft = _secondsOfCoverageLeft(_protocol); // If arb is not possible return false if (secondsLeft &gt;= MIN_SECONDS_OF_COVERAGE) return (0, false);  // This percentage scales over time // Reaches 100% on 0 seconds of coverage left uint256 percentageScaled = HUNDRED_PERCENT -   (secondsLeft * HUNDRED_PERCENT) /   MIN_SECONDS_OF_COVERAGE;  able = true; arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;  } /// @notice Removes a protocol with insufficent seconds of coverage left   /// @param _protocol Protocol identifier   // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second   function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {     // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings     address agent = _verifyProtocolExists(_protocol); // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance() // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance() // But when removing based on seconds of coverage left, the remainingBalance could still be quite large // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%) _settleProtocolDebt(_protocol); (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol); if (able == false) revert InvalidConditions();  if (arbAmount != 0) {   // subtracts the amount that will be paid to the arb from the active balance   activeBalances[_protocol] -= arbAmount; }  // Removes the protocol from coverage // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above _forceRemoveProtocol(_protocol, agent);  // Done after removing protocol to mitigate reentrency pattern // (In case token allows callback) if (arbAmount != 0) {   token.safeTransfer(msg.sender, arbAmount); } emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);  } /// @notice Set premium of _protocol to _premium   /// @param _protocol Protocol identifier   /// @param _premium Amount of premium _protocol pays per second   /// @dev The value 0 would mean inactive coverage   /// @dev Only callable by governance   function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {     // Checks to see if protocol has a protocol agent     _verifyProtocolExists(_protocol); // Updates individual protocol's premium and allPremiumsPerSecToStakers _setSingleAndGlobalProtocolPremium(_protocol, _premium);  } /// @notice Set premium of multiple protocols   /// @param _protocol Array of protocol identifiers   /// @param _premium Array of premium amounts protocols pay per second   /// @dev The value 0 would mean inactive coverage   /// @dev Only callable by governance   function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)     external     override     onlyOwner   {     // Checks to make sure there are an equal amount of entries in each array     if (_protocol.length != _premium.length) revert UnequalArrayLength();     if (_protocol.length == 0) revert InvalidArgument(); // Updates the global claimable amount for stakers _settleTotalDebt();  uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;  // Loops through the array of protocols and checks to make sure each has a protocol agent assigned for (uint256 i; i &lt; _protocol.length; i++) {   _verifyProtocolExists(_protocol[i]);    // Sets the protocol premium for that specific protocol   // Function returns the old premium and nonStakerPercentage for that specific protocol   (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(     _protocol[i],     _premium[i]   );    // Calculates the new global premium which adds up all premiums paid by all protocols   allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(     oldPremiumPerSecond,     _premium[i],     nonStakerPercentage,     nonStakerPercentage,     allPremiumsPerSecToStakers_   ); }  // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;  } // This is how protocols pay for coverage by increasing their active balance   /// @notice Deposits _amount of token to the active balance of _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens to deposit   /// @dev Approval should be made before calling   function depositToActiveBalance(bytes32 _protocol, uint256 _amount)     external     override     whenNotPaused   {     if (_amount == uint256(0)) revert ZeroArgument();     _verifyProtocolExists(_protocol); // Transfers _amount to this contract token.safeTransferFrom(msg.sender, address(this), _amount); // Increases the active balance of the protocol by _amount activeBalances[_protocol] += _amount;  emit ProtocolBalanceDeposited(_protocol, _amount);  } // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)   // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)   /// @notice Withdraws _amount of token from the active balance of _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens to withdraw   /// @dev Only protocol agent is able to withdraw   /// @dev Balance can be withdrawn up until 7 days worth of active balance   function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)     external     override     whenNotPaused   {     if (_amount == uint256(0)) revert ZeroArgument();     // Only the protocol agent can call this function     if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized(); // Updates the active balance of the protocol _settleProtocolDebt(_protocol);  // Sets currentBalance to the active balance of the protocol uint256 currentBalance = activeBalances[_protocol]; // Reverts if trying to withdraw more than the active balance if (_amount &gt; currentBalance) revert InsufficientBalance(_protocol);  // Removes the _amount to be withdrawn from the active balance activeBalances[_protocol] = currentBalance - _amount; // Reverts if a protocol has less than 7 days worth of active balance left if (_secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);  // Transfers the amount to the msg.sender (protocol agent) token.safeTransfer(msg.sender, _amount); emit ProtocolBalanceWithdrawn(_protocol, _amount);  } /// @notice Transfer protocol agent role   /// @param _protocol Protocol identifier   /// @param _protocolAgent Account able to submit a claim on behalf of the protocol   /// @dev Only the active protocolAgent is able to transfer the role   function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)     external     override     whenNotPaused   {     if (_protocolAgent == address(0)) revert ZeroArgument();     // Can't set the new protocol agent to the caller address     if (msg.sender == _protocolAgent) revert InvalidArgument();     // Because the caller must be the current protocol agent     if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized(); // Sets the protocol agent to the new address _setProtocolAgent(_protocol, msg.sender, _protocolAgent);  } /// @notice Function used to check if this is the current active protocol manager   /// @return Boolean indicating it's active   /// @dev If inactive the owner can pull all ERC20s and ETH   /// @dev Will be checked by calling the sherlock contract   function isActive() public view returns (bool) {     return address(sherlockCore.sherlockProtocolManager()) == address(this);   } // Only contract owner can call this   // Sends all specified tokens in this contract to the receiver's address (as well as ETH)   function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {     if (_receiver == address(0)) revert ZeroArgument();     // This contract must NOT be the current assigned protocol manager contract     if (isActive()) revert InvalidConditions();     // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH     _sweep(_receiver, _extraTokens);   } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/***********\\n Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x)\n Sherlock Protocol: https://sherlock.xyz\n/***********/\n\nimport \'./Manager.sol\';\nimport \'../interfaces/managers/ISherlockProtocolManager.sol\';\n\n/// @title Sherlock core interface for protocols\n/// @author Evert Kors\n// This is the contract that manages covered protocols\n\ncontract SherlockProtocolManager is ISherlockProtocolManager, Manager {\n  using SafeERC20 for IERC20;\n\n  // Represents the token that protocols pay with (currently USDC)\n  IERC20 public immutable token;\n\n  // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed\n  uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 106; // 30k usdc\n\n  // A removed protocol is still able to make a claim for this amount of time after its removal\n  uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days;\n\n  // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance\n  uint256 public constant MIN_SECONDS_LEFT = 7 days;\n\n  // Convenient for percentage calculations\n  uint256 internal constant HUNDRED_PERCENT = 1018;\n\n  // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage\n  // This value is calculated from a protocol\'s active balance divided by the premium per second the protocol is paying\n  uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours;\n\n  // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)\n  mapping(bytes32 =&gt; address) internal protocolAgent_;\n\n  // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)\n  mapping(bytes32 =&gt; uint256) internal nonStakersPercentage;\n\n  // The premium per second paid by each protocol is stored in this mapping\n  mapping(bytes32 =&gt; uint256) internal premiums_;\n\n  // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.\n  // This "active balance" is really just an accounting concept, doesn\'t mean tokens have been transferred or not\n  mapping(bytes32 =&gt; uint256) internal activeBalances;\n\n  // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol\n  mapping(bytes32 =&gt; uint256) internal lastAccountedEachProtocol;\n\n  // The amount that can be claimed by nonstakers for each protocol\n  // We need this value so we can track how much payment is coming from each protocol\n  mapping(bytes32 =&gt; uint256) internal nonStakersClaimableByProtocol;\n\n  // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)\n  uint256 internal lastAccountedGlobal;\n\n  // This is the total amount of premiums paid (per second) by all the covered protocols (added up)\n  uint256 internal allPremiumsPerSecToStakers;\n\n  // This is the amount that was claimable by stakers the last time the accounting was run\n  // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date\n  uint256 internal lastClaimablePremiumsForStakers;\n\n  // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage\n  // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)\n  uint256 public override minActiveBalance;\n\n  // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)\n  mapping(bytes32 =&gt; uint256) internal removedProtocolClaimDeadline;\n\n  // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)\n  mapping(bytes32 =&gt; address) internal removedProtocolAgent;\n\n  // Current amount of coverage (i.e. 20M USDC) for a protocol\n  mapping(bytes32 =&gt; uint256) internal currentCoverage;\n\n  // Previous amount of coverage for a protocol\n  // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount\n  mapping(bytes32 =&gt; uint256) internal previousCoverage;\n\n  // Setting the token to USDC\n  constructor(IERC20 token) {\n    if (address(_token) == address(0)) revert ZeroArgument();\n    token = _token;\n  }\n\n  // Modifier used to ensure a protocol exists (has been instantiated and not removed)\n  modifier protocolExists(bytes32 _protocol) {\n    _verifyProtocolExists(_protocol);\n    ;\n  }\n\n  /// @notice View current protocolAgent of _protocol\n  /// @param protocol Protocol identifier\n  /// @return Address able to submit claims\n  function protocolAgent(bytes32 _protocol) external view override returns (address) {\n    address agent = protocolAgent[protocol];\n    if (agent != address(0)) return agent;\n\n    // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned\n    // Note: Old protocol agent will never be address(0)\n    if (block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]) {\n      return removedProtocolAgent[_protocol];\n    }\n\n    // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned\n    revert ProtocolNotExists(_protocol);\n  }\n\n  // Checks if the protocol exists, then returns the current premium per second being charged\n  /// @notice View current premium of protocol\n  /// @param _protocol Protocol identifier\n  /// @return Amount of premium _protocol pays per second\n  function premium(bytes32 _protocol)\n    external\n    view\n    override\n    protocolExists(_protocol)\n    returns (uint256)\n  {\n    return premiums[protocol];\n  }\n\n  // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)\n  // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)\n  function _verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {\n    _protocolAgent = protocolAgent[protocol];\n    if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);\n  }\n\n  //\n  // View methods\n  //\n\n  // Calcs the debt accrued by the protocol since it last had an accounting update\n  // This is the amount that needs to be removed from a protocol\'s active balance\n  function _calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {\n    return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums[protocol];\n  }\n\n  /// @notice View the amount nonstakers can claim from this protocol\n  /// @param _protocol Protocol identifier\n  /// @return Amount of tokens claimable by nonstakers\n  /// @dev this reads from a storage variable + (now-lastsettled) * premiums\n  // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]\n  // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn\'t change since the protocol has been removed\n  function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {\n    // Calcs the debt of a protocol since the last accounting update\n    uint256 debt = _calcIncrementalProtocolDebt(_protocol);\n    // Gets the active balance of the protocol\n    uint256 balance = activeBalances[_protocol];\n    // The debt should never be higher than the balance (only happens if the arbitrages fail)\n    if (debt &gt; balance) debt = balance;\n\n    // Adds the incremental claimable amount owed to nonstakers to the total claimable amount\n    return\n      nonStakersClaimableByProtocol[_protocol] +\n      (nonStakersPercentage[_protocol] * debt) /\n      HUNDRED_PERCENT;\n  }\n\n  /// @notice View current amount of all premiums that are owed to stakers\n  /// @return Premiums claimable\n  /// @dev Will increase every block\n  /// @dev base + (now - last_settled) * ps\n  function claimablePremiums() public view override returns (uint256) {\n    // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)\n    return\n      lastClaimablePremiumsForStakers +\n      (block.timestamp - lastAccountedGlobal) \n      allPremiumsPerSecToStakers;\n  }\n\n  /// @notice View seconds of coverage left for _protocol before it runs out of active balance\n  /// @param protocol Protocol identifier\n  /// @return Seconds of coverage left\n  function secondsOfCoverageLeft(bytes32 _protocol)\n    external\n    view\n    override\n    protocolExists(_protocol)\n    returns (uint256)\n  {\n    return _secondsOfCoverageLeft(_protocol);\n  }\n\n  // Helper function to return seconds of coverage left for a protocol\n  // Gets the current active balance of the protocol and divides by the premium per second for the protocol\n  function _secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {\n    uint256 premium = premiums[protocol];\n    if (premium == 0) return 0;\n    return _activeBalance(_protocol) / premium;\n  }\n\n  /// @notice View current active balance of covered protocol\n  /// @param _protocol Protocol identifier\n  /// @return Active balance\n  /// @dev Accrued debt is subtracted from the stored active balance\n  function activeBalance(bytes32 _protocol)\n    external\n    view\n    override\n    protocolExists(_protocol)\n    returns (uint256)\n  {\n    return _activeBalance(_protocol);\n  }\n\n  // Helper function to calc the active balance of a protocol at current time\n  function _activeBalance(bytes32 _protocol) internal view returns (uint256) {\n    uint256 debt = _calcIncrementalProtocolDebt(_protocol);\n    uint256 balance = activeBalances[_protocol];\n    // The debt should never be higher than the balance (only happens if the arbitrages fail)\n    if (debt &gt; balance) return 0;\n    return balance - debt;\n  }\n\n  //\n  // State methods\n  //\n\n  /// @notice Helps set the premium per second for an individual protocol\n  /// @param _protocol Protocol identifier\n  /// @param _premium New premium per second\n  /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function\n  function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)\n    internal\n    returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)\n  {\n    // _settleProtocolDebt() subtracts debt from the protocol\'s active balance and updates the % due to nonstakers\n    // Also updates the last accounted timestamp for this protocol\n    // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings\n    // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol\n    nonStakerPercentage = _settleProtocolDebt(_protocol);\n    // Stores the old premium before it gets updated\n    oldPremiumPerSecond = premiums[protocol];\n\n    if (oldPremiumPerSecond != _premium) {\n      // Sets the protocol\'s premium per second to the new value\n      premiums[protocol] = _premium;\n      emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium);\n    }\n    // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing\n    // We don\'t need to check the min balance requirement for arbs because that value doesn\'t change like secondsOfCoverageLeft changes\n    // Effectively we just need to make sure we don\'t accidentally run a protocol\'s active balance down below the point\n    // Where arbs would no longer be incentivized to remove the protocol\n    // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems\n    if (_premium != 0 &amp;&amp; _secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_OF_COVERAGE) {\n      revert InsufficientBalance(_protocol);\n    }\n  }\n\n  /// @notice Sets a single protocol\'s premium per second and also updates the global total of premiums per second\n  /// @param _protocol Protocol identifier\n  /// @param _premium New premium per second\n  function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {\n    // Sets the individual protocol\'s premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings\n    (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(\n      _protocol,\n      _premium\n    );\n    // Settling the total amount of premiums owed to stakers before a new premium per second gets set\n    _settleTotalDebt();\n    // This calculates the new global premium per second that gets paid to stakers\n    // We input the same nonStakerPercentage twice because we simply aren\'t updating that value in this function\n    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(\n      oldPremiumPerSecond,\n      _premium,\n      nonStakerPercentage,\n      nonStakerPercentage,\n      allPremiumsPerSecToStakers\n    );\n  }\n\n  // Internal function to set a new protocolAgent for a specific protocol\n  // _oldAgent is only included as part of emitting an event\n  function _setProtocolAgent(\n    bytes32 _protocol,\n    address _oldAgent,\n    address _protocolAgent\n  ) internal {\n    protocolAgent[protocol] = _protocolAgent;\n    emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);\n  }\n\n  // Subtracts the accrued debt from a protocol\'s active balance\n  // Credits the amount that can be claimed by nonstakers for this protocol\n  // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings\n  // Most of this function is dealing with an edge case related to a protocol not being removed by arbs\n  function _settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {\n    // This calcs the accrued debt of the protocol since it was last updated\n    uint256 debt = _calcIncrementalProtocolDebt(_protocol);\n    // This pulls the percentage that is sent to nonstakers\n    _nonStakerPercentage = nonStakersPercentage[_protocol];\n    // In case the protocol has accrued debt, this code block will ensure the debt is settled properly\n    if (debt != 0) {\n      // Pulls the stored active balance of the protocol\n      uint256 balance = activeBalances[_protocol];\n      // This is the start of handling an edge case where arbitragers don\'t remove this protocol before debt becomes greater than active balance\n      // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point\n      // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage\n      // However, if arbs don\'t come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up\n      if (debt &gt; balance) {\n        // This error amount represents the magnitude of the mistake\n        uint256 error = debt - balance;\n        // Gets the latest value of claimable premiums for stakers\n        _settleTotalDebt();\n        // @note to production, set premium first to zero before solving accounting issue.\n        // otherwise the accounting error keeps increasing\n        uint256 lastClaimablePremiumsForStakers = lastClaimablePremiumsForStakers;\n\n        // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%\n        uint256 claimablePremiumError = ((HUNDRED_PERCENT - nonStakerPercentage) * error) /\n          HUNDRED_PERCENT;\n\n        // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short\n        uint256 insufficientTokens;\n\n        // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally\n        // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error\n        // This first line can be true if claimPremiumsForStakers() has been called and\n        // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be &gt;0 still\n        if (claimablePremiumError &gt; lastClaimablePremiumsForStakers) {\n          insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;\n          lastClaimablePremiumsForStakers = 0;\n        } else {\n          // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums\n          // By the amount that was added in error (error) and insufficientTokens = 0\n          lastClaimablePremiumsForStakers =\n            lastClaimablePremiumsForStakers_ -\n            claimablePremiumError;\n        }\n\n        // If two events are thrown, the values need to be summed up for the actual state.\n        // This means an error of this type will continue until it is handled\n        emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);\n        // We set the debt equal to the balance, and in the next line we effectively set the protocol\'s active balance to 0 in this case\n        debt = balance;\n      }\n      // Subtracts the accrued debt (since last update) from the protocol\'s active balance and updates active balance\n      activeBalances[_protocol] = balance - debt;\n      // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol\n      nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT;\n    }\n    // Updates the last accounted timestamp for this protocol\n    lastAccountedEachProtocol[_protocol] = block.timestamp;\n  }\n\n  // Multiplies the total premium per second * number of seconds since the last global accounting update\n  // And adds it to the total claimable amount for stakers\n  function _settleTotalDebt() internal {\n    lastClaimablePremiumsForStakers +=\n      (block.timestamp - lastAccountedGlobal) \n      allPremiumsPerSecToStakers;\n    lastAccountedGlobal = block.timestamp;\n  }\n\n  // Calculates the global premium per second for stakers\n  // Takes a specific protocol\'s old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers\n  // Subtracts out the old values of a protocol\'s premium per second and nonstaker percentage and adds the new ones\n  function _calcGlobalPremiumPerSecForStakers(\n    uint256 _premiumOld,\n    uint256 _premiumNew,\n    uint256 _nonStakerPercentageOld,\n    uint256 _nonStakerPercentageNew,\n    uint256 _inMemAllPremiumsPerSecToStakers\n  ) internal pure returns (uint256) {\n    return\n      _inMemAllPremiumsPerSecToStakers +\n      ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /\n      HUNDRED_PERCENT -\n      ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /\n      HUNDRED_PERCENT;\n  }\n\n  // Helper function to remove and clean up a protocol from Sherlock\n  // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made\n  function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {\n    // Sets the individual protocol\'s premium to zero and updates the global premium variable for a zero premium at this protocol\n    _setSingleAndGlobalProtocolPremium(_protocol, 0);\n\n    // Grabs the protocol\'s active balance\n    uint256 balance = activeBalances[_protocol];\n\n    // If there\'s still some active balance, delete the entry and send the remaining balance to the protocol agent\n    if (balance != 0) {\n      delete activeBalances[_protocol];\n      token.safeTransfer(_agent, balance);\n\n      emit ProtocolBalanceWithdrawn(_protocol, balance);\n    }\n\n    // Sets the protocol agent to zero address (as part of clean up)\n    _setProtocolAgent(_protocol, _agent, address(0));\n\n    // Cleans up other mappings for this protocol\n    delete nonStakersPercentage[_protocol];\n    delete lastAccountedEachProtocol[_protocol];\n    // premiums_ mapping is not deleted here as it\'s already 0 because of the _setSingleAndGlobalProtocolPremium call above\n\n    // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol\n    removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;\n\n    // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed\n    // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked\n    removedProtocolAgent[_protocol] = _agent;\n\n    emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0));\n    emit ProtocolRemoved(_protocol);\n  }\n\n  /// @notice Sets the minimum active balance before an arb can remove a protocol\n  /// @param _minActiveBalance Minimum balance needed (in USDC)\n  /// @dev Only gov\n  function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {\n    // New value cannot be the same as current value\n    if (minActiveBalance == _minActiveBalance) revert InvalidArgument();\n    // Can\'t set a value that is too high to be reasonable\n    if (_minActiveBalance &gt;= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions();\n\n    emit MinBalance(minActiveBalance, _minActiveBalance);\n    minActiveBalance = _minActiveBalance;\n  }\n\n  // This function allows the nonstakers role to claim tokens owed to them by a specific protocol\n  /// @notice Choose an _amount of tokens that nonstakers (_receiver address) will receive from _protocol\n  /// @param _protocol Protocol identifier\n  /// @param _amount Amount of tokens\n  /// @param _receiver Address to receive tokens\n  /// @dev Only callable by nonstakers role\n  function nonStakersClaim(\n    bytes32 _protocol,\n    uint256 _amount,\n    address _receiver\n  ) external override whenNotPaused {\n    if (_protocol == bytes32(0)) revert ZeroArgument();\n    if (_amount == uint256(0)) revert ZeroArgument();\n    if (_receiver == address(0)) revert ZeroArgument();\n    // Only the nonstakers role (multisig or contract) can pull the funds\n    if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized();\n\n    // Call can\'t be executed on protocol that is removed\n    if (protocolAgent[protocol] != address(0)) {\n      // Updates the amount that nonstakers can claim from this protocol\n      _settleProtocolDebt(_protocol);\n    }\n\n    // Sets balance to the amount that is claimable by nonstakers for this specific protocol\n    uint256 balance = nonStakersClaimableByProtocol[_protocol];\n    // If the amount requested is more than what\'s owed to nonstakers, revert\n    if (_amount &gt; balance) revert InsufficientBalance(_protocol);\n\n    // Sets the claimable amount to whatever is left over after this amount is pulled\n    nonStakersClaimableByProtocol[_protocol] = balance - _amount;\n    // Transfers the amount requested to the _receiver address\n    token.safeTransfer(_receiver, _amount);\n  }\n\n  // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)\n  /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address\n  /// @dev Callable by everyone\n  /// @dev Funds will be transferred to Sherlock core contract\n  function claimPremiumsForStakers() external override whenNotPaused {\n    // Gets address of core Sherlock contract\n    address sherlock = address(sherlockCore);\n    // Revert if core Sherlock contract not initialized yet\n    if (sherlock == address(0)) revert InvalidConditions();\n\n    // claimablePremiums is different from _settleTotalDebt() because it does not change state\n    // Retrieves current amount of all premiums that are owed to stakers\n    uint256 amount = claimablePremiums();\n\n    // Transfers all the premiums owed to stakers to the Sherlock core contract\n    if (amount != 0) {\n      // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out\n      lastClaimablePremiumsForStakers = 0;\n      lastAccountedGlobal = block.timestamp;\n      token.safeTransfer(sherlock, amount);\n    }\n  }\n\n  // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts\n  /// @param _protocol Protocol identifier\n  /// @return current and previous are the current and previous coverage amounts for this protocol\n  // Note For this process to work, a protocol\'s coverage amount should not be set more than once in the span of claim delay period (7 days or something)\n  function coverageAmounts(bytes32 _protocol)\n    external\n    view\n    override\n    returns (uint256 current, uint256 previous)\n  {\n    // Checks to see if the protocol has an active protocolAgent (protocol not removed)\n    // OR checks to see if the removed protocol is still within the claim window\n    // If so, gives the current and previous coverage, otherwise throws an error\n    if (\n      protocolAgent[protocol] != address(0) ||\n      block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]\n    ) {\n      return (currentCoverage[_protocol], previousCoverage[_protocol]);\n    }\n\n    revert ProtocolNotExists(_protocol);\n  }\n\n  /// @notice Add a new protocol to Sherlock\n  /// @param _protocol Protocol identifier\n  /// @param _protocolAgent Address able to submit a claim on behalf of the protocol\n  /// @param _coverage Hash referencing the active coverage agreement\n  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 1018\n  /// @param _coverageAmount Max amount claimable by this protocol\n  /// @dev Adding a protocol allows the _protocolAgent to submit a claim\n  /// @dev Coverage is not started yet as the protocol doesn\'t pay a premium at this point\n  /// @dev _nonStakers is scaled by 1018\n  /// @dev Only callable by governance\n  function protocolAdd(\n    bytes32 _protocol,\n    address _protocolAgent,\n    bytes32 _coverage,\n    uint256 _nonStakers,\n    uint256 _coverageAmount\n  ) external override onlyOwner {\n    if (_protocol == bytes32(0)) revert ZeroArgument();\n    if (_protocolAgent == address(0)) revert ZeroArgument();\n    // Checks to make sure the protocol doesn\'t exist already\n    if (protocolAgent[protocol] != address(0)) revert InvalidConditions();\n\n    // Updates the protocol agent and passes in the old agent which is 0 address in this case\n    _setProtocolAgent(_protocol, address(0), _protocolAgent);\n\n    // Delete mappings that are potentially non default values\n    // From previous time protocol was added/removed\n    delete removedProtocolClaimDeadline[_protocol];\n    delete removedProtocolAgent[_protocol];\n    delete currentCoverage[_protocol];\n    delete previousCoverage[_protocol];\n\n    emit ProtocolAdded(_protocol);\n\n    // Most of the logic for actually adding a protocol in this function\n    protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);\n  }\n\n  /// @notice Update info regarding a protocol\n  /// @param _protocol Protocol identifier\n  /// @param _coverage Hash referencing the active coverage agreement\n  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18\n  /// @param _coverageAmount Max amount claimable by this protocol\n  /// @dev Only callable by governance\n  /// @dev _nonStakers can be 0\n  function protocolUpdate(\n    bytes32 _protocol,\n    bytes32 _coverage,\n    uint256 _nonStakers,\n    uint256 _coverageAmount\n  ) public override onlyOwner {\n    if (_coverage == bytes32(0)) revert ZeroArgument();\n    if (_nonStakers &gt; HUNDRED_PERCENT) revert InvalidArgument();\n    if (_coverageAmount == uint256(0)) revert ZeroArgument();\n\n    // Checks to make sure the protocol has been assigned a protocol agent\n    _verifyProtocolExists(_protocol);\n\n    // Subtracts the accrued debt from a protocol\'s active balance (if any)\n    // Updates the amount that can be claimed by nonstakers\n    _settleProtocolDebt(_protocol);\n\n    // Updates the global claimable amount for stakers\n    _settleTotalDebt();\n\n    // Gets the premium per second for this protocol\n    uint256 premium = premiums[protocol];\n\n    // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be)\n    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(\n      premium,\n      premium,\n      nonStakersPercentage[_protocol],\n      _nonStakers,\n      allPremiumsPerSecToStakers\n    );\n\n    // Updates the stored value of percentage of premiums that go to nonstakers\n    nonStakersPercentage[_protocol] = _nonStakers;\n\n    // Updates previous coverage and current coverage amounts\n    previousCoverage[_protocol] = currentCoverage[_protocol];\n    currentCoverage[_protocol] = _coverageAmount;\n\n    emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);\n  }\n\n  /// @notice Remove a protocol from coverage\n  /// @param _protocol Protocol identifier\n  /// @dev Before removing a protocol the premium must be 0\n  /// @dev Removing a protocol basically stops the _protocolAgent from being active (can still submit claims until claim deadline though)\n  /// @dev Pays off debt + sends remaining balance to protocol agent\n  /// @dev This call should be subject to a timelock\n  /// @dev Only callable by governance\n  function protocolRemove(bytes32 _protocol) external override onlyOwner {\n    // checks to make sure the protocol actually has a protocol agent\n    address agent = _verifyProtocolExists(_protocol);\n\n    // Removes a protocol from Sherlock and cleans up its data\n    // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made\n    _forceRemoveProtocol(_protocol, agent);\n  }\n\n  /// @notice Remove a protocol with insufficient active balance\n  /// @param _protocol Protocol identifier\n  // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function\n  function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {\n    address agent = _verifyProtocolExists(_protocol);\n\n    // Gets the latest value of the active balance at this protocol\n    _settleProtocolDebt(_protocol);\n    // Sets latest value of active balance to remainingBalance variable\n    uint256 remainingBalance = activeBalances[_protocol];\n\n    // This means the protocol still has adequate active balance and thus cannot be removed\n    if (remainingBalance &gt;= minActiveBalance) revert InvalidConditions();\n\n    // Sets the protocol\'s active balance to 0\n    delete activeBalances[_protocol];\n    // Removes the protocol from coverage\n    _forceRemoveProtocol(_protocol, agent);\n\n    if (remainingBalance != 0) {\n      // sends the remaining balance to msg.sender\n      token.safeTransfer(msg.sender, remainingBalance);\n    }\n    emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);\n  }\n\n  /// @notice Calculate if arb is possible and what the reward would be\n  /// @param _protocol Protocol identifier\n  /// @return arbAmount Amount reward for arbing\n  /// @return able Indicator if arb call is even possible\n  /// @dev Doesn\'t subtract the current protocol debt from the active balance\n  function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)\n    internal\n    view\n    returns (uint256 arbAmount, bool able)\n  {\n    uint256 secondsLeft = _secondsOfCoverageLeft(_protocol);\n\n    // If arb is not possible return false\n    if (secondsLeft &gt;= MIN_SECONDS_OF_COVERAGE) return (0, false);\n\n    // This percentage scales over time\n    // Reaches 100% on 0 seconds of coverage left\n    uint256 percentageScaled = HUNDRED_PERCENT -\n      (secondsLeft * HUNDRED_PERCENT) /\n      MIN_SECONDS_OF_COVERAGE;\n\n    able = true;\n    arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;\n  }\n\n  /// @notice Removes a protocol with insufficent seconds of coverage left\n  /// @param _protocol Protocol identifier\n  // Seconds of coverage is defined by the active balance of the protocol divided by the protocol\'s premium per second\n  function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {\n    // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings\n    address agent = _verifyProtocolExists(_protocol);\n\n    // NOTE: We don\'t give the arb the full remaining balance like we do in forceRemoveByActiveBalance()\n    // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance()\n    // But when removing based on seconds of coverage left, the remainingBalance could still be quite large\n    // So it\'s better to scale the arb reward over time. It\'s a little complex because the remainingBalance\n    // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%)\n    _settleProtocolDebt(_protocol);\n    (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol);\n    if (able == false) revert InvalidConditions();\n\n    if (arbAmount != 0) {\n      // subtracts the amount that will be paid to the arb from the active balance\n      activeBalances[_protocol] -= arbAmount;\n    }\n\n    // Removes the protocol from coverage\n    // This function also pays the active balance to the protocol agent, so it\'s good we do this after subtracting arb amount above\n    _forceRemoveProtocol(_protocol, agent);\n\n    // Done after removing protocol to mitigate reentrency pattern\n    // (In case token allows callback)\n    if (arbAmount != 0) {\n      token.safeTransfer(msg.sender, arbAmount);\n    }\n    emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);\n  }\n\n  /// @notice Set premium of _protocol to _premium\n  /// @param _protocol Protocol identifier\n  /// @param _premium Amount of premium _protocol pays per second\n  /// @dev The value 0 would mean inactive coverage\n  /// @dev Only callable by governance\n  function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {\n    // Checks to see if protocol has a protocol agent\n    _verifyProtocolExists(_protocol);\n\n    // Updates individual protocol\'s premium and allPremiumsPerSecToStakers\n    _setSingleAndGlobalProtocolPremium(_protocol, _premium);\n  }\n\n  /// @notice Set premium of multiple protocols\n  /// @param _protocol Array of protocol identifiers\n  /// @param _premium Array of premium amounts protocols pay per second\n  /// @dev The value 0 would mean inactive coverage\n  /// @dev Only callable by governance\n  function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)\n    external\n    override\n    onlyOwner\n  {\n    // Checks to make sure there are an equal amount of entries in each array\n    if (_protocol.length != _premium.length) revert UnequalArrayLength();\n    if (_protocol.length == 0) revert InvalidArgument();\n\n    // Updates the global claimable amount for stakers\n    _settleTotalDebt();\n\n    uint256 allPremiumsPerSecToStakers = allPremiumsPerSecToStakers;\n\n    // Loops through the array of protocols and checks to make sure each has a protocol agent assigned\n    for (uint256 i; i &lt; protocol.length; i++) {\n      _verifyProtocolExists(_protocol[i]);\n\n      // Sets the protocol premium for that specific protocol\n      // Function returns the old premium and nonStakerPercentage for that specific protocol\n      (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(\n        _protocol[i],\n        _premium[i]\n      );\n\n      // Calculates the new global premium which adds up all premiums paid by all protocols\n      allPremiumsPerSecToStakers = calcGlobalPremiumPerSecForStakers(\n        oldPremiumPerSecond,\n        _premium[i],\n        nonStakerPercentage,\n        nonStakerPercentage,\n        allPremiumsPerSecToStakers\n      );\n    }\n\n    // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value\n    allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;\n  }\n\n  // This is how protocols pay for coverage by increasing their active balance\n  /// @notice Deposits _amount of token to the active balance of _protocol\n  /// @param _protocol Protocol identifier\n  /// @param _amount Amount of tokens to deposit\n  /// @dev Approval should be made before calling\n  function depositToActiveBalance(bytes32 _protocol, uint256 _amount)\n    external\n    override\n    whenNotPaused\n  {\n    if (_amount == uint256(0)) revert ZeroArgument();\n    _verifyProtocolExists(_protocol);\n\n    // Transfers _amount to this contract\n    token.safeTransferFrom(msg.sender, address(this), _amount);\n    // Increases the active balance of the protocol by _amount\n    activeBalances[_protocol] += _amount;\n\n    emit ProtocolBalanceDeposited(_protocol, _amount);\n  }\n\n  // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)\n  // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)\n  /// @notice Withdraws _amount of token from the active balance of _protocol\n  /// @param _protocol Protocol identifier\n  /// @param _amount Amount of tokens to withdraw\n  /// @dev Only protocol agent is able to withdraw\n  /// @dev Balance can be withdrawn up until 7 days worth of active balance\n  function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)\n    external\n    override\n    whenNotPaused\n  {\n    if (_amount == uint256(0)) revert ZeroArgument();\n    // Only the protocol agent can call this function\n    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();\n\n    // Updates the active balance of the protocol\n    _settleProtocolDebt(_protocol);\n\n    // Sets currentBalance to the active balance of the protocol\n    uint256 currentBalance = activeBalances[_protocol];\n    // Reverts if trying to withdraw more than the active balance\n    if (_amount &gt; currentBalance) revert InsufficientBalance(_protocol);\n\n    // Removes the _amount to be withdrawn from the active balance\n    activeBalances[_protocol] = currentBalance - _amount;\n    // Reverts if a protocol has less than 7 days worth of active balance left\n    if (_secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);\n\n    // Transfers the amount to the msg.sender (protocol agent)\n    token.safeTransfer(msg.sender, _amount);\n    emit ProtocolBalanceWithdrawn(_protocol, _amount);\n  }\n\n  /// @notice Transfer protocol agent role\n  /// @param _protocol Protocol identifier\n  /// @param _protocolAgent Account able to submit a claim on behalf of the protocol\n  /// @dev Only the active protocolAgent is able to transfer the role\n  function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)\n    external\n    override\n    whenNotPaused\n  {\n    if (_protocolAgent == address(0)) revert ZeroArgument();\n    // Can\'t set the new protocol agent to the caller address\n    if (msg.sender == _protocolAgent) revert InvalidArgument();\n    // Because the caller must be the current protocol agent\n    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();\n\n    // Sets the protocol agent to the new address\n    _setProtocolAgent(_protocol, msg.sender, _protocolAgent);\n  }\n\n  /// @notice Function used to check if this is the current active protocol manager\n  /// @return Boolean indicating it\'s active\n  /// @dev If inactive the owner can pull all ERC20s and ETH\n  /// @dev Will be checked by calling the sherlock contract\n  function isActive() public view returns (bool) {\n    return address(sherlockCore.sherlockProtocolManager()) == address(this);\n  }\n\n  // Only contract owner can call this\n  // Sends all specified tokens in this contract to the receiver\'s address (as well as ETH)\n  function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {\n    if (_receiver == address(0)) revert ZeroArgument();\n    // This contract must NOT be the current assigned protocol manager contract\n    if (isActive()) revert InvalidConditions();\n    // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH\n    _sweep(_receiver, _extraTokens);\n  }\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-25-08 10:58:57 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import './Manager.sol'; import '../interfaces/managers/ISherlockProtocolManager.sol'; /// @title Sherlock core interface for protocols /// @author Evert Kors // This is the contract that manages covered protocols contract SherlockProtocolManager is ISherlockProtocolManager, Manager {   using SafeERC20 for IERC20; // Represents the token that protocols pay with (currently USDC)   IERC20 public immutable token; // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed   uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc // A removed protocol is still able to make a claim for this amount of time after its removal   uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days; // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance   uint256 public constant MIN_SECONDS_LEFT = 7 days; // Convenient for percentage calculations   uint256 internal constant HUNDRED_PERCENT = 10**18; // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage   // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying   uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours; // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)   mapping(bytes32 =&gt; address) internal protocolAgent_; // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)   mapping(bytes32 =&gt; uint256) internal nonStakersPercentage; // The premium per second paid by each protocol is stored in this mapping   mapping(bytes32 =&gt; uint256) internal premiums_; // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.   // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not   mapping(bytes32 =&gt; uint256) internal activeBalances; // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol   mapping(bytes32 =&gt; uint256) internal lastAccountedEachProtocol; // The amount that can be claimed by nonstakers for each protocol   // We need this value so we can track how much payment is coming from each protocol   mapping(bytes32 =&gt; uint256) internal nonStakersClaimableByProtocol; // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)   uint256 internal lastAccountedGlobal; // This is the total amount of premiums paid (per second) by all the covered protocols (added up)   uint256 internal allPremiumsPerSecToStakers; // This is the amount that was claimable by stakers the last time the accounting was run   // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date   uint256 internal lastClaimablePremiumsForStakers; // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage   // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)   uint256 public override minActiveBalance; // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)   mapping(bytes32 =&gt; uint256) internal removedProtocolClaimDeadline; // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)   mapping(bytes32 =&gt; address) internal removedProtocolAgent; // Current amount of coverage (i.e. 20M USDC) for a protocol   mapping(bytes32 =&gt; uint256) internal currentCoverage; // Previous amount of coverage for a protocol   // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount   mapping(bytes32 =&gt; uint256) internal previousCoverage; // Setting the token to USDC   constructor(IERC20 _token) {     if (address(_token) == address(0)) revert ZeroArgument();     token = _token;   } // Modifier used to ensure a protocol exists (has been instantiated and not removed)   modifier protocolExists(bytes32 protocol) {     _verifyProtocolExists(_protocol);     ;   } /// @notice View current protocolAgent of _protocol   /// @param protocol Protocol identifier   /// @return Address able to submit claims   function protocolAgent(bytes32 _protocol) external view override returns (address) {     address agent = protocolAgent[_protocol];     if (agent != address(0)) return agent; // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned // Note: Old protocol agent will never be address(0) if (block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]) {   return removedProtocolAgent[_protocol]; }  // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned revert ProtocolNotExists(_protocol);  } // Checks if the protocol exists, then returns the current premium per second being charged   /// @notice View current premium of protocol   /// @param protocol Protocol identifier   /// @return Amount of premium _protocol pays per second   function premium(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return premiums[_protocol];   } // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)   // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)   function verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {     _protocolAgent = protocolAgent[_protocol];     if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);   } //   // View methods   // // Calcs the debt accrued by the protocol since it last had an accounting update   // This is the amount that needs to be removed from a protocol's active balance   function calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {     return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums[_protocol];   } /// @notice View the amount nonstakers can claim from this protocol   /// @param _protocol Protocol identifier   /// @return Amount of tokens claimable by nonstakers   /// @dev this reads from a storage variable + (now-lastsettled) * premiums   // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]   // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed   function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {     // Calcs the debt of a protocol since the last accounting update     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     // Gets the active balance of the protocol     uint256 balance = activeBalances[_protocol];     // The debt should never be higher than the balance (only happens if the arbitrages fail)     if (debt &gt; balance) debt = balance; // Adds the incremental claimable amount owed to nonstakers to the total claimable amount return   nonStakersClaimableByProtocol[_protocol] +   (nonStakersPercentage[_protocol] * debt) /   HUNDRED_PERCENT;  } /// @notice View current amount of all premiums that are owed to stakers   /// @return Premiums claimable   /// @dev Will increase every block   /// @dev base + (now - last_settled) * ps   function claimablePremiums() public view override returns (uint256) {     // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)     return       lastClaimablePremiumsForStakers +       (block.timestamp - lastAccountedGlobal) *       allPremiumsPerSecToStakers;   } /// @notice View seconds of coverage left for _protocol before it runs out of active balance   /// @param _protocol Protocol identifier   /// @return Seconds of coverage left   function secondsOfCoverageLeft(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return _secondsOfCoverageLeft(_protocol);   } // Helper function to return seconds of coverage left for a protocol   // Gets the current active balance of the protocol and divides by the premium per second for the protocol   function secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {     uint256 premium = premiums[_protocol];     if (premium == 0) return 0;     return _activeBalance(_protocol) / premium;   } /// @notice View current active balance of covered protocol   /// @param _protocol Protocol identifier   /// @return Active balance   /// @dev Accrued debt is subtracted from the stored active balance   function activeBalance(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return _activeBalance(_protocol);   } // Helper function to calc the active balance of a protocol at current time   function _activeBalance(bytes32 _protocol) internal view returns (uint256) {     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     uint256 balance = activeBalances[_protocol];     // The debt should never be higher than the balance (only happens if the arbitrages fail)     if (debt &gt; balance) return 0;     return balance - debt;   } //   // State methods   // /// @notice Helps set the premium per second for an individual protocol   /// @param protocol Protocol identifier   /// @param _premium New premium per second   /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function   function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)     internal     returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)   {     // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers     // Also updates the last accounted timestamp for this protocol     // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings     // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol     nonStakerPercentage = _settleProtocolDebt(_protocol);     // Stores the old premium before it gets updated     oldPremiumPerSecond = premiums[_protocol]; if (oldPremiumPerSecond != _premium) {   // Sets the protocol's premium per second to the new value   premiums_[_protocol] = _premium;   emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium); } // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point // Where arbs would no longer be incentivized to remove the protocol // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems if (_premium != 0 &amp;&amp; _secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_OF_COVERAGE) {   revert InsufficientBalance(_protocol); }  } /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second   /// @param _protocol Protocol identifier   /// @param _premium New premium per second   function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {     // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings     (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(       _protocol,       _premium     );     // Settling the total amount of premiums owed to stakers before a new premium per second gets set     _settleTotalDebt();     // This calculates the new global premium per second that gets paid to stakers     // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function     allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(       oldPremiumPerSecond,       _premium,       nonStakerPercentage,       nonStakerPercentage,       allPremiumsPerSecToStakers     );   } // Internal function to set a new protocolAgent for a specific protocol   // oldAgent is only included as part of emitting an event   function _setProtocolAgent(     bytes32 _protocol,     address _oldAgent,     address _protocolAgent   ) internal {     protocolAgent[_protocol] = _protocolAgent;     emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);   } // Subtracts the accrued debt from a protocol's active balance   // Credits the amount that can be claimed by nonstakers for this protocol   // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings   // Most of this function is dealing with an edge case related to a protocol not being removed by arbs   function settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {     // This calcs the accrued debt of the protocol since it was last updated     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     // This pulls the percentage that is sent to nonstakers     _nonStakerPercentage = nonStakersPercentage[_protocol];     // In case the protocol has accrued debt, this code block will ensure the debt is settled properly     if (debt != 0) {       // Pulls the stored active balance of the protocol       uint256 balance = activeBalances[_protocol];       // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance       // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point       // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage       // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up       if (debt &gt; balance) {         // This error amount represents the magnitude of the mistake         uint256 error = debt - balance;         // Gets the latest value of claimable premiums for stakers         _settleTotalDebt();         // @note to production, set premium first to zero before solving accounting issue.         // otherwise the accounting error keeps increasing         uint256 lastClaimablePremiumsForStakers = lastClaimablePremiumsForStakers;     // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%     uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /       HUNDRED_PERCENT;      // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short     uint256 insufficientTokens;      // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally     // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error     // This first line can be true if claimPremiumsForStakers() has been called and     // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be &gt;0 still     if (claimablePremiumError &gt; lastClaimablePremiumsForStakers_) {       insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;       lastClaimablePremiumsForStakers = 0;     } else {       // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums       // By the amount that was added in error (error) and insufficientTokens = 0       lastClaimablePremiumsForStakers =         lastClaimablePremiumsForStakers_ -         claimablePremiumError;     }      // If two events are thrown, the values need to be summed up for the actual state.     // This means an error of this type will continue until it is handled     emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);     // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case     debt = balance;   }   // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance   activeBalances[_protocol] = balance - debt;   // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol   nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT; } // Updates the last accounted timestamp for this protocol lastAccountedEachProtocol[_protocol] = block.timestamp;  } // Multiplies the total premium per second * number of seconds since the last global accounting update   // And adds it to the total claimable amount for stakers   function _settleTotalDebt() internal {     lastClaimablePremiumsForStakers +=       (block.timestamp - lastAccountedGlobal) *       allPremiumsPerSecToStakers;     lastAccountedGlobal = block.timestamp;   } // Calculates the global premium per second for stakers   // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers   // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones   function _calcGlobalPremiumPerSecForStakers(     uint256 _premiumOld,     uint256 _premiumNew,     uint256 _nonStakerPercentageOld,     uint256 _nonStakerPercentageNew,     uint256 _inMemAllPremiumsPerSecToStakers   ) internal pure returns (uint256) {     return       _inMemAllPremiumsPerSecToStakers +       ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /       HUNDRED_PERCENT -       ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /       HUNDRED_PERCENT;   } // Helper function to remove and clean up a protocol from Sherlock   // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made   function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {     // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol     _setSingleAndGlobalProtocolPremium(_protocol, 0); // Grabs the protocol's active balance uint256 balance = activeBalances[_protocol];  // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent if (balance != 0) {   delete activeBalances[_protocol];   token.safeTransfer(_agent, balance);    emit ProtocolBalanceWithdrawn(_protocol, balance); }  // Sets the protocol agent to zero address (as part of clean up) _setProtocolAgent(_protocol, _agent, address(0));  // Cleans up other mappings for this protocol delete nonStakersPercentage[_protocol]; delete lastAccountedEachProtocol[_protocol]; // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above  // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;  // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked removedProtocolAgent[_protocol] = _agent;  emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0)); emit ProtocolRemoved(_protocol);  } /// @notice Sets the minimum active balance before an arb can remove a protocol   /// @param _minActiveBalance Minimum balance needed (in USDC)   /// @dev Only gov   function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {     // New value cannot be the same as current value     if (minActiveBalance == _minActiveBalance) revert InvalidArgument();     // Can't set a value that is too high to be reasonable     if (_minActiveBalance &gt;= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions(); emit MinBalance(minActiveBalance, _minActiveBalance); minActiveBalance = _minActiveBalance;  } // This function allows the nonstakers role to claim tokens owed to them by a specific protocol   /// @notice Choose an _amount of tokens that nonstakers (_receiver address) will receive from _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens   /// @param _receiver Address to receive tokens   /// @dev Only callable by nonstakers role   function nonStakersClaim(     bytes32 _protocol,     uint256 _amount,     address _receiver   ) external override whenNotPaused {     if (_protocol == bytes32(0)) revert ZeroArgument();     if (_amount == uint256(0)) revert ZeroArgument();     if (_receiver == address(0)) revert ZeroArgument();     // Only the nonstakers role (multisig or contract) can pull the funds     if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized(); // Call can't be executed on protocol that is removed if (protocolAgent_[_protocol] != address(0)) {   // Updates the amount that nonstakers can claim from this protocol   _settleProtocolDebt(_protocol); }  // Sets balance to the amount that is claimable by nonstakers for this specific protocol uint256 balance = nonStakersClaimableByProtocol[_protocol]; // If the amount requested is more than what's owed to nonstakers, revert if (_amount &gt; balance) revert InsufficientBalance(_protocol);  // Sets the claimable amount to whatever is left over after this amount is pulled nonStakersClaimableByProtocol[_protocol] = balance - _amount; // Transfers the amount requested to the `_receiver` address token.safeTransfer(_receiver, _amount);  } // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)   /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address   /// @dev Callable by everyone   /// @dev Funds will be transferred to Sherlock core contract   function claimPremiumsForStakers() external override whenNotPaused {     // Gets address of core Sherlock contract     address sherlock = address(sherlockCore);     // Revert if core Sherlock contract not initialized yet     if (sherlock == address(0)) revert InvalidConditions(); // claimablePremiums is different from _settleTotalDebt() because it does not change state // Retrieves current amount of all premiums that are owed to stakers uint256 amount = claimablePremiums();  // Transfers all the premiums owed to stakers to the Sherlock core contract if (amount != 0) {   // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out   lastClaimablePremiumsForStakers = 0;   lastAccountedGlobal = block.timestamp;   token.safeTransfer(sherlock, amount); }  } // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts   /// @param protocol Protocol identifier   /// @return current and previous are the current and previous coverage amounts for this protocol   // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)   function coverageAmounts(bytes32 _protocol)     external     view     override     returns (uint256 current, uint256 previous)   {     // Checks to see if the protocol has an active protocolAgent (protocol not removed)     // OR checks to see if the removed protocol is still within the claim window     // If so, gives the current and previous coverage, otherwise throws an error     if (       protocolAgent[_protocol] != address(0) ||       block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]     ) {       return (currentCoverage[_protocol], previousCoverage[_protocol]);     } revert ProtocolNotExists(_protocol);  } /// @notice Add a new protocol to Sherlock   /// @param protocol Protocol identifier   /// @param _protocolAgent Address able to submit a claim on behalf of the protocol   /// @param _coverage Hash referencing the active coverage agreement   /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 1018   /// @param _coverageAmount Max amount claimable by this protocol   /// @dev Adding a protocol allows the _protocolAgent to submit a claim   /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point   /// @dev _nonStakers is scaled by 1018   /// @dev Only callable by governance   function protocolAdd(     bytes32 _protocol,     address _protocolAgent,     bytes32 _coverage,     uint256 _nonStakers,     uint256 _coverageAmount   ) external override onlyOwner {     if (_protocol == bytes32(0)) revert ZeroArgument();     if (_protocolAgent == address(0)) revert ZeroArgument();     // Checks to make sure the protocol doesn't exist already     if (protocolAgent[_protocol] != address(0)) revert InvalidConditions(); // Updates the protocol agent and passes in the old agent which is 0 address in this case _setProtocolAgent(_protocol, address(0), _protocolAgent);  // Delete mappings that are potentially non default values // From previous time protocol was added/removed delete removedProtocolClaimDeadline[_protocol]; delete removedProtocolAgent[_protocol]; delete currentCoverage[_protocol]; delete previousCoverage[_protocol];  emit ProtocolAdded(_protocol);  // Most of the logic for actually adding a protocol in this function protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);  } /// @notice Update info regarding a protocol   /// @param _protocol Protocol identifier   /// @param _coverage Hash referencing the active coverage agreement   /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18   /// @param _coverageAmount Max amount claimable by this protocol   /// @dev Only callable by governance   /// @dev _nonStakers can be 0   function protocolUpdate(     bytes32 _protocol,     bytes32 _coverage,     uint256 _nonStakers,     uint256 _coverageAmount   ) public override onlyOwner {     if (_coverage == bytes32(0)) revert ZeroArgument();     if (_nonStakers &gt; HUNDRED_PERCENT) revert InvalidArgument();     if (_coverageAmount == uint256(0)) revert ZeroArgument(); // Checks to make sure the protocol has been assigned a protocol agent _verifyProtocolExists(_protocol);  // Subtracts the accrued debt from a protocol's active balance (if any) // Updates the amount that can be claimed by nonstakers _settleProtocolDebt(_protocol);  // Updates the global claimable amount for stakers _settleTotalDebt();  // Gets the premium per second for this protocol uint256 premium = premiums_[_protocol];  // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be) allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(   premium,   premium,   nonStakersPercentage[_protocol],   _nonStakers,   allPremiumsPerSecToStakers );  // Updates the stored value of percentage of premiums that go to nonstakers nonStakersPercentage[_protocol] = _nonStakers;  // Updates previous coverage and current coverage amounts previousCoverage[_protocol] = currentCoverage[_protocol]; currentCoverage[_protocol] = _coverageAmount;  emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);  } /// @notice Remove a protocol from coverage   /// @param _protocol Protocol identifier   /// @dev Before removing a protocol the premium must be 0   /// @dev Removing a protocol basically stops the _protocolAgent from being active (can still submit claims until claim deadline though)   /// @dev Pays off debt + sends remaining balance to protocol agent   /// @dev This call should be subject to a timelock   /// @dev Only callable by governance   function protocolRemove(bytes32 _protocol) external override onlyOwner {     // checks to make sure the protocol actually has a protocol agent     address agent = _verifyProtocolExists(_protocol); // Removes a protocol from Sherlock and cleans up its data // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made _forceRemoveProtocol(_protocol, agent);  } /// @notice Remove a protocol with insufficient active balance   /// @param _protocol Protocol identifier   // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function   function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {     address agent = _verifyProtocolExists(_protocol); // Gets the latest value of the active balance at this protocol _settleProtocolDebt(_protocol); // Sets latest value of active balance to remainingBalance variable uint256 remainingBalance = activeBalances[_protocol];  // This means the protocol still has adequate active balance and thus cannot be removed if (remainingBalance &gt;= minActiveBalance) revert InvalidConditions();  // Sets the protocol's active balance to 0 delete activeBalances[_protocol]; // Removes the protocol from coverage _forceRemoveProtocol(_protocol, agent);  if (remainingBalance != 0) {   // sends the remaining balance to msg.sender   token.safeTransfer(msg.sender, remainingBalance); } emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);  } /// @notice Calculate if arb is possible and what the reward would be   /// @param _protocol Protocol identifier   /// @return arbAmount Amount reward for arbing   /// @return able Indicator if arb call is even possible   /// @dev Doesn't subtract the current protocol debt from the active balance   function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)     internal     view     returns (uint256 arbAmount, bool able)   {     uint256 secondsLeft = _secondsOfCoverageLeft(_protocol); // If arb is not possible return false if (secondsLeft &gt;= MIN_SECONDS_OF_COVERAGE) return (0, false);  // This percentage scales over time // Reaches 100% on 0 seconds of coverage left uint256 percentageScaled = HUNDRED_PERCENT -   (secondsLeft * HUNDRED_PERCENT) /   MIN_SECONDS_OF_COVERAGE;  able = true; arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;  } /// @notice Removes a protocol with insufficent seconds of coverage left   /// @param _protocol Protocol identifier   // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second   function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {     // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings     address agent = _verifyProtocolExists(_protocol); // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance() // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance() // But when removing based on seconds of coverage left, the remainingBalance could still be quite large // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%) _settleProtocolDebt(_protocol); (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol); if (able == false) revert InvalidConditions();  if (arbAmount != 0) {   // subtracts the amount that will be paid to the arb from the active balance   activeBalances[_protocol] -= arbAmount; }  // Removes the protocol from coverage // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above _forceRemoveProtocol(_protocol, agent);  // Done after removing protocol to mitigate reentrency pattern // (In case token allows callback) if (arbAmount != 0) {   token.safeTransfer(msg.sender, arbAmount); } emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);  } /// @notice Set premium of _protocol to _premium   /// @param _protocol Protocol identifier   /// @param _premium Amount of premium _protocol pays per second   /// @dev The value 0 would mean inactive coverage   /// @dev Only callable by governance   function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {     // Checks to see if protocol has a protocol agent     _verifyProtocolExists(_protocol); // Updates individual protocol's premium and allPremiumsPerSecToStakers _setSingleAndGlobalProtocolPremium(_protocol, _premium);  } /// @notice Set premium of multiple protocols   /// @param _protocol Array of protocol identifiers   /// @param _premium Array of premium amounts protocols pay per second   /// @dev The value 0 would mean inactive coverage   /// @dev Only callable by governance   function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)     external     override     onlyOwner   {     // Checks to make sure there are an equal amount of entries in each array     if (_protocol.length != _premium.length) revert UnequalArrayLength();     if (_protocol.length == 0) revert InvalidArgument(); // Updates the global claimable amount for stakers _settleTotalDebt();  uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;  // Loops through the array of protocols and checks to make sure each has a protocol agent assigned for (uint256 i; i &lt; _protocol.length; i++) {   _verifyProtocolExists(_protocol[i]);    // Sets the protocol premium for that specific protocol   // Function returns the old premium and nonStakerPercentage for that specific protocol   (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(     _protocol[i],     _premium[i]   );    // Calculates the new global premium which adds up all premiums paid by all protocols   allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(     oldPremiumPerSecond,     _premium[i],     nonStakerPercentage,     nonStakerPercentage,     allPremiumsPerSecToStakers_   ); }  // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;  } // This is how protocols pay for coverage by increasing their active balance   /// @notice Deposits _amount of token to the active balance of _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens to deposit   /// @dev Approval should be made before calling   function depositToActiveBalance(bytes32 _protocol, uint256 _amount)     external     override     whenNotPaused   {     if (_amount == uint256(0)) revert ZeroArgument();     _verifyProtocolExists(_protocol); // Transfers _amount to this contract token.safeTransferFrom(msg.sender, address(this), _amount); // Increases the active balance of the protocol by _amount activeBalances[_protocol] += _amount;  emit ProtocolBalanceDeposited(_protocol, _amount);  } // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)   // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)   /// @notice Withdraws _amount of token from the active balance of _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens to withdraw   /// @dev Only protocol agent is able to withdraw   /// @dev Balance can be withdrawn up until 7 days worth of active balance   function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)     external     override     whenNotPaused   {     if (_amount == uint256(0)) revert ZeroArgument();     // Only the protocol agent can call this function     if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized(); // Updates the active balance of the protocol _settleProtocolDebt(_protocol);  // Sets currentBalance to the active balance of the protocol uint256 currentBalance = activeBalances[_protocol]; // Reverts if trying to withdraw more than the active balance if (_amount &gt; currentBalance) revert InsufficientBalance(_protocol);  // Removes the _amount to be withdrawn from the active balance activeBalances[_protocol] = currentBalance - _amount; // Reverts if a protocol has less than 7 days worth of active balance left if (_secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);  // Transfers the amount to the msg.sender (protocol agent) token.safeTransfer(msg.sender, _amount); emit ProtocolBalanceWithdrawn(_protocol, _amount);  } /// @notice Transfer protocol agent role   /// @param _protocol Protocol identifier   /// @param _protocolAgent Account able to submit a claim on behalf of the protocol   /// @dev Only the active protocolAgent is able to transfer the role   function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)     external     override     whenNotPaused   {     if (_protocolAgent == address(0)) revert ZeroArgument();     // Can't set the new protocol agent to the caller address     if (msg.sender == _protocolAgent) revert InvalidArgument();     // Because the caller must be the current protocol agent     if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized(); // Sets the protocol agent to the new address _setProtocolAgent(_protocol, msg.sender, _protocolAgent);  } /// @notice Function used to check if this is the current active protocol manager   /// @return Boolean indicating it's active   /// @dev If inactive the owner can pull all ERC20s and ETH   /// @dev Will be checked by calling the sherlock contract   function isActive() public view returns (bool) {     return address(sherlockCore.sherlockProtocolManager()) == address(this);   } // Only contract owner can call this   // Sends all specified tokens in this contract to the receiver's address (as well as ETH)   function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {     if (_receiver == address(0)) revert ZeroArgument();     // This contract must NOT be the current assigned protocol manager contract     if (isActive()) revert InvalidConditions();     // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH     _sweep(_receiver, _extraTokens);   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-25-08 10:58:57 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import './Manager.sol';
import '../interfaces/managers/ISherlockProtocolManager.sol';

/// @title Sherlock core interface for protocols
/// @author Evert Kors
// This is the contract that manages covered protocols

contract SherlockProtocolManager is ISherlockProtocolManager, Manager {
  using SafeERC20 for IERC20;

  // Represents the token that protocols pay with (currently USDC)
  IERC20 public immutable token;

  // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed
  uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc

  // A removed protocol is still able to make a claim for this amount of time after its removal
  uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days;

  // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance
  uint256 public constant MIN_SECONDS_LEFT = 7 days;

  // Convenient for percentage calculations
  uint256 internal constant HUNDRED_PERCENT = 10**18;

  // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage
  // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying
  uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours;

  // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)
  mapping(bytes32 => address) internal protocolAgent_;

  // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)
  mapping(bytes32 => uint256) internal nonStakersPercentage;

  // The premium per second paid by each protocol is stored in this mapping
  mapping(bytes32 => uint256) internal premiums_;

  // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.
  // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not
  mapping(bytes32 => uint256) internal activeBalances;

  // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol
  mapping(bytes32 => uint256) internal lastAccountedEachProtocol;

  // The amount that can be claimed by nonstakers for each protocol
  // We need this value so we can track how much payment is coming from each protocol
  mapping(bytes32 => uint256) internal nonStakersClaimableByProtocol;

  // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)
  uint256 internal lastAccountedGlobal;

  // This is the total amount of premiums paid (per second) by all the covered protocols (added up)
  uint256 internal allPremiumsPerSecToStakers;

  // This is the amount that was claimable by stakers the last time the accounting was run
  // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date
  uint256 internal lastClaimablePremiumsForStakers;

  // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage
  // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)
  uint256 public override minActiveBalance;

  // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)
  mapping(bytes32 => uint256) internal removedProtocolClaimDeadline;

  // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)
  mapping(bytes32 => address) internal removedProtocolAgent;

  // Current amount of coverage (i.e. 20M USDC) for a protocol
  mapping(bytes32 => uint256) internal currentCoverage;

  // Previous amount of coverage for a protocol
  // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount
  mapping(bytes32 => uint256) internal previousCoverage;

  // Setting the token to USDC
  constructor(IERC20 _token) {
    if (address(_token) == address(0)) revert ZeroArgument();
    token = _token;
  }

  // Modifier used to ensure a protocol exists (has been instantiated and not removed)
  modifier protocolExists(bytes32 _protocol) {
    _verifyProtocolExists(_protocol);
    _;
  }

  /// @notice View current protocolAgent of `_protocol`
  /// @param _protocol Protocol identifier
  /// @return Address able to submit claims
  function protocolAgent(bytes32 _protocol) external view override returns (address) {
    address agent = protocolAgent_[_protocol];
    if (agent != address(0)) return agent;

    // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned
    // Note: Old protocol agent will never be address(0)
    if (block.timestamp <= removedProtocolClaimDeadline[_protocol]) {
      return removedProtocolAgent[_protocol];
    }

    // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned
    revert ProtocolNotExists(_protocol);
  }

  // Checks if the protocol exists, then returns the current premium per second being charged
  /// @notice View current premium of protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of premium `_protocol` pays per second
  function premium(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return premiums_[_protocol];
  }

  // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)
  // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)
  function _verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {
    _protocolAgent = protocolAgent_[_protocol];
    if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);
  }

  //
  // View methods
  //

  // Calcs the debt accrued by the protocol since it last had an accounting update
  // This is the amount that needs to be removed from a protocol's active balance
  function _calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {
    return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums_[_protocol];
  }

  /// @notice View the amount nonstakers can claim from this protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of tokens claimable by nonstakers
  /// @dev this reads from a storage variable + (now-lastsettled) * premiums
  // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]
  // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed
  function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {
    // Calcs the debt of a protocol since the last accounting update
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // Gets the active balance of the protocol
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) debt = balance;

    // Adds the incremental claimable amount owed to nonstakers to the total claimable amount
    return
      nonStakersClaimableByProtocol[_protocol] +
      (nonStakersPercentage[_protocol] * debt) /
      HUNDRED_PERCENT;
  }

  /// @notice View current amount of all premiums that are owed to stakers
  /// @return Premiums claimable
  /// @dev Will increase every block
  /// @dev base + (now - last_settled) * ps
  function claimablePremiums() public view override returns (uint256) {
    // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)
    return
      lastClaimablePremiumsForStakers +
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
  }

  /// @notice View seconds of coverage left for `_protocol` before it runs out of active balance
  /// @param _protocol Protocol identifier
  /// @return Seconds of coverage left
  function secondsOfCoverageLeft(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _secondsOfCoverageLeft(_protocol);
  }

  // Helper function to return seconds of coverage left for a protocol
  // Gets the current active balance of the protocol and divides by the premium per second for the protocol
  function _secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {
    uint256 premium = premiums_[_protocol];
    if (premium == 0) return 0;
    return _activeBalance(_protocol) / premium;
  }

  /// @notice View current active balance of covered protocol
  /// @param _protocol Protocol identifier
  /// @return Active balance
  /// @dev Accrued debt is subtracted from the stored active balance
  function activeBalance(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _activeBalance(_protocol);
  }

  // Helper function to calc the active balance of a protocol at current time
  function _activeBalance(bytes32 _protocol) internal view returns (uint256) {
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) return 0;
    return balance - debt;
  }

  //
  // State methods
  //

  /// @notice Helps set the premium per second for an individual protocol
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function
  function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)
    internal
    returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)
  {
    // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers
    // Also updates the last accounted timestamp for this protocol
    // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings
    // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol
    nonStakerPercentage = _settleProtocolDebt(_protocol);
    // Stores the old premium before it gets updated
    oldPremiumPerSecond = premiums_[_protocol];

    if (oldPremiumPerSecond != _premium) {
      // Sets the protocol's premium per second to the new value
      premiums_[_protocol] = _premium;
      emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium);
    }
    // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing
    // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes
    // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point
    // Where arbs would no longer be incentivized to remove the protocol
    // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems
    if (_premium != 0 && _secondsOfCoverageLeft(_protocol) < MIN_SECONDS_OF_COVERAGE) {
      revert InsufficientBalance(_protocol);
    }
  }

  /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {
    // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings
    (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
      _protocol,
      _premium
    );
    // Settling the total amount of premiums owed to stakers before a new premium per second gets set
    _settleTotalDebt();
    // This calculates the new global premium per second that gets paid to stakers
    // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      oldPremiumPerSecond,
      _premium,
      nonStakerPercentage,
      nonStakerPercentage,
      allPremiumsPerSecToStakers
    );
  }

  // Internal function to set a new protocolAgent for a specific protocol
  // _oldAgent is only included as part of emitting an event
  function _setProtocolAgent(
    bytes32 _protocol,
    address _oldAgent,
    address _protocolAgent
  ) internal {
    protocolAgent_[_protocol] = _protocolAgent;
    emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);
  }

  // Subtracts the accrued debt from a protocol's active balance
  // Credits the amount that can be claimed by nonstakers for this protocol
  // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings
  // Most of this function is dealing with an edge case related to a protocol not being removed by arbs
  function _settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {
    // This calcs the accrued debt of the protocol since it was last updated
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // This pulls the percentage that is sent to nonstakers
    _nonStakerPercentage = nonStakersPercentage[_protocol];
    // In case the protocol has accrued debt, this code block will ensure the debt is settled properly
    if (debt != 0) {
      // Pulls the stored active balance of the protocol
      uint256 balance = activeBalances[_protocol];
      // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance
      // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point
      // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage
      // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up
      if (debt > balance) {
        // This error amount represents the magnitude of the mistake
        uint256 error = debt - balance;
        // Gets the latest value of claimable premiums for stakers
        _settleTotalDebt();
        // @note to production, set premium first to zero before solving accounting issue.
        // otherwise the accounting error keeps increasing
        uint256 lastClaimablePremiumsForStakers_ = lastClaimablePremiumsForStakers;

        // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%
        uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /
          HUNDRED_PERCENT;

        // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short
        uint256 insufficientTokens;

        // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally
        // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error
        // This first line can be true if claimPremiumsForStakers() has been called and
        // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be >0 still
        if (claimablePremiumError > lastClaimablePremiumsForStakers_) {
          insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;
          lastClaimablePremiumsForStakers = 0;
        } else {
          // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums
          // By the amount that was added in error (error) and insufficientTokens = 0
          lastClaimablePremiumsForStakers =
            lastClaimablePremiumsForStakers_ -
            claimablePremiumError;
        }

        // If two events are thrown, the values need to be summed up for the actual state.
        // This means an error of this type will continue until it is handled
        emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);
        // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case
        debt = balance;
      }
      // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance
      activeBalances[_protocol] = balance - debt;
      // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol
      nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT;
    }
    // Updates the last accounted timestamp for this protocol
    lastAccountedEachProtocol[_protocol] = block.timestamp;
  }

  // Multiplies the total premium per second * number of seconds since the last global accounting update
  // And adds it to the total claimable amount for stakers
  function _settleTotalDebt() internal {
    lastClaimablePremiumsForStakers +=
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
    lastAccountedGlobal = block.timestamp;
  }

  // Calculates the global premium per second for stakers
  // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers
  // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones
  function _calcGlobalPremiumPerSecForStakers(
    uint256 _premiumOld,
    uint256 _premiumNew,
    uint256 _nonStakerPercentageOld,
    uint256 _nonStakerPercentageNew,
    uint256 _inMemAllPremiumsPerSecToStakers
  ) internal pure returns (uint256) {
    return
      _inMemAllPremiumsPerSecToStakers +
      ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /
      HUNDRED_PERCENT -
      ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /
      HUNDRED_PERCENT;
  }

  // Helper function to remove and clean up a protocol from Sherlock
  // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made
  function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {
    // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol
    _setSingleAndGlobalProtocolPremium(_protocol, 0);

    // Grabs the protocol's active balance
    uint256 balance = activeBalances[_protocol];

    // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent
    if (balance != 0) {
      delete activeBalances[_protocol];
      token.safeTransfer(_agent, balance);

      emit ProtocolBalanceWithdrawn(_protocol, balance);
    }

    // Sets the protocol agent to zero address (as part of clean up)
    _setProtocolAgent(_protocol, _agent, address(0));

    // Cleans up other mappings for this protocol
    delete nonStakersPercentage[_protocol];
    delete lastAccountedEachProtocol[_protocol];
    // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above

    // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol
    removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;

    // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed
    // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked
    removedProtocolAgent[_protocol] = _agent;

    emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0));
    emit ProtocolRemoved(_protocol);
  }

  /// @notice Sets the minimum active balance before an arb can remove a protocol
  /// @param _minActiveBalance Minimum balance needed (in USDC)
  /// @dev Only gov
  function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {
    // New value cannot be the same as current value
    if (minActiveBalance == _minActiveBalance) revert InvalidArgument();
    // Can't set a value that is too high to be reasonable
    if (_minActiveBalance >= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions();

    emit MinBalance(minActiveBalance, _minActiveBalance);
    minActiveBalance = _minActiveBalance;
  }

  // This function allows the nonstakers role to claim tokens owed to them by a specific protocol
  /// @notice Choose an `_amount` of tokens that nonstakers (`_receiver` address) will receive from `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens
  /// @param _receiver Address to receive tokens
  /// @dev Only callable by nonstakers role
  function nonStakersClaim(
    bytes32 _protocol,
    uint256 _amount,
    address _receiver
  ) external override whenNotPaused {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_amount == uint256(0)) revert ZeroArgument();
    if (_receiver == address(0)) revert ZeroArgument();
    // Only the nonstakers role (multisig or contract) can pull the funds
    if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized();

    // Call can't be executed on protocol that is removed
    if (protocolAgent_[_protocol] != address(0)) {
      // Updates the amount that nonstakers can claim from this protocol
      _settleProtocolDebt(_protocol);
    }

    // Sets balance to the amount that is claimable by nonstakers for this specific protocol
    uint256 balance = nonStakersClaimableByProtocol[_protocol];
    // If the amount requested is more than what's owed to nonstakers, revert
    if (_amount > balance) revert InsufficientBalance(_protocol);

    // Sets the claimable amount to whatever is left over after this amount is pulled
    nonStakersClaimableByProtocol[_protocol] = balance - _amount;
    // Transfers the amount requested to the `_receiver` address
    token.safeTransfer(_receiver, _amount);
  }

  // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)
  /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address
  /// @dev Callable by everyone
  /// @dev Funds will be transferred to Sherlock core contract
  function claimPremiumsForStakers() external override whenNotPaused {
    // Gets address of core Sherlock contract
    address sherlock = address(sherlockCore);
    // Revert if core Sherlock contract not initialized yet
    if (sherlock == address(0)) revert InvalidConditions();

    // claimablePremiums is different from _settleTotalDebt() because it does not change state
    // Retrieves current amount of all premiums that are owed to stakers
    uint256 amount = claimablePremiums();

    // Transfers all the premiums owed to stakers to the Sherlock core contract
    if (amount != 0) {
      // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out
      lastClaimablePremiumsForStakers = 0;
      lastAccountedGlobal = block.timestamp;
      token.safeTransfer(sherlock, amount);
    }
  }

  // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts
  /// @param _protocol Protocol identifier
  /// @return current and previous are the current and previous coverage amounts for this protocol
  // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)
  function coverageAmounts(bytes32 _protocol)
    external
    view
    override
    returns (uint256 current, uint256 previous)
  {
    // Checks to see if the protocol has an active protocolAgent (protocol not removed)
    // OR checks to see if the removed protocol is still within the claim window
    // If so, gives the current and previous coverage, otherwise throws an error
    if (
      protocolAgent_[_protocol] != address(0) ||
      block.timestamp <= removedProtocolClaimDeadline[_protocol]
    ) {
      return (currentCoverage[_protocol], previousCoverage[_protocol]);
    }

    revert ProtocolNotExists(_protocol);
  }

  /// @notice Add a new protocol to Sherlock
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Address able to submit a claim on behalf of the protocol
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Adding a protocol allows the `_protocolAgent` to submit a claim
  /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point
  /// @dev `_nonStakers` is scaled by 10**18
  /// @dev Only callable by governance
  function protocolAdd(
    bytes32 _protocol,
    address _protocolAgent,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) external override onlyOwner {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Checks to make sure the protocol doesn't exist already
    if (protocolAgent_[_protocol] != address(0)) revert InvalidConditions();

    // Updates the protocol agent and passes in the old agent which is 0 address in this case
    _setProtocolAgent(_protocol, address(0), _protocolAgent);

    // Delete mappings that are potentially non default values
    // From previous time protocol was added/removed
    delete removedProtocolClaimDeadline[_protocol];
    delete removedProtocolAgent[_protocol];
    delete currentCoverage[_protocol];
    delete previousCoverage[_protocol];

    emit ProtocolAdded(_protocol);

    // Most of the logic for actually adding a protocol in this function
    protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Update info regarding a protocol
  /// @param _protocol Protocol identifier
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Only callable by governance
  /// @dev `_nonStakers` can be 0
  function protocolUpdate(
    bytes32 _protocol,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) public override onlyOwner {
    if (_coverage == bytes32(0)) revert ZeroArgument();
    if (_nonStakers > HUNDRED_PERCENT) revert InvalidArgument();
    if (_coverageAmount == uint256(0)) revert ZeroArgument();

    // Checks to make sure the protocol has been assigned a protocol agent
    _verifyProtocolExists(_protocol);

    // Subtracts the accrued debt from a protocol's active balance (if any)
    // Updates the amount that can be claimed by nonstakers
    _settleProtocolDebt(_protocol);

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    // Gets the premium per second for this protocol
    uint256 premium = premiums_[_protocol];

    // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be)
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      premium,
      premium,
      nonStakersPercentage[_protocol],
      _nonStakers,
      allPremiumsPerSecToStakers
    );

    // Updates the stored value of percentage of premiums that go to nonstakers
    nonStakersPercentage[_protocol] = _nonStakers;

    // Updates previous coverage and current coverage amounts
    previousCoverage[_protocol] = currentCoverage[_protocol];
    currentCoverage[_protocol] = _coverageAmount;

    emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Remove a protocol from coverage
  /// @param _protocol Protocol identifier
  /// @dev Before removing a protocol the premium must be 0
  /// @dev Removing a protocol basically stops the `_protocolAgent` from being active (can still submit claims until claim deadline though)
  /// @dev Pays off debt + sends remaining balance to protocol agent
  /// @dev This call should be subject to a timelock
  /// @dev Only callable by governance
  function protocolRemove(bytes32 _protocol) external override onlyOwner {
    // checks to make sure the protocol actually has a protocol agent
    address agent = _verifyProtocolExists(_protocol);

    // Removes a protocol from Sherlock and cleans up its data
    // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made
    _forceRemoveProtocol(_protocol, agent);
  }

  /// @notice Remove a protocol with insufficient active balance
  /// @param _protocol Protocol identifier
  // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function
  function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {
    address agent = _verifyProtocolExists(_protocol);

    // Gets the latest value of the active balance at this protocol
    _settleProtocolDebt(_protocol);
    // Sets latest value of active balance to remainingBalance variable
    uint256 remainingBalance = activeBalances[_protocol];

    // This means the protocol still has adequate active balance and thus cannot be removed
    if (remainingBalance >= minActiveBalance) revert InvalidConditions();

    // Sets the protocol's active balance to 0
    delete activeBalances[_protocol];
    // Removes the protocol from coverage
    _forceRemoveProtocol(_protocol, agent);

    if (remainingBalance != 0) {
      // sends the remaining balance to msg.sender
      token.safeTransfer(msg.sender, remainingBalance);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);
  }

  /// @notice Calculate if arb is possible and what the reward would be
  /// @param _protocol Protocol identifier
  /// @return arbAmount Amount reward for arbing
  /// @return able Indicator if arb call is even possible
  /// @dev Doesn't subtract the current protocol debt from the active balance
  function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)
    internal
    view
    returns (uint256 arbAmount, bool able)
  {
    uint256 secondsLeft = _secondsOfCoverageLeft(_protocol);

    // If arb is not possible return false
    if (secondsLeft >= MIN_SECONDS_OF_COVERAGE) return (0, false);

    // This percentage scales over time
    // Reaches 100% on 0 seconds of coverage left
    uint256 percentageScaled = HUNDRED_PERCENT -
      (secondsLeft * HUNDRED_PERCENT) /
      MIN_SECONDS_OF_COVERAGE;

    able = true;
    arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;
  }

  /// @notice Removes a protocol with insufficent seconds of coverage left
  /// @param _protocol Protocol identifier
  // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second
  function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {
    // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings
    address agent = _verifyProtocolExists(_protocol);

    // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance()
    // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance()
    // But when removing based on seconds of coverage left, the remainingBalance could still be quite large
    // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance
    // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%)
    _settleProtocolDebt(_protocol);
    (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol);
    if (able == false) revert InvalidConditions();

    if (arbAmount != 0) {
      // subtracts the amount that will be paid to the arb from the active balance
      activeBalances[_protocol] -= arbAmount;
    }

    // Removes the protocol from coverage
    // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above
    _forceRemoveProtocol(_protocol, agent);

    // Done after removing protocol to mitigate reentrency pattern
    // (In case token allows callback)
    if (arbAmount != 0) {
      token.safeTransfer(msg.sender, arbAmount);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);
  }

  /// @notice Set premium of `_protocol` to `_premium`
  /// @param _protocol Protocol identifier
  /// @param _premium Amount of premium `_protocol` pays per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {
    // Checks to see if protocol has a protocol agent
    _verifyProtocolExists(_protocol);

    // Updates individual protocol's premium and allPremiumsPerSecToStakers
    _setSingleAndGlobalProtocolPremium(_protocol, _premium);
  }

  /// @notice Set premium of multiple protocols
  /// @param _protocol Array of protocol identifiers
  /// @param _premium Array of premium amounts protocols pay per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)
    external
    override
    onlyOwner
  {
    // Checks to make sure there are an equal amount of entries in each array
    if (_protocol.length != _premium.length) revert UnequalArrayLength();
    if (_protocol.length == 0) revert InvalidArgument();

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;

    // Loops through the array of protocols and checks to make sure each has a protocol agent assigned
    for (uint256 i; i < _protocol.length; i++) {
      _verifyProtocolExists(_protocol[i]);

      // Sets the protocol premium for that specific protocol
      // Function returns the old premium and nonStakerPercentage for that specific protocol
      (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
        _protocol[i],
        _premium[i]
      );

      // Calculates the new global premium which adds up all premiums paid by all protocols
      allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(
        oldPremiumPerSecond,
        _premium[i],
        nonStakerPercentage,
        nonStakerPercentage,
        allPremiumsPerSecToStakers_
      );
    }

    // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value
    allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;
  }

  // This is how protocols pay for coverage by increasing their active balance
  /// @notice Deposits `_amount` of token to the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to deposit
  /// @dev Approval should be made before calling
  function depositToActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    _verifyProtocolExists(_protocol);

    // Transfers _amount to this contract
    token.safeTransferFrom(msg.sender, address(this), _amount);
    // Increases the active balance of the protocol by _amount
    activeBalances[_protocol] += _amount;

    emit ProtocolBalanceDeposited(_protocol, _amount);
  }

  // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)
  // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)
  /// @notice Withdraws `_amount` of token from the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to withdraw
  /// @dev Only protocol agent is able to withdraw
  /// @dev Balance can be withdrawn up until 7 days worth of active balance
  function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    // Only the protocol agent can call this function
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Updates the active balance of the protocol
    _settleProtocolDebt(_protocol);

    // Sets currentBalance to the active balance of the protocol
    uint256 currentBalance = activeBalances[_protocol];
    // Reverts if trying to withdraw more than the active balance
    if (_amount > currentBalance) revert InsufficientBalance(_protocol);

    // Removes the _amount to be withdrawn from the active balance
    activeBalances[_protocol] = currentBalance - _amount;
    // Reverts if a protocol has less than 7 days worth of active balance left
    if (_secondsOfCoverageLeft(_protocol) < MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);

    // Transfers the amount to the msg.sender (protocol agent)
    token.safeTransfer(msg.sender, _amount);
    emit ProtocolBalanceWithdrawn(_protocol, _amount);
  }

  /// @notice Transfer protocol agent role
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Account able to submit a claim on behalf of the protocol
  /// @dev Only the active protocolAgent is able to transfer the role
  function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)
    external
    override
    whenNotPaused
  {
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Can't set the new protocol agent to the caller address
    if (msg.sender == _protocolAgent) revert InvalidArgument();
    // Because the caller must be the current protocol agent
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Sets the protocol agent to the new address
    _setProtocolAgent(_protocol, msg.sender, _protocolAgent);
  }

  /// @notice Function used to check if this is the current active protocol manager
  /// @return Boolean indicating it's active
  /// @dev If inactive the owner can pull all ERC20s and ETH
  /// @dev Will be checked by calling the sherlock contract
  function isActive() public view returns (bool) {
    return address(sherlockCore.sherlockProtocolManager()) == address(this);
  }

  // Only contract owner can call this
  // Sends all specified tokens in this contract to the receiver's address (as well as ETH)
  function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {
    if (_receiver == address(0)) revert ZeroArgument();
    // This contract must NOT be the current assigned protocol manager contract
    if (isActive()) revert InvalidConditions();
    // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH
    _sweep(_receiver, _extraTokens);
  }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import './Manager.sol';
import '../interfaces/managers/ISherlockProtocolManager.sol';

/// @title Sherlock core interface for protocols
/// @author Evert Kors
// This is the contract that manages covered protocols

contract SherlockProtocolManager is ISherlockProtocolManager, Manager {
  using SafeERC20 for IERC20;

  // Represents the token that protocols pay with (currently USDC)
  IERC20 public immutable token;

  // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed
  uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc

  // A removed protocol is still able to make a claim for this amount of time after its removal
  uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days;

  // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance
  uint256 public constant MIN_SECONDS_LEFT = 7 days;

  // Convenient for percentage calculations
  uint256 internal constant HUNDRED_PERCENT = 10**18;

  // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage
  // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying
  uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours;

  // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)
  mapping(bytes32 => address) internal protocolAgent_;

  // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)
  mapping(bytes32 => uint256) internal nonStakersPercentage;

  // The premium per second paid by each protocol is stored in this mapping
  mapping(bytes32 => uint256) internal premiums_;

  // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.
  // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not
  mapping(bytes32 => uint256) internal activeBalances;

  // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol
  mapping(bytes32 => uint256) internal lastAccountedEachProtocol;

  // The amount that can be claimed by nonstakers for each protocol
  // We need this value so we can track how much payment is coming from each protocol
  mapping(bytes32 => uint256) internal nonStakersClaimableByProtocol;

  // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)
  uint256 internal lastAccountedGlobal;

  // This is the total amount of premiums paid (per second) by all the covered protocols (added up)
  uint256 internal allPremiumsPerSecToStakers;

  // This is the amount that was claimable by stakers the last time the accounting was run
  // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date
  uint256 internal lastClaimablePremiumsForStakers;

  // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage
  // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)
  uint256 public override minActiveBalance;

  // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)
  mapping(bytes32 => uint256) internal removedProtocolClaimDeadline;

  // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)
  mapping(bytes32 => address) internal removedProtocolAgent;

  // Current amount of coverage (i.e. 20M USDC) for a protocol
  mapping(bytes32 => uint256) internal currentCoverage;

  // Previous amount of coverage for a protocol
  // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount
  mapping(bytes32 => uint256) internal previousCoverage;

  // Setting the token to USDC
  constructor(IERC20 _token) {
    if (address(_token) == address(0)) revert ZeroArgument();
    token = _token;
  }

  // Modifier used to ensure a protocol exists (has been instantiated and not removed)
  modifier protocolExists(bytes32 _protocol) {
    _verifyProtocolExists(_protocol);
    _;
  }

  /// @notice View current protocolAgent of `_protocol`
  /// @param _protocol Protocol identifier
  /// @return Address able to submit claims
  function protocolAgent(bytes32 _protocol) external view override returns (address) {
    address agent = protocolAgent_[_protocol];
    if (agent != address(0)) return agent;

    // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned
    // Note: Old protocol agent will never be address(0)
    if (block.timestamp <= removedProtocolClaimDeadline[_protocol]) {
      return removedProtocolAgent[_protocol];
    }

    // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned
    revert ProtocolNotExists(_protocol);
  }

  // Checks if the protocol exists, then returns the current premium per second being charged
  /// @notice View current premium of protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of premium `_protocol` pays per second
  function premium(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return premiums_[_protocol];
  }

  // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)
  // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)
  function _verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {
    _protocolAgent = protocolAgent_[_protocol];
    if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);
  }

  //
  // View methods
  //

  // Calcs the debt accrued by the protocol since it last had an accounting update
  // This is the amount that needs to be removed from a protocol's active balance
  function _calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {
    return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums_[_protocol];
  }

  /// @notice View the amount nonstakers can claim from this protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of tokens claimable by nonstakers
  /// @dev this reads from a storage variable + (now-lastsettled) * premiums
  // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]
  // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed
  function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {
    // Calcs the debt of a protocol since the last accounting update
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // Gets the active balance of the protocol
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) debt = balance;

    // Adds the incremental claimable amount owed to nonstakers to the total claimable amount
    return
      nonStakersClaimableByProtocol[_protocol] +
      (nonStakersPercentage[_protocol] * debt) /
      HUNDRED_PERCENT;
  }

  /// @notice View current amount of all premiums that are owed to stakers
  /// @return Premiums claimable
  /// @dev Will increase every block
  /// @dev base + (now - last_settled) * ps
  function claimablePremiums() public view override returns (uint256) {
    // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)
    return
      lastClaimablePremiumsForStakers +
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
  }

  /// @notice View seconds of coverage left for `_protocol` before it runs out of active balance
  /// @param _protocol Protocol identifier
  /// @return Seconds of coverage left
  function secondsOfCoverageLeft(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _secondsOfCoverageLeft(_protocol);
  }

  // Helper function to return seconds of coverage left for a protocol
  // Gets the current active balance of the protocol and divides by the premium per second for the protocol
  function _secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {
    uint256 premium = premiums_[_protocol];
    if (premium == 0) return 0;
    return _activeBalance(_protocol) / premium;
  }

  /// @notice View current active balance of covered protocol
  /// @param _protocol Protocol identifier
  /// @return Active balance
  /// @dev Accrued debt is subtracted from the stored active balance
  function activeBalance(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _activeBalance(_protocol);
  }

  // Helper function to calc the active balance of a protocol at current time
  function _activeBalance(bytes32 _protocol) internal view returns (uint256) {
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) return 0;
    return balance - debt;
  }

  //
  // State methods
  //

  /// @notice Helps set the premium per second for an individual protocol
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function
  function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)
    internal
    returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)
  {
    // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers
    // Also updates the last accounted timestamp for this protocol
    // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings
    // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol
    nonStakerPercentage = _settleProtocolDebt(_protocol);
    // Stores the old premium before it gets updated
    oldPremiumPerSecond = premiums_[_protocol];

    if (oldPremiumPerSecond != _premium) {
      // Sets the protocol's premium per second to the new value
      premiums_[_protocol] = _premium;
      emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium);
    }
    // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing
    // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes
    // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point
    // Where arbs would no longer be incentivized to remove the protocol
    // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems
    if (_premium != 0 && _secondsOfCoverageLeft(_protocol) < MIN_SECONDS_OF_COVERAGE) {
      revert InsufficientBalance(_protocol);
    }
  }

  /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {
    // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings
    (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
      _protocol,
      _premium
    );
    // Settling the total amount of premiums owed to stakers before a new premium per second gets set
    _settleTotalDebt();
    // This calculates the new global premium per second that gets paid to stakers
    // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      oldPremiumPerSecond,
      _premium,
      nonStakerPercentage,
      nonStakerPercentage,
      allPremiumsPerSecToStakers
    );
  }

  // Internal function to set a new protocolAgent for a specific protocol
  // _oldAgent is only included as part of emitting an event
  function _setProtocolAgent(
    bytes32 _protocol,
    address _oldAgent,
    address _protocolAgent
  ) internal {
    protocolAgent_[_protocol] = _protocolAgent;
    emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);
  }

  // Subtracts the accrued debt from a protocol's active balance
  // Credits the amount that can be claimed by nonstakers for this protocol
  // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings
  // Most of this function is dealing with an edge case related to a protocol not being removed by arbs
  function _settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {
    // This calcs the accrued debt of the protocol since it was last updated
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // This pulls the percentage that is sent to nonstakers
    _nonStakerPercentage = nonStakersPercentage[_protocol];
    // In case the protocol has accrued debt, this code block will ensure the debt is settled properly
    if (debt != 0) {
      // Pulls the stored active balance of the protocol
      uint256 balance = activeBalances[_protocol];
      // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance
      // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point
      // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage
      // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up
      if (debt > balance) {
        // This error amount represents the magnitude of the mistake
        uint256 error = debt - balance;
        // Gets the latest value of claimable premiums for stakers
        _settleTotalDebt();
        // @note to production, set premium first to zero before solving accounting issue.
        // otherwise the accounting error keeps increasing
        uint256 lastClaimablePremiumsForStakers_ = lastClaimablePremiumsForStakers;

        // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%
        uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /
          HUNDRED_PERCENT;

        // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short
        uint256 insufficientTokens;

        // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally
        // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error
        // This first line can be true if claimPremiumsForStakers() has been called and
        // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be >0 still
        if (claimablePremiumError > lastClaimablePremiumsForStakers_) {
          insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;
          lastClaimablePremiumsForStakers = 0;
        } else {
          // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums
          // By the amount that was added in error (error) and insufficientTokens = 0
          lastClaimablePremiumsForStakers =
            lastClaimablePremiumsForStakers_ -
            claimablePremiumError;
        }

        // If two events are thrown, the values need to be summed up for the actual state.
        // This means an error of this type will continue until it is handled
        emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);
        // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case
        debt = balance;
      }
      // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance
      activeBalances[_protocol] = balance - debt;
      // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol
      nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT;
    }
    // Updates the last accounted timestamp for this protocol
    lastAccountedEachProtocol[_protocol] = block.timestamp;
  }

  // Multiplies the total premium per second * number of seconds since the last global accounting update
  // And adds it to the total claimable amount for stakers
  function _settleTotalDebt() internal {
    lastClaimablePremiumsForStakers +=
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
    lastAccountedGlobal = block.timestamp;
  }

  // Calculates the global premium per second for stakers
  // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers
  // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones
  function _calcGlobalPremiumPerSecForStakers(
    uint256 _premiumOld,
    uint256 _premiumNew,
    uint256 _nonStakerPercentageOld,
    uint256 _nonStakerPercentageNew,
    uint256 _inMemAllPremiumsPerSecToStakers
  ) internal pure returns (uint256) {
    return
      _inMemAllPremiumsPerSecToStakers +
      ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /
      HUNDRED_PERCENT -
      ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /
      HUNDRED_PERCENT;
  }

  // Helper function to remove and clean up a protocol from Sherlock
  // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made
  function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {
    // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol
    _setSingleAndGlobalProtocolPremium(_protocol, 0);

    // Grabs the protocol's active balance
    uint256 balance = activeBalances[_protocol];

    // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent
    if (balance != 0) {
      delete activeBalances[_protocol];
      token.safeTransfer(_agent, balance);

      emit ProtocolBalanceWithdrawn(_protocol, balance);
    }

    // Sets the protocol agent to zero address (as part of clean up)
    _setProtocolAgent(_protocol, _agent, address(0));

    // Cleans up other mappings for this protocol
    delete nonStakersPercentage[_protocol];
    delete lastAccountedEachProtocol[_protocol];
    // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above

    // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol
    removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;

    // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed
    // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked
    removedProtocolAgent[_protocol] = _agent;

    emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0));
    emit ProtocolRemoved(_protocol);
  }

  /// @notice Sets the minimum active balance before an arb can remove a protocol
  /// @param _minActiveBalance Minimum balance needed (in USDC)
  /// @dev Only gov
  function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {
    // New value cannot be the same as current value
    if (minActiveBalance == _minActiveBalance) revert InvalidArgument();
    // Can't set a value that is too high to be reasonable
    if (_minActiveBalance >= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions();

    emit MinBalance(minActiveBalance, _minActiveBalance);
    minActiveBalance = _minActiveBalance;
  }

  // This function allows the nonstakers role to claim tokens owed to them by a specific protocol
  /// @notice Choose an `_amount` of tokens that nonstakers (`_receiver` address) will receive from `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens
  /// @param _receiver Address to receive tokens
  /// @dev Only callable by nonstakers role
  function nonStakersClaim(
    bytes32 _protocol,
    uint256 _amount,
    address _receiver
  ) external override whenNotPaused {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_amount == uint256(0)) revert ZeroArgument();
    if (_receiver == address(0)) revert ZeroArgument();
    // Only the nonstakers role (multisig or contract) can pull the funds
    if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized();

    // Call can't be executed on protocol that is removed
    if (protocolAgent_[_protocol] != address(0)) {
      // Updates the amount that nonstakers can claim from this protocol
      _settleProtocolDebt(_protocol);
    }

    // Sets balance to the amount that is claimable by nonstakers for this specific protocol
    uint256 balance = nonStakersClaimableByProtocol[_protocol];
    // If the amount requested is more than what's owed to nonstakers, revert
    if (_amount > balance) revert InsufficientBalance(_protocol);

    // Sets the claimable amount to whatever is left over after this amount is pulled
    nonStakersClaimableByProtocol[_protocol] = balance - _amount;
    // Transfers the amount requested to the `_receiver` address
    token.safeTransfer(_receiver, _amount);
  }

  // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)
  /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address
  /// @dev Callable by everyone
  /// @dev Funds will be transferred to Sherlock core contract
  function claimPremiumsForStakers() external override whenNotPaused {
    // Gets address of core Sherlock contract
    address sherlock = address(sherlockCore);
    // Revert if core Sherlock contract not initialized yet
    if (sherlock == address(0)) revert InvalidConditions();

    // claimablePremiums is different from _settleTotalDebt() because it does not change state
    // Retrieves current amount of all premiums that are owed to stakers
    uint256 amount = claimablePremiums();

    // Transfers all the premiums owed to stakers to the Sherlock core contract
    if (amount != 0) {
      // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out
      lastClaimablePremiumsForStakers = 0;
      lastAccountedGlobal = block.timestamp;
      token.safeTransfer(sherlock, amount);
    }
  }

  // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts
  /// @param _protocol Protocol identifier
  /// @return current and previous are the current and previous coverage amounts for this protocol
  // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)
  function coverageAmounts(bytes32 _protocol)
    external
    view
    override
    returns (uint256 current, uint256 previous)
  {
    // Checks to see if the protocol has an active protocolAgent (protocol not removed)
    // OR checks to see if the removed protocol is still within the claim window
    // If so, gives the current and previous coverage, otherwise throws an error
    if (
      protocolAgent_[_protocol] != address(0) ||
      block.timestamp <= removedProtocolClaimDeadline[_protocol]
    ) {
      return (currentCoverage[_protocol], previousCoverage[_protocol]);
    }

    revert ProtocolNotExists(_protocol);
  }

  /// @notice Add a new protocol to Sherlock
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Address able to submit a claim on behalf of the protocol
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Adding a protocol allows the `_protocolAgent` to submit a claim
  /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point
  /// @dev `_nonStakers` is scaled by 10**18
  /// @dev Only callable by governance
  function protocolAdd(
    bytes32 _protocol,
    address _protocolAgent,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) external override onlyOwner {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Checks to make sure the protocol doesn't exist already
    if (protocolAgent_[_protocol] != address(0)) revert InvalidConditions();

    // Updates the protocol agent and passes in the old agent which is 0 address in this case
    _setProtocolAgent(_protocol, address(0), _protocolAgent);

    // Delete mappings that are potentially non default values
    // From previous time protocol was added/removed
    delete removedProtocolClaimDeadline[_protocol];
    delete removedProtocolAgent[_protocol];
    delete currentCoverage[_protocol];
    delete previousCoverage[_protocol];

    emit ProtocolAdded(_protocol);

    // Most of the logic for actually adding a protocol in this function
    protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Update info regarding a protocol
  /// @param _protocol Protocol identifier
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Only callable by governance
  /// @dev `_nonStakers` can be 0
  function protocolUpdate(
    bytes32 _protocol,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) public override onlyOwner {
    if (_coverage == bytes32(0)) revert ZeroArgument();
    if (_nonStakers > HUNDRED_PERCENT) revert InvalidArgument();
    if (_coverageAmount == uint256(0)) revert ZeroArgument();

    // Checks to make sure the protocol has been assigned a protocol agent
    _verifyProtocolExists(_protocol);

    // Subtracts the accrued debt from a protocol's active balance (if any)
    // Updates the amount that can be claimed by nonstakers
    _settleProtocolDebt(_protocol);

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    // Gets the premium per second for this protocol
    uint256 premium = premiums_[_protocol];

    // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be)
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      premium,
      premium,
      nonStakersPercentage[_protocol],
      _nonStakers,
      allPremiumsPerSecToStakers
    );

    // Updates the stored value of percentage of premiums that go to nonstakers
    nonStakersPercentage[_protocol] = _nonStakers;

    // Updates previous coverage and current coverage amounts
    previousCoverage[_protocol] = currentCoverage[_protocol];
    currentCoverage[_protocol] = _coverageAmount;

    emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Remove a protocol from coverage
  /// @param _protocol Protocol identifier
  /// @dev Before removing a protocol the premium must be 0
  /// @dev Removing a protocol basically stops the `_protocolAgent` from being active (can still submit claims until claim deadline though)
  /// @dev Pays off debt + sends remaining balance to protocol agent
  /// @dev This call should be subject to a timelock
  /// @dev Only callable by governance
  function protocolRemove(bytes32 _protocol) external override onlyOwner {
    // checks to make sure the protocol actually has a protocol agent
    address agent = _verifyProtocolExists(_protocol);

    // Removes a protocol from Sherlock and cleans up its data
    // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made
    _forceRemoveProtocol(_protocol, agent);
  }

  /// @notice Remove a protocol with insufficient active balance
  /// @param _protocol Protocol identifier
  // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function
  function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {
    address agent = _verifyProtocolExists(_protocol);

    // Gets the latest value of the active balance at this protocol
    _settleProtocolDebt(_protocol);
    // Sets latest value of active balance to remainingBalance variable
    uint256 remainingBalance = activeBalances[_protocol];

    // This means the protocol still has adequate active balance and thus cannot be removed
    if (remainingBalance >= minActiveBalance) revert InvalidConditions();

    // Sets the protocol's active balance to 0
    delete activeBalances[_protocol];
    // Removes the protocol from coverage
    _forceRemoveProtocol(_protocol, agent);

    if (remainingBalance != 0) {
      // sends the remaining balance to msg.sender
      token.safeTransfer(msg.sender, remainingBalance);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);
  }

  /// @notice Calculate if arb is possible and what the reward would be
  /// @param _protocol Protocol identifier
  /// @return arbAmount Amount reward for arbing
  /// @return able Indicator if arb call is even possible
  /// @dev Doesn't subtract the current protocol debt from the active balance
  function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)
    internal
    view
    returns (uint256 arbAmount, bool able)
  {
    uint256 secondsLeft = _secondsOfCoverageLeft(_protocol);

    // If arb is not possible return false
    if (secondsLeft >= MIN_SECONDS_OF_COVERAGE) return (0, false);

    // This percentage scales over time
    // Reaches 100% on 0 seconds of coverage left
    uint256 percentageScaled = HUNDRED_PERCENT -
      (secondsLeft * HUNDRED_PERCENT) /
      MIN_SECONDS_OF_COVERAGE;

    able = true;
    arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;
  }

  /// @notice Removes a protocol with insufficent seconds of coverage left
  /// @param _protocol Protocol identifier
  // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second
  function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {
    // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings
    address agent = _verifyProtocolExists(_protocol);

    // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance()
    // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance()
    // But when removing based on seconds of coverage left, the remainingBalance could still be quite large
    // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance
    // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%)
    _settleProtocolDebt(_protocol);
    (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol);
    if (able == false) revert InvalidConditions();

    if (arbAmount != 0) {
      // subtracts the amount that will be paid to the arb from the active balance
      activeBalances[_protocol] -= arbAmount;
    }

    // Removes the protocol from coverage
    // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above
    _forceRemoveProtocol(_protocol, agent);

    // Done after removing protocol to mitigate reentrency pattern
    // (In case token allows callback)
    if (arbAmount != 0) {
      token.safeTransfer(msg.sender, arbAmount);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);
  }

  /// @notice Set premium of `_protocol` to `_premium`
  /// @param _protocol Protocol identifier
  /// @param _premium Amount of premium `_protocol` pays per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {
    // Checks to see if protocol has a protocol agent
    _verifyProtocolExists(_protocol);

    // Updates individual protocol's premium and allPremiumsPerSecToStakers
    _setSingleAndGlobalProtocolPremium(_protocol, _premium);
  }

  /// @notice Set premium of multiple protocols
  /// @param _protocol Array of protocol identifiers
  /// @param _premium Array of premium amounts protocols pay per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)
    external
    override
    onlyOwner
  {
    // Checks to make sure there are an equal amount of entries in each array
    if (_protocol.length != _premium.length) revert UnequalArrayLength();
    if (_protocol.length == 0) revert InvalidArgument();

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;

    // Loops through the array of protocols and checks to make sure each has a protocol agent assigned
    for (uint256 i; i < _protocol.length; i++) {
      _verifyProtocolExists(_protocol[i]);

      // Sets the protocol premium for that specific protocol
      // Function returns the old premium and nonStakerPercentage for that specific protocol
      (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
        _protocol[i],
        _premium[i]
      );

      // Calculates the new global premium which adds up all premiums paid by all protocols
      allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(
        oldPremiumPerSecond,
        _premium[i],
        nonStakerPercentage,
        nonStakerPercentage,
        allPremiumsPerSecToStakers_
      );
    }

    // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value
    allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;
  }

  // This is how protocols pay for coverage by increasing their active balance
  /// @notice Deposits `_amount` of token to the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to deposit
  /// @dev Approval should be made before calling
  function depositToActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    _verifyProtocolExists(_protocol);

    // Transfers _amount to this contract
    token.safeTransferFrom(msg.sender, address(this), _amount);
    // Increases the active balance of the protocol by _amount
    activeBalances[_protocol] += _amount;

    emit ProtocolBalanceDeposited(_protocol, _amount);
  }

  // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)
  // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)
  /// @notice Withdraws `_amount` of token from the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to withdraw
  /// @dev Only protocol agent is able to withdraw
  /// @dev Balance can be withdrawn up until 7 days worth of active balance
  function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    // Only the protocol agent can call this function
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Updates the active balance of the protocol
    _settleProtocolDebt(_protocol);

    // Sets currentBalance to the active balance of the protocol
    uint256 currentBalance = activeBalances[_protocol];
    // Reverts if trying to withdraw more than the active balance
    if (_amount > currentBalance) revert InsufficientBalance(_protocol);

    // Removes the _amount to be withdrawn from the active balance
    activeBalances[_protocol] = currentBalance - _amount;
    // Reverts if a protocol has less than 7 days worth of active balance left
    if (_secondsOfCoverageLeft(_protocol) < MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);

    // Transfers the amount to the msg.sender (protocol agent)
    token.safeTransfer(msg.sender, _amount);
    emit ProtocolBalanceWithdrawn(_protocol, _amount);
  }

  /// @notice Transfer protocol agent role
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Account able to submit a claim on behalf of the protocol
  /// @dev Only the active protocolAgent is able to transfer the role
  function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)
    external
    override
    whenNotPaused
  {
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Can't set the new protocol agent to the caller address
    if (msg.sender == _protocolAgent) revert InvalidArgument();
    // Because the caller must be the current protocol agent
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Sets the protocol agent to the new address
    _setProtocolAgent(_protocol, msg.sender, _protocolAgent);
  }

  /// @notice Function used to check if this is the current active protocol manager
  /// @return Boolean indicating it's active
  /// @dev If inactive the owner can pull all ERC20s and ETH
  /// @dev Will be checked by calling the sherlock contract
  function isActive() public view returns (bool) {
    return address(sherlockCore.sherlockProtocolManager()) == address(this);
  }

  // Only contract owner can call this
  // Sends all specified tokens in this contract to the receiver's address (as well as ETH)
  function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {
    if (_receiver == address(0)) revert ZeroArgument();
    // This contract must NOT be the current assigned protocol manager contract
    if (isActive()) revert InvalidConditions();
    // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH
    _sweep(_receiver, _extraTokens);
  }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-25-08 10:58:59 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-25-08 10:58:59 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 18293
completion_tokens: 1
total_tokens: 18294
cost: $-1.000000


[2024-25-08 10:58:59 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import './Manager.sol';
import '../interfaces/managers/ISherlockProtocolManager.sol';

/// @title Sherlock core interface for protocols
/// @author Evert Kors
// This is the contract that manages covered protocols

contract SherlockProtocolManager is ISherlockProtocolManager, Manager {
  using SafeERC20 for IERC20;

  // Represents the token that protocols pay with (currently USDC)
  IERC20 public immutable token;

  // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed
  uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc

  // A removed protocol is still able to make a claim for this amount of time after its removal
  uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days;

  // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance
  uint256 public constant MIN_SECONDS_LEFT = 7 days;

  // Convenient for percentage calculations
  uint256 internal constant HUNDRED_PERCENT = 10**18;

  // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage
  // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying
  uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours;

  // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)
  mapping(bytes32 => address) internal protocolAgent_;

  // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)
  mapping(bytes32 => uint256) internal nonStakersPercentage;

  // The premium per second paid by each protocol is stored in this mapping
  mapping(bytes32 => uint256) internal premiums_;

  // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.
  // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not
  mapping(bytes32 => uint256) internal activeBalances;

  // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol
  mapping(bytes32 => uint256) internal lastAccountedEachProtocol;

  // The amount that can be claimed by nonstakers for each protocol
  // We need this value so we can track how much payment is coming from each protocol
  mapping(bytes32 => uint256) internal nonStakersClaimableByProtocol;

  // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)
  uint256 internal lastAccountedGlobal;

  // This is the total amount of premiums paid (per second) by all the covered protocols (added up)
  uint256 internal allPremiumsPerSecToStakers;

  // This is the amount that was claimable by stakers the last time the accounting was run
  // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date
  uint256 internal lastClaimablePremiumsForStakers;

  // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage
  // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)
  uint256 public override minActiveBalance;

  // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)
  mapping(bytes32 => uint256) internal removedProtocolClaimDeadline;

  // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)
  mapping(bytes32 => address) internal removedProtocolAgent;

  // Current amount of coverage (i.e. 20M USDC) for a protocol
  mapping(bytes32 => uint256) internal currentCoverage;

  // Previous amount of coverage for a protocol
  // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount
  mapping(bytes32 => uint256) internal previousCoverage;

  // Setting the token to USDC
  constructor(IERC20 _token) {
    if (address(_token) == address(0)) revert ZeroArgument();
    token = _token;
  }

  // Modifier used to ensure a protocol exists (has been instantiated and not removed)
  modifier protocolExists(bytes32 _protocol) {
    _verifyProtocolExists(_protocol);
    _;
  }

  /// @notice View current protocolAgent of `_protocol`
  /// @param _protocol Protocol identifier
  /// @return Address able to submit claims
  function protocolAgent(bytes32 _protocol) external view override returns (address) {
    address agent = protocolAgent_[_protocol];
    if (agent != address(0)) return agent;

    // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned
    // Note: Old protocol agent will never be address(0)
    if (block.timestamp <= removedProtocolClaimDeadline[_protocol]) {
      return removedProtocolAgent[_protocol];
    }

    // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned
    revert ProtocolNotExists(_protocol);
  }

  // Checks if the protocol exists, then returns the current premium per second being charged
  /// @notice View current premium of protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of premium `_protocol` pays per second
  function premium(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return premiums_[_protocol];
  }

  // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)
  // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)
  function _verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {
    _protocolAgent = protocolAgent_[_protocol];
    if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);
  }

  //
  // View methods
  //

  // Calcs the debt accrued by the protocol since it last had an accounting update
  // This is the amount that needs to be removed from a protocol's active balance
  function _calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {
    return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums_[_protocol];
  }

  /// @notice View the amount nonstakers can claim from this protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of tokens claimable by nonstakers
  /// @dev this reads from a storage variable + (now-lastsettled) * premiums
  // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]
  // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed
  function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {
    // Calcs the debt of a protocol since the last accounting update
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // Gets the active balance of the protocol
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) debt = balance;

    // Adds the incremental claimable amount owed to nonstakers to the total claimable amount
    return
      nonStakersClaimableByProtocol[_protocol] +
      (nonStakersPercentage[_protocol] * debt) /
      HUNDRED_PERCENT;
  }

  /// @notice View current amount of all premiums that are owed to stakers
  /// @return Premiums claimable
  /// @dev Will increase every block
  /// @dev base + (now - last_settled) * ps
  function claimablePremiums() public view override returns (uint256) {
    // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)
    return
      lastClaimablePremiumsForStakers +
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
  }

  /// @notice View seconds of coverage left for `_protocol` before it runs out of active balance
  /// @param _protocol Protocol identifier
  /// @return Seconds of coverage left
  function secondsOfCoverageLeft(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _secondsOfCoverageLeft(_protocol);
  }

  // Helper function to return seconds of coverage left for a protocol
  // Gets the current active balance of the protocol and divides by the premium per second for the protocol
  function _secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {
    uint256 premium = premiums_[_protocol];
    if (premium == 0) return 0;
    return _activeBalance(_protocol) / premium;
  }

  /// @notice View current active balance of covered protocol
  /// @param _protocol Protocol identifier
  /// @return Active balance
  /// @dev Accrued debt is subtracted from the stored active balance
  function activeBalance(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _activeBalance(_protocol);
  }

  // Helper function to calc the active balance of a protocol at current time
  function _activeBalance(bytes32 _protocol) internal view returns (uint256) {
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) return 0;
    return balance - debt;
  }

  //
  // State methods
  //

  /// @notice Helps set the premium per second for an individual protocol
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function
  function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)
    internal
    returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)
  {
    // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers
    // Also updates the last accounted timestamp for this protocol
    // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings
    // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol
    nonStakerPercentage = _settleProtocolDebt(_protocol);
    // Stores the old premium before it gets updated
    oldPremiumPerSecond = premiums_[_protocol];

    if (oldPremiumPerSecond != _premium) {
      // Sets the protocol's premium per second to the new value
      premiums_[_protocol] = _premium;
      emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium);
    }
    // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing
    // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes
    // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point
    // Where arbs would no longer be incentivized to remove the protocol
    // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems
    if (_premium != 0 && _secondsOfCoverageLeft(_protocol) < MIN_SECONDS_OF_COVERAGE) {
      revert InsufficientBalance(_protocol);
    }
  }

  /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {
    // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings
    (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
      _protocol,
      _premium
    );
    // Settling the total amount of premiums owed to stakers before a new premium per second gets set
    _settleTotalDebt();
    // This calculates the new global premium per second that gets paid to stakers
    // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      oldPremiumPerSecond,
      _premium,
      nonStakerPercentage,
      nonStakerPercentage,
      allPremiumsPerSecToStakers
    );
  }

  // Internal function to set a new protocolAgent for a specific protocol
  // _oldAgent is only included as part of emitting an event
  function _setProtocolAgent(
    bytes32 _protocol,
    address _oldAgent,
    address _protocolAgent
  ) internal {
    protocolAgent_[_protocol] = _protocolAgent;
    emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);
  }

  // Subtracts the accrued debt from a protocol's active balance
  // Credits the amount that can be claimed by nonstakers for this protocol
  // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings
  // Most of this function is dealing with an edge case related to a protocol not being removed by arbs
  function _settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {
    // This calcs the accrued debt of the protocol since it was last updated
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // This pulls the percentage that is sent to nonstakers
    _nonStakerPercentage = nonStakersPercentage[_protocol];
    // In case the protocol has accrued debt, this code block will ensure the debt is settled properly
    if (debt != 0) {
      // Pulls the stored active balance of the protocol
      uint256 balance = activeBalances[_protocol];
      // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance
      // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point
      // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage
      // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up
      if (debt > balance) {
        // This error amount represents the magnitude of the mistake
        uint256 error = debt - balance;
        // Gets the latest value of claimable premiums for stakers
        _settleTotalDebt();
        // @note to production, set premium first to zero before solving accounting issue.
        // otherwise the accounting error keeps increasing
        uint256 lastClaimablePremiumsForStakers_ = lastClaimablePremiumsForStakers;

        // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%
        uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /
          HUNDRED_PERCENT;

        // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short
        uint256 insufficientTokens;

        // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally
        // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error
        // This first line can be true if claimPremiumsForStakers() has been called and
        // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be >0 still
        if (claimablePremiumError > lastClaimablePremiumsForStakers_) {
          insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;
          lastClaimablePremiumsForStakers = 0;
        } else {
          // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums
          // By the amount that was added in error (error) and insufficientTokens = 0
          lastClaimablePremiumsForStakers =
            lastClaimablePremiumsForStakers_ -
            claimablePremiumError;
        }

        // If two events are thrown, the values need to be summed up for the actual state.
        // This means an error of this type will continue until it is handled
        emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);
        // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case
        debt = balance;
      }
      // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance
      activeBalances[_protocol] = balance - debt;
      // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol
      nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT;
    }
    // Updates the last accounted timestamp for this protocol
    lastAccountedEachProtocol[_protocol] = block.timestamp;
  }

  // Multiplies the total premium per second * number of seconds since the last global accounting update
  // And adds it to the total claimable amount for stakers
  function _settleTotalDebt() internal {
    lastClaimablePremiumsForStakers +=
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
    lastAccountedGlobal = block.timestamp;
  }

  // Calculates the global premium per second for stakers
  // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers
  // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones
  function _calcGlobalPremiumPerSecForStakers(
    uint256 _premiumOld,
    uint256 _premiumNew,
    uint256 _nonStakerPercentageOld,
    uint256 _nonStakerPercentageNew,
    uint256 _inMemAllPremiumsPerSecToStakers
  ) internal pure returns (uint256) {
    return
      _inMemAllPremiumsPerSecToStakers +
      ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /
      HUNDRED_PERCENT -
      ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /
      HUNDRED_PERCENT;
  }

  // Helper function to remove and clean up a protocol from Sherlock
  // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made
  function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {
    // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol
    _setSingleAndGlobalProtocolPremium(_protocol, 0);

    // Grabs the protocol's active balance
    uint256 balance = activeBalances[_protocol];

    // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent
    if (balance != 0) {
      delete activeBalances[_protocol];
      token.safeTransfer(_agent, balance);

      emit ProtocolBalanceWithdrawn(_protocol, balance);
    }

    // Sets the protocol agent to zero address (as part of clean up)
    _setProtocolAgent(_protocol, _agent, address(0));

    // Cleans up other mappings for this protocol
    delete nonStakersPercentage[_protocol];
    delete lastAccountedEachProtocol[_protocol];
    // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above

    // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol
    removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;

    // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed
    // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked
    removedProtocolAgent[_protocol] = _agent;

    emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0));
    emit ProtocolRemoved(_protocol);
  }

  /// @notice Sets the minimum active balance before an arb can remove a protocol
  /// @param _minActiveBalance Minimum balance needed (in USDC)
  /// @dev Only gov
  function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {
    // New value cannot be the same as current value
    if (minActiveBalance == _minActiveBalance) revert InvalidArgument();
    // Can't set a value that is too high to be reasonable
    if (_minActiveBalance >= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions();

    emit MinBalance(minActiveBalance, _minActiveBalance);
    minActiveBalance = _minActiveBalance;
  }

  // This function allows the nonstakers role to claim tokens owed to them by a specific protocol
  /// @notice Choose an `_amount` of tokens that nonstakers (`_receiver` address) will receive from `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens
  /// @param _receiver Address to receive tokens
  /// @dev Only callable by nonstakers role
  function nonStakersClaim(
    bytes32 _protocol,
    uint256 _amount,
    address _receiver
  ) external override whenNotPaused {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_amount == uint256(0)) revert ZeroArgument();
    if (_receiver == address(0)) revert ZeroArgument();
    // Only the nonstakers role (multisig or contract) can pull the funds
    if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized();

    // Call can't be executed on protocol that is removed
    if (protocolAgent_[_protocol] != address(0)) {
      // Updates the amount that nonstakers can claim from this protocol
      _settleProtocolDebt(_protocol);
    }

    // Sets balance to the amount that is claimable by nonstakers for this specific protocol
    uint256 balance = nonStakersClaimableByProtocol[_protocol];
    // If the amount requested is more than what's owed to nonstakers, revert
    if (_amount > balance) revert InsufficientBalance(_protocol);

    // Sets the claimable amount to whatever is left over after this amount is pulled
    nonStakersClaimableByProtocol[_protocol] = balance - _amount;
    // Transfers the amount requested to the `_receiver` address
    token.safeTransfer(_receiver, _amount);
  }

  // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)
  /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address
  /// @dev Callable by everyone
  /// @dev Funds will be transferred to Sherlock core contract
  function claimPremiumsForStakers() external override whenNotPaused {
    // Gets address of core Sherlock contract
    address sherlock = address(sherlockCore);
    // Revert if core Sherlock contract not initialized yet
    if (sherlock == address(0)) revert InvalidConditions();

    // claimablePremiums is different from _settleTotalDebt() because it does not change state
    // Retrieves current amount of all premiums that are owed to stakers
    uint256 amount = claimablePremiums();

    // Transfers all the premiums owed to stakers to the Sherlock core contract
    if (amount != 0) {
      // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out
      lastClaimablePremiumsForStakers = 0;
      lastAccountedGlobal = block.timestamp;
      token.safeTransfer(sherlock, amount);
    }
  }

  // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts
  /// @param _protocol Protocol identifier
  /// @return current and previous are the current and previous coverage amounts for this protocol
  // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)
  function coverageAmounts(bytes32 _protocol)
    external
    view
    override
    returns (uint256 current, uint256 previous)
  {
    // Checks to see if the protocol has an active protocolAgent (protocol not removed)
    // OR checks to see if the removed protocol is still within the claim window
    // If so, gives the current and previous coverage, otherwise throws an error
    if (
      protocolAgent_[_protocol] != address(0) ||
      block.timestamp <= removedProtocolClaimDeadline[_protocol]
    ) {
      return (currentCoverage[_protocol], previousCoverage[_protocol]);
    }

    revert ProtocolNotExists(_protocol);
  }

  /// @notice Add a new protocol to Sherlock
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Address able to submit a claim on behalf of the protocol
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Adding a protocol allows the `_protocolAgent` to submit a claim
  /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point
  /// @dev `_nonStakers` is scaled by 10**18
  /// @dev Only callable by governance
  function protocolAdd(
    bytes32 _protocol,
    address _protocolAgent,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) external override onlyOwner {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Checks to make sure the protocol doesn't exist already
    if (protocolAgent_[_protocol] != address(0)) revert InvalidConditions();

    // Updates the protocol agent and passes in the old agent which is 0 address in this case
    _setProtocolAgent(_protocol, address(0), _protocolAgent);

    // Delete mappings that are potentially non default values
    // From previous time protocol was added/removed
    delete removedProtocolClaimDeadline[_protocol];
    delete removedProtocolAgent[_protocol];
    delete currentCoverage[_protocol];
    delete previousCoverage[_protocol];

    emit ProtocolAdded(_protocol);

    // Most of the logic for actually adding a protocol in this function
    protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Update info regarding a protocol
  /// @param _protocol Protocol identifier
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Only callable by governance
  /// @dev `_nonStakers` can be 0
  function protocolUpdate(
    bytes32 _protocol,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) public override onlyOwner {
    if (_coverage == bytes32(0)) revert ZeroArgument();
    if (_nonStakers > HUNDRED_PERCENT) revert InvalidArgument();
    if (_coverageAmount == uint256(0)) revert ZeroArgument();

    // Checks to make sure the protocol has been assigned a protocol agent
    _verifyProtocolExists(_protocol);

    // Subtracts the accrued debt from a protocol's active balance (if any)
    // Updates the amount that can be claimed by nonstakers
    _settleProtocolDebt(_protocol);

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    // Gets the premium per second for this protocol
    uint256 premium = premiums_[_protocol];

    // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be)
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      premium,
      premium,
      nonStakersPercentage[_protocol],
      _nonStakers,
      allPremiumsPerSecToStakers
    );

    // Updates the stored value of percentage of premiums that go to nonstakers
    nonStakersPercentage[_protocol] = _nonStakers;

    // Updates previous coverage and current coverage amounts
    previousCoverage[_protocol] = currentCoverage[_protocol];
    currentCoverage[_protocol] = _coverageAmount;

    emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Remove a protocol from coverage
  /// @param _protocol Protocol identifier
  /// @dev Before removing a protocol the premium must be 0
  /// @dev Removing a protocol basically stops the `_protocolAgent` from being active (can still submit claims until claim deadline though)
  /// @dev Pays off debt + sends remaining balance to protocol agent
  /// @dev This call should be subject to a timelock
  /// @dev Only callable by governance
  function protocolRemove(bytes32 _protocol) external override onlyOwner {
    // checks to make sure the protocol actually has a protocol agent
    address agent = _verifyProtocolExists(_protocol);

    // Removes a protocol from Sherlock and cleans up its data
    // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made
    _forceRemoveProtocol(_protocol, agent);
  }

  /// @notice Remove a protocol with insufficient active balance
  /// @param _protocol Protocol identifier
  // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function
  function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {
    address agent = _verifyProtocolExists(_protocol);

    // Gets the latest value of the active balance at this protocol
    _settleProtocolDebt(_protocol);
    // Sets latest value of active balance to remainingBalance variable
    uint256 remainingBalance = activeBalances[_protocol];

    // This means the protocol still has adequate active balance and thus cannot be removed
    if (remainingBalance >= minActiveBalance) revert InvalidConditions();

    // Sets the protocol's active balance to 0
    delete activeBalances[_protocol];
    // Removes the protocol from coverage
    _forceRemoveProtocol(_protocol, agent);

    if (remainingBalance != 0) {
      // sends the remaining balance to msg.sender
      token.safeTransfer(msg.sender, remainingBalance);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);
  }

  /// @notice Calculate if arb is possible and what the reward would be
  /// @param _protocol Protocol identifier
  /// @return arbAmount Amount reward for arbing
  /// @return able Indicator if arb call is even possible
  /// @dev Doesn't subtract the current protocol debt from the active balance
  function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)
    internal
    view
    returns (uint256 arbAmount, bool able)
  {
    uint256 secondsLeft = _secondsOfCoverageLeft(_protocol);

    // If arb is not possible return false
    if (secondsLeft >= MIN_SECONDS_OF_COVERAGE) return (0, false);

    // This percentage scales over time
    // Reaches 100% on 0 seconds of coverage left
    uint256 percentageScaled = HUNDRED_PERCENT -
      (secondsLeft * HUNDRED_PERCENT) /
      MIN_SECONDS_OF_COVERAGE;

    able = true;
    arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;
  }

  /// @notice Removes a protocol with insufficent seconds of coverage left
  /// @param _protocol Protocol identifier
  // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second
  function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {
    // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings
    address agent = _verifyProtocolExists(_protocol);

    // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance()
    // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance()
    // But when removing based on seconds of coverage left, the remainingBalance could still be quite large
    // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance
    // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%)
    _settleProtocolDebt(_protocol);
    (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol);
    if (able == false) revert InvalidConditions();

    if (arbAmount != 0) {
      // subtracts the amount that will be paid to the arb from the active balance
      activeBalances[_protocol] -= arbAmount;
    }

    // Removes the protocol from coverage
    // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above
    _forceRemoveProtocol(_protocol, agent);

    // Done after removing protocol to mitigate reentrency pattern
    // (In case token allows callback)
    if (arbAmount != 0) {
      token.safeTransfer(msg.sender, arbAmount);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);
  }

  /// @notice Set premium of `_protocol` to `_premium`
  /// @param _protocol Protocol identifier
  /// @param _premium Amount of premium `_protocol` pays per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {
    // Checks to see if protocol has a protocol agent
    _verifyProtocolExists(_protocol);

    // Updates individual protocol's premium and allPremiumsPerSecToStakers
    _setSingleAndGlobalProtocolPremium(_protocol, _premium);
  }

  /// @notice Set premium of multiple protocols
  /// @param _protocol Array of protocol identifiers
  /// @param _premium Array of premium amounts protocols pay per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)
    external
    override
    onlyOwner
  {
    // Checks to make sure there are an equal amount of entries in each array
    if (_protocol.length != _premium.length) revert UnequalArrayLength();
    if (_protocol.length == 0) revert InvalidArgument();

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;

    // Loops through the array of protocols and checks to make sure each has a protocol agent assigned
    for (uint256 i; i < _protocol.length; i++) {
      _verifyProtocolExists(_protocol[i]);

      // Sets the protocol premium for that specific protocol
      // Function returns the old premium and nonStakerPercentage for that specific protocol
      (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
        _protocol[i],
        _premium[i]
      );

      // Calculates the new global premium which adds up all premiums paid by all protocols
      allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(
        oldPremiumPerSecond,
        _premium[i],
        nonStakerPercentage,
        nonStakerPercentage,
        allPremiumsPerSecToStakers_
      );
    }

    // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value
    allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;
  }

  // This is how protocols pay for coverage by increasing their active balance
  /// @notice Deposits `_amount` of token to the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to deposit
  /// @dev Approval should be made before calling
  function depositToActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    _verifyProtocolExists(_protocol);

    // Transfers _amount to this contract
    token.safeTransferFrom(msg.sender, address(this), _amount);
    // Increases the active balance of the protocol by _amount
    activeBalances[_protocol] += _amount;

    emit ProtocolBalanceDeposited(_protocol, _amount);
  }

  // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)
  // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)
  /// @notice Withdraws `_amount` of token from the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to withdraw
  /// @dev Only protocol agent is able to withdraw
  /// @dev Balance can be withdrawn up until 7 days worth of active balance
  function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    // Only the protocol agent can call this function
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Updates the active balance of the protocol
    _settleProtocolDebt(_protocol);

    // Sets currentBalance to the active balance of the protocol
    uint256 currentBalance = activeBalances[_protocol];
    // Reverts if trying to withdraw more than the active balance
    if (_amount > currentBalance) revert InsufficientBalance(_protocol);

    // Removes the _amount to be withdrawn from the active balance
    activeBalances[_protocol] = currentBalance - _amount;
    // Reverts if a protocol has less than 7 days worth of active balance left
    if (_secondsOfCoverageLeft(_protocol) < MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);

    // Transfers the amount to the msg.sender (protocol agent)
    token.safeTransfer(msg.sender, _amount);
    emit ProtocolBalanceWithdrawn(_protocol, _amount);
  }

  /// @notice Transfer protocol agent role
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Account able to submit a claim on behalf of the protocol
  /// @dev Only the active protocolAgent is able to transfer the role
  function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)
    external
    override
    whenNotPaused
  {
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Can't set the new protocol agent to the caller address
    if (msg.sender == _protocolAgent) revert InvalidArgument();
    // Because the caller must be the current protocol agent
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Sets the protocol agent to the new address
    _setProtocolAgent(_protocol, msg.sender, _protocolAgent);
  }

  /// @notice Function used to check if this is the current active protocol manager
  /// @return Boolean indicating it's active
  /// @dev If inactive the owner can pull all ERC20s and ETH
  /// @dev Will be checked by calling the sherlock contract
  function isActive() public view returns (bool) {
    return address(sherlockCore.sherlockProtocolManager()) == address(this);
  }

  // Only contract owner can call this
  // Sends all specified tokens in this contract to the receiver's address (as well as ETH)
  function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {
    if (_receiver == address(0)) revert ZeroArgument();
    // This contract must NOT be the current assigned protocol manager contract
    if (isActive()) revert InvalidConditions();
    // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH
    _sweep(_receiver, _extraTokens);
  }
}
.]

###

[2024-25-08 10:58:59 INFO] **[Seminar Conclusion]**:

 ###

[2024-25-08 10:58:59 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-25-08 10:58:59 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import './Manager.sol'; import '../interfaces/managers/ISherlockProtocolManager.sol'; /// @title Sherlock core interface for protocols /// @author Evert Kors // This is the contract that manages covered protocols contract SherlockProtocolManager is ISherlockProtocolManager, Manager {   using SafeERC20 for IERC20; // Represents the token that protocols pay with (currently USDC)   IERC20 public immutable token; // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed   uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc // A removed protocol is still able to make a claim for this amount of time after its removal   uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days; // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance   uint256 public constant MIN_SECONDS_LEFT = 7 days; // Convenient for percentage calculations   uint256 internal constant HUNDRED_PERCENT = 10**18; // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage   // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying   uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours; // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)   mapping(bytes32 =&gt; address) internal protocolAgent_; // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)   mapping(bytes32 =&gt; uint256) internal nonStakersPercentage; // The premium per second paid by each protocol is stored in this mapping   mapping(bytes32 =&gt; uint256) internal premiums_; // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.   // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not   mapping(bytes32 =&gt; uint256) internal activeBalances; // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol   mapping(bytes32 =&gt; uint256) internal lastAccountedEachProtocol; // The amount that can be claimed by nonstakers for each protocol   // We need this value so we can track how much payment is coming from each protocol   mapping(bytes32 =&gt; uint256) internal nonStakersClaimableByProtocol; // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)   uint256 internal lastAccountedGlobal; // This is the total amount of premiums paid (per second) by all the covered protocols (added up)   uint256 internal allPremiumsPerSecToStakers; // This is the amount that was claimable by stakers the last time the accounting was run   // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date   uint256 internal lastClaimablePremiumsForStakers; // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage   // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)   uint256 public override minActiveBalance; // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)   mapping(bytes32 =&gt; uint256) internal removedProtocolClaimDeadline; // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)   mapping(bytes32 =&gt; address) internal removedProtocolAgent; // Current amount of coverage (i.e. 20M USDC) for a protocol   mapping(bytes32 =&gt; uint256) internal currentCoverage; // Previous amount of coverage for a protocol   // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount   mapping(bytes32 =&gt; uint256) internal previousCoverage; // Setting the token to USDC   constructor(IERC20 _token) {     if (address(_token) == address(0)) revert ZeroArgument();     token = _token;   } // Modifier used to ensure a protocol exists (has been instantiated and not removed)   modifier protocolExists(bytes32 protocol) {     _verifyProtocolExists(_protocol);     ;   } /// @notice View current protocolAgent of _protocol   /// @param protocol Protocol identifier   /// @return Address able to submit claims   function protocolAgent(bytes32 _protocol) external view override returns (address) {     address agent = protocolAgent[_protocol];     if (agent != address(0)) return agent; // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned // Note: Old protocol agent will never be address(0) if (block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]) {   return removedProtocolAgent[_protocol]; }  // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned revert ProtocolNotExists(_protocol);  } // Checks if the protocol exists, then returns the current premium per second being charged   /// @notice View current premium of protocol   /// @param protocol Protocol identifier   /// @return Amount of premium _protocol pays per second   function premium(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return premiums[_protocol];   } // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)   // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)   function verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {     _protocolAgent = protocolAgent[_protocol];     if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);   } //   // View methods   // // Calcs the debt accrued by the protocol since it last had an accounting update   // This is the amount that needs to be removed from a protocol's active balance   function calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {     return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums[_protocol];   } /// @notice View the amount nonstakers can claim from this protocol   /// @param _protocol Protocol identifier   /// @return Amount of tokens claimable by nonstakers   /// @dev this reads from a storage variable + (now-lastsettled) * premiums   // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]   // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed   function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {     // Calcs the debt of a protocol since the last accounting update     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     // Gets the active balance of the protocol     uint256 balance = activeBalances[_protocol];     // The debt should never be higher than the balance (only happens if the arbitrages fail)     if (debt &gt; balance) debt = balance; // Adds the incremental claimable amount owed to nonstakers to the total claimable amount return   nonStakersClaimableByProtocol[_protocol] +   (nonStakersPercentage[_protocol] * debt) /   HUNDRED_PERCENT;  } /// @notice View current amount of all premiums that are owed to stakers   /// @return Premiums claimable   /// @dev Will increase every block   /// @dev base + (now - last_settled) * ps   function claimablePremiums() public view override returns (uint256) {     // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)     return       lastClaimablePremiumsForStakers +       (block.timestamp - lastAccountedGlobal) *       allPremiumsPerSecToStakers;   } /// @notice View seconds of coverage left for _protocol before it runs out of active balance   /// @param _protocol Protocol identifier   /// @return Seconds of coverage left   function secondsOfCoverageLeft(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return _secondsOfCoverageLeft(_protocol);   } // Helper function to return seconds of coverage left for a protocol   // Gets the current active balance of the protocol and divides by the premium per second for the protocol   function secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {     uint256 premium = premiums[_protocol];     if (premium == 0) return 0;     return _activeBalance(_protocol) / premium;   } /// @notice View current active balance of covered protocol   /// @param _protocol Protocol identifier   /// @return Active balance   /// @dev Accrued debt is subtracted from the stored active balance   function activeBalance(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return _activeBalance(_protocol);   } // Helper function to calc the active balance of a protocol at current time   function _activeBalance(bytes32 _protocol) internal view returns (uint256) {     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     uint256 balance = activeBalances[_protocol];     // The debt should never be higher than the balance (only happens if the arbitrages fail)     if (debt &gt; balance) return 0;     return balance - debt;   } //   // State methods   // /// @notice Helps set the premium per second for an individual protocol   /// @param protocol Protocol identifier   /// @param _premium New premium per second   /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function   function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)     internal     returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)   {     // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers     // Also updates the last accounted timestamp for this protocol     // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings     // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol     nonStakerPercentage = _settleProtocolDebt(_protocol);     // Stores the old premium before it gets updated     oldPremiumPerSecond = premiums[_protocol]; if (oldPremiumPerSecond != _premium) {   // Sets the protocol's premium per second to the new value   premiums_[_protocol] = _premium;   emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium); } // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point // Where arbs would no longer be incentivized to remove the protocol // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems if (_premium != 0 &amp;&amp; _secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_OF_COVERAGE) {   revert InsufficientBalance(_protocol); }  } /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second   /// @param _protocol Protocol identifier   /// @param _premium New premium per second   function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {     // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings     (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(       _protocol,       _premium     );     // Settling the total amount of premiums owed to stakers before a new premium per second gets set     _settleTotalDebt();     // This calculates the new global premium per second that gets paid to stakers     // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function     allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(       oldPremiumPerSecond,       _premium,       nonStakerPercentage,       nonStakerPercentage,       allPremiumsPerSecToStakers     );   } // Internal function to set a new protocolAgent for a specific protocol   // oldAgent is only included as part of emitting an event   function _setProtocolAgent(     bytes32 _protocol,     address _oldAgent,     address _protocolAgent   ) internal {     protocolAgent[_protocol] = _protocolAgent;     emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);   } // Subtracts the accrued debt from a protocol's active balance   // Credits the amount that can be claimed by nonstakers for this protocol   // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings   // Most of this function is dealing with an edge case related to a protocol not being removed by arbs   function settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {     // This calcs the accrued debt of the protocol since it was last updated     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     // This pulls the percentage that is sent to nonstakers     _nonStakerPercentage = nonStakersPercentage[_protocol];     // In case the protocol has accrued debt, this code block will ensure the debt is settled properly     if (debt != 0) {       // Pulls the stored active balance of the protocol       uint256 balance = activeBalances[_protocol];       // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance       // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point       // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage       // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up       if (debt &gt; balance) {         // This error amount represents the magnitude of the mistake         uint256 error = debt - balance;         // Gets the latest value of claimable premiums for stakers         _settleTotalDebt();         // @note to production, set premium first to zero before solving accounting issue.         // otherwise the accounting error keeps increasing         uint256 lastClaimablePremiumsForStakers = lastClaimablePremiumsForStakers;     // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%     uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /       HUNDRED_PERCENT;      // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short     uint256 insufficientTokens;      // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally     // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error     // This first line can be true if claimPremiumsForStakers() has been called and     // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be &gt;0 still     if (claimablePremiumError &gt; lastClaimablePremiumsForStakers_) {       insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;       lastClaimablePremiumsForStakers = 0;     } else {       // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums       // By the amount that was added in error (error) and insufficientTokens = 0       lastClaimablePremiumsForStakers =         lastClaimablePremiumsForStakers_ -         claimablePremiumError;     }      // If two events are thrown, the values need to be summed up for the actual state.     // This means an error of this type will continue until it is handled     emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);     // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case     debt = balance;   }   // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance   activeBalances[_protocol] = balance - debt;   // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol   nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT; } // Updates the last accounted timestamp for this protocol lastAccountedEachProtocol[_protocol] = block.timestamp;  } // Multiplies the total premium per second * number of seconds since the last global accounting update   // And adds it to the total claimable amount for stakers   function _settleTotalDebt() internal {     lastClaimablePremiumsForStakers +=       (block.timestamp - lastAccountedGlobal) *       allPremiumsPerSecToStakers;     lastAccountedGlobal = block.timestamp;   } // Calculates the global premium per second for stakers   // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers   // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones   function _calcGlobalPremiumPerSecForStakers(     uint256 _premiumOld,     uint256 _premiumNew,     uint256 _nonStakerPercentageOld,     uint256 _nonStakerPercentageNew,     uint256 _inMemAllPremiumsPerSecToStakers   ) internal pure returns (uint256) {     return       _inMemAllPremiumsPerSecToStakers +       ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /       HUNDRED_PERCENT -       ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /       HUNDRED_PERCENT;   } // Helper function to remove and clean up a protocol from Sherlock   // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made   function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {     // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol     _setSingleAndGlobalProtocolPremium(_protocol, 0); // Grabs the protocol's active balance uint256 balance = activeBalances[_protocol];  // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent if (balance != 0) {   delete activeBalances[_protocol];   token.safeTransfer(_agent, balance);    emit ProtocolBalanceWithdrawn(_protocol, balance); }  // Sets the protocol agent to zero address (as part of clean up) _setProtocolAgent(_protocol, _agent, address(0));  // Cleans up other mappings for this protocol delete nonStakersPercentage[_protocol]; delete lastAccountedEachProtocol[_protocol]; // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above  // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;  // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked removedProtocolAgent[_protocol] = _agent;  emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0)); emit ProtocolRemoved(_protocol);  } /// @notice Sets the minimum active balance before an arb can remove a protocol   /// @param _minActiveBalance Minimum balance needed (in USDC)   /// @dev Only gov   function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {     // New value cannot be the same as current value     if (minActiveBalance == _minActiveBalance) revert InvalidArgument();     // Can't set a value that is too high to be reasonable     if (_minActiveBalance &gt;= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions(); emit MinBalance(minActiveBalance, _minActiveBalance); minActiveBalance = _minActiveBalance;  } // This function allows the nonstakers role to claim tokens owed to them by a specific protocol   /// @notice Choose an _amount of tokens that nonstakers (_receiver address) will receive from _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens   /// @param _receiver Address to receive tokens   /// @dev Only callable by nonstakers role   function nonStakersClaim(     bytes32 _protocol,     uint256 _amount,     address _receiver   ) external override whenNotPaused {     if (_protocol == bytes32(0)) revert ZeroArgument();     if (_amount == uint256(0)) revert ZeroArgument();     if (_receiver == address(0)) revert ZeroArgument();     // Only the nonstakers role (multisig or contract) can pull the funds     if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized(); // Call can't be executed on protocol that is removed if (protocolAgent_[_protocol] != address(0)) {   // Updates the amount that nonstakers can claim from this protocol   _settleProtocolDebt(_protocol); }  // Sets balance to the amount that is claimable by nonstakers for this specific protocol uint256 balance = nonStakersClaimableByProtocol[_protocol]; // If the amount requested is more than what's owed to nonstakers, revert if (_amount &gt; balance) revert InsufficientBalance(_protocol);  // Sets the claimable amount to whatever is left over after this amount is pulled nonStakersClaimableByProtocol[_protocol] = balance - _amount; // Transfers the amount requested to the `_receiver` address token.safeTransfer(_receiver, _amount);  } // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)   /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address   /// @dev Callable by everyone   /// @dev Funds will be transferred to Sherlock core contract   function claimPremiumsForStakers() external override whenNotPaused {     // Gets address of core Sherlock contract     address sherlock = address(sherlockCore);     // Revert if core Sherlock contract not initialized yet     if (sherlock == address(0)) revert InvalidConditions(); // claimablePremiums is different from _settleTotalDebt() because it does not change state // Retrieves current amount of all premiums that are owed to stakers uint256 amount = claimablePremiums();  // Transfers all the premiums owed to stakers to the Sherlock core contract if (amount != 0) {   // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out   lastClaimablePremiumsForStakers = 0;   lastAccountedGlobal = block.timestamp;   token.safeTransfer(sherlock, amount); }  } // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts   /// @param protocol Protocol identifier   /// @return current and previous are the current and previous coverage amounts for this protocol   // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)   function coverageAmounts(bytes32 _protocol)     external     view     override     returns (uint256 current, uint256 previous)   {     // Checks to see if the protocol has an active protocolAgent (protocol not removed)     // OR checks to see if the removed protocol is still within the claim window     // If so, gives the current and previous coverage, otherwise throws an error     if (       protocolAgent[_protocol] != address(0) ||       block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]     ) {       return (currentCoverage[_protocol], previousCoverage[_protocol]);     } revert ProtocolNotExists(_protocol);  } /// @notice Add a new protocol to Sherlock   /// @param protocol Protocol identifier   /// @param _protocolAgent Address able to submit a claim on behalf of the protocol   /// @param _coverage Hash referencing the active coverage agreement   /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 1018   /// @param _coverageAmount Max amount claimable by this protocol   /// @dev Adding a protocol allows the _protocolAgent to submit a claim   /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point   /// @dev _nonStakers is scaled by 1018   /// @dev Only callable by governance   function protocolAdd(     bytes32 _protocol,     address _protocolAgent,     bytes32 _coverage,     uint256 _nonStakers,     uint256 _coverageAmount   ) external override onlyOwner {     if (_protocol == bytes32(0)) revert ZeroArgument();     if (_protocolAgent == address(0)) revert ZeroArgument();     // Checks to make sure the protocol doesn't exist already     if (protocolAgent[_protocol] != address(0)) revert InvalidConditions(); // Updates the protocol agent and passes in the old agent which is 0 address in this case _setProtocolAgent(_protocol, address(0), _protocolAgent);  // Delete mappings that are potentially non default values // From previous time protocol was added/removed delete removedProtocolClaimDeadline[_protocol]; delete removedProtocolAgent[_protocol]; delete currentCoverage[_protocol]; delete previousCoverage[_protocol];  emit ProtocolAdded(_protocol);  // Most of the logic for actually adding a protocol in this function protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);  } /// @notice Update info regarding a protocol   /// @param _protocol Protocol identifier   /// @param _coverage Hash referencing the active coverage agreement   /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18   /// @param _coverageAmount Max amount claimable by this protocol   /// @dev Only callable by governance   /// @dev _nonStakers can be 0   function protocolUpdate(     bytes32 _protocol,     bytes32 _coverage,     uint256 _nonStakers,     uint256 _coverageAmount   ) public override onlyOwner {     if (_coverage == bytes32(0)) revert ZeroArgument();     if (_nonStakers &gt; HUNDRED_PERCENT) revert InvalidArgument();     if (_coverageAmount == uint256(0)) revert ZeroArgument(); // Checks to make sure the protocol has been assigned a protocol agent _verifyProtocolExists(_protocol);  // Subtracts the accrued debt from a protocol's active balance (if any) // Updates the amount that can be claimed by nonstakers _settleProtocolDebt(_protocol);  // Updates the global claimable amount for stakers _settleTotalDebt();  // Gets the premium per second for this protocol uint256 premium = premiums_[_protocol];  // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be) allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(   premium,   premium,   nonStakersPercentage[_protocol],   _nonStakers,   allPremiumsPerSecToStakers );  // Updates the stored value of percentage of premiums that go to nonstakers nonStakersPercentage[_protocol] = _nonStakers;  // Updates previous coverage and current coverage amounts previousCoverage[_protocol] = currentCoverage[_protocol]; currentCoverage[_protocol] = _coverageAmount;  emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);  } /// @notice Remove a protocol from coverage   /// @param _protocol Protocol identifier   /// @dev Before removing a protocol the premium must be 0   /// @dev Removing a protocol basically stops the _protocolAgent from being active (can still submit claims until claim deadline though)   /// @dev Pays off debt + sends remaining balance to protocol agent   /// @dev This call should be subject to a timelock   /// @dev Only callable by governance   function protocolRemove(bytes32 _protocol) external override onlyOwner {     // checks to make sure the protocol actually has a protocol agent     address agent = _verifyProtocolExists(_protocol); // Removes a protocol from Sherlock and cleans up its data // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made _forceRemoveProtocol(_protocol, agent);  } /// @notice Remove a protocol with insufficient active balance   /// @param _protocol Protocol identifier   // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function   function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {     address agent = _verifyProtocolExists(_protocol); // Gets the latest value of the active balance at this protocol _settleProtocolDebt(_protocol); // Sets latest value of active balance to remainingBalance variable uint256 remainingBalance = activeBalances[_protocol];  // This means the protocol still has adequate active balance and thus cannot be removed if (remainingBalance &gt;= minActiveBalance) revert InvalidConditions();  // Sets the protocol's active balance to 0 delete activeBalances[_protocol]; // Removes the protocol from coverage _forceRemoveProtocol(_protocol, agent);  if (remainingBalance != 0) {   // sends the remaining balance to msg.sender   token.safeTransfer(msg.sender, remainingBalance); } emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);  } /// @notice Calculate if arb is possible and what the reward would be   /// @param _protocol Protocol identifier   /// @return arbAmount Amount reward for arbing   /// @return able Indicator if arb call is even possible   /// @dev Doesn't subtract the current protocol debt from the active balance   function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)     internal     view     returns (uint256 arbAmount, bool able)   {     uint256 secondsLeft = _secondsOfCoverageLeft(_protocol); // If arb is not possible return false if (secondsLeft &gt;= MIN_SECONDS_OF_COVERAGE) return (0, false);  // This percentage scales over time // Reaches 100% on 0 seconds of coverage left uint256 percentageScaled = HUNDRED_PERCENT -   (secondsLeft * HUNDRED_PERCENT) /   MIN_SECONDS_OF_COVERAGE;  able = true; arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;  } /// @notice Removes a protocol with insufficent seconds of coverage left   /// @param _protocol Protocol identifier   // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second   function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {     // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings     address agent = _verifyProtocolExists(_protocol); // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance() // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance() // But when removing based on seconds of coverage left, the remainingBalance could still be quite large // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%) _settleProtocolDebt(_protocol); (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol); if (able == false) revert InvalidConditions();  if (arbAmount != 0) {   // subtracts the amount that will be paid to the arb from the active balance   activeBalances[_protocol] -= arbAmount; }  // Removes the protocol from coverage // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above _forceRemoveProtocol(_protocol, agent);  // Done after removing protocol to mitigate reentrency pattern // (In case token allows callback) if (arbAmount != 0) {   token.safeTransfer(msg.sender, arbAmount); } emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);  } /// @notice Set premium of _protocol to _premium   /// @param _protocol Protocol identifier   /// @param _premium Amount of premium _protocol pays per second   /// @dev The value 0 would mean inactive coverage   /// @dev Only callable by governance   function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {     // Checks to see if protocol has a protocol agent     _verifyProtocolExists(_protocol); // Updates individual protocol's premium and allPremiumsPerSecToStakers _setSingleAndGlobalProtocolPremium(_protocol, _premium);  } /// @notice Set premium of multiple protocols   /// @param _protocol Array of protocol identifiers   /// @param _premium Array of premium amounts protocols pay per second   /// @dev The value 0 would mean inactive coverage   /// @dev Only callable by governance   function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)     external     override     onlyOwner   {     // Checks to make sure there are an equal amount of entries in each array     if (_protocol.length != _premium.length) revert UnequalArrayLength();     if (_protocol.length == 0) revert InvalidArgument(); // Updates the global claimable amount for stakers _settleTotalDebt();  uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;  // Loops through the array of protocols and checks to make sure each has a protocol agent assigned for (uint256 i; i &lt; _protocol.length; i++) {   _verifyProtocolExists(_protocol[i]);    // Sets the protocol premium for that specific protocol   // Function returns the old premium and nonStakerPercentage for that specific protocol   (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(     _protocol[i],     _premium[i]   );    // Calculates the new global premium which adds up all premiums paid by all protocols   allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(     oldPremiumPerSecond,     _premium[i],     nonStakerPercentage,     nonStakerPercentage,     allPremiumsPerSecToStakers_   ); }  // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;  } // This is how protocols pay for coverage by increasing their active balance   /// @notice Deposits _amount of token to the active balance of _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens to deposit   /// @dev Approval should be made before calling   function depositToActiveBalance(bytes32 _protocol, uint256 _amount)     external     override     whenNotPaused   {     if (_amount == uint256(0)) revert ZeroArgument();     _verifyProtocolExists(_protocol); // Transfers _amount to this contract token.safeTransferFrom(msg.sender, address(this), _amount); // Increases the active balance of the protocol by _amount activeBalances[_protocol] += _amount;  emit ProtocolBalanceDeposited(_protocol, _amount);  } // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)   // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)   /// @notice Withdraws _amount of token from the active balance of _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens to withdraw   /// @dev Only protocol agent is able to withdraw   /// @dev Balance can be withdrawn up until 7 days worth of active balance   function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)     external     override     whenNotPaused   {     if (_amount == uint256(0)) revert ZeroArgument();     // Only the protocol agent can call this function     if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized(); // Updates the active balance of the protocol _settleProtocolDebt(_protocol);  // Sets currentBalance to the active balance of the protocol uint256 currentBalance = activeBalances[_protocol]; // Reverts if trying to withdraw more than the active balance if (_amount &gt; currentBalance) revert InsufficientBalance(_protocol);  // Removes the _amount to be withdrawn from the active balance activeBalances[_protocol] = currentBalance - _amount; // Reverts if a protocol has less than 7 days worth of active balance left if (_secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);  // Transfers the amount to the msg.sender (protocol agent) token.safeTransfer(msg.sender, _amount); emit ProtocolBalanceWithdrawn(_protocol, _amount);  } /// @notice Transfer protocol agent role   /// @param _protocol Protocol identifier   /// @param _protocolAgent Account able to submit a claim on behalf of the protocol   /// @dev Only the active protocolAgent is able to transfer the role   function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)     external     override     whenNotPaused   {     if (_protocolAgent == address(0)) revert ZeroArgument();     // Can't set the new protocol agent to the caller address     if (msg.sender == _protocolAgent) revert InvalidArgument();     // Because the caller must be the current protocol agent     if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized(); // Sets the protocol agent to the new address _setProtocolAgent(_protocol, msg.sender, _protocolAgent);  } /// @notice Function used to check if this is the current active protocol manager   /// @return Boolean indicating it's active   /// @dev If inactive the owner can pull all ERC20s and ETH   /// @dev Will be checked by calling the sherlock contract   function isActive() public view returns (bool) {     return address(sherlockCore.sherlockProtocolManager()) == address(this);   } // Only contract owner can call this   // Sends all specified tokens in this contract to the receiver's address (as well as ETH)   function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {     if (_receiver == address(0)) revert ZeroArgument();     // This contract must NOT be the current assigned protocol manager contract     if (isActive()) revert InvalidConditions();     // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH     _sweep(_receiver, _extraTokens);   } } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-25-08 10:58:59 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import './Manager.sol'; import '../interfaces/managers/ISherlockProtocolManager.sol'; /// @title Sherlock core interface for protocols /// @author Evert Kors // This is the contract that manages covered protocols contract SherlockProtocolManager is ISherlockProtocolManager, Manager {   using SafeERC20 for IERC20; // Represents the token that protocols pay with (currently USDC)   IERC20 public immutable token; // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed   uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc // A removed protocol is still able to make a claim for this amount of time after its removal   uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days; // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance   uint256 public constant MIN_SECONDS_LEFT = 7 days; // Convenient for percentage calculations   uint256 internal constant HUNDRED_PERCENT = 10**18; // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage   // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying   uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours; // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)   mapping(bytes32 =&gt; address) internal protocolAgent_; // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)   mapping(bytes32 =&gt; uint256) internal nonStakersPercentage; // The premium per second paid by each protocol is stored in this mapping   mapping(bytes32 =&gt; uint256) internal premiums_; // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.   // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not   mapping(bytes32 =&gt; uint256) internal activeBalances; // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol   mapping(bytes32 =&gt; uint256) internal lastAccountedEachProtocol; // The amount that can be claimed by nonstakers for each protocol   // We need this value so we can track how much payment is coming from each protocol   mapping(bytes32 =&gt; uint256) internal nonStakersClaimableByProtocol; // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)   uint256 internal lastAccountedGlobal; // This is the total amount of premiums paid (per second) by all the covered protocols (added up)   uint256 internal allPremiumsPerSecToStakers; // This is the amount that was claimable by stakers the last time the accounting was run   // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date   uint256 internal lastClaimablePremiumsForStakers; // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage   // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)   uint256 public override minActiveBalance; // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)   mapping(bytes32 =&gt; uint256) internal removedProtocolClaimDeadline; // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)   mapping(bytes32 =&gt; address) internal removedProtocolAgent; // Current amount of coverage (i.e. 20M USDC) for a protocol   mapping(bytes32 =&gt; uint256) internal currentCoverage; // Previous amount of coverage for a protocol   // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount   mapping(bytes32 =&gt; uint256) internal previousCoverage; // Setting the token to USDC   constructor(IERC20 _token) {     if (address(_token) == address(0)) revert ZeroArgument();     token = _token;   } // Modifier used to ensure a protocol exists (has been instantiated and not removed)   modifier protocolExists(bytes32 protocol) {     _verifyProtocolExists(_protocol);     ;   } /// @notice View current protocolAgent of _protocol   /// @param protocol Protocol identifier   /// @return Address able to submit claims   function protocolAgent(bytes32 _protocol) external view override returns (address) {     address agent = protocolAgent[_protocol];     if (agent != address(0)) return agent; // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned // Note: Old protocol agent will never be address(0) if (block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]) {   return removedProtocolAgent[_protocol]; }  // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned revert ProtocolNotExists(_protocol);  } // Checks if the protocol exists, then returns the current premium per second being charged   /// @notice View current premium of protocol   /// @param protocol Protocol identifier   /// @return Amount of premium _protocol pays per second   function premium(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return premiums[_protocol];   } // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)   // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)   function verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {     _protocolAgent = protocolAgent[_protocol];     if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);   } //   // View methods   // // Calcs the debt accrued by the protocol since it last had an accounting update   // This is the amount that needs to be removed from a protocol's active balance   function calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {     return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums[_protocol];   } /// @notice View the amount nonstakers can claim from this protocol   /// @param _protocol Protocol identifier   /// @return Amount of tokens claimable by nonstakers   /// @dev this reads from a storage variable + (now-lastsettled) * premiums   // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]   // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed   function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {     // Calcs the debt of a protocol since the last accounting update     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     // Gets the active balance of the protocol     uint256 balance = activeBalances[_protocol];     // The debt should never be higher than the balance (only happens if the arbitrages fail)     if (debt &gt; balance) debt = balance; // Adds the incremental claimable amount owed to nonstakers to the total claimable amount return   nonStakersClaimableByProtocol[_protocol] +   (nonStakersPercentage[_protocol] * debt) /   HUNDRED_PERCENT;  } /// @notice View current amount of all premiums that are owed to stakers   /// @return Premiums claimable   /// @dev Will increase every block   /// @dev base + (now - last_settled) * ps   function claimablePremiums() public view override returns (uint256) {     // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)     return       lastClaimablePremiumsForStakers +       (block.timestamp - lastAccountedGlobal) *       allPremiumsPerSecToStakers;   } /// @notice View seconds of coverage left for _protocol before it runs out of active balance   /// @param _protocol Protocol identifier   /// @return Seconds of coverage left   function secondsOfCoverageLeft(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return _secondsOfCoverageLeft(_protocol);   } // Helper function to return seconds of coverage left for a protocol   // Gets the current active balance of the protocol and divides by the premium per second for the protocol   function secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {     uint256 premium = premiums[_protocol];     if (premium == 0) return 0;     return _activeBalance(_protocol) / premium;   } /// @notice View current active balance of covered protocol   /// @param _protocol Protocol identifier   /// @return Active balance   /// @dev Accrued debt is subtracted from the stored active balance   function activeBalance(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return _activeBalance(_protocol);   } // Helper function to calc the active balance of a protocol at current time   function _activeBalance(bytes32 _protocol) internal view returns (uint256) {     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     uint256 balance = activeBalances[_protocol];     // The debt should never be higher than the balance (only happens if the arbitrages fail)     if (debt &gt; balance) return 0;     return balance - debt;   } //   // State methods   // /// @notice Helps set the premium per second for an individual protocol   /// @param protocol Protocol identifier   /// @param _premium New premium per second   /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function   function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)     internal     returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)   {     // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers     // Also updates the last accounted timestamp for this protocol     // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings     // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol     nonStakerPercentage = _settleProtocolDebt(_protocol);     // Stores the old premium before it gets updated     oldPremiumPerSecond = premiums[_protocol]; if (oldPremiumPerSecond != _premium) {   // Sets the protocol's premium per second to the new value   premiums_[_protocol] = _premium;   emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium); } // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point // Where arbs would no longer be incentivized to remove the protocol // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems if (_premium != 0 &amp;&amp; _secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_OF_COVERAGE) {   revert InsufficientBalance(_protocol); }  } /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second   /// @param _protocol Protocol identifier   /// @param _premium New premium per second   function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {     // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings     (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(       _protocol,       _premium     );     // Settling the total amount of premiums owed to stakers before a new premium per second gets set     _settleTotalDebt();     // This calculates the new global premium per second that gets paid to stakers     // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function     allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(       oldPremiumPerSecond,       _premium,       nonStakerPercentage,       nonStakerPercentage,       allPremiumsPerSecToStakers     );   } // Internal function to set a new protocolAgent for a specific protocol   // oldAgent is only included as part of emitting an event   function _setProtocolAgent(     bytes32 _protocol,     address _oldAgent,     address _protocolAgent   ) internal {     protocolAgent[_protocol] = _protocolAgent;     emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);   } // Subtracts the accrued debt from a protocol's active balance   // Credits the amount that can be claimed by nonstakers for this protocol   // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings   // Most of this function is dealing with an edge case related to a protocol not being removed by arbs   function settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {     // This calcs the accrued debt of the protocol since it was last updated     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     // This pulls the percentage that is sent to nonstakers     _nonStakerPercentage = nonStakersPercentage[_protocol];     // In case the protocol has accrued debt, this code block will ensure the debt is settled properly     if (debt != 0) {       // Pulls the stored active balance of the protocol       uint256 balance = activeBalances[_protocol];       // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance       // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point       // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage       // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up       if (debt &gt; balance) {         // This error amount represents the magnitude of the mistake         uint256 error = debt - balance;         // Gets the latest value of claimable premiums for stakers         _settleTotalDebt();         // @note to production, set premium first to zero before solving accounting issue.         // otherwise the accounting error keeps increasing         uint256 lastClaimablePremiumsForStakers = lastClaimablePremiumsForStakers;     // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%     uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /       HUNDRED_PERCENT;      // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short     uint256 insufficientTokens;      // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally     // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error     // This first line can be true if claimPremiumsForStakers() has been called and     // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be &gt;0 still     if (claimablePremiumError &gt; lastClaimablePremiumsForStakers_) {       insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;       lastClaimablePremiumsForStakers = 0;     } else {       // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums       // By the amount that was added in error (error) and insufficientTokens = 0       lastClaimablePremiumsForStakers =         lastClaimablePremiumsForStakers_ -         claimablePremiumError;     }      // If two events are thrown, the values need to be summed up for the actual state.     // This means an error of this type will continue until it is handled     emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);     // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case     debt = balance;   }   // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance   activeBalances[_protocol] = balance - debt;   // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol   nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT; } // Updates the last accounted timestamp for this protocol lastAccountedEachProtocol[_protocol] = block.timestamp;  } // Multiplies the total premium per second * number of seconds since the last global accounting update   // And adds it to the total claimable amount for stakers   function _settleTotalDebt() internal {     lastClaimablePremiumsForStakers +=       (block.timestamp - lastAccountedGlobal) *       allPremiumsPerSecToStakers;     lastAccountedGlobal = block.timestamp;   } // Calculates the global premium per second for stakers   // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers   // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones   function _calcGlobalPremiumPerSecForStakers(     uint256 _premiumOld,     uint256 _premiumNew,     uint256 _nonStakerPercentageOld,     uint256 _nonStakerPercentageNew,     uint256 _inMemAllPremiumsPerSecToStakers   ) internal pure returns (uint256) {     return       _inMemAllPremiumsPerSecToStakers +       ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /       HUNDRED_PERCENT -       ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /       HUNDRED_PERCENT;   } // Helper function to remove and clean up a protocol from Sherlock   // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made   function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {     // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol     _setSingleAndGlobalProtocolPremium(_protocol, 0); // Grabs the protocol's active balance uint256 balance = activeBalances[_protocol];  // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent if (balance != 0) {   delete activeBalances[_protocol];   token.safeTransfer(_agent, balance);    emit ProtocolBalanceWithdrawn(_protocol, balance); }  // Sets the protocol agent to zero address (as part of clean up) _setProtocolAgent(_protocol, _agent, address(0));  // Cleans up other mappings for this protocol delete nonStakersPercentage[_protocol]; delete lastAccountedEachProtocol[_protocol]; // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above  // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;  // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked removedProtocolAgent[_protocol] = _agent;  emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0)); emit ProtocolRemoved(_protocol);  } /// @notice Sets the minimum active balance before an arb can remove a protocol   /// @param _minActiveBalance Minimum balance needed (in USDC)   /// @dev Only gov   function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {     // New value cannot be the same as current value     if (minActiveBalance == _minActiveBalance) revert InvalidArgument();     // Can't set a value that is too high to be reasonable     if (_minActiveBalance &gt;= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions(); emit MinBalance(minActiveBalance, _minActiveBalance); minActiveBalance = _minActiveBalance;  } // This function allows the nonstakers role to claim tokens owed to them by a specific protocol   /// @notice Choose an _amount of tokens that nonstakers (_receiver address) will receive from _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens   /// @param _receiver Address to receive tokens   /// @dev Only callable by nonstakers role   function nonStakersClaim(     bytes32 _protocol,     uint256 _amount,     address _receiver   ) external override whenNotPaused {     if (_protocol == bytes32(0)) revert ZeroArgument();     if (_amount == uint256(0)) revert ZeroArgument();     if (_receiver == address(0)) revert ZeroArgument();     // Only the nonstakers role (multisig or contract) can pull the funds     if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized(); // Call can't be executed on protocol that is removed if (protocolAgent_[_protocol] != address(0)) {   // Updates the amount that nonstakers can claim from this protocol   _settleProtocolDebt(_protocol); }  // Sets balance to the amount that is claimable by nonstakers for this specific protocol uint256 balance = nonStakersClaimableByProtocol[_protocol]; // If the amount requested is more than what's owed to nonstakers, revert if (_amount &gt; balance) revert InsufficientBalance(_protocol);  // Sets the claimable amount to whatever is left over after this amount is pulled nonStakersClaimableByProtocol[_protocol] = balance - _amount; // Transfers the amount requested to the `_receiver` address token.safeTransfer(_receiver, _amount);  } // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)   /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address   /// @dev Callable by everyone   /// @dev Funds will be transferred to Sherlock core contract   function claimPremiumsForStakers() external override whenNotPaused {     // Gets address of core Sherlock contract     address sherlock = address(sherlockCore);     // Revert if core Sherlock contract not initialized yet     if (sherlock == address(0)) revert InvalidConditions(); // claimablePremiums is different from _settleTotalDebt() because it does not change state // Retrieves current amount of all premiums that are owed to stakers uint256 amount = claimablePremiums();  // Transfers all the premiums owed to stakers to the Sherlock core contract if (amount != 0) {   // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out   lastClaimablePremiumsForStakers = 0;   lastAccountedGlobal = block.timestamp;   token.safeTransfer(sherlock, amount); }  } // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts   /// @param protocol Protocol identifier   /// @return current and previous are the current and previous coverage amounts for this protocol   // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)   function coverageAmounts(bytes32 _protocol)     external     view     override     returns (uint256 current, uint256 previous)   {     // Checks to see if the protocol has an active protocolAgent (protocol not removed)     // OR checks to see if the removed protocol is still within the claim window     // If so, gives the current and previous coverage, otherwise throws an error     if (       protocolAgent[_protocol] != address(0) ||       block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]     ) {       return (currentCoverage[_protocol], previousCoverage[_protocol]);     } revert ProtocolNotExists(_protocol);  } /// @notice Add a new protocol to Sherlock   /// @param protocol Protocol identifier   /// @param _protocolAgent Address able to submit a claim on behalf of the protocol   /// @param _coverage Hash referencing the active coverage agreement   /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 1018   /// @param _coverageAmount Max amount claimable by this protocol   /// @dev Adding a protocol allows the _protocolAgent to submit a claim   /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point   /// @dev _nonStakers is scaled by 1018   /// @dev Only callable by governance   function protocolAdd(     bytes32 _protocol,     address _protocolAgent,     bytes32 _coverage,     uint256 _nonStakers,     uint256 _coverageAmount   ) external override onlyOwner {     if (_protocol == bytes32(0)) revert ZeroArgument();     if (_protocolAgent == address(0)) revert ZeroArgument();     // Checks to make sure the protocol doesn't exist already     if (protocolAgent[_protocol] != address(0)) revert InvalidConditions(); // Updates the protocol agent and passes in the old agent which is 0 address in this case _setProtocolAgent(_protocol, address(0), _protocolAgent);  // Delete mappings that are potentially non default values // From previous time protocol was added/removed delete removedProtocolClaimDeadline[_protocol]; delete removedProtocolAgent[_protocol]; delete currentCoverage[_protocol]; delete previousCoverage[_protocol];  emit ProtocolAdded(_protocol);  // Most of the logic for actually adding a protocol in this function protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);  } /// @notice Update info regarding a protocol   /// @param _protocol Protocol identifier   /// @param _coverage Hash referencing the active coverage agreement   /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18   /// @param _coverageAmount Max amount claimable by this protocol   /// @dev Only callable by governance   /// @dev _nonStakers can be 0   function protocolUpdate(     bytes32 _protocol,     bytes32 _coverage,     uint256 _nonStakers,     uint256 _coverageAmount   ) public override onlyOwner {     if (_coverage == bytes32(0)) revert ZeroArgument();     if (_nonStakers &gt; HUNDRED_PERCENT) revert InvalidArgument();     if (_coverageAmount == uint256(0)) revert ZeroArgument(); // Checks to make sure the protocol has been assigned a protocol agent _verifyProtocolExists(_protocol);  // Subtracts the accrued debt from a protocol's active balance (if any) // Updates the amount that can be claimed by nonstakers _settleProtocolDebt(_protocol);  // Updates the global claimable amount for stakers _settleTotalDebt();  // Gets the premium per second for this protocol uint256 premium = premiums_[_protocol];  // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be) allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(   premium,   premium,   nonStakersPercentage[_protocol],   _nonStakers,   allPremiumsPerSecToStakers );  // Updates the stored value of percentage of premiums that go to nonstakers nonStakersPercentage[_protocol] = _nonStakers;  // Updates previous coverage and current coverage amounts previousCoverage[_protocol] = currentCoverage[_protocol]; currentCoverage[_protocol] = _coverageAmount;  emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);  } /// @notice Remove a protocol from coverage   /// @param _protocol Protocol identifier   /// @dev Before removing a protocol the premium must be 0   /// @dev Removing a protocol basically stops the _protocolAgent from being active (can still submit claims until claim deadline though)   /// @dev Pays off debt + sends remaining balance to protocol agent   /// @dev This call should be subject to a timelock   /// @dev Only callable by governance   function protocolRemove(bytes32 _protocol) external override onlyOwner {     // checks to make sure the protocol actually has a protocol agent     address agent = _verifyProtocolExists(_protocol); // Removes a protocol from Sherlock and cleans up its data // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made _forceRemoveProtocol(_protocol, agent);  } /// @notice Remove a protocol with insufficient active balance   /// @param _protocol Protocol identifier   // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function   function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {     address agent = _verifyProtocolExists(_protocol); // Gets the latest value of the active balance at this protocol _settleProtocolDebt(_protocol); // Sets latest value of active balance to remainingBalance variable uint256 remainingBalance = activeBalances[_protocol];  // This means the protocol still has adequate active balance and thus cannot be removed if (remainingBalance &gt;= minActiveBalance) revert InvalidConditions();  // Sets the protocol's active balance to 0 delete activeBalances[_protocol]; // Removes the protocol from coverage _forceRemoveProtocol(_protocol, agent);  if (remainingBalance != 0) {   // sends the remaining balance to msg.sender   token.safeTransfer(msg.sender, remainingBalance); } emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);  } /// @notice Calculate if arb is possible and what the reward would be   /// @param _protocol Protocol identifier   /// @return arbAmount Amount reward for arbing   /// @return able Indicator if arb call is even possible   /// @dev Doesn't subtract the current protocol debt from the active balance   function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)     internal     view     returns (uint256 arbAmount, bool able)   {     uint256 secondsLeft = _secondsOfCoverageLeft(_protocol); // If arb is not possible return false if (secondsLeft &gt;= MIN_SECONDS_OF_COVERAGE) return (0, false);  // This percentage scales over time // Reaches 100% on 0 seconds of coverage left uint256 percentageScaled = HUNDRED_PERCENT -   (secondsLeft * HUNDRED_PERCENT) /   MIN_SECONDS_OF_COVERAGE;  able = true; arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;  } /// @notice Removes a protocol with insufficent seconds of coverage left   /// @param _protocol Protocol identifier   // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second   function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {     // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings     address agent = _verifyProtocolExists(_protocol); // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance() // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance() // But when removing based on seconds of coverage left, the remainingBalance could still be quite large // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%) _settleProtocolDebt(_protocol); (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol); if (able == false) revert InvalidConditions();  if (arbAmount != 0) {   // subtracts the amount that will be paid to the arb from the active balance   activeBalances[_protocol] -= arbAmount; }  // Removes the protocol from coverage // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above _forceRemoveProtocol(_protocol, agent);  // Done after removing protocol to mitigate reentrency pattern // (In case token allows callback) if (arbAmount != 0) {   token.safeTransfer(msg.sender, arbAmount); } emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);  } /// @notice Set premium of _protocol to _premium   /// @param _protocol Protocol identifier   /// @param _premium Amount of premium _protocol pays per second   /// @dev The value 0 would mean inactive coverage   /// @dev Only callable by governance   function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {     // Checks to see if protocol has a protocol agent     _verifyProtocolExists(_protocol); // Updates individual protocol's premium and allPremiumsPerSecToStakers _setSingleAndGlobalProtocolPremium(_protocol, _premium);  } /// @notice Set premium of multiple protocols   /// @param _protocol Array of protocol identifiers   /// @param _premium Array of premium amounts protocols pay per second   /// @dev The value 0 would mean inactive coverage   /// @dev Only callable by governance   function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)     external     override     onlyOwner   {     // Checks to make sure there are an equal amount of entries in each array     if (_protocol.length != _premium.length) revert UnequalArrayLength();     if (_protocol.length == 0) revert InvalidArgument(); // Updates the global claimable amount for stakers _settleTotalDebt();  uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;  // Loops through the array of protocols and checks to make sure each has a protocol agent assigned for (uint256 i; i &lt; _protocol.length; i++) {   _verifyProtocolExists(_protocol[i]);    // Sets the protocol premium for that specific protocol   // Function returns the old premium and nonStakerPercentage for that specific protocol   (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(     _protocol[i],     _premium[i]   );    // Calculates the new global premium which adds up all premiums paid by all protocols   allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(     oldPremiumPerSecond,     _premium[i],     nonStakerPercentage,     nonStakerPercentage,     allPremiumsPerSecToStakers_   ); }  // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;  } // This is how protocols pay for coverage by increasing their active balance   /// @notice Deposits _amount of token to the active balance of _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens to deposit   /// @dev Approval should be made before calling   function depositToActiveBalance(bytes32 _protocol, uint256 _amount)     external     override     whenNotPaused   {     if (_amount == uint256(0)) revert ZeroArgument();     _verifyProtocolExists(_protocol); // Transfers _amount to this contract token.safeTransferFrom(msg.sender, address(this), _amount); // Increases the active balance of the protocol by _amount activeBalances[_protocol] += _amount;  emit ProtocolBalanceDeposited(_protocol, _amount);  } // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)   // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)   /// @notice Withdraws _amount of token from the active balance of _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens to withdraw   /// @dev Only protocol agent is able to withdraw   /// @dev Balance can be withdrawn up until 7 days worth of active balance   function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)     external     override     whenNotPaused   {     if (_amount == uint256(0)) revert ZeroArgument();     // Only the protocol agent can call this function     if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized(); // Updates the active balance of the protocol _settleProtocolDebt(_protocol);  // Sets currentBalance to the active balance of the protocol uint256 currentBalance = activeBalances[_protocol]; // Reverts if trying to withdraw more than the active balance if (_amount &gt; currentBalance) revert InsufficientBalance(_protocol);  // Removes the _amount to be withdrawn from the active balance activeBalances[_protocol] = currentBalance - _amount; // Reverts if a protocol has less than 7 days worth of active balance left if (_secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);  // Transfers the amount to the msg.sender (protocol agent) token.safeTransfer(msg.sender, _amount); emit ProtocolBalanceWithdrawn(_protocol, _amount);  } /// @notice Transfer protocol agent role   /// @param _protocol Protocol identifier   /// @param _protocolAgent Account able to submit a claim on behalf of the protocol   /// @dev Only the active protocolAgent is able to transfer the role   function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)     external     override     whenNotPaused   {     if (_protocolAgent == address(0)) revert ZeroArgument();     // Can't set the new protocol agent to the caller address     if (msg.sender == _protocolAgent) revert InvalidArgument();     // Because the caller must be the current protocol agent     if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized(); // Sets the protocol agent to the new address _setProtocolAgent(_protocol, msg.sender, _protocolAgent);  } /// @notice Function used to check if this is the current active protocol manager   /// @return Boolean indicating it's active   /// @dev If inactive the owner can pull all ERC20s and ETH   /// @dev Will be checked by calling the sherlock contract   function isActive() public view returns (bool) {     return address(sherlockCore.sherlockProtocolManager()) == address(this);   } // Only contract owner can call this   // Sends all specified tokens in this contract to the receiver's address (as well as ETH)   function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {     if (_receiver == address(0)) revert ZeroArgument();     // This contract must NOT be the current assigned protocol manager contract     if (isActive()) revert InvalidConditions();     // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH     _sweep(_receiver, _extraTokens);   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-25-08 10:58:59 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import './Manager.sol';
import '../interfaces/managers/ISherlockProtocolManager.sol';

/// @title Sherlock core interface for protocols
/// @author Evert Kors
// This is the contract that manages covered protocols

contract SherlockProtocolManager is ISherlockProtocolManager, Manager {
  using SafeERC20 for IERC20;

  // Represents the token that protocols pay with (currently USDC)
  IERC20 public immutable token;

  // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed
  uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc

  // A removed protocol is still able to make a claim for this amount of time after its removal
  uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days;

  // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance
  uint256 public constant MIN_SECONDS_LEFT = 7 days;

  // Convenient for percentage calculations
  uint256 internal constant HUNDRED_PERCENT = 10**18;

  // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage
  // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying
  uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours;

  // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)
  mapping(bytes32 => address) internal protocolAgent_;

  // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)
  mapping(bytes32 => uint256) internal nonStakersPercentage;

  // The premium per second paid by each protocol is stored in this mapping
  mapping(bytes32 => uint256) internal premiums_;

  // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.
  // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not
  mapping(bytes32 => uint256) internal activeBalances;

  // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol
  mapping(bytes32 => uint256) internal lastAccountedEachProtocol;

  // The amount that can be claimed by nonstakers for each protocol
  // We need this value so we can track how much payment is coming from each protocol
  mapping(bytes32 => uint256) internal nonStakersClaimableByProtocol;

  // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)
  uint256 internal lastAccountedGlobal;

  // This is the total amount of premiums paid (per second) by all the covered protocols (added up)
  uint256 internal allPremiumsPerSecToStakers;

  // This is the amount that was claimable by stakers the last time the accounting was run
  // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date
  uint256 internal lastClaimablePremiumsForStakers;

  // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage
  // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)
  uint256 public override minActiveBalance;

  // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)
  mapping(bytes32 => uint256) internal removedProtocolClaimDeadline;

  // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)
  mapping(bytes32 => address) internal removedProtocolAgent;

  // Current amount of coverage (i.e. 20M USDC) for a protocol
  mapping(bytes32 => uint256) internal currentCoverage;

  // Previous amount of coverage for a protocol
  // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount
  mapping(bytes32 => uint256) internal previousCoverage;

  // Setting the token to USDC
  constructor(IERC20 _token) {
    if (address(_token) == address(0)) revert ZeroArgument();
    token = _token;
  }

  // Modifier used to ensure a protocol exists (has been instantiated and not removed)
  modifier protocolExists(bytes32 _protocol) {
    _verifyProtocolExists(_protocol);
    _;
  }

  /// @notice View current protocolAgent of `_protocol`
  /// @param _protocol Protocol identifier
  /// @return Address able to submit claims
  function protocolAgent(bytes32 _protocol) external view override returns (address) {
    address agent = protocolAgent_[_protocol];
    if (agent != address(0)) return agent;

    // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned
    // Note: Old protocol agent will never be address(0)
    if (block.timestamp <= removedProtocolClaimDeadline[_protocol]) {
      return removedProtocolAgent[_protocol];
    }

    // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned
    revert ProtocolNotExists(_protocol);
  }

  // Checks if the protocol exists, then returns the current premium per second being charged
  /// @notice View current premium of protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of premium `_protocol` pays per second
  function premium(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return premiums_[_protocol];
  }

  // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)
  // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)
  function _verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {
    _protocolAgent = protocolAgent_[_protocol];
    if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);
  }

  //
  // View methods
  //

  // Calcs the debt accrued by the protocol since it last had an accounting update
  // This is the amount that needs to be removed from a protocol's active balance
  function _calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {
    return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums_[_protocol];
  }

  /// @notice View the amount nonstakers can claim from this protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of tokens claimable by nonstakers
  /// @dev this reads from a storage variable + (now-lastsettled) * premiums
  // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]
  // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed
  function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {
    // Calcs the debt of a protocol since the last accounting update
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // Gets the active balance of the protocol
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) debt = balance;

    // Adds the incremental claimable amount owed to nonstakers to the total claimable amount
    return
      nonStakersClaimableByProtocol[_protocol] +
      (nonStakersPercentage[_protocol] * debt) /
      HUNDRED_PERCENT;
  }

  /// @notice View current amount of all premiums that are owed to stakers
  /// @return Premiums claimable
  /// @dev Will increase every block
  /// @dev base + (now - last_settled) * ps
  function claimablePremiums() public view override returns (uint256) {
    // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)
    return
      lastClaimablePremiumsForStakers +
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
  }

  /// @notice View seconds of coverage left for `_protocol` before it runs out of active balance
  /// @param _protocol Protocol identifier
  /// @return Seconds of coverage left
  function secondsOfCoverageLeft(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _secondsOfCoverageLeft(_protocol);
  }

  // Helper function to return seconds of coverage left for a protocol
  // Gets the current active balance of the protocol and divides by the premium per second for the protocol
  function _secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {
    uint256 premium = premiums_[_protocol];
    if (premium == 0) return 0;
    return _activeBalance(_protocol) / premium;
  }

  /// @notice View current active balance of covered protocol
  /// @param _protocol Protocol identifier
  /// @return Active balance
  /// @dev Accrued debt is subtracted from the stored active balance
  function activeBalance(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _activeBalance(_protocol);
  }

  // Helper function to calc the active balance of a protocol at current time
  function _activeBalance(bytes32 _protocol) internal view returns (uint256) {
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) return 0;
    return balance - debt;
  }

  //
  // State methods
  //

  /// @notice Helps set the premium per second for an individual protocol
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function
  function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)
    internal
    returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)
  {
    // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers
    // Also updates the last accounted timestamp for this protocol
    // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings
    // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol
    nonStakerPercentage = _settleProtocolDebt(_protocol);
    // Stores the old premium before it gets updated
    oldPremiumPerSecond = premiums_[_protocol];

    if (oldPremiumPerSecond != _premium) {
      // Sets the protocol's premium per second to the new value
      premiums_[_protocol] = _premium;
      emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium);
    }
    // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing
    // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes
    // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point
    // Where arbs would no longer be incentivized to remove the protocol
    // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems
    if (_premium != 0 && _secondsOfCoverageLeft(_protocol) < MIN_SECONDS_OF_COVERAGE) {
      revert InsufficientBalance(_protocol);
    }
  }

  /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {
    // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings
    (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
      _protocol,
      _premium
    );
    // Settling the total amount of premiums owed to stakers before a new premium per second gets set
    _settleTotalDebt();
    // This calculates the new global premium per second that gets paid to stakers
    // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      oldPremiumPerSecond,
      _premium,
      nonStakerPercentage,
      nonStakerPercentage,
      allPremiumsPerSecToStakers
    );
  }

  // Internal function to set a new protocolAgent for a specific protocol
  // _oldAgent is only included as part of emitting an event
  function _setProtocolAgent(
    bytes32 _protocol,
    address _oldAgent,
    address _protocolAgent
  ) internal {
    protocolAgent_[_protocol] = _protocolAgent;
    emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);
  }

  // Subtracts the accrued debt from a protocol's active balance
  // Credits the amount that can be claimed by nonstakers for this protocol
  // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings
  // Most of this function is dealing with an edge case related to a protocol not being removed by arbs
  function _settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {
    // This calcs the accrued debt of the protocol since it was last updated
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // This pulls the percentage that is sent to nonstakers
    _nonStakerPercentage = nonStakersPercentage[_protocol];
    // In case the protocol has accrued debt, this code block will ensure the debt is settled properly
    if (debt != 0) {
      // Pulls the stored active balance of the protocol
      uint256 balance = activeBalances[_protocol];
      // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance
      // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point
      // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage
      // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up
      if (debt > balance) {
        // This error amount represents the magnitude of the mistake
        uint256 error = debt - balance;
        // Gets the latest value of claimable premiums for stakers
        _settleTotalDebt();
        // @note to production, set premium first to zero before solving accounting issue.
        // otherwise the accounting error keeps increasing
        uint256 lastClaimablePremiumsForStakers_ = lastClaimablePremiumsForStakers;

        // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%
        uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /
          HUNDRED_PERCENT;

        // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short
        uint256 insufficientTokens;

        // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally
        // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error
        // This first line can be true if claimPremiumsForStakers() has been called and
        // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be >0 still
        if (claimablePremiumError > lastClaimablePremiumsForStakers_) {
          insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;
          lastClaimablePremiumsForStakers = 0;
        } else {
          // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums
          // By the amount that was added in error (error) and insufficientTokens = 0
          lastClaimablePremiumsForStakers =
            lastClaimablePremiumsForStakers_ -
            claimablePremiumError;
        }

        // If two events are thrown, the values need to be summed up for the actual state.
        // This means an error of this type will continue until it is handled
        emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);
        // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case
        debt = balance;
      }
      // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance
      activeBalances[_protocol] = balance - debt;
      // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol
      nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT;
    }
    // Updates the last accounted timestamp for this protocol
    lastAccountedEachProtocol[_protocol] = block.timestamp;
  }

  // Multiplies the total premium per second * number of seconds since the last global accounting update
  // And adds it to the total claimable amount for stakers
  function _settleTotalDebt() internal {
    lastClaimablePremiumsForStakers +=
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
    lastAccountedGlobal = block.timestamp;
  }

  // Calculates the global premium per second for stakers
  // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers
  // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones
  function _calcGlobalPremiumPerSecForStakers(
    uint256 _premiumOld,
    uint256 _premiumNew,
    uint256 _nonStakerPercentageOld,
    uint256 _nonStakerPercentageNew,
    uint256 _inMemAllPremiumsPerSecToStakers
  ) internal pure returns (uint256) {
    return
      _inMemAllPremiumsPerSecToStakers +
      ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /
      HUNDRED_PERCENT -
      ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /
      HUNDRED_PERCENT;
  }

  // Helper function to remove and clean up a protocol from Sherlock
  // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made
  function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {
    // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol
    _setSingleAndGlobalProtocolPremium(_protocol, 0);

    // Grabs the protocol's active balance
    uint256 balance = activeBalances[_protocol];

    // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent
    if (balance != 0) {
      delete activeBalances[_protocol];
      token.safeTransfer(_agent, balance);

      emit ProtocolBalanceWithdrawn(_protocol, balance);
    }

    // Sets the protocol agent to zero address (as part of clean up)
    _setProtocolAgent(_protocol, _agent, address(0));

    // Cleans up other mappings for this protocol
    delete nonStakersPercentage[_protocol];
    delete lastAccountedEachProtocol[_protocol];
    // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above

    // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol
    removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;

    // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed
    // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked
    removedProtocolAgent[_protocol] = _agent;

    emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0));
    emit ProtocolRemoved(_protocol);
  }

  /// @notice Sets the minimum active balance before an arb can remove a protocol
  /// @param _minActiveBalance Minimum balance needed (in USDC)
  /// @dev Only gov
  function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {
    // New value cannot be the same as current value
    if (minActiveBalance == _minActiveBalance) revert InvalidArgument();
    // Can't set a value that is too high to be reasonable
    if (_minActiveBalance >= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions();

    emit MinBalance(minActiveBalance, _minActiveBalance);
    minActiveBalance = _minActiveBalance;
  }

  // This function allows the nonstakers role to claim tokens owed to them by a specific protocol
  /// @notice Choose an `_amount` of tokens that nonstakers (`_receiver` address) will receive from `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens
  /// @param _receiver Address to receive tokens
  /// @dev Only callable by nonstakers role
  function nonStakersClaim(
    bytes32 _protocol,
    uint256 _amount,
    address _receiver
  ) external override whenNotPaused {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_amount == uint256(0)) revert ZeroArgument();
    if (_receiver == address(0)) revert ZeroArgument();
    // Only the nonstakers role (multisig or contract) can pull the funds
    if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized();

    // Call can't be executed on protocol that is removed
    if (protocolAgent_[_protocol] != address(0)) {
      // Updates the amount that nonstakers can claim from this protocol
      _settleProtocolDebt(_protocol);
    }

    // Sets balance to the amount that is claimable by nonstakers for this specific protocol
    uint256 balance = nonStakersClaimableByProtocol[_protocol];
    // If the amount requested is more than what's owed to nonstakers, revert
    if (_amount > balance) revert InsufficientBalance(_protocol);

    // Sets the claimable amount to whatever is left over after this amount is pulled
    nonStakersClaimableByProtocol[_protocol] = balance - _amount;
    // Transfers the amount requested to the `_receiver` address
    token.safeTransfer(_receiver, _amount);
  }

  // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)
  /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address
  /// @dev Callable by everyone
  /// @dev Funds will be transferred to Sherlock core contract
  function claimPremiumsForStakers() external override whenNotPaused {
    // Gets address of core Sherlock contract
    address sherlock = address(sherlockCore);
    // Revert if core Sherlock contract not initialized yet
    if (sherlock == address(0)) revert InvalidConditions();

    // claimablePremiums is different from _settleTotalDebt() because it does not change state
    // Retrieves current amount of all premiums that are owed to stakers
    uint256 amount = claimablePremiums();

    // Transfers all the premiums owed to stakers to the Sherlock core contract
    if (amount != 0) {
      // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out
      lastClaimablePremiumsForStakers = 0;
      lastAccountedGlobal = block.timestamp;
      token.safeTransfer(sherlock, amount);
    }
  }

  // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts
  /// @param _protocol Protocol identifier
  /// @return current and previous are the current and previous coverage amounts for this protocol
  // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)
  function coverageAmounts(bytes32 _protocol)
    external
    view
    override
    returns (uint256 current, uint256 previous)
  {
    // Checks to see if the protocol has an active protocolAgent (protocol not removed)
    // OR checks to see if the removed protocol is still within the claim window
    // If so, gives the current and previous coverage, otherwise throws an error
    if (
      protocolAgent_[_protocol] != address(0) ||
      block.timestamp <= removedProtocolClaimDeadline[_protocol]
    ) {
      return (currentCoverage[_protocol], previousCoverage[_protocol]);
    }

    revert ProtocolNotExists(_protocol);
  }

  /// @notice Add a new protocol to Sherlock
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Address able to submit a claim on behalf of the protocol
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Adding a protocol allows the `_protocolAgent` to submit a claim
  /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point
  /// @dev `_nonStakers` is scaled by 10**18
  /// @dev Only callable by governance
  function protocolAdd(
    bytes32 _protocol,
    address _protocolAgent,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) external override onlyOwner {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Checks to make sure the protocol doesn't exist already
    if (protocolAgent_[_protocol] != address(0)) revert InvalidConditions();

    // Updates the protocol agent and passes in the old agent which is 0 address in this case
    _setProtocolAgent(_protocol, address(0), _protocolAgent);

    // Delete mappings that are potentially non default values
    // From previous time protocol was added/removed
    delete removedProtocolClaimDeadline[_protocol];
    delete removedProtocolAgent[_protocol];
    delete currentCoverage[_protocol];
    delete previousCoverage[_protocol];

    emit ProtocolAdded(_protocol);

    // Most of the logic for actually adding a protocol in this function
    protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Update info regarding a protocol
  /// @param _protocol Protocol identifier
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Only callable by governance
  /// @dev `_nonStakers` can be 0
  function protocolUpdate(
    bytes32 _protocol,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) public override onlyOwner {
    if (_coverage == bytes32(0)) revert ZeroArgument();
    if (_nonStakers > HUNDRED_PERCENT) revert InvalidArgument();
    if (_coverageAmount == uint256(0)) revert ZeroArgument();

    // Checks to make sure the protocol has been assigned a protocol agent
    _verifyProtocolExists(_protocol);

    // Subtracts the accrued debt from a protocol's active balance (if any)
    // Updates the amount that can be claimed by nonstakers
    _settleProtocolDebt(_protocol);

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    // Gets the premium per second for this protocol
    uint256 premium = premiums_[_protocol];

    // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be)
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      premium,
      premium,
      nonStakersPercentage[_protocol],
      _nonStakers,
      allPremiumsPerSecToStakers
    );

    // Updates the stored value of percentage of premiums that go to nonstakers
    nonStakersPercentage[_protocol] = _nonStakers;

    // Updates previous coverage and current coverage amounts
    previousCoverage[_protocol] = currentCoverage[_protocol];
    currentCoverage[_protocol] = _coverageAmount;

    emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Remove a protocol from coverage
  /// @param _protocol Protocol identifier
  /// @dev Before removing a protocol the premium must be 0
  /// @dev Removing a protocol basically stops the `_protocolAgent` from being active (can still submit claims until claim deadline though)
  /// @dev Pays off debt + sends remaining balance to protocol agent
  /// @dev This call should be subject to a timelock
  /// @dev Only callable by governance
  function protocolRemove(bytes32 _protocol) external override onlyOwner {
    // checks to make sure the protocol actually has a protocol agent
    address agent = _verifyProtocolExists(_protocol);

    // Removes a protocol from Sherlock and cleans up its data
    // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made
    _forceRemoveProtocol(_protocol, agent);
  }

  /// @notice Remove a protocol with insufficient active balance
  /// @param _protocol Protocol identifier
  // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function
  function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {
    address agent = _verifyProtocolExists(_protocol);

    // Gets the latest value of the active balance at this protocol
    _settleProtocolDebt(_protocol);
    // Sets latest value of active balance to remainingBalance variable
    uint256 remainingBalance = activeBalances[_protocol];

    // This means the protocol still has adequate active balance and thus cannot be removed
    if (remainingBalance >= minActiveBalance) revert InvalidConditions();

    // Sets the protocol's active balance to 0
    delete activeBalances[_protocol];
    // Removes the protocol from coverage
    _forceRemoveProtocol(_protocol, agent);

    if (remainingBalance != 0) {
      // sends the remaining balance to msg.sender
      token.safeTransfer(msg.sender, remainingBalance);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);
  }

  /// @notice Calculate if arb is possible and what the reward would be
  /// @param _protocol Protocol identifier
  /// @return arbAmount Amount reward for arbing
  /// @return able Indicator if arb call is even possible
  /// @dev Doesn't subtract the current protocol debt from the active balance
  function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)
    internal
    view
    returns (uint256 arbAmount, bool able)
  {
    uint256 secondsLeft = _secondsOfCoverageLeft(_protocol);

    // If arb is not possible return false
    if (secondsLeft >= MIN_SECONDS_OF_COVERAGE) return (0, false);

    // This percentage scales over time
    // Reaches 100% on 0 seconds of coverage left
    uint256 percentageScaled = HUNDRED_PERCENT -
      (secondsLeft * HUNDRED_PERCENT) /
      MIN_SECONDS_OF_COVERAGE;

    able = true;
    arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;
  }

  /// @notice Removes a protocol with insufficent seconds of coverage left
  /// @param _protocol Protocol identifier
  // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second
  function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {
    // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings
    address agent = _verifyProtocolExists(_protocol);

    // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance()
    // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance()
    // But when removing based on seconds of coverage left, the remainingBalance could still be quite large
    // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance
    // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%)
    _settleProtocolDebt(_protocol);
    (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol);
    if (able == false) revert InvalidConditions();

    if (arbAmount != 0) {
      // subtracts the amount that will be paid to the arb from the active balance
      activeBalances[_protocol] -= arbAmount;
    }

    // Removes the protocol from coverage
    // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above
    _forceRemoveProtocol(_protocol, agent);

    // Done after removing protocol to mitigate reentrency pattern
    // (In case token allows callback)
    if (arbAmount != 0) {
      token.safeTransfer(msg.sender, arbAmount);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);
  }

  /// @notice Set premium of `_protocol` to `_premium`
  /// @param _protocol Protocol identifier
  /// @param _premium Amount of premium `_protocol` pays per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {
    // Checks to see if protocol has a protocol agent
    _verifyProtocolExists(_protocol);

    // Updates individual protocol's premium and allPremiumsPerSecToStakers
    _setSingleAndGlobalProtocolPremium(_protocol, _premium);
  }

  /// @notice Set premium of multiple protocols
  /// @param _protocol Array of protocol identifiers
  /// @param _premium Array of premium amounts protocols pay per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)
    external
    override
    onlyOwner
  {
    // Checks to make sure there are an equal amount of entries in each array
    if (_protocol.length != _premium.length) revert UnequalArrayLength();
    if (_protocol.length == 0) revert InvalidArgument();

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;

    // Loops through the array of protocols and checks to make sure each has a protocol agent assigned
    for (uint256 i; i < _protocol.length; i++) {
      _verifyProtocolExists(_protocol[i]);

      // Sets the protocol premium for that specific protocol
      // Function returns the old premium and nonStakerPercentage for that specific protocol
      (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
        _protocol[i],
        _premium[i]
      );

      // Calculates the new global premium which adds up all premiums paid by all protocols
      allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(
        oldPremiumPerSecond,
        _premium[i],
        nonStakerPercentage,
        nonStakerPercentage,
        allPremiumsPerSecToStakers_
      );
    }

    // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value
    allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;
  }

  // This is how protocols pay for coverage by increasing their active balance
  /// @notice Deposits `_amount` of token to the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to deposit
  /// @dev Approval should be made before calling
  function depositToActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    _verifyProtocolExists(_protocol);

    // Transfers _amount to this contract
    token.safeTransferFrom(msg.sender, address(this), _amount);
    // Increases the active balance of the protocol by _amount
    activeBalances[_protocol] += _amount;

    emit ProtocolBalanceDeposited(_protocol, _amount);
  }

  // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)
  // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)
  /// @notice Withdraws `_amount` of token from the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to withdraw
  /// @dev Only protocol agent is able to withdraw
  /// @dev Balance can be withdrawn up until 7 days worth of active balance
  function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    // Only the protocol agent can call this function
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Updates the active balance of the protocol
    _settleProtocolDebt(_protocol);

    // Sets currentBalance to the active balance of the protocol
    uint256 currentBalance = activeBalances[_protocol];
    // Reverts if trying to withdraw more than the active balance
    if (_amount > currentBalance) revert InsufficientBalance(_protocol);

    // Removes the _amount to be withdrawn from the active balance
    activeBalances[_protocol] = currentBalance - _amount;
    // Reverts if a protocol has less than 7 days worth of active balance left
    if (_secondsOfCoverageLeft(_protocol) < MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);

    // Transfers the amount to the msg.sender (protocol agent)
    token.safeTransfer(msg.sender, _amount);
    emit ProtocolBalanceWithdrawn(_protocol, _amount);
  }

  /// @notice Transfer protocol agent role
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Account able to submit a claim on behalf of the protocol
  /// @dev Only the active protocolAgent is able to transfer the role
  function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)
    external
    override
    whenNotPaused
  {
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Can't set the new protocol agent to the caller address
    if (msg.sender == _protocolAgent) revert InvalidArgument();
    // Because the caller must be the current protocol agent
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Sets the protocol agent to the new address
    _setProtocolAgent(_protocol, msg.sender, _protocolAgent);
  }

  /// @notice Function used to check if this is the current active protocol manager
  /// @return Boolean indicating it's active
  /// @dev If inactive the owner can pull all ERC20s and ETH
  /// @dev Will be checked by calling the sherlock contract
  function isActive() public view returns (bool) {
    return address(sherlockCore.sherlockProtocolManager()) == address(this);
  }

  // Only contract owner can call this
  // Sends all specified tokens in this contract to the receiver's address (as well as ETH)
  function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {
    if (_receiver == address(0)) revert ZeroArgument();
    // This contract must NOT be the current assigned protocol manager contract
    if (isActive()) revert InvalidConditions();
    // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH
    _sweep(_receiver, _extraTokens);
  }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-25-08 10:59:08 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-25-08 10:59:08 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 9206
completion_tokens: 820
total_tokens: 10026
cost: $-1.000000


[2024-25-08 10:59:09 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import './Manager.sol';
import '../interfaces/managers/ISherlockProtocolManager.sol';

/// @title Sherlock core interface for protocols
/// @author Evert Kors
// This is the contract that manages covered protocols

contract SherlockProtocolManager is ISherlockProtocolManager, Manager {
  using SafeERC20 for IERC20;

  // Represents the token that protocols pay with (currently USDC)
  IERC20 public immutable token;

  // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed
  uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc

  // A removed protocol is still able to make a claim for this amount of time after its removal
  uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days;

  // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance
  uint256 public constant MIN_SECONDS_LEFT = 7 days;

  // Convenient for percentage calculations
  uint256 internal constant HUNDRED_PERCENT = 10**18;

  // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage
  // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying
  uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours;

  // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)
  mapping(bytes32 => address) internal protocolAgent_;

  // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)
  mapping(bytes32 => uint256) internal nonStakersPercentage;

  // The premium per second paid by each protocol is stored in this mapping
  mapping(bytes32 => uint256) internal premiums_;

  // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.
  // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not
  mapping(bytes32 => uint256) internal activeBalances;

  // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol
  mapping(bytes32 => uint256) internal lastAccountedEachProtocol;

  // The amount that can be claimed by nonstakers for each protocol
  // We need this value so we can track how much payment is coming from each protocol
  mapping(bytes32 => uint256) internal nonStakersClaimableByProtocol;

  // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)
  uint256 internal lastAccountedGlobal;

  // This is the total amount of premiums paid (per second) by all the covered protocols (added up)
  uint256 internal allPremiumsPerSecToStakers;

  // This is the amount that was claimable by stakers the last time the accounting was run
  // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date
  uint256 internal lastClaimablePremiumsForStakers;

  // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage
  // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)
  uint256 public override minActiveBalance;

  // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)
  mapping(bytes32 => uint256) internal removedProtocolClaimDeadline;

  // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)
  mapping(bytes32 => address) internal removedProtocolAgent;

  // Current amount of coverage (i.e. 20M USDC) for a protocol
  mapping(bytes32 => uint256) internal currentCoverage;

  // Previous amount of coverage for a protocol
  // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount
  mapping(bytes32 => uint256) internal previousCoverage;

  // Setting the token to USDC
  constructor(IERC20 _token) {
    if (address(_token) == address(0)) revert ZeroArgument();
    token = _token;
  }

  // Modifier used to ensure a protocol exists (has been instantiated and not removed)
  modifier protocolExists(bytes32 _protocol) {
    _verifyProtocolExists(_protocol);
    _;
  }

  /// @notice View current protocolAgent of `_protocol`
  /// @param _protocol Protocol identifier
  /// @return Address able to submit claims
  function protocolAgent(bytes32 _protocol) external view override returns (address) {
    address agent = protocolAgent_[_protocol];
    if (agent != address(0)) return agent;

    // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned
    // Note: Old protocol agent will never be address(0)
    if (block.timestamp <= removedProtocolClaimDeadline[_protocol]) {
      return removedProtocolAgent[_protocol];
    }

    // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned
    revert ProtocolNotExists(_protocol);
  }

  // Checks if the protocol exists, then returns the current premium per second being charged
  /// @notice View current premium of protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of premium `_protocol` pays per second
  function premium(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return premiums_[_protocol];
  }

  // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)
  // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)
  function _verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {
    _protocolAgent = protocolAgent_[_protocol];
    if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);
  }

  //
  // View methods
  //

  // Calcs the debt accrued by the protocol since it last had an accounting update
  // This is the amount that needs to be removed from a protocol's active balance
  function _calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {
    return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums_[_protocol];
  }

  /// @notice View the amount nonstakers can claim from this protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of tokens claimable by nonstakers
  /// @dev this reads from a storage variable + (now-lastsettled) * premiums
  // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]
  // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed
  function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {
    // Calcs the debt of a protocol since the last accounting update
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // Gets the active balance of the protocol
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) debt = balance;

    // Adds the incremental claimable amount owed to nonstakers to the total claimable amount
    return
      nonStakersClaimableByProtocol[_protocol] +
      (nonStakersPercentage[_protocol] * debt) /
      HUNDRED_PERCENT;
  }

  /// @notice View current amount of all premiums that are owed to stakers
  /// @return Premiums claimable
  /// @dev Will increase every block
  /// @dev base + (now - last_settled) * ps
  function claimablePremiums() public view override returns (uint256) {
    // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)
    return
      lastClaimablePremiumsForStakers +
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
  }

  /// @notice View seconds of coverage left for `_protocol` before it runs out of active balance
  /// @param _protocol Protocol identifier
  /// @return Seconds of coverage left
  function secondsOfCoverageLeft(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _secondsOfCoverageLeft(_protocol);
  }

  // Helper function to return seconds of coverage left for a protocol
  // Gets the current active balance of the protocol and divides by the premium per second for the protocol
  function _secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {
    uint256 premium = premiums_[_protocol];
    if (premium == 0) return 0;
    return _activeBalance(_protocol) / premium;
  }

  /// @notice View current active balance of covered protocol
  /// @param _protocol Protocol identifier
  /// @return Active balance
  /// @dev Accrued debt is subtracted from the stored active balance
  function activeBalance(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _activeBalance(_protocol);
  }

  // Helper function to calc the active balance of a protocol at current time
  function _activeBalance(bytes32 _protocol) internal view returns (uint256) {
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) return 0;
    return balance - debt;
  }

  //
  // State methods
  //

  /// @notice Helps set the premium per second for an individual protocol
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function
  function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)
    internal
    returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)
  {
    // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers
    // Also updates the last accounted timestamp for this protocol
    // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings
    // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol
    nonStakerPercentage = _settleProtocolDebt(_protocol);
    // Stores the old premium before it gets updated
    oldPremiumPerSecond = premiums_[_protocol];

    if (oldPremiumPerSecond != _premium) {
      // Sets the protocol's premium per second to the new value
      premiums_[_protocol] = _premium;
      emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium);
    }
    // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing
    // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes
    // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point
    // Where arbs would no longer be incentivized to remove the protocol
    // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems
    if (_premium != 0 && _secondsOfCoverageLeft(_protocol) < MIN_SECONDS_OF_COVERAGE) {
      revert InsufficientBalance(_protocol);
    }
  }

  /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {
    // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings
    (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
      _protocol,
      _premium
    );
    // Settling the total amount of premiums owed to stakers before a new premium per second gets set
    _settleTotalDebt();
    // This calculates the new global premium per second that gets paid to stakers
    // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      oldPremiumPerSecond,
      _premium,
      nonStakerPercentage,
      nonStakerPercentage,
      allPremiumsPerSecToStakers
    );
  }

  // Internal function to set a new protocolAgent for a specific protocol
  // _oldAgent is only included as part of emitting an event
  function _setProtocolAgent(
    bytes32 _protocol,
    address _oldAgent,
    address _protocolAgent
  ) internal {
    protocolAgent_[_protocol] = _protocolAgent;
    emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);
  }

  // Subtracts the accrued debt from a protocol's active balance
  // Credits the amount that can be claimed by nonstakers for this protocol
  // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings
  // Most of this function is dealing with an edge case related to a protocol not being removed by arbs
  function _settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {
    // This calcs the accrued debt of the protocol since it was last updated
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // This pulls the percentage that is sent to nonstakers
    _nonStakerPercentage = nonStakersPercentage[_protocol];
    // In case the protocol has accrued debt, this code block will ensure the debt is settled properly
    if (debt != 0) {
      // Pulls the stored active balance of the protocol
      uint256 balance = activeBalances[_protocol];
      // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance
      // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point
      // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage
      // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up
      if (debt > balance) {
        // This error amount represents the magnitude of the mistake
        uint256 error = debt - balance;
        // Gets the latest value of claimable premiums for stakers
        _settleTotalDebt();
        // @note to production, set premium first to zero before solving accounting issue.
        // otherwise the accounting error keeps increasing
        uint256 lastClaimablePremiumsForStakers_ = lastClaimablePremiumsForStakers;

        // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%
        uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /
          HUNDRED_PERCENT;

        // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short
        uint256 insufficientTokens;

        // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally
        // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error
        // This first line can be true if claimPremiumsForStakers() has been called and
        // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be >0 still
        if (claimablePremiumError > lastClaimablePremiumsForStakers_) {
          insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;
          lastClaimablePremiumsForStakers = 0;
        } else {
          // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums
          // By the amount that was added in error (error) and insufficientTokens = 0
          lastClaimablePremiumsForStakers =
            lastClaimablePremiumsForStakers_ -
            claimablePremiumError;
        }

        // If two events are thrown, the values need to be summed up for the actual state.
        // This means an error of this type will continue until it is handled
        emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);
        // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case
        debt = balance;
      }
      // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance
      activeBalances[_protocol] = balance - debt;
      // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol
      nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT;
    }
    // Updates the last accounted timestamp for this protocol
    lastAccountedEachProtocol[_protocol] = block.timestamp;
  }

  // Multiplies the total premium per second * number of seconds since the last global accounting update
  // And adds it to the total claimable amount for stakers
  function _settleTotalDebt() internal {
    lastClaimablePremiumsForStakers +=
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
    lastAccountedGlobal = block.timestamp;
  }

  // Calculates the global premium per second for stakers
  // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers
  // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones
  function _calcGlobalPremiumPerSecForStakers(
    uint256 _premiumOld,
    uint256 _premiumNew,
    uint256 _nonStakerPercentageOld,
    uint256 _nonStakerPercentageNew,
    uint256 _inMemAllPremiumsPerSecToStakers
  ) internal pure returns (uint256) {
    return
      _inMemAllPremiumsPerSecToStakers +
      ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /
      HUNDRED_PERCENT -
      ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /
      HUNDRED_PERCENT;
  }

  // Helper function to remove and clean up a protocol from Sherlock
  // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made
  function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {
    // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol
    _setSingleAndGlobalProtocolPremium(_protocol, 0);

    // Grabs the protocol's active balance
    uint256 balance = activeBalances[_protocol];

    // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent
    if (balance != 0) {
      delete activeBalances[_protocol];
      token.safeTransfer(_agent, balance);

      emit ProtocolBalanceWithdrawn(_protocol, balance);
    }

    // Sets the protocol agent to zero address (as part of clean up)
    _setProtocolAgent(_protocol, _agent, address(0));

    // Cleans up other mappings for this protocol
    delete nonStakersPercentage[_protocol];
    delete lastAccountedEachProtocol[_protocol];
    // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above

    // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol
    removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;

    // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed
    // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked
    removedProtocolAgent[_protocol] = _agent;

    emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0));
    emit ProtocolRemoved(_protocol);
  }

  /// @notice Sets the minimum active balance before an arb can remove a protocol
  /// @param _minActiveBalance Minimum balance needed (in USDC)
  /// @dev Only gov
  function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {
    // New value cannot be the same as current value
    if (minActiveBalance == _minActiveBalance) revert InvalidArgument();
    // Can't set a value that is too high to be reasonable
    if (_minActiveBalance >= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions();

    emit MinBalance(minActiveBalance, _minActiveBalance);
    minActiveBalance = _minActiveBalance;
  }

  // This function allows the nonstakers role to claim tokens owed to them by a specific protocol
  /// @notice Choose an `_amount` of tokens that nonstakers (`_receiver` address) will receive from `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens
  /// @param _receiver Address to receive tokens
  /// @dev Only callable by nonstakers role
  function nonStakersClaim(
    bytes32 _protocol,
    uint256 _amount,
    address _receiver
  ) external override whenNotPaused {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_amount == uint256(0)) revert ZeroArgument();
    if (_receiver == address(0)) revert ZeroArgument();
    // Only the nonstakers role (multisig or contract) can pull the funds
    if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized();

    // Call can't be executed on protocol that is removed
    if (protocolAgent_[_protocol] != address(0)) {
      // Updates the amount that nonstakers can claim from this protocol
      _settleProtocolDebt(_protocol);
    }

    // Sets balance to the amount that is claimable by nonstakers for this specific protocol
    uint256 balance = nonStakersClaimableByProtocol[_protocol];
    // If the amount requested is more than what's owed to nonstakers, revert
    if (_amount > balance) revert InsufficientBalance(_protocol);

    // Sets the claimable amount to whatever is left over after this amount is pulled
    nonStakersClaimableByProtocol[_protocol] = balance - _amount;
    // Transfers the amount requested to the `_receiver` address
    token.safeTransfer(_receiver, _amount);
  }

  // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)
  /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address
  /// @dev Callable by everyone
  /// @dev Funds will be transferred to Sherlock core contract
  function claimPremiumsForStakers() external override whenNotPaused {
    // Gets address of core Sherlock contract
    address sherlock = address(sherlockCore);
    // Revert if core Sherlock contract not initialized yet
    if (sherlock == address(0)) revert InvalidConditions();

    // claimablePremiums is different from _settleTotalDebt() because it does not change state
    // Retrieves current amount of all premiums that are owed to stakers
    uint256 amount = claimablePremiums();

    // Transfers all the premiums owed to stakers to the Sherlock core contract
    if (amount != 0) {
      // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out
      lastClaimablePremiumsForStakers = 0;
      lastAccountedGlobal = block.timestamp;
      token.safeTransfer(sherlock, amount);
    }
  }

  // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts
  /// @param _protocol Protocol identifier
  /// @return current and previous are the current and previous coverage amounts for this protocol
  // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)
  function coverageAmounts(bytes32 _protocol)
    external
    view
    override
    returns (uint256 current, uint256 previous)
  {
    // Checks to see if the protocol has an active protocolAgent (protocol not removed)
    // OR checks to see if the removed protocol is still within the claim window
    // If so, gives the current and previous coverage, otherwise throws an error
    if (
      protocolAgent_[_protocol] != address(0) ||
      block.timestamp <= removedProtocolClaimDeadline[_protocol]
    ) {
      return (currentCoverage[_protocol], previousCoverage[_protocol]);
    }

    revert ProtocolNotExists(_protocol);
  }

  /// @notice Add a new protocol to Sherlock
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Address able to submit a claim on behalf of the protocol
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Adding a protocol allows the `_protocolAgent` to submit a claim
  /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point
  /// @dev `_nonStakers` is scaled by 10**18
  /// @dev Only callable by governance
  function protocolAdd(
    bytes32 _protocol,
    address _protocolAgent,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) external override onlyOwner {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Checks to make sure the protocol doesn't exist already
    if (protocolAgent_[_protocol] != address(0)) revert InvalidConditions();

    // Updates the protocol agent and passes in the old agent which is 0 address in this case
    _setProtocolAgent(_protocol, address(0), _protocolAgent);

    // Delete mappings that are potentially non default values
    // From previous time protocol was added/removed
    delete removedProtocolClaimDeadline[_protocol];
    delete removedProtocolAgent[_protocol];
    delete currentCoverage[_protocol];
    delete previousCoverage[_protocol];

    emit ProtocolAdded(_protocol);

    // Most of the logic for actually adding a protocol in this function
    protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Update info regarding a protocol
  /// @param _protocol Protocol identifier
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Only callable by governance
  /// @dev `_nonStakers` can be 0
  function protocolUpdate(
    bytes32 _protocol,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) public override onlyOwner {
    if (_coverage == bytes32(0)) revert ZeroArgument();
    if (_nonStakers > HUNDRED_PERCENT) revert InvalidArgument();
    if (_coverageAmount == uint256(0)) revert ZeroArgument();

    // Checks to make sure the protocol has been assigned a protocol agent
    _verifyProtocolExists(_protocol);

    // Subtracts the accrued debt from a protocol's active balance (if any)
    // Updates the amount that can be claimed by nonstakers
    _settleProtocolDebt(_protocol);

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    // Gets the premium per second for this protocol
    uint256 premium = premiums_[_protocol];

    // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be)
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      premium,
      premium,
      nonStakersPercentage[_protocol],
      _nonStakers,
      allPremiumsPerSecToStakers
    );

    // Updates the stored value of percentage of premiums that go to nonstakers
    nonStakersPercentage[_protocol] = _nonStakers;

    // Updates previous coverage and current coverage amounts
    previousCoverage[_protocol] = currentCoverage[_protocol];
    currentCoverage[_protocol] = _coverageAmount;

    emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Remove a protocol from coverage
  /// @param _protocol Protocol identifier
  /// @dev Before removing a protocol the premium must be 0
  /// @dev Removing a protocol basically stops the `_protocolAgent` from being active (can still submit claims until claim deadline though)
  /// @dev Pays off debt + sends remaining balance to protocol agent
  /// @dev This call should be subject to a timelock
  /// @dev Only callable by governance
  function protocolRemove(bytes32 _protocol) external override onlyOwner {
    // checks to make sure the protocol actually has a protocol agent
    address agent = _verifyProtocolExists(_protocol);

    // Removes a protocol from Sherlock and cleans up its data
    // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made
    _forceRemoveProtocol(_protocol, agent);
  }

  /// @notice Remove a protocol with insufficient active balance
  /// @param _protocol Protocol identifier
  // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function
  function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {
    address agent = _verifyProtocolExists(_protocol);

    // Gets the latest value of the active balance at this protocol
    _settleProtocolDebt(_protocol);
    // Sets latest value of active balance to remainingBalance variable
    uint256 remainingBalance = activeBalances[_protocol];

    // This means the protocol still has adequate active balance and thus cannot be removed
    if (remainingBalance >= minActiveBalance) revert InvalidConditions();

    // Sets the protocol's active balance to 0
    delete activeBalances[_protocol];
    // Removes the protocol from coverage
    _forceRemoveProtocol(_protocol, agent);

    if (remainingBalance != 0) {
      // sends the remaining balance to msg.sender
      token.safeTransfer(msg.sender, remainingBalance);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);
  }

  /// @notice Calculate if arb is possible and what the reward would be
  /// @param _protocol Protocol identifier
  /// @return arbAmount Amount reward for arbing
  /// @return able Indicator if arb call is even possible
  /// @dev Doesn't subtract the current protocol debt from the active balance
  function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)
    internal
    view
    returns (uint256 arbAmount, bool able)
  {
    uint256 secondsLeft = _secondsOfCoverageLeft(_protocol);

    // If arb is not possible return false
    if (secondsLeft >= MIN_SECONDS_OF_COVERAGE) return (0, false);

    // This percentage scales over time
    // Reaches 100% on 0 seconds of coverage left
    uint256 percentageScaled = HUNDRED_PERCENT -
      (secondsLeft * HUNDRED_PERCENT) /
      MIN_SECONDS_OF_COVERAGE;

    able = true;
    arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;
  }

  /// @notice Removes a protocol with insufficent seconds of coverage left
  /// @param _protocol Protocol identifier
  // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second
  function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {
    // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings
    address agent = _verifyProtocolExists(_protocol);

    // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance()
    // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance()
    // But when removing based on seconds of coverage left, the remainingBalance could still be quite large
    // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance
    // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%)
    _settleProtocolDebt(_protocol);
    (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol);
    if (able == false) revert InvalidConditions();

    if (arbAmount != 0) {
      // subtracts the amount that will be paid to the arb from the active balance
      activeBalances[_protocol] -= arbAmount;
    }

    // Removes the protocol from coverage
    // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above
    _forceRemoveProtocol(_protocol, agent);

    // Done after removing protocol to mitigate reentrency pattern
    // (In case token allows callback)
    if (arbAmount != 0) {
      token.safeTransfer(msg.sender, arbAmount);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);
  }

  /// @notice Set premium of `_protocol` to `_premium`
  /// @param _protocol Protocol identifier
  /// @param _premium Amount of premium `_protocol` pays per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {
    // Checks to see if protocol has a protocol agent
    _verifyProtocolExists(_protocol);

    // Updates individual protocol's premium and allPremiumsPerSecToStakers
    _setSingleAndGlobalProtocolPremium(_protocol, _premium);
  }

  /// @notice Set premium of multiple protocols
  /// @param _protocol Array of protocol identifiers
  /// @param _premium Array of premium amounts protocols pay per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)
    external
    override
    onlyOwner
  {
    // Checks to make sure there are an equal amount of entries in each array
    if (_protocol.length != _premium.length) revert UnequalArrayLength();
    if (_protocol.length == 0) revert InvalidArgument();

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;

    // Loops through the array of protocols and checks to make sure each has a protocol agent assigned
    for (uint256 i; i < _protocol.length; i++) {
      _verifyProtocolExists(_protocol[i]);

      // Sets the protocol premium for that specific protocol
      // Function returns the old premium and nonStakerPercentage for that specific protocol
      (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
        _protocol[i],
        _premium[i]
      );

      // Calculates the new global premium which adds up all premiums paid by all protocols
      allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(
        oldPremiumPerSecond,
        _premium[i],
        nonStakerPercentage,
        nonStakerPercentage,
        allPremiumsPerSecToStakers_
      );
    }

    // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value
    allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;
  }

  // This is how protocols pay for coverage by increasing their active balance
  /// @notice Deposits `_amount` of token to the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to deposit
  /// @dev Approval should be made before calling
  function depositToActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    _verifyProtocolExists(_protocol);

    // Transfers _amount to this contract
    token.safeTransferFrom(msg.sender, address(this), _amount);
    // Increases the active balance of the protocol by _amount
    activeBalances[_protocol] += _amount;

    emit ProtocolBalanceDeposited(_protocol, _amount);
  }

  // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)
  // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)
  /// @notice Withdraws `_amount` of token from the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to withdraw
  /// @dev Only protocol agent is able to withdraw
  /// @dev Balance can be withdrawn up until 7 days worth of active balance
  function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    // Only the protocol agent can call this function
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Updates the active balance of the protocol
    _settleProtocolDebt(_protocol);

    // Sets currentBalance to the active balance of the protocol
    uint256 currentBalance = activeBalances[_protocol];
    // Reverts if trying to withdraw more than the active balance
    if (_amount > currentBalance) revert InsufficientBalance(_protocol);

    // Removes the _amount to be withdrawn from the active balance
    activeBalances[_protocol] = currentBalance - _amount;
    // Reverts if a protocol has less than 7 days worth of active balance left
    if (_secondsOfCoverageLeft(_protocol) < MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);

    // Transfers the amount to the msg.sender (protocol agent)
    token.safeTransfer(msg.sender, _amount);
    emit ProtocolBalanceWithdrawn(_protocol, _amount);
  }

  /// @notice Transfer protocol agent role
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Account able to submit a claim on behalf of the protocol
  /// @dev Only the active protocolAgent is able to transfer the role
  function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)
    external
    override
    whenNotPaused
  {
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Can't set the new protocol agent to the caller address
    if (msg.sender == _protocolAgent) revert InvalidArgument();
    // Because the caller must be the current protocol agent
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Sets the protocol agent to the new address
    _setProtocolAgent(_protocol, msg.sender, _protocolAgent);
  }

  /// @notice Function used to check if this is the current active protocol manager
  /// @return Boolean indicating it's active
  /// @dev If inactive the owner can pull all ERC20s and ETH
  /// @dev Will be checked by calling the sherlock contract
  function isActive() public view returns (bool) {
    return address(sherlockCore.sherlockProtocolManager()) == address(this);
  }

  // Only contract owner can call this
  // Sends all specified tokens in this contract to the receiver's address (as well as ETH)
  function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {
    if (_receiver == address(0)) revert ZeroArgument();
    // This contract must NOT be the current assigned protocol manager contract
    if (isActive()) revert InvalidConditions();
    // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH
    _sweep(_receiver, _extraTokens);
  }
}
.]

Based on the provided Solidity smart contract code for the `SherlockProtocolManager`, here is a succinct summary of potential security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract performs external calls to transfer tokens (e.g., `token.safeTransfer`). If the receiving contract has a fallback function that calls back into the `SherlockProtocolManager`, it could lead to unexpected behavior or state changes. Although the contract uses `safeTransfer`, which mitigates some risks, it is still advisable to implement a reentrancy guard.

2. **Arithmetic Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow and underflow checks, any manual arithmetic operations should be carefully reviewed to ensure they do not lead to unexpected results, especially in functions that manipulate balances and claims.

3. **Access Control Issues**:
   - The `onlyOwner` modifier is used to restrict access to certain functions, but if the ownership is compromised (e.g., through a private key leak), an attacker could manipulate the contract. It is crucial to ensure that ownership transfer mechanisms are secure and that the owner’s private key is protected.

4. **Improper Handling of Protocol Removal**:
   - The `_forceRemoveProtocol` function allows for the removal of protocols, but if not carefully managed, it could lead to funds being sent to an incorrect address or an unintended state. The logic surrounding protocol removal should be thoroughly audited to ensure that it handles edge cases correctly.

5. **Claimable Balances Logic**:
   - The logic for calculating claimable balances for non-stakers and stakers could lead to discrepancies if not properly accounted for. The contract should ensure that all calculations are accurate and that there are no scenarios where claimable amounts could be manipulated.

6. **Lack of Event Emission for Critical State Changes**:
   - While the contract emits events for many state changes, it is essential to ensure that all critical state changes (especially those affecting balances and claims) are logged appropriately to maintain transparency and facilitate audits.

7. **Potential Gas Limit Issues**:
   - Functions that loop through arrays (e.g., `setProtocolPremiums`) could run into gas limit issues if the array size is too large. It is advisable to implement checks or limits on the number of protocols that can be processed in a single transaction.

8. **Protocol Agent Assignment Risks**:
   - The assignment of protocol agents should be carefully controlled. If a malicious actor gains control over a protocol agent, they could manipulate claims and balances. The contract should implement robust checks to validate protocol agent actions.

### Comprehensive Analysis Report:

The `SherlockProtocolManager` contract is designed to manage covered protocols and their associated premiums, balances, and claims. While it incorporates several best practices, including the use of `SafeERC20` for token transfers and built-in checks for arithmetic operations, there are notable vulnerabilities that could be exploited if not addressed.

1. **Reentrancy Protection**: Implement a reentrancy guard to prevent potential attacks during external calls.
2. **Access Control**: Ensure that ownership and access control mechanisms are robust and that ownership transfer is secure.
3. **Protocol Management**: Review the logic for protocol removal and ensure that it handles all edge cases to prevent loss of funds.
4. **Claim Calculations**: Audit the calculations for claimable balances to ensure accuracy and prevent manipulation.
5. **Event Emission**: Ensure that all critical state changes are logged with appropriate events for transparency.
6. **Gas Limit Considerations**: Implement limits on the number of protocols processed in a single transaction to avoid gas limit issues.

In conclusion, while the `SherlockProtocolManager` contract has a solid foundation, it requires a thorough security audit to address the identified vulnerabilities. Implementing the recommended changes will enhance the contract's security and reliability, ultimately protecting users and their funds. Regular audits and updates should be part of the contract's lifecycle to adapt to evolving security threats.

[2024-25-08 10:59:09 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code for the `SherlockProtocolManager`, here is a succinct summary of potential security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract performs external calls to transfer tokens (e.g., `token.safeTransfer`). If the receiving contract has a fallback function that calls back into the `SherlockProtocolManager`, it could lead to unexpected behavior or state changes. Although the contract uses `safeTransfer`, which mitigates some risks, it is still advisable to implement a reentrancy guard.

2. **Arithmetic Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow and underflow checks, any manual arithmetic operations should be carefully reviewed to ensure they do not lead to unexpected results, especially in functions that manipulate balances and claims.

3. **Access Control Issues**:
   - The `onlyOwner` modifier is used to restrict access to certain functions, but if the ownership is compromised (e.g., through a private key leak), an attacker could manipulate the contract. It is crucial to ensure that ownership transfer mechanisms are secure and that the owner’s private key is protected.

4. **Improper Handling of Protocol Removal**:
   - The `_forceRemoveProtocol` function allows for the removal of protocols, but if not carefully managed, it could lead to funds being sent to an incorrect address or an unintended state. The logic surrounding protocol removal should be thoroughly audited to ensure that it handles edge cases correctly.

5. **Claimable Balances Logic**:
   - The logic for calculating claimable balances for non-stakers and stakers could lead to discrepancies if not properly accounted for. The contract should ensure that all calculations are accurate and that there are no scenarios where claimable amounts could be manipulated.

6. **Lack of Event Emission for Critical State Changes**:
   - While the contract emits events for many state changes, it is essential to ensure that all critical state changes (especially those affecting balances and claims) are logged appropriately to maintain transparency and facilitate audits.

7. **Potential Gas Limit Issues**:
   - Functions that loop through arrays (e.g., `setProtocolPremiums`) could run into gas limit issues if the array size is too large. It is advisable to implement checks or limits on the number of protocols that can be processed in a single transaction.

8. **Protocol Agent Assignment Risks**:
   - The assignment of protocol agents should be carefully controlled. If a malicious actor gains control over a protocol agent, they could manipulate claims and balances. The contract should implement robust checks to validate protocol agent actions.

### Comprehensive Analysis Report:

The `SherlockProtocolManager` contract is designed to manage covered protocols and their associated premiums, balances, and claims. While it incorporates several best practices, including the use of `SafeERC20` for token transfers and built-in checks for arithmetic operations, there are notable vulnerabilities that could be exploited if not addressed.

1. **Reentrancy Protection**: Implement a reentrancy guard to prevent potential attacks during external calls.
2. **Access Control**: Ensure that ownership and access control mechanisms are robust and that ownership transfer is secure.
3. **Protocol Management**: Review the logic for protocol removal and ensure that it handles all edge cases to prevent loss of funds.
4. **Claim Calculations**: Audit the calculations for claimable balances to ensure accuracy and prevent manipulation.
5. **Event Emission**: Ensure that all critical state changes are logged with appropriate events for transparency.
6. **Gas Limit Considerations**: Implement limits on the number of protocols processed in a single transaction to avoid gas limit issues.

In conclusion, while the `SherlockProtocolManager` contract has a solid foundation, it requires a thorough security audit to address the identified vulnerabilities. Implementing the recommended changes will enhance the contract's security and reliability, ultimately protecting users and their funds. Regular audits and updates should be part of the contract's lifecycle to adapt to evolving security threats.

[2024-25-08 10:59:09 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-25-08 10:59:09 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import './Manager.sol'; import '../interfaces/managers/ISherlockProtocolManager.sol'; /// @title Sherlock core interface for protocols /// @author Evert Kors // This is the contract that manages covered protocols contract SherlockProtocolManager is ISherlockProtocolManager, Manager {   using SafeERC20 for IERC20; // Represents the token that protocols pay with (currently USDC)   IERC20 public immutable token; // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed   uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc // A removed protocol is still able to make a claim for this amount of time after its removal   uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days; // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance   uint256 public constant MIN_SECONDS_LEFT = 7 days; // Convenient for percentage calculations   uint256 internal constant HUNDRED_PERCENT = 10**18; // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage   // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying   uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours; // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)   mapping(bytes32 =&gt; address) internal protocolAgent_; // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)   mapping(bytes32 =&gt; uint256) internal nonStakersPercentage; // The premium per second paid by each protocol is stored in this mapping   mapping(bytes32 =&gt; uint256) internal premiums_; // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.   // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not   mapping(bytes32 =&gt; uint256) internal activeBalances; // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol   mapping(bytes32 =&gt; uint256) internal lastAccountedEachProtocol; // The amount that can be claimed by nonstakers for each protocol   // We need this value so we can track how much payment is coming from each protocol   mapping(bytes32 =&gt; uint256) internal nonStakersClaimableByProtocol; // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)   uint256 internal lastAccountedGlobal; // This is the total amount of premiums paid (per second) by all the covered protocols (added up)   uint256 internal allPremiumsPerSecToStakers; // This is the amount that was claimable by stakers the last time the accounting was run   // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date   uint256 internal lastClaimablePremiumsForStakers; // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage   // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)   uint256 public override minActiveBalance; // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)   mapping(bytes32 =&gt; uint256) internal removedProtocolClaimDeadline; // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)   mapping(bytes32 =&gt; address) internal removedProtocolAgent; // Current amount of coverage (i.e. 20M USDC) for a protocol   mapping(bytes32 =&gt; uint256) internal currentCoverage; // Previous amount of coverage for a protocol   // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount   mapping(bytes32 =&gt; uint256) internal previousCoverage; // Setting the token to USDC   constructor(IERC20 _token) {     if (address(_token) == address(0)) revert ZeroArgument();     token = _token;   } // Modifier used to ensure a protocol exists (has been instantiated and not removed)   modifier protocolExists(bytes32 protocol) {     _verifyProtocolExists(_protocol);     ;   } /// @notice View current protocolAgent of _protocol   /// @param protocol Protocol identifier   /// @return Address able to submit claims   function protocolAgent(bytes32 _protocol) external view override returns (address) {     address agent = protocolAgent[_protocol];     if (agent != address(0)) return agent; // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned // Note: Old protocol agent will never be address(0) if (block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]) {   return removedProtocolAgent[_protocol]; }  // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned revert ProtocolNotExists(_protocol);  } // Checks if the protocol exists, then returns the current premium per second being charged   /// @notice View current premium of protocol   /// @param protocol Protocol identifier   /// @return Amount of premium _protocol pays per second   function premium(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return premiums[_protocol];   } // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)   // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)   function verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {     _protocolAgent = protocolAgent[_protocol];     if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);   } //   // View methods   // // Calcs the debt accrued by the protocol since it last had an accounting update   // This is the amount that needs to be removed from a protocol's active balance   function calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {     return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums[_protocol];   } /// @notice View the amount nonstakers can claim from this protocol   /// @param _protocol Protocol identifier   /// @return Amount of tokens claimable by nonstakers   /// @dev this reads from a storage variable + (now-lastsettled) * premiums   // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]   // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed   function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {     // Calcs the debt of a protocol since the last accounting update     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     // Gets the active balance of the protocol     uint256 balance = activeBalances[_protocol];     // The debt should never be higher than the balance (only happens if the arbitrages fail)     if (debt &gt; balance) debt = balance; // Adds the incremental claimable amount owed to nonstakers to the total claimable amount return   nonStakersClaimableByProtocol[_protocol] +   (nonStakersPercentage[_protocol] * debt) /   HUNDRED_PERCENT;  } /// @notice View current amount of all premiums that are owed to stakers   /// @return Premiums claimable   /// @dev Will increase every block   /// @dev base + (now - last_settled) * ps   function claimablePremiums() public view override returns (uint256) {     // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)     return       lastClaimablePremiumsForStakers +       (block.timestamp - lastAccountedGlobal) *       allPremiumsPerSecToStakers;   } /// @notice View seconds of coverage left for _protocol before it runs out of active balance   /// @param _protocol Protocol identifier   /// @return Seconds of coverage left   function secondsOfCoverageLeft(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return _secondsOfCoverageLeft(_protocol);   } // Helper function to return seconds of coverage left for a protocol   // Gets the current active balance of the protocol and divides by the premium per second for the protocol   function secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {     uint256 premium = premiums[_protocol];     if (premium == 0) return 0;     return _activeBalance(_protocol) / premium;   } /// @notice View current active balance of covered protocol   /// @param _protocol Protocol identifier   /// @return Active balance   /// @dev Accrued debt is subtracted from the stored active balance   function activeBalance(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return _activeBalance(_protocol);   } // Helper function to calc the active balance of a protocol at current time   function _activeBalance(bytes32 _protocol) internal view returns (uint256) {     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     uint256 balance = activeBalances[_protocol];     // The debt should never be higher than the balance (only happens if the arbitrages fail)     if (debt &gt; balance) return 0;     return balance - debt;   } //   // State methods   // /// @notice Helps set the premium per second for an individual protocol   /// @param protocol Protocol identifier   /// @param _premium New premium per second   /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function   function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)     internal     returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)   {     // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers     // Also updates the last accounted timestamp for this protocol     // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings     // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol     nonStakerPercentage = _settleProtocolDebt(_protocol);     // Stores the old premium before it gets updated     oldPremiumPerSecond = premiums[_protocol]; if (oldPremiumPerSecond != _premium) {   // Sets the protocol's premium per second to the new value   premiums_[_protocol] = _premium;   emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium); } // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point // Where arbs would no longer be incentivized to remove the protocol // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems if (_premium != 0 &amp;&amp; _secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_OF_COVERAGE) {   revert InsufficientBalance(_protocol); }  } /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second   /// @param _protocol Protocol identifier   /// @param _premium New premium per second   function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {     // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings     (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(       _protocol,       _premium     );     // Settling the total amount of premiums owed to stakers before a new premium per second gets set     _settleTotalDebt();     // This calculates the new global premium per second that gets paid to stakers     // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function     allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(       oldPremiumPerSecond,       _premium,       nonStakerPercentage,       nonStakerPercentage,       allPremiumsPerSecToStakers     );   } // Internal function to set a new protocolAgent for a specific protocol   // oldAgent is only included as part of emitting an event   function _setProtocolAgent(     bytes32 _protocol,     address _oldAgent,     address _protocolAgent   ) internal {     protocolAgent[_protocol] = _protocolAgent;     emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);   } // Subtracts the accrued debt from a protocol's active balance   // Credits the amount that can be claimed by nonstakers for this protocol   // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings   // Most of this function is dealing with an edge case related to a protocol not being removed by arbs   function settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {     // This calcs the accrued debt of the protocol since it was last updated     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     // This pulls the percentage that is sent to nonstakers     _nonStakerPercentage = nonStakersPercentage[_protocol];     // In case the protocol has accrued debt, this code block will ensure the debt is settled properly     if (debt != 0) {       // Pulls the stored active balance of the protocol       uint256 balance = activeBalances[_protocol];       // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance       // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point       // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage       // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up       if (debt &gt; balance) {         // This error amount represents the magnitude of the mistake         uint256 error = debt - balance;         // Gets the latest value of claimable premiums for stakers         _settleTotalDebt();         // @note to production, set premium first to zero before solving accounting issue.         // otherwise the accounting error keeps increasing         uint256 lastClaimablePremiumsForStakers = lastClaimablePremiumsForStakers;     // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%     uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /       HUNDRED_PERCENT;      // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short     uint256 insufficientTokens;      // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally     // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error     // This first line can be true if claimPremiumsForStakers() has been called and     // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be &gt;0 still     if (claimablePremiumError &gt; lastClaimablePremiumsForStakers_) {       insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;       lastClaimablePremiumsForStakers = 0;     } else {       // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums       // By the amount that was added in error (error) and insufficientTokens = 0       lastClaimablePremiumsForStakers =         lastClaimablePremiumsForStakers_ -         claimablePremiumError;     }      // If two events are thrown, the values need to be summed up for the actual state.     // This means an error of this type will continue until it is handled     emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);     // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case     debt = balance;   }   // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance   activeBalances[_protocol] = balance - debt;   // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol   nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT; } // Updates the last accounted timestamp for this protocol lastAccountedEachProtocol[_protocol] = block.timestamp;  } // Multiplies the total premium per second * number of seconds since the last global accounting update   // And adds it to the total claimable amount for stakers   function _settleTotalDebt() internal {     lastClaimablePremiumsForStakers +=       (block.timestamp - lastAccountedGlobal) *       allPremiumsPerSecToStakers;     lastAccountedGlobal = block.timestamp;   } // Calculates the global premium per second for stakers   // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers   // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones   function _calcGlobalPremiumPerSecForStakers(     uint256 _premiumOld,     uint256 _premiumNew,     uint256 _nonStakerPercentageOld,     uint256 _nonStakerPercentageNew,     uint256 _inMemAllPremiumsPerSecToStakers   ) internal pure returns (uint256) {     return       _inMemAllPremiumsPerSecToStakers +       ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /       HUNDRED_PERCENT -       ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /       HUNDRED_PERCENT;   } // Helper function to remove and clean up a protocol from Sherlock   // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made   function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {     // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol     _setSingleAndGlobalProtocolPremium(_protocol, 0); // Grabs the protocol's active balance uint256 balance = activeBalances[_protocol];  // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent if (balance != 0) {   delete activeBalances[_protocol];   token.safeTransfer(_agent, balance);    emit ProtocolBalanceWithdrawn(_protocol, balance); }  // Sets the protocol agent to zero address (as part of clean up) _setProtocolAgent(_protocol, _agent, address(0));  // Cleans up other mappings for this protocol delete nonStakersPercentage[_protocol]; delete lastAccountedEachProtocol[_protocol]; // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above  // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;  // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked removedProtocolAgent[_protocol] = _agent;  emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0)); emit ProtocolRemoved(_protocol);  } /// @notice Sets the minimum active balance before an arb can remove a protocol   /// @param _minActiveBalance Minimum balance needed (in USDC)   /// @dev Only gov   function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {     // New value cannot be the same as current value     if (minActiveBalance == _minActiveBalance) revert InvalidArgument();     // Can't set a value that is too high to be reasonable     if (_minActiveBalance &gt;= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions(); emit MinBalance(minActiveBalance, _minActiveBalance); minActiveBalance = _minActiveBalance;  } // This function allows the nonstakers role to claim tokens owed to them by a specific protocol   /// @notice Choose an _amount of tokens that nonstakers (_receiver address) will receive from _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens   /// @param _receiver Address to receive tokens   /// @dev Only callable by nonstakers role   function nonStakersClaim(     bytes32 _protocol,     uint256 _amount,     address _receiver   ) external override whenNotPaused {     if (_protocol == bytes32(0)) revert ZeroArgument();     if (_amount == uint256(0)) revert ZeroArgument();     if (_receiver == address(0)) revert ZeroArgument();     // Only the nonstakers role (multisig or contract) can pull the funds     if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized(); // Call can't be executed on protocol that is removed if (protocolAgent_[_protocol] != address(0)) {   // Updates the amount that nonstakers can claim from this protocol   _settleProtocolDebt(_protocol); }  // Sets balance to the amount that is claimable by nonstakers for this specific protocol uint256 balance = nonStakersClaimableByProtocol[_protocol]; // If the amount requested is more than what's owed to nonstakers, revert if (_amount &gt; balance) revert InsufficientBalance(_protocol);  // Sets the claimable amount to whatever is left over after this amount is pulled nonStakersClaimableByProtocol[_protocol] = balance - _amount; // Transfers the amount requested to the `_receiver` address token.safeTransfer(_receiver, _amount);  } // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)   /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address   /// @dev Callable by everyone   /// @dev Funds will be transferred to Sherlock core contract   function claimPremiumsForStakers() external override whenNotPaused {     // Gets address of core Sherlock contract     address sherlock = address(sherlockCore);     // Revert if core Sherlock contract not initialized yet     if (sherlock == address(0)) revert InvalidConditions(); // claimablePremiums is different from _settleTotalDebt() because it does not change state // Retrieves current amount of all premiums that are owed to stakers uint256 amount = claimablePremiums();  // Transfers all the premiums owed to stakers to the Sherlock core contract if (amount != 0) {   // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out   lastClaimablePremiumsForStakers = 0;   lastAccountedGlobal = block.timestamp;   token.safeTransfer(sherlock, amount); }  } // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts   /// @param protocol Protocol identifier   /// @return current and previous are the current and previous coverage amounts for this protocol   // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)   function coverageAmounts(bytes32 _protocol)     external     view     override     returns (uint256 current, uint256 previous)   {     // Checks to see if the protocol has an active protocolAgent (protocol not removed)     // OR checks to see if the removed protocol is still within the claim window     // If so, gives the current and previous coverage, otherwise throws an error     if (       protocolAgent[_protocol] != address(0) ||       block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]     ) {       return (currentCoverage[_protocol], previousCoverage[_protocol]);     } revert ProtocolNotExists(_protocol);  } /// @notice Add a new protocol to Sherlock   /// @param protocol Protocol identifier   /// @param _protocolAgent Address able to submit a claim on behalf of the protocol   /// @param _coverage Hash referencing the active coverage agreement   /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 1018   /// @param _coverageAmount Max amount claimable by this protocol   /// @dev Adding a protocol allows the _protocolAgent to submit a claim   /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point   /// @dev _nonStakers is scaled by 1018   /// @dev Only callable by governance   function protocolAdd(     bytes32 _protocol,     address _protocolAgent,     bytes32 _coverage,     uint256 _nonStakers,     uint256 _coverageAmount   ) external override onlyOwner {     if (_protocol == bytes32(0)) revert ZeroArgument();     if (_protocolAgent == address(0)) revert ZeroArgument();     // Checks to make sure the protocol doesn't exist already     if (protocolAgent[_protocol] != address(0)) revert InvalidConditions(); // Updates the protocol agent and passes in the old agent which is 0 address in this case _setProtocolAgent(_protocol, address(0), _protocolAgent);  // Delete mappings that are potentially non default values // From previous time protocol was added/removed delete removedProtocolClaimDeadline[_protocol]; delete removedProtocolAgent[_protocol]; delete currentCoverage[_protocol]; delete previousCoverage[_protocol];  emit ProtocolAdded(_protocol);  // Most of the logic for actually adding a protocol in this function protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);  } /// @notice Update info regarding a protocol   /// @param _protocol Protocol identifier   /// @param _coverage Hash referencing the active coverage agreement   /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18   /// @param _coverageAmount Max amount claimable by this protocol   /// @dev Only callable by governance   /// @dev _nonStakers can be 0   function protocolUpdate(     bytes32 _protocol,     bytes32 _coverage,     uint256 _nonStakers,     uint256 _coverageAmount   ) public override onlyOwner {     if (_coverage == bytes32(0)) revert ZeroArgument();     if (_nonStakers &gt; HUNDRED_PERCENT) revert InvalidArgument();     if (_coverageAmount == uint256(0)) revert ZeroArgument(); // Checks to make sure the protocol has been assigned a protocol agent _verifyProtocolExists(_protocol);  // Subtracts the accrued debt from a protocol's active balance (if any) // Updates the amount that can be claimed by nonstakers _settleProtocolDebt(_protocol);  // Updates the global claimable amount for stakers _settleTotalDebt();  // Gets the premium per second for this protocol uint256 premium = premiums_[_protocol];  // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be) allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(   premium,   premium,   nonStakersPercentage[_protocol],   _nonStakers,   allPremiumsPerSecToStakers );  // Updates the stored value of percentage of premiums that go to nonstakers nonStakersPercentage[_protocol] = _nonStakers;  // Updates previous coverage and current coverage amounts previousCoverage[_protocol] = currentCoverage[_protocol]; currentCoverage[_protocol] = _coverageAmount;  emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);  } /// @notice Remove a protocol from coverage   /// @param _protocol Protocol identifier   /// @dev Before removing a protocol the premium must be 0   /// @dev Removing a protocol basically stops the _protocolAgent from being active (can still submit claims until claim deadline though)   /// @dev Pays off debt + sends remaining balance to protocol agent   /// @dev This call should be subject to a timelock   /// @dev Only callable by governance   function protocolRemove(bytes32 _protocol) external override onlyOwner {     // checks to make sure the protocol actually has a protocol agent     address agent = _verifyProtocolExists(_protocol); // Removes a protocol from Sherlock and cleans up its data // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made _forceRemoveProtocol(_protocol, agent);  } /// @notice Remove a protocol with insufficient active balance   /// @param _protocol Protocol identifier   // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function   function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {     address agent = _verifyProtocolExists(_protocol); // Gets the latest value of the active balance at this protocol _settleProtocolDebt(_protocol); // Sets latest value of active balance to remainingBalance variable uint256 remainingBalance = activeBalances[_protocol];  // This means the protocol still has adequate active balance and thus cannot be removed if (remainingBalance &gt;= minActiveBalance) revert InvalidConditions();  // Sets the protocol's active balance to 0 delete activeBalances[_protocol]; // Removes the protocol from coverage _forceRemoveProtocol(_protocol, agent);  if (remainingBalance != 0) {   // sends the remaining balance to msg.sender   token.safeTransfer(msg.sender, remainingBalance); } emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);  } /// @notice Calculate if arb is possible and what the reward would be   /// @param _protocol Protocol identifier   /// @return arbAmount Amount reward for arbing   /// @return able Indicator if arb call is even possible   /// @dev Doesn't subtract the current protocol debt from the active balance   function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)     internal     view     returns (uint256 arbAmount, bool able)   {     uint256 secondsLeft = _secondsOfCoverageLeft(_protocol); // If arb is not possible return false if (secondsLeft &gt;= MIN_SECONDS_OF_COVERAGE) return (0, false);  // This percentage scales over time // Reaches 100% on 0 seconds of coverage left uint256 percentageScaled = HUNDRED_PERCENT -   (secondsLeft * HUNDRED_PERCENT) /   MIN_SECONDS_OF_COVERAGE;  able = true; arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;  } /// @notice Removes a protocol with insufficent seconds of coverage left   /// @param _protocol Protocol identifier   // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second   function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {     // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings     address agent = _verifyProtocolExists(_protocol); // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance() // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance() // But when removing based on seconds of coverage left, the remainingBalance could still be quite large // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%) _settleProtocolDebt(_protocol); (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol); if (able == false) revert InvalidConditions();  if (arbAmount != 0) {   // subtracts the amount that will be paid to the arb from the active balance   activeBalances[_protocol] -= arbAmount; }  // Removes the protocol from coverage // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above _forceRemoveProtocol(_protocol, agent);  // Done after removing protocol to mitigate reentrency pattern // (In case token allows callback) if (arbAmount != 0) {   token.safeTransfer(msg.sender, arbAmount); } emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);  } /// @notice Set premium of _protocol to _premium   /// @param _protocol Protocol identifier   /// @param _premium Amount of premium _protocol pays per second   /// @dev The value 0 would mean inactive coverage   /// @dev Only callable by governance   function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {     // Checks to see if protocol has a protocol agent     _verifyProtocolExists(_protocol); // Updates individual protocol's premium and allPremiumsPerSecToStakers _setSingleAndGlobalProtocolPremium(_protocol, _premium);  } /// @notice Set premium of multiple protocols   /// @param _protocol Array of protocol identifiers   /// @param _premium Array of premium amounts protocols pay per second   /// @dev The value 0 would mean inactive coverage   /// @dev Only callable by governance   function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)     external     override     onlyOwner   {     // Checks to make sure there are an equal amount of entries in each array     if (_protocol.length != _premium.length) revert UnequalArrayLength();     if (_protocol.length == 0) revert InvalidArgument(); // Updates the global claimable amount for stakers _settleTotalDebt();  uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;  // Loops through the array of protocols and checks to make sure each has a protocol agent assigned for (uint256 i; i &lt; _protocol.length; i++) {   _verifyProtocolExists(_protocol[i]);    // Sets the protocol premium for that specific protocol   // Function returns the old premium and nonStakerPercentage for that specific protocol   (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(     _protocol[i],     _premium[i]   );    // Calculates the new global premium which adds up all premiums paid by all protocols   allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(     oldPremiumPerSecond,     _premium[i],     nonStakerPercentage,     nonStakerPercentage,     allPremiumsPerSecToStakers_   ); }  // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;  } // This is how protocols pay for coverage by increasing their active balance   /// @notice Deposits _amount of token to the active balance of _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens to deposit   /// @dev Approval should be made before calling   function depositToActiveBalance(bytes32 _protocol, uint256 _amount)     external     override     whenNotPaused   {     if (_amount == uint256(0)) revert ZeroArgument();     _verifyProtocolExists(_protocol); // Transfers _amount to this contract token.safeTransferFrom(msg.sender, address(this), _amount); // Increases the active balance of the protocol by _amount activeBalances[_protocol] += _amount;  emit ProtocolBalanceDeposited(_protocol, _amount);  } // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)   // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)   /// @notice Withdraws _amount of token from the active balance of _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens to withdraw   /// @dev Only protocol agent is able to withdraw   /// @dev Balance can be withdrawn up until 7 days worth of active balance   function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)     external     override     whenNotPaused   {     if (_amount == uint256(0)) revert ZeroArgument();     // Only the protocol agent can call this function     if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized(); // Updates the active balance of the protocol _settleProtocolDebt(_protocol);  // Sets currentBalance to the active balance of the protocol uint256 currentBalance = activeBalances[_protocol]; // Reverts if trying to withdraw more than the active balance if (_amount &gt; currentBalance) revert InsufficientBalance(_protocol);  // Removes the _amount to be withdrawn from the active balance activeBalances[_protocol] = currentBalance - _amount; // Reverts if a protocol has less than 7 days worth of active balance left if (_secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);  // Transfers the amount to the msg.sender (protocol agent) token.safeTransfer(msg.sender, _amount); emit ProtocolBalanceWithdrawn(_protocol, _amount);  } /// @notice Transfer protocol agent role   /// @param _protocol Protocol identifier   /// @param _protocolAgent Account able to submit a claim on behalf of the protocol   /// @dev Only the active protocolAgent is able to transfer the role   function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)     external     override     whenNotPaused   {     if (_protocolAgent == address(0)) revert ZeroArgument();     // Can't set the new protocol agent to the caller address     if (msg.sender == _protocolAgent) revert InvalidArgument();     // Because the caller must be the current protocol agent     if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized(); // Sets the protocol agent to the new address _setProtocolAgent(_protocol, msg.sender, _protocolAgent);  } /// @notice Function used to check if this is the current active protocol manager   /// @return Boolean indicating it's active   /// @dev If inactive the owner can pull all ERC20s and ETH   /// @dev Will be checked by calling the sherlock contract   function isActive() public view returns (bool) {     return address(sherlockCore.sherlockProtocolManager()) == address(this);   } // Only contract owner can call this   // Sends all specified tokens in this contract to the receiver's address (as well as ETH)   function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {     if (_receiver == address(0)) revert ZeroArgument();     // This contract must NOT be the current assigned protocol manager contract     if (isActive()) revert InvalidConditions();     // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH     _sweep(_receiver, _extraTokens);   } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/***********\\n Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x)\n Sherlock Protocol: https://sherlock.xyz\n/***********/\n\nimport \'./Manager.sol\';\nimport \'../interfaces/managers/ISherlockProtocolManager.sol\';\n\n/// @title Sherlock core interface for protocols\n/// @author Evert Kors\n// This is the contract that manages covered protocols\n\ncontract SherlockProtocolManager is ISherlockProtocolManager, Manager {\n  using SafeERC20 for IERC20;\n\n  // Represents the token that protocols pay with (currently USDC)\n  IERC20 public immutable token;\n\n  // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed\n  uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 106; // 30k usdc\n\n  // A removed protocol is still able to make a claim for this amount of time after its removal\n  uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days;\n\n  // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance\n  uint256 public constant MIN_SECONDS_LEFT = 7 days;\n\n  // Convenient for percentage calculations\n  uint256 internal constant HUNDRED_PERCENT = 1018;\n\n  // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage\n  // This value is calculated from a protocol\'s active balance divided by the premium per second the protocol is paying\n  uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours;\n\n  // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)\n  mapping(bytes32 =&gt; address) internal protocolAgent_;\n\n  // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)\n  mapping(bytes32 =&gt; uint256) internal nonStakersPercentage;\n\n  // The premium per second paid by each protocol is stored in this mapping\n  mapping(bytes32 =&gt; uint256) internal premiums_;\n\n  // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.\n  // This "active balance" is really just an accounting concept, doesn\'t mean tokens have been transferred or not\n  mapping(bytes32 =&gt; uint256) internal activeBalances;\n\n  // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol\n  mapping(bytes32 =&gt; uint256) internal lastAccountedEachProtocol;\n\n  // The amount that can be claimed by nonstakers for each protocol\n  // We need this value so we can track how much payment is coming from each protocol\n  mapping(bytes32 =&gt; uint256) internal nonStakersClaimableByProtocol;\n\n  // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)\n  uint256 internal lastAccountedGlobal;\n\n  // This is the total amount of premiums paid (per second) by all the covered protocols (added up)\n  uint256 internal allPremiumsPerSecToStakers;\n\n  // This is the amount that was claimable by stakers the last time the accounting was run\n  // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date\n  uint256 internal lastClaimablePremiumsForStakers;\n\n  // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage\n  // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)\n  uint256 public override minActiveBalance;\n\n  // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)\n  mapping(bytes32 =&gt; uint256) internal removedProtocolClaimDeadline;\n\n  // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)\n  mapping(bytes32 =&gt; address) internal removedProtocolAgent;\n\n  // Current amount of coverage (i.e. 20M USDC) for a protocol\n  mapping(bytes32 =&gt; uint256) internal currentCoverage;\n\n  // Previous amount of coverage for a protocol\n  // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount\n  mapping(bytes32 =&gt; uint256) internal previousCoverage;\n\n  // Setting the token to USDC\n  constructor(IERC20 token) {\n    if (address(_token) == address(0)) revert ZeroArgument();\n    token = _token;\n  }\n\n  // Modifier used to ensure a protocol exists (has been instantiated and not removed)\n  modifier protocolExists(bytes32 _protocol) {\n    _verifyProtocolExists(_protocol);\n    ;\n  }\n\n  /// @notice View current protocolAgent of _protocol\n  /// @param protocol Protocol identifier\n  /// @return Address able to submit claims\n  function protocolAgent(bytes32 _protocol) external view override returns (address) {\n    address agent = protocolAgent[protocol];\n    if (agent != address(0)) return agent;\n\n    // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned\n    // Note: Old protocol agent will never be address(0)\n    if (block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]) {\n      return removedProtocolAgent[_protocol];\n    }\n\n    // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned\n    revert ProtocolNotExists(_protocol);\n  }\n\n  // Checks if the protocol exists, then returns the current premium per second being charged\n  /// @notice View current premium of protocol\n  /// @param _protocol Protocol identifier\n  /// @return Amount of premium _protocol pays per second\n  function premium(bytes32 _protocol)\n    external\n    view\n    override\n    protocolExists(_protocol)\n    returns (uint256)\n  {\n    return premiums[protocol];\n  }\n\n  // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)\n  // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)\n  function _verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {\n    _protocolAgent = protocolAgent[protocol];\n    if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);\n  }\n\n  //\n  // View methods\n  //\n\n  // Calcs the debt accrued by the protocol since it last had an accounting update\n  // This is the amount that needs to be removed from a protocol\'s active balance\n  function _calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {\n    return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums[protocol];\n  }\n\n  /// @notice View the amount nonstakers can claim from this protocol\n  /// @param _protocol Protocol identifier\n  /// @return Amount of tokens claimable by nonstakers\n  /// @dev this reads from a storage variable + (now-lastsettled) * premiums\n  // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]\n  // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn\'t change since the protocol has been removed\n  function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {\n    // Calcs the debt of a protocol since the last accounting update\n    uint256 debt = _calcIncrementalProtocolDebt(_protocol);\n    // Gets the active balance of the protocol\n    uint256 balance = activeBalances[_protocol];\n    // The debt should never be higher than the balance (only happens if the arbitrages fail)\n    if (debt &gt; balance) debt = balance;\n\n    // Adds the incremental claimable amount owed to nonstakers to the total claimable amount\n    return\n      nonStakersClaimableByProtocol[_protocol] +\n      (nonStakersPercentage[_protocol] * debt) /\n      HUNDRED_PERCENT;\n  }\n\n  /// @notice View current amount of all premiums that are owed to stakers\n  /// @return Premiums claimable\n  /// @dev Will increase every block\n  /// @dev base + (now - last_settled) * ps\n  function claimablePremiums() public view override returns (uint256) {\n    // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)\n    return\n      lastClaimablePremiumsForStakers +\n      (block.timestamp - lastAccountedGlobal) \n      allPremiumsPerSecToStakers;\n  }\n\n  /// @notice View seconds of coverage left for _protocol before it runs out of active balance\n  /// @param protocol Protocol identifier\n  /// @return Seconds of coverage left\n  function secondsOfCoverageLeft(bytes32 _protocol)\n    external\n    view\n    override\n    protocolExists(_protocol)\n    returns (uint256)\n  {\n    return _secondsOfCoverageLeft(_protocol);\n  }\n\n  // Helper function to return seconds of coverage left for a protocol\n  // Gets the current active balance of the protocol and divides by the premium per second for the protocol\n  function _secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {\n    uint256 premium = premiums[protocol];\n    if (premium == 0) return 0;\n    return _activeBalance(_protocol) / premium;\n  }\n\n  /// @notice View current active balance of covered protocol\n  /// @param _protocol Protocol identifier\n  /// @return Active balance\n  /// @dev Accrued debt is subtracted from the stored active balance\n  function activeBalance(bytes32 _protocol)\n    external\n    view\n    override\n    protocolExists(_protocol)\n    returns (uint256)\n  {\n    return _activeBalance(_protocol);\n  }\n\n  // Helper function to calc the active balance of a protocol at current time\n  function _activeBalance(bytes32 _protocol) internal view returns (uint256) {\n    uint256 debt = _calcIncrementalProtocolDebt(_protocol);\n    uint256 balance = activeBalances[_protocol];\n    // The debt should never be higher than the balance (only happens if the arbitrages fail)\n    if (debt &gt; balance) return 0;\n    return balance - debt;\n  }\n\n  //\n  // State methods\n  //\n\n  /// @notice Helps set the premium per second for an individual protocol\n  /// @param _protocol Protocol identifier\n  /// @param _premium New premium per second\n  /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function\n  function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)\n    internal\n    returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)\n  {\n    // _settleProtocolDebt() subtracts debt from the protocol\'s active balance and updates the % due to nonstakers\n    // Also updates the last accounted timestamp for this protocol\n    // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings\n    // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol\n    nonStakerPercentage = _settleProtocolDebt(_protocol);\n    // Stores the old premium before it gets updated\n    oldPremiumPerSecond = premiums[protocol];\n\n    if (oldPremiumPerSecond != _premium) {\n      // Sets the protocol\'s premium per second to the new value\n      premiums[protocol] = _premium;\n      emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium);\n    }\n    // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing\n    // We don\'t need to check the min balance requirement for arbs because that value doesn\'t change like secondsOfCoverageLeft changes\n    // Effectively we just need to make sure we don\'t accidentally run a protocol\'s active balance down below the point\n    // Where arbs would no longer be incentivized to remove the protocol\n    // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems\n    if (_premium != 0 &amp;&amp; _secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_OF_COVERAGE) {\n      revert InsufficientBalance(_protocol);\n    }\n  }\n\n  /// @notice Sets a single protocol\'s premium per second and also updates the global total of premiums per second\n  /// @param _protocol Protocol identifier\n  /// @param _premium New premium per second\n  function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {\n    // Sets the individual protocol\'s premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings\n    (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(\n      _protocol,\n      _premium\n    );\n    // Settling the total amount of premiums owed to stakers before a new premium per second gets set\n    _settleTotalDebt();\n    // This calculates the new global premium per second that gets paid to stakers\n    // We input the same nonStakerPercentage twice because we simply aren\'t updating that value in this function\n    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(\n      oldPremiumPerSecond,\n      _premium,\n      nonStakerPercentage,\n      nonStakerPercentage,\n      allPremiumsPerSecToStakers\n    );\n  }\n\n  // Internal function to set a new protocolAgent for a specific protocol\n  // _oldAgent is only included as part of emitting an event\n  function _setProtocolAgent(\n    bytes32 _protocol,\n    address _oldAgent,\n    address _protocolAgent\n  ) internal {\n    protocolAgent[protocol] = _protocolAgent;\n    emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);\n  }\n\n  // Subtracts the accrued debt from a protocol\'s active balance\n  // Credits the amount that can be claimed by nonstakers for this protocol\n  // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings\n  // Most of this function is dealing with an edge case related to a protocol not being removed by arbs\n  function _settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {\n    // This calcs the accrued debt of the protocol since it was last updated\n    uint256 debt = _calcIncrementalProtocolDebt(_protocol);\n    // This pulls the percentage that is sent to nonstakers\n    _nonStakerPercentage = nonStakersPercentage[_protocol];\n    // In case the protocol has accrued debt, this code block will ensure the debt is settled properly\n    if (debt != 0) {\n      // Pulls the stored active balance of the protocol\n      uint256 balance = activeBalances[_protocol];\n      // This is the start of handling an edge case where arbitragers don\'t remove this protocol before debt becomes greater than active balance\n      // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point\n      // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage\n      // However, if arbs don\'t come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up\n      if (debt &gt; balance) {\n        // This error amount represents the magnitude of the mistake\n        uint256 error = debt - balance;\n        // Gets the latest value of claimable premiums for stakers\n        _settleTotalDebt();\n        // @note to production, set premium first to zero before solving accounting issue.\n        // otherwise the accounting error keeps increasing\n        uint256 lastClaimablePremiumsForStakers = lastClaimablePremiumsForStakers;\n\n        // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%\n        uint256 claimablePremiumError = ((HUNDRED_PERCENT - nonStakerPercentage) * error) /\n          HUNDRED_PERCENT;\n\n        // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short\n        uint256 insufficientTokens;\n\n        // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally\n        // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error\n        // This first line can be true if claimPremiumsForStakers() has been called and\n        // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be &gt;0 still\n        if (claimablePremiumError &gt; lastClaimablePremiumsForStakers) {\n          insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;\n          lastClaimablePremiumsForStakers = 0;\n        } else {\n          // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums\n          // By the amount that was added in error (error) and insufficientTokens = 0\n          lastClaimablePremiumsForStakers =\n            lastClaimablePremiumsForStakers_ -\n            claimablePremiumError;\n        }\n\n        // If two events are thrown, the values need to be summed up for the actual state.\n        // This means an error of this type will continue until it is handled\n        emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);\n        // We set the debt equal to the balance, and in the next line we effectively set the protocol\'s active balance to 0 in this case\n        debt = balance;\n      }\n      // Subtracts the accrued debt (since last update) from the protocol\'s active balance and updates active balance\n      activeBalances[_protocol] = balance - debt;\n      // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol\n      nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT;\n    }\n    // Updates the last accounted timestamp for this protocol\n    lastAccountedEachProtocol[_protocol] = block.timestamp;\n  }\n\n  // Multiplies the total premium per second * number of seconds since the last global accounting update\n  // And adds it to the total claimable amount for stakers\n  function _settleTotalDebt() internal {\n    lastClaimablePremiumsForStakers +=\n      (block.timestamp - lastAccountedGlobal) \n      allPremiumsPerSecToStakers;\n    lastAccountedGlobal = block.timestamp;\n  }\n\n  // Calculates the global premium per second for stakers\n  // Takes a specific protocol\'s old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers\n  // Subtracts out the old values of a protocol\'s premium per second and nonstaker percentage and adds the new ones\n  function _calcGlobalPremiumPerSecForStakers(\n    uint256 _premiumOld,\n    uint256 _premiumNew,\n    uint256 _nonStakerPercentageOld,\n    uint256 _nonStakerPercentageNew,\n    uint256 _inMemAllPremiumsPerSecToStakers\n  ) internal pure returns (uint256) {\n    return\n      _inMemAllPremiumsPerSecToStakers +\n      ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /\n      HUNDRED_PERCENT -\n      ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /\n      HUNDRED_PERCENT;\n  }\n\n  // Helper function to remove and clean up a protocol from Sherlock\n  // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made\n  function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {\n    // Sets the individual protocol\'s premium to zero and updates the global premium variable for a zero premium at this protocol\n    _setSingleAndGlobalProtocolPremium(_protocol, 0);\n\n    // Grabs the protocol\'s active balance\n    uint256 balance = activeBalances[_protocol];\n\n    // If there\'s still some active balance, delete the entry and send the remaining balance to the protocol agent\n    if (balance != 0) {\n      delete activeBalances[_protocol];\n      token.safeTransfer(_agent, balance);\n\n      emit ProtocolBalanceWithdrawn(_protocol, balance);\n    }\n\n    // Sets the protocol agent to zero address (as part of clean up)\n    _setProtocolAgent(_protocol, _agent, address(0));\n\n    // Cleans up other mappings for this protocol\n    delete nonStakersPercentage[_protocol];\n    delete lastAccountedEachProtocol[_protocol];\n    // premiums_ mapping is not deleted here as it\'s already 0 because of the _setSingleAndGlobalProtocolPremium call above\n\n    // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol\n    removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;\n\n    // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed\n    // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked\n    removedProtocolAgent[_protocol] = _agent;\n\n    emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0));\n    emit ProtocolRemoved(_protocol);\n  }\n\n  /// @notice Sets the minimum active balance before an arb can remove a protocol\n  /// @param _minActiveBalance Minimum balance needed (in USDC)\n  /// @dev Only gov\n  function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {\n    // New value cannot be the same as current value\n    if (minActiveBalance == _minActiveBalance) revert InvalidArgument();\n    // Can\'t set a value that is too high to be reasonable\n    if (_minActiveBalance &gt;= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions();\n\n    emit MinBalance(minActiveBalance, _minActiveBalance);\n    minActiveBalance = _minActiveBalance;\n  }\n\n  // This function allows the nonstakers role to claim tokens owed to them by a specific protocol\n  /// @notice Choose an _amount of tokens that nonstakers (_receiver address) will receive from _protocol\n  /// @param _protocol Protocol identifier\n  /// @param _amount Amount of tokens\n  /// @param _receiver Address to receive tokens\n  /// @dev Only callable by nonstakers role\n  function nonStakersClaim(\n    bytes32 _protocol,\n    uint256 _amount,\n    address _receiver\n  ) external override whenNotPaused {\n    if (_protocol == bytes32(0)) revert ZeroArgument();\n    if (_amount == uint256(0)) revert ZeroArgument();\n    if (_receiver == address(0)) revert ZeroArgument();\n    // Only the nonstakers role (multisig or contract) can pull the funds\n    if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized();\n\n    // Call can\'t be executed on protocol that is removed\n    if (protocolAgent[protocol] != address(0)) {\n      // Updates the amount that nonstakers can claim from this protocol\n      _settleProtocolDebt(_protocol);\n    }\n\n    // Sets balance to the amount that is claimable by nonstakers for this specific protocol\n    uint256 balance = nonStakersClaimableByProtocol[_protocol];\n    // If the amount requested is more than what\'s owed to nonstakers, revert\n    if (_amount &gt; balance) revert InsufficientBalance(_protocol);\n\n    // Sets the claimable amount to whatever is left over after this amount is pulled\n    nonStakersClaimableByProtocol[_protocol] = balance - _amount;\n    // Transfers the amount requested to the _receiver address\n    token.safeTransfer(_receiver, _amount);\n  }\n\n  // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)\n  /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address\n  /// @dev Callable by everyone\n  /// @dev Funds will be transferred to Sherlock core contract\n  function claimPremiumsForStakers() external override whenNotPaused {\n    // Gets address of core Sherlock contract\n    address sherlock = address(sherlockCore);\n    // Revert if core Sherlock contract not initialized yet\n    if (sherlock == address(0)) revert InvalidConditions();\n\n    // claimablePremiums is different from _settleTotalDebt() because it does not change state\n    // Retrieves current amount of all premiums that are owed to stakers\n    uint256 amount = claimablePremiums();\n\n    // Transfers all the premiums owed to stakers to the Sherlock core contract\n    if (amount != 0) {\n      // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out\n      lastClaimablePremiumsForStakers = 0;\n      lastAccountedGlobal = block.timestamp;\n      token.safeTransfer(sherlock, amount);\n    }\n  }\n\n  // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts\n  /// @param _protocol Protocol identifier\n  /// @return current and previous are the current and previous coverage amounts for this protocol\n  // Note For this process to work, a protocol\'s coverage amount should not be set more than once in the span of claim delay period (7 days or something)\n  function coverageAmounts(bytes32 _protocol)\n    external\n    view\n    override\n    returns (uint256 current, uint256 previous)\n  {\n    // Checks to see if the protocol has an active protocolAgent (protocol not removed)\n    // OR checks to see if the removed protocol is still within the claim window\n    // If so, gives the current and previous coverage, otherwise throws an error\n    if (\n      protocolAgent[protocol] != address(0) ||\n      block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]\n    ) {\n      return (currentCoverage[_protocol], previousCoverage[_protocol]);\n    }\n\n    revert ProtocolNotExists(_protocol);\n  }\n\n  /// @notice Add a new protocol to Sherlock\n  /// @param _protocol Protocol identifier\n  /// @param _protocolAgent Address able to submit a claim on behalf of the protocol\n  /// @param _coverage Hash referencing the active coverage agreement\n  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 1018\n  /// @param _coverageAmount Max amount claimable by this protocol\n  /// @dev Adding a protocol allows the _protocolAgent to submit a claim\n  /// @dev Coverage is not started yet as the protocol doesn\'t pay a premium at this point\n  /// @dev _nonStakers is scaled by 1018\n  /// @dev Only callable by governance\n  function protocolAdd(\n    bytes32 _protocol,\n    address _protocolAgent,\n    bytes32 _coverage,\n    uint256 _nonStakers,\n    uint256 _coverageAmount\n  ) external override onlyOwner {\n    if (_protocol == bytes32(0)) revert ZeroArgument();\n    if (_protocolAgent == address(0)) revert ZeroArgument();\n    // Checks to make sure the protocol doesn\'t exist already\n    if (protocolAgent[protocol] != address(0)) revert InvalidConditions();\n\n    // Updates the protocol agent and passes in the old agent which is 0 address in this case\n    _setProtocolAgent(_protocol, address(0), _protocolAgent);\n\n    // Delete mappings that are potentially non default values\n    // From previous time protocol was added/removed\n    delete removedProtocolClaimDeadline[_protocol];\n    delete removedProtocolAgent[_protocol];\n    delete currentCoverage[_protocol];\n    delete previousCoverage[_protocol];\n\n    emit ProtocolAdded(_protocol);\n\n    // Most of the logic for actually adding a protocol in this function\n    protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);\n  }\n\n  /// @notice Update info regarding a protocol\n  /// @param _protocol Protocol identifier\n  /// @param _coverage Hash referencing the active coverage agreement\n  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18\n  /// @param _coverageAmount Max amount claimable by this protocol\n  /// @dev Only callable by governance\n  /// @dev _nonStakers can be 0\n  function protocolUpdate(\n    bytes32 _protocol,\n    bytes32 _coverage,\n    uint256 _nonStakers,\n    uint256 _coverageAmount\n  ) public override onlyOwner {\n    if (_coverage == bytes32(0)) revert ZeroArgument();\n    if (_nonStakers &gt; HUNDRED_PERCENT) revert InvalidArgument();\n    if (_coverageAmount == uint256(0)) revert ZeroArgument();\n\n    // Checks to make sure the protocol has been assigned a protocol agent\n    _verifyProtocolExists(_protocol);\n\n    // Subtracts the accrued debt from a protocol\'s active balance (if any)\n    // Updates the amount that can be claimed by nonstakers\n    _settleProtocolDebt(_protocol);\n\n    // Updates the global claimable amount for stakers\n    _settleTotalDebt();\n\n    // Gets the premium per second for this protocol\n    uint256 premium = premiums[protocol];\n\n    // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be)\n    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(\n      premium,\n      premium,\n      nonStakersPercentage[_protocol],\n      _nonStakers,\n      allPremiumsPerSecToStakers\n    );\n\n    // Updates the stored value of percentage of premiums that go to nonstakers\n    nonStakersPercentage[_protocol] = _nonStakers;\n\n    // Updates previous coverage and current coverage amounts\n    previousCoverage[_protocol] = currentCoverage[_protocol];\n    currentCoverage[_protocol] = _coverageAmount;\n\n    emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);\n  }\n\n  /// @notice Remove a protocol from coverage\n  /// @param _protocol Protocol identifier\n  /// @dev Before removing a protocol the premium must be 0\n  /// @dev Removing a protocol basically stops the _protocolAgent from being active (can still submit claims until claim deadline though)\n  /// @dev Pays off debt + sends remaining balance to protocol agent\n  /// @dev This call should be subject to a timelock\n  /// @dev Only callable by governance\n  function protocolRemove(bytes32 _protocol) external override onlyOwner {\n    // checks to make sure the protocol actually has a protocol agent\n    address agent = _verifyProtocolExists(_protocol);\n\n    // Removes a protocol from Sherlock and cleans up its data\n    // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made\n    _forceRemoveProtocol(_protocol, agent);\n  }\n\n  /// @notice Remove a protocol with insufficient active balance\n  /// @param _protocol Protocol identifier\n  // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function\n  function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {\n    address agent = _verifyProtocolExists(_protocol);\n\n    // Gets the latest value of the active balance at this protocol\n    _settleProtocolDebt(_protocol);\n    // Sets latest value of active balance to remainingBalance variable\n    uint256 remainingBalance = activeBalances[_protocol];\n\n    // This means the protocol still has adequate active balance and thus cannot be removed\n    if (remainingBalance &gt;= minActiveBalance) revert InvalidConditions();\n\n    // Sets the protocol\'s active balance to 0\n    delete activeBalances[_protocol];\n    // Removes the protocol from coverage\n    _forceRemoveProtocol(_protocol, agent);\n\n    if (remainingBalance != 0) {\n      // sends the remaining balance to msg.sender\n      token.safeTransfer(msg.sender, remainingBalance);\n    }\n    emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);\n  }\n\n  /// @notice Calculate if arb is possible and what the reward would be\n  /// @param _protocol Protocol identifier\n  /// @return arbAmount Amount reward for arbing\n  /// @return able Indicator if arb call is even possible\n  /// @dev Doesn\'t subtract the current protocol debt from the active balance\n  function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)\n    internal\n    view\n    returns (uint256 arbAmount, bool able)\n  {\n    uint256 secondsLeft = _secondsOfCoverageLeft(_protocol);\n\n    // If arb is not possible return false\n    if (secondsLeft &gt;= MIN_SECONDS_OF_COVERAGE) return (0, false);\n\n    // This percentage scales over time\n    // Reaches 100% on 0 seconds of coverage left\n    uint256 percentageScaled = HUNDRED_PERCENT -\n      (secondsLeft * HUNDRED_PERCENT) /\n      MIN_SECONDS_OF_COVERAGE;\n\n    able = true;\n    arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;\n  }\n\n  /// @notice Removes a protocol with insufficent seconds of coverage left\n  /// @param _protocol Protocol identifier\n  // Seconds of coverage is defined by the active balance of the protocol divided by the protocol\'s premium per second\n  function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {\n    // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings\n    address agent = _verifyProtocolExists(_protocol);\n\n    // NOTE: We don\'t give the arb the full remaining balance like we do in forceRemoveByActiveBalance()\n    // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance()\n    // But when removing based on seconds of coverage left, the remainingBalance could still be quite large\n    // So it\'s better to scale the arb reward over time. It\'s a little complex because the remainingBalance\n    // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%)\n    _settleProtocolDebt(_protocol);\n    (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol);\n    if (able == false) revert InvalidConditions();\n\n    if (arbAmount != 0) {\n      // subtracts the amount that will be paid to the arb from the active balance\n      activeBalances[_protocol] -= arbAmount;\n    }\n\n    // Removes the protocol from coverage\n    // This function also pays the active balance to the protocol agent, so it\'s good we do this after subtracting arb amount above\n    _forceRemoveProtocol(_protocol, agent);\n\n    // Done after removing protocol to mitigate reentrency pattern\n    // (In case token allows callback)\n    if (arbAmount != 0) {\n      token.safeTransfer(msg.sender, arbAmount);\n    }\n    emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);\n  }\n\n  /// @notice Set premium of _protocol to _premium\n  /// @param _protocol Protocol identifier\n  /// @param _premium Amount of premium _protocol pays per second\n  /// @dev The value 0 would mean inactive coverage\n  /// @dev Only callable by governance\n  function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {\n    // Checks to see if protocol has a protocol agent\n    _verifyProtocolExists(_protocol);\n\n    // Updates individual protocol\'s premium and allPremiumsPerSecToStakers\n    _setSingleAndGlobalProtocolPremium(_protocol, _premium);\n  }\n\n  /// @notice Set premium of multiple protocols\n  /// @param _protocol Array of protocol identifiers\n  /// @param _premium Array of premium amounts protocols pay per second\n  /// @dev The value 0 would mean inactive coverage\n  /// @dev Only callable by governance\n  function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)\n    external\n    override\n    onlyOwner\n  {\n    // Checks to make sure there are an equal amount of entries in each array\n    if (_protocol.length != _premium.length) revert UnequalArrayLength();\n    if (_protocol.length == 0) revert InvalidArgument();\n\n    // Updates the global claimable amount for stakers\n    _settleTotalDebt();\n\n    uint256 allPremiumsPerSecToStakers = allPremiumsPerSecToStakers;\n\n    // Loops through the array of protocols and checks to make sure each has a protocol agent assigned\n    for (uint256 i; i &lt; protocol.length; i++) {\n      _verifyProtocolExists(_protocol[i]);\n\n      // Sets the protocol premium for that specific protocol\n      // Function returns the old premium and nonStakerPercentage for that specific protocol\n      (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(\n        _protocol[i],\n        _premium[i]\n      );\n\n      // Calculates the new global premium which adds up all premiums paid by all protocols\n      allPremiumsPerSecToStakers = calcGlobalPremiumPerSecForStakers(\n        oldPremiumPerSecond,\n        _premium[i],\n        nonStakerPercentage,\n        nonStakerPercentage,\n        allPremiumsPerSecToStakers\n      );\n    }\n\n    // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value\n    allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;\n  }\n\n  // This is how protocols pay for coverage by increasing their active balance\n  /// @notice Deposits _amount of token to the active balance of _protocol\n  /// @param _protocol Protocol identifier\n  /// @param _amount Amount of tokens to deposit\n  /// @dev Approval should be made before calling\n  function depositToActiveBalance(bytes32 _protocol, uint256 _amount)\n    external\n    override\n    whenNotPaused\n  {\n    if (_amount == uint256(0)) revert ZeroArgument();\n    _verifyProtocolExists(_protocol);\n\n    // Transfers _amount to this contract\n    token.safeTransferFrom(msg.sender, address(this), _amount);\n    // Increases the active balance of the protocol by _amount\n    activeBalances[_protocol] += _amount;\n\n    emit ProtocolBalanceDeposited(_protocol, _amount);\n  }\n\n  // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)\n  // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)\n  /// @notice Withdraws _amount of token from the active balance of _protocol\n  /// @param _protocol Protocol identifier\n  /// @param _amount Amount of tokens to withdraw\n  /// @dev Only protocol agent is able to withdraw\n  /// @dev Balance can be withdrawn up until 7 days worth of active balance\n  function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)\n    external\n    override\n    whenNotPaused\n  {\n    if (_amount == uint256(0)) revert ZeroArgument();\n    // Only the protocol agent can call this function\n    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();\n\n    // Updates the active balance of the protocol\n    _settleProtocolDebt(_protocol);\n\n    // Sets currentBalance to the active balance of the protocol\n    uint256 currentBalance = activeBalances[_protocol];\n    // Reverts if trying to withdraw more than the active balance\n    if (_amount &gt; currentBalance) revert InsufficientBalance(_protocol);\n\n    // Removes the _amount to be withdrawn from the active balance\n    activeBalances[_protocol] = currentBalance - _amount;\n    // Reverts if a protocol has less than 7 days worth of active balance left\n    if (_secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);\n\n    // Transfers the amount to the msg.sender (protocol agent)\n    token.safeTransfer(msg.sender, _amount);\n    emit ProtocolBalanceWithdrawn(_protocol, _amount);\n  }\n\n  /// @notice Transfer protocol agent role\n  /// @param _protocol Protocol identifier\n  /// @param _protocolAgent Account able to submit a claim on behalf of the protocol\n  /// @dev Only the active protocolAgent is able to transfer the role\n  function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)\n    external\n    override\n    whenNotPaused\n  {\n    if (_protocolAgent == address(0)) revert ZeroArgument();\n    // Can\'t set the new protocol agent to the caller address\n    if (msg.sender == _protocolAgent) revert InvalidArgument();\n    // Because the caller must be the current protocol agent\n    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();\n\n    // Sets the protocol agent to the new address\n    _setProtocolAgent(_protocol, msg.sender, _protocolAgent);\n  }\n\n  /// @notice Function used to check if this is the current active protocol manager\n  /// @return Boolean indicating it\'s active\n  /// @dev If inactive the owner can pull all ERC20s and ETH\n  /// @dev Will be checked by calling the sherlock contract\n  function isActive() public view returns (bool) {\n    return address(sherlockCore.sherlockProtocolManager()) == address(this);\n  }\n\n  // Only contract owner can call this\n  // Sends all specified tokens in this contract to the receiver\'s address (as well as ETH)\n  function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {\n    if (_receiver == address(0)) revert ZeroArgument();\n    // This contract must NOT be the current assigned protocol manager contract\n    if (isActive()) revert InvalidConditions();\n    // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH\n    _sweep(_receiver, _extraTokens);\n  }\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-25-08 10:59:09 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import './Manager.sol'; import '../interfaces/managers/ISherlockProtocolManager.sol'; /// @title Sherlock core interface for protocols /// @author Evert Kors // This is the contract that manages covered protocols contract SherlockProtocolManager is ISherlockProtocolManager, Manager {   using SafeERC20 for IERC20; // Represents the token that protocols pay with (currently USDC)   IERC20 public immutable token; // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed   uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc // A removed protocol is still able to make a claim for this amount of time after its removal   uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days; // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance   uint256 public constant MIN_SECONDS_LEFT = 7 days; // Convenient for percentage calculations   uint256 internal constant HUNDRED_PERCENT = 10**18; // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage   // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying   uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours; // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)   mapping(bytes32 =&gt; address) internal protocolAgent_; // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)   mapping(bytes32 =&gt; uint256) internal nonStakersPercentage; // The premium per second paid by each protocol is stored in this mapping   mapping(bytes32 =&gt; uint256) internal premiums_; // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.   // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not   mapping(bytes32 =&gt; uint256) internal activeBalances; // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol   mapping(bytes32 =&gt; uint256) internal lastAccountedEachProtocol; // The amount that can be claimed by nonstakers for each protocol   // We need this value so we can track how much payment is coming from each protocol   mapping(bytes32 =&gt; uint256) internal nonStakersClaimableByProtocol; // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)   uint256 internal lastAccountedGlobal; // This is the total amount of premiums paid (per second) by all the covered protocols (added up)   uint256 internal allPremiumsPerSecToStakers; // This is the amount that was claimable by stakers the last time the accounting was run   // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date   uint256 internal lastClaimablePremiumsForStakers; // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage   // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)   uint256 public override minActiveBalance; // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)   mapping(bytes32 =&gt; uint256) internal removedProtocolClaimDeadline; // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)   mapping(bytes32 =&gt; address) internal removedProtocolAgent; // Current amount of coverage (i.e. 20M USDC) for a protocol   mapping(bytes32 =&gt; uint256) internal currentCoverage; // Previous amount of coverage for a protocol   // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount   mapping(bytes32 =&gt; uint256) internal previousCoverage; // Setting the token to USDC   constructor(IERC20 _token) {     if (address(_token) == address(0)) revert ZeroArgument();     token = _token;   } // Modifier used to ensure a protocol exists (has been instantiated and not removed)   modifier protocolExists(bytes32 protocol) {     _verifyProtocolExists(_protocol);     ;   } /// @notice View current protocolAgent of _protocol   /// @param protocol Protocol identifier   /// @return Address able to submit claims   function protocolAgent(bytes32 _protocol) external view override returns (address) {     address agent = protocolAgent[_protocol];     if (agent != address(0)) return agent; // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned // Note: Old protocol agent will never be address(0) if (block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]) {   return removedProtocolAgent[_protocol]; }  // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned revert ProtocolNotExists(_protocol);  } // Checks if the protocol exists, then returns the current premium per second being charged   /// @notice View current premium of protocol   /// @param protocol Protocol identifier   /// @return Amount of premium _protocol pays per second   function premium(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return premiums[_protocol];   } // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)   // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)   function verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {     _protocolAgent = protocolAgent[_protocol];     if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);   } //   // View methods   // // Calcs the debt accrued by the protocol since it last had an accounting update   // This is the amount that needs to be removed from a protocol's active balance   function calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {     return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums[_protocol];   } /// @notice View the amount nonstakers can claim from this protocol   /// @param _protocol Protocol identifier   /// @return Amount of tokens claimable by nonstakers   /// @dev this reads from a storage variable + (now-lastsettled) * premiums   // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]   // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed   function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {     // Calcs the debt of a protocol since the last accounting update     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     // Gets the active balance of the protocol     uint256 balance = activeBalances[_protocol];     // The debt should never be higher than the balance (only happens if the arbitrages fail)     if (debt &gt; balance) debt = balance; // Adds the incremental claimable amount owed to nonstakers to the total claimable amount return   nonStakersClaimableByProtocol[_protocol] +   (nonStakersPercentage[_protocol] * debt) /   HUNDRED_PERCENT;  } /// @notice View current amount of all premiums that are owed to stakers   /// @return Premiums claimable   /// @dev Will increase every block   /// @dev base + (now - last_settled) * ps   function claimablePremiums() public view override returns (uint256) {     // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)     return       lastClaimablePremiumsForStakers +       (block.timestamp - lastAccountedGlobal) *       allPremiumsPerSecToStakers;   } /// @notice View seconds of coverage left for _protocol before it runs out of active balance   /// @param _protocol Protocol identifier   /// @return Seconds of coverage left   function secondsOfCoverageLeft(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return _secondsOfCoverageLeft(_protocol);   } // Helper function to return seconds of coverage left for a protocol   // Gets the current active balance of the protocol and divides by the premium per second for the protocol   function secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {     uint256 premium = premiums[_protocol];     if (premium == 0) return 0;     return _activeBalance(_protocol) / premium;   } /// @notice View current active balance of covered protocol   /// @param _protocol Protocol identifier   /// @return Active balance   /// @dev Accrued debt is subtracted from the stored active balance   function activeBalance(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return _activeBalance(_protocol);   } // Helper function to calc the active balance of a protocol at current time   function _activeBalance(bytes32 _protocol) internal view returns (uint256) {     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     uint256 balance = activeBalances[_protocol];     // The debt should never be higher than the balance (only happens if the arbitrages fail)     if (debt &gt; balance) return 0;     return balance - debt;   } //   // State methods   // /// @notice Helps set the premium per second for an individual protocol   /// @param protocol Protocol identifier   /// @param _premium New premium per second   /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function   function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)     internal     returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)   {     // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers     // Also updates the last accounted timestamp for this protocol     // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings     // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol     nonStakerPercentage = _settleProtocolDebt(_protocol);     // Stores the old premium before it gets updated     oldPremiumPerSecond = premiums[_protocol]; if (oldPremiumPerSecond != _premium) {   // Sets the protocol's premium per second to the new value   premiums_[_protocol] = _premium;   emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium); } // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point // Where arbs would no longer be incentivized to remove the protocol // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems if (_premium != 0 &amp;&amp; _secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_OF_COVERAGE) {   revert InsufficientBalance(_protocol); }  } /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second   /// @param _protocol Protocol identifier   /// @param _premium New premium per second   function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {     // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings     (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(       _protocol,       _premium     );     // Settling the total amount of premiums owed to stakers before a new premium per second gets set     _settleTotalDebt();     // This calculates the new global premium per second that gets paid to stakers     // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function     allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(       oldPremiumPerSecond,       _premium,       nonStakerPercentage,       nonStakerPercentage,       allPremiumsPerSecToStakers     );   } // Internal function to set a new protocolAgent for a specific protocol   // oldAgent is only included as part of emitting an event   function _setProtocolAgent(     bytes32 _protocol,     address _oldAgent,     address _protocolAgent   ) internal {     protocolAgent[_protocol] = _protocolAgent;     emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);   } // Subtracts the accrued debt from a protocol's active balance   // Credits the amount that can be claimed by nonstakers for this protocol   // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings   // Most of this function is dealing with an edge case related to a protocol not being removed by arbs   function settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {     // This calcs the accrued debt of the protocol since it was last updated     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     // This pulls the percentage that is sent to nonstakers     _nonStakerPercentage = nonStakersPercentage[_protocol];     // In case the protocol has accrued debt, this code block will ensure the debt is settled properly     if (debt != 0) {       // Pulls the stored active balance of the protocol       uint256 balance = activeBalances[_protocol];       // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance       // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point       // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage       // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up       if (debt &gt; balance) {         // This error amount represents the magnitude of the mistake         uint256 error = debt - balance;         // Gets the latest value of claimable premiums for stakers         _settleTotalDebt();         // @note to production, set premium first to zero before solving accounting issue.         // otherwise the accounting error keeps increasing         uint256 lastClaimablePremiumsForStakers = lastClaimablePremiumsForStakers;     // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%     uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /       HUNDRED_PERCENT;      // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short     uint256 insufficientTokens;      // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally     // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error     // This first line can be true if claimPremiumsForStakers() has been called and     // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be &gt;0 still     if (claimablePremiumError &gt; lastClaimablePremiumsForStakers_) {       insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;       lastClaimablePremiumsForStakers = 0;     } else {       // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums       // By the amount that was added in error (error) and insufficientTokens = 0       lastClaimablePremiumsForStakers =         lastClaimablePremiumsForStakers_ -         claimablePremiumError;     }      // If two events are thrown, the values need to be summed up for the actual state.     // This means an error of this type will continue until it is handled     emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);     // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case     debt = balance;   }   // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance   activeBalances[_protocol] = balance - debt;   // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol   nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT; } // Updates the last accounted timestamp for this protocol lastAccountedEachProtocol[_protocol] = block.timestamp;  } // Multiplies the total premium per second * number of seconds since the last global accounting update   // And adds it to the total claimable amount for stakers   function _settleTotalDebt() internal {     lastClaimablePremiumsForStakers +=       (block.timestamp - lastAccountedGlobal) *       allPremiumsPerSecToStakers;     lastAccountedGlobal = block.timestamp;   } // Calculates the global premium per second for stakers   // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers   // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones   function _calcGlobalPremiumPerSecForStakers(     uint256 _premiumOld,     uint256 _premiumNew,     uint256 _nonStakerPercentageOld,     uint256 _nonStakerPercentageNew,     uint256 _inMemAllPremiumsPerSecToStakers   ) internal pure returns (uint256) {     return       _inMemAllPremiumsPerSecToStakers +       ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /       HUNDRED_PERCENT -       ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /       HUNDRED_PERCENT;   } // Helper function to remove and clean up a protocol from Sherlock   // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made   function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {     // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol     _setSingleAndGlobalProtocolPremium(_protocol, 0); // Grabs the protocol's active balance uint256 balance = activeBalances[_protocol];  // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent if (balance != 0) {   delete activeBalances[_protocol];   token.safeTransfer(_agent, balance);    emit ProtocolBalanceWithdrawn(_protocol, balance); }  // Sets the protocol agent to zero address (as part of clean up) _setProtocolAgent(_protocol, _agent, address(0));  // Cleans up other mappings for this protocol delete nonStakersPercentage[_protocol]; delete lastAccountedEachProtocol[_protocol]; // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above  // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;  // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked removedProtocolAgent[_protocol] = _agent;  emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0)); emit ProtocolRemoved(_protocol);  } /// @notice Sets the minimum active balance before an arb can remove a protocol   /// @param _minActiveBalance Minimum balance needed (in USDC)   /// @dev Only gov   function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {     // New value cannot be the same as current value     if (minActiveBalance == _minActiveBalance) revert InvalidArgument();     // Can't set a value that is too high to be reasonable     if (_minActiveBalance &gt;= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions(); emit MinBalance(minActiveBalance, _minActiveBalance); minActiveBalance = _minActiveBalance;  } // This function allows the nonstakers role to claim tokens owed to them by a specific protocol   /// @notice Choose an _amount of tokens that nonstakers (_receiver address) will receive from _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens   /// @param _receiver Address to receive tokens   /// @dev Only callable by nonstakers role   function nonStakersClaim(     bytes32 _protocol,     uint256 _amount,     address _receiver   ) external override whenNotPaused {     if (_protocol == bytes32(0)) revert ZeroArgument();     if (_amount == uint256(0)) revert ZeroArgument();     if (_receiver == address(0)) revert ZeroArgument();     // Only the nonstakers role (multisig or contract) can pull the funds     if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized(); // Call can't be executed on protocol that is removed if (protocolAgent_[_protocol] != address(0)) {   // Updates the amount that nonstakers can claim from this protocol   _settleProtocolDebt(_protocol); }  // Sets balance to the amount that is claimable by nonstakers for this specific protocol uint256 balance = nonStakersClaimableByProtocol[_protocol]; // If the amount requested is more than what's owed to nonstakers, revert if (_amount &gt; balance) revert InsufficientBalance(_protocol);  // Sets the claimable amount to whatever is left over after this amount is pulled nonStakersClaimableByProtocol[_protocol] = balance - _amount; // Transfers the amount requested to the `_receiver` address token.safeTransfer(_receiver, _amount);  } // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)   /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address   /// @dev Callable by everyone   /// @dev Funds will be transferred to Sherlock core contract   function claimPremiumsForStakers() external override whenNotPaused {     // Gets address of core Sherlock contract     address sherlock = address(sherlockCore);     // Revert if core Sherlock contract not initialized yet     if (sherlock == address(0)) revert InvalidConditions(); // claimablePremiums is different from _settleTotalDebt() because it does not change state // Retrieves current amount of all premiums that are owed to stakers uint256 amount = claimablePremiums();  // Transfers all the premiums owed to stakers to the Sherlock core contract if (amount != 0) {   // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out   lastClaimablePremiumsForStakers = 0;   lastAccountedGlobal = block.timestamp;   token.safeTransfer(sherlock, amount); }  } // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts   /// @param protocol Protocol identifier   /// @return current and previous are the current and previous coverage amounts for this protocol   // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)   function coverageAmounts(bytes32 _protocol)     external     view     override     returns (uint256 current, uint256 previous)   {     // Checks to see if the protocol has an active protocolAgent (protocol not removed)     // OR checks to see if the removed protocol is still within the claim window     // If so, gives the current and previous coverage, otherwise throws an error     if (       protocolAgent[_protocol] != address(0) ||       block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]     ) {       return (currentCoverage[_protocol], previousCoverage[_protocol]);     } revert ProtocolNotExists(_protocol);  } /// @notice Add a new protocol to Sherlock   /// @param protocol Protocol identifier   /// @param _protocolAgent Address able to submit a claim on behalf of the protocol   /// @param _coverage Hash referencing the active coverage agreement   /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 1018   /// @param _coverageAmount Max amount claimable by this protocol   /// @dev Adding a protocol allows the _protocolAgent to submit a claim   /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point   /// @dev _nonStakers is scaled by 1018   /// @dev Only callable by governance   function protocolAdd(     bytes32 _protocol,     address _protocolAgent,     bytes32 _coverage,     uint256 _nonStakers,     uint256 _coverageAmount   ) external override onlyOwner {     if (_protocol == bytes32(0)) revert ZeroArgument();     if (_protocolAgent == address(0)) revert ZeroArgument();     // Checks to make sure the protocol doesn't exist already     if (protocolAgent[_protocol] != address(0)) revert InvalidConditions(); // Updates the protocol agent and passes in the old agent which is 0 address in this case _setProtocolAgent(_protocol, address(0), _protocolAgent);  // Delete mappings that are potentially non default values // From previous time protocol was added/removed delete removedProtocolClaimDeadline[_protocol]; delete removedProtocolAgent[_protocol]; delete currentCoverage[_protocol]; delete previousCoverage[_protocol];  emit ProtocolAdded(_protocol);  // Most of the logic for actually adding a protocol in this function protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);  } /// @notice Update info regarding a protocol   /// @param _protocol Protocol identifier   /// @param _coverage Hash referencing the active coverage agreement   /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18   /// @param _coverageAmount Max amount claimable by this protocol   /// @dev Only callable by governance   /// @dev _nonStakers can be 0   function protocolUpdate(     bytes32 _protocol,     bytes32 _coverage,     uint256 _nonStakers,     uint256 _coverageAmount   ) public override onlyOwner {     if (_coverage == bytes32(0)) revert ZeroArgument();     if (_nonStakers &gt; HUNDRED_PERCENT) revert InvalidArgument();     if (_coverageAmount == uint256(0)) revert ZeroArgument(); // Checks to make sure the protocol has been assigned a protocol agent _verifyProtocolExists(_protocol);  // Subtracts the accrued debt from a protocol's active balance (if any) // Updates the amount that can be claimed by nonstakers _settleProtocolDebt(_protocol);  // Updates the global claimable amount for stakers _settleTotalDebt();  // Gets the premium per second for this protocol uint256 premium = premiums_[_protocol];  // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be) allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(   premium,   premium,   nonStakersPercentage[_protocol],   _nonStakers,   allPremiumsPerSecToStakers );  // Updates the stored value of percentage of premiums that go to nonstakers nonStakersPercentage[_protocol] = _nonStakers;  // Updates previous coverage and current coverage amounts previousCoverage[_protocol] = currentCoverage[_protocol]; currentCoverage[_protocol] = _coverageAmount;  emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);  } /// @notice Remove a protocol from coverage   /// @param _protocol Protocol identifier   /// @dev Before removing a protocol the premium must be 0   /// @dev Removing a protocol basically stops the _protocolAgent from being active (can still submit claims until claim deadline though)   /// @dev Pays off debt + sends remaining balance to protocol agent   /// @dev This call should be subject to a timelock   /// @dev Only callable by governance   function protocolRemove(bytes32 _protocol) external override onlyOwner {     // checks to make sure the protocol actually has a protocol agent     address agent = _verifyProtocolExists(_protocol); // Removes a protocol from Sherlock and cleans up its data // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made _forceRemoveProtocol(_protocol, agent);  } /// @notice Remove a protocol with insufficient active balance   /// @param _protocol Protocol identifier   // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function   function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {     address agent = _verifyProtocolExists(_protocol); // Gets the latest value of the active balance at this protocol _settleProtocolDebt(_protocol); // Sets latest value of active balance to remainingBalance variable uint256 remainingBalance = activeBalances[_protocol];  // This means the protocol still has adequate active balance and thus cannot be removed if (remainingBalance &gt;= minActiveBalance) revert InvalidConditions();  // Sets the protocol's active balance to 0 delete activeBalances[_protocol]; // Removes the protocol from coverage _forceRemoveProtocol(_protocol, agent);  if (remainingBalance != 0) {   // sends the remaining balance to msg.sender   token.safeTransfer(msg.sender, remainingBalance); } emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);  } /// @notice Calculate if arb is possible and what the reward would be   /// @param _protocol Protocol identifier   /// @return arbAmount Amount reward for arbing   /// @return able Indicator if arb call is even possible   /// @dev Doesn't subtract the current protocol debt from the active balance   function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)     internal     view     returns (uint256 arbAmount, bool able)   {     uint256 secondsLeft = _secondsOfCoverageLeft(_protocol); // If arb is not possible return false if (secondsLeft &gt;= MIN_SECONDS_OF_COVERAGE) return (0, false);  // This percentage scales over time // Reaches 100% on 0 seconds of coverage left uint256 percentageScaled = HUNDRED_PERCENT -   (secondsLeft * HUNDRED_PERCENT) /   MIN_SECONDS_OF_COVERAGE;  able = true; arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;  } /// @notice Removes a protocol with insufficent seconds of coverage left   /// @param _protocol Protocol identifier   // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second   function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {     // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings     address agent = _verifyProtocolExists(_protocol); // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance() // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance() // But when removing based on seconds of coverage left, the remainingBalance could still be quite large // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%) _settleProtocolDebt(_protocol); (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol); if (able == false) revert InvalidConditions();  if (arbAmount != 0) {   // subtracts the amount that will be paid to the arb from the active balance   activeBalances[_protocol] -= arbAmount; }  // Removes the protocol from coverage // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above _forceRemoveProtocol(_protocol, agent);  // Done after removing protocol to mitigate reentrency pattern // (In case token allows callback) if (arbAmount != 0) {   token.safeTransfer(msg.sender, arbAmount); } emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);  } /// @notice Set premium of _protocol to _premium   /// @param _protocol Protocol identifier   /// @param _premium Amount of premium _protocol pays per second   /// @dev The value 0 would mean inactive coverage   /// @dev Only callable by governance   function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {     // Checks to see if protocol has a protocol agent     _verifyProtocolExists(_protocol); // Updates individual protocol's premium and allPremiumsPerSecToStakers _setSingleAndGlobalProtocolPremium(_protocol, _premium);  } /// @notice Set premium of multiple protocols   /// @param _protocol Array of protocol identifiers   /// @param _premium Array of premium amounts protocols pay per second   /// @dev The value 0 would mean inactive coverage   /// @dev Only callable by governance   function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)     external     override     onlyOwner   {     // Checks to make sure there are an equal amount of entries in each array     if (_protocol.length != _premium.length) revert UnequalArrayLength();     if (_protocol.length == 0) revert InvalidArgument(); // Updates the global claimable amount for stakers _settleTotalDebt();  uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;  // Loops through the array of protocols and checks to make sure each has a protocol agent assigned for (uint256 i; i &lt; _protocol.length; i++) {   _verifyProtocolExists(_protocol[i]);    // Sets the protocol premium for that specific protocol   // Function returns the old premium and nonStakerPercentage for that specific protocol   (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(     _protocol[i],     _premium[i]   );    // Calculates the new global premium which adds up all premiums paid by all protocols   allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(     oldPremiumPerSecond,     _premium[i],     nonStakerPercentage,     nonStakerPercentage,     allPremiumsPerSecToStakers_   ); }  // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;  } // This is how protocols pay for coverage by increasing their active balance   /// @notice Deposits _amount of token to the active balance of _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens to deposit   /// @dev Approval should be made before calling   function depositToActiveBalance(bytes32 _protocol, uint256 _amount)     external     override     whenNotPaused   {     if (_amount == uint256(0)) revert ZeroArgument();     _verifyProtocolExists(_protocol); // Transfers _amount to this contract token.safeTransferFrom(msg.sender, address(this), _amount); // Increases the active balance of the protocol by _amount activeBalances[_protocol] += _amount;  emit ProtocolBalanceDeposited(_protocol, _amount);  } // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)   // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)   /// @notice Withdraws _amount of token from the active balance of _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens to withdraw   /// @dev Only protocol agent is able to withdraw   /// @dev Balance can be withdrawn up until 7 days worth of active balance   function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)     external     override     whenNotPaused   {     if (_amount == uint256(0)) revert ZeroArgument();     // Only the protocol agent can call this function     if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized(); // Updates the active balance of the protocol _settleProtocolDebt(_protocol);  // Sets currentBalance to the active balance of the protocol uint256 currentBalance = activeBalances[_protocol]; // Reverts if trying to withdraw more than the active balance if (_amount &gt; currentBalance) revert InsufficientBalance(_protocol);  // Removes the _amount to be withdrawn from the active balance activeBalances[_protocol] = currentBalance - _amount; // Reverts if a protocol has less than 7 days worth of active balance left if (_secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);  // Transfers the amount to the msg.sender (protocol agent) token.safeTransfer(msg.sender, _amount); emit ProtocolBalanceWithdrawn(_protocol, _amount);  } /// @notice Transfer protocol agent role   /// @param _protocol Protocol identifier   /// @param _protocolAgent Account able to submit a claim on behalf of the protocol   /// @dev Only the active protocolAgent is able to transfer the role   function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)     external     override     whenNotPaused   {     if (_protocolAgent == address(0)) revert ZeroArgument();     // Can't set the new protocol agent to the caller address     if (msg.sender == _protocolAgent) revert InvalidArgument();     // Because the caller must be the current protocol agent     if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized(); // Sets the protocol agent to the new address _setProtocolAgent(_protocol, msg.sender, _protocolAgent);  } /// @notice Function used to check if this is the current active protocol manager   /// @return Boolean indicating it's active   /// @dev If inactive the owner can pull all ERC20s and ETH   /// @dev Will be checked by calling the sherlock contract   function isActive() public view returns (bool) {     return address(sherlockCore.sherlockProtocolManager()) == address(this);   } // Only contract owner can call this   // Sends all specified tokens in this contract to the receiver's address (as well as ETH)   function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {     if (_receiver == address(0)) revert ZeroArgument();     // This contract must NOT be the current assigned protocol manager contract     if (isActive()) revert InvalidConditions();     // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH     _sweep(_receiver, _extraTokens);   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-25-08 10:59:09 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import './Manager.sol';
import '../interfaces/managers/ISherlockProtocolManager.sol';

/// @title Sherlock core interface for protocols
/// @author Evert Kors
// This is the contract that manages covered protocols

contract SherlockProtocolManager is ISherlockProtocolManager, Manager {
  using SafeERC20 for IERC20;

  // Represents the token that protocols pay with (currently USDC)
  IERC20 public immutable token;

  // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed
  uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc

  // A removed protocol is still able to make a claim for this amount of time after its removal
  uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days;

  // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance
  uint256 public constant MIN_SECONDS_LEFT = 7 days;

  // Convenient for percentage calculations
  uint256 internal constant HUNDRED_PERCENT = 10**18;

  // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage
  // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying
  uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours;

  // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)
  mapping(bytes32 => address) internal protocolAgent_;

  // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)
  mapping(bytes32 => uint256) internal nonStakersPercentage;

  // The premium per second paid by each protocol is stored in this mapping
  mapping(bytes32 => uint256) internal premiums_;

  // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.
  // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not
  mapping(bytes32 => uint256) internal activeBalances;

  // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol
  mapping(bytes32 => uint256) internal lastAccountedEachProtocol;

  // The amount that can be claimed by nonstakers for each protocol
  // We need this value so we can track how much payment is coming from each protocol
  mapping(bytes32 => uint256) internal nonStakersClaimableByProtocol;

  // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)
  uint256 internal lastAccountedGlobal;

  // This is the total amount of premiums paid (per second) by all the covered protocols (added up)
  uint256 internal allPremiumsPerSecToStakers;

  // This is the amount that was claimable by stakers the last time the accounting was run
  // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date
  uint256 internal lastClaimablePremiumsForStakers;

  // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage
  // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)
  uint256 public override minActiveBalance;

  // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)
  mapping(bytes32 => uint256) internal removedProtocolClaimDeadline;

  // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)
  mapping(bytes32 => address) internal removedProtocolAgent;

  // Current amount of coverage (i.e. 20M USDC) for a protocol
  mapping(bytes32 => uint256) internal currentCoverage;

  // Previous amount of coverage for a protocol
  // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount
  mapping(bytes32 => uint256) internal previousCoverage;

  // Setting the token to USDC
  constructor(IERC20 _token) {
    if (address(_token) == address(0)) revert ZeroArgument();
    token = _token;
  }

  // Modifier used to ensure a protocol exists (has been instantiated and not removed)
  modifier protocolExists(bytes32 _protocol) {
    _verifyProtocolExists(_protocol);
    _;
  }

  /// @notice View current protocolAgent of `_protocol`
  /// @param _protocol Protocol identifier
  /// @return Address able to submit claims
  function protocolAgent(bytes32 _protocol) external view override returns (address) {
    address agent = protocolAgent_[_protocol];
    if (agent != address(0)) return agent;

    // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned
    // Note: Old protocol agent will never be address(0)
    if (block.timestamp <= removedProtocolClaimDeadline[_protocol]) {
      return removedProtocolAgent[_protocol];
    }

    // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned
    revert ProtocolNotExists(_protocol);
  }

  // Checks if the protocol exists, then returns the current premium per second being charged
  /// @notice View current premium of protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of premium `_protocol` pays per second
  function premium(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return premiums_[_protocol];
  }

  // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)
  // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)
  function _verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {
    _protocolAgent = protocolAgent_[_protocol];
    if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);
  }

  //
  // View methods
  //

  // Calcs the debt accrued by the protocol since it last had an accounting update
  // This is the amount that needs to be removed from a protocol's active balance
  function _calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {
    return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums_[_protocol];
  }

  /// @notice View the amount nonstakers can claim from this protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of tokens claimable by nonstakers
  /// @dev this reads from a storage variable + (now-lastsettled) * premiums
  // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]
  // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed
  function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {
    // Calcs the debt of a protocol since the last accounting update
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // Gets the active balance of the protocol
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) debt = balance;

    // Adds the incremental claimable amount owed to nonstakers to the total claimable amount
    return
      nonStakersClaimableByProtocol[_protocol] +
      (nonStakersPercentage[_protocol] * debt) /
      HUNDRED_PERCENT;
  }

  /// @notice View current amount of all premiums that are owed to stakers
  /// @return Premiums claimable
  /// @dev Will increase every block
  /// @dev base + (now - last_settled) * ps
  function claimablePremiums() public view override returns (uint256) {
    // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)
    return
      lastClaimablePremiumsForStakers +
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
  }

  /// @notice View seconds of coverage left for `_protocol` before it runs out of active balance
  /// @param _protocol Protocol identifier
  /// @return Seconds of coverage left
  function secondsOfCoverageLeft(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _secondsOfCoverageLeft(_protocol);
  }

  // Helper function to return seconds of coverage left for a protocol
  // Gets the current active balance of the protocol and divides by the premium per second for the protocol
  function _secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {
    uint256 premium = premiums_[_protocol];
    if (premium == 0) return 0;
    return _activeBalance(_protocol) / premium;
  }

  /// @notice View current active balance of covered protocol
  /// @param _protocol Protocol identifier
  /// @return Active balance
  /// @dev Accrued debt is subtracted from the stored active balance
  function activeBalance(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _activeBalance(_protocol);
  }

  // Helper function to calc the active balance of a protocol at current time
  function _activeBalance(bytes32 _protocol) internal view returns (uint256) {
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) return 0;
    return balance - debt;
  }

  //
  // State methods
  //

  /// @notice Helps set the premium per second for an individual protocol
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function
  function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)
    internal
    returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)
  {
    // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers
    // Also updates the last accounted timestamp for this protocol
    // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings
    // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol
    nonStakerPercentage = _settleProtocolDebt(_protocol);
    // Stores the old premium before it gets updated
    oldPremiumPerSecond = premiums_[_protocol];

    if (oldPremiumPerSecond != _premium) {
      // Sets the protocol's premium per second to the new value
      premiums_[_protocol] = _premium;
      emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium);
    }
    // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing
    // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes
    // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point
    // Where arbs would no longer be incentivized to remove the protocol
    // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems
    if (_premium != 0 && _secondsOfCoverageLeft(_protocol) < MIN_SECONDS_OF_COVERAGE) {
      revert InsufficientBalance(_protocol);
    }
  }

  /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {
    // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings
    (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
      _protocol,
      _premium
    );
    // Settling the total amount of premiums owed to stakers before a new premium per second gets set
    _settleTotalDebt();
    // This calculates the new global premium per second that gets paid to stakers
    // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      oldPremiumPerSecond,
      _premium,
      nonStakerPercentage,
      nonStakerPercentage,
      allPremiumsPerSecToStakers
    );
  }

  // Internal function to set a new protocolAgent for a specific protocol
  // _oldAgent is only included as part of emitting an event
  function _setProtocolAgent(
    bytes32 _protocol,
    address _oldAgent,
    address _protocolAgent
  ) internal {
    protocolAgent_[_protocol] = _protocolAgent;
    emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);
  }

  // Subtracts the accrued debt from a protocol's active balance
  // Credits the amount that can be claimed by nonstakers for this protocol
  // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings
  // Most of this function is dealing with an edge case related to a protocol not being removed by arbs
  function _settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {
    // This calcs the accrued debt of the protocol since it was last updated
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // This pulls the percentage that is sent to nonstakers
    _nonStakerPercentage = nonStakersPercentage[_protocol];
    // In case the protocol has accrued debt, this code block will ensure the debt is settled properly
    if (debt != 0) {
      // Pulls the stored active balance of the protocol
      uint256 balance = activeBalances[_protocol];
      // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance
      // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point
      // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage
      // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up
      if (debt > balance) {
        // This error amount represents the magnitude of the mistake
        uint256 error = debt - balance;
        // Gets the latest value of claimable premiums for stakers
        _settleTotalDebt();
        // @note to production, set premium first to zero before solving accounting issue.
        // otherwise the accounting error keeps increasing
        uint256 lastClaimablePremiumsForStakers_ = lastClaimablePremiumsForStakers;

        // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%
        uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /
          HUNDRED_PERCENT;

        // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short
        uint256 insufficientTokens;

        // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally
        // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error
        // This first line can be true if claimPremiumsForStakers() has been called and
        // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be >0 still
        if (claimablePremiumError > lastClaimablePremiumsForStakers_) {
          insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;
          lastClaimablePremiumsForStakers = 0;
        } else {
          // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums
          // By the amount that was added in error (error) and insufficientTokens = 0
          lastClaimablePremiumsForStakers =
            lastClaimablePremiumsForStakers_ -
            claimablePremiumError;
        }

        // If two events are thrown, the values need to be summed up for the actual state.
        // This means an error of this type will continue until it is handled
        emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);
        // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case
        debt = balance;
      }
      // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance
      activeBalances[_protocol] = balance - debt;
      // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol
      nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT;
    }
    // Updates the last accounted timestamp for this protocol
    lastAccountedEachProtocol[_protocol] = block.timestamp;
  }

  // Multiplies the total premium per second * number of seconds since the last global accounting update
  // And adds it to the total claimable amount for stakers
  function _settleTotalDebt() internal {
    lastClaimablePremiumsForStakers +=
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
    lastAccountedGlobal = block.timestamp;
  }

  // Calculates the global premium per second for stakers
  // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers
  // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones
  function _calcGlobalPremiumPerSecForStakers(
    uint256 _premiumOld,
    uint256 _premiumNew,
    uint256 _nonStakerPercentageOld,
    uint256 _nonStakerPercentageNew,
    uint256 _inMemAllPremiumsPerSecToStakers
  ) internal pure returns (uint256) {
    return
      _inMemAllPremiumsPerSecToStakers +
      ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /
      HUNDRED_PERCENT -
      ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /
      HUNDRED_PERCENT;
  }

  // Helper function to remove and clean up a protocol from Sherlock
  // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made
  function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {
    // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol
    _setSingleAndGlobalProtocolPremium(_protocol, 0);

    // Grabs the protocol's active balance
    uint256 balance = activeBalances[_protocol];

    // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent
    if (balance != 0) {
      delete activeBalances[_protocol];
      token.safeTransfer(_agent, balance);

      emit ProtocolBalanceWithdrawn(_protocol, balance);
    }

    // Sets the protocol agent to zero address (as part of clean up)
    _setProtocolAgent(_protocol, _agent, address(0));

    // Cleans up other mappings for this protocol
    delete nonStakersPercentage[_protocol];
    delete lastAccountedEachProtocol[_protocol];
    // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above

    // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol
    removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;

    // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed
    // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked
    removedProtocolAgent[_protocol] = _agent;

    emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0));
    emit ProtocolRemoved(_protocol);
  }

  /// @notice Sets the minimum active balance before an arb can remove a protocol
  /// @param _minActiveBalance Minimum balance needed (in USDC)
  /// @dev Only gov
  function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {
    // New value cannot be the same as current value
    if (minActiveBalance == _minActiveBalance) revert InvalidArgument();
    // Can't set a value that is too high to be reasonable
    if (_minActiveBalance >= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions();

    emit MinBalance(minActiveBalance, _minActiveBalance);
    minActiveBalance = _minActiveBalance;
  }

  // This function allows the nonstakers role to claim tokens owed to them by a specific protocol
  /// @notice Choose an `_amount` of tokens that nonstakers (`_receiver` address) will receive from `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens
  /// @param _receiver Address to receive tokens
  /// @dev Only callable by nonstakers role
  function nonStakersClaim(
    bytes32 _protocol,
    uint256 _amount,
    address _receiver
  ) external override whenNotPaused {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_amount == uint256(0)) revert ZeroArgument();
    if (_receiver == address(0)) revert ZeroArgument();
    // Only the nonstakers role (multisig or contract) can pull the funds
    if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized();

    // Call can't be executed on protocol that is removed
    if (protocolAgent_[_protocol] != address(0)) {
      // Updates the amount that nonstakers can claim from this protocol
      _settleProtocolDebt(_protocol);
    }

    // Sets balance to the amount that is claimable by nonstakers for this specific protocol
    uint256 balance = nonStakersClaimableByProtocol[_protocol];
    // If the amount requested is more than what's owed to nonstakers, revert
    if (_amount > balance) revert InsufficientBalance(_protocol);

    // Sets the claimable amount to whatever is left over after this amount is pulled
    nonStakersClaimableByProtocol[_protocol] = balance - _amount;
    // Transfers the amount requested to the `_receiver` address
    token.safeTransfer(_receiver, _amount);
  }

  // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)
  /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address
  /// @dev Callable by everyone
  /// @dev Funds will be transferred to Sherlock core contract
  function claimPremiumsForStakers() external override whenNotPaused {
    // Gets address of core Sherlock contract
    address sherlock = address(sherlockCore);
    // Revert if core Sherlock contract not initialized yet
    if (sherlock == address(0)) revert InvalidConditions();

    // claimablePremiums is different from _settleTotalDebt() because it does not change state
    // Retrieves current amount of all premiums that are owed to stakers
    uint256 amount = claimablePremiums();

    // Transfers all the premiums owed to stakers to the Sherlock core contract
    if (amount != 0) {
      // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out
      lastClaimablePremiumsForStakers = 0;
      lastAccountedGlobal = block.timestamp;
      token.safeTransfer(sherlock, amount);
    }
  }

  // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts
  /// @param _protocol Protocol identifier
  /// @return current and previous are the current and previous coverage amounts for this protocol
  // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)
  function coverageAmounts(bytes32 _protocol)
    external
    view
    override
    returns (uint256 current, uint256 previous)
  {
    // Checks to see if the protocol has an active protocolAgent (protocol not removed)
    // OR checks to see if the removed protocol is still within the claim window
    // If so, gives the current and previous coverage, otherwise throws an error
    if (
      protocolAgent_[_protocol] != address(0) ||
      block.timestamp <= removedProtocolClaimDeadline[_protocol]
    ) {
      return (currentCoverage[_protocol], previousCoverage[_protocol]);
    }

    revert ProtocolNotExists(_protocol);
  }

  /// @notice Add a new protocol to Sherlock
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Address able to submit a claim on behalf of the protocol
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Adding a protocol allows the `_protocolAgent` to submit a claim
  /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point
  /// @dev `_nonStakers` is scaled by 10**18
  /// @dev Only callable by governance
  function protocolAdd(
    bytes32 _protocol,
    address _protocolAgent,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) external override onlyOwner {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Checks to make sure the protocol doesn't exist already
    if (protocolAgent_[_protocol] != address(0)) revert InvalidConditions();

    // Updates the protocol agent and passes in the old agent which is 0 address in this case
    _setProtocolAgent(_protocol, address(0), _protocolAgent);

    // Delete mappings that are potentially non default values
    // From previous time protocol was added/removed
    delete removedProtocolClaimDeadline[_protocol];
    delete removedProtocolAgent[_protocol];
    delete currentCoverage[_protocol];
    delete previousCoverage[_protocol];

    emit ProtocolAdded(_protocol);

    // Most of the logic for actually adding a protocol in this function
    protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Update info regarding a protocol
  /// @param _protocol Protocol identifier
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Only callable by governance
  /// @dev `_nonStakers` can be 0
  function protocolUpdate(
    bytes32 _protocol,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) public override onlyOwner {
    if (_coverage == bytes32(0)) revert ZeroArgument();
    if (_nonStakers > HUNDRED_PERCENT) revert InvalidArgument();
    if (_coverageAmount == uint256(0)) revert ZeroArgument();

    // Checks to make sure the protocol has been assigned a protocol agent
    _verifyProtocolExists(_protocol);

    // Subtracts the accrued debt from a protocol's active balance (if any)
    // Updates the amount that can be claimed by nonstakers
    _settleProtocolDebt(_protocol);

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    // Gets the premium per second for this protocol
    uint256 premium = premiums_[_protocol];

    // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be)
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      premium,
      premium,
      nonStakersPercentage[_protocol],
      _nonStakers,
      allPremiumsPerSecToStakers
    );

    // Updates the stored value of percentage of premiums that go to nonstakers
    nonStakersPercentage[_protocol] = _nonStakers;

    // Updates previous coverage and current coverage amounts
    previousCoverage[_protocol] = currentCoverage[_protocol];
    currentCoverage[_protocol] = _coverageAmount;

    emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Remove a protocol from coverage
  /// @param _protocol Protocol identifier
  /// @dev Before removing a protocol the premium must be 0
  /// @dev Removing a protocol basically stops the `_protocolAgent` from being active (can still submit claims until claim deadline though)
  /// @dev Pays off debt + sends remaining balance to protocol agent
  /// @dev This call should be subject to a timelock
  /// @dev Only callable by governance
  function protocolRemove(bytes32 _protocol) external override onlyOwner {
    // checks to make sure the protocol actually has a protocol agent
    address agent = _verifyProtocolExists(_protocol);

    // Removes a protocol from Sherlock and cleans up its data
    // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made
    _forceRemoveProtocol(_protocol, agent);
  }

  /// @notice Remove a protocol with insufficient active balance
  /// @param _protocol Protocol identifier
  // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function
  function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {
    address agent = _verifyProtocolExists(_protocol);

    // Gets the latest value of the active balance at this protocol
    _settleProtocolDebt(_protocol);
    // Sets latest value of active balance to remainingBalance variable
    uint256 remainingBalance = activeBalances[_protocol];

    // This means the protocol still has adequate active balance and thus cannot be removed
    if (remainingBalance >= minActiveBalance) revert InvalidConditions();

    // Sets the protocol's active balance to 0
    delete activeBalances[_protocol];
    // Removes the protocol from coverage
    _forceRemoveProtocol(_protocol, agent);

    if (remainingBalance != 0) {
      // sends the remaining balance to msg.sender
      token.safeTransfer(msg.sender, remainingBalance);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);
  }

  /// @notice Calculate if arb is possible and what the reward would be
  /// @param _protocol Protocol identifier
  /// @return arbAmount Amount reward for arbing
  /// @return able Indicator if arb call is even possible
  /// @dev Doesn't subtract the current protocol debt from the active balance
  function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)
    internal
    view
    returns (uint256 arbAmount, bool able)
  {
    uint256 secondsLeft = _secondsOfCoverageLeft(_protocol);

    // If arb is not possible return false
    if (secondsLeft >= MIN_SECONDS_OF_COVERAGE) return (0, false);

    // This percentage scales over time
    // Reaches 100% on 0 seconds of coverage left
    uint256 percentageScaled = HUNDRED_PERCENT -
      (secondsLeft * HUNDRED_PERCENT) /
      MIN_SECONDS_OF_COVERAGE;

    able = true;
    arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;
  }

  /// @notice Removes a protocol with insufficent seconds of coverage left
  /// @param _protocol Protocol identifier
  // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second
  function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {
    // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings
    address agent = _verifyProtocolExists(_protocol);

    // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance()
    // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance()
    // But when removing based on seconds of coverage left, the remainingBalance could still be quite large
    // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance
    // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%)
    _settleProtocolDebt(_protocol);
    (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol);
    if (able == false) revert InvalidConditions();

    if (arbAmount != 0) {
      // subtracts the amount that will be paid to the arb from the active balance
      activeBalances[_protocol] -= arbAmount;
    }

    // Removes the protocol from coverage
    // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above
    _forceRemoveProtocol(_protocol, agent);

    // Done after removing protocol to mitigate reentrency pattern
    // (In case token allows callback)
    if (arbAmount != 0) {
      token.safeTransfer(msg.sender, arbAmount);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);
  }

  /// @notice Set premium of `_protocol` to `_premium`
  /// @param _protocol Protocol identifier
  /// @param _premium Amount of premium `_protocol` pays per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {
    // Checks to see if protocol has a protocol agent
    _verifyProtocolExists(_protocol);

    // Updates individual protocol's premium and allPremiumsPerSecToStakers
    _setSingleAndGlobalProtocolPremium(_protocol, _premium);
  }

  /// @notice Set premium of multiple protocols
  /// @param _protocol Array of protocol identifiers
  /// @param _premium Array of premium amounts protocols pay per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)
    external
    override
    onlyOwner
  {
    // Checks to make sure there are an equal amount of entries in each array
    if (_protocol.length != _premium.length) revert UnequalArrayLength();
    if (_protocol.length == 0) revert InvalidArgument();

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;

    // Loops through the array of protocols and checks to make sure each has a protocol agent assigned
    for (uint256 i; i < _protocol.length; i++) {
      _verifyProtocolExists(_protocol[i]);

      // Sets the protocol premium for that specific protocol
      // Function returns the old premium and nonStakerPercentage for that specific protocol
      (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
        _protocol[i],
        _premium[i]
      );

      // Calculates the new global premium which adds up all premiums paid by all protocols
      allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(
        oldPremiumPerSecond,
        _premium[i],
        nonStakerPercentage,
        nonStakerPercentage,
        allPremiumsPerSecToStakers_
      );
    }

    // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value
    allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;
  }

  // This is how protocols pay for coverage by increasing their active balance
  /// @notice Deposits `_amount` of token to the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to deposit
  /// @dev Approval should be made before calling
  function depositToActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    _verifyProtocolExists(_protocol);

    // Transfers _amount to this contract
    token.safeTransferFrom(msg.sender, address(this), _amount);
    // Increases the active balance of the protocol by _amount
    activeBalances[_protocol] += _amount;

    emit ProtocolBalanceDeposited(_protocol, _amount);
  }

  // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)
  // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)
  /// @notice Withdraws `_amount` of token from the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to withdraw
  /// @dev Only protocol agent is able to withdraw
  /// @dev Balance can be withdrawn up until 7 days worth of active balance
  function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    // Only the protocol agent can call this function
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Updates the active balance of the protocol
    _settleProtocolDebt(_protocol);

    // Sets currentBalance to the active balance of the protocol
    uint256 currentBalance = activeBalances[_protocol];
    // Reverts if trying to withdraw more than the active balance
    if (_amount > currentBalance) revert InsufficientBalance(_protocol);

    // Removes the _amount to be withdrawn from the active balance
    activeBalances[_protocol] = currentBalance - _amount;
    // Reverts if a protocol has less than 7 days worth of active balance left
    if (_secondsOfCoverageLeft(_protocol) < MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);

    // Transfers the amount to the msg.sender (protocol agent)
    token.safeTransfer(msg.sender, _amount);
    emit ProtocolBalanceWithdrawn(_protocol, _amount);
  }

  /// @notice Transfer protocol agent role
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Account able to submit a claim on behalf of the protocol
  /// @dev Only the active protocolAgent is able to transfer the role
  function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)
    external
    override
    whenNotPaused
  {
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Can't set the new protocol agent to the caller address
    if (msg.sender == _protocolAgent) revert InvalidArgument();
    // Because the caller must be the current protocol agent
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Sets the protocol agent to the new address
    _setProtocolAgent(_protocol, msg.sender, _protocolAgent);
  }

  /// @notice Function used to check if this is the current active protocol manager
  /// @return Boolean indicating it's active
  /// @dev If inactive the owner can pull all ERC20s and ETH
  /// @dev Will be checked by calling the sherlock contract
  function isActive() public view returns (bool) {
    return address(sherlockCore.sherlockProtocolManager()) == address(this);
  }

  // Only contract owner can call this
  // Sends all specified tokens in this contract to the receiver's address (as well as ETH)
  function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {
    if (_receiver == address(0)) revert ZeroArgument();
    // This contract must NOT be the current assigned protocol manager contract
    if (isActive()) revert InvalidConditions();
    // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH
    _sweep(_receiver, _extraTokens);
  }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import './Manager.sol';
import '../interfaces/managers/ISherlockProtocolManager.sol';

/// @title Sherlock core interface for protocols
/// @author Evert Kors
// This is the contract that manages covered protocols

contract SherlockProtocolManager is ISherlockProtocolManager, Manager {
  using SafeERC20 for IERC20;

  // Represents the token that protocols pay with (currently USDC)
  IERC20 public immutable token;

  // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed
  uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc

  // A removed protocol is still able to make a claim for this amount of time after its removal
  uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days;

  // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance
  uint256 public constant MIN_SECONDS_LEFT = 7 days;

  // Convenient for percentage calculations
  uint256 internal constant HUNDRED_PERCENT = 10**18;

  // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage
  // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying
  uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours;

  // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)
  mapping(bytes32 => address) internal protocolAgent_;

  // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)
  mapping(bytes32 => uint256) internal nonStakersPercentage;

  // The premium per second paid by each protocol is stored in this mapping
  mapping(bytes32 => uint256) internal premiums_;

  // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.
  // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not
  mapping(bytes32 => uint256) internal activeBalances;

  // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol
  mapping(bytes32 => uint256) internal lastAccountedEachProtocol;

  // The amount that can be claimed by nonstakers for each protocol
  // We need this value so we can track how much payment is coming from each protocol
  mapping(bytes32 => uint256) internal nonStakersClaimableByProtocol;

  // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)
  uint256 internal lastAccountedGlobal;

  // This is the total amount of premiums paid (per second) by all the covered protocols (added up)
  uint256 internal allPremiumsPerSecToStakers;

  // This is the amount that was claimable by stakers the last time the accounting was run
  // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date
  uint256 internal lastClaimablePremiumsForStakers;

  // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage
  // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)
  uint256 public override minActiveBalance;

  // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)
  mapping(bytes32 => uint256) internal removedProtocolClaimDeadline;

  // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)
  mapping(bytes32 => address) internal removedProtocolAgent;

  // Current amount of coverage (i.e. 20M USDC) for a protocol
  mapping(bytes32 => uint256) internal currentCoverage;

  // Previous amount of coverage for a protocol
  // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount
  mapping(bytes32 => uint256) internal previousCoverage;

  // Setting the token to USDC
  constructor(IERC20 _token) {
    if (address(_token) == address(0)) revert ZeroArgument();
    token = _token;
  }

  // Modifier used to ensure a protocol exists (has been instantiated and not removed)
  modifier protocolExists(bytes32 _protocol) {
    _verifyProtocolExists(_protocol);
    _;
  }

  /// @notice View current protocolAgent of `_protocol`
  /// @param _protocol Protocol identifier
  /// @return Address able to submit claims
  function protocolAgent(bytes32 _protocol) external view override returns (address) {
    address agent = protocolAgent_[_protocol];
    if (agent != address(0)) return agent;

    // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned
    // Note: Old protocol agent will never be address(0)
    if (block.timestamp <= removedProtocolClaimDeadline[_protocol]) {
      return removedProtocolAgent[_protocol];
    }

    // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned
    revert ProtocolNotExists(_protocol);
  }

  // Checks if the protocol exists, then returns the current premium per second being charged
  /// @notice View current premium of protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of premium `_protocol` pays per second
  function premium(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return premiums_[_protocol];
  }

  // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)
  // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)
  function _verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {
    _protocolAgent = protocolAgent_[_protocol];
    if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);
  }

  //
  // View methods
  //

  // Calcs the debt accrued by the protocol since it last had an accounting update
  // This is the amount that needs to be removed from a protocol's active balance
  function _calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {
    return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums_[_protocol];
  }

  /// @notice View the amount nonstakers can claim from this protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of tokens claimable by nonstakers
  /// @dev this reads from a storage variable + (now-lastsettled) * premiums
  // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]
  // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed
  function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {
    // Calcs the debt of a protocol since the last accounting update
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // Gets the active balance of the protocol
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) debt = balance;

    // Adds the incremental claimable amount owed to nonstakers to the total claimable amount
    return
      nonStakersClaimableByProtocol[_protocol] +
      (nonStakersPercentage[_protocol] * debt) /
      HUNDRED_PERCENT;
  }

  /// @notice View current amount of all premiums that are owed to stakers
  /// @return Premiums claimable
  /// @dev Will increase every block
  /// @dev base + (now - last_settled) * ps
  function claimablePremiums() public view override returns (uint256) {
    // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)
    return
      lastClaimablePremiumsForStakers +
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
  }

  /// @notice View seconds of coverage left for `_protocol` before it runs out of active balance
  /// @param _protocol Protocol identifier
  /// @return Seconds of coverage left
  function secondsOfCoverageLeft(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _secondsOfCoverageLeft(_protocol);
  }

  // Helper function to return seconds of coverage left for a protocol
  // Gets the current active balance of the protocol and divides by the premium per second for the protocol
  function _secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {
    uint256 premium = premiums_[_protocol];
    if (premium == 0) return 0;
    return _activeBalance(_protocol) / premium;
  }

  /// @notice View current active balance of covered protocol
  /// @param _protocol Protocol identifier
  /// @return Active balance
  /// @dev Accrued debt is subtracted from the stored active balance
  function activeBalance(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _activeBalance(_protocol);
  }

  // Helper function to calc the active balance of a protocol at current time
  function _activeBalance(bytes32 _protocol) internal view returns (uint256) {
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) return 0;
    return balance - debt;
  }

  //
  // State methods
  //

  /// @notice Helps set the premium per second for an individual protocol
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function
  function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)
    internal
    returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)
  {
    // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers
    // Also updates the last accounted timestamp for this protocol
    // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings
    // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol
    nonStakerPercentage = _settleProtocolDebt(_protocol);
    // Stores the old premium before it gets updated
    oldPremiumPerSecond = premiums_[_protocol];

    if (oldPremiumPerSecond != _premium) {
      // Sets the protocol's premium per second to the new value
      premiums_[_protocol] = _premium;
      emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium);
    }
    // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing
    // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes
    // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point
    // Where arbs would no longer be incentivized to remove the protocol
    // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems
    if (_premium != 0 && _secondsOfCoverageLeft(_protocol) < MIN_SECONDS_OF_COVERAGE) {
      revert InsufficientBalance(_protocol);
    }
  }

  /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {
    // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings
    (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
      _protocol,
      _premium
    );
    // Settling the total amount of premiums owed to stakers before a new premium per second gets set
    _settleTotalDebt();
    // This calculates the new global premium per second that gets paid to stakers
    // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      oldPremiumPerSecond,
      _premium,
      nonStakerPercentage,
      nonStakerPercentage,
      allPremiumsPerSecToStakers
    );
  }

  // Internal function to set a new protocolAgent for a specific protocol
  // _oldAgent is only included as part of emitting an event
  function _setProtocolAgent(
    bytes32 _protocol,
    address _oldAgent,
    address _protocolAgent
  ) internal {
    protocolAgent_[_protocol] = _protocolAgent;
    emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);
  }

  // Subtracts the accrued debt from a protocol's active balance
  // Credits the amount that can be claimed by nonstakers for this protocol
  // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings
  // Most of this function is dealing with an edge case related to a protocol not being removed by arbs
  function _settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {
    // This calcs the accrued debt of the protocol since it was last updated
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // This pulls the percentage that is sent to nonstakers
    _nonStakerPercentage = nonStakersPercentage[_protocol];
    // In case the protocol has accrued debt, this code block will ensure the debt is settled properly
    if (debt != 0) {
      // Pulls the stored active balance of the protocol
      uint256 balance = activeBalances[_protocol];
      // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance
      // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point
      // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage
      // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up
      if (debt > balance) {
        // This error amount represents the magnitude of the mistake
        uint256 error = debt - balance;
        // Gets the latest value of claimable premiums for stakers
        _settleTotalDebt();
        // @note to production, set premium first to zero before solving accounting issue.
        // otherwise the accounting error keeps increasing
        uint256 lastClaimablePremiumsForStakers_ = lastClaimablePremiumsForStakers;

        // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%
        uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /
          HUNDRED_PERCENT;

        // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short
        uint256 insufficientTokens;

        // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally
        // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error
        // This first line can be true if claimPremiumsForStakers() has been called and
        // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be >0 still
        if (claimablePremiumError > lastClaimablePremiumsForStakers_) {
          insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;
          lastClaimablePremiumsForStakers = 0;
        } else {
          // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums
          // By the amount that was added in error (error) and insufficientTokens = 0
          lastClaimablePremiumsForStakers =
            lastClaimablePremiumsForStakers_ -
            claimablePremiumError;
        }

        // If two events are thrown, the values need to be summed up for the actual state.
        // This means an error of this type will continue until it is handled
        emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);
        // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case
        debt = balance;
      }
      // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance
      activeBalances[_protocol] = balance - debt;
      // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol
      nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT;
    }
    // Updates the last accounted timestamp for this protocol
    lastAccountedEachProtocol[_protocol] = block.timestamp;
  }

  // Multiplies the total premium per second * number of seconds since the last global accounting update
  // And adds it to the total claimable amount for stakers
  function _settleTotalDebt() internal {
    lastClaimablePremiumsForStakers +=
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
    lastAccountedGlobal = block.timestamp;
  }

  // Calculates the global premium per second for stakers
  // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers
  // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones
  function _calcGlobalPremiumPerSecForStakers(
    uint256 _premiumOld,
    uint256 _premiumNew,
    uint256 _nonStakerPercentageOld,
    uint256 _nonStakerPercentageNew,
    uint256 _inMemAllPremiumsPerSecToStakers
  ) internal pure returns (uint256) {
    return
      _inMemAllPremiumsPerSecToStakers +
      ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /
      HUNDRED_PERCENT -
      ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /
      HUNDRED_PERCENT;
  }

  // Helper function to remove and clean up a protocol from Sherlock
  // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made
  function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {
    // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol
    _setSingleAndGlobalProtocolPremium(_protocol, 0);

    // Grabs the protocol's active balance
    uint256 balance = activeBalances[_protocol];

    // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent
    if (balance != 0) {
      delete activeBalances[_protocol];
      token.safeTransfer(_agent, balance);

      emit ProtocolBalanceWithdrawn(_protocol, balance);
    }

    // Sets the protocol agent to zero address (as part of clean up)
    _setProtocolAgent(_protocol, _agent, address(0));

    // Cleans up other mappings for this protocol
    delete nonStakersPercentage[_protocol];
    delete lastAccountedEachProtocol[_protocol];
    // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above

    // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol
    removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;

    // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed
    // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked
    removedProtocolAgent[_protocol] = _agent;

    emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0));
    emit ProtocolRemoved(_protocol);
  }

  /// @notice Sets the minimum active balance before an arb can remove a protocol
  /// @param _minActiveBalance Minimum balance needed (in USDC)
  /// @dev Only gov
  function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {
    // New value cannot be the same as current value
    if (minActiveBalance == _minActiveBalance) revert InvalidArgument();
    // Can't set a value that is too high to be reasonable
    if (_minActiveBalance >= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions();

    emit MinBalance(minActiveBalance, _minActiveBalance);
    minActiveBalance = _minActiveBalance;
  }

  // This function allows the nonstakers role to claim tokens owed to them by a specific protocol
  /// @notice Choose an `_amount` of tokens that nonstakers (`_receiver` address) will receive from `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens
  /// @param _receiver Address to receive tokens
  /// @dev Only callable by nonstakers role
  function nonStakersClaim(
    bytes32 _protocol,
    uint256 _amount,
    address _receiver
  ) external override whenNotPaused {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_amount == uint256(0)) revert ZeroArgument();
    if (_receiver == address(0)) revert ZeroArgument();
    // Only the nonstakers role (multisig or contract) can pull the funds
    if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized();

    // Call can't be executed on protocol that is removed
    if (protocolAgent_[_protocol] != address(0)) {
      // Updates the amount that nonstakers can claim from this protocol
      _settleProtocolDebt(_protocol);
    }

    // Sets balance to the amount that is claimable by nonstakers for this specific protocol
    uint256 balance = nonStakersClaimableByProtocol[_protocol];
    // If the amount requested is more than what's owed to nonstakers, revert
    if (_amount > balance) revert InsufficientBalance(_protocol);

    // Sets the claimable amount to whatever is left over after this amount is pulled
    nonStakersClaimableByProtocol[_protocol] = balance - _amount;
    // Transfers the amount requested to the `_receiver` address
    token.safeTransfer(_receiver, _amount);
  }

  // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)
  /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address
  /// @dev Callable by everyone
  /// @dev Funds will be transferred to Sherlock core contract
  function claimPremiumsForStakers() external override whenNotPaused {
    // Gets address of core Sherlock contract
    address sherlock = address(sherlockCore);
    // Revert if core Sherlock contract not initialized yet
    if (sherlock == address(0)) revert InvalidConditions();

    // claimablePremiums is different from _settleTotalDebt() because it does not change state
    // Retrieves current amount of all premiums that are owed to stakers
    uint256 amount = claimablePremiums();

    // Transfers all the premiums owed to stakers to the Sherlock core contract
    if (amount != 0) {
      // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out
      lastClaimablePremiumsForStakers = 0;
      lastAccountedGlobal = block.timestamp;
      token.safeTransfer(sherlock, amount);
    }
  }

  // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts
  /// @param _protocol Protocol identifier
  /// @return current and previous are the current and previous coverage amounts for this protocol
  // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)
  function coverageAmounts(bytes32 _protocol)
    external
    view
    override
    returns (uint256 current, uint256 previous)
  {
    // Checks to see if the protocol has an active protocolAgent (protocol not removed)
    // OR checks to see if the removed protocol is still within the claim window
    // If so, gives the current and previous coverage, otherwise throws an error
    if (
      protocolAgent_[_protocol] != address(0) ||
      block.timestamp <= removedProtocolClaimDeadline[_protocol]
    ) {
      return (currentCoverage[_protocol], previousCoverage[_protocol]);
    }

    revert ProtocolNotExists(_protocol);
  }

  /// @notice Add a new protocol to Sherlock
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Address able to submit a claim on behalf of the protocol
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Adding a protocol allows the `_protocolAgent` to submit a claim
  /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point
  /// @dev `_nonStakers` is scaled by 10**18
  /// @dev Only callable by governance
  function protocolAdd(
    bytes32 _protocol,
    address _protocolAgent,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) external override onlyOwner {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Checks to make sure the protocol doesn't exist already
    if (protocolAgent_[_protocol] != address(0)) revert InvalidConditions();

    // Updates the protocol agent and passes in the old agent which is 0 address in this case
    _setProtocolAgent(_protocol, address(0), _protocolAgent);

    // Delete mappings that are potentially non default values
    // From previous time protocol was added/removed
    delete removedProtocolClaimDeadline[_protocol];
    delete removedProtocolAgent[_protocol];
    delete currentCoverage[_protocol];
    delete previousCoverage[_protocol];

    emit ProtocolAdded(_protocol);

    // Most of the logic for actually adding a protocol in this function
    protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Update info regarding a protocol
  /// @param _protocol Protocol identifier
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Only callable by governance
  /// @dev `_nonStakers` can be 0
  function protocolUpdate(
    bytes32 _protocol,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) public override onlyOwner {
    if (_coverage == bytes32(0)) revert ZeroArgument();
    if (_nonStakers > HUNDRED_PERCENT) revert InvalidArgument();
    if (_coverageAmount == uint256(0)) revert ZeroArgument();

    // Checks to make sure the protocol has been assigned a protocol agent
    _verifyProtocolExists(_protocol);

    // Subtracts the accrued debt from a protocol's active balance (if any)
    // Updates the amount that can be claimed by nonstakers
    _settleProtocolDebt(_protocol);

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    // Gets the premium per second for this protocol
    uint256 premium = premiums_[_protocol];

    // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be)
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      premium,
      premium,
      nonStakersPercentage[_protocol],
      _nonStakers,
      allPremiumsPerSecToStakers
    );

    // Updates the stored value of percentage of premiums that go to nonstakers
    nonStakersPercentage[_protocol] = _nonStakers;

    // Updates previous coverage and current coverage amounts
    previousCoverage[_protocol] = currentCoverage[_protocol];
    currentCoverage[_protocol] = _coverageAmount;

    emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Remove a protocol from coverage
  /// @param _protocol Protocol identifier
  /// @dev Before removing a protocol the premium must be 0
  /// @dev Removing a protocol basically stops the `_protocolAgent` from being active (can still submit claims until claim deadline though)
  /// @dev Pays off debt + sends remaining balance to protocol agent
  /// @dev This call should be subject to a timelock
  /// @dev Only callable by governance
  function protocolRemove(bytes32 _protocol) external override onlyOwner {
    // checks to make sure the protocol actually has a protocol agent
    address agent = _verifyProtocolExists(_protocol);

    // Removes a protocol from Sherlock and cleans up its data
    // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made
    _forceRemoveProtocol(_protocol, agent);
  }

  /// @notice Remove a protocol with insufficient active balance
  /// @param _protocol Protocol identifier
  // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function
  function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {
    address agent = _verifyProtocolExists(_protocol);

    // Gets the latest value of the active balance at this protocol
    _settleProtocolDebt(_protocol);
    // Sets latest value of active balance to remainingBalance variable
    uint256 remainingBalance = activeBalances[_protocol];

    // This means the protocol still has adequate active balance and thus cannot be removed
    if (remainingBalance >= minActiveBalance) revert InvalidConditions();

    // Sets the protocol's active balance to 0
    delete activeBalances[_protocol];
    // Removes the protocol from coverage
    _forceRemoveProtocol(_protocol, agent);

    if (remainingBalance != 0) {
      // sends the remaining balance to msg.sender
      token.safeTransfer(msg.sender, remainingBalance);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);
  }

  /// @notice Calculate if arb is possible and what the reward would be
  /// @param _protocol Protocol identifier
  /// @return arbAmount Amount reward for arbing
  /// @return able Indicator if arb call is even possible
  /// @dev Doesn't subtract the current protocol debt from the active balance
  function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)
    internal
    view
    returns (uint256 arbAmount, bool able)
  {
    uint256 secondsLeft = _secondsOfCoverageLeft(_protocol);

    // If arb is not possible return false
    if (secondsLeft >= MIN_SECONDS_OF_COVERAGE) return (0, false);

    // This percentage scales over time
    // Reaches 100% on 0 seconds of coverage left
    uint256 percentageScaled = HUNDRED_PERCENT -
      (secondsLeft * HUNDRED_PERCENT) /
      MIN_SECONDS_OF_COVERAGE;

    able = true;
    arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;
  }

  /// @notice Removes a protocol with insufficent seconds of coverage left
  /// @param _protocol Protocol identifier
  // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second
  function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {
    // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings
    address agent = _verifyProtocolExists(_protocol);

    // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance()
    // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance()
    // But when removing based on seconds of coverage left, the remainingBalance could still be quite large
    // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance
    // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%)
    _settleProtocolDebt(_protocol);
    (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol);
    if (able == false) revert InvalidConditions();

    if (arbAmount != 0) {
      // subtracts the amount that will be paid to the arb from the active balance
      activeBalances[_protocol] -= arbAmount;
    }

    // Removes the protocol from coverage
    // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above
    _forceRemoveProtocol(_protocol, agent);

    // Done after removing protocol to mitigate reentrency pattern
    // (In case token allows callback)
    if (arbAmount != 0) {
      token.safeTransfer(msg.sender, arbAmount);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);
  }

  /// @notice Set premium of `_protocol` to `_premium`
  /// @param _protocol Protocol identifier
  /// @param _premium Amount of premium `_protocol` pays per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {
    // Checks to see if protocol has a protocol agent
    _verifyProtocolExists(_protocol);

    // Updates individual protocol's premium and allPremiumsPerSecToStakers
    _setSingleAndGlobalProtocolPremium(_protocol, _premium);
  }

  /// @notice Set premium of multiple protocols
  /// @param _protocol Array of protocol identifiers
  /// @param _premium Array of premium amounts protocols pay per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)
    external
    override
    onlyOwner
  {
    // Checks to make sure there are an equal amount of entries in each array
    if (_protocol.length != _premium.length) revert UnequalArrayLength();
    if (_protocol.length == 0) revert InvalidArgument();

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;

    // Loops through the array of protocols and checks to make sure each has a protocol agent assigned
    for (uint256 i; i < _protocol.length; i++) {
      _verifyProtocolExists(_protocol[i]);

      // Sets the protocol premium for that specific protocol
      // Function returns the old premium and nonStakerPercentage for that specific protocol
      (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
        _protocol[i],
        _premium[i]
      );

      // Calculates the new global premium which adds up all premiums paid by all protocols
      allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(
        oldPremiumPerSecond,
        _premium[i],
        nonStakerPercentage,
        nonStakerPercentage,
        allPremiumsPerSecToStakers_
      );
    }

    // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value
    allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;
  }

  // This is how protocols pay for coverage by increasing their active balance
  /// @notice Deposits `_amount` of token to the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to deposit
  /// @dev Approval should be made before calling
  function depositToActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    _verifyProtocolExists(_protocol);

    // Transfers _amount to this contract
    token.safeTransferFrom(msg.sender, address(this), _amount);
    // Increases the active balance of the protocol by _amount
    activeBalances[_protocol] += _amount;

    emit ProtocolBalanceDeposited(_protocol, _amount);
  }

  // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)
  // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)
  /// @notice Withdraws `_amount` of token from the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to withdraw
  /// @dev Only protocol agent is able to withdraw
  /// @dev Balance can be withdrawn up until 7 days worth of active balance
  function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    // Only the protocol agent can call this function
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Updates the active balance of the protocol
    _settleProtocolDebt(_protocol);

    // Sets currentBalance to the active balance of the protocol
    uint256 currentBalance = activeBalances[_protocol];
    // Reverts if trying to withdraw more than the active balance
    if (_amount > currentBalance) revert InsufficientBalance(_protocol);

    // Removes the _amount to be withdrawn from the active balance
    activeBalances[_protocol] = currentBalance - _amount;
    // Reverts if a protocol has less than 7 days worth of active balance left
    if (_secondsOfCoverageLeft(_protocol) < MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);

    // Transfers the amount to the msg.sender (protocol agent)
    token.safeTransfer(msg.sender, _amount);
    emit ProtocolBalanceWithdrawn(_protocol, _amount);
  }

  /// @notice Transfer protocol agent role
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Account able to submit a claim on behalf of the protocol
  /// @dev Only the active protocolAgent is able to transfer the role
  function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)
    external
    override
    whenNotPaused
  {
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Can't set the new protocol agent to the caller address
    if (msg.sender == _protocolAgent) revert InvalidArgument();
    // Because the caller must be the current protocol agent
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Sets the protocol agent to the new address
    _setProtocolAgent(_protocol, msg.sender, _protocolAgent);
  }

  /// @notice Function used to check if this is the current active protocol manager
  /// @return Boolean indicating it's active
  /// @dev If inactive the owner can pull all ERC20s and ETH
  /// @dev Will be checked by calling the sherlock contract
  function isActive() public view returns (bool) {
    return address(sherlockCore.sherlockProtocolManager()) == address(this);
  }

  // Only contract owner can call this
  // Sends all specified tokens in this contract to the receiver's address (as well as ETH)
  function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {
    if (_receiver == address(0)) revert ZeroArgument();
    // This contract must NOT be the current assigned protocol manager contract
    if (isActive()) revert InvalidConditions();
    // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH
    _sweep(_receiver, _extraTokens);
  }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-25-08 10:59:11 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-25-08 10:59:11 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 18293
completion_tokens: 1
total_tokens: 18294
cost: $-1.000000


[2024-25-08 10:59:11 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import './Manager.sol';
import '../interfaces/managers/ISherlockProtocolManager.sol';

/// @title Sherlock core interface for protocols
/// @author Evert Kors
// This is the contract that manages covered protocols

contract SherlockProtocolManager is ISherlockProtocolManager, Manager {
  using SafeERC20 for IERC20;

  // Represents the token that protocols pay with (currently USDC)
  IERC20 public immutable token;

  // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed
  uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc

  // A removed protocol is still able to make a claim for this amount of time after its removal
  uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days;

  // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance
  uint256 public constant MIN_SECONDS_LEFT = 7 days;

  // Convenient for percentage calculations
  uint256 internal constant HUNDRED_PERCENT = 10**18;

  // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage
  // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying
  uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours;

  // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)
  mapping(bytes32 => address) internal protocolAgent_;

  // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)
  mapping(bytes32 => uint256) internal nonStakersPercentage;

  // The premium per second paid by each protocol is stored in this mapping
  mapping(bytes32 => uint256) internal premiums_;

  // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.
  // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not
  mapping(bytes32 => uint256) internal activeBalances;

  // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol
  mapping(bytes32 => uint256) internal lastAccountedEachProtocol;

  // The amount that can be claimed by nonstakers for each protocol
  // We need this value so we can track how much payment is coming from each protocol
  mapping(bytes32 => uint256) internal nonStakersClaimableByProtocol;

  // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)
  uint256 internal lastAccountedGlobal;

  // This is the total amount of premiums paid (per second) by all the covered protocols (added up)
  uint256 internal allPremiumsPerSecToStakers;

  // This is the amount that was claimable by stakers the last time the accounting was run
  // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date
  uint256 internal lastClaimablePremiumsForStakers;

  // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage
  // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)
  uint256 public override minActiveBalance;

  // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)
  mapping(bytes32 => uint256) internal removedProtocolClaimDeadline;

  // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)
  mapping(bytes32 => address) internal removedProtocolAgent;

  // Current amount of coverage (i.e. 20M USDC) for a protocol
  mapping(bytes32 => uint256) internal currentCoverage;

  // Previous amount of coverage for a protocol
  // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount
  mapping(bytes32 => uint256) internal previousCoverage;

  // Setting the token to USDC
  constructor(IERC20 _token) {
    if (address(_token) == address(0)) revert ZeroArgument();
    token = _token;
  }

  // Modifier used to ensure a protocol exists (has been instantiated and not removed)
  modifier protocolExists(bytes32 _protocol) {
    _verifyProtocolExists(_protocol);
    _;
  }

  /// @notice View current protocolAgent of `_protocol`
  /// @param _protocol Protocol identifier
  /// @return Address able to submit claims
  function protocolAgent(bytes32 _protocol) external view override returns (address) {
    address agent = protocolAgent_[_protocol];
    if (agent != address(0)) return agent;

    // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned
    // Note: Old protocol agent will never be address(0)
    if (block.timestamp <= removedProtocolClaimDeadline[_protocol]) {
      return removedProtocolAgent[_protocol];
    }

    // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned
    revert ProtocolNotExists(_protocol);
  }

  // Checks if the protocol exists, then returns the current premium per second being charged
  /// @notice View current premium of protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of premium `_protocol` pays per second
  function premium(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return premiums_[_protocol];
  }

  // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)
  // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)
  function _verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {
    _protocolAgent = protocolAgent_[_protocol];
    if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);
  }

  //
  // View methods
  //

  // Calcs the debt accrued by the protocol since it last had an accounting update
  // This is the amount that needs to be removed from a protocol's active balance
  function _calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {
    return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums_[_protocol];
  }

  /// @notice View the amount nonstakers can claim from this protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of tokens claimable by nonstakers
  /// @dev this reads from a storage variable + (now-lastsettled) * premiums
  // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]
  // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed
  function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {
    // Calcs the debt of a protocol since the last accounting update
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // Gets the active balance of the protocol
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) debt = balance;

    // Adds the incremental claimable amount owed to nonstakers to the total claimable amount
    return
      nonStakersClaimableByProtocol[_protocol] +
      (nonStakersPercentage[_protocol] * debt) /
      HUNDRED_PERCENT;
  }

  /// @notice View current amount of all premiums that are owed to stakers
  /// @return Premiums claimable
  /// @dev Will increase every block
  /// @dev base + (now - last_settled) * ps
  function claimablePremiums() public view override returns (uint256) {
    // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)
    return
      lastClaimablePremiumsForStakers +
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
  }

  /// @notice View seconds of coverage left for `_protocol` before it runs out of active balance
  /// @param _protocol Protocol identifier
  /// @return Seconds of coverage left
  function secondsOfCoverageLeft(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _secondsOfCoverageLeft(_protocol);
  }

  // Helper function to return seconds of coverage left for a protocol
  // Gets the current active balance of the protocol and divides by the premium per second for the protocol
  function _secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {
    uint256 premium = premiums_[_protocol];
    if (premium == 0) return 0;
    return _activeBalance(_protocol) / premium;
  }

  /// @notice View current active balance of covered protocol
  /// @param _protocol Protocol identifier
  /// @return Active balance
  /// @dev Accrued debt is subtracted from the stored active balance
  function activeBalance(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _activeBalance(_protocol);
  }

  // Helper function to calc the active balance of a protocol at current time
  function _activeBalance(bytes32 _protocol) internal view returns (uint256) {
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) return 0;
    return balance - debt;
  }

  //
  // State methods
  //

  /// @notice Helps set the premium per second for an individual protocol
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function
  function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)
    internal
    returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)
  {
    // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers
    // Also updates the last accounted timestamp for this protocol
    // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings
    // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol
    nonStakerPercentage = _settleProtocolDebt(_protocol);
    // Stores the old premium before it gets updated
    oldPremiumPerSecond = premiums_[_protocol];

    if (oldPremiumPerSecond != _premium) {
      // Sets the protocol's premium per second to the new value
      premiums_[_protocol] = _premium;
      emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium);
    }
    // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing
    // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes
    // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point
    // Where arbs would no longer be incentivized to remove the protocol
    // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems
    if (_premium != 0 && _secondsOfCoverageLeft(_protocol) < MIN_SECONDS_OF_COVERAGE) {
      revert InsufficientBalance(_protocol);
    }
  }

  /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {
    // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings
    (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
      _protocol,
      _premium
    );
    // Settling the total amount of premiums owed to stakers before a new premium per second gets set
    _settleTotalDebt();
    // This calculates the new global premium per second that gets paid to stakers
    // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      oldPremiumPerSecond,
      _premium,
      nonStakerPercentage,
      nonStakerPercentage,
      allPremiumsPerSecToStakers
    );
  }

  // Internal function to set a new protocolAgent for a specific protocol
  // _oldAgent is only included as part of emitting an event
  function _setProtocolAgent(
    bytes32 _protocol,
    address _oldAgent,
    address _protocolAgent
  ) internal {
    protocolAgent_[_protocol] = _protocolAgent;
    emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);
  }

  // Subtracts the accrued debt from a protocol's active balance
  // Credits the amount that can be claimed by nonstakers for this protocol
  // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings
  // Most of this function is dealing with an edge case related to a protocol not being removed by arbs
  function _settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {
    // This calcs the accrued debt of the protocol since it was last updated
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // This pulls the percentage that is sent to nonstakers
    _nonStakerPercentage = nonStakersPercentage[_protocol];
    // In case the protocol has accrued debt, this code block will ensure the debt is settled properly
    if (debt != 0) {
      // Pulls the stored active balance of the protocol
      uint256 balance = activeBalances[_protocol];
      // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance
      // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point
      // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage
      // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up
      if (debt > balance) {
        // This error amount represents the magnitude of the mistake
        uint256 error = debt - balance;
        // Gets the latest value of claimable premiums for stakers
        _settleTotalDebt();
        // @note to production, set premium first to zero before solving accounting issue.
        // otherwise the accounting error keeps increasing
        uint256 lastClaimablePremiumsForStakers_ = lastClaimablePremiumsForStakers;

        // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%
        uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /
          HUNDRED_PERCENT;

        // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short
        uint256 insufficientTokens;

        // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally
        // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error
        // This first line can be true if claimPremiumsForStakers() has been called and
        // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be >0 still
        if (claimablePremiumError > lastClaimablePremiumsForStakers_) {
          insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;
          lastClaimablePremiumsForStakers = 0;
        } else {
          // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums
          // By the amount that was added in error (error) and insufficientTokens = 0
          lastClaimablePremiumsForStakers =
            lastClaimablePremiumsForStakers_ -
            claimablePremiumError;
        }

        // If two events are thrown, the values need to be summed up for the actual state.
        // This means an error of this type will continue until it is handled
        emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);
        // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case
        debt = balance;
      }
      // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance
      activeBalances[_protocol] = balance - debt;
      // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol
      nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT;
    }
    // Updates the last accounted timestamp for this protocol
    lastAccountedEachProtocol[_protocol] = block.timestamp;
  }

  // Multiplies the total premium per second * number of seconds since the last global accounting update
  // And adds it to the total claimable amount for stakers
  function _settleTotalDebt() internal {
    lastClaimablePremiumsForStakers +=
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
    lastAccountedGlobal = block.timestamp;
  }

  // Calculates the global premium per second for stakers
  // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers
  // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones
  function _calcGlobalPremiumPerSecForStakers(
    uint256 _premiumOld,
    uint256 _premiumNew,
    uint256 _nonStakerPercentageOld,
    uint256 _nonStakerPercentageNew,
    uint256 _inMemAllPremiumsPerSecToStakers
  ) internal pure returns (uint256) {
    return
      _inMemAllPremiumsPerSecToStakers +
      ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /
      HUNDRED_PERCENT -
      ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /
      HUNDRED_PERCENT;
  }

  // Helper function to remove and clean up a protocol from Sherlock
  // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made
  function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {
    // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol
    _setSingleAndGlobalProtocolPremium(_protocol, 0);

    // Grabs the protocol's active balance
    uint256 balance = activeBalances[_protocol];

    // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent
    if (balance != 0) {
      delete activeBalances[_protocol];
      token.safeTransfer(_agent, balance);

      emit ProtocolBalanceWithdrawn(_protocol, balance);
    }

    // Sets the protocol agent to zero address (as part of clean up)
    _setProtocolAgent(_protocol, _agent, address(0));

    // Cleans up other mappings for this protocol
    delete nonStakersPercentage[_protocol];
    delete lastAccountedEachProtocol[_protocol];
    // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above

    // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol
    removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;

    // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed
    // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked
    removedProtocolAgent[_protocol] = _agent;

    emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0));
    emit ProtocolRemoved(_protocol);
  }

  /// @notice Sets the minimum active balance before an arb can remove a protocol
  /// @param _minActiveBalance Minimum balance needed (in USDC)
  /// @dev Only gov
  function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {
    // New value cannot be the same as current value
    if (minActiveBalance == _minActiveBalance) revert InvalidArgument();
    // Can't set a value that is too high to be reasonable
    if (_minActiveBalance >= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions();

    emit MinBalance(minActiveBalance, _minActiveBalance);
    minActiveBalance = _minActiveBalance;
  }

  // This function allows the nonstakers role to claim tokens owed to them by a specific protocol
  /// @notice Choose an `_amount` of tokens that nonstakers (`_receiver` address) will receive from `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens
  /// @param _receiver Address to receive tokens
  /// @dev Only callable by nonstakers role
  function nonStakersClaim(
    bytes32 _protocol,
    uint256 _amount,
    address _receiver
  ) external override whenNotPaused {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_amount == uint256(0)) revert ZeroArgument();
    if (_receiver == address(0)) revert ZeroArgument();
    // Only the nonstakers role (multisig or contract) can pull the funds
    if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized();

    // Call can't be executed on protocol that is removed
    if (protocolAgent_[_protocol] != address(0)) {
      // Updates the amount that nonstakers can claim from this protocol
      _settleProtocolDebt(_protocol);
    }

    // Sets balance to the amount that is claimable by nonstakers for this specific protocol
    uint256 balance = nonStakersClaimableByProtocol[_protocol];
    // If the amount requested is more than what's owed to nonstakers, revert
    if (_amount > balance) revert InsufficientBalance(_protocol);

    // Sets the claimable amount to whatever is left over after this amount is pulled
    nonStakersClaimableByProtocol[_protocol] = balance - _amount;
    // Transfers the amount requested to the `_receiver` address
    token.safeTransfer(_receiver, _amount);
  }

  // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)
  /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address
  /// @dev Callable by everyone
  /// @dev Funds will be transferred to Sherlock core contract
  function claimPremiumsForStakers() external override whenNotPaused {
    // Gets address of core Sherlock contract
    address sherlock = address(sherlockCore);
    // Revert if core Sherlock contract not initialized yet
    if (sherlock == address(0)) revert InvalidConditions();

    // claimablePremiums is different from _settleTotalDebt() because it does not change state
    // Retrieves current amount of all premiums that are owed to stakers
    uint256 amount = claimablePremiums();

    // Transfers all the premiums owed to stakers to the Sherlock core contract
    if (amount != 0) {
      // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out
      lastClaimablePremiumsForStakers = 0;
      lastAccountedGlobal = block.timestamp;
      token.safeTransfer(sherlock, amount);
    }
  }

  // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts
  /// @param _protocol Protocol identifier
  /// @return current and previous are the current and previous coverage amounts for this protocol
  // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)
  function coverageAmounts(bytes32 _protocol)
    external
    view
    override
    returns (uint256 current, uint256 previous)
  {
    // Checks to see if the protocol has an active protocolAgent (protocol not removed)
    // OR checks to see if the removed protocol is still within the claim window
    // If so, gives the current and previous coverage, otherwise throws an error
    if (
      protocolAgent_[_protocol] != address(0) ||
      block.timestamp <= removedProtocolClaimDeadline[_protocol]
    ) {
      return (currentCoverage[_protocol], previousCoverage[_protocol]);
    }

    revert ProtocolNotExists(_protocol);
  }

  /// @notice Add a new protocol to Sherlock
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Address able to submit a claim on behalf of the protocol
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Adding a protocol allows the `_protocolAgent` to submit a claim
  /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point
  /// @dev `_nonStakers` is scaled by 10**18
  /// @dev Only callable by governance
  function protocolAdd(
    bytes32 _protocol,
    address _protocolAgent,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) external override onlyOwner {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Checks to make sure the protocol doesn't exist already
    if (protocolAgent_[_protocol] != address(0)) revert InvalidConditions();

    // Updates the protocol agent and passes in the old agent which is 0 address in this case
    _setProtocolAgent(_protocol, address(0), _protocolAgent);

    // Delete mappings that are potentially non default values
    // From previous time protocol was added/removed
    delete removedProtocolClaimDeadline[_protocol];
    delete removedProtocolAgent[_protocol];
    delete currentCoverage[_protocol];
    delete previousCoverage[_protocol];

    emit ProtocolAdded(_protocol);

    // Most of the logic for actually adding a protocol in this function
    protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Update info regarding a protocol
  /// @param _protocol Protocol identifier
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Only callable by governance
  /// @dev `_nonStakers` can be 0
  function protocolUpdate(
    bytes32 _protocol,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) public override onlyOwner {
    if (_coverage == bytes32(0)) revert ZeroArgument();
    if (_nonStakers > HUNDRED_PERCENT) revert InvalidArgument();
    if (_coverageAmount == uint256(0)) revert ZeroArgument();

    // Checks to make sure the protocol has been assigned a protocol agent
    _verifyProtocolExists(_protocol);

    // Subtracts the accrued debt from a protocol's active balance (if any)
    // Updates the amount that can be claimed by nonstakers
    _settleProtocolDebt(_protocol);

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    // Gets the premium per second for this protocol
    uint256 premium = premiums_[_protocol];

    // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be)
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      premium,
      premium,
      nonStakersPercentage[_protocol],
      _nonStakers,
      allPremiumsPerSecToStakers
    );

    // Updates the stored value of percentage of premiums that go to nonstakers
    nonStakersPercentage[_protocol] = _nonStakers;

    // Updates previous coverage and current coverage amounts
    previousCoverage[_protocol] = currentCoverage[_protocol];
    currentCoverage[_protocol] = _coverageAmount;

    emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Remove a protocol from coverage
  /// @param _protocol Protocol identifier
  /// @dev Before removing a protocol the premium must be 0
  /// @dev Removing a protocol basically stops the `_protocolAgent` from being active (can still submit claims until claim deadline though)
  /// @dev Pays off debt + sends remaining balance to protocol agent
  /// @dev This call should be subject to a timelock
  /// @dev Only callable by governance
  function protocolRemove(bytes32 _protocol) external override onlyOwner {
    // checks to make sure the protocol actually has a protocol agent
    address agent = _verifyProtocolExists(_protocol);

    // Removes a protocol from Sherlock and cleans up its data
    // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made
    _forceRemoveProtocol(_protocol, agent);
  }

  /// @notice Remove a protocol with insufficient active balance
  /// @param _protocol Protocol identifier
  // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function
  function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {
    address agent = _verifyProtocolExists(_protocol);

    // Gets the latest value of the active balance at this protocol
    _settleProtocolDebt(_protocol);
    // Sets latest value of active balance to remainingBalance variable
    uint256 remainingBalance = activeBalances[_protocol];

    // This means the protocol still has adequate active balance and thus cannot be removed
    if (remainingBalance >= minActiveBalance) revert InvalidConditions();

    // Sets the protocol's active balance to 0
    delete activeBalances[_protocol];
    // Removes the protocol from coverage
    _forceRemoveProtocol(_protocol, agent);

    if (remainingBalance != 0) {
      // sends the remaining balance to msg.sender
      token.safeTransfer(msg.sender, remainingBalance);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);
  }

  /// @notice Calculate if arb is possible and what the reward would be
  /// @param _protocol Protocol identifier
  /// @return arbAmount Amount reward for arbing
  /// @return able Indicator if arb call is even possible
  /// @dev Doesn't subtract the current protocol debt from the active balance
  function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)
    internal
    view
    returns (uint256 arbAmount, bool able)
  {
    uint256 secondsLeft = _secondsOfCoverageLeft(_protocol);

    // If arb is not possible return false
    if (secondsLeft >= MIN_SECONDS_OF_COVERAGE) return (0, false);

    // This percentage scales over time
    // Reaches 100% on 0 seconds of coverage left
    uint256 percentageScaled = HUNDRED_PERCENT -
      (secondsLeft * HUNDRED_PERCENT) /
      MIN_SECONDS_OF_COVERAGE;

    able = true;
    arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;
  }

  /// @notice Removes a protocol with insufficent seconds of coverage left
  /// @param _protocol Protocol identifier
  // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second
  function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {
    // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings
    address agent = _verifyProtocolExists(_protocol);

    // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance()
    // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance()
    // But when removing based on seconds of coverage left, the remainingBalance could still be quite large
    // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance
    // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%)
    _settleProtocolDebt(_protocol);
    (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol);
    if (able == false) revert InvalidConditions();

    if (arbAmount != 0) {
      // subtracts the amount that will be paid to the arb from the active balance
      activeBalances[_protocol] -= arbAmount;
    }

    // Removes the protocol from coverage
    // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above
    _forceRemoveProtocol(_protocol, agent);

    // Done after removing protocol to mitigate reentrency pattern
    // (In case token allows callback)
    if (arbAmount != 0) {
      token.safeTransfer(msg.sender, arbAmount);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);
  }

  /// @notice Set premium of `_protocol` to `_premium`
  /// @param _protocol Protocol identifier
  /// @param _premium Amount of premium `_protocol` pays per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {
    // Checks to see if protocol has a protocol agent
    _verifyProtocolExists(_protocol);

    // Updates individual protocol's premium and allPremiumsPerSecToStakers
    _setSingleAndGlobalProtocolPremium(_protocol, _premium);
  }

  /// @notice Set premium of multiple protocols
  /// @param _protocol Array of protocol identifiers
  /// @param _premium Array of premium amounts protocols pay per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)
    external
    override
    onlyOwner
  {
    // Checks to make sure there are an equal amount of entries in each array
    if (_protocol.length != _premium.length) revert UnequalArrayLength();
    if (_protocol.length == 0) revert InvalidArgument();

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;

    // Loops through the array of protocols and checks to make sure each has a protocol agent assigned
    for (uint256 i; i < _protocol.length; i++) {
      _verifyProtocolExists(_protocol[i]);

      // Sets the protocol premium for that specific protocol
      // Function returns the old premium and nonStakerPercentage for that specific protocol
      (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
        _protocol[i],
        _premium[i]
      );

      // Calculates the new global premium which adds up all premiums paid by all protocols
      allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(
        oldPremiumPerSecond,
        _premium[i],
        nonStakerPercentage,
        nonStakerPercentage,
        allPremiumsPerSecToStakers_
      );
    }

    // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value
    allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;
  }

  // This is how protocols pay for coverage by increasing their active balance
  /// @notice Deposits `_amount` of token to the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to deposit
  /// @dev Approval should be made before calling
  function depositToActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    _verifyProtocolExists(_protocol);

    // Transfers _amount to this contract
    token.safeTransferFrom(msg.sender, address(this), _amount);
    // Increases the active balance of the protocol by _amount
    activeBalances[_protocol] += _amount;

    emit ProtocolBalanceDeposited(_protocol, _amount);
  }

  // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)
  // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)
  /// @notice Withdraws `_amount` of token from the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to withdraw
  /// @dev Only protocol agent is able to withdraw
  /// @dev Balance can be withdrawn up until 7 days worth of active balance
  function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    // Only the protocol agent can call this function
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Updates the active balance of the protocol
    _settleProtocolDebt(_protocol);

    // Sets currentBalance to the active balance of the protocol
    uint256 currentBalance = activeBalances[_protocol];
    // Reverts if trying to withdraw more than the active balance
    if (_amount > currentBalance) revert InsufficientBalance(_protocol);

    // Removes the _amount to be withdrawn from the active balance
    activeBalances[_protocol] = currentBalance - _amount;
    // Reverts if a protocol has less than 7 days worth of active balance left
    if (_secondsOfCoverageLeft(_protocol) < MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);

    // Transfers the amount to the msg.sender (protocol agent)
    token.safeTransfer(msg.sender, _amount);
    emit ProtocolBalanceWithdrawn(_protocol, _amount);
  }

  /// @notice Transfer protocol agent role
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Account able to submit a claim on behalf of the protocol
  /// @dev Only the active protocolAgent is able to transfer the role
  function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)
    external
    override
    whenNotPaused
  {
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Can't set the new protocol agent to the caller address
    if (msg.sender == _protocolAgent) revert InvalidArgument();
    // Because the caller must be the current protocol agent
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Sets the protocol agent to the new address
    _setProtocolAgent(_protocol, msg.sender, _protocolAgent);
  }

  /// @notice Function used to check if this is the current active protocol manager
  /// @return Boolean indicating it's active
  /// @dev If inactive the owner can pull all ERC20s and ETH
  /// @dev Will be checked by calling the sherlock contract
  function isActive() public view returns (bool) {
    return address(sherlockCore.sherlockProtocolManager()) == address(this);
  }

  // Only contract owner can call this
  // Sends all specified tokens in this contract to the receiver's address (as well as ETH)
  function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {
    if (_receiver == address(0)) revert ZeroArgument();
    // This contract must NOT be the current assigned protocol manager contract
    if (isActive()) revert InvalidConditions();
    // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH
    _sweep(_receiver, _extraTokens);
  }
}
.]

###

[2024-25-08 10:59:11 INFO] **[Seminar Conclusion]**:

 ###

[2024-25-08 10:59:11 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-25-08 10:59:11 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import './Manager.sol'; import '../interfaces/managers/ISherlockProtocolManager.sol'; /// @title Sherlock core interface for protocols /// @author Evert Kors // This is the contract that manages covered protocols contract SherlockProtocolManager is ISherlockProtocolManager, Manager {   using SafeERC20 for IERC20; // Represents the token that protocols pay with (currently USDC)   IERC20 public immutable token; // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed   uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc // A removed protocol is still able to make a claim for this amount of time after its removal   uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days; // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance   uint256 public constant MIN_SECONDS_LEFT = 7 days; // Convenient for percentage calculations   uint256 internal constant HUNDRED_PERCENT = 10**18; // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage   // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying   uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours; // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)   mapping(bytes32 =&gt; address) internal protocolAgent_; // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)   mapping(bytes32 =&gt; uint256) internal nonStakersPercentage; // The premium per second paid by each protocol is stored in this mapping   mapping(bytes32 =&gt; uint256) internal premiums_; // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.   // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not   mapping(bytes32 =&gt; uint256) internal activeBalances; // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol   mapping(bytes32 =&gt; uint256) internal lastAccountedEachProtocol; // The amount that can be claimed by nonstakers for each protocol   // We need this value so we can track how much payment is coming from each protocol   mapping(bytes32 =&gt; uint256) internal nonStakersClaimableByProtocol; // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)   uint256 internal lastAccountedGlobal; // This is the total amount of premiums paid (per second) by all the covered protocols (added up)   uint256 internal allPremiumsPerSecToStakers; // This is the amount that was claimable by stakers the last time the accounting was run   // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date   uint256 internal lastClaimablePremiumsForStakers; // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage   // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)   uint256 public override minActiveBalance; // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)   mapping(bytes32 =&gt; uint256) internal removedProtocolClaimDeadline; // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)   mapping(bytes32 =&gt; address) internal removedProtocolAgent; // Current amount of coverage (i.e. 20M USDC) for a protocol   mapping(bytes32 =&gt; uint256) internal currentCoverage; // Previous amount of coverage for a protocol   // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount   mapping(bytes32 =&gt; uint256) internal previousCoverage; // Setting the token to USDC   constructor(IERC20 _token) {     if (address(_token) == address(0)) revert ZeroArgument();     token = _token;   } // Modifier used to ensure a protocol exists (has been instantiated and not removed)   modifier protocolExists(bytes32 protocol) {     _verifyProtocolExists(_protocol);     ;   } /// @notice View current protocolAgent of _protocol   /// @param protocol Protocol identifier   /// @return Address able to submit claims   function protocolAgent(bytes32 _protocol) external view override returns (address) {     address agent = protocolAgent[_protocol];     if (agent != address(0)) return agent; // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned // Note: Old protocol agent will never be address(0) if (block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]) {   return removedProtocolAgent[_protocol]; }  // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned revert ProtocolNotExists(_protocol);  } // Checks if the protocol exists, then returns the current premium per second being charged   /// @notice View current premium of protocol   /// @param protocol Protocol identifier   /// @return Amount of premium _protocol pays per second   function premium(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return premiums[_protocol];   } // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)   // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)   function verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {     _protocolAgent = protocolAgent[_protocol];     if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);   } //   // View methods   // // Calcs the debt accrued by the protocol since it last had an accounting update   // This is the amount that needs to be removed from a protocol's active balance   function calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {     return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums[_protocol];   } /// @notice View the amount nonstakers can claim from this protocol   /// @param _protocol Protocol identifier   /// @return Amount of tokens claimable by nonstakers   /// @dev this reads from a storage variable + (now-lastsettled) * premiums   // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]   // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed   function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {     // Calcs the debt of a protocol since the last accounting update     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     // Gets the active balance of the protocol     uint256 balance = activeBalances[_protocol];     // The debt should never be higher than the balance (only happens if the arbitrages fail)     if (debt &gt; balance) debt = balance; // Adds the incremental claimable amount owed to nonstakers to the total claimable amount return   nonStakersClaimableByProtocol[_protocol] +   (nonStakersPercentage[_protocol] * debt) /   HUNDRED_PERCENT;  } /// @notice View current amount of all premiums that are owed to stakers   /// @return Premiums claimable   /// @dev Will increase every block   /// @dev base + (now - last_settled) * ps   function claimablePremiums() public view override returns (uint256) {     // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)     return       lastClaimablePremiumsForStakers +       (block.timestamp - lastAccountedGlobal) *       allPremiumsPerSecToStakers;   } /// @notice View seconds of coverage left for _protocol before it runs out of active balance   /// @param _protocol Protocol identifier   /// @return Seconds of coverage left   function secondsOfCoverageLeft(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return _secondsOfCoverageLeft(_protocol);   } // Helper function to return seconds of coverage left for a protocol   // Gets the current active balance of the protocol and divides by the premium per second for the protocol   function secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {     uint256 premium = premiums[_protocol];     if (premium == 0) return 0;     return _activeBalance(_protocol) / premium;   } /// @notice View current active balance of covered protocol   /// @param _protocol Protocol identifier   /// @return Active balance   /// @dev Accrued debt is subtracted from the stored active balance   function activeBalance(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return _activeBalance(_protocol);   } // Helper function to calc the active balance of a protocol at current time   function _activeBalance(bytes32 _protocol) internal view returns (uint256) {     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     uint256 balance = activeBalances[_protocol];     // The debt should never be higher than the balance (only happens if the arbitrages fail)     if (debt &gt; balance) return 0;     return balance - debt;   } //   // State methods   // /// @notice Helps set the premium per second for an individual protocol   /// @param protocol Protocol identifier   /// @param _premium New premium per second   /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function   function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)     internal     returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)   {     // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers     // Also updates the last accounted timestamp for this protocol     // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings     // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol     nonStakerPercentage = _settleProtocolDebt(_protocol);     // Stores the old premium before it gets updated     oldPremiumPerSecond = premiums[_protocol]; if (oldPremiumPerSecond != _premium) {   // Sets the protocol's premium per second to the new value   premiums_[_protocol] = _premium;   emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium); } // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point // Where arbs would no longer be incentivized to remove the protocol // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems if (_premium != 0 &amp;&amp; _secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_OF_COVERAGE) {   revert InsufficientBalance(_protocol); }  } /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second   /// @param _protocol Protocol identifier   /// @param _premium New premium per second   function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {     // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings     (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(       _protocol,       _premium     );     // Settling the total amount of premiums owed to stakers before a new premium per second gets set     _settleTotalDebt();     // This calculates the new global premium per second that gets paid to stakers     // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function     allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(       oldPremiumPerSecond,       _premium,       nonStakerPercentage,       nonStakerPercentage,       allPremiumsPerSecToStakers     );   } // Internal function to set a new protocolAgent for a specific protocol   // oldAgent is only included as part of emitting an event   function _setProtocolAgent(     bytes32 _protocol,     address _oldAgent,     address _protocolAgent   ) internal {     protocolAgent[_protocol] = _protocolAgent;     emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);   } // Subtracts the accrued debt from a protocol's active balance   // Credits the amount that can be claimed by nonstakers for this protocol   // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings   // Most of this function is dealing with an edge case related to a protocol not being removed by arbs   function settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {     // This calcs the accrued debt of the protocol since it was last updated     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     // This pulls the percentage that is sent to nonstakers     _nonStakerPercentage = nonStakersPercentage[_protocol];     // In case the protocol has accrued debt, this code block will ensure the debt is settled properly     if (debt != 0) {       // Pulls the stored active balance of the protocol       uint256 balance = activeBalances[_protocol];       // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance       // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point       // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage       // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up       if (debt &gt; balance) {         // This error amount represents the magnitude of the mistake         uint256 error = debt - balance;         // Gets the latest value of claimable premiums for stakers         _settleTotalDebt();         // @note to production, set premium first to zero before solving accounting issue.         // otherwise the accounting error keeps increasing         uint256 lastClaimablePremiumsForStakers = lastClaimablePremiumsForStakers;     // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%     uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /       HUNDRED_PERCENT;      // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short     uint256 insufficientTokens;      // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally     // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error     // This first line can be true if claimPremiumsForStakers() has been called and     // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be &gt;0 still     if (claimablePremiumError &gt; lastClaimablePremiumsForStakers_) {       insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;       lastClaimablePremiumsForStakers = 0;     } else {       // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums       // By the amount that was added in error (error) and insufficientTokens = 0       lastClaimablePremiumsForStakers =         lastClaimablePremiumsForStakers_ -         claimablePremiumError;     }      // If two events are thrown, the values need to be summed up for the actual state.     // This means an error of this type will continue until it is handled     emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);     // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case     debt = balance;   }   // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance   activeBalances[_protocol] = balance - debt;   // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol   nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT; } // Updates the last accounted timestamp for this protocol lastAccountedEachProtocol[_protocol] = block.timestamp;  } // Multiplies the total premium per second * number of seconds since the last global accounting update   // And adds it to the total claimable amount for stakers   function _settleTotalDebt() internal {     lastClaimablePremiumsForStakers +=       (block.timestamp - lastAccountedGlobal) *       allPremiumsPerSecToStakers;     lastAccountedGlobal = block.timestamp;   } // Calculates the global premium per second for stakers   // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers   // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones   function _calcGlobalPremiumPerSecForStakers(     uint256 _premiumOld,     uint256 _premiumNew,     uint256 _nonStakerPercentageOld,     uint256 _nonStakerPercentageNew,     uint256 _inMemAllPremiumsPerSecToStakers   ) internal pure returns (uint256) {     return       _inMemAllPremiumsPerSecToStakers +       ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /       HUNDRED_PERCENT -       ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /       HUNDRED_PERCENT;   } // Helper function to remove and clean up a protocol from Sherlock   // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made   function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {     // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol     _setSingleAndGlobalProtocolPremium(_protocol, 0); // Grabs the protocol's active balance uint256 balance = activeBalances[_protocol];  // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent if (balance != 0) {   delete activeBalances[_protocol];   token.safeTransfer(_agent, balance);    emit ProtocolBalanceWithdrawn(_protocol, balance); }  // Sets the protocol agent to zero address (as part of clean up) _setProtocolAgent(_protocol, _agent, address(0));  // Cleans up other mappings for this protocol delete nonStakersPercentage[_protocol]; delete lastAccountedEachProtocol[_protocol]; // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above  // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;  // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked removedProtocolAgent[_protocol] = _agent;  emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0)); emit ProtocolRemoved(_protocol);  } /// @notice Sets the minimum active balance before an arb can remove a protocol   /// @param _minActiveBalance Minimum balance needed (in USDC)   /// @dev Only gov   function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {     // New value cannot be the same as current value     if (minActiveBalance == _minActiveBalance) revert InvalidArgument();     // Can't set a value that is too high to be reasonable     if (_minActiveBalance &gt;= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions(); emit MinBalance(minActiveBalance, _minActiveBalance); minActiveBalance = _minActiveBalance;  } // This function allows the nonstakers role to claim tokens owed to them by a specific protocol   /// @notice Choose an _amount of tokens that nonstakers (_receiver address) will receive from _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens   /// @param _receiver Address to receive tokens   /// @dev Only callable by nonstakers role   function nonStakersClaim(     bytes32 _protocol,     uint256 _amount,     address _receiver   ) external override whenNotPaused {     if (_protocol == bytes32(0)) revert ZeroArgument();     if (_amount == uint256(0)) revert ZeroArgument();     if (_receiver == address(0)) revert ZeroArgument();     // Only the nonstakers role (multisig or contract) can pull the funds     if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized(); // Call can't be executed on protocol that is removed if (protocolAgent_[_protocol] != address(0)) {   // Updates the amount that nonstakers can claim from this protocol   _settleProtocolDebt(_protocol); }  // Sets balance to the amount that is claimable by nonstakers for this specific protocol uint256 balance = nonStakersClaimableByProtocol[_protocol]; // If the amount requested is more than what's owed to nonstakers, revert if (_amount &gt; balance) revert InsufficientBalance(_protocol);  // Sets the claimable amount to whatever is left over after this amount is pulled nonStakersClaimableByProtocol[_protocol] = balance - _amount; // Transfers the amount requested to the `_receiver` address token.safeTransfer(_receiver, _amount);  } // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)   /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address   /// @dev Callable by everyone   /// @dev Funds will be transferred to Sherlock core contract   function claimPremiumsForStakers() external override whenNotPaused {     // Gets address of core Sherlock contract     address sherlock = address(sherlockCore);     // Revert if core Sherlock contract not initialized yet     if (sherlock == address(0)) revert InvalidConditions(); // claimablePremiums is different from _settleTotalDebt() because it does not change state // Retrieves current amount of all premiums that are owed to stakers uint256 amount = claimablePremiums();  // Transfers all the premiums owed to stakers to the Sherlock core contract if (amount != 0) {   // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out   lastClaimablePremiumsForStakers = 0;   lastAccountedGlobal = block.timestamp;   token.safeTransfer(sherlock, amount); }  } // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts   /// @param protocol Protocol identifier   /// @return current and previous are the current and previous coverage amounts for this protocol   // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)   function coverageAmounts(bytes32 _protocol)     external     view     override     returns (uint256 current, uint256 previous)   {     // Checks to see if the protocol has an active protocolAgent (protocol not removed)     // OR checks to see if the removed protocol is still within the claim window     // If so, gives the current and previous coverage, otherwise throws an error     if (       protocolAgent[_protocol] != address(0) ||       block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]     ) {       return (currentCoverage[_protocol], previousCoverage[_protocol]);     } revert ProtocolNotExists(_protocol);  } /// @notice Add a new protocol to Sherlock   /// @param protocol Protocol identifier   /// @param _protocolAgent Address able to submit a claim on behalf of the protocol   /// @param _coverage Hash referencing the active coverage agreement   /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 1018   /// @param _coverageAmount Max amount claimable by this protocol   /// @dev Adding a protocol allows the _protocolAgent to submit a claim   /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point   /// @dev _nonStakers is scaled by 1018   /// @dev Only callable by governance   function protocolAdd(     bytes32 _protocol,     address _protocolAgent,     bytes32 _coverage,     uint256 _nonStakers,     uint256 _coverageAmount   ) external override onlyOwner {     if (_protocol == bytes32(0)) revert ZeroArgument();     if (_protocolAgent == address(0)) revert ZeroArgument();     // Checks to make sure the protocol doesn't exist already     if (protocolAgent[_protocol] != address(0)) revert InvalidConditions(); // Updates the protocol agent and passes in the old agent which is 0 address in this case _setProtocolAgent(_protocol, address(0), _protocolAgent);  // Delete mappings that are potentially non default values // From previous time protocol was added/removed delete removedProtocolClaimDeadline[_protocol]; delete removedProtocolAgent[_protocol]; delete currentCoverage[_protocol]; delete previousCoverage[_protocol];  emit ProtocolAdded(_protocol);  // Most of the logic for actually adding a protocol in this function protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);  } /// @notice Update info regarding a protocol   /// @param _protocol Protocol identifier   /// @param _coverage Hash referencing the active coverage agreement   /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18   /// @param _coverageAmount Max amount claimable by this protocol   /// @dev Only callable by governance   /// @dev _nonStakers can be 0   function protocolUpdate(     bytes32 _protocol,     bytes32 _coverage,     uint256 _nonStakers,     uint256 _coverageAmount   ) public override onlyOwner {     if (_coverage == bytes32(0)) revert ZeroArgument();     if (_nonStakers &gt; HUNDRED_PERCENT) revert InvalidArgument();     if (_coverageAmount == uint256(0)) revert ZeroArgument(); // Checks to make sure the protocol has been assigned a protocol agent _verifyProtocolExists(_protocol);  // Subtracts the accrued debt from a protocol's active balance (if any) // Updates the amount that can be claimed by nonstakers _settleProtocolDebt(_protocol);  // Updates the global claimable amount for stakers _settleTotalDebt();  // Gets the premium per second for this protocol uint256 premium = premiums_[_protocol];  // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be) allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(   premium,   premium,   nonStakersPercentage[_protocol],   _nonStakers,   allPremiumsPerSecToStakers );  // Updates the stored value of percentage of premiums that go to nonstakers nonStakersPercentage[_protocol] = _nonStakers;  // Updates previous coverage and current coverage amounts previousCoverage[_protocol] = currentCoverage[_protocol]; currentCoverage[_protocol] = _coverageAmount;  emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);  } /// @notice Remove a protocol from coverage   /// @param _protocol Protocol identifier   /// @dev Before removing a protocol the premium must be 0   /// @dev Removing a protocol basically stops the _protocolAgent from being active (can still submit claims until claim deadline though)   /// @dev Pays off debt + sends remaining balance to protocol agent   /// @dev This call should be subject to a timelock   /// @dev Only callable by governance   function protocolRemove(bytes32 _protocol) external override onlyOwner {     // checks to make sure the protocol actually has a protocol agent     address agent = _verifyProtocolExists(_protocol); // Removes a protocol from Sherlock and cleans up its data // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made _forceRemoveProtocol(_protocol, agent);  } /// @notice Remove a protocol with insufficient active balance   /// @param _protocol Protocol identifier   // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function   function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {     address agent = _verifyProtocolExists(_protocol); // Gets the latest value of the active balance at this protocol _settleProtocolDebt(_protocol); // Sets latest value of active balance to remainingBalance variable uint256 remainingBalance = activeBalances[_protocol];  // This means the protocol still has adequate active balance and thus cannot be removed if (remainingBalance &gt;= minActiveBalance) revert InvalidConditions();  // Sets the protocol's active balance to 0 delete activeBalances[_protocol]; // Removes the protocol from coverage _forceRemoveProtocol(_protocol, agent);  if (remainingBalance != 0) {   // sends the remaining balance to msg.sender   token.safeTransfer(msg.sender, remainingBalance); } emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);  } /// @notice Calculate if arb is possible and what the reward would be   /// @param _protocol Protocol identifier   /// @return arbAmount Amount reward for arbing   /// @return able Indicator if arb call is even possible   /// @dev Doesn't subtract the current protocol debt from the active balance   function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)     internal     view     returns (uint256 arbAmount, bool able)   {     uint256 secondsLeft = _secondsOfCoverageLeft(_protocol); // If arb is not possible return false if (secondsLeft &gt;= MIN_SECONDS_OF_COVERAGE) return (0, false);  // This percentage scales over time // Reaches 100% on 0 seconds of coverage left uint256 percentageScaled = HUNDRED_PERCENT -   (secondsLeft * HUNDRED_PERCENT) /   MIN_SECONDS_OF_COVERAGE;  able = true; arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;  } /// @notice Removes a protocol with insufficent seconds of coverage left   /// @param _protocol Protocol identifier   // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second   function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {     // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings     address agent = _verifyProtocolExists(_protocol); // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance() // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance() // But when removing based on seconds of coverage left, the remainingBalance could still be quite large // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%) _settleProtocolDebt(_protocol); (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol); if (able == false) revert InvalidConditions();  if (arbAmount != 0) {   // subtracts the amount that will be paid to the arb from the active balance   activeBalances[_protocol] -= arbAmount; }  // Removes the protocol from coverage // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above _forceRemoveProtocol(_protocol, agent);  // Done after removing protocol to mitigate reentrency pattern // (In case token allows callback) if (arbAmount != 0) {   token.safeTransfer(msg.sender, arbAmount); } emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);  } /// @notice Set premium of _protocol to _premium   /// @param _protocol Protocol identifier   /// @param _premium Amount of premium _protocol pays per second   /// @dev The value 0 would mean inactive coverage   /// @dev Only callable by governance   function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {     // Checks to see if protocol has a protocol agent     _verifyProtocolExists(_protocol); // Updates individual protocol's premium and allPremiumsPerSecToStakers _setSingleAndGlobalProtocolPremium(_protocol, _premium);  } /// @notice Set premium of multiple protocols   /// @param _protocol Array of protocol identifiers   /// @param _premium Array of premium amounts protocols pay per second   /// @dev The value 0 would mean inactive coverage   /// @dev Only callable by governance   function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)     external     override     onlyOwner   {     // Checks to make sure there are an equal amount of entries in each array     if (_protocol.length != _premium.length) revert UnequalArrayLength();     if (_protocol.length == 0) revert InvalidArgument(); // Updates the global claimable amount for stakers _settleTotalDebt();  uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;  // Loops through the array of protocols and checks to make sure each has a protocol agent assigned for (uint256 i; i &lt; _protocol.length; i++) {   _verifyProtocolExists(_protocol[i]);    // Sets the protocol premium for that specific protocol   // Function returns the old premium and nonStakerPercentage for that specific protocol   (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(     _protocol[i],     _premium[i]   );    // Calculates the new global premium which adds up all premiums paid by all protocols   allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(     oldPremiumPerSecond,     _premium[i],     nonStakerPercentage,     nonStakerPercentage,     allPremiumsPerSecToStakers_   ); }  // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;  } // This is how protocols pay for coverage by increasing their active balance   /// @notice Deposits _amount of token to the active balance of _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens to deposit   /// @dev Approval should be made before calling   function depositToActiveBalance(bytes32 _protocol, uint256 _amount)     external     override     whenNotPaused   {     if (_amount == uint256(0)) revert ZeroArgument();     _verifyProtocolExists(_protocol); // Transfers _amount to this contract token.safeTransferFrom(msg.sender, address(this), _amount); // Increases the active balance of the protocol by _amount activeBalances[_protocol] += _amount;  emit ProtocolBalanceDeposited(_protocol, _amount);  } // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)   // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)   /// @notice Withdraws _amount of token from the active balance of _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens to withdraw   /// @dev Only protocol agent is able to withdraw   /// @dev Balance can be withdrawn up until 7 days worth of active balance   function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)     external     override     whenNotPaused   {     if (_amount == uint256(0)) revert ZeroArgument();     // Only the protocol agent can call this function     if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized(); // Updates the active balance of the protocol _settleProtocolDebt(_protocol);  // Sets currentBalance to the active balance of the protocol uint256 currentBalance = activeBalances[_protocol]; // Reverts if trying to withdraw more than the active balance if (_amount &gt; currentBalance) revert InsufficientBalance(_protocol);  // Removes the _amount to be withdrawn from the active balance activeBalances[_protocol] = currentBalance - _amount; // Reverts if a protocol has less than 7 days worth of active balance left if (_secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);  // Transfers the amount to the msg.sender (protocol agent) token.safeTransfer(msg.sender, _amount); emit ProtocolBalanceWithdrawn(_protocol, _amount);  } /// @notice Transfer protocol agent role   /// @param _protocol Protocol identifier   /// @param _protocolAgent Account able to submit a claim on behalf of the protocol   /// @dev Only the active protocolAgent is able to transfer the role   function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)     external     override     whenNotPaused   {     if (_protocolAgent == address(0)) revert ZeroArgument();     // Can't set the new protocol agent to the caller address     if (msg.sender == _protocolAgent) revert InvalidArgument();     // Because the caller must be the current protocol agent     if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized(); // Sets the protocol agent to the new address _setProtocolAgent(_protocol, msg.sender, _protocolAgent);  } /// @notice Function used to check if this is the current active protocol manager   /// @return Boolean indicating it's active   /// @dev If inactive the owner can pull all ERC20s and ETH   /// @dev Will be checked by calling the sherlock contract   function isActive() public view returns (bool) {     return address(sherlockCore.sherlockProtocolManager()) == address(this);   } // Only contract owner can call this   // Sends all specified tokens in this contract to the receiver's address (as well as ETH)   function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {     if (_receiver == address(0)) revert ZeroArgument();     // This contract must NOT be the current assigned protocol manager contract     if (isActive()) revert InvalidConditions();     // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH     _sweep(_receiver, _extraTokens);   } } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-25-08 10:59:11 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import './Manager.sol'; import '../interfaces/managers/ISherlockProtocolManager.sol'; /// @title Sherlock core interface for protocols /// @author Evert Kors // This is the contract that manages covered protocols contract SherlockProtocolManager is ISherlockProtocolManager, Manager {   using SafeERC20 for IERC20; // Represents the token that protocols pay with (currently USDC)   IERC20 public immutable token; // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed   uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc // A removed protocol is still able to make a claim for this amount of time after its removal   uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days; // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance   uint256 public constant MIN_SECONDS_LEFT = 7 days; // Convenient for percentage calculations   uint256 internal constant HUNDRED_PERCENT = 10**18; // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage   // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying   uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours; // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)   mapping(bytes32 =&gt; address) internal protocolAgent_; // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)   mapping(bytes32 =&gt; uint256) internal nonStakersPercentage; // The premium per second paid by each protocol is stored in this mapping   mapping(bytes32 =&gt; uint256) internal premiums_; // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.   // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not   mapping(bytes32 =&gt; uint256) internal activeBalances; // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol   mapping(bytes32 =&gt; uint256) internal lastAccountedEachProtocol; // The amount that can be claimed by nonstakers for each protocol   // We need this value so we can track how much payment is coming from each protocol   mapping(bytes32 =&gt; uint256) internal nonStakersClaimableByProtocol; // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)   uint256 internal lastAccountedGlobal; // This is the total amount of premiums paid (per second) by all the covered protocols (added up)   uint256 internal allPremiumsPerSecToStakers; // This is the amount that was claimable by stakers the last time the accounting was run   // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date   uint256 internal lastClaimablePremiumsForStakers; // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage   // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)   uint256 public override minActiveBalance; // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)   mapping(bytes32 =&gt; uint256) internal removedProtocolClaimDeadline; // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)   mapping(bytes32 =&gt; address) internal removedProtocolAgent; // Current amount of coverage (i.e. 20M USDC) for a protocol   mapping(bytes32 =&gt; uint256) internal currentCoverage; // Previous amount of coverage for a protocol   // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount   mapping(bytes32 =&gt; uint256) internal previousCoverage; // Setting the token to USDC   constructor(IERC20 _token) {     if (address(_token) == address(0)) revert ZeroArgument();     token = _token;   } // Modifier used to ensure a protocol exists (has been instantiated and not removed)   modifier protocolExists(bytes32 protocol) {     _verifyProtocolExists(_protocol);     ;   } /// @notice View current protocolAgent of _protocol   /// @param protocol Protocol identifier   /// @return Address able to submit claims   function protocolAgent(bytes32 _protocol) external view override returns (address) {     address agent = protocolAgent[_protocol];     if (agent != address(0)) return agent; // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned // Note: Old protocol agent will never be address(0) if (block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]) {   return removedProtocolAgent[_protocol]; }  // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned revert ProtocolNotExists(_protocol);  } // Checks if the protocol exists, then returns the current premium per second being charged   /// @notice View current premium of protocol   /// @param protocol Protocol identifier   /// @return Amount of premium _protocol pays per second   function premium(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return premiums[_protocol];   } // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)   // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)   function verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {     _protocolAgent = protocolAgent[_protocol];     if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);   } //   // View methods   // // Calcs the debt accrued by the protocol since it last had an accounting update   // This is the amount that needs to be removed from a protocol's active balance   function calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {     return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums[_protocol];   } /// @notice View the amount nonstakers can claim from this protocol   /// @param _protocol Protocol identifier   /// @return Amount of tokens claimable by nonstakers   /// @dev this reads from a storage variable + (now-lastsettled) * premiums   // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]   // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed   function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {     // Calcs the debt of a protocol since the last accounting update     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     // Gets the active balance of the protocol     uint256 balance = activeBalances[_protocol];     // The debt should never be higher than the balance (only happens if the arbitrages fail)     if (debt &gt; balance) debt = balance; // Adds the incremental claimable amount owed to nonstakers to the total claimable amount return   nonStakersClaimableByProtocol[_protocol] +   (nonStakersPercentage[_protocol] * debt) /   HUNDRED_PERCENT;  } /// @notice View current amount of all premiums that are owed to stakers   /// @return Premiums claimable   /// @dev Will increase every block   /// @dev base + (now - last_settled) * ps   function claimablePremiums() public view override returns (uint256) {     // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)     return       lastClaimablePremiumsForStakers +       (block.timestamp - lastAccountedGlobal) *       allPremiumsPerSecToStakers;   } /// @notice View seconds of coverage left for _protocol before it runs out of active balance   /// @param _protocol Protocol identifier   /// @return Seconds of coverage left   function secondsOfCoverageLeft(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return _secondsOfCoverageLeft(_protocol);   } // Helper function to return seconds of coverage left for a protocol   // Gets the current active balance of the protocol and divides by the premium per second for the protocol   function secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {     uint256 premium = premiums[_protocol];     if (premium == 0) return 0;     return _activeBalance(_protocol) / premium;   } /// @notice View current active balance of covered protocol   /// @param _protocol Protocol identifier   /// @return Active balance   /// @dev Accrued debt is subtracted from the stored active balance   function activeBalance(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return _activeBalance(_protocol);   } // Helper function to calc the active balance of a protocol at current time   function _activeBalance(bytes32 _protocol) internal view returns (uint256) {     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     uint256 balance = activeBalances[_protocol];     // The debt should never be higher than the balance (only happens if the arbitrages fail)     if (debt &gt; balance) return 0;     return balance - debt;   } //   // State methods   // /// @notice Helps set the premium per second for an individual protocol   /// @param protocol Protocol identifier   /// @param _premium New premium per second   /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function   function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)     internal     returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)   {     // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers     // Also updates the last accounted timestamp for this protocol     // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings     // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol     nonStakerPercentage = _settleProtocolDebt(_protocol);     // Stores the old premium before it gets updated     oldPremiumPerSecond = premiums[_protocol]; if (oldPremiumPerSecond != _premium) {   // Sets the protocol's premium per second to the new value   premiums_[_protocol] = _premium;   emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium); } // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point // Where arbs would no longer be incentivized to remove the protocol // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems if (_premium != 0 &amp;&amp; _secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_OF_COVERAGE) {   revert InsufficientBalance(_protocol); }  } /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second   /// @param _protocol Protocol identifier   /// @param _premium New premium per second   function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {     // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings     (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(       _protocol,       _premium     );     // Settling the total amount of premiums owed to stakers before a new premium per second gets set     _settleTotalDebt();     // This calculates the new global premium per second that gets paid to stakers     // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function     allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(       oldPremiumPerSecond,       _premium,       nonStakerPercentage,       nonStakerPercentage,       allPremiumsPerSecToStakers     );   } // Internal function to set a new protocolAgent for a specific protocol   // oldAgent is only included as part of emitting an event   function _setProtocolAgent(     bytes32 _protocol,     address _oldAgent,     address _protocolAgent   ) internal {     protocolAgent[_protocol] = _protocolAgent;     emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);   } // Subtracts the accrued debt from a protocol's active balance   // Credits the amount that can be claimed by nonstakers for this protocol   // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings   // Most of this function is dealing with an edge case related to a protocol not being removed by arbs   function settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {     // This calcs the accrued debt of the protocol since it was last updated     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     // This pulls the percentage that is sent to nonstakers     _nonStakerPercentage = nonStakersPercentage[_protocol];     // In case the protocol has accrued debt, this code block will ensure the debt is settled properly     if (debt != 0) {       // Pulls the stored active balance of the protocol       uint256 balance = activeBalances[_protocol];       // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance       // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point       // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage       // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up       if (debt &gt; balance) {         // This error amount represents the magnitude of the mistake         uint256 error = debt - balance;         // Gets the latest value of claimable premiums for stakers         _settleTotalDebt();         // @note to production, set premium first to zero before solving accounting issue.         // otherwise the accounting error keeps increasing         uint256 lastClaimablePremiumsForStakers = lastClaimablePremiumsForStakers;     // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%     uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /       HUNDRED_PERCENT;      // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short     uint256 insufficientTokens;      // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally     // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error     // This first line can be true if claimPremiumsForStakers() has been called and     // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be &gt;0 still     if (claimablePremiumError &gt; lastClaimablePremiumsForStakers_) {       insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;       lastClaimablePremiumsForStakers = 0;     } else {       // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums       // By the amount that was added in error (error) and insufficientTokens = 0       lastClaimablePremiumsForStakers =         lastClaimablePremiumsForStakers_ -         claimablePremiumError;     }      // If two events are thrown, the values need to be summed up for the actual state.     // This means an error of this type will continue until it is handled     emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);     // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case     debt = balance;   }   // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance   activeBalances[_protocol] = balance - debt;   // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol   nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT; } // Updates the last accounted timestamp for this protocol lastAccountedEachProtocol[_protocol] = block.timestamp;  } // Multiplies the total premium per second * number of seconds since the last global accounting update   // And adds it to the total claimable amount for stakers   function _settleTotalDebt() internal {     lastClaimablePremiumsForStakers +=       (block.timestamp - lastAccountedGlobal) *       allPremiumsPerSecToStakers;     lastAccountedGlobal = block.timestamp;   } // Calculates the global premium per second for stakers   // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers   // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones   function _calcGlobalPremiumPerSecForStakers(     uint256 _premiumOld,     uint256 _premiumNew,     uint256 _nonStakerPercentageOld,     uint256 _nonStakerPercentageNew,     uint256 _inMemAllPremiumsPerSecToStakers   ) internal pure returns (uint256) {     return       _inMemAllPremiumsPerSecToStakers +       ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /       HUNDRED_PERCENT -       ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /       HUNDRED_PERCENT;   } // Helper function to remove and clean up a protocol from Sherlock   // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made   function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {     // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol     _setSingleAndGlobalProtocolPremium(_protocol, 0); // Grabs the protocol's active balance uint256 balance = activeBalances[_protocol];  // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent if (balance != 0) {   delete activeBalances[_protocol];   token.safeTransfer(_agent, balance);    emit ProtocolBalanceWithdrawn(_protocol, balance); }  // Sets the protocol agent to zero address (as part of clean up) _setProtocolAgent(_protocol, _agent, address(0));  // Cleans up other mappings for this protocol delete nonStakersPercentage[_protocol]; delete lastAccountedEachProtocol[_protocol]; // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above  // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;  // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked removedProtocolAgent[_protocol] = _agent;  emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0)); emit ProtocolRemoved(_protocol);  } /// @notice Sets the minimum active balance before an arb can remove a protocol   /// @param _minActiveBalance Minimum balance needed (in USDC)   /// @dev Only gov   function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {     // New value cannot be the same as current value     if (minActiveBalance == _minActiveBalance) revert InvalidArgument();     // Can't set a value that is too high to be reasonable     if (_minActiveBalance &gt;= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions(); emit MinBalance(minActiveBalance, _minActiveBalance); minActiveBalance = _minActiveBalance;  } // This function allows the nonstakers role to claim tokens owed to them by a specific protocol   /// @notice Choose an _amount of tokens that nonstakers (_receiver address) will receive from _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens   /// @param _receiver Address to receive tokens   /// @dev Only callable by nonstakers role   function nonStakersClaim(     bytes32 _protocol,     uint256 _amount,     address _receiver   ) external override whenNotPaused {     if (_protocol == bytes32(0)) revert ZeroArgument();     if (_amount == uint256(0)) revert ZeroArgument();     if (_receiver == address(0)) revert ZeroArgument();     // Only the nonstakers role (multisig or contract) can pull the funds     if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized(); // Call can't be executed on protocol that is removed if (protocolAgent_[_protocol] != address(0)) {   // Updates the amount that nonstakers can claim from this protocol   _settleProtocolDebt(_protocol); }  // Sets balance to the amount that is claimable by nonstakers for this specific protocol uint256 balance = nonStakersClaimableByProtocol[_protocol]; // If the amount requested is more than what's owed to nonstakers, revert if (_amount &gt; balance) revert InsufficientBalance(_protocol);  // Sets the claimable amount to whatever is left over after this amount is pulled nonStakersClaimableByProtocol[_protocol] = balance - _amount; // Transfers the amount requested to the `_receiver` address token.safeTransfer(_receiver, _amount);  } // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)   /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address   /// @dev Callable by everyone   /// @dev Funds will be transferred to Sherlock core contract   function claimPremiumsForStakers() external override whenNotPaused {     // Gets address of core Sherlock contract     address sherlock = address(sherlockCore);     // Revert if core Sherlock contract not initialized yet     if (sherlock == address(0)) revert InvalidConditions(); // claimablePremiums is different from _settleTotalDebt() because it does not change state // Retrieves current amount of all premiums that are owed to stakers uint256 amount = claimablePremiums();  // Transfers all the premiums owed to stakers to the Sherlock core contract if (amount != 0) {   // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out   lastClaimablePremiumsForStakers = 0;   lastAccountedGlobal = block.timestamp;   token.safeTransfer(sherlock, amount); }  } // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts   /// @param protocol Protocol identifier   /// @return current and previous are the current and previous coverage amounts for this protocol   // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)   function coverageAmounts(bytes32 _protocol)     external     view     override     returns (uint256 current, uint256 previous)   {     // Checks to see if the protocol has an active protocolAgent (protocol not removed)     // OR checks to see if the removed protocol is still within the claim window     // If so, gives the current and previous coverage, otherwise throws an error     if (       protocolAgent[_protocol] != address(0) ||       block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]     ) {       return (currentCoverage[_protocol], previousCoverage[_protocol]);     } revert ProtocolNotExists(_protocol);  } /// @notice Add a new protocol to Sherlock   /// @param protocol Protocol identifier   /// @param _protocolAgent Address able to submit a claim on behalf of the protocol   /// @param _coverage Hash referencing the active coverage agreement   /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 1018   /// @param _coverageAmount Max amount claimable by this protocol   /// @dev Adding a protocol allows the _protocolAgent to submit a claim   /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point   /// @dev _nonStakers is scaled by 1018   /// @dev Only callable by governance   function protocolAdd(     bytes32 _protocol,     address _protocolAgent,     bytes32 _coverage,     uint256 _nonStakers,     uint256 _coverageAmount   ) external override onlyOwner {     if (_protocol == bytes32(0)) revert ZeroArgument();     if (_protocolAgent == address(0)) revert ZeroArgument();     // Checks to make sure the protocol doesn't exist already     if (protocolAgent[_protocol] != address(0)) revert InvalidConditions(); // Updates the protocol agent and passes in the old agent which is 0 address in this case _setProtocolAgent(_protocol, address(0), _protocolAgent);  // Delete mappings that are potentially non default values // From previous time protocol was added/removed delete removedProtocolClaimDeadline[_protocol]; delete removedProtocolAgent[_protocol]; delete currentCoverage[_protocol]; delete previousCoverage[_protocol];  emit ProtocolAdded(_protocol);  // Most of the logic for actually adding a protocol in this function protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);  } /// @notice Update info regarding a protocol   /// @param _protocol Protocol identifier   /// @param _coverage Hash referencing the active coverage agreement   /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18   /// @param _coverageAmount Max amount claimable by this protocol   /// @dev Only callable by governance   /// @dev _nonStakers can be 0   function protocolUpdate(     bytes32 _protocol,     bytes32 _coverage,     uint256 _nonStakers,     uint256 _coverageAmount   ) public override onlyOwner {     if (_coverage == bytes32(0)) revert ZeroArgument();     if (_nonStakers &gt; HUNDRED_PERCENT) revert InvalidArgument();     if (_coverageAmount == uint256(0)) revert ZeroArgument(); // Checks to make sure the protocol has been assigned a protocol agent _verifyProtocolExists(_protocol);  // Subtracts the accrued debt from a protocol's active balance (if any) // Updates the amount that can be claimed by nonstakers _settleProtocolDebt(_protocol);  // Updates the global claimable amount for stakers _settleTotalDebt();  // Gets the premium per second for this protocol uint256 premium = premiums_[_protocol];  // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be) allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(   premium,   premium,   nonStakersPercentage[_protocol],   _nonStakers,   allPremiumsPerSecToStakers );  // Updates the stored value of percentage of premiums that go to nonstakers nonStakersPercentage[_protocol] = _nonStakers;  // Updates previous coverage and current coverage amounts previousCoverage[_protocol] = currentCoverage[_protocol]; currentCoverage[_protocol] = _coverageAmount;  emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);  } /// @notice Remove a protocol from coverage   /// @param _protocol Protocol identifier   /// @dev Before removing a protocol the premium must be 0   /// @dev Removing a protocol basically stops the _protocolAgent from being active (can still submit claims until claim deadline though)   /// @dev Pays off debt + sends remaining balance to protocol agent   /// @dev This call should be subject to a timelock   /// @dev Only callable by governance   function protocolRemove(bytes32 _protocol) external override onlyOwner {     // checks to make sure the protocol actually has a protocol agent     address agent = _verifyProtocolExists(_protocol); // Removes a protocol from Sherlock and cleans up its data // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made _forceRemoveProtocol(_protocol, agent);  } /// @notice Remove a protocol with insufficient active balance   /// @param _protocol Protocol identifier   // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function   function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {     address agent = _verifyProtocolExists(_protocol); // Gets the latest value of the active balance at this protocol _settleProtocolDebt(_protocol); // Sets latest value of active balance to remainingBalance variable uint256 remainingBalance = activeBalances[_protocol];  // This means the protocol still has adequate active balance and thus cannot be removed if (remainingBalance &gt;= minActiveBalance) revert InvalidConditions();  // Sets the protocol's active balance to 0 delete activeBalances[_protocol]; // Removes the protocol from coverage _forceRemoveProtocol(_protocol, agent);  if (remainingBalance != 0) {   // sends the remaining balance to msg.sender   token.safeTransfer(msg.sender, remainingBalance); } emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);  } /// @notice Calculate if arb is possible and what the reward would be   /// @param _protocol Protocol identifier   /// @return arbAmount Amount reward for arbing   /// @return able Indicator if arb call is even possible   /// @dev Doesn't subtract the current protocol debt from the active balance   function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)     internal     view     returns (uint256 arbAmount, bool able)   {     uint256 secondsLeft = _secondsOfCoverageLeft(_protocol); // If arb is not possible return false if (secondsLeft &gt;= MIN_SECONDS_OF_COVERAGE) return (0, false);  // This percentage scales over time // Reaches 100% on 0 seconds of coverage left uint256 percentageScaled = HUNDRED_PERCENT -   (secondsLeft * HUNDRED_PERCENT) /   MIN_SECONDS_OF_COVERAGE;  able = true; arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;  } /// @notice Removes a protocol with insufficent seconds of coverage left   /// @param _protocol Protocol identifier   // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second   function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {     // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings     address agent = _verifyProtocolExists(_protocol); // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance() // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance() // But when removing based on seconds of coverage left, the remainingBalance could still be quite large // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%) _settleProtocolDebt(_protocol); (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol); if (able == false) revert InvalidConditions();  if (arbAmount != 0) {   // subtracts the amount that will be paid to the arb from the active balance   activeBalances[_protocol] -= arbAmount; }  // Removes the protocol from coverage // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above _forceRemoveProtocol(_protocol, agent);  // Done after removing protocol to mitigate reentrency pattern // (In case token allows callback) if (arbAmount != 0) {   token.safeTransfer(msg.sender, arbAmount); } emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);  } /// @notice Set premium of _protocol to _premium   /// @param _protocol Protocol identifier   /// @param _premium Amount of premium _protocol pays per second   /// @dev The value 0 would mean inactive coverage   /// @dev Only callable by governance   function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {     // Checks to see if protocol has a protocol agent     _verifyProtocolExists(_protocol); // Updates individual protocol's premium and allPremiumsPerSecToStakers _setSingleAndGlobalProtocolPremium(_protocol, _premium);  } /// @notice Set premium of multiple protocols   /// @param _protocol Array of protocol identifiers   /// @param _premium Array of premium amounts protocols pay per second   /// @dev The value 0 would mean inactive coverage   /// @dev Only callable by governance   function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)     external     override     onlyOwner   {     // Checks to make sure there are an equal amount of entries in each array     if (_protocol.length != _premium.length) revert UnequalArrayLength();     if (_protocol.length == 0) revert InvalidArgument(); // Updates the global claimable amount for stakers _settleTotalDebt();  uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;  // Loops through the array of protocols and checks to make sure each has a protocol agent assigned for (uint256 i; i &lt; _protocol.length; i++) {   _verifyProtocolExists(_protocol[i]);    // Sets the protocol premium for that specific protocol   // Function returns the old premium and nonStakerPercentage for that specific protocol   (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(     _protocol[i],     _premium[i]   );    // Calculates the new global premium which adds up all premiums paid by all protocols   allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(     oldPremiumPerSecond,     _premium[i],     nonStakerPercentage,     nonStakerPercentage,     allPremiumsPerSecToStakers_   ); }  // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;  } // This is how protocols pay for coverage by increasing their active balance   /// @notice Deposits _amount of token to the active balance of _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens to deposit   /// @dev Approval should be made before calling   function depositToActiveBalance(bytes32 _protocol, uint256 _amount)     external     override     whenNotPaused   {     if (_amount == uint256(0)) revert ZeroArgument();     _verifyProtocolExists(_protocol); // Transfers _amount to this contract token.safeTransferFrom(msg.sender, address(this), _amount); // Increases the active balance of the protocol by _amount activeBalances[_protocol] += _amount;  emit ProtocolBalanceDeposited(_protocol, _amount);  } // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)   // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)   /// @notice Withdraws _amount of token from the active balance of _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens to withdraw   /// @dev Only protocol agent is able to withdraw   /// @dev Balance can be withdrawn up until 7 days worth of active balance   function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)     external     override     whenNotPaused   {     if (_amount == uint256(0)) revert ZeroArgument();     // Only the protocol agent can call this function     if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized(); // Updates the active balance of the protocol _settleProtocolDebt(_protocol);  // Sets currentBalance to the active balance of the protocol uint256 currentBalance = activeBalances[_protocol]; // Reverts if trying to withdraw more than the active balance if (_amount &gt; currentBalance) revert InsufficientBalance(_protocol);  // Removes the _amount to be withdrawn from the active balance activeBalances[_protocol] = currentBalance - _amount; // Reverts if a protocol has less than 7 days worth of active balance left if (_secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);  // Transfers the amount to the msg.sender (protocol agent) token.safeTransfer(msg.sender, _amount); emit ProtocolBalanceWithdrawn(_protocol, _amount);  } /// @notice Transfer protocol agent role   /// @param _protocol Protocol identifier   /// @param _protocolAgent Account able to submit a claim on behalf of the protocol   /// @dev Only the active protocolAgent is able to transfer the role   function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)     external     override     whenNotPaused   {     if (_protocolAgent == address(0)) revert ZeroArgument();     // Can't set the new protocol agent to the caller address     if (msg.sender == _protocolAgent) revert InvalidArgument();     // Because the caller must be the current protocol agent     if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized(); // Sets the protocol agent to the new address _setProtocolAgent(_protocol, msg.sender, _protocolAgent);  } /// @notice Function used to check if this is the current active protocol manager   /// @return Boolean indicating it's active   /// @dev If inactive the owner can pull all ERC20s and ETH   /// @dev Will be checked by calling the sherlock contract   function isActive() public view returns (bool) {     return address(sherlockCore.sherlockProtocolManager()) == address(this);   } // Only contract owner can call this   // Sends all specified tokens in this contract to the receiver's address (as well as ETH)   function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {     if (_receiver == address(0)) revert ZeroArgument();     // This contract must NOT be the current assigned protocol manager contract     if (isActive()) revert InvalidConditions();     // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH     _sweep(_receiver, _extraTokens);   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-25-08 10:59:11 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import './Manager.sol';
import '../interfaces/managers/ISherlockProtocolManager.sol';

/// @title Sherlock core interface for protocols
/// @author Evert Kors
// This is the contract that manages covered protocols

contract SherlockProtocolManager is ISherlockProtocolManager, Manager {
  using SafeERC20 for IERC20;

  // Represents the token that protocols pay with (currently USDC)
  IERC20 public immutable token;

  // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed
  uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc

  // A removed protocol is still able to make a claim for this amount of time after its removal
  uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days;

  // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance
  uint256 public constant MIN_SECONDS_LEFT = 7 days;

  // Convenient for percentage calculations
  uint256 internal constant HUNDRED_PERCENT = 10**18;

  // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage
  // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying
  uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours;

  // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)
  mapping(bytes32 => address) internal protocolAgent_;

  // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)
  mapping(bytes32 => uint256) internal nonStakersPercentage;

  // The premium per second paid by each protocol is stored in this mapping
  mapping(bytes32 => uint256) internal premiums_;

  // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.
  // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not
  mapping(bytes32 => uint256) internal activeBalances;

  // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol
  mapping(bytes32 => uint256) internal lastAccountedEachProtocol;

  // The amount that can be claimed by nonstakers for each protocol
  // We need this value so we can track how much payment is coming from each protocol
  mapping(bytes32 => uint256) internal nonStakersClaimableByProtocol;

  // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)
  uint256 internal lastAccountedGlobal;

  // This is the total amount of premiums paid (per second) by all the covered protocols (added up)
  uint256 internal allPremiumsPerSecToStakers;

  // This is the amount that was claimable by stakers the last time the accounting was run
  // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date
  uint256 internal lastClaimablePremiumsForStakers;

  // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage
  // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)
  uint256 public override minActiveBalance;

  // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)
  mapping(bytes32 => uint256) internal removedProtocolClaimDeadline;

  // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)
  mapping(bytes32 => address) internal removedProtocolAgent;

  // Current amount of coverage (i.e. 20M USDC) for a protocol
  mapping(bytes32 => uint256) internal currentCoverage;

  // Previous amount of coverage for a protocol
  // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount
  mapping(bytes32 => uint256) internal previousCoverage;

  // Setting the token to USDC
  constructor(IERC20 _token) {
    if (address(_token) == address(0)) revert ZeroArgument();
    token = _token;
  }

  // Modifier used to ensure a protocol exists (has been instantiated and not removed)
  modifier protocolExists(bytes32 _protocol) {
    _verifyProtocolExists(_protocol);
    _;
  }

  /// @notice View current protocolAgent of `_protocol`
  /// @param _protocol Protocol identifier
  /// @return Address able to submit claims
  function protocolAgent(bytes32 _protocol) external view override returns (address) {
    address agent = protocolAgent_[_protocol];
    if (agent != address(0)) return agent;

    // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned
    // Note: Old protocol agent will never be address(0)
    if (block.timestamp <= removedProtocolClaimDeadline[_protocol]) {
      return removedProtocolAgent[_protocol];
    }

    // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned
    revert ProtocolNotExists(_protocol);
  }

  // Checks if the protocol exists, then returns the current premium per second being charged
  /// @notice View current premium of protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of premium `_protocol` pays per second
  function premium(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return premiums_[_protocol];
  }

  // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)
  // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)
  function _verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {
    _protocolAgent = protocolAgent_[_protocol];
    if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);
  }

  //
  // View methods
  //

  // Calcs the debt accrued by the protocol since it last had an accounting update
  // This is the amount that needs to be removed from a protocol's active balance
  function _calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {
    return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums_[_protocol];
  }

  /// @notice View the amount nonstakers can claim from this protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of tokens claimable by nonstakers
  /// @dev this reads from a storage variable + (now-lastsettled) * premiums
  // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]
  // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed
  function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {
    // Calcs the debt of a protocol since the last accounting update
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // Gets the active balance of the protocol
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) debt = balance;

    // Adds the incremental claimable amount owed to nonstakers to the total claimable amount
    return
      nonStakersClaimableByProtocol[_protocol] +
      (nonStakersPercentage[_protocol] * debt) /
      HUNDRED_PERCENT;
  }

  /// @notice View current amount of all premiums that are owed to stakers
  /// @return Premiums claimable
  /// @dev Will increase every block
  /// @dev base + (now - last_settled) * ps
  function claimablePremiums() public view override returns (uint256) {
    // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)
    return
      lastClaimablePremiumsForStakers +
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
  }

  /// @notice View seconds of coverage left for `_protocol` before it runs out of active balance
  /// @param _protocol Protocol identifier
  /// @return Seconds of coverage left
  function secondsOfCoverageLeft(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _secondsOfCoverageLeft(_protocol);
  }

  // Helper function to return seconds of coverage left for a protocol
  // Gets the current active balance of the protocol and divides by the premium per second for the protocol
  function _secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {
    uint256 premium = premiums_[_protocol];
    if (premium == 0) return 0;
    return _activeBalance(_protocol) / premium;
  }

  /// @notice View current active balance of covered protocol
  /// @param _protocol Protocol identifier
  /// @return Active balance
  /// @dev Accrued debt is subtracted from the stored active balance
  function activeBalance(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _activeBalance(_protocol);
  }

  // Helper function to calc the active balance of a protocol at current time
  function _activeBalance(bytes32 _protocol) internal view returns (uint256) {
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) return 0;
    return balance - debt;
  }

  //
  // State methods
  //

  /// @notice Helps set the premium per second for an individual protocol
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function
  function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)
    internal
    returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)
  {
    // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers
    // Also updates the last accounted timestamp for this protocol
    // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings
    // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol
    nonStakerPercentage = _settleProtocolDebt(_protocol);
    // Stores the old premium before it gets updated
    oldPremiumPerSecond = premiums_[_protocol];

    if (oldPremiumPerSecond != _premium) {
      // Sets the protocol's premium per second to the new value
      premiums_[_protocol] = _premium;
      emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium);
    }
    // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing
    // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes
    // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point
    // Where arbs would no longer be incentivized to remove the protocol
    // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems
    if (_premium != 0 && _secondsOfCoverageLeft(_protocol) < MIN_SECONDS_OF_COVERAGE) {
      revert InsufficientBalance(_protocol);
    }
  }

  /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {
    // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings
    (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
      _protocol,
      _premium
    );
    // Settling the total amount of premiums owed to stakers before a new premium per second gets set
    _settleTotalDebt();
    // This calculates the new global premium per second that gets paid to stakers
    // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      oldPremiumPerSecond,
      _premium,
      nonStakerPercentage,
      nonStakerPercentage,
      allPremiumsPerSecToStakers
    );
  }

  // Internal function to set a new protocolAgent for a specific protocol
  // _oldAgent is only included as part of emitting an event
  function _setProtocolAgent(
    bytes32 _protocol,
    address _oldAgent,
    address _protocolAgent
  ) internal {
    protocolAgent_[_protocol] = _protocolAgent;
    emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);
  }

  // Subtracts the accrued debt from a protocol's active balance
  // Credits the amount that can be claimed by nonstakers for this protocol
  // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings
  // Most of this function is dealing with an edge case related to a protocol not being removed by arbs
  function _settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {
    // This calcs the accrued debt of the protocol since it was last updated
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // This pulls the percentage that is sent to nonstakers
    _nonStakerPercentage = nonStakersPercentage[_protocol];
    // In case the protocol has accrued debt, this code block will ensure the debt is settled properly
    if (debt != 0) {
      // Pulls the stored active balance of the protocol
      uint256 balance = activeBalances[_protocol];
      // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance
      // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point
      // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage
      // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up
      if (debt > balance) {
        // This error amount represents the magnitude of the mistake
        uint256 error = debt - balance;
        // Gets the latest value of claimable premiums for stakers
        _settleTotalDebt();
        // @note to production, set premium first to zero before solving accounting issue.
        // otherwise the accounting error keeps increasing
        uint256 lastClaimablePremiumsForStakers_ = lastClaimablePremiumsForStakers;

        // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%
        uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /
          HUNDRED_PERCENT;

        // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short
        uint256 insufficientTokens;

        // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally
        // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error
        // This first line can be true if claimPremiumsForStakers() has been called and
        // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be >0 still
        if (claimablePremiumError > lastClaimablePremiumsForStakers_) {
          insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;
          lastClaimablePremiumsForStakers = 0;
        } else {
          // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums
          // By the amount that was added in error (error) and insufficientTokens = 0
          lastClaimablePremiumsForStakers =
            lastClaimablePremiumsForStakers_ -
            claimablePremiumError;
        }

        // If two events are thrown, the values need to be summed up for the actual state.
        // This means an error of this type will continue until it is handled
        emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);
        // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case
        debt = balance;
      }
      // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance
      activeBalances[_protocol] = balance - debt;
      // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol
      nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT;
    }
    // Updates the last accounted timestamp for this protocol
    lastAccountedEachProtocol[_protocol] = block.timestamp;
  }

  // Multiplies the total premium per second * number of seconds since the last global accounting update
  // And adds it to the total claimable amount for stakers
  function _settleTotalDebt() internal {
    lastClaimablePremiumsForStakers +=
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
    lastAccountedGlobal = block.timestamp;
  }

  // Calculates the global premium per second for stakers
  // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers
  // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones
  function _calcGlobalPremiumPerSecForStakers(
    uint256 _premiumOld,
    uint256 _premiumNew,
    uint256 _nonStakerPercentageOld,
    uint256 _nonStakerPercentageNew,
    uint256 _inMemAllPremiumsPerSecToStakers
  ) internal pure returns (uint256) {
    return
      _inMemAllPremiumsPerSecToStakers +
      ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /
      HUNDRED_PERCENT -
      ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /
      HUNDRED_PERCENT;
  }

  // Helper function to remove and clean up a protocol from Sherlock
  // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made
  function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {
    // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol
    _setSingleAndGlobalProtocolPremium(_protocol, 0);

    // Grabs the protocol's active balance
    uint256 balance = activeBalances[_protocol];

    // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent
    if (balance != 0) {
      delete activeBalances[_protocol];
      token.safeTransfer(_agent, balance);

      emit ProtocolBalanceWithdrawn(_protocol, balance);
    }

    // Sets the protocol agent to zero address (as part of clean up)
    _setProtocolAgent(_protocol, _agent, address(0));

    // Cleans up other mappings for this protocol
    delete nonStakersPercentage[_protocol];
    delete lastAccountedEachProtocol[_protocol];
    // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above

    // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol
    removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;

    // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed
    // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked
    removedProtocolAgent[_protocol] = _agent;

    emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0));
    emit ProtocolRemoved(_protocol);
  }

  /// @notice Sets the minimum active balance before an arb can remove a protocol
  /// @param _minActiveBalance Minimum balance needed (in USDC)
  /// @dev Only gov
  function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {
    // New value cannot be the same as current value
    if (minActiveBalance == _minActiveBalance) revert InvalidArgument();
    // Can't set a value that is too high to be reasonable
    if (_minActiveBalance >= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions();

    emit MinBalance(minActiveBalance, _minActiveBalance);
    minActiveBalance = _minActiveBalance;
  }

  // This function allows the nonstakers role to claim tokens owed to them by a specific protocol
  /// @notice Choose an `_amount` of tokens that nonstakers (`_receiver` address) will receive from `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens
  /// @param _receiver Address to receive tokens
  /// @dev Only callable by nonstakers role
  function nonStakersClaim(
    bytes32 _protocol,
    uint256 _amount,
    address _receiver
  ) external override whenNotPaused {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_amount == uint256(0)) revert ZeroArgument();
    if (_receiver == address(0)) revert ZeroArgument();
    // Only the nonstakers role (multisig or contract) can pull the funds
    if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized();

    // Call can't be executed on protocol that is removed
    if (protocolAgent_[_protocol] != address(0)) {
      // Updates the amount that nonstakers can claim from this protocol
      _settleProtocolDebt(_protocol);
    }

    // Sets balance to the amount that is claimable by nonstakers for this specific protocol
    uint256 balance = nonStakersClaimableByProtocol[_protocol];
    // If the amount requested is more than what's owed to nonstakers, revert
    if (_amount > balance) revert InsufficientBalance(_protocol);

    // Sets the claimable amount to whatever is left over after this amount is pulled
    nonStakersClaimableByProtocol[_protocol] = balance - _amount;
    // Transfers the amount requested to the `_receiver` address
    token.safeTransfer(_receiver, _amount);
  }

  // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)
  /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address
  /// @dev Callable by everyone
  /// @dev Funds will be transferred to Sherlock core contract
  function claimPremiumsForStakers() external override whenNotPaused {
    // Gets address of core Sherlock contract
    address sherlock = address(sherlockCore);
    // Revert if core Sherlock contract not initialized yet
    if (sherlock == address(0)) revert InvalidConditions();

    // claimablePremiums is different from _settleTotalDebt() because it does not change state
    // Retrieves current amount of all premiums that are owed to stakers
    uint256 amount = claimablePremiums();

    // Transfers all the premiums owed to stakers to the Sherlock core contract
    if (amount != 0) {
      // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out
      lastClaimablePremiumsForStakers = 0;
      lastAccountedGlobal = block.timestamp;
      token.safeTransfer(sherlock, amount);
    }
  }

  // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts
  /// @param _protocol Protocol identifier
  /// @return current and previous are the current and previous coverage amounts for this protocol
  // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)
  function coverageAmounts(bytes32 _protocol)
    external
    view
    override
    returns (uint256 current, uint256 previous)
  {
    // Checks to see if the protocol has an active protocolAgent (protocol not removed)
    // OR checks to see if the removed protocol is still within the claim window
    // If so, gives the current and previous coverage, otherwise throws an error
    if (
      protocolAgent_[_protocol] != address(0) ||
      block.timestamp <= removedProtocolClaimDeadline[_protocol]
    ) {
      return (currentCoverage[_protocol], previousCoverage[_protocol]);
    }

    revert ProtocolNotExists(_protocol);
  }

  /// @notice Add a new protocol to Sherlock
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Address able to submit a claim on behalf of the protocol
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Adding a protocol allows the `_protocolAgent` to submit a claim
  /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point
  /// @dev `_nonStakers` is scaled by 10**18
  /// @dev Only callable by governance
  function protocolAdd(
    bytes32 _protocol,
    address _protocolAgent,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) external override onlyOwner {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Checks to make sure the protocol doesn't exist already
    if (protocolAgent_[_protocol] != address(0)) revert InvalidConditions();

    // Updates the protocol agent and passes in the old agent which is 0 address in this case
    _setProtocolAgent(_protocol, address(0), _protocolAgent);

    // Delete mappings that are potentially non default values
    // From previous time protocol was added/removed
    delete removedProtocolClaimDeadline[_protocol];
    delete removedProtocolAgent[_protocol];
    delete currentCoverage[_protocol];
    delete previousCoverage[_protocol];

    emit ProtocolAdded(_protocol);

    // Most of the logic for actually adding a protocol in this function
    protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Update info regarding a protocol
  /// @param _protocol Protocol identifier
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Only callable by governance
  /// @dev `_nonStakers` can be 0
  function protocolUpdate(
    bytes32 _protocol,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) public override onlyOwner {
    if (_coverage == bytes32(0)) revert ZeroArgument();
    if (_nonStakers > HUNDRED_PERCENT) revert InvalidArgument();
    if (_coverageAmount == uint256(0)) revert ZeroArgument();

    // Checks to make sure the protocol has been assigned a protocol agent
    _verifyProtocolExists(_protocol);

    // Subtracts the accrued debt from a protocol's active balance (if any)
    // Updates the amount that can be claimed by nonstakers
    _settleProtocolDebt(_protocol);

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    // Gets the premium per second for this protocol
    uint256 premium = premiums_[_protocol];

    // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be)
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      premium,
      premium,
      nonStakersPercentage[_protocol],
      _nonStakers,
      allPremiumsPerSecToStakers
    );

    // Updates the stored value of percentage of premiums that go to nonstakers
    nonStakersPercentage[_protocol] = _nonStakers;

    // Updates previous coverage and current coverage amounts
    previousCoverage[_protocol] = currentCoverage[_protocol];
    currentCoverage[_protocol] = _coverageAmount;

    emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Remove a protocol from coverage
  /// @param _protocol Protocol identifier
  /// @dev Before removing a protocol the premium must be 0
  /// @dev Removing a protocol basically stops the `_protocolAgent` from being active (can still submit claims until claim deadline though)
  /// @dev Pays off debt + sends remaining balance to protocol agent
  /// @dev This call should be subject to a timelock
  /// @dev Only callable by governance
  function protocolRemove(bytes32 _protocol) external override onlyOwner {
    // checks to make sure the protocol actually has a protocol agent
    address agent = _verifyProtocolExists(_protocol);

    // Removes a protocol from Sherlock and cleans up its data
    // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made
    _forceRemoveProtocol(_protocol, agent);
  }

  /// @notice Remove a protocol with insufficient active balance
  /// @param _protocol Protocol identifier
  // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function
  function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {
    address agent = _verifyProtocolExists(_protocol);

    // Gets the latest value of the active balance at this protocol
    _settleProtocolDebt(_protocol);
    // Sets latest value of active balance to remainingBalance variable
    uint256 remainingBalance = activeBalances[_protocol];

    // This means the protocol still has adequate active balance and thus cannot be removed
    if (remainingBalance >= minActiveBalance) revert InvalidConditions();

    // Sets the protocol's active balance to 0
    delete activeBalances[_protocol];
    // Removes the protocol from coverage
    _forceRemoveProtocol(_protocol, agent);

    if (remainingBalance != 0) {
      // sends the remaining balance to msg.sender
      token.safeTransfer(msg.sender, remainingBalance);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);
  }

  /// @notice Calculate if arb is possible and what the reward would be
  /// @param _protocol Protocol identifier
  /// @return arbAmount Amount reward for arbing
  /// @return able Indicator if arb call is even possible
  /// @dev Doesn't subtract the current protocol debt from the active balance
  function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)
    internal
    view
    returns (uint256 arbAmount, bool able)
  {
    uint256 secondsLeft = _secondsOfCoverageLeft(_protocol);

    // If arb is not possible return false
    if (secondsLeft >= MIN_SECONDS_OF_COVERAGE) return (0, false);

    // This percentage scales over time
    // Reaches 100% on 0 seconds of coverage left
    uint256 percentageScaled = HUNDRED_PERCENT -
      (secondsLeft * HUNDRED_PERCENT) /
      MIN_SECONDS_OF_COVERAGE;

    able = true;
    arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;
  }

  /// @notice Removes a protocol with insufficent seconds of coverage left
  /// @param _protocol Protocol identifier
  // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second
  function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {
    // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings
    address agent = _verifyProtocolExists(_protocol);

    // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance()
    // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance()
    // But when removing based on seconds of coverage left, the remainingBalance could still be quite large
    // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance
    // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%)
    _settleProtocolDebt(_protocol);
    (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol);
    if (able == false) revert InvalidConditions();

    if (arbAmount != 0) {
      // subtracts the amount that will be paid to the arb from the active balance
      activeBalances[_protocol] -= arbAmount;
    }

    // Removes the protocol from coverage
    // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above
    _forceRemoveProtocol(_protocol, agent);

    // Done after removing protocol to mitigate reentrency pattern
    // (In case token allows callback)
    if (arbAmount != 0) {
      token.safeTransfer(msg.sender, arbAmount);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);
  }

  /// @notice Set premium of `_protocol` to `_premium`
  /// @param _protocol Protocol identifier
  /// @param _premium Amount of premium `_protocol` pays per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {
    // Checks to see if protocol has a protocol agent
    _verifyProtocolExists(_protocol);

    // Updates individual protocol's premium and allPremiumsPerSecToStakers
    _setSingleAndGlobalProtocolPremium(_protocol, _premium);
  }

  /// @notice Set premium of multiple protocols
  /// @param _protocol Array of protocol identifiers
  /// @param _premium Array of premium amounts protocols pay per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)
    external
    override
    onlyOwner
  {
    // Checks to make sure there are an equal amount of entries in each array
    if (_protocol.length != _premium.length) revert UnequalArrayLength();
    if (_protocol.length == 0) revert InvalidArgument();

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;

    // Loops through the array of protocols and checks to make sure each has a protocol agent assigned
    for (uint256 i; i < _protocol.length; i++) {
      _verifyProtocolExists(_protocol[i]);

      // Sets the protocol premium for that specific protocol
      // Function returns the old premium and nonStakerPercentage for that specific protocol
      (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
        _protocol[i],
        _premium[i]
      );

      // Calculates the new global premium which adds up all premiums paid by all protocols
      allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(
        oldPremiumPerSecond,
        _premium[i],
        nonStakerPercentage,
        nonStakerPercentage,
        allPremiumsPerSecToStakers_
      );
    }

    // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value
    allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;
  }

  // This is how protocols pay for coverage by increasing their active balance
  /// @notice Deposits `_amount` of token to the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to deposit
  /// @dev Approval should be made before calling
  function depositToActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    _verifyProtocolExists(_protocol);

    // Transfers _amount to this contract
    token.safeTransferFrom(msg.sender, address(this), _amount);
    // Increases the active balance of the protocol by _amount
    activeBalances[_protocol] += _amount;

    emit ProtocolBalanceDeposited(_protocol, _amount);
  }

  // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)
  // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)
  /// @notice Withdraws `_amount` of token from the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to withdraw
  /// @dev Only protocol agent is able to withdraw
  /// @dev Balance can be withdrawn up until 7 days worth of active balance
  function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    // Only the protocol agent can call this function
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Updates the active balance of the protocol
    _settleProtocolDebt(_protocol);

    // Sets currentBalance to the active balance of the protocol
    uint256 currentBalance = activeBalances[_protocol];
    // Reverts if trying to withdraw more than the active balance
    if (_amount > currentBalance) revert InsufficientBalance(_protocol);

    // Removes the _amount to be withdrawn from the active balance
    activeBalances[_protocol] = currentBalance - _amount;
    // Reverts if a protocol has less than 7 days worth of active balance left
    if (_secondsOfCoverageLeft(_protocol) < MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);

    // Transfers the amount to the msg.sender (protocol agent)
    token.safeTransfer(msg.sender, _amount);
    emit ProtocolBalanceWithdrawn(_protocol, _amount);
  }

  /// @notice Transfer protocol agent role
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Account able to submit a claim on behalf of the protocol
  /// @dev Only the active protocolAgent is able to transfer the role
  function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)
    external
    override
    whenNotPaused
  {
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Can't set the new protocol agent to the caller address
    if (msg.sender == _protocolAgent) revert InvalidArgument();
    // Because the caller must be the current protocol agent
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Sets the protocol agent to the new address
    _setProtocolAgent(_protocol, msg.sender, _protocolAgent);
  }

  /// @notice Function used to check if this is the current active protocol manager
  /// @return Boolean indicating it's active
  /// @dev If inactive the owner can pull all ERC20s and ETH
  /// @dev Will be checked by calling the sherlock contract
  function isActive() public view returns (bool) {
    return address(sherlockCore.sherlockProtocolManager()) == address(this);
  }

  // Only contract owner can call this
  // Sends all specified tokens in this contract to the receiver's address (as well as ETH)
  function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {
    if (_receiver == address(0)) revert ZeroArgument();
    // This contract must NOT be the current assigned protocol manager contract
    if (isActive()) revert InvalidConditions();
    // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH
    _sweep(_receiver, _extraTokens);
  }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-25-08 10:59:21 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-25-08 10:59:21 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 9206
completion_tokens: 798
total_tokens: 10004
cost: $-1.000000


[2024-25-08 10:59:21 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import './Manager.sol';
import '../interfaces/managers/ISherlockProtocolManager.sol';

/// @title Sherlock core interface for protocols
/// @author Evert Kors
// This is the contract that manages covered protocols

contract SherlockProtocolManager is ISherlockProtocolManager, Manager {
  using SafeERC20 for IERC20;

  // Represents the token that protocols pay with (currently USDC)
  IERC20 public immutable token;

  // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed
  uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc

  // A removed protocol is still able to make a claim for this amount of time after its removal
  uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days;

  // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance
  uint256 public constant MIN_SECONDS_LEFT = 7 days;

  // Convenient for percentage calculations
  uint256 internal constant HUNDRED_PERCENT = 10**18;

  // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage
  // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying
  uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours;

  // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)
  mapping(bytes32 => address) internal protocolAgent_;

  // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)
  mapping(bytes32 => uint256) internal nonStakersPercentage;

  // The premium per second paid by each protocol is stored in this mapping
  mapping(bytes32 => uint256) internal premiums_;

  // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.
  // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not
  mapping(bytes32 => uint256) internal activeBalances;

  // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol
  mapping(bytes32 => uint256) internal lastAccountedEachProtocol;

  // The amount that can be claimed by nonstakers for each protocol
  // We need this value so we can track how much payment is coming from each protocol
  mapping(bytes32 => uint256) internal nonStakersClaimableByProtocol;

  // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)
  uint256 internal lastAccountedGlobal;

  // This is the total amount of premiums paid (per second) by all the covered protocols (added up)
  uint256 internal allPremiumsPerSecToStakers;

  // This is the amount that was claimable by stakers the last time the accounting was run
  // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date
  uint256 internal lastClaimablePremiumsForStakers;

  // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage
  // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)
  uint256 public override minActiveBalance;

  // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)
  mapping(bytes32 => uint256) internal removedProtocolClaimDeadline;

  // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)
  mapping(bytes32 => address) internal removedProtocolAgent;

  // Current amount of coverage (i.e. 20M USDC) for a protocol
  mapping(bytes32 => uint256) internal currentCoverage;

  // Previous amount of coverage for a protocol
  // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount
  mapping(bytes32 => uint256) internal previousCoverage;

  // Setting the token to USDC
  constructor(IERC20 _token) {
    if (address(_token) == address(0)) revert ZeroArgument();
    token = _token;
  }

  // Modifier used to ensure a protocol exists (has been instantiated and not removed)
  modifier protocolExists(bytes32 _protocol) {
    _verifyProtocolExists(_protocol);
    _;
  }

  /// @notice View current protocolAgent of `_protocol`
  /// @param _protocol Protocol identifier
  /// @return Address able to submit claims
  function protocolAgent(bytes32 _protocol) external view override returns (address) {
    address agent = protocolAgent_[_protocol];
    if (agent != address(0)) return agent;

    // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned
    // Note: Old protocol agent will never be address(0)
    if (block.timestamp <= removedProtocolClaimDeadline[_protocol]) {
      return removedProtocolAgent[_protocol];
    }

    // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned
    revert ProtocolNotExists(_protocol);
  }

  // Checks if the protocol exists, then returns the current premium per second being charged
  /// @notice View current premium of protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of premium `_protocol` pays per second
  function premium(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return premiums_[_protocol];
  }

  // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)
  // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)
  function _verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {
    _protocolAgent = protocolAgent_[_protocol];
    if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);
  }

  //
  // View methods
  //

  // Calcs the debt accrued by the protocol since it last had an accounting update
  // This is the amount that needs to be removed from a protocol's active balance
  function _calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {
    return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums_[_protocol];
  }

  /// @notice View the amount nonstakers can claim from this protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of tokens claimable by nonstakers
  /// @dev this reads from a storage variable + (now-lastsettled) * premiums
  // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]
  // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed
  function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {
    // Calcs the debt of a protocol since the last accounting update
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // Gets the active balance of the protocol
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) debt = balance;

    // Adds the incremental claimable amount owed to nonstakers to the total claimable amount
    return
      nonStakersClaimableByProtocol[_protocol] +
      (nonStakersPercentage[_protocol] * debt) /
      HUNDRED_PERCENT;
  }

  /// @notice View current amount of all premiums that are owed to stakers
  /// @return Premiums claimable
  /// @dev Will increase every block
  /// @dev base + (now - last_settled) * ps
  function claimablePremiums() public view override returns (uint256) {
    // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)
    return
      lastClaimablePremiumsForStakers +
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
  }

  /// @notice View seconds of coverage left for `_protocol` before it runs out of active balance
  /// @param _protocol Protocol identifier
  /// @return Seconds of coverage left
  function secondsOfCoverageLeft(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _secondsOfCoverageLeft(_protocol);
  }

  // Helper function to return seconds of coverage left for a protocol
  // Gets the current active balance of the protocol and divides by the premium per second for the protocol
  function _secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {
    uint256 premium = premiums_[_protocol];
    if (premium == 0) return 0;
    return _activeBalance(_protocol) / premium;
  }

  /// @notice View current active balance of covered protocol
  /// @param _protocol Protocol identifier
  /// @return Active balance
  /// @dev Accrued debt is subtracted from the stored active balance
  function activeBalance(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _activeBalance(_protocol);
  }

  // Helper function to calc the active balance of a protocol at current time
  function _activeBalance(bytes32 _protocol) internal view returns (uint256) {
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) return 0;
    return balance - debt;
  }

  //
  // State methods
  //

  /// @notice Helps set the premium per second for an individual protocol
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function
  function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)
    internal
    returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)
  {
    // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers
    // Also updates the last accounted timestamp for this protocol
    // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings
    // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol
    nonStakerPercentage = _settleProtocolDebt(_protocol);
    // Stores the old premium before it gets updated
    oldPremiumPerSecond = premiums_[_protocol];

    if (oldPremiumPerSecond != _premium) {
      // Sets the protocol's premium per second to the new value
      premiums_[_protocol] = _premium;
      emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium);
    }
    // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing
    // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes
    // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point
    // Where arbs would no longer be incentivized to remove the protocol
    // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems
    if (_premium != 0 && _secondsOfCoverageLeft(_protocol) < MIN_SECONDS_OF_COVERAGE) {
      revert InsufficientBalance(_protocol);
    }
  }

  /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {
    // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings
    (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
      _protocol,
      _premium
    );
    // Settling the total amount of premiums owed to stakers before a new premium per second gets set
    _settleTotalDebt();
    // This calculates the new global premium per second that gets paid to stakers
    // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      oldPremiumPerSecond,
      _premium,
      nonStakerPercentage,
      nonStakerPercentage,
      allPremiumsPerSecToStakers
    );
  }

  // Internal function to set a new protocolAgent for a specific protocol
  // _oldAgent is only included as part of emitting an event
  function _setProtocolAgent(
    bytes32 _protocol,
    address _oldAgent,
    address _protocolAgent
  ) internal {
    protocolAgent_[_protocol] = _protocolAgent;
    emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);
  }

  // Subtracts the accrued debt from a protocol's active balance
  // Credits the amount that can be claimed by nonstakers for this protocol
  // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings
  // Most of this function is dealing with an edge case related to a protocol not being removed by arbs
  function _settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {
    // This calcs the accrued debt of the protocol since it was last updated
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // This pulls the percentage that is sent to nonstakers
    _nonStakerPercentage = nonStakersPercentage[_protocol];
    // In case the protocol has accrued debt, this code block will ensure the debt is settled properly
    if (debt != 0) {
      // Pulls the stored active balance of the protocol
      uint256 balance = activeBalances[_protocol];
      // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance
      // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point
      // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage
      // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up
      if (debt > balance) {
        // This error amount represents the magnitude of the mistake
        uint256 error = debt - balance;
        // Gets the latest value of claimable premiums for stakers
        _settleTotalDebt();
        // @note to production, set premium first to zero before solving accounting issue.
        // otherwise the accounting error keeps increasing
        uint256 lastClaimablePremiumsForStakers_ = lastClaimablePremiumsForStakers;

        // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%
        uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /
          HUNDRED_PERCENT;

        // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short
        uint256 insufficientTokens;

        // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally
        // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error
        // This first line can be true if claimPremiumsForStakers() has been called and
        // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be >0 still
        if (claimablePremiumError > lastClaimablePremiumsForStakers_) {
          insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;
          lastClaimablePremiumsForStakers = 0;
        } else {
          // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums
          // By the amount that was added in error (error) and insufficientTokens = 0
          lastClaimablePremiumsForStakers =
            lastClaimablePremiumsForStakers_ -
            claimablePremiumError;
        }

        // If two events are thrown, the values need to be summed up for the actual state.
        // This means an error of this type will continue until it is handled
        emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);
        // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case
        debt = balance;
      }
      // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance
      activeBalances[_protocol] = balance - debt;
      // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol
      nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT;
    }
    // Updates the last accounted timestamp for this protocol
    lastAccountedEachProtocol[_protocol] = block.timestamp;
  }

  // Multiplies the total premium per second * number of seconds since the last global accounting update
  // And adds it to the total claimable amount for stakers
  function _settleTotalDebt() internal {
    lastClaimablePremiumsForStakers +=
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
    lastAccountedGlobal = block.timestamp;
  }

  // Calculates the global premium per second for stakers
  // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers
  // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones
  function _calcGlobalPremiumPerSecForStakers(
    uint256 _premiumOld,
    uint256 _premiumNew,
    uint256 _nonStakerPercentageOld,
    uint256 _nonStakerPercentageNew,
    uint256 _inMemAllPremiumsPerSecToStakers
  ) internal pure returns (uint256) {
    return
      _inMemAllPremiumsPerSecToStakers +
      ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /
      HUNDRED_PERCENT -
      ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /
      HUNDRED_PERCENT;
  }

  // Helper function to remove and clean up a protocol from Sherlock
  // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made
  function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {
    // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol
    _setSingleAndGlobalProtocolPremium(_protocol, 0);

    // Grabs the protocol's active balance
    uint256 balance = activeBalances[_protocol];

    // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent
    if (balance != 0) {
      delete activeBalances[_protocol];
      token.safeTransfer(_agent, balance);

      emit ProtocolBalanceWithdrawn(_protocol, balance);
    }

    // Sets the protocol agent to zero address (as part of clean up)
    _setProtocolAgent(_protocol, _agent, address(0));

    // Cleans up other mappings for this protocol
    delete nonStakersPercentage[_protocol];
    delete lastAccountedEachProtocol[_protocol];
    // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above

    // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol
    removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;

    // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed
    // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked
    removedProtocolAgent[_protocol] = _agent;

    emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0));
    emit ProtocolRemoved(_protocol);
  }

  /// @notice Sets the minimum active balance before an arb can remove a protocol
  /// @param _minActiveBalance Minimum balance needed (in USDC)
  /// @dev Only gov
  function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {
    // New value cannot be the same as current value
    if (minActiveBalance == _minActiveBalance) revert InvalidArgument();
    // Can't set a value that is too high to be reasonable
    if (_minActiveBalance >= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions();

    emit MinBalance(minActiveBalance, _minActiveBalance);
    minActiveBalance = _minActiveBalance;
  }

  // This function allows the nonstakers role to claim tokens owed to them by a specific protocol
  /// @notice Choose an `_amount` of tokens that nonstakers (`_receiver` address) will receive from `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens
  /// @param _receiver Address to receive tokens
  /// @dev Only callable by nonstakers role
  function nonStakersClaim(
    bytes32 _protocol,
    uint256 _amount,
    address _receiver
  ) external override whenNotPaused {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_amount == uint256(0)) revert ZeroArgument();
    if (_receiver == address(0)) revert ZeroArgument();
    // Only the nonstakers role (multisig or contract) can pull the funds
    if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized();

    // Call can't be executed on protocol that is removed
    if (protocolAgent_[_protocol] != address(0)) {
      // Updates the amount that nonstakers can claim from this protocol
      _settleProtocolDebt(_protocol);
    }

    // Sets balance to the amount that is claimable by nonstakers for this specific protocol
    uint256 balance = nonStakersClaimableByProtocol[_protocol];
    // If the amount requested is more than what's owed to nonstakers, revert
    if (_amount > balance) revert InsufficientBalance(_protocol);

    // Sets the claimable amount to whatever is left over after this amount is pulled
    nonStakersClaimableByProtocol[_protocol] = balance - _amount;
    // Transfers the amount requested to the `_receiver` address
    token.safeTransfer(_receiver, _amount);
  }

  // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)
  /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address
  /// @dev Callable by everyone
  /// @dev Funds will be transferred to Sherlock core contract
  function claimPremiumsForStakers() external override whenNotPaused {
    // Gets address of core Sherlock contract
    address sherlock = address(sherlockCore);
    // Revert if core Sherlock contract not initialized yet
    if (sherlock == address(0)) revert InvalidConditions();

    // claimablePremiums is different from _settleTotalDebt() because it does not change state
    // Retrieves current amount of all premiums that are owed to stakers
    uint256 amount = claimablePremiums();

    // Transfers all the premiums owed to stakers to the Sherlock core contract
    if (amount != 0) {
      // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out
      lastClaimablePremiumsForStakers = 0;
      lastAccountedGlobal = block.timestamp;
      token.safeTransfer(sherlock, amount);
    }
  }

  // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts
  /// @param _protocol Protocol identifier
  /// @return current and previous are the current and previous coverage amounts for this protocol
  // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)
  function coverageAmounts(bytes32 _protocol)
    external
    view
    override
    returns (uint256 current, uint256 previous)
  {
    // Checks to see if the protocol has an active protocolAgent (protocol not removed)
    // OR checks to see if the removed protocol is still within the claim window
    // If so, gives the current and previous coverage, otherwise throws an error
    if (
      protocolAgent_[_protocol] != address(0) ||
      block.timestamp <= removedProtocolClaimDeadline[_protocol]
    ) {
      return (currentCoverage[_protocol], previousCoverage[_protocol]);
    }

    revert ProtocolNotExists(_protocol);
  }

  /// @notice Add a new protocol to Sherlock
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Address able to submit a claim on behalf of the protocol
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Adding a protocol allows the `_protocolAgent` to submit a claim
  /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point
  /// @dev `_nonStakers` is scaled by 10**18
  /// @dev Only callable by governance
  function protocolAdd(
    bytes32 _protocol,
    address _protocolAgent,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) external override onlyOwner {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Checks to make sure the protocol doesn't exist already
    if (protocolAgent_[_protocol] != address(0)) revert InvalidConditions();

    // Updates the protocol agent and passes in the old agent which is 0 address in this case
    _setProtocolAgent(_protocol, address(0), _protocolAgent);

    // Delete mappings that are potentially non default values
    // From previous time protocol was added/removed
    delete removedProtocolClaimDeadline[_protocol];
    delete removedProtocolAgent[_protocol];
    delete currentCoverage[_protocol];
    delete previousCoverage[_protocol];

    emit ProtocolAdded(_protocol);

    // Most of the logic for actually adding a protocol in this function
    protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Update info regarding a protocol
  /// @param _protocol Protocol identifier
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Only callable by governance
  /// @dev `_nonStakers` can be 0
  function protocolUpdate(
    bytes32 _protocol,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) public override onlyOwner {
    if (_coverage == bytes32(0)) revert ZeroArgument();
    if (_nonStakers > HUNDRED_PERCENT) revert InvalidArgument();
    if (_coverageAmount == uint256(0)) revert ZeroArgument();

    // Checks to make sure the protocol has been assigned a protocol agent
    _verifyProtocolExists(_protocol);

    // Subtracts the accrued debt from a protocol's active balance (if any)
    // Updates the amount that can be claimed by nonstakers
    _settleProtocolDebt(_protocol);

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    // Gets the premium per second for this protocol
    uint256 premium = premiums_[_protocol];

    // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be)
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      premium,
      premium,
      nonStakersPercentage[_protocol],
      _nonStakers,
      allPremiumsPerSecToStakers
    );

    // Updates the stored value of percentage of premiums that go to nonstakers
    nonStakersPercentage[_protocol] = _nonStakers;

    // Updates previous coverage and current coverage amounts
    previousCoverage[_protocol] = currentCoverage[_protocol];
    currentCoverage[_protocol] = _coverageAmount;

    emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Remove a protocol from coverage
  /// @param _protocol Protocol identifier
  /// @dev Before removing a protocol the premium must be 0
  /// @dev Removing a protocol basically stops the `_protocolAgent` from being active (can still submit claims until claim deadline though)
  /// @dev Pays off debt + sends remaining balance to protocol agent
  /// @dev This call should be subject to a timelock
  /// @dev Only callable by governance
  function protocolRemove(bytes32 _protocol) external override onlyOwner {
    // checks to make sure the protocol actually has a protocol agent
    address agent = _verifyProtocolExists(_protocol);

    // Removes a protocol from Sherlock and cleans up its data
    // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made
    _forceRemoveProtocol(_protocol, agent);
  }

  /// @notice Remove a protocol with insufficient active balance
  /// @param _protocol Protocol identifier
  // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function
  function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {
    address agent = _verifyProtocolExists(_protocol);

    // Gets the latest value of the active balance at this protocol
    _settleProtocolDebt(_protocol);
    // Sets latest value of active balance to remainingBalance variable
    uint256 remainingBalance = activeBalances[_protocol];

    // This means the protocol still has adequate active balance and thus cannot be removed
    if (remainingBalance >= minActiveBalance) revert InvalidConditions();

    // Sets the protocol's active balance to 0
    delete activeBalances[_protocol];
    // Removes the protocol from coverage
    _forceRemoveProtocol(_protocol, agent);

    if (remainingBalance != 0) {
      // sends the remaining balance to msg.sender
      token.safeTransfer(msg.sender, remainingBalance);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);
  }

  /// @notice Calculate if arb is possible and what the reward would be
  /// @param _protocol Protocol identifier
  /// @return arbAmount Amount reward for arbing
  /// @return able Indicator if arb call is even possible
  /// @dev Doesn't subtract the current protocol debt from the active balance
  function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)
    internal
    view
    returns (uint256 arbAmount, bool able)
  {
    uint256 secondsLeft = _secondsOfCoverageLeft(_protocol);

    // If arb is not possible return false
    if (secondsLeft >= MIN_SECONDS_OF_COVERAGE) return (0, false);

    // This percentage scales over time
    // Reaches 100% on 0 seconds of coverage left
    uint256 percentageScaled = HUNDRED_PERCENT -
      (secondsLeft * HUNDRED_PERCENT) /
      MIN_SECONDS_OF_COVERAGE;

    able = true;
    arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;
  }

  /// @notice Removes a protocol with insufficent seconds of coverage left
  /// @param _protocol Protocol identifier
  // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second
  function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {
    // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings
    address agent = _verifyProtocolExists(_protocol);

    // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance()
    // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance()
    // But when removing based on seconds of coverage left, the remainingBalance could still be quite large
    // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance
    // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%)
    _settleProtocolDebt(_protocol);
    (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol);
    if (able == false) revert InvalidConditions();

    if (arbAmount != 0) {
      // subtracts the amount that will be paid to the arb from the active balance
      activeBalances[_protocol] -= arbAmount;
    }

    // Removes the protocol from coverage
    // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above
    _forceRemoveProtocol(_protocol, agent);

    // Done after removing protocol to mitigate reentrency pattern
    // (In case token allows callback)
    if (arbAmount != 0) {
      token.safeTransfer(msg.sender, arbAmount);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);
  }

  /// @notice Set premium of `_protocol` to `_premium`
  /// @param _protocol Protocol identifier
  /// @param _premium Amount of premium `_protocol` pays per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {
    // Checks to see if protocol has a protocol agent
    _verifyProtocolExists(_protocol);

    // Updates individual protocol's premium and allPremiumsPerSecToStakers
    _setSingleAndGlobalProtocolPremium(_protocol, _premium);
  }

  /// @notice Set premium of multiple protocols
  /// @param _protocol Array of protocol identifiers
  /// @param _premium Array of premium amounts protocols pay per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)
    external
    override
    onlyOwner
  {
    // Checks to make sure there are an equal amount of entries in each array
    if (_protocol.length != _premium.length) revert UnequalArrayLength();
    if (_protocol.length == 0) revert InvalidArgument();

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;

    // Loops through the array of protocols and checks to make sure each has a protocol agent assigned
    for (uint256 i; i < _protocol.length; i++) {
      _verifyProtocolExists(_protocol[i]);

      // Sets the protocol premium for that specific protocol
      // Function returns the old premium and nonStakerPercentage for that specific protocol
      (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
        _protocol[i],
        _premium[i]
      );

      // Calculates the new global premium which adds up all premiums paid by all protocols
      allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(
        oldPremiumPerSecond,
        _premium[i],
        nonStakerPercentage,
        nonStakerPercentage,
        allPremiumsPerSecToStakers_
      );
    }

    // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value
    allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;
  }

  // This is how protocols pay for coverage by increasing their active balance
  /// @notice Deposits `_amount` of token to the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to deposit
  /// @dev Approval should be made before calling
  function depositToActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    _verifyProtocolExists(_protocol);

    // Transfers _amount to this contract
    token.safeTransferFrom(msg.sender, address(this), _amount);
    // Increases the active balance of the protocol by _amount
    activeBalances[_protocol] += _amount;

    emit ProtocolBalanceDeposited(_protocol, _amount);
  }

  // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)
  // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)
  /// @notice Withdraws `_amount` of token from the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to withdraw
  /// @dev Only protocol agent is able to withdraw
  /// @dev Balance can be withdrawn up until 7 days worth of active balance
  function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    // Only the protocol agent can call this function
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Updates the active balance of the protocol
    _settleProtocolDebt(_protocol);

    // Sets currentBalance to the active balance of the protocol
    uint256 currentBalance = activeBalances[_protocol];
    // Reverts if trying to withdraw more than the active balance
    if (_amount > currentBalance) revert InsufficientBalance(_protocol);

    // Removes the _amount to be withdrawn from the active balance
    activeBalances[_protocol] = currentBalance - _amount;
    // Reverts if a protocol has less than 7 days worth of active balance left
    if (_secondsOfCoverageLeft(_protocol) < MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);

    // Transfers the amount to the msg.sender (protocol agent)
    token.safeTransfer(msg.sender, _amount);
    emit ProtocolBalanceWithdrawn(_protocol, _amount);
  }

  /// @notice Transfer protocol agent role
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Account able to submit a claim on behalf of the protocol
  /// @dev Only the active protocolAgent is able to transfer the role
  function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)
    external
    override
    whenNotPaused
  {
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Can't set the new protocol agent to the caller address
    if (msg.sender == _protocolAgent) revert InvalidArgument();
    // Because the caller must be the current protocol agent
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Sets the protocol agent to the new address
    _setProtocolAgent(_protocol, msg.sender, _protocolAgent);
  }

  /// @notice Function used to check if this is the current active protocol manager
  /// @return Boolean indicating it's active
  /// @dev If inactive the owner can pull all ERC20s and ETH
  /// @dev Will be checked by calling the sherlock contract
  function isActive() public view returns (bool) {
    return address(sherlockCore.sherlockProtocolManager()) == address(this);
  }

  // Only contract owner can call this
  // Sends all specified tokens in this contract to the receiver's address (as well as ETH)
  function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {
    if (_receiver == address(0)) revert ZeroArgument();
    // This contract must NOT be the current assigned protocol manager contract
    if (isActive()) revert InvalidConditions();
    // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH
    _sweep(_receiver, _extraTokens);
  }
}
.]

Based on the provided smart contract code for the `SherlockProtocolManager`, here is a succinct summary of the identified security vulnerabilities and issues:

### Summary of Security Vulnerabilities

1. **Reentrancy Risk**: 
   - The contract uses external calls to transfer tokens (e.g., `token.safeTransfer`). If the token contract has a fallback function that calls back into the `SherlockProtocolManager`, it could lead to reentrancy attacks, especially in functions that modify state before transferring tokens.

2. **Arithmetic Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow and underflow checks, it is essential to ensure that all arithmetic operations are safe, especially in calculations involving active balances and premiums.

3. **Access Control Issues**:
   - The `onlyOwner` modifier is used extensively, but there is no mechanism to ensure that the owner cannot be locked out or that ownership can be transferred securely. If the owner loses access, it could lead to a situation where no one can manage the contract.

4. **Protocol Removal Logic**:
   - The logic for removing protocols does not adequately handle scenarios where a protocol might be removed while still having outstanding claims or balances. This could lead to funds being locked or lost.

5. **Claimable Premiums Calculation**:
   - The calculation of claimable premiums relies on timestamps and could be manipulated if the block timestamp is not reliable. This could lead to incorrect calculations of what is owed to stakers.

6. **Insufficient Input Validation**:
   - Functions like `protocolAdd`, `protocolUpdate`, and others do not have comprehensive checks for all possible edge cases, such as ensuring that the protocol does not already exist before adding it.

7. **Gas Limit Issues**:
   - The contract has several loops and mappings that could lead to high gas costs, especially in functions that update multiple protocols at once. This could lead to transaction failures due to exceeding the block gas limit.

8. **Potential for Locked Funds**:
   - The contract allows for protocols to withdraw their active balance, but if the withdrawal conditions are not met (e.g., not enough coverage left), funds could become locked indefinitely.

### Comprehensive Analysis Report

The `SherlockProtocolManager` contract is designed to manage coverage for protocols, but it has several security vulnerabilities that need to be addressed to ensure the safety of funds and the integrity of operations. 

1. **Reentrancy Protection**: Implement checks-effects-interactions pattern to prevent reentrancy attacks. Consider using a reentrancy guard modifier.

2. **Robust Arithmetic Operations**: While Solidity 0.8.x provides overflow checks, ensure that all calculations are logically sound and consider using libraries like OpenZeppelin's SafeMath for clarity.

3. **Enhanced Access Control**: Implement a multi-signature wallet for ownership or a time-lock mechanism for critical functions to prevent unilateral actions by a single owner.

4. **Protocol Management Logic**: Review and enhance the logic for protocol removal to ensure that all claims and balances are properly handled before a protocol is removed.

5. **Timestamp Manipulation Safeguards**: Consider using block numbers or other mechanisms to ensure that calculations based on time are not susceptible to manipulation.

6. **Input Validation**: Strengthen input validation across all functions to ensure that all edge cases are covered and that invalid states cannot be created.

7. **Gas Optimization**: Review functions for gas efficiency, especially those that involve loops or multiple state changes, to avoid transaction failures.

8. **Withdrawal Conditions**: Clearly define and enforce conditions under which funds can be withdrawn to prevent locking of funds indefinitely.

In conclusion, while the `SherlockProtocolManager` contract has a well-defined purpose, it requires careful attention to security practices to mitigate the identified vulnerabilities. A thorough audit and testing phase should be conducted before deployment to ensure the contract operates as intended without exposing users to unnecessary risks.

[2024-25-08 10:59:21 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for the `SherlockProtocolManager`, here is a succinct summary of the identified security vulnerabilities and issues:

### Summary of Security Vulnerabilities

1. **Reentrancy Risk**: 
   - The contract uses external calls to transfer tokens (e.g., `token.safeTransfer`). If the token contract has a fallback function that calls back into the `SherlockProtocolManager`, it could lead to reentrancy attacks, especially in functions that modify state before transferring tokens.

2. **Arithmetic Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow and underflow checks, it is essential to ensure that all arithmetic operations are safe, especially in calculations involving active balances and premiums.

3. **Access Control Issues**:
   - The `onlyOwner` modifier is used extensively, but there is no mechanism to ensure that the owner cannot be locked out or that ownership can be transferred securely. If the owner loses access, it could lead to a situation where no one can manage the contract.

4. **Protocol Removal Logic**:
   - The logic for removing protocols does not adequately handle scenarios where a protocol might be removed while still having outstanding claims or balances. This could lead to funds being locked or lost.

5. **Claimable Premiums Calculation**:
   - The calculation of claimable premiums relies on timestamps and could be manipulated if the block timestamp is not reliable. This could lead to incorrect calculations of what is owed to stakers.

6. **Insufficient Input Validation**:
   - Functions like `protocolAdd`, `protocolUpdate`, and others do not have comprehensive checks for all possible edge cases, such as ensuring that the protocol does not already exist before adding it.

7. **Gas Limit Issues**:
   - The contract has several loops and mappings that could lead to high gas costs, especially in functions that update multiple protocols at once. This could lead to transaction failures due to exceeding the block gas limit.

8. **Potential for Locked Funds**:
   - The contract allows for protocols to withdraw their active balance, but if the withdrawal conditions are not met (e.g., not enough coverage left), funds could become locked indefinitely.

### Comprehensive Analysis Report

The `SherlockProtocolManager` contract is designed to manage coverage for protocols, but it has several security vulnerabilities that need to be addressed to ensure the safety of funds and the integrity of operations. 

1. **Reentrancy Protection**: Implement checks-effects-interactions pattern to prevent reentrancy attacks. Consider using a reentrancy guard modifier.

2. **Robust Arithmetic Operations**: While Solidity 0.8.x provides overflow checks, ensure that all calculations are logically sound and consider using libraries like OpenZeppelin's SafeMath for clarity.

3. **Enhanced Access Control**: Implement a multi-signature wallet for ownership or a time-lock mechanism for critical functions to prevent unilateral actions by a single owner.

4. **Protocol Management Logic**: Review and enhance the logic for protocol removal to ensure that all claims and balances are properly handled before a protocol is removed.

5. **Timestamp Manipulation Safeguards**: Consider using block numbers or other mechanisms to ensure that calculations based on time are not susceptible to manipulation.

6. **Input Validation**: Strengthen input validation across all functions to ensure that all edge cases are covered and that invalid states cannot be created.

7. **Gas Optimization**: Review functions for gas efficiency, especially those that involve loops or multiple state changes, to avoid transaction failures.

8. **Withdrawal Conditions**: Clearly define and enforce conditions under which funds can be withdrawn to prevent locking of funds indefinitely.

In conclusion, while the `SherlockProtocolManager` contract has a well-defined purpose, it requires careful attention to security practices to mitigate the identified vulnerabilities. A thorough audit and testing phase should be conducted before deployment to ensure the contract operates as intended without exposing users to unnecessary risks.

[2024-25-08 10:59:21 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-25-08 10:59:21 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import './Manager.sol'; import '../interfaces/managers/ISherlockProtocolManager.sol'; /// @title Sherlock core interface for protocols /// @author Evert Kors // This is the contract that manages covered protocols contract SherlockProtocolManager is ISherlockProtocolManager, Manager {   using SafeERC20 for IERC20; // Represents the token that protocols pay with (currently USDC)   IERC20 public immutable token; // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed   uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc // A removed protocol is still able to make a claim for this amount of time after its removal   uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days; // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance   uint256 public constant MIN_SECONDS_LEFT = 7 days; // Convenient for percentage calculations   uint256 internal constant HUNDRED_PERCENT = 10**18; // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage   // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying   uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours; // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)   mapping(bytes32 =&gt; address) internal protocolAgent_; // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)   mapping(bytes32 =&gt; uint256) internal nonStakersPercentage; // The premium per second paid by each protocol is stored in this mapping   mapping(bytes32 =&gt; uint256) internal premiums_; // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.   // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not   mapping(bytes32 =&gt; uint256) internal activeBalances; // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol   mapping(bytes32 =&gt; uint256) internal lastAccountedEachProtocol; // The amount that can be claimed by nonstakers for each protocol   // We need this value so we can track how much payment is coming from each protocol   mapping(bytes32 =&gt; uint256) internal nonStakersClaimableByProtocol; // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)   uint256 internal lastAccountedGlobal; // This is the total amount of premiums paid (per second) by all the covered protocols (added up)   uint256 internal allPremiumsPerSecToStakers; // This is the amount that was claimable by stakers the last time the accounting was run   // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date   uint256 internal lastClaimablePremiumsForStakers; // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage   // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)   uint256 public override minActiveBalance; // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)   mapping(bytes32 =&gt; uint256) internal removedProtocolClaimDeadline; // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)   mapping(bytes32 =&gt; address) internal removedProtocolAgent; // Current amount of coverage (i.e. 20M USDC) for a protocol   mapping(bytes32 =&gt; uint256) internal currentCoverage; // Previous amount of coverage for a protocol   // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount   mapping(bytes32 =&gt; uint256) internal previousCoverage; // Setting the token to USDC   constructor(IERC20 _token) {     if (address(_token) == address(0)) revert ZeroArgument();     token = _token;   } // Modifier used to ensure a protocol exists (has been instantiated and not removed)   modifier protocolExists(bytes32 protocol) {     _verifyProtocolExists(_protocol);     ;   } /// @notice View current protocolAgent of _protocol   /// @param protocol Protocol identifier   /// @return Address able to submit claims   function protocolAgent(bytes32 _protocol) external view override returns (address) {     address agent = protocolAgent[_protocol];     if (agent != address(0)) return agent; // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned // Note: Old protocol agent will never be address(0) if (block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]) {   return removedProtocolAgent[_protocol]; }  // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned revert ProtocolNotExists(_protocol);  } // Checks if the protocol exists, then returns the current premium per second being charged   /// @notice View current premium of protocol   /// @param protocol Protocol identifier   /// @return Amount of premium _protocol pays per second   function premium(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return premiums[_protocol];   } // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)   // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)   function verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {     _protocolAgent = protocolAgent[_protocol];     if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);   } //   // View methods   // // Calcs the debt accrued by the protocol since it last had an accounting update   // This is the amount that needs to be removed from a protocol's active balance   function calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {     return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums[_protocol];   } /// @notice View the amount nonstakers can claim from this protocol   /// @param _protocol Protocol identifier   /// @return Amount of tokens claimable by nonstakers   /// @dev this reads from a storage variable + (now-lastsettled) * premiums   // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]   // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed   function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {     // Calcs the debt of a protocol since the last accounting update     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     // Gets the active balance of the protocol     uint256 balance = activeBalances[_protocol];     // The debt should never be higher than the balance (only happens if the arbitrages fail)     if (debt &gt; balance) debt = balance; // Adds the incremental claimable amount owed to nonstakers to the total claimable amount return   nonStakersClaimableByProtocol[_protocol] +   (nonStakersPercentage[_protocol] * debt) /   HUNDRED_PERCENT;  } /// @notice View current amount of all premiums that are owed to stakers   /// @return Premiums claimable   /// @dev Will increase every block   /// @dev base + (now - last_settled) * ps   function claimablePremiums() public view override returns (uint256) {     // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)     return       lastClaimablePremiumsForStakers +       (block.timestamp - lastAccountedGlobal) *       allPremiumsPerSecToStakers;   } /// @notice View seconds of coverage left for _protocol before it runs out of active balance   /// @param _protocol Protocol identifier   /// @return Seconds of coverage left   function secondsOfCoverageLeft(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return _secondsOfCoverageLeft(_protocol);   } // Helper function to return seconds of coverage left for a protocol   // Gets the current active balance of the protocol and divides by the premium per second for the protocol   function secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {     uint256 premium = premiums[_protocol];     if (premium == 0) return 0;     return _activeBalance(_protocol) / premium;   } /// @notice View current active balance of covered protocol   /// @param _protocol Protocol identifier   /// @return Active balance   /// @dev Accrued debt is subtracted from the stored active balance   function activeBalance(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return _activeBalance(_protocol);   } // Helper function to calc the active balance of a protocol at current time   function _activeBalance(bytes32 _protocol) internal view returns (uint256) {     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     uint256 balance = activeBalances[_protocol];     // The debt should never be higher than the balance (only happens if the arbitrages fail)     if (debt &gt; balance) return 0;     return balance - debt;   } //   // State methods   // /// @notice Helps set the premium per second for an individual protocol   /// @param protocol Protocol identifier   /// @param _premium New premium per second   /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function   function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)     internal     returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)   {     // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers     // Also updates the last accounted timestamp for this protocol     // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings     // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol     nonStakerPercentage = _settleProtocolDebt(_protocol);     // Stores the old premium before it gets updated     oldPremiumPerSecond = premiums[_protocol]; if (oldPremiumPerSecond != _premium) {   // Sets the protocol's premium per second to the new value   premiums_[_protocol] = _premium;   emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium); } // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point // Where arbs would no longer be incentivized to remove the protocol // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems if (_premium != 0 &amp;&amp; _secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_OF_COVERAGE) {   revert InsufficientBalance(_protocol); }  } /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second   /// @param _protocol Protocol identifier   /// @param _premium New premium per second   function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {     // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings     (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(       _protocol,       _premium     );     // Settling the total amount of premiums owed to stakers before a new premium per second gets set     _settleTotalDebt();     // This calculates the new global premium per second that gets paid to stakers     // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function     allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(       oldPremiumPerSecond,       _premium,       nonStakerPercentage,       nonStakerPercentage,       allPremiumsPerSecToStakers     );   } // Internal function to set a new protocolAgent for a specific protocol   // oldAgent is only included as part of emitting an event   function _setProtocolAgent(     bytes32 _protocol,     address _oldAgent,     address _protocolAgent   ) internal {     protocolAgent[_protocol] = _protocolAgent;     emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);   } // Subtracts the accrued debt from a protocol's active balance   // Credits the amount that can be claimed by nonstakers for this protocol   // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings   // Most of this function is dealing with an edge case related to a protocol not being removed by arbs   function settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {     // This calcs the accrued debt of the protocol since it was last updated     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     // This pulls the percentage that is sent to nonstakers     _nonStakerPercentage = nonStakersPercentage[_protocol];     // In case the protocol has accrued debt, this code block will ensure the debt is settled properly     if (debt != 0) {       // Pulls the stored active balance of the protocol       uint256 balance = activeBalances[_protocol];       // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance       // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point       // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage       // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up       if (debt &gt; balance) {         // This error amount represents the magnitude of the mistake         uint256 error = debt - balance;         // Gets the latest value of claimable premiums for stakers         _settleTotalDebt();         // @note to production, set premium first to zero before solving accounting issue.         // otherwise the accounting error keeps increasing         uint256 lastClaimablePremiumsForStakers = lastClaimablePremiumsForStakers;     // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%     uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /       HUNDRED_PERCENT;      // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short     uint256 insufficientTokens;      // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally     // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error     // This first line can be true if claimPremiumsForStakers() has been called and     // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be &gt;0 still     if (claimablePremiumError &gt; lastClaimablePremiumsForStakers_) {       insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;       lastClaimablePremiumsForStakers = 0;     } else {       // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums       // By the amount that was added in error (error) and insufficientTokens = 0       lastClaimablePremiumsForStakers =         lastClaimablePremiumsForStakers_ -         claimablePremiumError;     }      // If two events are thrown, the values need to be summed up for the actual state.     // This means an error of this type will continue until it is handled     emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);     // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case     debt = balance;   }   // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance   activeBalances[_protocol] = balance - debt;   // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol   nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT; } // Updates the last accounted timestamp for this protocol lastAccountedEachProtocol[_protocol] = block.timestamp;  } // Multiplies the total premium per second * number of seconds since the last global accounting update   // And adds it to the total claimable amount for stakers   function _settleTotalDebt() internal {     lastClaimablePremiumsForStakers +=       (block.timestamp - lastAccountedGlobal) *       allPremiumsPerSecToStakers;     lastAccountedGlobal = block.timestamp;   } // Calculates the global premium per second for stakers   // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers   // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones   function _calcGlobalPremiumPerSecForStakers(     uint256 _premiumOld,     uint256 _premiumNew,     uint256 _nonStakerPercentageOld,     uint256 _nonStakerPercentageNew,     uint256 _inMemAllPremiumsPerSecToStakers   ) internal pure returns (uint256) {     return       _inMemAllPremiumsPerSecToStakers +       ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /       HUNDRED_PERCENT -       ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /       HUNDRED_PERCENT;   } // Helper function to remove and clean up a protocol from Sherlock   // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made   function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {     // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol     _setSingleAndGlobalProtocolPremium(_protocol, 0); // Grabs the protocol's active balance uint256 balance = activeBalances[_protocol];  // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent if (balance != 0) {   delete activeBalances[_protocol];   token.safeTransfer(_agent, balance);    emit ProtocolBalanceWithdrawn(_protocol, balance); }  // Sets the protocol agent to zero address (as part of clean up) _setProtocolAgent(_protocol, _agent, address(0));  // Cleans up other mappings for this protocol delete nonStakersPercentage[_protocol]; delete lastAccountedEachProtocol[_protocol]; // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above  // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;  // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked removedProtocolAgent[_protocol] = _agent;  emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0)); emit ProtocolRemoved(_protocol);  } /// @notice Sets the minimum active balance before an arb can remove a protocol   /// @param _minActiveBalance Minimum balance needed (in USDC)   /// @dev Only gov   function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {     // New value cannot be the same as current value     if (minActiveBalance == _minActiveBalance) revert InvalidArgument();     // Can't set a value that is too high to be reasonable     if (_minActiveBalance &gt;= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions(); emit MinBalance(minActiveBalance, _minActiveBalance); minActiveBalance = _minActiveBalance;  } // This function allows the nonstakers role to claim tokens owed to them by a specific protocol   /// @notice Choose an _amount of tokens that nonstakers (_receiver address) will receive from _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens   /// @param _receiver Address to receive tokens   /// @dev Only callable by nonstakers role   function nonStakersClaim(     bytes32 _protocol,     uint256 _amount,     address _receiver   ) external override whenNotPaused {     if (_protocol == bytes32(0)) revert ZeroArgument();     if (_amount == uint256(0)) revert ZeroArgument();     if (_receiver == address(0)) revert ZeroArgument();     // Only the nonstakers role (multisig or contract) can pull the funds     if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized(); // Call can't be executed on protocol that is removed if (protocolAgent_[_protocol] != address(0)) {   // Updates the amount that nonstakers can claim from this protocol   _settleProtocolDebt(_protocol); }  // Sets balance to the amount that is claimable by nonstakers for this specific protocol uint256 balance = nonStakersClaimableByProtocol[_protocol]; // If the amount requested is more than what's owed to nonstakers, revert if (_amount &gt; balance) revert InsufficientBalance(_protocol);  // Sets the claimable amount to whatever is left over after this amount is pulled nonStakersClaimableByProtocol[_protocol] = balance - _amount; // Transfers the amount requested to the `_receiver` address token.safeTransfer(_receiver, _amount);  } // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)   /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address   /// @dev Callable by everyone   /// @dev Funds will be transferred to Sherlock core contract   function claimPremiumsForStakers() external override whenNotPaused {     // Gets address of core Sherlock contract     address sherlock = address(sherlockCore);     // Revert if core Sherlock contract not initialized yet     if (sherlock == address(0)) revert InvalidConditions(); // claimablePremiums is different from _settleTotalDebt() because it does not change state // Retrieves current amount of all premiums that are owed to stakers uint256 amount = claimablePremiums();  // Transfers all the premiums owed to stakers to the Sherlock core contract if (amount != 0) {   // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out   lastClaimablePremiumsForStakers = 0;   lastAccountedGlobal = block.timestamp;   token.safeTransfer(sherlock, amount); }  } // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts   /// @param protocol Protocol identifier   /// @return current and previous are the current and previous coverage amounts for this protocol   // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)   function coverageAmounts(bytes32 _protocol)     external     view     override     returns (uint256 current, uint256 previous)   {     // Checks to see if the protocol has an active protocolAgent (protocol not removed)     // OR checks to see if the removed protocol is still within the claim window     // If so, gives the current and previous coverage, otherwise throws an error     if (       protocolAgent[_protocol] != address(0) ||       block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]     ) {       return (currentCoverage[_protocol], previousCoverage[_protocol]);     } revert ProtocolNotExists(_protocol);  } /// @notice Add a new protocol to Sherlock   /// @param protocol Protocol identifier   /// @param _protocolAgent Address able to submit a claim on behalf of the protocol   /// @param _coverage Hash referencing the active coverage agreement   /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 1018   /// @param _coverageAmount Max amount claimable by this protocol   /// @dev Adding a protocol allows the _protocolAgent to submit a claim   /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point   /// @dev _nonStakers is scaled by 1018   /// @dev Only callable by governance   function protocolAdd(     bytes32 _protocol,     address _protocolAgent,     bytes32 _coverage,     uint256 _nonStakers,     uint256 _coverageAmount   ) external override onlyOwner {     if (_protocol == bytes32(0)) revert ZeroArgument();     if (_protocolAgent == address(0)) revert ZeroArgument();     // Checks to make sure the protocol doesn't exist already     if (protocolAgent[_protocol] != address(0)) revert InvalidConditions(); // Updates the protocol agent and passes in the old agent which is 0 address in this case _setProtocolAgent(_protocol, address(0), _protocolAgent);  // Delete mappings that are potentially non default values // From previous time protocol was added/removed delete removedProtocolClaimDeadline[_protocol]; delete removedProtocolAgent[_protocol]; delete currentCoverage[_protocol]; delete previousCoverage[_protocol];  emit ProtocolAdded(_protocol);  // Most of the logic for actually adding a protocol in this function protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);  } /// @notice Update info regarding a protocol   /// @param _protocol Protocol identifier   /// @param _coverage Hash referencing the active coverage agreement   /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18   /// @param _coverageAmount Max amount claimable by this protocol   /// @dev Only callable by governance   /// @dev _nonStakers can be 0   function protocolUpdate(     bytes32 _protocol,     bytes32 _coverage,     uint256 _nonStakers,     uint256 _coverageAmount   ) public override onlyOwner {     if (_coverage == bytes32(0)) revert ZeroArgument();     if (_nonStakers &gt; HUNDRED_PERCENT) revert InvalidArgument();     if (_coverageAmount == uint256(0)) revert ZeroArgument(); // Checks to make sure the protocol has been assigned a protocol agent _verifyProtocolExists(_protocol);  // Subtracts the accrued debt from a protocol's active balance (if any) // Updates the amount that can be claimed by nonstakers _settleProtocolDebt(_protocol);  // Updates the global claimable amount for stakers _settleTotalDebt();  // Gets the premium per second for this protocol uint256 premium = premiums_[_protocol];  // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be) allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(   premium,   premium,   nonStakersPercentage[_protocol],   _nonStakers,   allPremiumsPerSecToStakers );  // Updates the stored value of percentage of premiums that go to nonstakers nonStakersPercentage[_protocol] = _nonStakers;  // Updates previous coverage and current coverage amounts previousCoverage[_protocol] = currentCoverage[_protocol]; currentCoverage[_protocol] = _coverageAmount;  emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);  } /// @notice Remove a protocol from coverage   /// @param _protocol Protocol identifier   /// @dev Before removing a protocol the premium must be 0   /// @dev Removing a protocol basically stops the _protocolAgent from being active (can still submit claims until claim deadline though)   /// @dev Pays off debt + sends remaining balance to protocol agent   /// @dev This call should be subject to a timelock   /// @dev Only callable by governance   function protocolRemove(bytes32 _protocol) external override onlyOwner {     // checks to make sure the protocol actually has a protocol agent     address agent = _verifyProtocolExists(_protocol); // Removes a protocol from Sherlock and cleans up its data // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made _forceRemoveProtocol(_protocol, agent);  } /// @notice Remove a protocol with insufficient active balance   /// @param _protocol Protocol identifier   // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function   function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {     address agent = _verifyProtocolExists(_protocol); // Gets the latest value of the active balance at this protocol _settleProtocolDebt(_protocol); // Sets latest value of active balance to remainingBalance variable uint256 remainingBalance = activeBalances[_protocol];  // This means the protocol still has adequate active balance and thus cannot be removed if (remainingBalance &gt;= minActiveBalance) revert InvalidConditions();  // Sets the protocol's active balance to 0 delete activeBalances[_protocol]; // Removes the protocol from coverage _forceRemoveProtocol(_protocol, agent);  if (remainingBalance != 0) {   // sends the remaining balance to msg.sender   token.safeTransfer(msg.sender, remainingBalance); } emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);  } /// @notice Calculate if arb is possible and what the reward would be   /// @param _protocol Protocol identifier   /// @return arbAmount Amount reward for arbing   /// @return able Indicator if arb call is even possible   /// @dev Doesn't subtract the current protocol debt from the active balance   function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)     internal     view     returns (uint256 arbAmount, bool able)   {     uint256 secondsLeft = _secondsOfCoverageLeft(_protocol); // If arb is not possible return false if (secondsLeft &gt;= MIN_SECONDS_OF_COVERAGE) return (0, false);  // This percentage scales over time // Reaches 100% on 0 seconds of coverage left uint256 percentageScaled = HUNDRED_PERCENT -   (secondsLeft * HUNDRED_PERCENT) /   MIN_SECONDS_OF_COVERAGE;  able = true; arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;  } /// @notice Removes a protocol with insufficent seconds of coverage left   /// @param _protocol Protocol identifier   // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second   function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {     // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings     address agent = _verifyProtocolExists(_protocol); // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance() // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance() // But when removing based on seconds of coverage left, the remainingBalance could still be quite large // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%) _settleProtocolDebt(_protocol); (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol); if (able == false) revert InvalidConditions();  if (arbAmount != 0) {   // subtracts the amount that will be paid to the arb from the active balance   activeBalances[_protocol] -= arbAmount; }  // Removes the protocol from coverage // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above _forceRemoveProtocol(_protocol, agent);  // Done after removing protocol to mitigate reentrency pattern // (In case token allows callback) if (arbAmount != 0) {   token.safeTransfer(msg.sender, arbAmount); } emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);  } /// @notice Set premium of _protocol to _premium   /// @param _protocol Protocol identifier   /// @param _premium Amount of premium _protocol pays per second   /// @dev The value 0 would mean inactive coverage   /// @dev Only callable by governance   function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {     // Checks to see if protocol has a protocol agent     _verifyProtocolExists(_protocol); // Updates individual protocol's premium and allPremiumsPerSecToStakers _setSingleAndGlobalProtocolPremium(_protocol, _premium);  } /// @notice Set premium of multiple protocols   /// @param _protocol Array of protocol identifiers   /// @param _premium Array of premium amounts protocols pay per second   /// @dev The value 0 would mean inactive coverage   /// @dev Only callable by governance   function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)     external     override     onlyOwner   {     // Checks to make sure there are an equal amount of entries in each array     if (_protocol.length != _premium.length) revert UnequalArrayLength();     if (_protocol.length == 0) revert InvalidArgument(); // Updates the global claimable amount for stakers _settleTotalDebt();  uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;  // Loops through the array of protocols and checks to make sure each has a protocol agent assigned for (uint256 i; i &lt; _protocol.length; i++) {   _verifyProtocolExists(_protocol[i]);    // Sets the protocol premium for that specific protocol   // Function returns the old premium and nonStakerPercentage for that specific protocol   (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(     _protocol[i],     _premium[i]   );    // Calculates the new global premium which adds up all premiums paid by all protocols   allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(     oldPremiumPerSecond,     _premium[i],     nonStakerPercentage,     nonStakerPercentage,     allPremiumsPerSecToStakers_   ); }  // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;  } // This is how protocols pay for coverage by increasing their active balance   /// @notice Deposits _amount of token to the active balance of _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens to deposit   /// @dev Approval should be made before calling   function depositToActiveBalance(bytes32 _protocol, uint256 _amount)     external     override     whenNotPaused   {     if (_amount == uint256(0)) revert ZeroArgument();     _verifyProtocolExists(_protocol); // Transfers _amount to this contract token.safeTransferFrom(msg.sender, address(this), _amount); // Increases the active balance of the protocol by _amount activeBalances[_protocol] += _amount;  emit ProtocolBalanceDeposited(_protocol, _amount);  } // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)   // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)   /// @notice Withdraws _amount of token from the active balance of _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens to withdraw   /// @dev Only protocol agent is able to withdraw   /// @dev Balance can be withdrawn up until 7 days worth of active balance   function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)     external     override     whenNotPaused   {     if (_amount == uint256(0)) revert ZeroArgument();     // Only the protocol agent can call this function     if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized(); // Updates the active balance of the protocol _settleProtocolDebt(_protocol);  // Sets currentBalance to the active balance of the protocol uint256 currentBalance = activeBalances[_protocol]; // Reverts if trying to withdraw more than the active balance if (_amount &gt; currentBalance) revert InsufficientBalance(_protocol);  // Removes the _amount to be withdrawn from the active balance activeBalances[_protocol] = currentBalance - _amount; // Reverts if a protocol has less than 7 days worth of active balance left if (_secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);  // Transfers the amount to the msg.sender (protocol agent) token.safeTransfer(msg.sender, _amount); emit ProtocolBalanceWithdrawn(_protocol, _amount);  } /// @notice Transfer protocol agent role   /// @param _protocol Protocol identifier   /// @param _protocolAgent Account able to submit a claim on behalf of the protocol   /// @dev Only the active protocolAgent is able to transfer the role   function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)     external     override     whenNotPaused   {     if (_protocolAgent == address(0)) revert ZeroArgument();     // Can't set the new protocol agent to the caller address     if (msg.sender == _protocolAgent) revert InvalidArgument();     // Because the caller must be the current protocol agent     if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized(); // Sets the protocol agent to the new address _setProtocolAgent(_protocol, msg.sender, _protocolAgent);  } /// @notice Function used to check if this is the current active protocol manager   /// @return Boolean indicating it's active   /// @dev If inactive the owner can pull all ERC20s and ETH   /// @dev Will be checked by calling the sherlock contract   function isActive() public view returns (bool) {     return address(sherlockCore.sherlockProtocolManager()) == address(this);   } // Only contract owner can call this   // Sends all specified tokens in this contract to the receiver's address (as well as ETH)   function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {     if (_receiver == address(0)) revert ZeroArgument();     // This contract must NOT be the current assigned protocol manager contract     if (isActive()) revert InvalidConditions();     // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH     _sweep(_receiver, _extraTokens);   } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/***********\\n Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x)\n Sherlock Protocol: https://sherlock.xyz\n/***********/\n\nimport \'./Manager.sol\';\nimport \'../interfaces/managers/ISherlockProtocolManager.sol\';\n\n/// @title Sherlock core interface for protocols\n/// @author Evert Kors\n// This is the contract that manages covered protocols\n\ncontract SherlockProtocolManager is ISherlockProtocolManager, Manager {\n  using SafeERC20 for IERC20;\n\n  // Represents the token that protocols pay with (currently USDC)\n  IERC20 public immutable token;\n\n  // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed\n  uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 106; // 30k usdc\n\n  // A removed protocol is still able to make a claim for this amount of time after its removal\n  uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days;\n\n  // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance\n  uint256 public constant MIN_SECONDS_LEFT = 7 days;\n\n  // Convenient for percentage calculations\n  uint256 internal constant HUNDRED_PERCENT = 1018;\n\n  // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage\n  // This value is calculated from a protocol\'s active balance divided by the premium per second the protocol is paying\n  uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours;\n\n  // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)\n  mapping(bytes32 =&gt; address) internal protocolAgent_;\n\n  // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)\n  mapping(bytes32 =&gt; uint256) internal nonStakersPercentage;\n\n  // The premium per second paid by each protocol is stored in this mapping\n  mapping(bytes32 =&gt; uint256) internal premiums_;\n\n  // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.\n  // This "active balance" is really just an accounting concept, doesn\'t mean tokens have been transferred or not\n  mapping(bytes32 =&gt; uint256) internal activeBalances;\n\n  // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol\n  mapping(bytes32 =&gt; uint256) internal lastAccountedEachProtocol;\n\n  // The amount that can be claimed by nonstakers for each protocol\n  // We need this value so we can track how much payment is coming from each protocol\n  mapping(bytes32 =&gt; uint256) internal nonStakersClaimableByProtocol;\n\n  // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)\n  uint256 internal lastAccountedGlobal;\n\n  // This is the total amount of premiums paid (per second) by all the covered protocols (added up)\n  uint256 internal allPremiumsPerSecToStakers;\n\n  // This is the amount that was claimable by stakers the last time the accounting was run\n  // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date\n  uint256 internal lastClaimablePremiumsForStakers;\n\n  // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage\n  // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)\n  uint256 public override minActiveBalance;\n\n  // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)\n  mapping(bytes32 =&gt; uint256) internal removedProtocolClaimDeadline;\n\n  // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)\n  mapping(bytes32 =&gt; address) internal removedProtocolAgent;\n\n  // Current amount of coverage (i.e. 20M USDC) for a protocol\n  mapping(bytes32 =&gt; uint256) internal currentCoverage;\n\n  // Previous amount of coverage for a protocol\n  // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount\n  mapping(bytes32 =&gt; uint256) internal previousCoverage;\n\n  // Setting the token to USDC\n  constructor(IERC20 token) {\n    if (address(_token) == address(0)) revert ZeroArgument();\n    token = _token;\n  }\n\n  // Modifier used to ensure a protocol exists (has been instantiated and not removed)\n  modifier protocolExists(bytes32 _protocol) {\n    _verifyProtocolExists(_protocol);\n    ;\n  }\n\n  /// @notice View current protocolAgent of _protocol\n  /// @param protocol Protocol identifier\n  /// @return Address able to submit claims\n  function protocolAgent(bytes32 _protocol) external view override returns (address) {\n    address agent = protocolAgent[protocol];\n    if (agent != address(0)) return agent;\n\n    // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned\n    // Note: Old protocol agent will never be address(0)\n    if (block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]) {\n      return removedProtocolAgent[_protocol];\n    }\n\n    // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned\n    revert ProtocolNotExists(_protocol);\n  }\n\n  // Checks if the protocol exists, then returns the current premium per second being charged\n  /// @notice View current premium of protocol\n  /// @param _protocol Protocol identifier\n  /// @return Amount of premium _protocol pays per second\n  function premium(bytes32 _protocol)\n    external\n    view\n    override\n    protocolExists(_protocol)\n    returns (uint256)\n  {\n    return premiums[protocol];\n  }\n\n  // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)\n  // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)\n  function _verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {\n    _protocolAgent = protocolAgent[protocol];\n    if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);\n  }\n\n  //\n  // View methods\n  //\n\n  // Calcs the debt accrued by the protocol since it last had an accounting update\n  // This is the amount that needs to be removed from a protocol\'s active balance\n  function _calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {\n    return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums[protocol];\n  }\n\n  /// @notice View the amount nonstakers can claim from this protocol\n  /// @param _protocol Protocol identifier\n  /// @return Amount of tokens claimable by nonstakers\n  /// @dev this reads from a storage variable + (now-lastsettled) * premiums\n  // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]\n  // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn\'t change since the protocol has been removed\n  function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {\n    // Calcs the debt of a protocol since the last accounting update\n    uint256 debt = _calcIncrementalProtocolDebt(_protocol);\n    // Gets the active balance of the protocol\n    uint256 balance = activeBalances[_protocol];\n    // The debt should never be higher than the balance (only happens if the arbitrages fail)\n    if (debt &gt; balance) debt = balance;\n\n    // Adds the incremental claimable amount owed to nonstakers to the total claimable amount\n    return\n      nonStakersClaimableByProtocol[_protocol] +\n      (nonStakersPercentage[_protocol] * debt) /\n      HUNDRED_PERCENT;\n  }\n\n  /// @notice View current amount of all premiums that are owed to stakers\n  /// @return Premiums claimable\n  /// @dev Will increase every block\n  /// @dev base + (now - last_settled) * ps\n  function claimablePremiums() public view override returns (uint256) {\n    // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)\n    return\n      lastClaimablePremiumsForStakers +\n      (block.timestamp - lastAccountedGlobal) \n      allPremiumsPerSecToStakers;\n  }\n\n  /// @notice View seconds of coverage left for _protocol before it runs out of active balance\n  /// @param protocol Protocol identifier\n  /// @return Seconds of coverage left\n  function secondsOfCoverageLeft(bytes32 _protocol)\n    external\n    view\n    override\n    protocolExists(_protocol)\n    returns (uint256)\n  {\n    return _secondsOfCoverageLeft(_protocol);\n  }\n\n  // Helper function to return seconds of coverage left for a protocol\n  // Gets the current active balance of the protocol and divides by the premium per second for the protocol\n  function _secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {\n    uint256 premium = premiums[protocol];\n    if (premium == 0) return 0;\n    return _activeBalance(_protocol) / premium;\n  }\n\n  /// @notice View current active balance of covered protocol\n  /// @param _protocol Protocol identifier\n  /// @return Active balance\n  /// @dev Accrued debt is subtracted from the stored active balance\n  function activeBalance(bytes32 _protocol)\n    external\n    view\n    override\n    protocolExists(_protocol)\n    returns (uint256)\n  {\n    return _activeBalance(_protocol);\n  }\n\n  // Helper function to calc the active balance of a protocol at current time\n  function _activeBalance(bytes32 _protocol) internal view returns (uint256) {\n    uint256 debt = _calcIncrementalProtocolDebt(_protocol);\n    uint256 balance = activeBalances[_protocol];\n    // The debt should never be higher than the balance (only happens if the arbitrages fail)\n    if (debt &gt; balance) return 0;\n    return balance - debt;\n  }\n\n  //\n  // State methods\n  //\n\n  /// @notice Helps set the premium per second for an individual protocol\n  /// @param _protocol Protocol identifier\n  /// @param _premium New premium per second\n  /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function\n  function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)\n    internal\n    returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)\n  {\n    // _settleProtocolDebt() subtracts debt from the protocol\'s active balance and updates the % due to nonstakers\n    // Also updates the last accounted timestamp for this protocol\n    // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings\n    // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol\n    nonStakerPercentage = _settleProtocolDebt(_protocol);\n    // Stores the old premium before it gets updated\n    oldPremiumPerSecond = premiums[protocol];\n\n    if (oldPremiumPerSecond != _premium) {\n      // Sets the protocol\'s premium per second to the new value\n      premiums[protocol] = _premium;\n      emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium);\n    }\n    // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing\n    // We don\'t need to check the min balance requirement for arbs because that value doesn\'t change like secondsOfCoverageLeft changes\n    // Effectively we just need to make sure we don\'t accidentally run a protocol\'s active balance down below the point\n    // Where arbs would no longer be incentivized to remove the protocol\n    // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems\n    if (_premium != 0 &amp;&amp; _secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_OF_COVERAGE) {\n      revert InsufficientBalance(_protocol);\n    }\n  }\n\n  /// @notice Sets a single protocol\'s premium per second and also updates the global total of premiums per second\n  /// @param _protocol Protocol identifier\n  /// @param _premium New premium per second\n  function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {\n    // Sets the individual protocol\'s premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings\n    (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(\n      _protocol,\n      _premium\n    );\n    // Settling the total amount of premiums owed to stakers before a new premium per second gets set\n    _settleTotalDebt();\n    // This calculates the new global premium per second that gets paid to stakers\n    // We input the same nonStakerPercentage twice because we simply aren\'t updating that value in this function\n    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(\n      oldPremiumPerSecond,\n      _premium,\n      nonStakerPercentage,\n      nonStakerPercentage,\n      allPremiumsPerSecToStakers\n    );\n  }\n\n  // Internal function to set a new protocolAgent for a specific protocol\n  // _oldAgent is only included as part of emitting an event\n  function _setProtocolAgent(\n    bytes32 _protocol,\n    address _oldAgent,\n    address _protocolAgent\n  ) internal {\n    protocolAgent[protocol] = _protocolAgent;\n    emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);\n  }\n\n  // Subtracts the accrued debt from a protocol\'s active balance\n  // Credits the amount that can be claimed by nonstakers for this protocol\n  // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings\n  // Most of this function is dealing with an edge case related to a protocol not being removed by arbs\n  function _settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {\n    // This calcs the accrued debt of the protocol since it was last updated\n    uint256 debt = _calcIncrementalProtocolDebt(_protocol);\n    // This pulls the percentage that is sent to nonstakers\n    _nonStakerPercentage = nonStakersPercentage[_protocol];\n    // In case the protocol has accrued debt, this code block will ensure the debt is settled properly\n    if (debt != 0) {\n      // Pulls the stored active balance of the protocol\n      uint256 balance = activeBalances[_protocol];\n      // This is the start of handling an edge case where arbitragers don\'t remove this protocol before debt becomes greater than active balance\n      // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point\n      // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage\n      // However, if arbs don\'t come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up\n      if (debt &gt; balance) {\n        // This error amount represents the magnitude of the mistake\n        uint256 error = debt - balance;\n        // Gets the latest value of claimable premiums for stakers\n        _settleTotalDebt();\n        // @note to production, set premium first to zero before solving accounting issue.\n        // otherwise the accounting error keeps increasing\n        uint256 lastClaimablePremiumsForStakers = lastClaimablePremiumsForStakers;\n\n        // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%\n        uint256 claimablePremiumError = ((HUNDRED_PERCENT - nonStakerPercentage) * error) /\n          HUNDRED_PERCENT;\n\n        // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short\n        uint256 insufficientTokens;\n\n        // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally\n        // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error\n        // This first line can be true if claimPremiumsForStakers() has been called and\n        // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be &gt;0 still\n        if (claimablePremiumError &gt; lastClaimablePremiumsForStakers) {\n          insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;\n          lastClaimablePremiumsForStakers = 0;\n        } else {\n          // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums\n          // By the amount that was added in error (error) and insufficientTokens = 0\n          lastClaimablePremiumsForStakers =\n            lastClaimablePremiumsForStakers_ -\n            claimablePremiumError;\n        }\n\n        // If two events are thrown, the values need to be summed up for the actual state.\n        // This means an error of this type will continue until it is handled\n        emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);\n        // We set the debt equal to the balance, and in the next line we effectively set the protocol\'s active balance to 0 in this case\n        debt = balance;\n      }\n      // Subtracts the accrued debt (since last update) from the protocol\'s active balance and updates active balance\n      activeBalances[_protocol] = balance - debt;\n      // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol\n      nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT;\n    }\n    // Updates the last accounted timestamp for this protocol\n    lastAccountedEachProtocol[_protocol] = block.timestamp;\n  }\n\n  // Multiplies the total premium per second * number of seconds since the last global accounting update\n  // And adds it to the total claimable amount for stakers\n  function _settleTotalDebt() internal {\n    lastClaimablePremiumsForStakers +=\n      (block.timestamp - lastAccountedGlobal) \n      allPremiumsPerSecToStakers;\n    lastAccountedGlobal = block.timestamp;\n  }\n\n  // Calculates the global premium per second for stakers\n  // Takes a specific protocol\'s old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers\n  // Subtracts out the old values of a protocol\'s premium per second and nonstaker percentage and adds the new ones\n  function _calcGlobalPremiumPerSecForStakers(\n    uint256 _premiumOld,\n    uint256 _premiumNew,\n    uint256 _nonStakerPercentageOld,\n    uint256 _nonStakerPercentageNew,\n    uint256 _inMemAllPremiumsPerSecToStakers\n  ) internal pure returns (uint256) {\n    return\n      _inMemAllPremiumsPerSecToStakers +\n      ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /\n      HUNDRED_PERCENT -\n      ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /\n      HUNDRED_PERCENT;\n  }\n\n  // Helper function to remove and clean up a protocol from Sherlock\n  // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made\n  function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {\n    // Sets the individual protocol\'s premium to zero and updates the global premium variable for a zero premium at this protocol\n    _setSingleAndGlobalProtocolPremium(_protocol, 0);\n\n    // Grabs the protocol\'s active balance\n    uint256 balance = activeBalances[_protocol];\n\n    // If there\'s still some active balance, delete the entry and send the remaining balance to the protocol agent\n    if (balance != 0) {\n      delete activeBalances[_protocol];\n      token.safeTransfer(_agent, balance);\n\n      emit ProtocolBalanceWithdrawn(_protocol, balance);\n    }\n\n    // Sets the protocol agent to zero address (as part of clean up)\n    _setProtocolAgent(_protocol, _agent, address(0));\n\n    // Cleans up other mappings for this protocol\n    delete nonStakersPercentage[_protocol];\n    delete lastAccountedEachProtocol[_protocol];\n    // premiums_ mapping is not deleted here as it\'s already 0 because of the _setSingleAndGlobalProtocolPremium call above\n\n    // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol\n    removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;\n\n    // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed\n    // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked\n    removedProtocolAgent[_protocol] = _agent;\n\n    emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0));\n    emit ProtocolRemoved(_protocol);\n  }\n\n  /// @notice Sets the minimum active balance before an arb can remove a protocol\n  /// @param _minActiveBalance Minimum balance needed (in USDC)\n  /// @dev Only gov\n  function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {\n    // New value cannot be the same as current value\n    if (minActiveBalance == _minActiveBalance) revert InvalidArgument();\n    // Can\'t set a value that is too high to be reasonable\n    if (_minActiveBalance &gt;= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions();\n\n    emit MinBalance(minActiveBalance, _minActiveBalance);\n    minActiveBalance = _minActiveBalance;\n  }\n\n  // This function allows the nonstakers role to claim tokens owed to them by a specific protocol\n  /// @notice Choose an _amount of tokens that nonstakers (_receiver address) will receive from _protocol\n  /// @param _protocol Protocol identifier\n  /// @param _amount Amount of tokens\n  /// @param _receiver Address to receive tokens\n  /// @dev Only callable by nonstakers role\n  function nonStakersClaim(\n    bytes32 _protocol,\n    uint256 _amount,\n    address _receiver\n  ) external override whenNotPaused {\n    if (_protocol == bytes32(0)) revert ZeroArgument();\n    if (_amount == uint256(0)) revert ZeroArgument();\n    if (_receiver == address(0)) revert ZeroArgument();\n    // Only the nonstakers role (multisig or contract) can pull the funds\n    if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized();\n\n    // Call can\'t be executed on protocol that is removed\n    if (protocolAgent[protocol] != address(0)) {\n      // Updates the amount that nonstakers can claim from this protocol\n      _settleProtocolDebt(_protocol);\n    }\n\n    // Sets balance to the amount that is claimable by nonstakers for this specific protocol\n    uint256 balance = nonStakersClaimableByProtocol[_protocol];\n    // If the amount requested is more than what\'s owed to nonstakers, revert\n    if (_amount &gt; balance) revert InsufficientBalance(_protocol);\n\n    // Sets the claimable amount to whatever is left over after this amount is pulled\n    nonStakersClaimableByProtocol[_protocol] = balance - _amount;\n    // Transfers the amount requested to the _receiver address\n    token.safeTransfer(_receiver, _amount);\n  }\n\n  // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)\n  /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address\n  /// @dev Callable by everyone\n  /// @dev Funds will be transferred to Sherlock core contract\n  function claimPremiumsForStakers() external override whenNotPaused {\n    // Gets address of core Sherlock contract\n    address sherlock = address(sherlockCore);\n    // Revert if core Sherlock contract not initialized yet\n    if (sherlock == address(0)) revert InvalidConditions();\n\n    // claimablePremiums is different from _settleTotalDebt() because it does not change state\n    // Retrieves current amount of all premiums that are owed to stakers\n    uint256 amount = claimablePremiums();\n\n    // Transfers all the premiums owed to stakers to the Sherlock core contract\n    if (amount != 0) {\n      // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out\n      lastClaimablePremiumsForStakers = 0;\n      lastAccountedGlobal = block.timestamp;\n      token.safeTransfer(sherlock, amount);\n    }\n  }\n\n  // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts\n  /// @param _protocol Protocol identifier\n  /// @return current and previous are the current and previous coverage amounts for this protocol\n  // Note For this process to work, a protocol\'s coverage amount should not be set more than once in the span of claim delay period (7 days or something)\n  function coverageAmounts(bytes32 _protocol)\n    external\n    view\n    override\n    returns (uint256 current, uint256 previous)\n  {\n    // Checks to see if the protocol has an active protocolAgent (protocol not removed)\n    // OR checks to see if the removed protocol is still within the claim window\n    // If so, gives the current and previous coverage, otherwise throws an error\n    if (\n      protocolAgent[protocol] != address(0) ||\n      block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]\n    ) {\n      return (currentCoverage[_protocol], previousCoverage[_protocol]);\n    }\n\n    revert ProtocolNotExists(_protocol);\n  }\n\n  /// @notice Add a new protocol to Sherlock\n  /// @param _protocol Protocol identifier\n  /// @param _protocolAgent Address able to submit a claim on behalf of the protocol\n  /// @param _coverage Hash referencing the active coverage agreement\n  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 1018\n  /// @param _coverageAmount Max amount claimable by this protocol\n  /// @dev Adding a protocol allows the _protocolAgent to submit a claim\n  /// @dev Coverage is not started yet as the protocol doesn\'t pay a premium at this point\n  /// @dev _nonStakers is scaled by 1018\n  /// @dev Only callable by governance\n  function protocolAdd(\n    bytes32 _protocol,\n    address _protocolAgent,\n    bytes32 _coverage,\n    uint256 _nonStakers,\n    uint256 _coverageAmount\n  ) external override onlyOwner {\n    if (_protocol == bytes32(0)) revert ZeroArgument();\n    if (_protocolAgent == address(0)) revert ZeroArgument();\n    // Checks to make sure the protocol doesn\'t exist already\n    if (protocolAgent[protocol] != address(0)) revert InvalidConditions();\n\n    // Updates the protocol agent and passes in the old agent which is 0 address in this case\n    _setProtocolAgent(_protocol, address(0), _protocolAgent);\n\n    // Delete mappings that are potentially non default values\n    // From previous time protocol was added/removed\n    delete removedProtocolClaimDeadline[_protocol];\n    delete removedProtocolAgent[_protocol];\n    delete currentCoverage[_protocol];\n    delete previousCoverage[_protocol];\n\n    emit ProtocolAdded(_protocol);\n\n    // Most of the logic for actually adding a protocol in this function\n    protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);\n  }\n\n  /// @notice Update info regarding a protocol\n  /// @param _protocol Protocol identifier\n  /// @param _coverage Hash referencing the active coverage agreement\n  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18\n  /// @param _coverageAmount Max amount claimable by this protocol\n  /// @dev Only callable by governance\n  /// @dev _nonStakers can be 0\n  function protocolUpdate(\n    bytes32 _protocol,\n    bytes32 _coverage,\n    uint256 _nonStakers,\n    uint256 _coverageAmount\n  ) public override onlyOwner {\n    if (_coverage == bytes32(0)) revert ZeroArgument();\n    if (_nonStakers &gt; HUNDRED_PERCENT) revert InvalidArgument();\n    if (_coverageAmount == uint256(0)) revert ZeroArgument();\n\n    // Checks to make sure the protocol has been assigned a protocol agent\n    _verifyProtocolExists(_protocol);\n\n    // Subtracts the accrued debt from a protocol\'s active balance (if any)\n    // Updates the amount that can be claimed by nonstakers\n    _settleProtocolDebt(_protocol);\n\n    // Updates the global claimable amount for stakers\n    _settleTotalDebt();\n\n    // Gets the premium per second for this protocol\n    uint256 premium = premiums[protocol];\n\n    // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be)\n    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(\n      premium,\n      premium,\n      nonStakersPercentage[_protocol],\n      _nonStakers,\n      allPremiumsPerSecToStakers\n    );\n\n    // Updates the stored value of percentage of premiums that go to nonstakers\n    nonStakersPercentage[_protocol] = _nonStakers;\n\n    // Updates previous coverage and current coverage amounts\n    previousCoverage[_protocol] = currentCoverage[_protocol];\n    currentCoverage[_protocol] = _coverageAmount;\n\n    emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);\n  }\n\n  /// @notice Remove a protocol from coverage\n  /// @param _protocol Protocol identifier\n  /// @dev Before removing a protocol the premium must be 0\n  /// @dev Removing a protocol basically stops the _protocolAgent from being active (can still submit claims until claim deadline though)\n  /// @dev Pays off debt + sends remaining balance to protocol agent\n  /// @dev This call should be subject to a timelock\n  /// @dev Only callable by governance\n  function protocolRemove(bytes32 _protocol) external override onlyOwner {\n    // checks to make sure the protocol actually has a protocol agent\n    address agent = _verifyProtocolExists(_protocol);\n\n    // Removes a protocol from Sherlock and cleans up its data\n    // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made\n    _forceRemoveProtocol(_protocol, agent);\n  }\n\n  /// @notice Remove a protocol with insufficient active balance\n  /// @param _protocol Protocol identifier\n  // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function\n  function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {\n    address agent = _verifyProtocolExists(_protocol);\n\n    // Gets the latest value of the active balance at this protocol\n    _settleProtocolDebt(_protocol);\n    // Sets latest value of active balance to remainingBalance variable\n    uint256 remainingBalance = activeBalances[_protocol];\n\n    // This means the protocol still has adequate active balance and thus cannot be removed\n    if (remainingBalance &gt;= minActiveBalance) revert InvalidConditions();\n\n    // Sets the protocol\'s active balance to 0\n    delete activeBalances[_protocol];\n    // Removes the protocol from coverage\n    _forceRemoveProtocol(_protocol, agent);\n\n    if (remainingBalance != 0) {\n      // sends the remaining balance to msg.sender\n      token.safeTransfer(msg.sender, remainingBalance);\n    }\n    emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);\n  }\n\n  /// @notice Calculate if arb is possible and what the reward would be\n  /// @param _protocol Protocol identifier\n  /// @return arbAmount Amount reward for arbing\n  /// @return able Indicator if arb call is even possible\n  /// @dev Doesn\'t subtract the current protocol debt from the active balance\n  function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)\n    internal\n    view\n    returns (uint256 arbAmount, bool able)\n  {\n    uint256 secondsLeft = _secondsOfCoverageLeft(_protocol);\n\n    // If arb is not possible return false\n    if (secondsLeft &gt;= MIN_SECONDS_OF_COVERAGE) return (0, false);\n\n    // This percentage scales over time\n    // Reaches 100% on 0 seconds of coverage left\n    uint256 percentageScaled = HUNDRED_PERCENT -\n      (secondsLeft * HUNDRED_PERCENT) /\n      MIN_SECONDS_OF_COVERAGE;\n\n    able = true;\n    arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;\n  }\n\n  /// @notice Removes a protocol with insufficent seconds of coverage left\n  /// @param _protocol Protocol identifier\n  // Seconds of coverage is defined by the active balance of the protocol divided by the protocol\'s premium per second\n  function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {\n    // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings\n    address agent = _verifyProtocolExists(_protocol);\n\n    // NOTE: We don\'t give the arb the full remaining balance like we do in forceRemoveByActiveBalance()\n    // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance()\n    // But when removing based on seconds of coverage left, the remainingBalance could still be quite large\n    // So it\'s better to scale the arb reward over time. It\'s a little complex because the remainingBalance\n    // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%)\n    _settleProtocolDebt(_protocol);\n    (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol);\n    if (able == false) revert InvalidConditions();\n\n    if (arbAmount != 0) {\n      // subtracts the amount that will be paid to the arb from the active balance\n      activeBalances[_protocol] -= arbAmount;\n    }\n\n    // Removes the protocol from coverage\n    // This function also pays the active balance to the protocol agent, so it\'s good we do this after subtracting arb amount above\n    _forceRemoveProtocol(_protocol, agent);\n\n    // Done after removing protocol to mitigate reentrency pattern\n    // (In case token allows callback)\n    if (arbAmount != 0) {\n      token.safeTransfer(msg.sender, arbAmount);\n    }\n    emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);\n  }\n\n  /// @notice Set premium of _protocol to _premium\n  /// @param _protocol Protocol identifier\n  /// @param _premium Amount of premium _protocol pays per second\n  /// @dev The value 0 would mean inactive coverage\n  /// @dev Only callable by governance\n  function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {\n    // Checks to see if protocol has a protocol agent\n    _verifyProtocolExists(_protocol);\n\n    // Updates individual protocol\'s premium and allPremiumsPerSecToStakers\n    _setSingleAndGlobalProtocolPremium(_protocol, _premium);\n  }\n\n  /// @notice Set premium of multiple protocols\n  /// @param _protocol Array of protocol identifiers\n  /// @param _premium Array of premium amounts protocols pay per second\n  /// @dev The value 0 would mean inactive coverage\n  /// @dev Only callable by governance\n  function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)\n    external\n    override\n    onlyOwner\n  {\n    // Checks to make sure there are an equal amount of entries in each array\n    if (_protocol.length != _premium.length) revert UnequalArrayLength();\n    if (_protocol.length == 0) revert InvalidArgument();\n\n    // Updates the global claimable amount for stakers\n    _settleTotalDebt();\n\n    uint256 allPremiumsPerSecToStakers = allPremiumsPerSecToStakers;\n\n    // Loops through the array of protocols and checks to make sure each has a protocol agent assigned\n    for (uint256 i; i &lt; protocol.length; i++) {\n      _verifyProtocolExists(_protocol[i]);\n\n      // Sets the protocol premium for that specific protocol\n      // Function returns the old premium and nonStakerPercentage for that specific protocol\n      (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(\n        _protocol[i],\n        _premium[i]\n      );\n\n      // Calculates the new global premium which adds up all premiums paid by all protocols\n      allPremiumsPerSecToStakers = calcGlobalPremiumPerSecForStakers(\n        oldPremiumPerSecond,\n        _premium[i],\n        nonStakerPercentage,\n        nonStakerPercentage,\n        allPremiumsPerSecToStakers\n      );\n    }\n\n    // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value\n    allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;\n  }\n\n  // This is how protocols pay for coverage by increasing their active balance\n  /// @notice Deposits _amount of token to the active balance of _protocol\n  /// @param _protocol Protocol identifier\n  /// @param _amount Amount of tokens to deposit\n  /// @dev Approval should be made before calling\n  function depositToActiveBalance(bytes32 _protocol, uint256 _amount)\n    external\n    override\n    whenNotPaused\n  {\n    if (_amount == uint256(0)) revert ZeroArgument();\n    _verifyProtocolExists(_protocol);\n\n    // Transfers _amount to this contract\n    token.safeTransferFrom(msg.sender, address(this), _amount);\n    // Increases the active balance of the protocol by _amount\n    activeBalances[_protocol] += _amount;\n\n    emit ProtocolBalanceDeposited(_protocol, _amount);\n  }\n\n  // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)\n  // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)\n  /// @notice Withdraws _amount of token from the active balance of _protocol\n  /// @param _protocol Protocol identifier\n  /// @param _amount Amount of tokens to withdraw\n  /// @dev Only protocol agent is able to withdraw\n  /// @dev Balance can be withdrawn up until 7 days worth of active balance\n  function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)\n    external\n    override\n    whenNotPaused\n  {\n    if (_amount == uint256(0)) revert ZeroArgument();\n    // Only the protocol agent can call this function\n    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();\n\n    // Updates the active balance of the protocol\n    _settleProtocolDebt(_protocol);\n\n    // Sets currentBalance to the active balance of the protocol\n    uint256 currentBalance = activeBalances[_protocol];\n    // Reverts if trying to withdraw more than the active balance\n    if (_amount &gt; currentBalance) revert InsufficientBalance(_protocol);\n\n    // Removes the _amount to be withdrawn from the active balance\n    activeBalances[_protocol] = currentBalance - _amount;\n    // Reverts if a protocol has less than 7 days worth of active balance left\n    if (_secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);\n\n    // Transfers the amount to the msg.sender (protocol agent)\n    token.safeTransfer(msg.sender, _amount);\n    emit ProtocolBalanceWithdrawn(_protocol, _amount);\n  }\n\n  /// @notice Transfer protocol agent role\n  /// @param _protocol Protocol identifier\n  /// @param _protocolAgent Account able to submit a claim on behalf of the protocol\n  /// @dev Only the active protocolAgent is able to transfer the role\n  function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)\n    external\n    override\n    whenNotPaused\n  {\n    if (_protocolAgent == address(0)) revert ZeroArgument();\n    // Can\'t set the new protocol agent to the caller address\n    if (msg.sender == _protocolAgent) revert InvalidArgument();\n    // Because the caller must be the current protocol agent\n    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();\n\n    // Sets the protocol agent to the new address\n    _setProtocolAgent(_protocol, msg.sender, _protocolAgent);\n  }\n\n  /// @notice Function used to check if this is the current active protocol manager\n  /// @return Boolean indicating it\'s active\n  /// @dev If inactive the owner can pull all ERC20s and ETH\n  /// @dev Will be checked by calling the sherlock contract\n  function isActive() public view returns (bool) {\n    return address(sherlockCore.sherlockProtocolManager()) == address(this);\n  }\n\n  // Only contract owner can call this\n  // Sends all specified tokens in this contract to the receiver\'s address (as well as ETH)\n  function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {\n    if (_receiver == address(0)) revert ZeroArgument();\n    // This contract must NOT be the current assigned protocol manager contract\n    if (isActive()) revert InvalidConditions();\n    // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH\n    _sweep(_receiver, _extraTokens);\n  }\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-25-08 10:59:21 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import './Manager.sol'; import '../interfaces/managers/ISherlockProtocolManager.sol'; /// @title Sherlock core interface for protocols /// @author Evert Kors // This is the contract that manages covered protocols contract SherlockProtocolManager is ISherlockProtocolManager, Manager {   using SafeERC20 for IERC20; // Represents the token that protocols pay with (currently USDC)   IERC20 public immutable token; // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed   uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc // A removed protocol is still able to make a claim for this amount of time after its removal   uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days; // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance   uint256 public constant MIN_SECONDS_LEFT = 7 days; // Convenient for percentage calculations   uint256 internal constant HUNDRED_PERCENT = 10**18; // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage   // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying   uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours; // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)   mapping(bytes32 =&gt; address) internal protocolAgent_; // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)   mapping(bytes32 =&gt; uint256) internal nonStakersPercentage; // The premium per second paid by each protocol is stored in this mapping   mapping(bytes32 =&gt; uint256) internal premiums_; // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.   // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not   mapping(bytes32 =&gt; uint256) internal activeBalances; // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol   mapping(bytes32 =&gt; uint256) internal lastAccountedEachProtocol; // The amount that can be claimed by nonstakers for each protocol   // We need this value so we can track how much payment is coming from each protocol   mapping(bytes32 =&gt; uint256) internal nonStakersClaimableByProtocol; // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)   uint256 internal lastAccountedGlobal; // This is the total amount of premiums paid (per second) by all the covered protocols (added up)   uint256 internal allPremiumsPerSecToStakers; // This is the amount that was claimable by stakers the last time the accounting was run   // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date   uint256 internal lastClaimablePremiumsForStakers; // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage   // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)   uint256 public override minActiveBalance; // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)   mapping(bytes32 =&gt; uint256) internal removedProtocolClaimDeadline; // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)   mapping(bytes32 =&gt; address) internal removedProtocolAgent; // Current amount of coverage (i.e. 20M USDC) for a protocol   mapping(bytes32 =&gt; uint256) internal currentCoverage; // Previous amount of coverage for a protocol   // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount   mapping(bytes32 =&gt; uint256) internal previousCoverage; // Setting the token to USDC   constructor(IERC20 _token) {     if (address(_token) == address(0)) revert ZeroArgument();     token = _token;   } // Modifier used to ensure a protocol exists (has been instantiated and not removed)   modifier protocolExists(bytes32 protocol) {     _verifyProtocolExists(_protocol);     ;   } /// @notice View current protocolAgent of _protocol   /// @param protocol Protocol identifier   /// @return Address able to submit claims   function protocolAgent(bytes32 _protocol) external view override returns (address) {     address agent = protocolAgent[_protocol];     if (agent != address(0)) return agent; // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned // Note: Old protocol agent will never be address(0) if (block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]) {   return removedProtocolAgent[_protocol]; }  // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned revert ProtocolNotExists(_protocol);  } // Checks if the protocol exists, then returns the current premium per second being charged   /// @notice View current premium of protocol   /// @param protocol Protocol identifier   /// @return Amount of premium _protocol pays per second   function premium(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return premiums[_protocol];   } // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)   // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)   function verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {     _protocolAgent = protocolAgent[_protocol];     if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);   } //   // View methods   // // Calcs the debt accrued by the protocol since it last had an accounting update   // This is the amount that needs to be removed from a protocol's active balance   function calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {     return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums[_protocol];   } /// @notice View the amount nonstakers can claim from this protocol   /// @param _protocol Protocol identifier   /// @return Amount of tokens claimable by nonstakers   /// @dev this reads from a storage variable + (now-lastsettled) * premiums   // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]   // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed   function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {     // Calcs the debt of a protocol since the last accounting update     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     // Gets the active balance of the protocol     uint256 balance = activeBalances[_protocol];     // The debt should never be higher than the balance (only happens if the arbitrages fail)     if (debt &gt; balance) debt = balance; // Adds the incremental claimable amount owed to nonstakers to the total claimable amount return   nonStakersClaimableByProtocol[_protocol] +   (nonStakersPercentage[_protocol] * debt) /   HUNDRED_PERCENT;  } /// @notice View current amount of all premiums that are owed to stakers   /// @return Premiums claimable   /// @dev Will increase every block   /// @dev base + (now - last_settled) * ps   function claimablePremiums() public view override returns (uint256) {     // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)     return       lastClaimablePremiumsForStakers +       (block.timestamp - lastAccountedGlobal) *       allPremiumsPerSecToStakers;   } /// @notice View seconds of coverage left for _protocol before it runs out of active balance   /// @param _protocol Protocol identifier   /// @return Seconds of coverage left   function secondsOfCoverageLeft(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return _secondsOfCoverageLeft(_protocol);   } // Helper function to return seconds of coverage left for a protocol   // Gets the current active balance of the protocol and divides by the premium per second for the protocol   function secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {     uint256 premium = premiums[_protocol];     if (premium == 0) return 0;     return _activeBalance(_protocol) / premium;   } /// @notice View current active balance of covered protocol   /// @param _protocol Protocol identifier   /// @return Active balance   /// @dev Accrued debt is subtracted from the stored active balance   function activeBalance(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return _activeBalance(_protocol);   } // Helper function to calc the active balance of a protocol at current time   function _activeBalance(bytes32 _protocol) internal view returns (uint256) {     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     uint256 balance = activeBalances[_protocol];     // The debt should never be higher than the balance (only happens if the arbitrages fail)     if (debt &gt; balance) return 0;     return balance - debt;   } //   // State methods   // /// @notice Helps set the premium per second for an individual protocol   /// @param protocol Protocol identifier   /// @param _premium New premium per second   /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function   function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)     internal     returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)   {     // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers     // Also updates the last accounted timestamp for this protocol     // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings     // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol     nonStakerPercentage = _settleProtocolDebt(_protocol);     // Stores the old premium before it gets updated     oldPremiumPerSecond = premiums[_protocol]; if (oldPremiumPerSecond != _premium) {   // Sets the protocol's premium per second to the new value   premiums_[_protocol] = _premium;   emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium); } // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point // Where arbs would no longer be incentivized to remove the protocol // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems if (_premium != 0 &amp;&amp; _secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_OF_COVERAGE) {   revert InsufficientBalance(_protocol); }  } /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second   /// @param _protocol Protocol identifier   /// @param _premium New premium per second   function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {     // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings     (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(       _protocol,       _premium     );     // Settling the total amount of premiums owed to stakers before a new premium per second gets set     _settleTotalDebt();     // This calculates the new global premium per second that gets paid to stakers     // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function     allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(       oldPremiumPerSecond,       _premium,       nonStakerPercentage,       nonStakerPercentage,       allPremiumsPerSecToStakers     );   } // Internal function to set a new protocolAgent for a specific protocol   // oldAgent is only included as part of emitting an event   function _setProtocolAgent(     bytes32 _protocol,     address _oldAgent,     address _protocolAgent   ) internal {     protocolAgent[_protocol] = _protocolAgent;     emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);   } // Subtracts the accrued debt from a protocol's active balance   // Credits the amount that can be claimed by nonstakers for this protocol   // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings   // Most of this function is dealing with an edge case related to a protocol not being removed by arbs   function settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {     // This calcs the accrued debt of the protocol since it was last updated     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     // This pulls the percentage that is sent to nonstakers     _nonStakerPercentage = nonStakersPercentage[_protocol];     // In case the protocol has accrued debt, this code block will ensure the debt is settled properly     if (debt != 0) {       // Pulls the stored active balance of the protocol       uint256 balance = activeBalances[_protocol];       // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance       // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point       // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage       // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up       if (debt &gt; balance) {         // This error amount represents the magnitude of the mistake         uint256 error = debt - balance;         // Gets the latest value of claimable premiums for stakers         _settleTotalDebt();         // @note to production, set premium first to zero before solving accounting issue.         // otherwise the accounting error keeps increasing         uint256 lastClaimablePremiumsForStakers = lastClaimablePremiumsForStakers;     // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%     uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /       HUNDRED_PERCENT;      // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short     uint256 insufficientTokens;      // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally     // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error     // This first line can be true if claimPremiumsForStakers() has been called and     // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be &gt;0 still     if (claimablePremiumError &gt; lastClaimablePremiumsForStakers_) {       insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;       lastClaimablePremiumsForStakers = 0;     } else {       // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums       // By the amount that was added in error (error) and insufficientTokens = 0       lastClaimablePremiumsForStakers =         lastClaimablePremiumsForStakers_ -         claimablePremiumError;     }      // If two events are thrown, the values need to be summed up for the actual state.     // This means an error of this type will continue until it is handled     emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);     // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case     debt = balance;   }   // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance   activeBalances[_protocol] = balance - debt;   // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol   nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT; } // Updates the last accounted timestamp for this protocol lastAccountedEachProtocol[_protocol] = block.timestamp;  } // Multiplies the total premium per second * number of seconds since the last global accounting update   // And adds it to the total claimable amount for stakers   function _settleTotalDebt() internal {     lastClaimablePremiumsForStakers +=       (block.timestamp - lastAccountedGlobal) *       allPremiumsPerSecToStakers;     lastAccountedGlobal = block.timestamp;   } // Calculates the global premium per second for stakers   // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers   // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones   function _calcGlobalPremiumPerSecForStakers(     uint256 _premiumOld,     uint256 _premiumNew,     uint256 _nonStakerPercentageOld,     uint256 _nonStakerPercentageNew,     uint256 _inMemAllPremiumsPerSecToStakers   ) internal pure returns (uint256) {     return       _inMemAllPremiumsPerSecToStakers +       ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /       HUNDRED_PERCENT -       ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /       HUNDRED_PERCENT;   } // Helper function to remove and clean up a protocol from Sherlock   // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made   function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {     // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol     _setSingleAndGlobalProtocolPremium(_protocol, 0); // Grabs the protocol's active balance uint256 balance = activeBalances[_protocol];  // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent if (balance != 0) {   delete activeBalances[_protocol];   token.safeTransfer(_agent, balance);    emit ProtocolBalanceWithdrawn(_protocol, balance); }  // Sets the protocol agent to zero address (as part of clean up) _setProtocolAgent(_protocol, _agent, address(0));  // Cleans up other mappings for this protocol delete nonStakersPercentage[_protocol]; delete lastAccountedEachProtocol[_protocol]; // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above  // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;  // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked removedProtocolAgent[_protocol] = _agent;  emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0)); emit ProtocolRemoved(_protocol);  } /// @notice Sets the minimum active balance before an arb can remove a protocol   /// @param _minActiveBalance Minimum balance needed (in USDC)   /// @dev Only gov   function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {     // New value cannot be the same as current value     if (minActiveBalance == _minActiveBalance) revert InvalidArgument();     // Can't set a value that is too high to be reasonable     if (_minActiveBalance &gt;= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions(); emit MinBalance(minActiveBalance, _minActiveBalance); minActiveBalance = _minActiveBalance;  } // This function allows the nonstakers role to claim tokens owed to them by a specific protocol   /// @notice Choose an _amount of tokens that nonstakers (_receiver address) will receive from _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens   /// @param _receiver Address to receive tokens   /// @dev Only callable by nonstakers role   function nonStakersClaim(     bytes32 _protocol,     uint256 _amount,     address _receiver   ) external override whenNotPaused {     if (_protocol == bytes32(0)) revert ZeroArgument();     if (_amount == uint256(0)) revert ZeroArgument();     if (_receiver == address(0)) revert ZeroArgument();     // Only the nonstakers role (multisig or contract) can pull the funds     if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized(); // Call can't be executed on protocol that is removed if (protocolAgent_[_protocol] != address(0)) {   // Updates the amount that nonstakers can claim from this protocol   _settleProtocolDebt(_protocol); }  // Sets balance to the amount that is claimable by nonstakers for this specific protocol uint256 balance = nonStakersClaimableByProtocol[_protocol]; // If the amount requested is more than what's owed to nonstakers, revert if (_amount &gt; balance) revert InsufficientBalance(_protocol);  // Sets the claimable amount to whatever is left over after this amount is pulled nonStakersClaimableByProtocol[_protocol] = balance - _amount; // Transfers the amount requested to the `_receiver` address token.safeTransfer(_receiver, _amount);  } // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)   /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address   /// @dev Callable by everyone   /// @dev Funds will be transferred to Sherlock core contract   function claimPremiumsForStakers() external override whenNotPaused {     // Gets address of core Sherlock contract     address sherlock = address(sherlockCore);     // Revert if core Sherlock contract not initialized yet     if (sherlock == address(0)) revert InvalidConditions(); // claimablePremiums is different from _settleTotalDebt() because it does not change state // Retrieves current amount of all premiums that are owed to stakers uint256 amount = claimablePremiums();  // Transfers all the premiums owed to stakers to the Sherlock core contract if (amount != 0) {   // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out   lastClaimablePremiumsForStakers = 0;   lastAccountedGlobal = block.timestamp;   token.safeTransfer(sherlock, amount); }  } // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts   /// @param protocol Protocol identifier   /// @return current and previous are the current and previous coverage amounts for this protocol   // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)   function coverageAmounts(bytes32 _protocol)     external     view     override     returns (uint256 current, uint256 previous)   {     // Checks to see if the protocol has an active protocolAgent (protocol not removed)     // OR checks to see if the removed protocol is still within the claim window     // If so, gives the current and previous coverage, otherwise throws an error     if (       protocolAgent[_protocol] != address(0) ||       block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]     ) {       return (currentCoverage[_protocol], previousCoverage[_protocol]);     } revert ProtocolNotExists(_protocol);  } /// @notice Add a new protocol to Sherlock   /// @param protocol Protocol identifier   /// @param _protocolAgent Address able to submit a claim on behalf of the protocol   /// @param _coverage Hash referencing the active coverage agreement   /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 1018   /// @param _coverageAmount Max amount claimable by this protocol   /// @dev Adding a protocol allows the _protocolAgent to submit a claim   /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point   /// @dev _nonStakers is scaled by 1018   /// @dev Only callable by governance   function protocolAdd(     bytes32 _protocol,     address _protocolAgent,     bytes32 _coverage,     uint256 _nonStakers,     uint256 _coverageAmount   ) external override onlyOwner {     if (_protocol == bytes32(0)) revert ZeroArgument();     if (_protocolAgent == address(0)) revert ZeroArgument();     // Checks to make sure the protocol doesn't exist already     if (protocolAgent[_protocol] != address(0)) revert InvalidConditions(); // Updates the protocol agent and passes in the old agent which is 0 address in this case _setProtocolAgent(_protocol, address(0), _protocolAgent);  // Delete mappings that are potentially non default values // From previous time protocol was added/removed delete removedProtocolClaimDeadline[_protocol]; delete removedProtocolAgent[_protocol]; delete currentCoverage[_protocol]; delete previousCoverage[_protocol];  emit ProtocolAdded(_protocol);  // Most of the logic for actually adding a protocol in this function protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);  } /// @notice Update info regarding a protocol   /// @param _protocol Protocol identifier   /// @param _coverage Hash referencing the active coverage agreement   /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18   /// @param _coverageAmount Max amount claimable by this protocol   /// @dev Only callable by governance   /// @dev _nonStakers can be 0   function protocolUpdate(     bytes32 _protocol,     bytes32 _coverage,     uint256 _nonStakers,     uint256 _coverageAmount   ) public override onlyOwner {     if (_coverage == bytes32(0)) revert ZeroArgument();     if (_nonStakers &gt; HUNDRED_PERCENT) revert InvalidArgument();     if (_coverageAmount == uint256(0)) revert ZeroArgument(); // Checks to make sure the protocol has been assigned a protocol agent _verifyProtocolExists(_protocol);  // Subtracts the accrued debt from a protocol's active balance (if any) // Updates the amount that can be claimed by nonstakers _settleProtocolDebt(_protocol);  // Updates the global claimable amount for stakers _settleTotalDebt();  // Gets the premium per second for this protocol uint256 premium = premiums_[_protocol];  // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be) allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(   premium,   premium,   nonStakersPercentage[_protocol],   _nonStakers,   allPremiumsPerSecToStakers );  // Updates the stored value of percentage of premiums that go to nonstakers nonStakersPercentage[_protocol] = _nonStakers;  // Updates previous coverage and current coverage amounts previousCoverage[_protocol] = currentCoverage[_protocol]; currentCoverage[_protocol] = _coverageAmount;  emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);  } /// @notice Remove a protocol from coverage   /// @param _protocol Protocol identifier   /// @dev Before removing a protocol the premium must be 0   /// @dev Removing a protocol basically stops the _protocolAgent from being active (can still submit claims until claim deadline though)   /// @dev Pays off debt + sends remaining balance to protocol agent   /// @dev This call should be subject to a timelock   /// @dev Only callable by governance   function protocolRemove(bytes32 _protocol) external override onlyOwner {     // checks to make sure the protocol actually has a protocol agent     address agent = _verifyProtocolExists(_protocol); // Removes a protocol from Sherlock and cleans up its data // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made _forceRemoveProtocol(_protocol, agent);  } /// @notice Remove a protocol with insufficient active balance   /// @param _protocol Protocol identifier   // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function   function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {     address agent = _verifyProtocolExists(_protocol); // Gets the latest value of the active balance at this protocol _settleProtocolDebt(_protocol); // Sets latest value of active balance to remainingBalance variable uint256 remainingBalance = activeBalances[_protocol];  // This means the protocol still has adequate active balance and thus cannot be removed if (remainingBalance &gt;= minActiveBalance) revert InvalidConditions();  // Sets the protocol's active balance to 0 delete activeBalances[_protocol]; // Removes the protocol from coverage _forceRemoveProtocol(_protocol, agent);  if (remainingBalance != 0) {   // sends the remaining balance to msg.sender   token.safeTransfer(msg.sender, remainingBalance); } emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);  } /// @notice Calculate if arb is possible and what the reward would be   /// @param _protocol Protocol identifier   /// @return arbAmount Amount reward for arbing   /// @return able Indicator if arb call is even possible   /// @dev Doesn't subtract the current protocol debt from the active balance   function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)     internal     view     returns (uint256 arbAmount, bool able)   {     uint256 secondsLeft = _secondsOfCoverageLeft(_protocol); // If arb is not possible return false if (secondsLeft &gt;= MIN_SECONDS_OF_COVERAGE) return (0, false);  // This percentage scales over time // Reaches 100% on 0 seconds of coverage left uint256 percentageScaled = HUNDRED_PERCENT -   (secondsLeft * HUNDRED_PERCENT) /   MIN_SECONDS_OF_COVERAGE;  able = true; arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;  } /// @notice Removes a protocol with insufficent seconds of coverage left   /// @param _protocol Protocol identifier   // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second   function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {     // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings     address agent = _verifyProtocolExists(_protocol); // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance() // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance() // But when removing based on seconds of coverage left, the remainingBalance could still be quite large // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%) _settleProtocolDebt(_protocol); (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol); if (able == false) revert InvalidConditions();  if (arbAmount != 0) {   // subtracts the amount that will be paid to the arb from the active balance   activeBalances[_protocol] -= arbAmount; }  // Removes the protocol from coverage // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above _forceRemoveProtocol(_protocol, agent);  // Done after removing protocol to mitigate reentrency pattern // (In case token allows callback) if (arbAmount != 0) {   token.safeTransfer(msg.sender, arbAmount); } emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);  } /// @notice Set premium of _protocol to _premium   /// @param _protocol Protocol identifier   /// @param _premium Amount of premium _protocol pays per second   /// @dev The value 0 would mean inactive coverage   /// @dev Only callable by governance   function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {     // Checks to see if protocol has a protocol agent     _verifyProtocolExists(_protocol); // Updates individual protocol's premium and allPremiumsPerSecToStakers _setSingleAndGlobalProtocolPremium(_protocol, _premium);  } /// @notice Set premium of multiple protocols   /// @param _protocol Array of protocol identifiers   /// @param _premium Array of premium amounts protocols pay per second   /// @dev The value 0 would mean inactive coverage   /// @dev Only callable by governance   function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)     external     override     onlyOwner   {     // Checks to make sure there are an equal amount of entries in each array     if (_protocol.length != _premium.length) revert UnequalArrayLength();     if (_protocol.length == 0) revert InvalidArgument(); // Updates the global claimable amount for stakers _settleTotalDebt();  uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;  // Loops through the array of protocols and checks to make sure each has a protocol agent assigned for (uint256 i; i &lt; _protocol.length; i++) {   _verifyProtocolExists(_protocol[i]);    // Sets the protocol premium for that specific protocol   // Function returns the old premium and nonStakerPercentage for that specific protocol   (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(     _protocol[i],     _premium[i]   );    // Calculates the new global premium which adds up all premiums paid by all protocols   allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(     oldPremiumPerSecond,     _premium[i],     nonStakerPercentage,     nonStakerPercentage,     allPremiumsPerSecToStakers_   ); }  // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;  } // This is how protocols pay for coverage by increasing their active balance   /// @notice Deposits _amount of token to the active balance of _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens to deposit   /// @dev Approval should be made before calling   function depositToActiveBalance(bytes32 _protocol, uint256 _amount)     external     override     whenNotPaused   {     if (_amount == uint256(0)) revert ZeroArgument();     _verifyProtocolExists(_protocol); // Transfers _amount to this contract token.safeTransferFrom(msg.sender, address(this), _amount); // Increases the active balance of the protocol by _amount activeBalances[_protocol] += _amount;  emit ProtocolBalanceDeposited(_protocol, _amount);  } // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)   // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)   /// @notice Withdraws _amount of token from the active balance of _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens to withdraw   /// @dev Only protocol agent is able to withdraw   /// @dev Balance can be withdrawn up until 7 days worth of active balance   function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)     external     override     whenNotPaused   {     if (_amount == uint256(0)) revert ZeroArgument();     // Only the protocol agent can call this function     if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized(); // Updates the active balance of the protocol _settleProtocolDebt(_protocol);  // Sets currentBalance to the active balance of the protocol uint256 currentBalance = activeBalances[_protocol]; // Reverts if trying to withdraw more than the active balance if (_amount &gt; currentBalance) revert InsufficientBalance(_protocol);  // Removes the _amount to be withdrawn from the active balance activeBalances[_protocol] = currentBalance - _amount; // Reverts if a protocol has less than 7 days worth of active balance left if (_secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);  // Transfers the amount to the msg.sender (protocol agent) token.safeTransfer(msg.sender, _amount); emit ProtocolBalanceWithdrawn(_protocol, _amount);  } /// @notice Transfer protocol agent role   /// @param _protocol Protocol identifier   /// @param _protocolAgent Account able to submit a claim on behalf of the protocol   /// @dev Only the active protocolAgent is able to transfer the role   function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)     external     override     whenNotPaused   {     if (_protocolAgent == address(0)) revert ZeroArgument();     // Can't set the new protocol agent to the caller address     if (msg.sender == _protocolAgent) revert InvalidArgument();     // Because the caller must be the current protocol agent     if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized(); // Sets the protocol agent to the new address _setProtocolAgent(_protocol, msg.sender, _protocolAgent);  } /// @notice Function used to check if this is the current active protocol manager   /// @return Boolean indicating it's active   /// @dev If inactive the owner can pull all ERC20s and ETH   /// @dev Will be checked by calling the sherlock contract   function isActive() public view returns (bool) {     return address(sherlockCore.sherlockProtocolManager()) == address(this);   } // Only contract owner can call this   // Sends all specified tokens in this contract to the receiver's address (as well as ETH)   function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {     if (_receiver == address(0)) revert ZeroArgument();     // This contract must NOT be the current assigned protocol manager contract     if (isActive()) revert InvalidConditions();     // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH     _sweep(_receiver, _extraTokens);   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-25-08 10:59:21 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import './Manager.sol';
import '../interfaces/managers/ISherlockProtocolManager.sol';

/// @title Sherlock core interface for protocols
/// @author Evert Kors
// This is the contract that manages covered protocols

contract SherlockProtocolManager is ISherlockProtocolManager, Manager {
  using SafeERC20 for IERC20;

  // Represents the token that protocols pay with (currently USDC)
  IERC20 public immutable token;

  // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed
  uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc

  // A removed protocol is still able to make a claim for this amount of time after its removal
  uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days;

  // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance
  uint256 public constant MIN_SECONDS_LEFT = 7 days;

  // Convenient for percentage calculations
  uint256 internal constant HUNDRED_PERCENT = 10**18;

  // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage
  // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying
  uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours;

  // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)
  mapping(bytes32 => address) internal protocolAgent_;

  // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)
  mapping(bytes32 => uint256) internal nonStakersPercentage;

  // The premium per second paid by each protocol is stored in this mapping
  mapping(bytes32 => uint256) internal premiums_;

  // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.
  // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not
  mapping(bytes32 => uint256) internal activeBalances;

  // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol
  mapping(bytes32 => uint256) internal lastAccountedEachProtocol;

  // The amount that can be claimed by nonstakers for each protocol
  // We need this value so we can track how much payment is coming from each protocol
  mapping(bytes32 => uint256) internal nonStakersClaimableByProtocol;

  // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)
  uint256 internal lastAccountedGlobal;

  // This is the total amount of premiums paid (per second) by all the covered protocols (added up)
  uint256 internal allPremiumsPerSecToStakers;

  // This is the amount that was claimable by stakers the last time the accounting was run
  // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date
  uint256 internal lastClaimablePremiumsForStakers;

  // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage
  // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)
  uint256 public override minActiveBalance;

  // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)
  mapping(bytes32 => uint256) internal removedProtocolClaimDeadline;

  // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)
  mapping(bytes32 => address) internal removedProtocolAgent;

  // Current amount of coverage (i.e. 20M USDC) for a protocol
  mapping(bytes32 => uint256) internal currentCoverage;

  // Previous amount of coverage for a protocol
  // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount
  mapping(bytes32 => uint256) internal previousCoverage;

  // Setting the token to USDC
  constructor(IERC20 _token) {
    if (address(_token) == address(0)) revert ZeroArgument();
    token = _token;
  }

  // Modifier used to ensure a protocol exists (has been instantiated and not removed)
  modifier protocolExists(bytes32 _protocol) {
    _verifyProtocolExists(_protocol);
    _;
  }

  /// @notice View current protocolAgent of `_protocol`
  /// @param _protocol Protocol identifier
  /// @return Address able to submit claims
  function protocolAgent(bytes32 _protocol) external view override returns (address) {
    address agent = protocolAgent_[_protocol];
    if (agent != address(0)) return agent;

    // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned
    // Note: Old protocol agent will never be address(0)
    if (block.timestamp <= removedProtocolClaimDeadline[_protocol]) {
      return removedProtocolAgent[_protocol];
    }

    // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned
    revert ProtocolNotExists(_protocol);
  }

  // Checks if the protocol exists, then returns the current premium per second being charged
  /// @notice View current premium of protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of premium `_protocol` pays per second
  function premium(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return premiums_[_protocol];
  }

  // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)
  // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)
  function _verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {
    _protocolAgent = protocolAgent_[_protocol];
    if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);
  }

  //
  // View methods
  //

  // Calcs the debt accrued by the protocol since it last had an accounting update
  // This is the amount that needs to be removed from a protocol's active balance
  function _calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {
    return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums_[_protocol];
  }

  /// @notice View the amount nonstakers can claim from this protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of tokens claimable by nonstakers
  /// @dev this reads from a storage variable + (now-lastsettled) * premiums
  // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]
  // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed
  function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {
    // Calcs the debt of a protocol since the last accounting update
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // Gets the active balance of the protocol
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) debt = balance;

    // Adds the incremental claimable amount owed to nonstakers to the total claimable amount
    return
      nonStakersClaimableByProtocol[_protocol] +
      (nonStakersPercentage[_protocol] * debt) /
      HUNDRED_PERCENT;
  }

  /// @notice View current amount of all premiums that are owed to stakers
  /// @return Premiums claimable
  /// @dev Will increase every block
  /// @dev base + (now - last_settled) * ps
  function claimablePremiums() public view override returns (uint256) {
    // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)
    return
      lastClaimablePremiumsForStakers +
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
  }

  /// @notice View seconds of coverage left for `_protocol` before it runs out of active balance
  /// @param _protocol Protocol identifier
  /// @return Seconds of coverage left
  function secondsOfCoverageLeft(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _secondsOfCoverageLeft(_protocol);
  }

  // Helper function to return seconds of coverage left for a protocol
  // Gets the current active balance of the protocol and divides by the premium per second for the protocol
  function _secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {
    uint256 premium = premiums_[_protocol];
    if (premium == 0) return 0;
    return _activeBalance(_protocol) / premium;
  }

  /// @notice View current active balance of covered protocol
  /// @param _protocol Protocol identifier
  /// @return Active balance
  /// @dev Accrued debt is subtracted from the stored active balance
  function activeBalance(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _activeBalance(_protocol);
  }

  // Helper function to calc the active balance of a protocol at current time
  function _activeBalance(bytes32 _protocol) internal view returns (uint256) {
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) return 0;
    return balance - debt;
  }

  //
  // State methods
  //

  /// @notice Helps set the premium per second for an individual protocol
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function
  function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)
    internal
    returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)
  {
    // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers
    // Also updates the last accounted timestamp for this protocol
    // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings
    // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol
    nonStakerPercentage = _settleProtocolDebt(_protocol);
    // Stores the old premium before it gets updated
    oldPremiumPerSecond = premiums_[_protocol];

    if (oldPremiumPerSecond != _premium) {
      // Sets the protocol's premium per second to the new value
      premiums_[_protocol] = _premium;
      emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium);
    }
    // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing
    // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes
    // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point
    // Where arbs would no longer be incentivized to remove the protocol
    // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems
    if (_premium != 0 && _secondsOfCoverageLeft(_protocol) < MIN_SECONDS_OF_COVERAGE) {
      revert InsufficientBalance(_protocol);
    }
  }

  /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {
    // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings
    (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
      _protocol,
      _premium
    );
    // Settling the total amount of premiums owed to stakers before a new premium per second gets set
    _settleTotalDebt();
    // This calculates the new global premium per second that gets paid to stakers
    // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      oldPremiumPerSecond,
      _premium,
      nonStakerPercentage,
      nonStakerPercentage,
      allPremiumsPerSecToStakers
    );
  }

  // Internal function to set a new protocolAgent for a specific protocol
  // _oldAgent is only included as part of emitting an event
  function _setProtocolAgent(
    bytes32 _protocol,
    address _oldAgent,
    address _protocolAgent
  ) internal {
    protocolAgent_[_protocol] = _protocolAgent;
    emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);
  }

  // Subtracts the accrued debt from a protocol's active balance
  // Credits the amount that can be claimed by nonstakers for this protocol
  // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings
  // Most of this function is dealing with an edge case related to a protocol not being removed by arbs
  function _settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {
    // This calcs the accrued debt of the protocol since it was last updated
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // This pulls the percentage that is sent to nonstakers
    _nonStakerPercentage = nonStakersPercentage[_protocol];
    // In case the protocol has accrued debt, this code block will ensure the debt is settled properly
    if (debt != 0) {
      // Pulls the stored active balance of the protocol
      uint256 balance = activeBalances[_protocol];
      // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance
      // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point
      // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage
      // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up
      if (debt > balance) {
        // This error amount represents the magnitude of the mistake
        uint256 error = debt - balance;
        // Gets the latest value of claimable premiums for stakers
        _settleTotalDebt();
        // @note to production, set premium first to zero before solving accounting issue.
        // otherwise the accounting error keeps increasing
        uint256 lastClaimablePremiumsForStakers_ = lastClaimablePremiumsForStakers;

        // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%
        uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /
          HUNDRED_PERCENT;

        // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short
        uint256 insufficientTokens;

        // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally
        // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error
        // This first line can be true if claimPremiumsForStakers() has been called and
        // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be >0 still
        if (claimablePremiumError > lastClaimablePremiumsForStakers_) {
          insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;
          lastClaimablePremiumsForStakers = 0;
        } else {
          // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums
          // By the amount that was added in error (error) and insufficientTokens = 0
          lastClaimablePremiumsForStakers =
            lastClaimablePremiumsForStakers_ -
            claimablePremiumError;
        }

        // If two events are thrown, the values need to be summed up for the actual state.
        // This means an error of this type will continue until it is handled
        emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);
        // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case
        debt = balance;
      }
      // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance
      activeBalances[_protocol] = balance - debt;
      // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol
      nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT;
    }
    // Updates the last accounted timestamp for this protocol
    lastAccountedEachProtocol[_protocol] = block.timestamp;
  }

  // Multiplies the total premium per second * number of seconds since the last global accounting update
  // And adds it to the total claimable amount for stakers
  function _settleTotalDebt() internal {
    lastClaimablePremiumsForStakers +=
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
    lastAccountedGlobal = block.timestamp;
  }

  // Calculates the global premium per second for stakers
  // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers
  // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones
  function _calcGlobalPremiumPerSecForStakers(
    uint256 _premiumOld,
    uint256 _premiumNew,
    uint256 _nonStakerPercentageOld,
    uint256 _nonStakerPercentageNew,
    uint256 _inMemAllPremiumsPerSecToStakers
  ) internal pure returns (uint256) {
    return
      _inMemAllPremiumsPerSecToStakers +
      ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /
      HUNDRED_PERCENT -
      ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /
      HUNDRED_PERCENT;
  }

  // Helper function to remove and clean up a protocol from Sherlock
  // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made
  function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {
    // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol
    _setSingleAndGlobalProtocolPremium(_protocol, 0);

    // Grabs the protocol's active balance
    uint256 balance = activeBalances[_protocol];

    // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent
    if (balance != 0) {
      delete activeBalances[_protocol];
      token.safeTransfer(_agent, balance);

      emit ProtocolBalanceWithdrawn(_protocol, balance);
    }

    // Sets the protocol agent to zero address (as part of clean up)
    _setProtocolAgent(_protocol, _agent, address(0));

    // Cleans up other mappings for this protocol
    delete nonStakersPercentage[_protocol];
    delete lastAccountedEachProtocol[_protocol];
    // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above

    // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol
    removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;

    // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed
    // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked
    removedProtocolAgent[_protocol] = _agent;

    emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0));
    emit ProtocolRemoved(_protocol);
  }

  /// @notice Sets the minimum active balance before an arb can remove a protocol
  /// @param _minActiveBalance Minimum balance needed (in USDC)
  /// @dev Only gov
  function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {
    // New value cannot be the same as current value
    if (minActiveBalance == _minActiveBalance) revert InvalidArgument();
    // Can't set a value that is too high to be reasonable
    if (_minActiveBalance >= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions();

    emit MinBalance(minActiveBalance, _minActiveBalance);
    minActiveBalance = _minActiveBalance;
  }

  // This function allows the nonstakers role to claim tokens owed to them by a specific protocol
  /// @notice Choose an `_amount` of tokens that nonstakers (`_receiver` address) will receive from `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens
  /// @param _receiver Address to receive tokens
  /// @dev Only callable by nonstakers role
  function nonStakersClaim(
    bytes32 _protocol,
    uint256 _amount,
    address _receiver
  ) external override whenNotPaused {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_amount == uint256(0)) revert ZeroArgument();
    if (_receiver == address(0)) revert ZeroArgument();
    // Only the nonstakers role (multisig or contract) can pull the funds
    if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized();

    // Call can't be executed on protocol that is removed
    if (protocolAgent_[_protocol] != address(0)) {
      // Updates the amount that nonstakers can claim from this protocol
      _settleProtocolDebt(_protocol);
    }

    // Sets balance to the amount that is claimable by nonstakers for this specific protocol
    uint256 balance = nonStakersClaimableByProtocol[_protocol];
    // If the amount requested is more than what's owed to nonstakers, revert
    if (_amount > balance) revert InsufficientBalance(_protocol);

    // Sets the claimable amount to whatever is left over after this amount is pulled
    nonStakersClaimableByProtocol[_protocol] = balance - _amount;
    // Transfers the amount requested to the `_receiver` address
    token.safeTransfer(_receiver, _amount);
  }

  // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)
  /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address
  /// @dev Callable by everyone
  /// @dev Funds will be transferred to Sherlock core contract
  function claimPremiumsForStakers() external override whenNotPaused {
    // Gets address of core Sherlock contract
    address sherlock = address(sherlockCore);
    // Revert if core Sherlock contract not initialized yet
    if (sherlock == address(0)) revert InvalidConditions();

    // claimablePremiums is different from _settleTotalDebt() because it does not change state
    // Retrieves current amount of all premiums that are owed to stakers
    uint256 amount = claimablePremiums();

    // Transfers all the premiums owed to stakers to the Sherlock core contract
    if (amount != 0) {
      // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out
      lastClaimablePremiumsForStakers = 0;
      lastAccountedGlobal = block.timestamp;
      token.safeTransfer(sherlock, amount);
    }
  }

  // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts
  /// @param _protocol Protocol identifier
  /// @return current and previous are the current and previous coverage amounts for this protocol
  // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)
  function coverageAmounts(bytes32 _protocol)
    external
    view
    override
    returns (uint256 current, uint256 previous)
  {
    // Checks to see if the protocol has an active protocolAgent (protocol not removed)
    // OR checks to see if the removed protocol is still within the claim window
    // If so, gives the current and previous coverage, otherwise throws an error
    if (
      protocolAgent_[_protocol] != address(0) ||
      block.timestamp <= removedProtocolClaimDeadline[_protocol]
    ) {
      return (currentCoverage[_protocol], previousCoverage[_protocol]);
    }

    revert ProtocolNotExists(_protocol);
  }

  /// @notice Add a new protocol to Sherlock
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Address able to submit a claim on behalf of the protocol
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Adding a protocol allows the `_protocolAgent` to submit a claim
  /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point
  /// @dev `_nonStakers` is scaled by 10**18
  /// @dev Only callable by governance
  function protocolAdd(
    bytes32 _protocol,
    address _protocolAgent,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) external override onlyOwner {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Checks to make sure the protocol doesn't exist already
    if (protocolAgent_[_protocol] != address(0)) revert InvalidConditions();

    // Updates the protocol agent and passes in the old agent which is 0 address in this case
    _setProtocolAgent(_protocol, address(0), _protocolAgent);

    // Delete mappings that are potentially non default values
    // From previous time protocol was added/removed
    delete removedProtocolClaimDeadline[_protocol];
    delete removedProtocolAgent[_protocol];
    delete currentCoverage[_protocol];
    delete previousCoverage[_protocol];

    emit ProtocolAdded(_protocol);

    // Most of the logic for actually adding a protocol in this function
    protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Update info regarding a protocol
  /// @param _protocol Protocol identifier
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Only callable by governance
  /// @dev `_nonStakers` can be 0
  function protocolUpdate(
    bytes32 _protocol,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) public override onlyOwner {
    if (_coverage == bytes32(0)) revert ZeroArgument();
    if (_nonStakers > HUNDRED_PERCENT) revert InvalidArgument();
    if (_coverageAmount == uint256(0)) revert ZeroArgument();

    // Checks to make sure the protocol has been assigned a protocol agent
    _verifyProtocolExists(_protocol);

    // Subtracts the accrued debt from a protocol's active balance (if any)
    // Updates the amount that can be claimed by nonstakers
    _settleProtocolDebt(_protocol);

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    // Gets the premium per second for this protocol
    uint256 premium = premiums_[_protocol];

    // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be)
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      premium,
      premium,
      nonStakersPercentage[_protocol],
      _nonStakers,
      allPremiumsPerSecToStakers
    );

    // Updates the stored value of percentage of premiums that go to nonstakers
    nonStakersPercentage[_protocol] = _nonStakers;

    // Updates previous coverage and current coverage amounts
    previousCoverage[_protocol] = currentCoverage[_protocol];
    currentCoverage[_protocol] = _coverageAmount;

    emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Remove a protocol from coverage
  /// @param _protocol Protocol identifier
  /// @dev Before removing a protocol the premium must be 0
  /// @dev Removing a protocol basically stops the `_protocolAgent` from being active (can still submit claims until claim deadline though)
  /// @dev Pays off debt + sends remaining balance to protocol agent
  /// @dev This call should be subject to a timelock
  /// @dev Only callable by governance
  function protocolRemove(bytes32 _protocol) external override onlyOwner {
    // checks to make sure the protocol actually has a protocol agent
    address agent = _verifyProtocolExists(_protocol);

    // Removes a protocol from Sherlock and cleans up its data
    // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made
    _forceRemoveProtocol(_protocol, agent);
  }

  /// @notice Remove a protocol with insufficient active balance
  /// @param _protocol Protocol identifier
  // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function
  function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {
    address agent = _verifyProtocolExists(_protocol);

    // Gets the latest value of the active balance at this protocol
    _settleProtocolDebt(_protocol);
    // Sets latest value of active balance to remainingBalance variable
    uint256 remainingBalance = activeBalances[_protocol];

    // This means the protocol still has adequate active balance and thus cannot be removed
    if (remainingBalance >= minActiveBalance) revert InvalidConditions();

    // Sets the protocol's active balance to 0
    delete activeBalances[_protocol];
    // Removes the protocol from coverage
    _forceRemoveProtocol(_protocol, agent);

    if (remainingBalance != 0) {
      // sends the remaining balance to msg.sender
      token.safeTransfer(msg.sender, remainingBalance);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);
  }

  /// @notice Calculate if arb is possible and what the reward would be
  /// @param _protocol Protocol identifier
  /// @return arbAmount Amount reward for arbing
  /// @return able Indicator if arb call is even possible
  /// @dev Doesn't subtract the current protocol debt from the active balance
  function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)
    internal
    view
    returns (uint256 arbAmount, bool able)
  {
    uint256 secondsLeft = _secondsOfCoverageLeft(_protocol);

    // If arb is not possible return false
    if (secondsLeft >= MIN_SECONDS_OF_COVERAGE) return (0, false);

    // This percentage scales over time
    // Reaches 100% on 0 seconds of coverage left
    uint256 percentageScaled = HUNDRED_PERCENT -
      (secondsLeft * HUNDRED_PERCENT) /
      MIN_SECONDS_OF_COVERAGE;

    able = true;
    arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;
  }

  /// @notice Removes a protocol with insufficent seconds of coverage left
  /// @param _protocol Protocol identifier
  // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second
  function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {
    // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings
    address agent = _verifyProtocolExists(_protocol);

    // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance()
    // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance()
    // But when removing based on seconds of coverage left, the remainingBalance could still be quite large
    // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance
    // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%)
    _settleProtocolDebt(_protocol);
    (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol);
    if (able == false) revert InvalidConditions();

    if (arbAmount != 0) {
      // subtracts the amount that will be paid to the arb from the active balance
      activeBalances[_protocol] -= arbAmount;
    }

    // Removes the protocol from coverage
    // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above
    _forceRemoveProtocol(_protocol, agent);

    // Done after removing protocol to mitigate reentrency pattern
    // (In case token allows callback)
    if (arbAmount != 0) {
      token.safeTransfer(msg.sender, arbAmount);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);
  }

  /// @notice Set premium of `_protocol` to `_premium`
  /// @param _protocol Protocol identifier
  /// @param _premium Amount of premium `_protocol` pays per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {
    // Checks to see if protocol has a protocol agent
    _verifyProtocolExists(_protocol);

    // Updates individual protocol's premium and allPremiumsPerSecToStakers
    _setSingleAndGlobalProtocolPremium(_protocol, _premium);
  }

  /// @notice Set premium of multiple protocols
  /// @param _protocol Array of protocol identifiers
  /// @param _premium Array of premium amounts protocols pay per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)
    external
    override
    onlyOwner
  {
    // Checks to make sure there are an equal amount of entries in each array
    if (_protocol.length != _premium.length) revert UnequalArrayLength();
    if (_protocol.length == 0) revert InvalidArgument();

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;

    // Loops through the array of protocols and checks to make sure each has a protocol agent assigned
    for (uint256 i; i < _protocol.length; i++) {
      _verifyProtocolExists(_protocol[i]);

      // Sets the protocol premium for that specific protocol
      // Function returns the old premium and nonStakerPercentage for that specific protocol
      (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
        _protocol[i],
        _premium[i]
      );

      // Calculates the new global premium which adds up all premiums paid by all protocols
      allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(
        oldPremiumPerSecond,
        _premium[i],
        nonStakerPercentage,
        nonStakerPercentage,
        allPremiumsPerSecToStakers_
      );
    }

    // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value
    allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;
  }

  // This is how protocols pay for coverage by increasing their active balance
  /// @notice Deposits `_amount` of token to the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to deposit
  /// @dev Approval should be made before calling
  function depositToActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    _verifyProtocolExists(_protocol);

    // Transfers _amount to this contract
    token.safeTransferFrom(msg.sender, address(this), _amount);
    // Increases the active balance of the protocol by _amount
    activeBalances[_protocol] += _amount;

    emit ProtocolBalanceDeposited(_protocol, _amount);
  }

  // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)
  // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)
  /// @notice Withdraws `_amount` of token from the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to withdraw
  /// @dev Only protocol agent is able to withdraw
  /// @dev Balance can be withdrawn up until 7 days worth of active balance
  function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    // Only the protocol agent can call this function
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Updates the active balance of the protocol
    _settleProtocolDebt(_protocol);

    // Sets currentBalance to the active balance of the protocol
    uint256 currentBalance = activeBalances[_protocol];
    // Reverts if trying to withdraw more than the active balance
    if (_amount > currentBalance) revert InsufficientBalance(_protocol);

    // Removes the _amount to be withdrawn from the active balance
    activeBalances[_protocol] = currentBalance - _amount;
    // Reverts if a protocol has less than 7 days worth of active balance left
    if (_secondsOfCoverageLeft(_protocol) < MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);

    // Transfers the amount to the msg.sender (protocol agent)
    token.safeTransfer(msg.sender, _amount);
    emit ProtocolBalanceWithdrawn(_protocol, _amount);
  }

  /// @notice Transfer protocol agent role
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Account able to submit a claim on behalf of the protocol
  /// @dev Only the active protocolAgent is able to transfer the role
  function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)
    external
    override
    whenNotPaused
  {
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Can't set the new protocol agent to the caller address
    if (msg.sender == _protocolAgent) revert InvalidArgument();
    // Because the caller must be the current protocol agent
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Sets the protocol agent to the new address
    _setProtocolAgent(_protocol, msg.sender, _protocolAgent);
  }

  /// @notice Function used to check if this is the current active protocol manager
  /// @return Boolean indicating it's active
  /// @dev If inactive the owner can pull all ERC20s and ETH
  /// @dev Will be checked by calling the sherlock contract
  function isActive() public view returns (bool) {
    return address(sherlockCore.sherlockProtocolManager()) == address(this);
  }

  // Only contract owner can call this
  // Sends all specified tokens in this contract to the receiver's address (as well as ETH)
  function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {
    if (_receiver == address(0)) revert ZeroArgument();
    // This contract must NOT be the current assigned protocol manager contract
    if (isActive()) revert InvalidConditions();
    // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH
    _sweep(_receiver, _extraTokens);
  }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import './Manager.sol';
import '../interfaces/managers/ISherlockProtocolManager.sol';

/// @title Sherlock core interface for protocols
/// @author Evert Kors
// This is the contract that manages covered protocols

contract SherlockProtocolManager is ISherlockProtocolManager, Manager {
  using SafeERC20 for IERC20;

  // Represents the token that protocols pay with (currently USDC)
  IERC20 public immutable token;

  // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed
  uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc

  // A removed protocol is still able to make a claim for this amount of time after its removal
  uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days;

  // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance
  uint256 public constant MIN_SECONDS_LEFT = 7 days;

  // Convenient for percentage calculations
  uint256 internal constant HUNDRED_PERCENT = 10**18;

  // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage
  // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying
  uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours;

  // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)
  mapping(bytes32 => address) internal protocolAgent_;

  // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)
  mapping(bytes32 => uint256) internal nonStakersPercentage;

  // The premium per second paid by each protocol is stored in this mapping
  mapping(bytes32 => uint256) internal premiums_;

  // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.
  // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not
  mapping(bytes32 => uint256) internal activeBalances;

  // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol
  mapping(bytes32 => uint256) internal lastAccountedEachProtocol;

  // The amount that can be claimed by nonstakers for each protocol
  // We need this value so we can track how much payment is coming from each protocol
  mapping(bytes32 => uint256) internal nonStakersClaimableByProtocol;

  // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)
  uint256 internal lastAccountedGlobal;

  // This is the total amount of premiums paid (per second) by all the covered protocols (added up)
  uint256 internal allPremiumsPerSecToStakers;

  // This is the amount that was claimable by stakers the last time the accounting was run
  // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date
  uint256 internal lastClaimablePremiumsForStakers;

  // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage
  // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)
  uint256 public override minActiveBalance;

  // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)
  mapping(bytes32 => uint256) internal removedProtocolClaimDeadline;

  // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)
  mapping(bytes32 => address) internal removedProtocolAgent;

  // Current amount of coverage (i.e. 20M USDC) for a protocol
  mapping(bytes32 => uint256) internal currentCoverage;

  // Previous amount of coverage for a protocol
  // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount
  mapping(bytes32 => uint256) internal previousCoverage;

  // Setting the token to USDC
  constructor(IERC20 _token) {
    if (address(_token) == address(0)) revert ZeroArgument();
    token = _token;
  }

  // Modifier used to ensure a protocol exists (has been instantiated and not removed)
  modifier protocolExists(bytes32 _protocol) {
    _verifyProtocolExists(_protocol);
    _;
  }

  /// @notice View current protocolAgent of `_protocol`
  /// @param _protocol Protocol identifier
  /// @return Address able to submit claims
  function protocolAgent(bytes32 _protocol) external view override returns (address) {
    address agent = protocolAgent_[_protocol];
    if (agent != address(0)) return agent;

    // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned
    // Note: Old protocol agent will never be address(0)
    if (block.timestamp <= removedProtocolClaimDeadline[_protocol]) {
      return removedProtocolAgent[_protocol];
    }

    // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned
    revert ProtocolNotExists(_protocol);
  }

  // Checks if the protocol exists, then returns the current premium per second being charged
  /// @notice View current premium of protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of premium `_protocol` pays per second
  function premium(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return premiums_[_protocol];
  }

  // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)
  // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)
  function _verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {
    _protocolAgent = protocolAgent_[_protocol];
    if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);
  }

  //
  // View methods
  //

  // Calcs the debt accrued by the protocol since it last had an accounting update
  // This is the amount that needs to be removed from a protocol's active balance
  function _calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {
    return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums_[_protocol];
  }

  /// @notice View the amount nonstakers can claim from this protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of tokens claimable by nonstakers
  /// @dev this reads from a storage variable + (now-lastsettled) * premiums
  // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]
  // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed
  function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {
    // Calcs the debt of a protocol since the last accounting update
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // Gets the active balance of the protocol
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) debt = balance;

    // Adds the incremental claimable amount owed to nonstakers to the total claimable amount
    return
      nonStakersClaimableByProtocol[_protocol] +
      (nonStakersPercentage[_protocol] * debt) /
      HUNDRED_PERCENT;
  }

  /// @notice View current amount of all premiums that are owed to stakers
  /// @return Premiums claimable
  /// @dev Will increase every block
  /// @dev base + (now - last_settled) * ps
  function claimablePremiums() public view override returns (uint256) {
    // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)
    return
      lastClaimablePremiumsForStakers +
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
  }

  /// @notice View seconds of coverage left for `_protocol` before it runs out of active balance
  /// @param _protocol Protocol identifier
  /// @return Seconds of coverage left
  function secondsOfCoverageLeft(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _secondsOfCoverageLeft(_protocol);
  }

  // Helper function to return seconds of coverage left for a protocol
  // Gets the current active balance of the protocol and divides by the premium per second for the protocol
  function _secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {
    uint256 premium = premiums_[_protocol];
    if (premium == 0) return 0;
    return _activeBalance(_protocol) / premium;
  }

  /// @notice View current active balance of covered protocol
  /// @param _protocol Protocol identifier
  /// @return Active balance
  /// @dev Accrued debt is subtracted from the stored active balance
  function activeBalance(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _activeBalance(_protocol);
  }

  // Helper function to calc the active balance of a protocol at current time
  function _activeBalance(bytes32 _protocol) internal view returns (uint256) {
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) return 0;
    return balance - debt;
  }

  //
  // State methods
  //

  /// @notice Helps set the premium per second for an individual protocol
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function
  function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)
    internal
    returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)
  {
    // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers
    // Also updates the last accounted timestamp for this protocol
    // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings
    // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol
    nonStakerPercentage = _settleProtocolDebt(_protocol);
    // Stores the old premium before it gets updated
    oldPremiumPerSecond = premiums_[_protocol];

    if (oldPremiumPerSecond != _premium) {
      // Sets the protocol's premium per second to the new value
      premiums_[_protocol] = _premium;
      emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium);
    }
    // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing
    // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes
    // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point
    // Where arbs would no longer be incentivized to remove the protocol
    // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems
    if (_premium != 0 && _secondsOfCoverageLeft(_protocol) < MIN_SECONDS_OF_COVERAGE) {
      revert InsufficientBalance(_protocol);
    }
  }

  /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {
    // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings
    (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
      _protocol,
      _premium
    );
    // Settling the total amount of premiums owed to stakers before a new premium per second gets set
    _settleTotalDebt();
    // This calculates the new global premium per second that gets paid to stakers
    // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      oldPremiumPerSecond,
      _premium,
      nonStakerPercentage,
      nonStakerPercentage,
      allPremiumsPerSecToStakers
    );
  }

  // Internal function to set a new protocolAgent for a specific protocol
  // _oldAgent is only included as part of emitting an event
  function _setProtocolAgent(
    bytes32 _protocol,
    address _oldAgent,
    address _protocolAgent
  ) internal {
    protocolAgent_[_protocol] = _protocolAgent;
    emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);
  }

  // Subtracts the accrued debt from a protocol's active balance
  // Credits the amount that can be claimed by nonstakers for this protocol
  // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings
  // Most of this function is dealing with an edge case related to a protocol not being removed by arbs
  function _settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {
    // This calcs the accrued debt of the protocol since it was last updated
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // This pulls the percentage that is sent to nonstakers
    _nonStakerPercentage = nonStakersPercentage[_protocol];
    // In case the protocol has accrued debt, this code block will ensure the debt is settled properly
    if (debt != 0) {
      // Pulls the stored active balance of the protocol
      uint256 balance = activeBalances[_protocol];
      // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance
      // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point
      // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage
      // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up
      if (debt > balance) {
        // This error amount represents the magnitude of the mistake
        uint256 error = debt - balance;
        // Gets the latest value of claimable premiums for stakers
        _settleTotalDebt();
        // @note to production, set premium first to zero before solving accounting issue.
        // otherwise the accounting error keeps increasing
        uint256 lastClaimablePremiumsForStakers_ = lastClaimablePremiumsForStakers;

        // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%
        uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /
          HUNDRED_PERCENT;

        // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short
        uint256 insufficientTokens;

        // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally
        // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error
        // This first line can be true if claimPremiumsForStakers() has been called and
        // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be >0 still
        if (claimablePremiumError > lastClaimablePremiumsForStakers_) {
          insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;
          lastClaimablePremiumsForStakers = 0;
        } else {
          // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums
          // By the amount that was added in error (error) and insufficientTokens = 0
          lastClaimablePremiumsForStakers =
            lastClaimablePremiumsForStakers_ -
            claimablePremiumError;
        }

        // If two events are thrown, the values need to be summed up for the actual state.
        // This means an error of this type will continue until it is handled
        emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);
        // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case
        debt = balance;
      }
      // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance
      activeBalances[_protocol] = balance - debt;
      // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol
      nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT;
    }
    // Updates the last accounted timestamp for this protocol
    lastAccountedEachProtocol[_protocol] = block.timestamp;
  }

  // Multiplies the total premium per second * number of seconds since the last global accounting update
  // And adds it to the total claimable amount for stakers
  function _settleTotalDebt() internal {
    lastClaimablePremiumsForStakers +=
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
    lastAccountedGlobal = block.timestamp;
  }

  // Calculates the global premium per second for stakers
  // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers
  // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones
  function _calcGlobalPremiumPerSecForStakers(
    uint256 _premiumOld,
    uint256 _premiumNew,
    uint256 _nonStakerPercentageOld,
    uint256 _nonStakerPercentageNew,
    uint256 _inMemAllPremiumsPerSecToStakers
  ) internal pure returns (uint256) {
    return
      _inMemAllPremiumsPerSecToStakers +
      ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /
      HUNDRED_PERCENT -
      ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /
      HUNDRED_PERCENT;
  }

  // Helper function to remove and clean up a protocol from Sherlock
  // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made
  function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {
    // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol
    _setSingleAndGlobalProtocolPremium(_protocol, 0);

    // Grabs the protocol's active balance
    uint256 balance = activeBalances[_protocol];

    // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent
    if (balance != 0) {
      delete activeBalances[_protocol];
      token.safeTransfer(_agent, balance);

      emit ProtocolBalanceWithdrawn(_protocol, balance);
    }

    // Sets the protocol agent to zero address (as part of clean up)
    _setProtocolAgent(_protocol, _agent, address(0));

    // Cleans up other mappings for this protocol
    delete nonStakersPercentage[_protocol];
    delete lastAccountedEachProtocol[_protocol];
    // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above

    // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol
    removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;

    // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed
    // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked
    removedProtocolAgent[_protocol] = _agent;

    emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0));
    emit ProtocolRemoved(_protocol);
  }

  /// @notice Sets the minimum active balance before an arb can remove a protocol
  /// @param _minActiveBalance Minimum balance needed (in USDC)
  /// @dev Only gov
  function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {
    // New value cannot be the same as current value
    if (minActiveBalance == _minActiveBalance) revert InvalidArgument();
    // Can't set a value that is too high to be reasonable
    if (_minActiveBalance >= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions();

    emit MinBalance(minActiveBalance, _minActiveBalance);
    minActiveBalance = _minActiveBalance;
  }

  // This function allows the nonstakers role to claim tokens owed to them by a specific protocol
  /// @notice Choose an `_amount` of tokens that nonstakers (`_receiver` address) will receive from `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens
  /// @param _receiver Address to receive tokens
  /// @dev Only callable by nonstakers role
  function nonStakersClaim(
    bytes32 _protocol,
    uint256 _amount,
    address _receiver
  ) external override whenNotPaused {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_amount == uint256(0)) revert ZeroArgument();
    if (_receiver == address(0)) revert ZeroArgument();
    // Only the nonstakers role (multisig or contract) can pull the funds
    if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized();

    // Call can't be executed on protocol that is removed
    if (protocolAgent_[_protocol] != address(0)) {
      // Updates the amount that nonstakers can claim from this protocol
      _settleProtocolDebt(_protocol);
    }

    // Sets balance to the amount that is claimable by nonstakers for this specific protocol
    uint256 balance = nonStakersClaimableByProtocol[_protocol];
    // If the amount requested is more than what's owed to nonstakers, revert
    if (_amount > balance) revert InsufficientBalance(_protocol);

    // Sets the claimable amount to whatever is left over after this amount is pulled
    nonStakersClaimableByProtocol[_protocol] = balance - _amount;
    // Transfers the amount requested to the `_receiver` address
    token.safeTransfer(_receiver, _amount);
  }

  // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)
  /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address
  /// @dev Callable by everyone
  /// @dev Funds will be transferred to Sherlock core contract
  function claimPremiumsForStakers() external override whenNotPaused {
    // Gets address of core Sherlock contract
    address sherlock = address(sherlockCore);
    // Revert if core Sherlock contract not initialized yet
    if (sherlock == address(0)) revert InvalidConditions();

    // claimablePremiums is different from _settleTotalDebt() because it does not change state
    // Retrieves current amount of all premiums that are owed to stakers
    uint256 amount = claimablePremiums();

    // Transfers all the premiums owed to stakers to the Sherlock core contract
    if (amount != 0) {
      // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out
      lastClaimablePremiumsForStakers = 0;
      lastAccountedGlobal = block.timestamp;
      token.safeTransfer(sherlock, amount);
    }
  }

  // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts
  /// @param _protocol Protocol identifier
  /// @return current and previous are the current and previous coverage amounts for this protocol
  // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)
  function coverageAmounts(bytes32 _protocol)
    external
    view
    override
    returns (uint256 current, uint256 previous)
  {
    // Checks to see if the protocol has an active protocolAgent (protocol not removed)
    // OR checks to see if the removed protocol is still within the claim window
    // If so, gives the current and previous coverage, otherwise throws an error
    if (
      protocolAgent_[_protocol] != address(0) ||
      block.timestamp <= removedProtocolClaimDeadline[_protocol]
    ) {
      return (currentCoverage[_protocol], previousCoverage[_protocol]);
    }

    revert ProtocolNotExists(_protocol);
  }

  /// @notice Add a new protocol to Sherlock
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Address able to submit a claim on behalf of the protocol
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Adding a protocol allows the `_protocolAgent` to submit a claim
  /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point
  /// @dev `_nonStakers` is scaled by 10**18
  /// @dev Only callable by governance
  function protocolAdd(
    bytes32 _protocol,
    address _protocolAgent,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) external override onlyOwner {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Checks to make sure the protocol doesn't exist already
    if (protocolAgent_[_protocol] != address(0)) revert InvalidConditions();

    // Updates the protocol agent and passes in the old agent which is 0 address in this case
    _setProtocolAgent(_protocol, address(0), _protocolAgent);

    // Delete mappings that are potentially non default values
    // From previous time protocol was added/removed
    delete removedProtocolClaimDeadline[_protocol];
    delete removedProtocolAgent[_protocol];
    delete currentCoverage[_protocol];
    delete previousCoverage[_protocol];

    emit ProtocolAdded(_protocol);

    // Most of the logic for actually adding a protocol in this function
    protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Update info regarding a protocol
  /// @param _protocol Protocol identifier
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Only callable by governance
  /// @dev `_nonStakers` can be 0
  function protocolUpdate(
    bytes32 _protocol,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) public override onlyOwner {
    if (_coverage == bytes32(0)) revert ZeroArgument();
    if (_nonStakers > HUNDRED_PERCENT) revert InvalidArgument();
    if (_coverageAmount == uint256(0)) revert ZeroArgument();

    // Checks to make sure the protocol has been assigned a protocol agent
    _verifyProtocolExists(_protocol);

    // Subtracts the accrued debt from a protocol's active balance (if any)
    // Updates the amount that can be claimed by nonstakers
    _settleProtocolDebt(_protocol);

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    // Gets the premium per second for this protocol
    uint256 premium = premiums_[_protocol];

    // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be)
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      premium,
      premium,
      nonStakersPercentage[_protocol],
      _nonStakers,
      allPremiumsPerSecToStakers
    );

    // Updates the stored value of percentage of premiums that go to nonstakers
    nonStakersPercentage[_protocol] = _nonStakers;

    // Updates previous coverage and current coverage amounts
    previousCoverage[_protocol] = currentCoverage[_protocol];
    currentCoverage[_protocol] = _coverageAmount;

    emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Remove a protocol from coverage
  /// @param _protocol Protocol identifier
  /// @dev Before removing a protocol the premium must be 0
  /// @dev Removing a protocol basically stops the `_protocolAgent` from being active (can still submit claims until claim deadline though)
  /// @dev Pays off debt + sends remaining balance to protocol agent
  /// @dev This call should be subject to a timelock
  /// @dev Only callable by governance
  function protocolRemove(bytes32 _protocol) external override onlyOwner {
    // checks to make sure the protocol actually has a protocol agent
    address agent = _verifyProtocolExists(_protocol);

    // Removes a protocol from Sherlock and cleans up its data
    // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made
    _forceRemoveProtocol(_protocol, agent);
  }

  /// @notice Remove a protocol with insufficient active balance
  /// @param _protocol Protocol identifier
  // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function
  function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {
    address agent = _verifyProtocolExists(_protocol);

    // Gets the latest value of the active balance at this protocol
    _settleProtocolDebt(_protocol);
    // Sets latest value of active balance to remainingBalance variable
    uint256 remainingBalance = activeBalances[_protocol];

    // This means the protocol still has adequate active balance and thus cannot be removed
    if (remainingBalance >= minActiveBalance) revert InvalidConditions();

    // Sets the protocol's active balance to 0
    delete activeBalances[_protocol];
    // Removes the protocol from coverage
    _forceRemoveProtocol(_protocol, agent);

    if (remainingBalance != 0) {
      // sends the remaining balance to msg.sender
      token.safeTransfer(msg.sender, remainingBalance);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);
  }

  /// @notice Calculate if arb is possible and what the reward would be
  /// @param _protocol Protocol identifier
  /// @return arbAmount Amount reward for arbing
  /// @return able Indicator if arb call is even possible
  /// @dev Doesn't subtract the current protocol debt from the active balance
  function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)
    internal
    view
    returns (uint256 arbAmount, bool able)
  {
    uint256 secondsLeft = _secondsOfCoverageLeft(_protocol);

    // If arb is not possible return false
    if (secondsLeft >= MIN_SECONDS_OF_COVERAGE) return (0, false);

    // This percentage scales over time
    // Reaches 100% on 0 seconds of coverage left
    uint256 percentageScaled = HUNDRED_PERCENT -
      (secondsLeft * HUNDRED_PERCENT) /
      MIN_SECONDS_OF_COVERAGE;

    able = true;
    arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;
  }

  /// @notice Removes a protocol with insufficent seconds of coverage left
  /// @param _protocol Protocol identifier
  // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second
  function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {
    // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings
    address agent = _verifyProtocolExists(_protocol);

    // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance()
    // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance()
    // But when removing based on seconds of coverage left, the remainingBalance could still be quite large
    // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance
    // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%)
    _settleProtocolDebt(_protocol);
    (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol);
    if (able == false) revert InvalidConditions();

    if (arbAmount != 0) {
      // subtracts the amount that will be paid to the arb from the active balance
      activeBalances[_protocol] -= arbAmount;
    }

    // Removes the protocol from coverage
    // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above
    _forceRemoveProtocol(_protocol, agent);

    // Done after removing protocol to mitigate reentrency pattern
    // (In case token allows callback)
    if (arbAmount != 0) {
      token.safeTransfer(msg.sender, arbAmount);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);
  }

  /// @notice Set premium of `_protocol` to `_premium`
  /// @param _protocol Protocol identifier
  /// @param _premium Amount of premium `_protocol` pays per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {
    // Checks to see if protocol has a protocol agent
    _verifyProtocolExists(_protocol);

    // Updates individual protocol's premium and allPremiumsPerSecToStakers
    _setSingleAndGlobalProtocolPremium(_protocol, _premium);
  }

  /// @notice Set premium of multiple protocols
  /// @param _protocol Array of protocol identifiers
  /// @param _premium Array of premium amounts protocols pay per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)
    external
    override
    onlyOwner
  {
    // Checks to make sure there are an equal amount of entries in each array
    if (_protocol.length != _premium.length) revert UnequalArrayLength();
    if (_protocol.length == 0) revert InvalidArgument();

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;

    // Loops through the array of protocols and checks to make sure each has a protocol agent assigned
    for (uint256 i; i < _protocol.length; i++) {
      _verifyProtocolExists(_protocol[i]);

      // Sets the protocol premium for that specific protocol
      // Function returns the old premium and nonStakerPercentage for that specific protocol
      (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
        _protocol[i],
        _premium[i]
      );

      // Calculates the new global premium which adds up all premiums paid by all protocols
      allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(
        oldPremiumPerSecond,
        _premium[i],
        nonStakerPercentage,
        nonStakerPercentage,
        allPremiumsPerSecToStakers_
      );
    }

    // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value
    allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;
  }

  // This is how protocols pay for coverage by increasing their active balance
  /// @notice Deposits `_amount` of token to the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to deposit
  /// @dev Approval should be made before calling
  function depositToActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    _verifyProtocolExists(_protocol);

    // Transfers _amount to this contract
    token.safeTransferFrom(msg.sender, address(this), _amount);
    // Increases the active balance of the protocol by _amount
    activeBalances[_protocol] += _amount;

    emit ProtocolBalanceDeposited(_protocol, _amount);
  }

  // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)
  // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)
  /// @notice Withdraws `_amount` of token from the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to withdraw
  /// @dev Only protocol agent is able to withdraw
  /// @dev Balance can be withdrawn up until 7 days worth of active balance
  function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    // Only the protocol agent can call this function
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Updates the active balance of the protocol
    _settleProtocolDebt(_protocol);

    // Sets currentBalance to the active balance of the protocol
    uint256 currentBalance = activeBalances[_protocol];
    // Reverts if trying to withdraw more than the active balance
    if (_amount > currentBalance) revert InsufficientBalance(_protocol);

    // Removes the _amount to be withdrawn from the active balance
    activeBalances[_protocol] = currentBalance - _amount;
    // Reverts if a protocol has less than 7 days worth of active balance left
    if (_secondsOfCoverageLeft(_protocol) < MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);

    // Transfers the amount to the msg.sender (protocol agent)
    token.safeTransfer(msg.sender, _amount);
    emit ProtocolBalanceWithdrawn(_protocol, _amount);
  }

  /// @notice Transfer protocol agent role
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Account able to submit a claim on behalf of the protocol
  /// @dev Only the active protocolAgent is able to transfer the role
  function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)
    external
    override
    whenNotPaused
  {
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Can't set the new protocol agent to the caller address
    if (msg.sender == _protocolAgent) revert InvalidArgument();
    // Because the caller must be the current protocol agent
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Sets the protocol agent to the new address
    _setProtocolAgent(_protocol, msg.sender, _protocolAgent);
  }

  /// @notice Function used to check if this is the current active protocol manager
  /// @return Boolean indicating it's active
  /// @dev If inactive the owner can pull all ERC20s and ETH
  /// @dev Will be checked by calling the sherlock contract
  function isActive() public view returns (bool) {
    return address(sherlockCore.sherlockProtocolManager()) == address(this);
  }

  // Only contract owner can call this
  // Sends all specified tokens in this contract to the receiver's address (as well as ETH)
  function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {
    if (_receiver == address(0)) revert ZeroArgument();
    // This contract must NOT be the current assigned protocol manager contract
    if (isActive()) revert InvalidConditions();
    // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH
    _sweep(_receiver, _extraTokens);
  }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-25-08 10:59:23 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-25-08 10:59:23 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 18293
completion_tokens: 1
total_tokens: 18294
cost: $-1.000000


[2024-25-08 10:59:23 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import './Manager.sol';
import '../interfaces/managers/ISherlockProtocolManager.sol';

/// @title Sherlock core interface for protocols
/// @author Evert Kors
// This is the contract that manages covered protocols

contract SherlockProtocolManager is ISherlockProtocolManager, Manager {
  using SafeERC20 for IERC20;

  // Represents the token that protocols pay with (currently USDC)
  IERC20 public immutable token;

  // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed
  uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc

  // A removed protocol is still able to make a claim for this amount of time after its removal
  uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days;

  // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance
  uint256 public constant MIN_SECONDS_LEFT = 7 days;

  // Convenient for percentage calculations
  uint256 internal constant HUNDRED_PERCENT = 10**18;

  // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage
  // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying
  uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours;

  // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)
  mapping(bytes32 => address) internal protocolAgent_;

  // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)
  mapping(bytes32 => uint256) internal nonStakersPercentage;

  // The premium per second paid by each protocol is stored in this mapping
  mapping(bytes32 => uint256) internal premiums_;

  // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.
  // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not
  mapping(bytes32 => uint256) internal activeBalances;

  // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol
  mapping(bytes32 => uint256) internal lastAccountedEachProtocol;

  // The amount that can be claimed by nonstakers for each protocol
  // We need this value so we can track how much payment is coming from each protocol
  mapping(bytes32 => uint256) internal nonStakersClaimableByProtocol;

  // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)
  uint256 internal lastAccountedGlobal;

  // This is the total amount of premiums paid (per second) by all the covered protocols (added up)
  uint256 internal allPremiumsPerSecToStakers;

  // This is the amount that was claimable by stakers the last time the accounting was run
  // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date
  uint256 internal lastClaimablePremiumsForStakers;

  // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage
  // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)
  uint256 public override minActiveBalance;

  // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)
  mapping(bytes32 => uint256) internal removedProtocolClaimDeadline;

  // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)
  mapping(bytes32 => address) internal removedProtocolAgent;

  // Current amount of coverage (i.e. 20M USDC) for a protocol
  mapping(bytes32 => uint256) internal currentCoverage;

  // Previous amount of coverage for a protocol
  // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount
  mapping(bytes32 => uint256) internal previousCoverage;

  // Setting the token to USDC
  constructor(IERC20 _token) {
    if (address(_token) == address(0)) revert ZeroArgument();
    token = _token;
  }

  // Modifier used to ensure a protocol exists (has been instantiated and not removed)
  modifier protocolExists(bytes32 _protocol) {
    _verifyProtocolExists(_protocol);
    _;
  }

  /// @notice View current protocolAgent of `_protocol`
  /// @param _protocol Protocol identifier
  /// @return Address able to submit claims
  function protocolAgent(bytes32 _protocol) external view override returns (address) {
    address agent = protocolAgent_[_protocol];
    if (agent != address(0)) return agent;

    // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned
    // Note: Old protocol agent will never be address(0)
    if (block.timestamp <= removedProtocolClaimDeadline[_protocol]) {
      return removedProtocolAgent[_protocol];
    }

    // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned
    revert ProtocolNotExists(_protocol);
  }

  // Checks if the protocol exists, then returns the current premium per second being charged
  /// @notice View current premium of protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of premium `_protocol` pays per second
  function premium(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return premiums_[_protocol];
  }

  // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)
  // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)
  function _verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {
    _protocolAgent = protocolAgent_[_protocol];
    if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);
  }

  //
  // View methods
  //

  // Calcs the debt accrued by the protocol since it last had an accounting update
  // This is the amount that needs to be removed from a protocol's active balance
  function _calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {
    return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums_[_protocol];
  }

  /// @notice View the amount nonstakers can claim from this protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of tokens claimable by nonstakers
  /// @dev this reads from a storage variable + (now-lastsettled) * premiums
  // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]
  // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed
  function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {
    // Calcs the debt of a protocol since the last accounting update
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // Gets the active balance of the protocol
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) debt = balance;

    // Adds the incremental claimable amount owed to nonstakers to the total claimable amount
    return
      nonStakersClaimableByProtocol[_protocol] +
      (nonStakersPercentage[_protocol] * debt) /
      HUNDRED_PERCENT;
  }

  /// @notice View current amount of all premiums that are owed to stakers
  /// @return Premiums claimable
  /// @dev Will increase every block
  /// @dev base + (now - last_settled) * ps
  function claimablePremiums() public view override returns (uint256) {
    // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)
    return
      lastClaimablePremiumsForStakers +
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
  }

  /// @notice View seconds of coverage left for `_protocol` before it runs out of active balance
  /// @param _protocol Protocol identifier
  /// @return Seconds of coverage left
  function secondsOfCoverageLeft(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _secondsOfCoverageLeft(_protocol);
  }

  // Helper function to return seconds of coverage left for a protocol
  // Gets the current active balance of the protocol and divides by the premium per second for the protocol
  function _secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {
    uint256 premium = premiums_[_protocol];
    if (premium == 0) return 0;
    return _activeBalance(_protocol) / premium;
  }

  /// @notice View current active balance of covered protocol
  /// @param _protocol Protocol identifier
  /// @return Active balance
  /// @dev Accrued debt is subtracted from the stored active balance
  function activeBalance(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _activeBalance(_protocol);
  }

  // Helper function to calc the active balance of a protocol at current time
  function _activeBalance(bytes32 _protocol) internal view returns (uint256) {
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) return 0;
    return balance - debt;
  }

  //
  // State methods
  //

  /// @notice Helps set the premium per second for an individual protocol
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function
  function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)
    internal
    returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)
  {
    // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers
    // Also updates the last accounted timestamp for this protocol
    // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings
    // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol
    nonStakerPercentage = _settleProtocolDebt(_protocol);
    // Stores the old premium before it gets updated
    oldPremiumPerSecond = premiums_[_protocol];

    if (oldPremiumPerSecond != _premium) {
      // Sets the protocol's premium per second to the new value
      premiums_[_protocol] = _premium;
      emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium);
    }
    // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing
    // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes
    // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point
    // Where arbs would no longer be incentivized to remove the protocol
    // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems
    if (_premium != 0 && _secondsOfCoverageLeft(_protocol) < MIN_SECONDS_OF_COVERAGE) {
      revert InsufficientBalance(_protocol);
    }
  }

  /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {
    // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings
    (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
      _protocol,
      _premium
    );
    // Settling the total amount of premiums owed to stakers before a new premium per second gets set
    _settleTotalDebt();
    // This calculates the new global premium per second that gets paid to stakers
    // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      oldPremiumPerSecond,
      _premium,
      nonStakerPercentage,
      nonStakerPercentage,
      allPremiumsPerSecToStakers
    );
  }

  // Internal function to set a new protocolAgent for a specific protocol
  // _oldAgent is only included as part of emitting an event
  function _setProtocolAgent(
    bytes32 _protocol,
    address _oldAgent,
    address _protocolAgent
  ) internal {
    protocolAgent_[_protocol] = _protocolAgent;
    emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);
  }

  // Subtracts the accrued debt from a protocol's active balance
  // Credits the amount that can be claimed by nonstakers for this protocol
  // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings
  // Most of this function is dealing with an edge case related to a protocol not being removed by arbs
  function _settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {
    // This calcs the accrued debt of the protocol since it was last updated
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // This pulls the percentage that is sent to nonstakers
    _nonStakerPercentage = nonStakersPercentage[_protocol];
    // In case the protocol has accrued debt, this code block will ensure the debt is settled properly
    if (debt != 0) {
      // Pulls the stored active balance of the protocol
      uint256 balance = activeBalances[_protocol];
      // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance
      // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point
      // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage
      // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up
      if (debt > balance) {
        // This error amount represents the magnitude of the mistake
        uint256 error = debt - balance;
        // Gets the latest value of claimable premiums for stakers
        _settleTotalDebt();
        // @note to production, set premium first to zero before solving accounting issue.
        // otherwise the accounting error keeps increasing
        uint256 lastClaimablePremiumsForStakers_ = lastClaimablePremiumsForStakers;

        // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%
        uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /
          HUNDRED_PERCENT;

        // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short
        uint256 insufficientTokens;

        // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally
        // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error
        // This first line can be true if claimPremiumsForStakers() has been called and
        // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be >0 still
        if (claimablePremiumError > lastClaimablePremiumsForStakers_) {
          insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;
          lastClaimablePremiumsForStakers = 0;
        } else {
          // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums
          // By the amount that was added in error (error) and insufficientTokens = 0
          lastClaimablePremiumsForStakers =
            lastClaimablePremiumsForStakers_ -
            claimablePremiumError;
        }

        // If two events are thrown, the values need to be summed up for the actual state.
        // This means an error of this type will continue until it is handled
        emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);
        // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case
        debt = balance;
      }
      // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance
      activeBalances[_protocol] = balance - debt;
      // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol
      nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT;
    }
    // Updates the last accounted timestamp for this protocol
    lastAccountedEachProtocol[_protocol] = block.timestamp;
  }

  // Multiplies the total premium per second * number of seconds since the last global accounting update
  // And adds it to the total claimable amount for stakers
  function _settleTotalDebt() internal {
    lastClaimablePremiumsForStakers +=
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
    lastAccountedGlobal = block.timestamp;
  }

  // Calculates the global premium per second for stakers
  // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers
  // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones
  function _calcGlobalPremiumPerSecForStakers(
    uint256 _premiumOld,
    uint256 _premiumNew,
    uint256 _nonStakerPercentageOld,
    uint256 _nonStakerPercentageNew,
    uint256 _inMemAllPremiumsPerSecToStakers
  ) internal pure returns (uint256) {
    return
      _inMemAllPremiumsPerSecToStakers +
      ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /
      HUNDRED_PERCENT -
      ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /
      HUNDRED_PERCENT;
  }

  // Helper function to remove and clean up a protocol from Sherlock
  // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made
  function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {
    // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol
    _setSingleAndGlobalProtocolPremium(_protocol, 0);

    // Grabs the protocol's active balance
    uint256 balance = activeBalances[_protocol];

    // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent
    if (balance != 0) {
      delete activeBalances[_protocol];
      token.safeTransfer(_agent, balance);

      emit ProtocolBalanceWithdrawn(_protocol, balance);
    }

    // Sets the protocol agent to zero address (as part of clean up)
    _setProtocolAgent(_protocol, _agent, address(0));

    // Cleans up other mappings for this protocol
    delete nonStakersPercentage[_protocol];
    delete lastAccountedEachProtocol[_protocol];
    // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above

    // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol
    removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;

    // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed
    // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked
    removedProtocolAgent[_protocol] = _agent;

    emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0));
    emit ProtocolRemoved(_protocol);
  }

  /// @notice Sets the minimum active balance before an arb can remove a protocol
  /// @param _minActiveBalance Minimum balance needed (in USDC)
  /// @dev Only gov
  function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {
    // New value cannot be the same as current value
    if (minActiveBalance == _minActiveBalance) revert InvalidArgument();
    // Can't set a value that is too high to be reasonable
    if (_minActiveBalance >= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions();

    emit MinBalance(minActiveBalance, _minActiveBalance);
    minActiveBalance = _minActiveBalance;
  }

  // This function allows the nonstakers role to claim tokens owed to them by a specific protocol
  /// @notice Choose an `_amount` of tokens that nonstakers (`_receiver` address) will receive from `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens
  /// @param _receiver Address to receive tokens
  /// @dev Only callable by nonstakers role
  function nonStakersClaim(
    bytes32 _protocol,
    uint256 _amount,
    address _receiver
  ) external override whenNotPaused {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_amount == uint256(0)) revert ZeroArgument();
    if (_receiver == address(0)) revert ZeroArgument();
    // Only the nonstakers role (multisig or contract) can pull the funds
    if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized();

    // Call can't be executed on protocol that is removed
    if (protocolAgent_[_protocol] != address(0)) {
      // Updates the amount that nonstakers can claim from this protocol
      _settleProtocolDebt(_protocol);
    }

    // Sets balance to the amount that is claimable by nonstakers for this specific protocol
    uint256 balance = nonStakersClaimableByProtocol[_protocol];
    // If the amount requested is more than what's owed to nonstakers, revert
    if (_amount > balance) revert InsufficientBalance(_protocol);

    // Sets the claimable amount to whatever is left over after this amount is pulled
    nonStakersClaimableByProtocol[_protocol] = balance - _amount;
    // Transfers the amount requested to the `_receiver` address
    token.safeTransfer(_receiver, _amount);
  }

  // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)
  /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address
  /// @dev Callable by everyone
  /// @dev Funds will be transferred to Sherlock core contract
  function claimPremiumsForStakers() external override whenNotPaused {
    // Gets address of core Sherlock contract
    address sherlock = address(sherlockCore);
    // Revert if core Sherlock contract not initialized yet
    if (sherlock == address(0)) revert InvalidConditions();

    // claimablePremiums is different from _settleTotalDebt() because it does not change state
    // Retrieves current amount of all premiums that are owed to stakers
    uint256 amount = claimablePremiums();

    // Transfers all the premiums owed to stakers to the Sherlock core contract
    if (amount != 0) {
      // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out
      lastClaimablePremiumsForStakers = 0;
      lastAccountedGlobal = block.timestamp;
      token.safeTransfer(sherlock, amount);
    }
  }

  // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts
  /// @param _protocol Protocol identifier
  /// @return current and previous are the current and previous coverage amounts for this protocol
  // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)
  function coverageAmounts(bytes32 _protocol)
    external
    view
    override
    returns (uint256 current, uint256 previous)
  {
    // Checks to see if the protocol has an active protocolAgent (protocol not removed)
    // OR checks to see if the removed protocol is still within the claim window
    // If so, gives the current and previous coverage, otherwise throws an error
    if (
      protocolAgent_[_protocol] != address(0) ||
      block.timestamp <= removedProtocolClaimDeadline[_protocol]
    ) {
      return (currentCoverage[_protocol], previousCoverage[_protocol]);
    }

    revert ProtocolNotExists(_protocol);
  }

  /// @notice Add a new protocol to Sherlock
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Address able to submit a claim on behalf of the protocol
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Adding a protocol allows the `_protocolAgent` to submit a claim
  /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point
  /// @dev `_nonStakers` is scaled by 10**18
  /// @dev Only callable by governance
  function protocolAdd(
    bytes32 _protocol,
    address _protocolAgent,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) external override onlyOwner {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Checks to make sure the protocol doesn't exist already
    if (protocolAgent_[_protocol] != address(0)) revert InvalidConditions();

    // Updates the protocol agent and passes in the old agent which is 0 address in this case
    _setProtocolAgent(_protocol, address(0), _protocolAgent);

    // Delete mappings that are potentially non default values
    // From previous time protocol was added/removed
    delete removedProtocolClaimDeadline[_protocol];
    delete removedProtocolAgent[_protocol];
    delete currentCoverage[_protocol];
    delete previousCoverage[_protocol];

    emit ProtocolAdded(_protocol);

    // Most of the logic for actually adding a protocol in this function
    protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Update info regarding a protocol
  /// @param _protocol Protocol identifier
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Only callable by governance
  /// @dev `_nonStakers` can be 0
  function protocolUpdate(
    bytes32 _protocol,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) public override onlyOwner {
    if (_coverage == bytes32(0)) revert ZeroArgument();
    if (_nonStakers > HUNDRED_PERCENT) revert InvalidArgument();
    if (_coverageAmount == uint256(0)) revert ZeroArgument();

    // Checks to make sure the protocol has been assigned a protocol agent
    _verifyProtocolExists(_protocol);

    // Subtracts the accrued debt from a protocol's active balance (if any)
    // Updates the amount that can be claimed by nonstakers
    _settleProtocolDebt(_protocol);

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    // Gets the premium per second for this protocol
    uint256 premium = premiums_[_protocol];

    // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be)
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      premium,
      premium,
      nonStakersPercentage[_protocol],
      _nonStakers,
      allPremiumsPerSecToStakers
    );

    // Updates the stored value of percentage of premiums that go to nonstakers
    nonStakersPercentage[_protocol] = _nonStakers;

    // Updates previous coverage and current coverage amounts
    previousCoverage[_protocol] = currentCoverage[_protocol];
    currentCoverage[_protocol] = _coverageAmount;

    emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Remove a protocol from coverage
  /// @param _protocol Protocol identifier
  /// @dev Before removing a protocol the premium must be 0
  /// @dev Removing a protocol basically stops the `_protocolAgent` from being active (can still submit claims until claim deadline though)
  /// @dev Pays off debt + sends remaining balance to protocol agent
  /// @dev This call should be subject to a timelock
  /// @dev Only callable by governance
  function protocolRemove(bytes32 _protocol) external override onlyOwner {
    // checks to make sure the protocol actually has a protocol agent
    address agent = _verifyProtocolExists(_protocol);

    // Removes a protocol from Sherlock and cleans up its data
    // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made
    _forceRemoveProtocol(_protocol, agent);
  }

  /// @notice Remove a protocol with insufficient active balance
  /// @param _protocol Protocol identifier
  // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function
  function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {
    address agent = _verifyProtocolExists(_protocol);

    // Gets the latest value of the active balance at this protocol
    _settleProtocolDebt(_protocol);
    // Sets latest value of active balance to remainingBalance variable
    uint256 remainingBalance = activeBalances[_protocol];

    // This means the protocol still has adequate active balance and thus cannot be removed
    if (remainingBalance >= minActiveBalance) revert InvalidConditions();

    // Sets the protocol's active balance to 0
    delete activeBalances[_protocol];
    // Removes the protocol from coverage
    _forceRemoveProtocol(_protocol, agent);

    if (remainingBalance != 0) {
      // sends the remaining balance to msg.sender
      token.safeTransfer(msg.sender, remainingBalance);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);
  }

  /// @notice Calculate if arb is possible and what the reward would be
  /// @param _protocol Protocol identifier
  /// @return arbAmount Amount reward for arbing
  /// @return able Indicator if arb call is even possible
  /// @dev Doesn't subtract the current protocol debt from the active balance
  function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)
    internal
    view
    returns (uint256 arbAmount, bool able)
  {
    uint256 secondsLeft = _secondsOfCoverageLeft(_protocol);

    // If arb is not possible return false
    if (secondsLeft >= MIN_SECONDS_OF_COVERAGE) return (0, false);

    // This percentage scales over time
    // Reaches 100% on 0 seconds of coverage left
    uint256 percentageScaled = HUNDRED_PERCENT -
      (secondsLeft * HUNDRED_PERCENT) /
      MIN_SECONDS_OF_COVERAGE;

    able = true;
    arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;
  }

  /// @notice Removes a protocol with insufficent seconds of coverage left
  /// @param _protocol Protocol identifier
  // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second
  function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {
    // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings
    address agent = _verifyProtocolExists(_protocol);

    // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance()
    // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance()
    // But when removing based on seconds of coverage left, the remainingBalance could still be quite large
    // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance
    // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%)
    _settleProtocolDebt(_protocol);
    (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol);
    if (able == false) revert InvalidConditions();

    if (arbAmount != 0) {
      // subtracts the amount that will be paid to the arb from the active balance
      activeBalances[_protocol] -= arbAmount;
    }

    // Removes the protocol from coverage
    // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above
    _forceRemoveProtocol(_protocol, agent);

    // Done after removing protocol to mitigate reentrency pattern
    // (In case token allows callback)
    if (arbAmount != 0) {
      token.safeTransfer(msg.sender, arbAmount);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);
  }

  /// @notice Set premium of `_protocol` to `_premium`
  /// @param _protocol Protocol identifier
  /// @param _premium Amount of premium `_protocol` pays per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {
    // Checks to see if protocol has a protocol agent
    _verifyProtocolExists(_protocol);

    // Updates individual protocol's premium and allPremiumsPerSecToStakers
    _setSingleAndGlobalProtocolPremium(_protocol, _premium);
  }

  /// @notice Set premium of multiple protocols
  /// @param _protocol Array of protocol identifiers
  /// @param _premium Array of premium amounts protocols pay per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)
    external
    override
    onlyOwner
  {
    // Checks to make sure there are an equal amount of entries in each array
    if (_protocol.length != _premium.length) revert UnequalArrayLength();
    if (_protocol.length == 0) revert InvalidArgument();

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;

    // Loops through the array of protocols and checks to make sure each has a protocol agent assigned
    for (uint256 i; i < _protocol.length; i++) {
      _verifyProtocolExists(_protocol[i]);

      // Sets the protocol premium for that specific protocol
      // Function returns the old premium and nonStakerPercentage for that specific protocol
      (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
        _protocol[i],
        _premium[i]
      );

      // Calculates the new global premium which adds up all premiums paid by all protocols
      allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(
        oldPremiumPerSecond,
        _premium[i],
        nonStakerPercentage,
        nonStakerPercentage,
        allPremiumsPerSecToStakers_
      );
    }

    // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value
    allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;
  }

  // This is how protocols pay for coverage by increasing their active balance
  /// @notice Deposits `_amount` of token to the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to deposit
  /// @dev Approval should be made before calling
  function depositToActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    _verifyProtocolExists(_protocol);

    // Transfers _amount to this contract
    token.safeTransferFrom(msg.sender, address(this), _amount);
    // Increases the active balance of the protocol by _amount
    activeBalances[_protocol] += _amount;

    emit ProtocolBalanceDeposited(_protocol, _amount);
  }

  // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)
  // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)
  /// @notice Withdraws `_amount` of token from the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to withdraw
  /// @dev Only protocol agent is able to withdraw
  /// @dev Balance can be withdrawn up until 7 days worth of active balance
  function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    // Only the protocol agent can call this function
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Updates the active balance of the protocol
    _settleProtocolDebt(_protocol);

    // Sets currentBalance to the active balance of the protocol
    uint256 currentBalance = activeBalances[_protocol];
    // Reverts if trying to withdraw more than the active balance
    if (_amount > currentBalance) revert InsufficientBalance(_protocol);

    // Removes the _amount to be withdrawn from the active balance
    activeBalances[_protocol] = currentBalance - _amount;
    // Reverts if a protocol has less than 7 days worth of active balance left
    if (_secondsOfCoverageLeft(_protocol) < MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);

    // Transfers the amount to the msg.sender (protocol agent)
    token.safeTransfer(msg.sender, _amount);
    emit ProtocolBalanceWithdrawn(_protocol, _amount);
  }

  /// @notice Transfer protocol agent role
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Account able to submit a claim on behalf of the protocol
  /// @dev Only the active protocolAgent is able to transfer the role
  function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)
    external
    override
    whenNotPaused
  {
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Can't set the new protocol agent to the caller address
    if (msg.sender == _protocolAgent) revert InvalidArgument();
    // Because the caller must be the current protocol agent
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Sets the protocol agent to the new address
    _setProtocolAgent(_protocol, msg.sender, _protocolAgent);
  }

  /// @notice Function used to check if this is the current active protocol manager
  /// @return Boolean indicating it's active
  /// @dev If inactive the owner can pull all ERC20s and ETH
  /// @dev Will be checked by calling the sherlock contract
  function isActive() public view returns (bool) {
    return address(sherlockCore.sherlockProtocolManager()) == address(this);
  }

  // Only contract owner can call this
  // Sends all specified tokens in this contract to the receiver's address (as well as ETH)
  function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {
    if (_receiver == address(0)) revert ZeroArgument();
    // This contract must NOT be the current assigned protocol manager contract
    if (isActive()) revert InvalidConditions();
    // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH
    _sweep(_receiver, _extraTokens);
  }
}
.]

###

[2024-25-08 10:59:23 INFO] **[Seminar Conclusion]**:

 ###

[2024-25-08 10:59:23 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-25-08 10:59:23 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import './Manager.sol'; import '../interfaces/managers/ISherlockProtocolManager.sol'; /// @title Sherlock core interface for protocols /// @author Evert Kors // This is the contract that manages covered protocols contract SherlockProtocolManager is ISherlockProtocolManager, Manager {   using SafeERC20 for IERC20; // Represents the token that protocols pay with (currently USDC)   IERC20 public immutable token; // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed   uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc // A removed protocol is still able to make a claim for this amount of time after its removal   uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days; // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance   uint256 public constant MIN_SECONDS_LEFT = 7 days; // Convenient for percentage calculations   uint256 internal constant HUNDRED_PERCENT = 10**18; // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage   // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying   uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours; // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)   mapping(bytes32 =&gt; address) internal protocolAgent_; // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)   mapping(bytes32 =&gt; uint256) internal nonStakersPercentage; // The premium per second paid by each protocol is stored in this mapping   mapping(bytes32 =&gt; uint256) internal premiums_; // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.   // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not   mapping(bytes32 =&gt; uint256) internal activeBalances; // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol   mapping(bytes32 =&gt; uint256) internal lastAccountedEachProtocol; // The amount that can be claimed by nonstakers for each protocol   // We need this value so we can track how much payment is coming from each protocol   mapping(bytes32 =&gt; uint256) internal nonStakersClaimableByProtocol; // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)   uint256 internal lastAccountedGlobal; // This is the total amount of premiums paid (per second) by all the covered protocols (added up)   uint256 internal allPremiumsPerSecToStakers; // This is the amount that was claimable by stakers the last time the accounting was run   // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date   uint256 internal lastClaimablePremiumsForStakers; // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage   // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)   uint256 public override minActiveBalance; // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)   mapping(bytes32 =&gt; uint256) internal removedProtocolClaimDeadline; // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)   mapping(bytes32 =&gt; address) internal removedProtocolAgent; // Current amount of coverage (i.e. 20M USDC) for a protocol   mapping(bytes32 =&gt; uint256) internal currentCoverage; // Previous amount of coverage for a protocol   // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount   mapping(bytes32 =&gt; uint256) internal previousCoverage; // Setting the token to USDC   constructor(IERC20 _token) {     if (address(_token) == address(0)) revert ZeroArgument();     token = _token;   } // Modifier used to ensure a protocol exists (has been instantiated and not removed)   modifier protocolExists(bytes32 protocol) {     _verifyProtocolExists(_protocol);     ;   } /// @notice View current protocolAgent of _protocol   /// @param protocol Protocol identifier   /// @return Address able to submit claims   function protocolAgent(bytes32 _protocol) external view override returns (address) {     address agent = protocolAgent[_protocol];     if (agent != address(0)) return agent; // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned // Note: Old protocol agent will never be address(0) if (block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]) {   return removedProtocolAgent[_protocol]; }  // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned revert ProtocolNotExists(_protocol);  } // Checks if the protocol exists, then returns the current premium per second being charged   /// @notice View current premium of protocol   /// @param protocol Protocol identifier   /// @return Amount of premium _protocol pays per second   function premium(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return premiums[_protocol];   } // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)   // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)   function verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {     _protocolAgent = protocolAgent[_protocol];     if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);   } //   // View methods   // // Calcs the debt accrued by the protocol since it last had an accounting update   // This is the amount that needs to be removed from a protocol's active balance   function calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {     return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums[_protocol];   } /// @notice View the amount nonstakers can claim from this protocol   /// @param _protocol Protocol identifier   /// @return Amount of tokens claimable by nonstakers   /// @dev this reads from a storage variable + (now-lastsettled) * premiums   // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]   // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed   function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {     // Calcs the debt of a protocol since the last accounting update     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     // Gets the active balance of the protocol     uint256 balance = activeBalances[_protocol];     // The debt should never be higher than the balance (only happens if the arbitrages fail)     if (debt &gt; balance) debt = balance; // Adds the incremental claimable amount owed to nonstakers to the total claimable amount return   nonStakersClaimableByProtocol[_protocol] +   (nonStakersPercentage[_protocol] * debt) /   HUNDRED_PERCENT;  } /// @notice View current amount of all premiums that are owed to stakers   /// @return Premiums claimable   /// @dev Will increase every block   /// @dev base + (now - last_settled) * ps   function claimablePremiums() public view override returns (uint256) {     // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)     return       lastClaimablePremiumsForStakers +       (block.timestamp - lastAccountedGlobal) *       allPremiumsPerSecToStakers;   } /// @notice View seconds of coverage left for _protocol before it runs out of active balance   /// @param _protocol Protocol identifier   /// @return Seconds of coverage left   function secondsOfCoverageLeft(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return _secondsOfCoverageLeft(_protocol);   } // Helper function to return seconds of coverage left for a protocol   // Gets the current active balance of the protocol and divides by the premium per second for the protocol   function secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {     uint256 premium = premiums[_protocol];     if (premium == 0) return 0;     return _activeBalance(_protocol) / premium;   } /// @notice View current active balance of covered protocol   /// @param _protocol Protocol identifier   /// @return Active balance   /// @dev Accrued debt is subtracted from the stored active balance   function activeBalance(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return _activeBalance(_protocol);   } // Helper function to calc the active balance of a protocol at current time   function _activeBalance(bytes32 _protocol) internal view returns (uint256) {     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     uint256 balance = activeBalances[_protocol];     // The debt should never be higher than the balance (only happens if the arbitrages fail)     if (debt &gt; balance) return 0;     return balance - debt;   } //   // State methods   // /// @notice Helps set the premium per second for an individual protocol   /// @param protocol Protocol identifier   /// @param _premium New premium per second   /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function   function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)     internal     returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)   {     // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers     // Also updates the last accounted timestamp for this protocol     // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings     // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol     nonStakerPercentage = _settleProtocolDebt(_protocol);     // Stores the old premium before it gets updated     oldPremiumPerSecond = premiums[_protocol]; if (oldPremiumPerSecond != _premium) {   // Sets the protocol's premium per second to the new value   premiums_[_protocol] = _premium;   emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium); } // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point // Where arbs would no longer be incentivized to remove the protocol // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems if (_premium != 0 &amp;&amp; _secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_OF_COVERAGE) {   revert InsufficientBalance(_protocol); }  } /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second   /// @param _protocol Protocol identifier   /// @param _premium New premium per second   function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {     // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings     (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(       _protocol,       _premium     );     // Settling the total amount of premiums owed to stakers before a new premium per second gets set     _settleTotalDebt();     // This calculates the new global premium per second that gets paid to stakers     // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function     allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(       oldPremiumPerSecond,       _premium,       nonStakerPercentage,       nonStakerPercentage,       allPremiumsPerSecToStakers     );   } // Internal function to set a new protocolAgent for a specific protocol   // oldAgent is only included as part of emitting an event   function _setProtocolAgent(     bytes32 _protocol,     address _oldAgent,     address _protocolAgent   ) internal {     protocolAgent[_protocol] = _protocolAgent;     emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);   } // Subtracts the accrued debt from a protocol's active balance   // Credits the amount that can be claimed by nonstakers for this protocol   // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings   // Most of this function is dealing with an edge case related to a protocol not being removed by arbs   function settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {     // This calcs the accrued debt of the protocol since it was last updated     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     // This pulls the percentage that is sent to nonstakers     _nonStakerPercentage = nonStakersPercentage[_protocol];     // In case the protocol has accrued debt, this code block will ensure the debt is settled properly     if (debt != 0) {       // Pulls the stored active balance of the protocol       uint256 balance = activeBalances[_protocol];       // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance       // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point       // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage       // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up       if (debt &gt; balance) {         // This error amount represents the magnitude of the mistake         uint256 error = debt - balance;         // Gets the latest value of claimable premiums for stakers         _settleTotalDebt();         // @note to production, set premium first to zero before solving accounting issue.         // otherwise the accounting error keeps increasing         uint256 lastClaimablePremiumsForStakers = lastClaimablePremiumsForStakers;     // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%     uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /       HUNDRED_PERCENT;      // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short     uint256 insufficientTokens;      // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally     // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error     // This first line can be true if claimPremiumsForStakers() has been called and     // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be &gt;0 still     if (claimablePremiumError &gt; lastClaimablePremiumsForStakers_) {       insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;       lastClaimablePremiumsForStakers = 0;     } else {       // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums       // By the amount that was added in error (error) and insufficientTokens = 0       lastClaimablePremiumsForStakers =         lastClaimablePremiumsForStakers_ -         claimablePremiumError;     }      // If two events are thrown, the values need to be summed up for the actual state.     // This means an error of this type will continue until it is handled     emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);     // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case     debt = balance;   }   // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance   activeBalances[_protocol] = balance - debt;   // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol   nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT; } // Updates the last accounted timestamp for this protocol lastAccountedEachProtocol[_protocol] = block.timestamp;  } // Multiplies the total premium per second * number of seconds since the last global accounting update   // And adds it to the total claimable amount for stakers   function _settleTotalDebt() internal {     lastClaimablePremiumsForStakers +=       (block.timestamp - lastAccountedGlobal) *       allPremiumsPerSecToStakers;     lastAccountedGlobal = block.timestamp;   } // Calculates the global premium per second for stakers   // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers   // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones   function _calcGlobalPremiumPerSecForStakers(     uint256 _premiumOld,     uint256 _premiumNew,     uint256 _nonStakerPercentageOld,     uint256 _nonStakerPercentageNew,     uint256 _inMemAllPremiumsPerSecToStakers   ) internal pure returns (uint256) {     return       _inMemAllPremiumsPerSecToStakers +       ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /       HUNDRED_PERCENT -       ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /       HUNDRED_PERCENT;   } // Helper function to remove and clean up a protocol from Sherlock   // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made   function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {     // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol     _setSingleAndGlobalProtocolPremium(_protocol, 0); // Grabs the protocol's active balance uint256 balance = activeBalances[_protocol];  // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent if (balance != 0) {   delete activeBalances[_protocol];   token.safeTransfer(_agent, balance);    emit ProtocolBalanceWithdrawn(_protocol, balance); }  // Sets the protocol agent to zero address (as part of clean up) _setProtocolAgent(_protocol, _agent, address(0));  // Cleans up other mappings for this protocol delete nonStakersPercentage[_protocol]; delete lastAccountedEachProtocol[_protocol]; // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above  // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;  // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked removedProtocolAgent[_protocol] = _agent;  emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0)); emit ProtocolRemoved(_protocol);  } /// @notice Sets the minimum active balance before an arb can remove a protocol   /// @param _minActiveBalance Minimum balance needed (in USDC)   /// @dev Only gov   function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {     // New value cannot be the same as current value     if (minActiveBalance == _minActiveBalance) revert InvalidArgument();     // Can't set a value that is too high to be reasonable     if (_minActiveBalance &gt;= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions(); emit MinBalance(minActiveBalance, _minActiveBalance); minActiveBalance = _minActiveBalance;  } // This function allows the nonstakers role to claim tokens owed to them by a specific protocol   /// @notice Choose an _amount of tokens that nonstakers (_receiver address) will receive from _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens   /// @param _receiver Address to receive tokens   /// @dev Only callable by nonstakers role   function nonStakersClaim(     bytes32 _protocol,     uint256 _amount,     address _receiver   ) external override whenNotPaused {     if (_protocol == bytes32(0)) revert ZeroArgument();     if (_amount == uint256(0)) revert ZeroArgument();     if (_receiver == address(0)) revert ZeroArgument();     // Only the nonstakers role (multisig or contract) can pull the funds     if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized(); // Call can't be executed on protocol that is removed if (protocolAgent_[_protocol] != address(0)) {   // Updates the amount that nonstakers can claim from this protocol   _settleProtocolDebt(_protocol); }  // Sets balance to the amount that is claimable by nonstakers for this specific protocol uint256 balance = nonStakersClaimableByProtocol[_protocol]; // If the amount requested is more than what's owed to nonstakers, revert if (_amount &gt; balance) revert InsufficientBalance(_protocol);  // Sets the claimable amount to whatever is left over after this amount is pulled nonStakersClaimableByProtocol[_protocol] = balance - _amount; // Transfers the amount requested to the `_receiver` address token.safeTransfer(_receiver, _amount);  } // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)   /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address   /// @dev Callable by everyone   /// @dev Funds will be transferred to Sherlock core contract   function claimPremiumsForStakers() external override whenNotPaused {     // Gets address of core Sherlock contract     address sherlock = address(sherlockCore);     // Revert if core Sherlock contract not initialized yet     if (sherlock == address(0)) revert InvalidConditions(); // claimablePremiums is different from _settleTotalDebt() because it does not change state // Retrieves current amount of all premiums that are owed to stakers uint256 amount = claimablePremiums();  // Transfers all the premiums owed to stakers to the Sherlock core contract if (amount != 0) {   // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out   lastClaimablePremiumsForStakers = 0;   lastAccountedGlobal = block.timestamp;   token.safeTransfer(sherlock, amount); }  } // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts   /// @param protocol Protocol identifier   /// @return current and previous are the current and previous coverage amounts for this protocol   // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)   function coverageAmounts(bytes32 _protocol)     external     view     override     returns (uint256 current, uint256 previous)   {     // Checks to see if the protocol has an active protocolAgent (protocol not removed)     // OR checks to see if the removed protocol is still within the claim window     // If so, gives the current and previous coverage, otherwise throws an error     if (       protocolAgent[_protocol] != address(0) ||       block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]     ) {       return (currentCoverage[_protocol], previousCoverage[_protocol]);     } revert ProtocolNotExists(_protocol);  } /// @notice Add a new protocol to Sherlock   /// @param protocol Protocol identifier   /// @param _protocolAgent Address able to submit a claim on behalf of the protocol   /// @param _coverage Hash referencing the active coverage agreement   /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 1018   /// @param _coverageAmount Max amount claimable by this protocol   /// @dev Adding a protocol allows the _protocolAgent to submit a claim   /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point   /// @dev _nonStakers is scaled by 1018   /// @dev Only callable by governance   function protocolAdd(     bytes32 _protocol,     address _protocolAgent,     bytes32 _coverage,     uint256 _nonStakers,     uint256 _coverageAmount   ) external override onlyOwner {     if (_protocol == bytes32(0)) revert ZeroArgument();     if (_protocolAgent == address(0)) revert ZeroArgument();     // Checks to make sure the protocol doesn't exist already     if (protocolAgent[_protocol] != address(0)) revert InvalidConditions(); // Updates the protocol agent and passes in the old agent which is 0 address in this case _setProtocolAgent(_protocol, address(0), _protocolAgent);  // Delete mappings that are potentially non default values // From previous time protocol was added/removed delete removedProtocolClaimDeadline[_protocol]; delete removedProtocolAgent[_protocol]; delete currentCoverage[_protocol]; delete previousCoverage[_protocol];  emit ProtocolAdded(_protocol);  // Most of the logic for actually adding a protocol in this function protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);  } /// @notice Update info regarding a protocol   /// @param _protocol Protocol identifier   /// @param _coverage Hash referencing the active coverage agreement   /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18   /// @param _coverageAmount Max amount claimable by this protocol   /// @dev Only callable by governance   /// @dev _nonStakers can be 0   function protocolUpdate(     bytes32 _protocol,     bytes32 _coverage,     uint256 _nonStakers,     uint256 _coverageAmount   ) public override onlyOwner {     if (_coverage == bytes32(0)) revert ZeroArgument();     if (_nonStakers &gt; HUNDRED_PERCENT) revert InvalidArgument();     if (_coverageAmount == uint256(0)) revert ZeroArgument(); // Checks to make sure the protocol has been assigned a protocol agent _verifyProtocolExists(_protocol);  // Subtracts the accrued debt from a protocol's active balance (if any) // Updates the amount that can be claimed by nonstakers _settleProtocolDebt(_protocol);  // Updates the global claimable amount for stakers _settleTotalDebt();  // Gets the premium per second for this protocol uint256 premium = premiums_[_protocol];  // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be) allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(   premium,   premium,   nonStakersPercentage[_protocol],   _nonStakers,   allPremiumsPerSecToStakers );  // Updates the stored value of percentage of premiums that go to nonstakers nonStakersPercentage[_protocol] = _nonStakers;  // Updates previous coverage and current coverage amounts previousCoverage[_protocol] = currentCoverage[_protocol]; currentCoverage[_protocol] = _coverageAmount;  emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);  } /// @notice Remove a protocol from coverage   /// @param _protocol Protocol identifier   /// @dev Before removing a protocol the premium must be 0   /// @dev Removing a protocol basically stops the _protocolAgent from being active (can still submit claims until claim deadline though)   /// @dev Pays off debt + sends remaining balance to protocol agent   /// @dev This call should be subject to a timelock   /// @dev Only callable by governance   function protocolRemove(bytes32 _protocol) external override onlyOwner {     // checks to make sure the protocol actually has a protocol agent     address agent = _verifyProtocolExists(_protocol); // Removes a protocol from Sherlock and cleans up its data // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made _forceRemoveProtocol(_protocol, agent);  } /// @notice Remove a protocol with insufficient active balance   /// @param _protocol Protocol identifier   // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function   function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {     address agent = _verifyProtocolExists(_protocol); // Gets the latest value of the active balance at this protocol _settleProtocolDebt(_protocol); // Sets latest value of active balance to remainingBalance variable uint256 remainingBalance = activeBalances[_protocol];  // This means the protocol still has adequate active balance and thus cannot be removed if (remainingBalance &gt;= minActiveBalance) revert InvalidConditions();  // Sets the protocol's active balance to 0 delete activeBalances[_protocol]; // Removes the protocol from coverage _forceRemoveProtocol(_protocol, agent);  if (remainingBalance != 0) {   // sends the remaining balance to msg.sender   token.safeTransfer(msg.sender, remainingBalance); } emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);  } /// @notice Calculate if arb is possible and what the reward would be   /// @param _protocol Protocol identifier   /// @return arbAmount Amount reward for arbing   /// @return able Indicator if arb call is even possible   /// @dev Doesn't subtract the current protocol debt from the active balance   function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)     internal     view     returns (uint256 arbAmount, bool able)   {     uint256 secondsLeft = _secondsOfCoverageLeft(_protocol); // If arb is not possible return false if (secondsLeft &gt;= MIN_SECONDS_OF_COVERAGE) return (0, false);  // This percentage scales over time // Reaches 100% on 0 seconds of coverage left uint256 percentageScaled = HUNDRED_PERCENT -   (secondsLeft * HUNDRED_PERCENT) /   MIN_SECONDS_OF_COVERAGE;  able = true; arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;  } /// @notice Removes a protocol with insufficent seconds of coverage left   /// @param _protocol Protocol identifier   // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second   function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {     // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings     address agent = _verifyProtocolExists(_protocol); // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance() // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance() // But when removing based on seconds of coverage left, the remainingBalance could still be quite large // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%) _settleProtocolDebt(_protocol); (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol); if (able == false) revert InvalidConditions();  if (arbAmount != 0) {   // subtracts the amount that will be paid to the arb from the active balance   activeBalances[_protocol] -= arbAmount; }  // Removes the protocol from coverage // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above _forceRemoveProtocol(_protocol, agent);  // Done after removing protocol to mitigate reentrency pattern // (In case token allows callback) if (arbAmount != 0) {   token.safeTransfer(msg.sender, arbAmount); } emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);  } /// @notice Set premium of _protocol to _premium   /// @param _protocol Protocol identifier   /// @param _premium Amount of premium _protocol pays per second   /// @dev The value 0 would mean inactive coverage   /// @dev Only callable by governance   function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {     // Checks to see if protocol has a protocol agent     _verifyProtocolExists(_protocol); // Updates individual protocol's premium and allPremiumsPerSecToStakers _setSingleAndGlobalProtocolPremium(_protocol, _premium);  } /// @notice Set premium of multiple protocols   /// @param _protocol Array of protocol identifiers   /// @param _premium Array of premium amounts protocols pay per second   /// @dev The value 0 would mean inactive coverage   /// @dev Only callable by governance   function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)     external     override     onlyOwner   {     // Checks to make sure there are an equal amount of entries in each array     if (_protocol.length != _premium.length) revert UnequalArrayLength();     if (_protocol.length == 0) revert InvalidArgument(); // Updates the global claimable amount for stakers _settleTotalDebt();  uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;  // Loops through the array of protocols and checks to make sure each has a protocol agent assigned for (uint256 i; i &lt; _protocol.length; i++) {   _verifyProtocolExists(_protocol[i]);    // Sets the protocol premium for that specific protocol   // Function returns the old premium and nonStakerPercentage for that specific protocol   (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(     _protocol[i],     _premium[i]   );    // Calculates the new global premium which adds up all premiums paid by all protocols   allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(     oldPremiumPerSecond,     _premium[i],     nonStakerPercentage,     nonStakerPercentage,     allPremiumsPerSecToStakers_   ); }  // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;  } // This is how protocols pay for coverage by increasing their active balance   /// @notice Deposits _amount of token to the active balance of _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens to deposit   /// @dev Approval should be made before calling   function depositToActiveBalance(bytes32 _protocol, uint256 _amount)     external     override     whenNotPaused   {     if (_amount == uint256(0)) revert ZeroArgument();     _verifyProtocolExists(_protocol); // Transfers _amount to this contract token.safeTransferFrom(msg.sender, address(this), _amount); // Increases the active balance of the protocol by _amount activeBalances[_protocol] += _amount;  emit ProtocolBalanceDeposited(_protocol, _amount);  } // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)   // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)   /// @notice Withdraws _amount of token from the active balance of _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens to withdraw   /// @dev Only protocol agent is able to withdraw   /// @dev Balance can be withdrawn up until 7 days worth of active balance   function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)     external     override     whenNotPaused   {     if (_amount == uint256(0)) revert ZeroArgument();     // Only the protocol agent can call this function     if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized(); // Updates the active balance of the protocol _settleProtocolDebt(_protocol);  // Sets currentBalance to the active balance of the protocol uint256 currentBalance = activeBalances[_protocol]; // Reverts if trying to withdraw more than the active balance if (_amount &gt; currentBalance) revert InsufficientBalance(_protocol);  // Removes the _amount to be withdrawn from the active balance activeBalances[_protocol] = currentBalance - _amount; // Reverts if a protocol has less than 7 days worth of active balance left if (_secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);  // Transfers the amount to the msg.sender (protocol agent) token.safeTransfer(msg.sender, _amount); emit ProtocolBalanceWithdrawn(_protocol, _amount);  } /// @notice Transfer protocol agent role   /// @param _protocol Protocol identifier   /// @param _protocolAgent Account able to submit a claim on behalf of the protocol   /// @dev Only the active protocolAgent is able to transfer the role   function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)     external     override     whenNotPaused   {     if (_protocolAgent == address(0)) revert ZeroArgument();     // Can't set the new protocol agent to the caller address     if (msg.sender == _protocolAgent) revert InvalidArgument();     // Because the caller must be the current protocol agent     if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized(); // Sets the protocol agent to the new address _setProtocolAgent(_protocol, msg.sender, _protocolAgent);  } /// @notice Function used to check if this is the current active protocol manager   /// @return Boolean indicating it's active   /// @dev If inactive the owner can pull all ERC20s and ETH   /// @dev Will be checked by calling the sherlock contract   function isActive() public view returns (bool) {     return address(sherlockCore.sherlockProtocolManager()) == address(this);   } // Only contract owner can call this   // Sends all specified tokens in this contract to the receiver's address (as well as ETH)   function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {     if (_receiver == address(0)) revert ZeroArgument();     // This contract must NOT be the current assigned protocol manager contract     if (isActive()) revert InvalidConditions();     // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH     _sweep(_receiver, _extraTokens);   } } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-25-08 10:59:23 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import './Manager.sol'; import '../interfaces/managers/ISherlockProtocolManager.sol'; /// @title Sherlock core interface for protocols /// @author Evert Kors // This is the contract that manages covered protocols contract SherlockProtocolManager is ISherlockProtocolManager, Manager {   using SafeERC20 for IERC20; // Represents the token that protocols pay with (currently USDC)   IERC20 public immutable token; // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed   uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc // A removed protocol is still able to make a claim for this amount of time after its removal   uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days; // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance   uint256 public constant MIN_SECONDS_LEFT = 7 days; // Convenient for percentage calculations   uint256 internal constant HUNDRED_PERCENT = 10**18; // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage   // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying   uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours; // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)   mapping(bytes32 =&gt; address) internal protocolAgent_; // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)   mapping(bytes32 =&gt; uint256) internal nonStakersPercentage; // The premium per second paid by each protocol is stored in this mapping   mapping(bytes32 =&gt; uint256) internal premiums_; // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.   // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not   mapping(bytes32 =&gt; uint256) internal activeBalances; // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol   mapping(bytes32 =&gt; uint256) internal lastAccountedEachProtocol; // The amount that can be claimed by nonstakers for each protocol   // We need this value so we can track how much payment is coming from each protocol   mapping(bytes32 =&gt; uint256) internal nonStakersClaimableByProtocol; // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)   uint256 internal lastAccountedGlobal; // This is the total amount of premiums paid (per second) by all the covered protocols (added up)   uint256 internal allPremiumsPerSecToStakers; // This is the amount that was claimable by stakers the last time the accounting was run   // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date   uint256 internal lastClaimablePremiumsForStakers; // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage   // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)   uint256 public override minActiveBalance; // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)   mapping(bytes32 =&gt; uint256) internal removedProtocolClaimDeadline; // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)   mapping(bytes32 =&gt; address) internal removedProtocolAgent; // Current amount of coverage (i.e. 20M USDC) for a protocol   mapping(bytes32 =&gt; uint256) internal currentCoverage; // Previous amount of coverage for a protocol   // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount   mapping(bytes32 =&gt; uint256) internal previousCoverage; // Setting the token to USDC   constructor(IERC20 _token) {     if (address(_token) == address(0)) revert ZeroArgument();     token = _token;   } // Modifier used to ensure a protocol exists (has been instantiated and not removed)   modifier protocolExists(bytes32 protocol) {     _verifyProtocolExists(_protocol);     ;   } /// @notice View current protocolAgent of _protocol   /// @param protocol Protocol identifier   /// @return Address able to submit claims   function protocolAgent(bytes32 _protocol) external view override returns (address) {     address agent = protocolAgent[_protocol];     if (agent != address(0)) return agent; // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned // Note: Old protocol agent will never be address(0) if (block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]) {   return removedProtocolAgent[_protocol]; }  // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned revert ProtocolNotExists(_protocol);  } // Checks if the protocol exists, then returns the current premium per second being charged   /// @notice View current premium of protocol   /// @param protocol Protocol identifier   /// @return Amount of premium _protocol pays per second   function premium(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return premiums[_protocol];   } // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)   // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)   function verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {     _protocolAgent = protocolAgent[_protocol];     if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);   } //   // View methods   // // Calcs the debt accrued by the protocol since it last had an accounting update   // This is the amount that needs to be removed from a protocol's active balance   function calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {     return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums[_protocol];   } /// @notice View the amount nonstakers can claim from this protocol   /// @param _protocol Protocol identifier   /// @return Amount of tokens claimable by nonstakers   /// @dev this reads from a storage variable + (now-lastsettled) * premiums   // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]   // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed   function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {     // Calcs the debt of a protocol since the last accounting update     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     // Gets the active balance of the protocol     uint256 balance = activeBalances[_protocol];     // The debt should never be higher than the balance (only happens if the arbitrages fail)     if (debt &gt; balance) debt = balance; // Adds the incremental claimable amount owed to nonstakers to the total claimable amount return   nonStakersClaimableByProtocol[_protocol] +   (nonStakersPercentage[_protocol] * debt) /   HUNDRED_PERCENT;  } /// @notice View current amount of all premiums that are owed to stakers   /// @return Premiums claimable   /// @dev Will increase every block   /// @dev base + (now - last_settled) * ps   function claimablePremiums() public view override returns (uint256) {     // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)     return       lastClaimablePremiumsForStakers +       (block.timestamp - lastAccountedGlobal) *       allPremiumsPerSecToStakers;   } /// @notice View seconds of coverage left for _protocol before it runs out of active balance   /// @param _protocol Protocol identifier   /// @return Seconds of coverage left   function secondsOfCoverageLeft(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return _secondsOfCoverageLeft(_protocol);   } // Helper function to return seconds of coverage left for a protocol   // Gets the current active balance of the protocol and divides by the premium per second for the protocol   function secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {     uint256 premium = premiums[_protocol];     if (premium == 0) return 0;     return _activeBalance(_protocol) / premium;   } /// @notice View current active balance of covered protocol   /// @param _protocol Protocol identifier   /// @return Active balance   /// @dev Accrued debt is subtracted from the stored active balance   function activeBalance(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return _activeBalance(_protocol);   } // Helper function to calc the active balance of a protocol at current time   function _activeBalance(bytes32 _protocol) internal view returns (uint256) {     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     uint256 balance = activeBalances[_protocol];     // The debt should never be higher than the balance (only happens if the arbitrages fail)     if (debt &gt; balance) return 0;     return balance - debt;   } //   // State methods   // /// @notice Helps set the premium per second for an individual protocol   /// @param protocol Protocol identifier   /// @param _premium New premium per second   /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function   function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)     internal     returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)   {     // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers     // Also updates the last accounted timestamp for this protocol     // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings     // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol     nonStakerPercentage = _settleProtocolDebt(_protocol);     // Stores the old premium before it gets updated     oldPremiumPerSecond = premiums[_protocol]; if (oldPremiumPerSecond != _premium) {   // Sets the protocol's premium per second to the new value   premiums_[_protocol] = _premium;   emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium); } // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point // Where arbs would no longer be incentivized to remove the protocol // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems if (_premium != 0 &amp;&amp; _secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_OF_COVERAGE) {   revert InsufficientBalance(_protocol); }  } /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second   /// @param _protocol Protocol identifier   /// @param _premium New premium per second   function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {     // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings     (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(       _protocol,       _premium     );     // Settling the total amount of premiums owed to stakers before a new premium per second gets set     _settleTotalDebt();     // This calculates the new global premium per second that gets paid to stakers     // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function     allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(       oldPremiumPerSecond,       _premium,       nonStakerPercentage,       nonStakerPercentage,       allPremiumsPerSecToStakers     );   } // Internal function to set a new protocolAgent for a specific protocol   // oldAgent is only included as part of emitting an event   function _setProtocolAgent(     bytes32 _protocol,     address _oldAgent,     address _protocolAgent   ) internal {     protocolAgent[_protocol] = _protocolAgent;     emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);   } // Subtracts the accrued debt from a protocol's active balance   // Credits the amount that can be claimed by nonstakers for this protocol   // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings   // Most of this function is dealing with an edge case related to a protocol not being removed by arbs   function settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {     // This calcs the accrued debt of the protocol since it was last updated     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     // This pulls the percentage that is sent to nonstakers     _nonStakerPercentage = nonStakersPercentage[_protocol];     // In case the protocol has accrued debt, this code block will ensure the debt is settled properly     if (debt != 0) {       // Pulls the stored active balance of the protocol       uint256 balance = activeBalances[_protocol];       // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance       // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point       // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage       // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up       if (debt &gt; balance) {         // This error amount represents the magnitude of the mistake         uint256 error = debt - balance;         // Gets the latest value of claimable premiums for stakers         _settleTotalDebt();         // @note to production, set premium first to zero before solving accounting issue.         // otherwise the accounting error keeps increasing         uint256 lastClaimablePremiumsForStakers = lastClaimablePremiumsForStakers;     // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%     uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /       HUNDRED_PERCENT;      // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short     uint256 insufficientTokens;      // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally     // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error     // This first line can be true if claimPremiumsForStakers() has been called and     // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be &gt;0 still     if (claimablePremiumError &gt; lastClaimablePremiumsForStakers_) {       insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;       lastClaimablePremiumsForStakers = 0;     } else {       // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums       // By the amount that was added in error (error) and insufficientTokens = 0       lastClaimablePremiumsForStakers =         lastClaimablePremiumsForStakers_ -         claimablePremiumError;     }      // If two events are thrown, the values need to be summed up for the actual state.     // This means an error of this type will continue until it is handled     emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);     // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case     debt = balance;   }   // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance   activeBalances[_protocol] = balance - debt;   // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol   nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT; } // Updates the last accounted timestamp for this protocol lastAccountedEachProtocol[_protocol] = block.timestamp;  } // Multiplies the total premium per second * number of seconds since the last global accounting update   // And adds it to the total claimable amount for stakers   function _settleTotalDebt() internal {     lastClaimablePremiumsForStakers +=       (block.timestamp - lastAccountedGlobal) *       allPremiumsPerSecToStakers;     lastAccountedGlobal = block.timestamp;   } // Calculates the global premium per second for stakers   // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers   // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones   function _calcGlobalPremiumPerSecForStakers(     uint256 _premiumOld,     uint256 _premiumNew,     uint256 _nonStakerPercentageOld,     uint256 _nonStakerPercentageNew,     uint256 _inMemAllPremiumsPerSecToStakers   ) internal pure returns (uint256) {     return       _inMemAllPremiumsPerSecToStakers +       ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /       HUNDRED_PERCENT -       ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /       HUNDRED_PERCENT;   } // Helper function to remove and clean up a protocol from Sherlock   // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made   function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {     // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol     _setSingleAndGlobalProtocolPremium(_protocol, 0); // Grabs the protocol's active balance uint256 balance = activeBalances[_protocol];  // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent if (balance != 0) {   delete activeBalances[_protocol];   token.safeTransfer(_agent, balance);    emit ProtocolBalanceWithdrawn(_protocol, balance); }  // Sets the protocol agent to zero address (as part of clean up) _setProtocolAgent(_protocol, _agent, address(0));  // Cleans up other mappings for this protocol delete nonStakersPercentage[_protocol]; delete lastAccountedEachProtocol[_protocol]; // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above  // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;  // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked removedProtocolAgent[_protocol] = _agent;  emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0)); emit ProtocolRemoved(_protocol);  } /// @notice Sets the minimum active balance before an arb can remove a protocol   /// @param _minActiveBalance Minimum balance needed (in USDC)   /// @dev Only gov   function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {     // New value cannot be the same as current value     if (minActiveBalance == _minActiveBalance) revert InvalidArgument();     // Can't set a value that is too high to be reasonable     if (_minActiveBalance &gt;= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions(); emit MinBalance(minActiveBalance, _minActiveBalance); minActiveBalance = _minActiveBalance;  } // This function allows the nonstakers role to claim tokens owed to them by a specific protocol   /// @notice Choose an _amount of tokens that nonstakers (_receiver address) will receive from _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens   /// @param _receiver Address to receive tokens   /// @dev Only callable by nonstakers role   function nonStakersClaim(     bytes32 _protocol,     uint256 _amount,     address _receiver   ) external override whenNotPaused {     if (_protocol == bytes32(0)) revert ZeroArgument();     if (_amount == uint256(0)) revert ZeroArgument();     if (_receiver == address(0)) revert ZeroArgument();     // Only the nonstakers role (multisig or contract) can pull the funds     if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized(); // Call can't be executed on protocol that is removed if (protocolAgent_[_protocol] != address(0)) {   // Updates the amount that nonstakers can claim from this protocol   _settleProtocolDebt(_protocol); }  // Sets balance to the amount that is claimable by nonstakers for this specific protocol uint256 balance = nonStakersClaimableByProtocol[_protocol]; // If the amount requested is more than what's owed to nonstakers, revert if (_amount &gt; balance) revert InsufficientBalance(_protocol);  // Sets the claimable amount to whatever is left over after this amount is pulled nonStakersClaimableByProtocol[_protocol] = balance - _amount; // Transfers the amount requested to the `_receiver` address token.safeTransfer(_receiver, _amount);  } // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)   /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address   /// @dev Callable by everyone   /// @dev Funds will be transferred to Sherlock core contract   function claimPremiumsForStakers() external override whenNotPaused {     // Gets address of core Sherlock contract     address sherlock = address(sherlockCore);     // Revert if core Sherlock contract not initialized yet     if (sherlock == address(0)) revert InvalidConditions(); // claimablePremiums is different from _settleTotalDebt() because it does not change state // Retrieves current amount of all premiums that are owed to stakers uint256 amount = claimablePremiums();  // Transfers all the premiums owed to stakers to the Sherlock core contract if (amount != 0) {   // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out   lastClaimablePremiumsForStakers = 0;   lastAccountedGlobal = block.timestamp;   token.safeTransfer(sherlock, amount); }  } // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts   /// @param protocol Protocol identifier   /// @return current and previous are the current and previous coverage amounts for this protocol   // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)   function coverageAmounts(bytes32 _protocol)     external     view     override     returns (uint256 current, uint256 previous)   {     // Checks to see if the protocol has an active protocolAgent (protocol not removed)     // OR checks to see if the removed protocol is still within the claim window     // If so, gives the current and previous coverage, otherwise throws an error     if (       protocolAgent[_protocol] != address(0) ||       block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]     ) {       return (currentCoverage[_protocol], previousCoverage[_protocol]);     } revert ProtocolNotExists(_protocol);  } /// @notice Add a new protocol to Sherlock   /// @param protocol Protocol identifier   /// @param _protocolAgent Address able to submit a claim on behalf of the protocol   /// @param _coverage Hash referencing the active coverage agreement   /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 1018   /// @param _coverageAmount Max amount claimable by this protocol   /// @dev Adding a protocol allows the _protocolAgent to submit a claim   /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point   /// @dev _nonStakers is scaled by 1018   /// @dev Only callable by governance   function protocolAdd(     bytes32 _protocol,     address _protocolAgent,     bytes32 _coverage,     uint256 _nonStakers,     uint256 _coverageAmount   ) external override onlyOwner {     if (_protocol == bytes32(0)) revert ZeroArgument();     if (_protocolAgent == address(0)) revert ZeroArgument();     // Checks to make sure the protocol doesn't exist already     if (protocolAgent[_protocol] != address(0)) revert InvalidConditions(); // Updates the protocol agent and passes in the old agent which is 0 address in this case _setProtocolAgent(_protocol, address(0), _protocolAgent);  // Delete mappings that are potentially non default values // From previous time protocol was added/removed delete removedProtocolClaimDeadline[_protocol]; delete removedProtocolAgent[_protocol]; delete currentCoverage[_protocol]; delete previousCoverage[_protocol];  emit ProtocolAdded(_protocol);  // Most of the logic for actually adding a protocol in this function protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);  } /// @notice Update info regarding a protocol   /// @param _protocol Protocol identifier   /// @param _coverage Hash referencing the active coverage agreement   /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18   /// @param _coverageAmount Max amount claimable by this protocol   /// @dev Only callable by governance   /// @dev _nonStakers can be 0   function protocolUpdate(     bytes32 _protocol,     bytes32 _coverage,     uint256 _nonStakers,     uint256 _coverageAmount   ) public override onlyOwner {     if (_coverage == bytes32(0)) revert ZeroArgument();     if (_nonStakers &gt; HUNDRED_PERCENT) revert InvalidArgument();     if (_coverageAmount == uint256(0)) revert ZeroArgument(); // Checks to make sure the protocol has been assigned a protocol agent _verifyProtocolExists(_protocol);  // Subtracts the accrued debt from a protocol's active balance (if any) // Updates the amount that can be claimed by nonstakers _settleProtocolDebt(_protocol);  // Updates the global claimable amount for stakers _settleTotalDebt();  // Gets the premium per second for this protocol uint256 premium = premiums_[_protocol];  // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be) allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(   premium,   premium,   nonStakersPercentage[_protocol],   _nonStakers,   allPremiumsPerSecToStakers );  // Updates the stored value of percentage of premiums that go to nonstakers nonStakersPercentage[_protocol] = _nonStakers;  // Updates previous coverage and current coverage amounts previousCoverage[_protocol] = currentCoverage[_protocol]; currentCoverage[_protocol] = _coverageAmount;  emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);  } /// @notice Remove a protocol from coverage   /// @param _protocol Protocol identifier   /// @dev Before removing a protocol the premium must be 0   /// @dev Removing a protocol basically stops the _protocolAgent from being active (can still submit claims until claim deadline though)   /// @dev Pays off debt + sends remaining balance to protocol agent   /// @dev This call should be subject to a timelock   /// @dev Only callable by governance   function protocolRemove(bytes32 _protocol) external override onlyOwner {     // checks to make sure the protocol actually has a protocol agent     address agent = _verifyProtocolExists(_protocol); // Removes a protocol from Sherlock and cleans up its data // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made _forceRemoveProtocol(_protocol, agent);  } /// @notice Remove a protocol with insufficient active balance   /// @param _protocol Protocol identifier   // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function   function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {     address agent = _verifyProtocolExists(_protocol); // Gets the latest value of the active balance at this protocol _settleProtocolDebt(_protocol); // Sets latest value of active balance to remainingBalance variable uint256 remainingBalance = activeBalances[_protocol];  // This means the protocol still has adequate active balance and thus cannot be removed if (remainingBalance &gt;= minActiveBalance) revert InvalidConditions();  // Sets the protocol's active balance to 0 delete activeBalances[_protocol]; // Removes the protocol from coverage _forceRemoveProtocol(_protocol, agent);  if (remainingBalance != 0) {   // sends the remaining balance to msg.sender   token.safeTransfer(msg.sender, remainingBalance); } emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);  } /// @notice Calculate if arb is possible and what the reward would be   /// @param _protocol Protocol identifier   /// @return arbAmount Amount reward for arbing   /// @return able Indicator if arb call is even possible   /// @dev Doesn't subtract the current protocol debt from the active balance   function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)     internal     view     returns (uint256 arbAmount, bool able)   {     uint256 secondsLeft = _secondsOfCoverageLeft(_protocol); // If arb is not possible return false if (secondsLeft &gt;= MIN_SECONDS_OF_COVERAGE) return (0, false);  // This percentage scales over time // Reaches 100% on 0 seconds of coverage left uint256 percentageScaled = HUNDRED_PERCENT -   (secondsLeft * HUNDRED_PERCENT) /   MIN_SECONDS_OF_COVERAGE;  able = true; arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;  } /// @notice Removes a protocol with insufficent seconds of coverage left   /// @param _protocol Protocol identifier   // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second   function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {     // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings     address agent = _verifyProtocolExists(_protocol); // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance() // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance() // But when removing based on seconds of coverage left, the remainingBalance could still be quite large // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%) _settleProtocolDebt(_protocol); (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol); if (able == false) revert InvalidConditions();  if (arbAmount != 0) {   // subtracts the amount that will be paid to the arb from the active balance   activeBalances[_protocol] -= arbAmount; }  // Removes the protocol from coverage // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above _forceRemoveProtocol(_protocol, agent);  // Done after removing protocol to mitigate reentrency pattern // (In case token allows callback) if (arbAmount != 0) {   token.safeTransfer(msg.sender, arbAmount); } emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);  } /// @notice Set premium of _protocol to _premium   /// @param _protocol Protocol identifier   /// @param _premium Amount of premium _protocol pays per second   /// @dev The value 0 would mean inactive coverage   /// @dev Only callable by governance   function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {     // Checks to see if protocol has a protocol agent     _verifyProtocolExists(_protocol); // Updates individual protocol's premium and allPremiumsPerSecToStakers _setSingleAndGlobalProtocolPremium(_protocol, _premium);  } /// @notice Set premium of multiple protocols   /// @param _protocol Array of protocol identifiers   /// @param _premium Array of premium amounts protocols pay per second   /// @dev The value 0 would mean inactive coverage   /// @dev Only callable by governance   function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)     external     override     onlyOwner   {     // Checks to make sure there are an equal amount of entries in each array     if (_protocol.length != _premium.length) revert UnequalArrayLength();     if (_protocol.length == 0) revert InvalidArgument(); // Updates the global claimable amount for stakers _settleTotalDebt();  uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;  // Loops through the array of protocols and checks to make sure each has a protocol agent assigned for (uint256 i; i &lt; _protocol.length; i++) {   _verifyProtocolExists(_protocol[i]);    // Sets the protocol premium for that specific protocol   // Function returns the old premium and nonStakerPercentage for that specific protocol   (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(     _protocol[i],     _premium[i]   );    // Calculates the new global premium which adds up all premiums paid by all protocols   allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(     oldPremiumPerSecond,     _premium[i],     nonStakerPercentage,     nonStakerPercentage,     allPremiumsPerSecToStakers_   ); }  // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;  } // This is how protocols pay for coverage by increasing their active balance   /// @notice Deposits _amount of token to the active balance of _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens to deposit   /// @dev Approval should be made before calling   function depositToActiveBalance(bytes32 _protocol, uint256 _amount)     external     override     whenNotPaused   {     if (_amount == uint256(0)) revert ZeroArgument();     _verifyProtocolExists(_protocol); // Transfers _amount to this contract token.safeTransferFrom(msg.sender, address(this), _amount); // Increases the active balance of the protocol by _amount activeBalances[_protocol] += _amount;  emit ProtocolBalanceDeposited(_protocol, _amount);  } // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)   // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)   /// @notice Withdraws _amount of token from the active balance of _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens to withdraw   /// @dev Only protocol agent is able to withdraw   /// @dev Balance can be withdrawn up until 7 days worth of active balance   function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)     external     override     whenNotPaused   {     if (_amount == uint256(0)) revert ZeroArgument();     // Only the protocol agent can call this function     if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized(); // Updates the active balance of the protocol _settleProtocolDebt(_protocol);  // Sets currentBalance to the active balance of the protocol uint256 currentBalance = activeBalances[_protocol]; // Reverts if trying to withdraw more than the active balance if (_amount &gt; currentBalance) revert InsufficientBalance(_protocol);  // Removes the _amount to be withdrawn from the active balance activeBalances[_protocol] = currentBalance - _amount; // Reverts if a protocol has less than 7 days worth of active balance left if (_secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);  // Transfers the amount to the msg.sender (protocol agent) token.safeTransfer(msg.sender, _amount); emit ProtocolBalanceWithdrawn(_protocol, _amount);  } /// @notice Transfer protocol agent role   /// @param _protocol Protocol identifier   /// @param _protocolAgent Account able to submit a claim on behalf of the protocol   /// @dev Only the active protocolAgent is able to transfer the role   function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)     external     override     whenNotPaused   {     if (_protocolAgent == address(0)) revert ZeroArgument();     // Can't set the new protocol agent to the caller address     if (msg.sender == _protocolAgent) revert InvalidArgument();     // Because the caller must be the current protocol agent     if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized(); // Sets the protocol agent to the new address _setProtocolAgent(_protocol, msg.sender, _protocolAgent);  } /// @notice Function used to check if this is the current active protocol manager   /// @return Boolean indicating it's active   /// @dev If inactive the owner can pull all ERC20s and ETH   /// @dev Will be checked by calling the sherlock contract   function isActive() public view returns (bool) {     return address(sherlockCore.sherlockProtocolManager()) == address(this);   } // Only contract owner can call this   // Sends all specified tokens in this contract to the receiver's address (as well as ETH)   function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {     if (_receiver == address(0)) revert ZeroArgument();     // This contract must NOT be the current assigned protocol manager contract     if (isActive()) revert InvalidConditions();     // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH     _sweep(_receiver, _extraTokens);   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-25-08 10:59:24 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import './Manager.sol';
import '../interfaces/managers/ISherlockProtocolManager.sol';

/// @title Sherlock core interface for protocols
/// @author Evert Kors
// This is the contract that manages covered protocols

contract SherlockProtocolManager is ISherlockProtocolManager, Manager {
  using SafeERC20 for IERC20;

  // Represents the token that protocols pay with (currently USDC)
  IERC20 public immutable token;

  // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed
  uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc

  // A removed protocol is still able to make a claim for this amount of time after its removal
  uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days;

  // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance
  uint256 public constant MIN_SECONDS_LEFT = 7 days;

  // Convenient for percentage calculations
  uint256 internal constant HUNDRED_PERCENT = 10**18;

  // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage
  // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying
  uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours;

  // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)
  mapping(bytes32 => address) internal protocolAgent_;

  // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)
  mapping(bytes32 => uint256) internal nonStakersPercentage;

  // The premium per second paid by each protocol is stored in this mapping
  mapping(bytes32 => uint256) internal premiums_;

  // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.
  // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not
  mapping(bytes32 => uint256) internal activeBalances;

  // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol
  mapping(bytes32 => uint256) internal lastAccountedEachProtocol;

  // The amount that can be claimed by nonstakers for each protocol
  // We need this value so we can track how much payment is coming from each protocol
  mapping(bytes32 => uint256) internal nonStakersClaimableByProtocol;

  // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)
  uint256 internal lastAccountedGlobal;

  // This is the total amount of premiums paid (per second) by all the covered protocols (added up)
  uint256 internal allPremiumsPerSecToStakers;

  // This is the amount that was claimable by stakers the last time the accounting was run
  // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date
  uint256 internal lastClaimablePremiumsForStakers;

  // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage
  // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)
  uint256 public override minActiveBalance;

  // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)
  mapping(bytes32 => uint256) internal removedProtocolClaimDeadline;

  // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)
  mapping(bytes32 => address) internal removedProtocolAgent;

  // Current amount of coverage (i.e. 20M USDC) for a protocol
  mapping(bytes32 => uint256) internal currentCoverage;

  // Previous amount of coverage for a protocol
  // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount
  mapping(bytes32 => uint256) internal previousCoverage;

  // Setting the token to USDC
  constructor(IERC20 _token) {
    if (address(_token) == address(0)) revert ZeroArgument();
    token = _token;
  }

  // Modifier used to ensure a protocol exists (has been instantiated and not removed)
  modifier protocolExists(bytes32 _protocol) {
    _verifyProtocolExists(_protocol);
    _;
  }

  /// @notice View current protocolAgent of `_protocol`
  /// @param _protocol Protocol identifier
  /// @return Address able to submit claims
  function protocolAgent(bytes32 _protocol) external view override returns (address) {
    address agent = protocolAgent_[_protocol];
    if (agent != address(0)) return agent;

    // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned
    // Note: Old protocol agent will never be address(0)
    if (block.timestamp <= removedProtocolClaimDeadline[_protocol]) {
      return removedProtocolAgent[_protocol];
    }

    // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned
    revert ProtocolNotExists(_protocol);
  }

  // Checks if the protocol exists, then returns the current premium per second being charged
  /// @notice View current premium of protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of premium `_protocol` pays per second
  function premium(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return premiums_[_protocol];
  }

  // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)
  // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)
  function _verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {
    _protocolAgent = protocolAgent_[_protocol];
    if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);
  }

  //
  // View methods
  //

  // Calcs the debt accrued by the protocol since it last had an accounting update
  // This is the amount that needs to be removed from a protocol's active balance
  function _calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {
    return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums_[_protocol];
  }

  /// @notice View the amount nonstakers can claim from this protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of tokens claimable by nonstakers
  /// @dev this reads from a storage variable + (now-lastsettled) * premiums
  // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]
  // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed
  function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {
    // Calcs the debt of a protocol since the last accounting update
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // Gets the active balance of the protocol
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) debt = balance;

    // Adds the incremental claimable amount owed to nonstakers to the total claimable amount
    return
      nonStakersClaimableByProtocol[_protocol] +
      (nonStakersPercentage[_protocol] * debt) /
      HUNDRED_PERCENT;
  }

  /// @notice View current amount of all premiums that are owed to stakers
  /// @return Premiums claimable
  /// @dev Will increase every block
  /// @dev base + (now - last_settled) * ps
  function claimablePremiums() public view override returns (uint256) {
    // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)
    return
      lastClaimablePremiumsForStakers +
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
  }

  /// @notice View seconds of coverage left for `_protocol` before it runs out of active balance
  /// @param _protocol Protocol identifier
  /// @return Seconds of coverage left
  function secondsOfCoverageLeft(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _secondsOfCoverageLeft(_protocol);
  }

  // Helper function to return seconds of coverage left for a protocol
  // Gets the current active balance of the protocol and divides by the premium per second for the protocol
  function _secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {
    uint256 premium = premiums_[_protocol];
    if (premium == 0) return 0;
    return _activeBalance(_protocol) / premium;
  }

  /// @notice View current active balance of covered protocol
  /// @param _protocol Protocol identifier
  /// @return Active balance
  /// @dev Accrued debt is subtracted from the stored active balance
  function activeBalance(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _activeBalance(_protocol);
  }

  // Helper function to calc the active balance of a protocol at current time
  function _activeBalance(bytes32 _protocol) internal view returns (uint256) {
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) return 0;
    return balance - debt;
  }

  //
  // State methods
  //

  /// @notice Helps set the premium per second for an individual protocol
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function
  function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)
    internal
    returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)
  {
    // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers
    // Also updates the last accounted timestamp for this protocol
    // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings
    // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol
    nonStakerPercentage = _settleProtocolDebt(_protocol);
    // Stores the old premium before it gets updated
    oldPremiumPerSecond = premiums_[_protocol];

    if (oldPremiumPerSecond != _premium) {
      // Sets the protocol's premium per second to the new value
      premiums_[_protocol] = _premium;
      emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium);
    }
    // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing
    // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes
    // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point
    // Where arbs would no longer be incentivized to remove the protocol
    // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems
    if (_premium != 0 && _secondsOfCoverageLeft(_protocol) < MIN_SECONDS_OF_COVERAGE) {
      revert InsufficientBalance(_protocol);
    }
  }

  /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {
    // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings
    (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
      _protocol,
      _premium
    );
    // Settling the total amount of premiums owed to stakers before a new premium per second gets set
    _settleTotalDebt();
    // This calculates the new global premium per second that gets paid to stakers
    // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      oldPremiumPerSecond,
      _premium,
      nonStakerPercentage,
      nonStakerPercentage,
      allPremiumsPerSecToStakers
    );
  }

  // Internal function to set a new protocolAgent for a specific protocol
  // _oldAgent is only included as part of emitting an event
  function _setProtocolAgent(
    bytes32 _protocol,
    address _oldAgent,
    address _protocolAgent
  ) internal {
    protocolAgent_[_protocol] = _protocolAgent;
    emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);
  }

  // Subtracts the accrued debt from a protocol's active balance
  // Credits the amount that can be claimed by nonstakers for this protocol
  // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings
  // Most of this function is dealing with an edge case related to a protocol not being removed by arbs
  function _settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {
    // This calcs the accrued debt of the protocol since it was last updated
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // This pulls the percentage that is sent to nonstakers
    _nonStakerPercentage = nonStakersPercentage[_protocol];
    // In case the protocol has accrued debt, this code block will ensure the debt is settled properly
    if (debt != 0) {
      // Pulls the stored active balance of the protocol
      uint256 balance = activeBalances[_protocol];
      // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance
      // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point
      // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage
      // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up
      if (debt > balance) {
        // This error amount represents the magnitude of the mistake
        uint256 error = debt - balance;
        // Gets the latest value of claimable premiums for stakers
        _settleTotalDebt();
        // @note to production, set premium first to zero before solving accounting issue.
        // otherwise the accounting error keeps increasing
        uint256 lastClaimablePremiumsForStakers_ = lastClaimablePremiumsForStakers;

        // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%
        uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /
          HUNDRED_PERCENT;

        // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short
        uint256 insufficientTokens;

        // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally
        // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error
        // This first line can be true if claimPremiumsForStakers() has been called and
        // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be >0 still
        if (claimablePremiumError > lastClaimablePremiumsForStakers_) {
          insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;
          lastClaimablePremiumsForStakers = 0;
        } else {
          // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums
          // By the amount that was added in error (error) and insufficientTokens = 0
          lastClaimablePremiumsForStakers =
            lastClaimablePremiumsForStakers_ -
            claimablePremiumError;
        }

        // If two events are thrown, the values need to be summed up for the actual state.
        // This means an error of this type will continue until it is handled
        emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);
        // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case
        debt = balance;
      }
      // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance
      activeBalances[_protocol] = balance - debt;
      // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol
      nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT;
    }
    // Updates the last accounted timestamp for this protocol
    lastAccountedEachProtocol[_protocol] = block.timestamp;
  }

  // Multiplies the total premium per second * number of seconds since the last global accounting update
  // And adds it to the total claimable amount for stakers
  function _settleTotalDebt() internal {
    lastClaimablePremiumsForStakers +=
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
    lastAccountedGlobal = block.timestamp;
  }

  // Calculates the global premium per second for stakers
  // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers
  // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones
  function _calcGlobalPremiumPerSecForStakers(
    uint256 _premiumOld,
    uint256 _premiumNew,
    uint256 _nonStakerPercentageOld,
    uint256 _nonStakerPercentageNew,
    uint256 _inMemAllPremiumsPerSecToStakers
  ) internal pure returns (uint256) {
    return
      _inMemAllPremiumsPerSecToStakers +
      ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /
      HUNDRED_PERCENT -
      ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /
      HUNDRED_PERCENT;
  }

  // Helper function to remove and clean up a protocol from Sherlock
  // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made
  function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {
    // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol
    _setSingleAndGlobalProtocolPremium(_protocol, 0);

    // Grabs the protocol's active balance
    uint256 balance = activeBalances[_protocol];

    // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent
    if (balance != 0) {
      delete activeBalances[_protocol];
      token.safeTransfer(_agent, balance);

      emit ProtocolBalanceWithdrawn(_protocol, balance);
    }

    // Sets the protocol agent to zero address (as part of clean up)
    _setProtocolAgent(_protocol, _agent, address(0));

    // Cleans up other mappings for this protocol
    delete nonStakersPercentage[_protocol];
    delete lastAccountedEachProtocol[_protocol];
    // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above

    // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol
    removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;

    // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed
    // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked
    removedProtocolAgent[_protocol] = _agent;

    emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0));
    emit ProtocolRemoved(_protocol);
  }

  /// @notice Sets the minimum active balance before an arb can remove a protocol
  /// @param _minActiveBalance Minimum balance needed (in USDC)
  /// @dev Only gov
  function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {
    // New value cannot be the same as current value
    if (minActiveBalance == _minActiveBalance) revert InvalidArgument();
    // Can't set a value that is too high to be reasonable
    if (_minActiveBalance >= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions();

    emit MinBalance(minActiveBalance, _minActiveBalance);
    minActiveBalance = _minActiveBalance;
  }

  // This function allows the nonstakers role to claim tokens owed to them by a specific protocol
  /// @notice Choose an `_amount` of tokens that nonstakers (`_receiver` address) will receive from `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens
  /// @param _receiver Address to receive tokens
  /// @dev Only callable by nonstakers role
  function nonStakersClaim(
    bytes32 _protocol,
    uint256 _amount,
    address _receiver
  ) external override whenNotPaused {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_amount == uint256(0)) revert ZeroArgument();
    if (_receiver == address(0)) revert ZeroArgument();
    // Only the nonstakers role (multisig or contract) can pull the funds
    if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized();

    // Call can't be executed on protocol that is removed
    if (protocolAgent_[_protocol] != address(0)) {
      // Updates the amount that nonstakers can claim from this protocol
      _settleProtocolDebt(_protocol);
    }

    // Sets balance to the amount that is claimable by nonstakers for this specific protocol
    uint256 balance = nonStakersClaimableByProtocol[_protocol];
    // If the amount requested is more than what's owed to nonstakers, revert
    if (_amount > balance) revert InsufficientBalance(_protocol);

    // Sets the claimable amount to whatever is left over after this amount is pulled
    nonStakersClaimableByProtocol[_protocol] = balance - _amount;
    // Transfers the amount requested to the `_receiver` address
    token.safeTransfer(_receiver, _amount);
  }

  // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)
  /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address
  /// @dev Callable by everyone
  /// @dev Funds will be transferred to Sherlock core contract
  function claimPremiumsForStakers() external override whenNotPaused {
    // Gets address of core Sherlock contract
    address sherlock = address(sherlockCore);
    // Revert if core Sherlock contract not initialized yet
    if (sherlock == address(0)) revert InvalidConditions();

    // claimablePremiums is different from _settleTotalDebt() because it does not change state
    // Retrieves current amount of all premiums that are owed to stakers
    uint256 amount = claimablePremiums();

    // Transfers all the premiums owed to stakers to the Sherlock core contract
    if (amount != 0) {
      // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out
      lastClaimablePremiumsForStakers = 0;
      lastAccountedGlobal = block.timestamp;
      token.safeTransfer(sherlock, amount);
    }
  }

  // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts
  /// @param _protocol Protocol identifier
  /// @return current and previous are the current and previous coverage amounts for this protocol
  // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)
  function coverageAmounts(bytes32 _protocol)
    external
    view
    override
    returns (uint256 current, uint256 previous)
  {
    // Checks to see if the protocol has an active protocolAgent (protocol not removed)
    // OR checks to see if the removed protocol is still within the claim window
    // If so, gives the current and previous coverage, otherwise throws an error
    if (
      protocolAgent_[_protocol] != address(0) ||
      block.timestamp <= removedProtocolClaimDeadline[_protocol]
    ) {
      return (currentCoverage[_protocol], previousCoverage[_protocol]);
    }

    revert ProtocolNotExists(_protocol);
  }

  /// @notice Add a new protocol to Sherlock
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Address able to submit a claim on behalf of the protocol
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Adding a protocol allows the `_protocolAgent` to submit a claim
  /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point
  /// @dev `_nonStakers` is scaled by 10**18
  /// @dev Only callable by governance
  function protocolAdd(
    bytes32 _protocol,
    address _protocolAgent,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) external override onlyOwner {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Checks to make sure the protocol doesn't exist already
    if (protocolAgent_[_protocol] != address(0)) revert InvalidConditions();

    // Updates the protocol agent and passes in the old agent which is 0 address in this case
    _setProtocolAgent(_protocol, address(0), _protocolAgent);

    // Delete mappings that are potentially non default values
    // From previous time protocol was added/removed
    delete removedProtocolClaimDeadline[_protocol];
    delete removedProtocolAgent[_protocol];
    delete currentCoverage[_protocol];
    delete previousCoverage[_protocol];

    emit ProtocolAdded(_protocol);

    // Most of the logic for actually adding a protocol in this function
    protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Update info regarding a protocol
  /// @param _protocol Protocol identifier
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Only callable by governance
  /// @dev `_nonStakers` can be 0
  function protocolUpdate(
    bytes32 _protocol,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) public override onlyOwner {
    if (_coverage == bytes32(0)) revert ZeroArgument();
    if (_nonStakers > HUNDRED_PERCENT) revert InvalidArgument();
    if (_coverageAmount == uint256(0)) revert ZeroArgument();

    // Checks to make sure the protocol has been assigned a protocol agent
    _verifyProtocolExists(_protocol);

    // Subtracts the accrued debt from a protocol's active balance (if any)
    // Updates the amount that can be claimed by nonstakers
    _settleProtocolDebt(_protocol);

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    // Gets the premium per second for this protocol
    uint256 premium = premiums_[_protocol];

    // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be)
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      premium,
      premium,
      nonStakersPercentage[_protocol],
      _nonStakers,
      allPremiumsPerSecToStakers
    );

    // Updates the stored value of percentage of premiums that go to nonstakers
    nonStakersPercentage[_protocol] = _nonStakers;

    // Updates previous coverage and current coverage amounts
    previousCoverage[_protocol] = currentCoverage[_protocol];
    currentCoverage[_protocol] = _coverageAmount;

    emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Remove a protocol from coverage
  /// @param _protocol Protocol identifier
  /// @dev Before removing a protocol the premium must be 0
  /// @dev Removing a protocol basically stops the `_protocolAgent` from being active (can still submit claims until claim deadline though)
  /// @dev Pays off debt + sends remaining balance to protocol agent
  /// @dev This call should be subject to a timelock
  /// @dev Only callable by governance
  function protocolRemove(bytes32 _protocol) external override onlyOwner {
    // checks to make sure the protocol actually has a protocol agent
    address agent = _verifyProtocolExists(_protocol);

    // Removes a protocol from Sherlock and cleans up its data
    // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made
    _forceRemoveProtocol(_protocol, agent);
  }

  /// @notice Remove a protocol with insufficient active balance
  /// @param _protocol Protocol identifier
  // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function
  function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {
    address agent = _verifyProtocolExists(_protocol);

    // Gets the latest value of the active balance at this protocol
    _settleProtocolDebt(_protocol);
    // Sets latest value of active balance to remainingBalance variable
    uint256 remainingBalance = activeBalances[_protocol];

    // This means the protocol still has adequate active balance and thus cannot be removed
    if (remainingBalance >= minActiveBalance) revert InvalidConditions();

    // Sets the protocol's active balance to 0
    delete activeBalances[_protocol];
    // Removes the protocol from coverage
    _forceRemoveProtocol(_protocol, agent);

    if (remainingBalance != 0) {
      // sends the remaining balance to msg.sender
      token.safeTransfer(msg.sender, remainingBalance);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);
  }

  /// @notice Calculate if arb is possible and what the reward would be
  /// @param _protocol Protocol identifier
  /// @return arbAmount Amount reward for arbing
  /// @return able Indicator if arb call is even possible
  /// @dev Doesn't subtract the current protocol debt from the active balance
  function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)
    internal
    view
    returns (uint256 arbAmount, bool able)
  {
    uint256 secondsLeft = _secondsOfCoverageLeft(_protocol);

    // If arb is not possible return false
    if (secondsLeft >= MIN_SECONDS_OF_COVERAGE) return (0, false);

    // This percentage scales over time
    // Reaches 100% on 0 seconds of coverage left
    uint256 percentageScaled = HUNDRED_PERCENT -
      (secondsLeft * HUNDRED_PERCENT) /
      MIN_SECONDS_OF_COVERAGE;

    able = true;
    arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;
  }

  /// @notice Removes a protocol with insufficent seconds of coverage left
  /// @param _protocol Protocol identifier
  // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second
  function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {
    // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings
    address agent = _verifyProtocolExists(_protocol);

    // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance()
    // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance()
    // But when removing based on seconds of coverage left, the remainingBalance could still be quite large
    // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance
    // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%)
    _settleProtocolDebt(_protocol);
    (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol);
    if (able == false) revert InvalidConditions();

    if (arbAmount != 0) {
      // subtracts the amount that will be paid to the arb from the active balance
      activeBalances[_protocol] -= arbAmount;
    }

    // Removes the protocol from coverage
    // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above
    _forceRemoveProtocol(_protocol, agent);

    // Done after removing protocol to mitigate reentrency pattern
    // (In case token allows callback)
    if (arbAmount != 0) {
      token.safeTransfer(msg.sender, arbAmount);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);
  }

  /// @notice Set premium of `_protocol` to `_premium`
  /// @param _protocol Protocol identifier
  /// @param _premium Amount of premium `_protocol` pays per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {
    // Checks to see if protocol has a protocol agent
    _verifyProtocolExists(_protocol);

    // Updates individual protocol's premium and allPremiumsPerSecToStakers
    _setSingleAndGlobalProtocolPremium(_protocol, _premium);
  }

  /// @notice Set premium of multiple protocols
  /// @param _protocol Array of protocol identifiers
  /// @param _premium Array of premium amounts protocols pay per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)
    external
    override
    onlyOwner
  {
    // Checks to make sure there are an equal amount of entries in each array
    if (_protocol.length != _premium.length) revert UnequalArrayLength();
    if (_protocol.length == 0) revert InvalidArgument();

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;

    // Loops through the array of protocols and checks to make sure each has a protocol agent assigned
    for (uint256 i; i < _protocol.length; i++) {
      _verifyProtocolExists(_protocol[i]);

      // Sets the protocol premium for that specific protocol
      // Function returns the old premium and nonStakerPercentage for that specific protocol
      (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
        _protocol[i],
        _premium[i]
      );

      // Calculates the new global premium which adds up all premiums paid by all protocols
      allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(
        oldPremiumPerSecond,
        _premium[i],
        nonStakerPercentage,
        nonStakerPercentage,
        allPremiumsPerSecToStakers_
      );
    }

    // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value
    allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;
  }

  // This is how protocols pay for coverage by increasing their active balance
  /// @notice Deposits `_amount` of token to the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to deposit
  /// @dev Approval should be made before calling
  function depositToActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    _verifyProtocolExists(_protocol);

    // Transfers _amount to this contract
    token.safeTransferFrom(msg.sender, address(this), _amount);
    // Increases the active balance of the protocol by _amount
    activeBalances[_protocol] += _amount;

    emit ProtocolBalanceDeposited(_protocol, _amount);
  }

  // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)
  // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)
  /// @notice Withdraws `_amount` of token from the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to withdraw
  /// @dev Only protocol agent is able to withdraw
  /// @dev Balance can be withdrawn up until 7 days worth of active balance
  function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    // Only the protocol agent can call this function
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Updates the active balance of the protocol
    _settleProtocolDebt(_protocol);

    // Sets currentBalance to the active balance of the protocol
    uint256 currentBalance = activeBalances[_protocol];
    // Reverts if trying to withdraw more than the active balance
    if (_amount > currentBalance) revert InsufficientBalance(_protocol);

    // Removes the _amount to be withdrawn from the active balance
    activeBalances[_protocol] = currentBalance - _amount;
    // Reverts if a protocol has less than 7 days worth of active balance left
    if (_secondsOfCoverageLeft(_protocol) < MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);

    // Transfers the amount to the msg.sender (protocol agent)
    token.safeTransfer(msg.sender, _amount);
    emit ProtocolBalanceWithdrawn(_protocol, _amount);
  }

  /// @notice Transfer protocol agent role
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Account able to submit a claim on behalf of the protocol
  /// @dev Only the active protocolAgent is able to transfer the role
  function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)
    external
    override
    whenNotPaused
  {
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Can't set the new protocol agent to the caller address
    if (msg.sender == _protocolAgent) revert InvalidArgument();
    // Because the caller must be the current protocol agent
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Sets the protocol agent to the new address
    _setProtocolAgent(_protocol, msg.sender, _protocolAgent);
  }

  /// @notice Function used to check if this is the current active protocol manager
  /// @return Boolean indicating it's active
  /// @dev If inactive the owner can pull all ERC20s and ETH
  /// @dev Will be checked by calling the sherlock contract
  function isActive() public view returns (bool) {
    return address(sherlockCore.sherlockProtocolManager()) == address(this);
  }

  // Only contract owner can call this
  // Sends all specified tokens in this contract to the receiver's address (as well as ETH)
  function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {
    if (_receiver == address(0)) revert ZeroArgument();
    // This contract must NOT be the current assigned protocol manager contract
    if (isActive()) revert InvalidConditions();
    // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH
    _sweep(_receiver, _extraTokens);
  }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-25-08 10:59:35 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-25-08 10:59:35 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 9206
completion_tokens: 840
total_tokens: 10046
cost: $-1.000000


[2024-25-08 10:59:35 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import './Manager.sol';
import '../interfaces/managers/ISherlockProtocolManager.sol';

/// @title Sherlock core interface for protocols
/// @author Evert Kors
// This is the contract that manages covered protocols

contract SherlockProtocolManager is ISherlockProtocolManager, Manager {
  using SafeERC20 for IERC20;

  // Represents the token that protocols pay with (currently USDC)
  IERC20 public immutable token;

  // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed
  uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc

  // A removed protocol is still able to make a claim for this amount of time after its removal
  uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days;

  // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance
  uint256 public constant MIN_SECONDS_LEFT = 7 days;

  // Convenient for percentage calculations
  uint256 internal constant HUNDRED_PERCENT = 10**18;

  // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage
  // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying
  uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours;

  // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)
  mapping(bytes32 => address) internal protocolAgent_;

  // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)
  mapping(bytes32 => uint256) internal nonStakersPercentage;

  // The premium per second paid by each protocol is stored in this mapping
  mapping(bytes32 => uint256) internal premiums_;

  // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.
  // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not
  mapping(bytes32 => uint256) internal activeBalances;

  // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol
  mapping(bytes32 => uint256) internal lastAccountedEachProtocol;

  // The amount that can be claimed by nonstakers for each protocol
  // We need this value so we can track how much payment is coming from each protocol
  mapping(bytes32 => uint256) internal nonStakersClaimableByProtocol;

  // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)
  uint256 internal lastAccountedGlobal;

  // This is the total amount of premiums paid (per second) by all the covered protocols (added up)
  uint256 internal allPremiumsPerSecToStakers;

  // This is the amount that was claimable by stakers the last time the accounting was run
  // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date
  uint256 internal lastClaimablePremiumsForStakers;

  // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage
  // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)
  uint256 public override minActiveBalance;

  // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)
  mapping(bytes32 => uint256) internal removedProtocolClaimDeadline;

  // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)
  mapping(bytes32 => address) internal removedProtocolAgent;

  // Current amount of coverage (i.e. 20M USDC) for a protocol
  mapping(bytes32 => uint256) internal currentCoverage;

  // Previous amount of coverage for a protocol
  // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount
  mapping(bytes32 => uint256) internal previousCoverage;

  // Setting the token to USDC
  constructor(IERC20 _token) {
    if (address(_token) == address(0)) revert ZeroArgument();
    token = _token;
  }

  // Modifier used to ensure a protocol exists (has been instantiated and not removed)
  modifier protocolExists(bytes32 _protocol) {
    _verifyProtocolExists(_protocol);
    _;
  }

  /// @notice View current protocolAgent of `_protocol`
  /// @param _protocol Protocol identifier
  /// @return Address able to submit claims
  function protocolAgent(bytes32 _protocol) external view override returns (address) {
    address agent = protocolAgent_[_protocol];
    if (agent != address(0)) return agent;

    // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned
    // Note: Old protocol agent will never be address(0)
    if (block.timestamp <= removedProtocolClaimDeadline[_protocol]) {
      return removedProtocolAgent[_protocol];
    }

    // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned
    revert ProtocolNotExists(_protocol);
  }

  // Checks if the protocol exists, then returns the current premium per second being charged
  /// @notice View current premium of protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of premium `_protocol` pays per second
  function premium(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return premiums_[_protocol];
  }

  // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)
  // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)
  function _verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {
    _protocolAgent = protocolAgent_[_protocol];
    if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);
  }

  //
  // View methods
  //

  // Calcs the debt accrued by the protocol since it last had an accounting update
  // This is the amount that needs to be removed from a protocol's active balance
  function _calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {
    return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums_[_protocol];
  }

  /// @notice View the amount nonstakers can claim from this protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of tokens claimable by nonstakers
  /// @dev this reads from a storage variable + (now-lastsettled) * premiums
  // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]
  // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed
  function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {
    // Calcs the debt of a protocol since the last accounting update
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // Gets the active balance of the protocol
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) debt = balance;

    // Adds the incremental claimable amount owed to nonstakers to the total claimable amount
    return
      nonStakersClaimableByProtocol[_protocol] +
      (nonStakersPercentage[_protocol] * debt) /
      HUNDRED_PERCENT;
  }

  /// @notice View current amount of all premiums that are owed to stakers
  /// @return Premiums claimable
  /// @dev Will increase every block
  /// @dev base + (now - last_settled) * ps
  function claimablePremiums() public view override returns (uint256) {
    // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)
    return
      lastClaimablePremiumsForStakers +
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
  }

  /// @notice View seconds of coverage left for `_protocol` before it runs out of active balance
  /// @param _protocol Protocol identifier
  /// @return Seconds of coverage left
  function secondsOfCoverageLeft(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _secondsOfCoverageLeft(_protocol);
  }

  // Helper function to return seconds of coverage left for a protocol
  // Gets the current active balance of the protocol and divides by the premium per second for the protocol
  function _secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {
    uint256 premium = premiums_[_protocol];
    if (premium == 0) return 0;
    return _activeBalance(_protocol) / premium;
  }

  /// @notice View current active balance of covered protocol
  /// @param _protocol Protocol identifier
  /// @return Active balance
  /// @dev Accrued debt is subtracted from the stored active balance
  function activeBalance(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _activeBalance(_protocol);
  }

  // Helper function to calc the active balance of a protocol at current time
  function _activeBalance(bytes32 _protocol) internal view returns (uint256) {
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) return 0;
    return balance - debt;
  }

  //
  // State methods
  //

  /// @notice Helps set the premium per second for an individual protocol
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function
  function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)
    internal
    returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)
  {
    // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers
    // Also updates the last accounted timestamp for this protocol
    // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings
    // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol
    nonStakerPercentage = _settleProtocolDebt(_protocol);
    // Stores the old premium before it gets updated
    oldPremiumPerSecond = premiums_[_protocol];

    if (oldPremiumPerSecond != _premium) {
      // Sets the protocol's premium per second to the new value
      premiums_[_protocol] = _premium;
      emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium);
    }
    // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing
    // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes
    // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point
    // Where arbs would no longer be incentivized to remove the protocol
    // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems
    if (_premium != 0 && _secondsOfCoverageLeft(_protocol) < MIN_SECONDS_OF_COVERAGE) {
      revert InsufficientBalance(_protocol);
    }
  }

  /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {
    // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings
    (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
      _protocol,
      _premium
    );
    // Settling the total amount of premiums owed to stakers before a new premium per second gets set
    _settleTotalDebt();
    // This calculates the new global premium per second that gets paid to stakers
    // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      oldPremiumPerSecond,
      _premium,
      nonStakerPercentage,
      nonStakerPercentage,
      allPremiumsPerSecToStakers
    );
  }

  // Internal function to set a new protocolAgent for a specific protocol
  // _oldAgent is only included as part of emitting an event
  function _setProtocolAgent(
    bytes32 _protocol,
    address _oldAgent,
    address _protocolAgent
  ) internal {
    protocolAgent_[_protocol] = _protocolAgent;
    emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);
  }

  // Subtracts the accrued debt from a protocol's active balance
  // Credits the amount that can be claimed by nonstakers for this protocol
  // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings
  // Most of this function is dealing with an edge case related to a protocol not being removed by arbs
  function _settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {
    // This calcs the accrued debt of the protocol since it was last updated
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // This pulls the percentage that is sent to nonstakers
    _nonStakerPercentage = nonStakersPercentage[_protocol];
    // In case the protocol has accrued debt, this code block will ensure the debt is settled properly
    if (debt != 0) {
      // Pulls the stored active balance of the protocol
      uint256 balance = activeBalances[_protocol];
      // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance
      // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point
      // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage
      // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up
      if (debt > balance) {
        // This error amount represents the magnitude of the mistake
        uint256 error = debt - balance;
        // Gets the latest value of claimable premiums for stakers
        _settleTotalDebt();
        // @note to production, set premium first to zero before solving accounting issue.
        // otherwise the accounting error keeps increasing
        uint256 lastClaimablePremiumsForStakers_ = lastClaimablePremiumsForStakers;

        // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%
        uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /
          HUNDRED_PERCENT;

        // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short
        uint256 insufficientTokens;

        // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally
        // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error
        // This first line can be true if claimPremiumsForStakers() has been called and
        // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be >0 still
        if (claimablePremiumError > lastClaimablePremiumsForStakers_) {
          insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;
          lastClaimablePremiumsForStakers = 0;
        } else {
          // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums
          // By the amount that was added in error (error) and insufficientTokens = 0
          lastClaimablePremiumsForStakers =
            lastClaimablePremiumsForStakers_ -
            claimablePremiumError;
        }

        // If two events are thrown, the values need to be summed up for the actual state.
        // This means an error of this type will continue until it is handled
        emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);
        // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case
        debt = balance;
      }
      // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance
      activeBalances[_protocol] = balance - debt;
      // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol
      nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT;
    }
    // Updates the last accounted timestamp for this protocol
    lastAccountedEachProtocol[_protocol] = block.timestamp;
  }

  // Multiplies the total premium per second * number of seconds since the last global accounting update
  // And adds it to the total claimable amount for stakers
  function _settleTotalDebt() internal {
    lastClaimablePremiumsForStakers +=
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
    lastAccountedGlobal = block.timestamp;
  }

  // Calculates the global premium per second for stakers
  // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers
  // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones
  function _calcGlobalPremiumPerSecForStakers(
    uint256 _premiumOld,
    uint256 _premiumNew,
    uint256 _nonStakerPercentageOld,
    uint256 _nonStakerPercentageNew,
    uint256 _inMemAllPremiumsPerSecToStakers
  ) internal pure returns (uint256) {
    return
      _inMemAllPremiumsPerSecToStakers +
      ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /
      HUNDRED_PERCENT -
      ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /
      HUNDRED_PERCENT;
  }

  // Helper function to remove and clean up a protocol from Sherlock
  // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made
  function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {
    // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol
    _setSingleAndGlobalProtocolPremium(_protocol, 0);

    // Grabs the protocol's active balance
    uint256 balance = activeBalances[_protocol];

    // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent
    if (balance != 0) {
      delete activeBalances[_protocol];
      token.safeTransfer(_agent, balance);

      emit ProtocolBalanceWithdrawn(_protocol, balance);
    }

    // Sets the protocol agent to zero address (as part of clean up)
    _setProtocolAgent(_protocol, _agent, address(0));

    // Cleans up other mappings for this protocol
    delete nonStakersPercentage[_protocol];
    delete lastAccountedEachProtocol[_protocol];
    // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above

    // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol
    removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;

    // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed
    // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked
    removedProtocolAgent[_protocol] = _agent;

    emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0));
    emit ProtocolRemoved(_protocol);
  }

  /// @notice Sets the minimum active balance before an arb can remove a protocol
  /// @param _minActiveBalance Minimum balance needed (in USDC)
  /// @dev Only gov
  function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {
    // New value cannot be the same as current value
    if (minActiveBalance == _minActiveBalance) revert InvalidArgument();
    // Can't set a value that is too high to be reasonable
    if (_minActiveBalance >= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions();

    emit MinBalance(minActiveBalance, _minActiveBalance);
    minActiveBalance = _minActiveBalance;
  }

  // This function allows the nonstakers role to claim tokens owed to them by a specific protocol
  /// @notice Choose an `_amount` of tokens that nonstakers (`_receiver` address) will receive from `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens
  /// @param _receiver Address to receive tokens
  /// @dev Only callable by nonstakers role
  function nonStakersClaim(
    bytes32 _protocol,
    uint256 _amount,
    address _receiver
  ) external override whenNotPaused {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_amount == uint256(0)) revert ZeroArgument();
    if (_receiver == address(0)) revert ZeroArgument();
    // Only the nonstakers role (multisig or contract) can pull the funds
    if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized();

    // Call can't be executed on protocol that is removed
    if (protocolAgent_[_protocol] != address(0)) {
      // Updates the amount that nonstakers can claim from this protocol
      _settleProtocolDebt(_protocol);
    }

    // Sets balance to the amount that is claimable by nonstakers for this specific protocol
    uint256 balance = nonStakersClaimableByProtocol[_protocol];
    // If the amount requested is more than what's owed to nonstakers, revert
    if (_amount > balance) revert InsufficientBalance(_protocol);

    // Sets the claimable amount to whatever is left over after this amount is pulled
    nonStakersClaimableByProtocol[_protocol] = balance - _amount;
    // Transfers the amount requested to the `_receiver` address
    token.safeTransfer(_receiver, _amount);
  }

  // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)
  /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address
  /// @dev Callable by everyone
  /// @dev Funds will be transferred to Sherlock core contract
  function claimPremiumsForStakers() external override whenNotPaused {
    // Gets address of core Sherlock contract
    address sherlock = address(sherlockCore);
    // Revert if core Sherlock contract not initialized yet
    if (sherlock == address(0)) revert InvalidConditions();

    // claimablePremiums is different from _settleTotalDebt() because it does not change state
    // Retrieves current amount of all premiums that are owed to stakers
    uint256 amount = claimablePremiums();

    // Transfers all the premiums owed to stakers to the Sherlock core contract
    if (amount != 0) {
      // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out
      lastClaimablePremiumsForStakers = 0;
      lastAccountedGlobal = block.timestamp;
      token.safeTransfer(sherlock, amount);
    }
  }

  // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts
  /// @param _protocol Protocol identifier
  /// @return current and previous are the current and previous coverage amounts for this protocol
  // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)
  function coverageAmounts(bytes32 _protocol)
    external
    view
    override
    returns (uint256 current, uint256 previous)
  {
    // Checks to see if the protocol has an active protocolAgent (protocol not removed)
    // OR checks to see if the removed protocol is still within the claim window
    // If so, gives the current and previous coverage, otherwise throws an error
    if (
      protocolAgent_[_protocol] != address(0) ||
      block.timestamp <= removedProtocolClaimDeadline[_protocol]
    ) {
      return (currentCoverage[_protocol], previousCoverage[_protocol]);
    }

    revert ProtocolNotExists(_protocol);
  }

  /// @notice Add a new protocol to Sherlock
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Address able to submit a claim on behalf of the protocol
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Adding a protocol allows the `_protocolAgent` to submit a claim
  /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point
  /// @dev `_nonStakers` is scaled by 10**18
  /// @dev Only callable by governance
  function protocolAdd(
    bytes32 _protocol,
    address _protocolAgent,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) external override onlyOwner {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Checks to make sure the protocol doesn't exist already
    if (protocolAgent_[_protocol] != address(0)) revert InvalidConditions();

    // Updates the protocol agent and passes in the old agent which is 0 address in this case
    _setProtocolAgent(_protocol, address(0), _protocolAgent);

    // Delete mappings that are potentially non default values
    // From previous time protocol was added/removed
    delete removedProtocolClaimDeadline[_protocol];
    delete removedProtocolAgent[_protocol];
    delete currentCoverage[_protocol];
    delete previousCoverage[_protocol];

    emit ProtocolAdded(_protocol);

    // Most of the logic for actually adding a protocol in this function
    protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Update info regarding a protocol
  /// @param _protocol Protocol identifier
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Only callable by governance
  /// @dev `_nonStakers` can be 0
  function protocolUpdate(
    bytes32 _protocol,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) public override onlyOwner {
    if (_coverage == bytes32(0)) revert ZeroArgument();
    if (_nonStakers > HUNDRED_PERCENT) revert InvalidArgument();
    if (_coverageAmount == uint256(0)) revert ZeroArgument();

    // Checks to make sure the protocol has been assigned a protocol agent
    _verifyProtocolExists(_protocol);

    // Subtracts the accrued debt from a protocol's active balance (if any)
    // Updates the amount that can be claimed by nonstakers
    _settleProtocolDebt(_protocol);

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    // Gets the premium per second for this protocol
    uint256 premium = premiums_[_protocol];

    // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be)
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      premium,
      premium,
      nonStakersPercentage[_protocol],
      _nonStakers,
      allPremiumsPerSecToStakers
    );

    // Updates the stored value of percentage of premiums that go to nonstakers
    nonStakersPercentage[_protocol] = _nonStakers;

    // Updates previous coverage and current coverage amounts
    previousCoverage[_protocol] = currentCoverage[_protocol];
    currentCoverage[_protocol] = _coverageAmount;

    emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Remove a protocol from coverage
  /// @param _protocol Protocol identifier
  /// @dev Before removing a protocol the premium must be 0
  /// @dev Removing a protocol basically stops the `_protocolAgent` from being active (can still submit claims until claim deadline though)
  /// @dev Pays off debt + sends remaining balance to protocol agent
  /// @dev This call should be subject to a timelock
  /// @dev Only callable by governance
  function protocolRemove(bytes32 _protocol) external override onlyOwner {
    // checks to make sure the protocol actually has a protocol agent
    address agent = _verifyProtocolExists(_protocol);

    // Removes a protocol from Sherlock and cleans up its data
    // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made
    _forceRemoveProtocol(_protocol, agent);
  }

  /// @notice Remove a protocol with insufficient active balance
  /// @param _protocol Protocol identifier
  // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function
  function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {
    address agent = _verifyProtocolExists(_protocol);

    // Gets the latest value of the active balance at this protocol
    _settleProtocolDebt(_protocol);
    // Sets latest value of active balance to remainingBalance variable
    uint256 remainingBalance = activeBalances[_protocol];

    // This means the protocol still has adequate active balance and thus cannot be removed
    if (remainingBalance >= minActiveBalance) revert InvalidConditions();

    // Sets the protocol's active balance to 0
    delete activeBalances[_protocol];
    // Removes the protocol from coverage
    _forceRemoveProtocol(_protocol, agent);

    if (remainingBalance != 0) {
      // sends the remaining balance to msg.sender
      token.safeTransfer(msg.sender, remainingBalance);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);
  }

  /// @notice Calculate if arb is possible and what the reward would be
  /// @param _protocol Protocol identifier
  /// @return arbAmount Amount reward for arbing
  /// @return able Indicator if arb call is even possible
  /// @dev Doesn't subtract the current protocol debt from the active balance
  function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)
    internal
    view
    returns (uint256 arbAmount, bool able)
  {
    uint256 secondsLeft = _secondsOfCoverageLeft(_protocol);

    // If arb is not possible return false
    if (secondsLeft >= MIN_SECONDS_OF_COVERAGE) return (0, false);

    // This percentage scales over time
    // Reaches 100% on 0 seconds of coverage left
    uint256 percentageScaled = HUNDRED_PERCENT -
      (secondsLeft * HUNDRED_PERCENT) /
      MIN_SECONDS_OF_COVERAGE;

    able = true;
    arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;
  }

  /// @notice Removes a protocol with insufficent seconds of coverage left
  /// @param _protocol Protocol identifier
  // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second
  function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {
    // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings
    address agent = _verifyProtocolExists(_protocol);

    // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance()
    // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance()
    // But when removing based on seconds of coverage left, the remainingBalance could still be quite large
    // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance
    // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%)
    _settleProtocolDebt(_protocol);
    (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol);
    if (able == false) revert InvalidConditions();

    if (arbAmount != 0) {
      // subtracts the amount that will be paid to the arb from the active balance
      activeBalances[_protocol] -= arbAmount;
    }

    // Removes the protocol from coverage
    // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above
    _forceRemoveProtocol(_protocol, agent);

    // Done after removing protocol to mitigate reentrency pattern
    // (In case token allows callback)
    if (arbAmount != 0) {
      token.safeTransfer(msg.sender, arbAmount);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);
  }

  /// @notice Set premium of `_protocol` to `_premium`
  /// @param _protocol Protocol identifier
  /// @param _premium Amount of premium `_protocol` pays per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {
    // Checks to see if protocol has a protocol agent
    _verifyProtocolExists(_protocol);

    // Updates individual protocol's premium and allPremiumsPerSecToStakers
    _setSingleAndGlobalProtocolPremium(_protocol, _premium);
  }

  /// @notice Set premium of multiple protocols
  /// @param _protocol Array of protocol identifiers
  /// @param _premium Array of premium amounts protocols pay per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)
    external
    override
    onlyOwner
  {
    // Checks to make sure there are an equal amount of entries in each array
    if (_protocol.length != _premium.length) revert UnequalArrayLength();
    if (_protocol.length == 0) revert InvalidArgument();

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;

    // Loops through the array of protocols and checks to make sure each has a protocol agent assigned
    for (uint256 i; i < _protocol.length; i++) {
      _verifyProtocolExists(_protocol[i]);

      // Sets the protocol premium for that specific protocol
      // Function returns the old premium and nonStakerPercentage for that specific protocol
      (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
        _protocol[i],
        _premium[i]
      );

      // Calculates the new global premium which adds up all premiums paid by all protocols
      allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(
        oldPremiumPerSecond,
        _premium[i],
        nonStakerPercentage,
        nonStakerPercentage,
        allPremiumsPerSecToStakers_
      );
    }

    // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value
    allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;
  }

  // This is how protocols pay for coverage by increasing their active balance
  /// @notice Deposits `_amount` of token to the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to deposit
  /// @dev Approval should be made before calling
  function depositToActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    _verifyProtocolExists(_protocol);

    // Transfers _amount to this contract
    token.safeTransferFrom(msg.sender, address(this), _amount);
    // Increases the active balance of the protocol by _amount
    activeBalances[_protocol] += _amount;

    emit ProtocolBalanceDeposited(_protocol, _amount);
  }

  // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)
  // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)
  /// @notice Withdraws `_amount` of token from the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to withdraw
  /// @dev Only protocol agent is able to withdraw
  /// @dev Balance can be withdrawn up until 7 days worth of active balance
  function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    // Only the protocol agent can call this function
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Updates the active balance of the protocol
    _settleProtocolDebt(_protocol);

    // Sets currentBalance to the active balance of the protocol
    uint256 currentBalance = activeBalances[_protocol];
    // Reverts if trying to withdraw more than the active balance
    if (_amount > currentBalance) revert InsufficientBalance(_protocol);

    // Removes the _amount to be withdrawn from the active balance
    activeBalances[_protocol] = currentBalance - _amount;
    // Reverts if a protocol has less than 7 days worth of active balance left
    if (_secondsOfCoverageLeft(_protocol) < MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);

    // Transfers the amount to the msg.sender (protocol agent)
    token.safeTransfer(msg.sender, _amount);
    emit ProtocolBalanceWithdrawn(_protocol, _amount);
  }

  /// @notice Transfer protocol agent role
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Account able to submit a claim on behalf of the protocol
  /// @dev Only the active protocolAgent is able to transfer the role
  function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)
    external
    override
    whenNotPaused
  {
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Can't set the new protocol agent to the caller address
    if (msg.sender == _protocolAgent) revert InvalidArgument();
    // Because the caller must be the current protocol agent
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Sets the protocol agent to the new address
    _setProtocolAgent(_protocol, msg.sender, _protocolAgent);
  }

  /// @notice Function used to check if this is the current active protocol manager
  /// @return Boolean indicating it's active
  /// @dev If inactive the owner can pull all ERC20s and ETH
  /// @dev Will be checked by calling the sherlock contract
  function isActive() public view returns (bool) {
    return address(sherlockCore.sherlockProtocolManager()) == address(this);
  }

  // Only contract owner can call this
  // Sends all specified tokens in this contract to the receiver's address (as well as ETH)
  function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {
    if (_receiver == address(0)) revert ZeroArgument();
    // This contract must NOT be the current assigned protocol manager contract
    if (isActive()) revert InvalidConditions();
    // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH
    _sweep(_receiver, _extraTokens);
  }
}
.]

Based on the provided Solidity smart contract code for the `SherlockProtocolManager`, here is a summary of potential security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract uses external calls to transfer tokens (e.g., `token.safeTransfer`). If the token contract has a fallback function that calls back into the `SherlockProtocolManager`, it could lead to unexpected behavior or reentrancy attacks. Although the contract uses `safeTransfer`, which mitigates some risks, it is still advisable to implement a reentrancy guard.

2. **Arithmetic Vulnerabilities**:
   - Although Solidity 0.8.x has built-in overflow and underflow checks, there are still areas where arithmetic operations could lead to unexpected results, especially when calculating debts and balances. Care should be taken to ensure that all arithmetic operations are safe and do not lead to negative values or unexpected overflows.

3. **Access Control Issues**:
   - The contract relies on the `onlyOwner` modifier for critical functions, which could be a single point of failure. If the owner’s private key is compromised, an attacker could gain control over the contract. Implementing a multi-signature wallet or a time-lock mechanism for sensitive operations would enhance security.

4. **Insufficient Input Validation**:
   - The contract has several checks for zero addresses and zero amounts, but additional validation could be beneficial. For instance, ensuring that the `_protocol` identifier is valid and not already in use before adding a new protocol could prevent potential issues.

5. **Potential Denial of Service (DoS)**:
   - Functions that rely on external contracts (like the token contract) could be susceptible to DoS attacks if those contracts become unresponsive or malicious. This could prevent users from withdrawing funds or executing critical functions.

6. **Lack of Event Emission for Critical State Changes**:
   - While there are events emitted for many state changes, ensuring that all critical state changes are logged can help in tracking the contract's behavior and debugging issues. For example, when changing the protocol's active balance or premium, it would be prudent to emit an event.

7. **Claim Deadline Logic**:
   - The logic around claim deadlines for removed protocols could lead to confusion or exploitation if not properly documented and understood. It’s crucial to ensure that the claim process is transparent and that users are aware of the timelines involved.

8. **Gas Limit Issues**:
   - Functions that involve loops (like `setProtocolPremiums`) could run into gas limit issues if the number of protocols becomes large. This could lead to failed transactions and a poor user experience.

### Comprehensive Analysis Report:

The `SherlockProtocolManager` contract is a complex piece of code that manages protocol coverage and premium payments. While it incorporates several best practices, including the use of SafeERC20 for token transfers, there are notable vulnerabilities that could be exploited if not addressed.

1. **Reentrancy and External Calls**: The potential for reentrancy attacks exists, especially in functions that transfer tokens. Implementing a reentrancy guard would help mitigate this risk.

2. **Access Control**: The reliance on a single owner for critical operations poses a risk. Transitioning to a multi-signature model or incorporating a governance mechanism could enhance security.

3. **Input Validation and Error Handling**: While the contract performs some input validation, additional checks could prevent invalid states and enhance robustness. Ensuring that all critical state changes are logged through events will also aid in tracking and debugging.

4. **Gas Limit Considerations**: Functions that involve loops should be optimized to prevent gas limit issues, especially as the number of protocols grows.

5. **Documentation and Clarity**: Clear documentation regarding the claim deadlines and protocol management processes will help users understand the contract's functionality and limitations.

In conclusion, while the `SherlockProtocolManager` contract is designed with several security features, addressing the identified vulnerabilities will significantly enhance its resilience against potential attacks and operational failures. Regular audits and updates, along with community feedback, will be essential in maintaining the contract's security posture.

[2024-25-08 10:59:35 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code for the `SherlockProtocolManager`, here is a summary of potential security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract uses external calls to transfer tokens (e.g., `token.safeTransfer`). If the token contract has a fallback function that calls back into the `SherlockProtocolManager`, it could lead to unexpected behavior or reentrancy attacks. Although the contract uses `safeTransfer`, which mitigates some risks, it is still advisable to implement a reentrancy guard.

2. **Arithmetic Vulnerabilities**:
   - Although Solidity 0.8.x has built-in overflow and underflow checks, there are still areas where arithmetic operations could lead to unexpected results, especially when calculating debts and balances. Care should be taken to ensure that all arithmetic operations are safe and do not lead to negative values or unexpected overflows.

3. **Access Control Issues**:
   - The contract relies on the `onlyOwner` modifier for critical functions, which could be a single point of failure. If the owner’s private key is compromised, an attacker could gain control over the contract. Implementing a multi-signature wallet or a time-lock mechanism for sensitive operations would enhance security.

4. **Insufficient Input Validation**:
   - The contract has several checks for zero addresses and zero amounts, but additional validation could be beneficial. For instance, ensuring that the `_protocol` identifier is valid and not already in use before adding a new protocol could prevent potential issues.

5. **Potential Denial of Service (DoS)**:
   - Functions that rely on external contracts (like the token contract) could be susceptible to DoS attacks if those contracts become unresponsive or malicious. This could prevent users from withdrawing funds or executing critical functions.

6. **Lack of Event Emission for Critical State Changes**:
   - While there are events emitted for many state changes, ensuring that all critical state changes are logged can help in tracking the contract's behavior and debugging issues. For example, when changing the protocol's active balance or premium, it would be prudent to emit an event.

7. **Claim Deadline Logic**:
   - The logic around claim deadlines for removed protocols could lead to confusion or exploitation if not properly documented and understood. It’s crucial to ensure that the claim process is transparent and that users are aware of the timelines involved.

8. **Gas Limit Issues**:
   - Functions that involve loops (like `setProtocolPremiums`) could run into gas limit issues if the number of protocols becomes large. This could lead to failed transactions and a poor user experience.

### Comprehensive Analysis Report:

The `SherlockProtocolManager` contract is a complex piece of code that manages protocol coverage and premium payments. While it incorporates several best practices, including the use of SafeERC20 for token transfers, there are notable vulnerabilities that could be exploited if not addressed.

1. **Reentrancy and External Calls**: The potential for reentrancy attacks exists, especially in functions that transfer tokens. Implementing a reentrancy guard would help mitigate this risk.

2. **Access Control**: The reliance on a single owner for critical operations poses a risk. Transitioning to a multi-signature model or incorporating a governance mechanism could enhance security.

3. **Input Validation and Error Handling**: While the contract performs some input validation, additional checks could prevent invalid states and enhance robustness. Ensuring that all critical state changes are logged through events will also aid in tracking and debugging.

4. **Gas Limit Considerations**: Functions that involve loops should be optimized to prevent gas limit issues, especially as the number of protocols grows.

5. **Documentation and Clarity**: Clear documentation regarding the claim deadlines and protocol management processes will help users understand the contract's functionality and limitations.

In conclusion, while the `SherlockProtocolManager` contract is designed with several security features, addressing the identified vulnerabilities will significantly enhance its resilience against potential attacks and operational failures. Regular audits and updates, along with community feedback, will be essential in maintaining the contract's security posture.

[2024-25-08 10:59:38 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import './Manager.sol'; import '../interfaces/managers/ISherlockProtocolManager.sol'; /// @title Sherlock core interface for protocols /// @author Evert Kors // This is the contract that manages covered protocols contract SherlockProtocolManager is ISherlockProtocolManager, Manager {   using SafeERC20 for IERC20; // Represents the token that protocols pay with (currently USDC)   IERC20 public immutable token; // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed   uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc // A removed protocol is still able to make a claim for this amount of time after its removal   uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days; // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance   uint256 public constant MIN_SECONDS_LEFT = 7 days; // Convenient for percentage calculations   uint256 internal constant HUNDRED_PERCENT = 10**18; // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage   // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying   uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours; // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)   mapping(bytes32 =&gt; address) internal protocolAgent_; // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)   mapping(bytes32 =&gt; uint256) internal nonStakersPercentage; // The premium per second paid by each protocol is stored in this mapping   mapping(bytes32 =&gt; uint256) internal premiums_; // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.   // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not   mapping(bytes32 =&gt; uint256) internal activeBalances; // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol   mapping(bytes32 =&gt; uint256) internal lastAccountedEachProtocol; // The amount that can be claimed by nonstakers for each protocol   // We need this value so we can track how much payment is coming from each protocol   mapping(bytes32 =&gt; uint256) internal nonStakersClaimableByProtocol; // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)   uint256 internal lastAccountedGlobal; // This is the total amount of premiums paid (per second) by all the covered protocols (added up)   uint256 internal allPremiumsPerSecToStakers; // This is the amount that was claimable by stakers the last time the accounting was run   // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date   uint256 internal lastClaimablePremiumsForStakers; // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage   // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)   uint256 public override minActiveBalance; // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)   mapping(bytes32 =&gt; uint256) internal removedProtocolClaimDeadline; // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)   mapping(bytes32 =&gt; address) internal removedProtocolAgent; // Current amount of coverage (i.e. 20M USDC) for a protocol   mapping(bytes32 =&gt; uint256) internal currentCoverage; // Previous amount of coverage for a protocol   // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount   mapping(bytes32 =&gt; uint256) internal previousCoverage; // Setting the token to USDC   constructor(IERC20 _token) {     if (address(_token) == address(0)) revert ZeroArgument();     token = _token;   } // Modifier used to ensure a protocol exists (has been instantiated and not removed)   modifier protocolExists(bytes32 protocol) {     _verifyProtocolExists(_protocol);     ;   } /// @notice View current protocolAgent of _protocol   /// @param protocol Protocol identifier   /// @return Address able to submit claims   function protocolAgent(bytes32 _protocol) external view override returns (address) {     address agent = protocolAgent[_protocol];     if (agent != address(0)) return agent; // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned // Note: Old protocol agent will never be address(0) if (block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]) {   return removedProtocolAgent[_protocol]; }  // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned revert ProtocolNotExists(_protocol);  } // Checks if the protocol exists, then returns the current premium per second being charged   /// @notice View current premium of protocol   /// @param protocol Protocol identifier   /// @return Amount of premium _protocol pays per second   function premium(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return premiums[_protocol];   } // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)   // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)   function verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {     _protocolAgent = protocolAgent[_protocol];     if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);   } //   // View methods   // // Calcs the debt accrued by the protocol since it last had an accounting update   // This is the amount that needs to be removed from a protocol's active balance   function calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {     return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums[_protocol];   } /// @notice View the amount nonstakers can claim from this protocol   /// @param _protocol Protocol identifier   /// @return Amount of tokens claimable by nonstakers   /// @dev this reads from a storage variable + (now-lastsettled) * premiums   // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]   // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed   function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {     // Calcs the debt of a protocol since the last accounting update     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     // Gets the active balance of the protocol     uint256 balance = activeBalances[_protocol];     // The debt should never be higher than the balance (only happens if the arbitrages fail)     if (debt &gt; balance) debt = balance; // Adds the incremental claimable amount owed to nonstakers to the total claimable amount return   nonStakersClaimableByProtocol[_protocol] +   (nonStakersPercentage[_protocol] * debt) /   HUNDRED_PERCENT;  } /// @notice View current amount of all premiums that are owed to stakers   /// @return Premiums claimable   /// @dev Will increase every block   /// @dev base + (now - last_settled) * ps   function claimablePremiums() public view override returns (uint256) {     // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)     return       lastClaimablePremiumsForStakers +       (block.timestamp - lastAccountedGlobal) *       allPremiumsPerSecToStakers;   } /// @notice View seconds of coverage left for _protocol before it runs out of active balance   /// @param _protocol Protocol identifier   /// @return Seconds of coverage left   function secondsOfCoverageLeft(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return _secondsOfCoverageLeft(_protocol);   } // Helper function to return seconds of coverage left for a protocol   // Gets the current active balance of the protocol and divides by the premium per second for the protocol   function secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {     uint256 premium = premiums[_protocol];     if (premium == 0) return 0;     return _activeBalance(_protocol) / premium;   } /// @notice View current active balance of covered protocol   /// @param _protocol Protocol identifier   /// @return Active balance   /// @dev Accrued debt is subtracted from the stored active balance   function activeBalance(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return _activeBalance(_protocol);   } // Helper function to calc the active balance of a protocol at current time   function _activeBalance(bytes32 _protocol) internal view returns (uint256) {     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     uint256 balance = activeBalances[_protocol];     // The debt should never be higher than the balance (only happens if the arbitrages fail)     if (debt &gt; balance) return 0;     return balance - debt;   } //   // State methods   // /// @notice Helps set the premium per second for an individual protocol   /// @param protocol Protocol identifier   /// @param _premium New premium per second   /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function   function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)     internal     returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)   {     // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers     // Also updates the last accounted timestamp for this protocol     // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings     // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol     nonStakerPercentage = _settleProtocolDebt(_protocol);     // Stores the old premium before it gets updated     oldPremiumPerSecond = premiums[_protocol]; if (oldPremiumPerSecond != _premium) {   // Sets the protocol's premium per second to the new value   premiums_[_protocol] = _premium;   emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium); } // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point // Where arbs would no longer be incentivized to remove the protocol // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems if (_premium != 0 &amp;&amp; _secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_OF_COVERAGE) {   revert InsufficientBalance(_protocol); }  } /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second   /// @param _protocol Protocol identifier   /// @param _premium New premium per second   function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {     // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings     (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(       _protocol,       _premium     );     // Settling the total amount of premiums owed to stakers before a new premium per second gets set     _settleTotalDebt();     // This calculates the new global premium per second that gets paid to stakers     // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function     allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(       oldPremiumPerSecond,       _premium,       nonStakerPercentage,       nonStakerPercentage,       allPremiumsPerSecToStakers     );   } // Internal function to set a new protocolAgent for a specific protocol   // oldAgent is only included as part of emitting an event   function _setProtocolAgent(     bytes32 _protocol,     address _oldAgent,     address _protocolAgent   ) internal {     protocolAgent[_protocol] = _protocolAgent;     emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);   } // Subtracts the accrued debt from a protocol's active balance   // Credits the amount that can be claimed by nonstakers for this protocol   // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings   // Most of this function is dealing with an edge case related to a protocol not being removed by arbs   function settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {     // This calcs the accrued debt of the protocol since it was last updated     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     // This pulls the percentage that is sent to nonstakers     _nonStakerPercentage = nonStakersPercentage[_protocol];     // In case the protocol has accrued debt, this code block will ensure the debt is settled properly     if (debt != 0) {       // Pulls the stored active balance of the protocol       uint256 balance = activeBalances[_protocol];       // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance       // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point       // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage       // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up       if (debt &gt; balance) {         // This error amount represents the magnitude of the mistake         uint256 error = debt - balance;         // Gets the latest value of claimable premiums for stakers         _settleTotalDebt();         // @note to production, set premium first to zero before solving accounting issue.         // otherwise the accounting error keeps increasing         uint256 lastClaimablePremiumsForStakers = lastClaimablePremiumsForStakers;     // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%     uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /       HUNDRED_PERCENT;      // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short     uint256 insufficientTokens;      // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally     // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error     // This first line can be true if claimPremiumsForStakers() has been called and     // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be &gt;0 still     if (claimablePremiumError &gt; lastClaimablePremiumsForStakers_) {       insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;       lastClaimablePremiumsForStakers = 0;     } else {       // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums       // By the amount that was added in error (error) and insufficientTokens = 0       lastClaimablePremiumsForStakers =         lastClaimablePremiumsForStakers_ -         claimablePremiumError;     }      // If two events are thrown, the values need to be summed up for the actual state.     // This means an error of this type will continue until it is handled     emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);     // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case     debt = balance;   }   // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance   activeBalances[_protocol] = balance - debt;   // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol   nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT; } // Updates the last accounted timestamp for this protocol lastAccountedEachProtocol[_protocol] = block.timestamp;  } // Multiplies the total premium per second * number of seconds since the last global accounting update   // And adds it to the total claimable amount for stakers   function _settleTotalDebt() internal {     lastClaimablePremiumsForStakers +=       (block.timestamp - lastAccountedGlobal) *       allPremiumsPerSecToStakers;     lastAccountedGlobal = block.timestamp;   } // Calculates the global premium per second for stakers   // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers   // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones   function _calcGlobalPremiumPerSecForStakers(     uint256 _premiumOld,     uint256 _premiumNew,     uint256 _nonStakerPercentageOld,     uint256 _nonStakerPercentageNew,     uint256 _inMemAllPremiumsPerSecToStakers   ) internal pure returns (uint256) {     return       _inMemAllPremiumsPerSecToStakers +       ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /       HUNDRED_PERCENT -       ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /       HUNDRED_PERCENT;   } // Helper function to remove and clean up a protocol from Sherlock   // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made   function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {     // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol     _setSingleAndGlobalProtocolPremium(_protocol, 0); // Grabs the protocol's active balance uint256 balance = activeBalances[_protocol];  // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent if (balance != 0) {   delete activeBalances[_protocol];   token.safeTransfer(_agent, balance);    emit ProtocolBalanceWithdrawn(_protocol, balance); }  // Sets the protocol agent to zero address (as part of clean up) _setProtocolAgent(_protocol, _agent, address(0));  // Cleans up other mappings for this protocol delete nonStakersPercentage[_protocol]; delete lastAccountedEachProtocol[_protocol]; // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above  // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;  // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked removedProtocolAgent[_protocol] = _agent;  emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0)); emit ProtocolRemoved(_protocol);  } /// @notice Sets the minimum active balance before an arb can remove a protocol   /// @param _minActiveBalance Minimum balance needed (in USDC)   /// @dev Only gov   function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {     // New value cannot be the same as current value     if (minActiveBalance == _minActiveBalance) revert InvalidArgument();     // Can't set a value that is too high to be reasonable     if (_minActiveBalance &gt;= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions(); emit MinBalance(minActiveBalance, _minActiveBalance); minActiveBalance = _minActiveBalance;  } // This function allows the nonstakers role to claim tokens owed to them by a specific protocol   /// @notice Choose an _amount of tokens that nonstakers (_receiver address) will receive from _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens   /// @param _receiver Address to receive tokens   /// @dev Only callable by nonstakers role   function nonStakersClaim(     bytes32 _protocol,     uint256 _amount,     address _receiver   ) external override whenNotPaused {     if (_protocol == bytes32(0)) revert ZeroArgument();     if (_amount == uint256(0)) revert ZeroArgument();     if (_receiver == address(0)) revert ZeroArgument();     // Only the nonstakers role (multisig or contract) can pull the funds     if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized(); // Call can't be executed on protocol that is removed if (protocolAgent_[_protocol] != address(0)) {   // Updates the amount that nonstakers can claim from this protocol   _settleProtocolDebt(_protocol); }  // Sets balance to the amount that is claimable by nonstakers for this specific protocol uint256 balance = nonStakersClaimableByProtocol[_protocol]; // If the amount requested is more than what's owed to nonstakers, revert if (_amount &gt; balance) revert InsufficientBalance(_protocol);  // Sets the claimable amount to whatever is left over after this amount is pulled nonStakersClaimableByProtocol[_protocol] = balance - _amount; // Transfers the amount requested to the `_receiver` address token.safeTransfer(_receiver, _amount);  } // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)   /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address   /// @dev Callable by everyone   /// @dev Funds will be transferred to Sherlock core contract   function claimPremiumsForStakers() external override whenNotPaused {     // Gets address of core Sherlock contract     address sherlock = address(sherlockCore);     // Revert if core Sherlock contract not initialized yet     if (sherlock == address(0)) revert InvalidConditions(); // claimablePremiums is different from _settleTotalDebt() because it does not change state // Retrieves current amount of all premiums that are owed to stakers uint256 amount = claimablePremiums();  // Transfers all the premiums owed to stakers to the Sherlock core contract if (amount != 0) {   // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out   lastClaimablePremiumsForStakers = 0;   lastAccountedGlobal = block.timestamp;   token.safeTransfer(sherlock, amount); }  } // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts   /// @param protocol Protocol identifier   /// @return current and previous are the current and previous coverage amounts for this protocol   // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)   function coverageAmounts(bytes32 _protocol)     external     view     override     returns (uint256 current, uint256 previous)   {     // Checks to see if the protocol has an active protocolAgent (protocol not removed)     // OR checks to see if the removed protocol is still within the claim window     // If so, gives the current and previous coverage, otherwise throws an error     if (       protocolAgent[_protocol] != address(0) ||       block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]     ) {       return (currentCoverage[_protocol], previousCoverage[_protocol]);     } revert ProtocolNotExists(_protocol);  } /// @notice Add a new protocol to Sherlock   /// @param protocol Protocol identifier   /// @param _protocolAgent Address able to submit a claim on behalf of the protocol   /// @param _coverage Hash referencing the active coverage agreement   /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 1018   /// @param _coverageAmount Max amount claimable by this protocol   /// @dev Adding a protocol allows the _protocolAgent to submit a claim   /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point   /// @dev _nonStakers is scaled by 1018   /// @dev Only callable by governance   function protocolAdd(     bytes32 _protocol,     address _protocolAgent,     bytes32 _coverage,     uint256 _nonStakers,     uint256 _coverageAmount   ) external override onlyOwner {     if (_protocol == bytes32(0)) revert ZeroArgument();     if (_protocolAgent == address(0)) revert ZeroArgument();     // Checks to make sure the protocol doesn't exist already     if (protocolAgent[_protocol] != address(0)) revert InvalidConditions(); // Updates the protocol agent and passes in the old agent which is 0 address in this case _setProtocolAgent(_protocol, address(0), _protocolAgent);  // Delete mappings that are potentially non default values // From previous time protocol was added/removed delete removedProtocolClaimDeadline[_protocol]; delete removedProtocolAgent[_protocol]; delete currentCoverage[_protocol]; delete previousCoverage[_protocol];  emit ProtocolAdded(_protocol);  // Most of the logic for actually adding a protocol in this function protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);  } /// @notice Update info regarding a protocol   /// @param _protocol Protocol identifier   /// @param _coverage Hash referencing the active coverage agreement   /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18   /// @param _coverageAmount Max amount claimable by this protocol   /// @dev Only callable by governance   /// @dev _nonStakers can be 0   function protocolUpdate(     bytes32 _protocol,     bytes32 _coverage,     uint256 _nonStakers,     uint256 _coverageAmount   ) public override onlyOwner {     if (_coverage == bytes32(0)) revert ZeroArgument();     if (_nonStakers &gt; HUNDRED_PERCENT) revert InvalidArgument();     if (_coverageAmount == uint256(0)) revert ZeroArgument(); // Checks to make sure the protocol has been assigned a protocol agent _verifyProtocolExists(_protocol);  // Subtracts the accrued debt from a protocol's active balance (if any) // Updates the amount that can be claimed by nonstakers _settleProtocolDebt(_protocol);  // Updates the global claimable amount for stakers _settleTotalDebt();  // Gets the premium per second for this protocol uint256 premium = premiums_[_protocol];  // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be) allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(   premium,   premium,   nonStakersPercentage[_protocol],   _nonStakers,   allPremiumsPerSecToStakers );  // Updates the stored value of percentage of premiums that go to nonstakers nonStakersPercentage[_protocol] = _nonStakers;  // Updates previous coverage and current coverage amounts previousCoverage[_protocol] = currentCoverage[_protocol]; currentCoverage[_protocol] = _coverageAmount;  emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);  } /// @notice Remove a protocol from coverage   /// @param _protocol Protocol identifier   /// @dev Before removing a protocol the premium must be 0   /// @dev Removing a protocol basically stops the _protocolAgent from being active (can still submit claims until claim deadline though)   /// @dev Pays off debt + sends remaining balance to protocol agent   /// @dev This call should be subject to a timelock   /// @dev Only callable by governance   function protocolRemove(bytes32 _protocol) external override onlyOwner {     // checks to make sure the protocol actually has a protocol agent     address agent = _verifyProtocolExists(_protocol); // Removes a protocol from Sherlock and cleans up its data // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made _forceRemoveProtocol(_protocol, agent);  } /// @notice Remove a protocol with insufficient active balance   /// @param _protocol Protocol identifier   // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function   function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {     address agent = _verifyProtocolExists(_protocol); // Gets the latest value of the active balance at this protocol _settleProtocolDebt(_protocol); // Sets latest value of active balance to remainingBalance variable uint256 remainingBalance = activeBalances[_protocol];  // This means the protocol still has adequate active balance and thus cannot be removed if (remainingBalance &gt;= minActiveBalance) revert InvalidConditions();  // Sets the protocol's active balance to 0 delete activeBalances[_protocol]; // Removes the protocol from coverage _forceRemoveProtocol(_protocol, agent);  if (remainingBalance != 0) {   // sends the remaining balance to msg.sender   token.safeTransfer(msg.sender, remainingBalance); } emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);  } /// @notice Calculate if arb is possible and what the reward would be   /// @param _protocol Protocol identifier   /// @return arbAmount Amount reward for arbing   /// @return able Indicator if arb call is even possible   /// @dev Doesn't subtract the current protocol debt from the active balance   function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)     internal     view     returns (uint256 arbAmount, bool able)   {     uint256 secondsLeft = _secondsOfCoverageLeft(_protocol); // If arb is not possible return false if (secondsLeft &gt;= MIN_SECONDS_OF_COVERAGE) return (0, false);  // This percentage scales over time // Reaches 100% on 0 seconds of coverage left uint256 percentageScaled = HUNDRED_PERCENT -   (secondsLeft * HUNDRED_PERCENT) /   MIN_SECONDS_OF_COVERAGE;  able = true; arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;  } /// @notice Removes a protocol with insufficent seconds of coverage left   /// @param _protocol Protocol identifier   // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second   function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {     // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings     address agent = _verifyProtocolExists(_protocol); // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance() // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance() // But when removing based on seconds of coverage left, the remainingBalance could still be quite large // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%) _settleProtocolDebt(_protocol); (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol); if (able == false) revert InvalidConditions();  if (arbAmount != 0) {   // subtracts the amount that will be paid to the arb from the active balance   activeBalances[_protocol] -= arbAmount; }  // Removes the protocol from coverage // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above _forceRemoveProtocol(_protocol, agent);  // Done after removing protocol to mitigate reentrency pattern // (In case token allows callback) if (arbAmount != 0) {   token.safeTransfer(msg.sender, arbAmount); } emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);  } /// @notice Set premium of _protocol to _premium   /// @param _protocol Protocol identifier   /// @param _premium Amount of premium _protocol pays per second   /// @dev The value 0 would mean inactive coverage   /// @dev Only callable by governance   function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {     // Checks to see if protocol has a protocol agent     _verifyProtocolExists(_protocol); // Updates individual protocol's premium and allPremiumsPerSecToStakers _setSingleAndGlobalProtocolPremium(_protocol, _premium);  } /// @notice Set premium of multiple protocols   /// @param _protocol Array of protocol identifiers   /// @param _premium Array of premium amounts protocols pay per second   /// @dev The value 0 would mean inactive coverage   /// @dev Only callable by governance   function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)     external     override     onlyOwner   {     // Checks to make sure there are an equal amount of entries in each array     if (_protocol.length != _premium.length) revert UnequalArrayLength();     if (_protocol.length == 0) revert InvalidArgument(); // Updates the global claimable amount for stakers _settleTotalDebt();  uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;  // Loops through the array of protocols and checks to make sure each has a protocol agent assigned for (uint256 i; i &lt; _protocol.length; i++) {   _verifyProtocolExists(_protocol[i]);    // Sets the protocol premium for that specific protocol   // Function returns the old premium and nonStakerPercentage for that specific protocol   (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(     _protocol[i],     _premium[i]   );    // Calculates the new global premium which adds up all premiums paid by all protocols   allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(     oldPremiumPerSecond,     _premium[i],     nonStakerPercentage,     nonStakerPercentage,     allPremiumsPerSecToStakers_   ); }  // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;  } // This is how protocols pay for coverage by increasing their active balance   /// @notice Deposits _amount of token to the active balance of _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens to deposit   /// @dev Approval should be made before calling   function depositToActiveBalance(bytes32 _protocol, uint256 _amount)     external     override     whenNotPaused   {     if (_amount == uint256(0)) revert ZeroArgument();     _verifyProtocolExists(_protocol); // Transfers _amount to this contract token.safeTransferFrom(msg.sender, address(this), _amount); // Increases the active balance of the protocol by _amount activeBalances[_protocol] += _amount;  emit ProtocolBalanceDeposited(_protocol, _amount);  } // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)   // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)   /// @notice Withdraws _amount of token from the active balance of _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens to withdraw   /// @dev Only protocol agent is able to withdraw   /// @dev Balance can be withdrawn up until 7 days worth of active balance   function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)     external     override     whenNotPaused   {     if (_amount == uint256(0)) revert ZeroArgument();     // Only the protocol agent can call this function     if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized(); // Updates the active balance of the protocol _settleProtocolDebt(_protocol);  // Sets currentBalance to the active balance of the protocol uint256 currentBalance = activeBalances[_protocol]; // Reverts if trying to withdraw more than the active balance if (_amount &gt; currentBalance) revert InsufficientBalance(_protocol);  // Removes the _amount to be withdrawn from the active balance activeBalances[_protocol] = currentBalance - _amount; // Reverts if a protocol has less than 7 days worth of active balance left if (_secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);  // Transfers the amount to the msg.sender (protocol agent) token.safeTransfer(msg.sender, _amount); emit ProtocolBalanceWithdrawn(_protocol, _amount);  } /// @notice Transfer protocol agent role   /// @param _protocol Protocol identifier   /// @param _protocolAgent Account able to submit a claim on behalf of the protocol   /// @dev Only the active protocolAgent is able to transfer the role   function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)     external     override     whenNotPaused   {     if (_protocolAgent == address(0)) revert ZeroArgument();     // Can't set the new protocol agent to the caller address     if (msg.sender == _protocolAgent) revert InvalidArgument();     // Because the caller must be the current protocol agent     if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized(); // Sets the protocol agent to the new address _setProtocolAgent(_protocol, msg.sender, _protocolAgent);  } /// @notice Function used to check if this is the current active protocol manager   /// @return Boolean indicating it's active   /// @dev If inactive the owner can pull all ERC20s and ETH   /// @dev Will be checked by calling the sherlock contract   function isActive() public view returns (bool) {     return address(sherlockCore.sherlockProtocolManager()) == address(this);   } // Only contract owner can call this   // Sends all specified tokens in this contract to the receiver's address (as well as ETH)   function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {     if (_receiver == address(0)) revert ZeroArgument();     // This contract must NOT be the current assigned protocol manager contract     if (isActive()) revert InvalidConditions();     // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH     _sweep(_receiver, _extraTokens);   } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/***********\\n Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x)\n Sherlock Protocol: https://sherlock.xyz\n/***********/\n\nimport \'./Manager.sol\';\nimport \'../interfaces/managers/ISherlockProtocolManager.sol\';\n\n/// @title Sherlock core interface for protocols\n/// @author Evert Kors\n// This is the contract that manages covered protocols\n\ncontract SherlockProtocolManager is ISherlockProtocolManager, Manager {\n  using SafeERC20 for IERC20;\n\n  // Represents the token that protocols pay with (currently USDC)\n  IERC20 public immutable token;\n\n  // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed\n  uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 106; // 30k usdc\n\n  // A removed protocol is still able to make a claim for this amount of time after its removal\n  uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days;\n\n  // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance\n  uint256 public constant MIN_SECONDS_LEFT = 7 days;\n\n  // Convenient for percentage calculations\n  uint256 internal constant HUNDRED_PERCENT = 1018;\n\n  // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage\n  // This value is calculated from a protocol\'s active balance divided by the premium per second the protocol is paying\n  uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours;\n\n  // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)\n  mapping(bytes32 =&gt; address) internal protocolAgent_;\n\n  // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)\n  mapping(bytes32 =&gt; uint256) internal nonStakersPercentage;\n\n  // The premium per second paid by each protocol is stored in this mapping\n  mapping(bytes32 =&gt; uint256) internal premiums_;\n\n  // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.\n  // This "active balance" is really just an accounting concept, doesn\'t mean tokens have been transferred or not\n  mapping(bytes32 =&gt; uint256) internal activeBalances;\n\n  // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol\n  mapping(bytes32 =&gt; uint256) internal lastAccountedEachProtocol;\n\n  // The amount that can be claimed by nonstakers for each protocol\n  // We need this value so we can track how much payment is coming from each protocol\n  mapping(bytes32 =&gt; uint256) internal nonStakersClaimableByProtocol;\n\n  // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)\n  uint256 internal lastAccountedGlobal;\n\n  // This is the total amount of premiums paid (per second) by all the covered protocols (added up)\n  uint256 internal allPremiumsPerSecToStakers;\n\n  // This is the amount that was claimable by stakers the last time the accounting was run\n  // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date\n  uint256 internal lastClaimablePremiumsForStakers;\n\n  // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage\n  // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)\n  uint256 public override minActiveBalance;\n\n  // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)\n  mapping(bytes32 =&gt; uint256) internal removedProtocolClaimDeadline;\n\n  // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)\n  mapping(bytes32 =&gt; address) internal removedProtocolAgent;\n\n  // Current amount of coverage (i.e. 20M USDC) for a protocol\n  mapping(bytes32 =&gt; uint256) internal currentCoverage;\n\n  // Previous amount of coverage for a protocol\n  // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount\n  mapping(bytes32 =&gt; uint256) internal previousCoverage;\n\n  // Setting the token to USDC\n  constructor(IERC20 token) {\n    if (address(_token) == address(0)) revert ZeroArgument();\n    token = _token;\n  }\n\n  // Modifier used to ensure a protocol exists (has been instantiated and not removed)\n  modifier protocolExists(bytes32 _protocol) {\n    _verifyProtocolExists(_protocol);\n    ;\n  }\n\n  /// @notice View current protocolAgent of _protocol\n  /// @param protocol Protocol identifier\n  /// @return Address able to submit claims\n  function protocolAgent(bytes32 _protocol) external view override returns (address) {\n    address agent = protocolAgent[protocol];\n    if (agent != address(0)) return agent;\n\n    // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned\n    // Note: Old protocol agent will never be address(0)\n    if (block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]) {\n      return removedProtocolAgent[_protocol];\n    }\n\n    // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned\n    revert ProtocolNotExists(_protocol);\n  }\n\n  // Checks if the protocol exists, then returns the current premium per second being charged\n  /// @notice View current premium of protocol\n  /// @param _protocol Protocol identifier\n  /// @return Amount of premium _protocol pays per second\n  function premium(bytes32 _protocol)\n    external\n    view\n    override\n    protocolExists(_protocol)\n    returns (uint256)\n  {\n    return premiums[protocol];\n  }\n\n  // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)\n  // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)\n  function _verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {\n    _protocolAgent = protocolAgent[protocol];\n    if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);\n  }\n\n  //\n  // View methods\n  //\n\n  // Calcs the debt accrued by the protocol since it last had an accounting update\n  // This is the amount that needs to be removed from a protocol\'s active balance\n  function _calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {\n    return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums[protocol];\n  }\n\n  /// @notice View the amount nonstakers can claim from this protocol\n  /// @param _protocol Protocol identifier\n  /// @return Amount of tokens claimable by nonstakers\n  /// @dev this reads from a storage variable + (now-lastsettled) * premiums\n  // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]\n  // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn\'t change since the protocol has been removed\n  function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {\n    // Calcs the debt of a protocol since the last accounting update\n    uint256 debt = _calcIncrementalProtocolDebt(_protocol);\n    // Gets the active balance of the protocol\n    uint256 balance = activeBalances[_protocol];\n    // The debt should never be higher than the balance (only happens if the arbitrages fail)\n    if (debt &gt; balance) debt = balance;\n\n    // Adds the incremental claimable amount owed to nonstakers to the total claimable amount\n    return\n      nonStakersClaimableByProtocol[_protocol] +\n      (nonStakersPercentage[_protocol] * debt) /\n      HUNDRED_PERCENT;\n  }\n\n  /// @notice View current amount of all premiums that are owed to stakers\n  /// @return Premiums claimable\n  /// @dev Will increase every block\n  /// @dev base + (now - last_settled) * ps\n  function claimablePremiums() public view override returns (uint256) {\n    // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)\n    return\n      lastClaimablePremiumsForStakers +\n      (block.timestamp - lastAccountedGlobal) \n      allPremiumsPerSecToStakers;\n  }\n\n  /// @notice View seconds of coverage left for _protocol before it runs out of active balance\n  /// @param protocol Protocol identifier\n  /// @return Seconds of coverage left\n  function secondsOfCoverageLeft(bytes32 _protocol)\n    external\n    view\n    override\n    protocolExists(_protocol)\n    returns (uint256)\n  {\n    return _secondsOfCoverageLeft(_protocol);\n  }\n\n  // Helper function to return seconds of coverage left for a protocol\n  // Gets the current active balance of the protocol and divides by the premium per second for the protocol\n  function _secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {\n    uint256 premium = premiums[protocol];\n    if (premium == 0) return 0;\n    return _activeBalance(_protocol) / premium;\n  }\n\n  /// @notice View current active balance of covered protocol\n  /// @param _protocol Protocol identifier\n  /// @return Active balance\n  /// @dev Accrued debt is subtracted from the stored active balance\n  function activeBalance(bytes32 _protocol)\n    external\n    view\n    override\n    protocolExists(_protocol)\n    returns (uint256)\n  {\n    return _activeBalance(_protocol);\n  }\n\n  // Helper function to calc the active balance of a protocol at current time\n  function _activeBalance(bytes32 _protocol) internal view returns (uint256) {\n    uint256 debt = _calcIncrementalProtocolDebt(_protocol);\n    uint256 balance = activeBalances[_protocol];\n    // The debt should never be higher than the balance (only happens if the arbitrages fail)\n    if (debt &gt; balance) return 0;\n    return balance - debt;\n  }\n\n  //\n  // State methods\n  //\n\n  /// @notice Helps set the premium per second for an individual protocol\n  /// @param _protocol Protocol identifier\n  /// @param _premium New premium per second\n  /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function\n  function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)\n    internal\n    returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)\n  {\n    // _settleProtocolDebt() subtracts debt from the protocol\'s active balance and updates the % due to nonstakers\n    // Also updates the last accounted timestamp for this protocol\n    // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings\n    // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol\n    nonStakerPercentage = _settleProtocolDebt(_protocol);\n    // Stores the old premium before it gets updated\n    oldPremiumPerSecond = premiums[protocol];\n\n    if (oldPremiumPerSecond != _premium) {\n      // Sets the protocol\'s premium per second to the new value\n      premiums[protocol] = _premium;\n      emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium);\n    }\n    // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing\n    // We don\'t need to check the min balance requirement for arbs because that value doesn\'t change like secondsOfCoverageLeft changes\n    // Effectively we just need to make sure we don\'t accidentally run a protocol\'s active balance down below the point\n    // Where arbs would no longer be incentivized to remove the protocol\n    // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems\n    if (_premium != 0 &amp;&amp; _secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_OF_COVERAGE) {\n      revert InsufficientBalance(_protocol);\n    }\n  }\n\n  /// @notice Sets a single protocol\'s premium per second and also updates the global total of premiums per second\n  /// @param _protocol Protocol identifier\n  /// @param _premium New premium per second\n  function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {\n    // Sets the individual protocol\'s premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings\n    (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(\n      _protocol,\n      _premium\n    );\n    // Settling the total amount of premiums owed to stakers before a new premium per second gets set\n    _settleTotalDebt();\n    // This calculates the new global premium per second that gets paid to stakers\n    // We input the same nonStakerPercentage twice because we simply aren\'t updating that value in this function\n    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(\n      oldPremiumPerSecond,\n      _premium,\n      nonStakerPercentage,\n      nonStakerPercentage,\n      allPremiumsPerSecToStakers\n    );\n  }\n\n  // Internal function to set a new protocolAgent for a specific protocol\n  // _oldAgent is only included as part of emitting an event\n  function _setProtocolAgent(\n    bytes32 _protocol,\n    address _oldAgent,\n    address _protocolAgent\n  ) internal {\n    protocolAgent[protocol] = _protocolAgent;\n    emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);\n  }\n\n  // Subtracts the accrued debt from a protocol\'s active balance\n  // Credits the amount that can be claimed by nonstakers for this protocol\n  // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings\n  // Most of this function is dealing with an edge case related to a protocol not being removed by arbs\n  function _settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {\n    // This calcs the accrued debt of the protocol since it was last updated\n    uint256 debt = _calcIncrementalProtocolDebt(_protocol);\n    // This pulls the percentage that is sent to nonstakers\n    _nonStakerPercentage = nonStakersPercentage[_protocol];\n    // In case the protocol has accrued debt, this code block will ensure the debt is settled properly\n    if (debt != 0) {\n      // Pulls the stored active balance of the protocol\n      uint256 balance = activeBalances[_protocol];\n      // This is the start of handling an edge case where arbitragers don\'t remove this protocol before debt becomes greater than active balance\n      // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point\n      // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage\n      // However, if arbs don\'t come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up\n      if (debt &gt; balance) {\n        // This error amount represents the magnitude of the mistake\n        uint256 error = debt - balance;\n        // Gets the latest value of claimable premiums for stakers\n        _settleTotalDebt();\n        // @note to production, set premium first to zero before solving accounting issue.\n        // otherwise the accounting error keeps increasing\n        uint256 lastClaimablePremiumsForStakers = lastClaimablePremiumsForStakers;\n\n        // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%\n        uint256 claimablePremiumError = ((HUNDRED_PERCENT - nonStakerPercentage) * error) /\n          HUNDRED_PERCENT;\n\n        // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short\n        uint256 insufficientTokens;\n\n        // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally\n        // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error\n        // This first line can be true if claimPremiumsForStakers() has been called and\n        // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be &gt;0 still\n        if (claimablePremiumError &gt; lastClaimablePremiumsForStakers) {\n          insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;\n          lastClaimablePremiumsForStakers = 0;\n        } else {\n          // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums\n          // By the amount that was added in error (error) and insufficientTokens = 0\n          lastClaimablePremiumsForStakers =\n            lastClaimablePremiumsForStakers_ -\n            claimablePremiumError;\n        }\n\n        // If two events are thrown, the values need to be summed up for the actual state.\n        // This means an error of this type will continue until it is handled\n        emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);\n        // We set the debt equal to the balance, and in the next line we effectively set the protocol\'s active balance to 0 in this case\n        debt = balance;\n      }\n      // Subtracts the accrued debt (since last update) from the protocol\'s active balance and updates active balance\n      activeBalances[_protocol] = balance - debt;\n      // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol\n      nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT;\n    }\n    // Updates the last accounted timestamp for this protocol\n    lastAccountedEachProtocol[_protocol] = block.timestamp;\n  }\n\n  // Multiplies the total premium per second * number of seconds since the last global accounting update\n  // And adds it to the total claimable amount for stakers\n  function _settleTotalDebt() internal {\n    lastClaimablePremiumsForStakers +=\n      (block.timestamp - lastAccountedGlobal) \n      allPremiumsPerSecToStakers;\n    lastAccountedGlobal = block.timestamp;\n  }\n\n  // Calculates the global premium per second for stakers\n  // Takes a specific protocol\'s old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers\n  // Subtracts out the old values of a protocol\'s premium per second and nonstaker percentage and adds the new ones\n  function _calcGlobalPremiumPerSecForStakers(\n    uint256 _premiumOld,\n    uint256 _premiumNew,\n    uint256 _nonStakerPercentageOld,\n    uint256 _nonStakerPercentageNew,\n    uint256 _inMemAllPremiumsPerSecToStakers\n  ) internal pure returns (uint256) {\n    return\n      _inMemAllPremiumsPerSecToStakers +\n      ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /\n      HUNDRED_PERCENT -\n      ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /\n      HUNDRED_PERCENT;\n  }\n\n  // Helper function to remove and clean up a protocol from Sherlock\n  // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made\n  function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {\n    // Sets the individual protocol\'s premium to zero and updates the global premium variable for a zero premium at this protocol\n    _setSingleAndGlobalProtocolPremium(_protocol, 0);\n\n    // Grabs the protocol\'s active balance\n    uint256 balance = activeBalances[_protocol];\n\n    // If there\'s still some active balance, delete the entry and send the remaining balance to the protocol agent\n    if (balance != 0) {\n      delete activeBalances[_protocol];\n      token.safeTransfer(_agent, balance);\n\n      emit ProtocolBalanceWithdrawn(_protocol, balance);\n    }\n\n    // Sets the protocol agent to zero address (as part of clean up)\n    _setProtocolAgent(_protocol, _agent, address(0));\n\n    // Cleans up other mappings for this protocol\n    delete nonStakersPercentage[_protocol];\n    delete lastAccountedEachProtocol[_protocol];\n    // premiums_ mapping is not deleted here as it\'s already 0 because of the _setSingleAndGlobalProtocolPremium call above\n\n    // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol\n    removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;\n\n    // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed\n    // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked\n    removedProtocolAgent[_protocol] = _agent;\n\n    emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0));\n    emit ProtocolRemoved(_protocol);\n  }\n\n  /// @notice Sets the minimum active balance before an arb can remove a protocol\n  /// @param _minActiveBalance Minimum balance needed (in USDC)\n  /// @dev Only gov\n  function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {\n    // New value cannot be the same as current value\n    if (minActiveBalance == _minActiveBalance) revert InvalidArgument();\n    // Can\'t set a value that is too high to be reasonable\n    if (_minActiveBalance &gt;= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions();\n\n    emit MinBalance(minActiveBalance, _minActiveBalance);\n    minActiveBalance = _minActiveBalance;\n  }\n\n  // This function allows the nonstakers role to claim tokens owed to them by a specific protocol\n  /// @notice Choose an _amount of tokens that nonstakers (_receiver address) will receive from _protocol\n  /// @param _protocol Protocol identifier\n  /// @param _amount Amount of tokens\n  /// @param _receiver Address to receive tokens\n  /// @dev Only callable by nonstakers role\n  function nonStakersClaim(\n    bytes32 _protocol,\n    uint256 _amount,\n    address _receiver\n  ) external override whenNotPaused {\n    if (_protocol == bytes32(0)) revert ZeroArgument();\n    if (_amount == uint256(0)) revert ZeroArgument();\n    if (_receiver == address(0)) revert ZeroArgument();\n    // Only the nonstakers role (multisig or contract) can pull the funds\n    if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized();\n\n    // Call can\'t be executed on protocol that is removed\n    if (protocolAgent[protocol] != address(0)) {\n      // Updates the amount that nonstakers can claim from this protocol\n      _settleProtocolDebt(_protocol);\n    }\n\n    // Sets balance to the amount that is claimable by nonstakers for this specific protocol\n    uint256 balance = nonStakersClaimableByProtocol[_protocol];\n    // If the amount requested is more than what\'s owed to nonstakers, revert\n    if (_amount &gt; balance) revert InsufficientBalance(_protocol);\n\n    // Sets the claimable amount to whatever is left over after this amount is pulled\n    nonStakersClaimableByProtocol[_protocol] = balance - _amount;\n    // Transfers the amount requested to the _receiver address\n    token.safeTransfer(_receiver, _amount);\n  }\n\n  // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)\n  /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address\n  /// @dev Callable by everyone\n  /// @dev Funds will be transferred to Sherlock core contract\n  function claimPremiumsForStakers() external override whenNotPaused {\n    // Gets address of core Sherlock contract\n    address sherlock = address(sherlockCore);\n    // Revert if core Sherlock contract not initialized yet\n    if (sherlock == address(0)) revert InvalidConditions();\n\n    // claimablePremiums is different from _settleTotalDebt() because it does not change state\n    // Retrieves current amount of all premiums that are owed to stakers\n    uint256 amount = claimablePremiums();\n\n    // Transfers all the premiums owed to stakers to the Sherlock core contract\n    if (amount != 0) {\n      // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out\n      lastClaimablePremiumsForStakers = 0;\n      lastAccountedGlobal = block.timestamp;\n      token.safeTransfer(sherlock, amount);\n    }\n  }\n\n  // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts\n  /// @param _protocol Protocol identifier\n  /// @return current and previous are the current and previous coverage amounts for this protocol\n  // Note For this process to work, a protocol\'s coverage amount should not be set more than once in the span of claim delay period (7 days or something)\n  function coverageAmounts(bytes32 _protocol)\n    external\n    view\n    override\n    returns (uint256 current, uint256 previous)\n  {\n    // Checks to see if the protocol has an active protocolAgent (protocol not removed)\n    // OR checks to see if the removed protocol is still within the claim window\n    // If so, gives the current and previous coverage, otherwise throws an error\n    if (\n      protocolAgent[protocol] != address(0) ||\n      block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]\n    ) {\n      return (currentCoverage[_protocol], previousCoverage[_protocol]);\n    }\n\n    revert ProtocolNotExists(_protocol);\n  }\n\n  /// @notice Add a new protocol to Sherlock\n  /// @param _protocol Protocol identifier\n  /// @param _protocolAgent Address able to submit a claim on behalf of the protocol\n  /// @param _coverage Hash referencing the active coverage agreement\n  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 1018\n  /// @param _coverageAmount Max amount claimable by this protocol\n  /// @dev Adding a protocol allows the _protocolAgent to submit a claim\n  /// @dev Coverage is not started yet as the protocol doesn\'t pay a premium at this point\n  /// @dev _nonStakers is scaled by 1018\n  /// @dev Only callable by governance\n  function protocolAdd(\n    bytes32 _protocol,\n    address _protocolAgent,\n    bytes32 _coverage,\n    uint256 _nonStakers,\n    uint256 _coverageAmount\n  ) external override onlyOwner {\n    if (_protocol == bytes32(0)) revert ZeroArgument();\n    if (_protocolAgent == address(0)) revert ZeroArgument();\n    // Checks to make sure the protocol doesn\'t exist already\n    if (protocolAgent[protocol] != address(0)) revert InvalidConditions();\n\n    // Updates the protocol agent and passes in the old agent which is 0 address in this case\n    _setProtocolAgent(_protocol, address(0), _protocolAgent);\n\n    // Delete mappings that are potentially non default values\n    // From previous time protocol was added/removed\n    delete removedProtocolClaimDeadline[_protocol];\n    delete removedProtocolAgent[_protocol];\n    delete currentCoverage[_protocol];\n    delete previousCoverage[_protocol];\n\n    emit ProtocolAdded(_protocol);\n\n    // Most of the logic for actually adding a protocol in this function\n    protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);\n  }\n\n  /// @notice Update info regarding a protocol\n  /// @param _protocol Protocol identifier\n  /// @param _coverage Hash referencing the active coverage agreement\n  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18\n  /// @param _coverageAmount Max amount claimable by this protocol\n  /// @dev Only callable by governance\n  /// @dev _nonStakers can be 0\n  function protocolUpdate(\n    bytes32 _protocol,\n    bytes32 _coverage,\n    uint256 _nonStakers,\n    uint256 _coverageAmount\n  ) public override onlyOwner {\n    if (_coverage == bytes32(0)) revert ZeroArgument();\n    if (_nonStakers &gt; HUNDRED_PERCENT) revert InvalidArgument();\n    if (_coverageAmount == uint256(0)) revert ZeroArgument();\n\n    // Checks to make sure the protocol has been assigned a protocol agent\n    _verifyProtocolExists(_protocol);\n\n    // Subtracts the accrued debt from a protocol\'s active balance (if any)\n    // Updates the amount that can be claimed by nonstakers\n    _settleProtocolDebt(_protocol);\n\n    // Updates the global claimable amount for stakers\n    _settleTotalDebt();\n\n    // Gets the premium per second for this protocol\n    uint256 premium = premiums[protocol];\n\n    // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be)\n    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(\n      premium,\n      premium,\n      nonStakersPercentage[_protocol],\n      _nonStakers,\n      allPremiumsPerSecToStakers\n    );\n\n    // Updates the stored value of percentage of premiums that go to nonstakers\n    nonStakersPercentage[_protocol] = _nonStakers;\n\n    // Updates previous coverage and current coverage amounts\n    previousCoverage[_protocol] = currentCoverage[_protocol];\n    currentCoverage[_protocol] = _coverageAmount;\n\n    emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);\n  }\n\n  /// @notice Remove a protocol from coverage\n  /// @param _protocol Protocol identifier\n  /// @dev Before removing a protocol the premium must be 0\n  /// @dev Removing a protocol basically stops the _protocolAgent from being active (can still submit claims until claim deadline though)\n  /// @dev Pays off debt + sends remaining balance to protocol agent\n  /// @dev This call should be subject to a timelock\n  /// @dev Only callable by governance\n  function protocolRemove(bytes32 _protocol) external override onlyOwner {\n    // checks to make sure the protocol actually has a protocol agent\n    address agent = _verifyProtocolExists(_protocol);\n\n    // Removes a protocol from Sherlock and cleans up its data\n    // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made\n    _forceRemoveProtocol(_protocol, agent);\n  }\n\n  /// @notice Remove a protocol with insufficient active balance\n  /// @param _protocol Protocol identifier\n  // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function\n  function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {\n    address agent = _verifyProtocolExists(_protocol);\n\n    // Gets the latest value of the active balance at this protocol\n    _settleProtocolDebt(_protocol);\n    // Sets latest value of active balance to remainingBalance variable\n    uint256 remainingBalance = activeBalances[_protocol];\n\n    // This means the protocol still has adequate active balance and thus cannot be removed\n    if (remainingBalance &gt;= minActiveBalance) revert InvalidConditions();\n\n    // Sets the protocol\'s active balance to 0\n    delete activeBalances[_protocol];\n    // Removes the protocol from coverage\n    _forceRemoveProtocol(_protocol, agent);\n\n    if (remainingBalance != 0) {\n      // sends the remaining balance to msg.sender\n      token.safeTransfer(msg.sender, remainingBalance);\n    }\n    emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);\n  }\n\n  /// @notice Calculate if arb is possible and what the reward would be\n  /// @param _protocol Protocol identifier\n  /// @return arbAmount Amount reward for arbing\n  /// @return able Indicator if arb call is even possible\n  /// @dev Doesn\'t subtract the current protocol debt from the active balance\n  function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)\n    internal\n    view\n    returns (uint256 arbAmount, bool able)\n  {\n    uint256 secondsLeft = _secondsOfCoverageLeft(_protocol);\n\n    // If arb is not possible return false\n    if (secondsLeft &gt;= MIN_SECONDS_OF_COVERAGE) return (0, false);\n\n    // This percentage scales over time\n    // Reaches 100% on 0 seconds of coverage left\n    uint256 percentageScaled = HUNDRED_PERCENT -\n      (secondsLeft * HUNDRED_PERCENT) /\n      MIN_SECONDS_OF_COVERAGE;\n\n    able = true;\n    arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;\n  }\n\n  /// @notice Removes a protocol with insufficent seconds of coverage left\n  /// @param _protocol Protocol identifier\n  // Seconds of coverage is defined by the active balance of the protocol divided by the protocol\'s premium per second\n  function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {\n    // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings\n    address agent = _verifyProtocolExists(_protocol);\n\n    // NOTE: We don\'t give the arb the full remaining balance like we do in forceRemoveByActiveBalance()\n    // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance()\n    // But when removing based on seconds of coverage left, the remainingBalance could still be quite large\n    // So it\'s better to scale the arb reward over time. It\'s a little complex because the remainingBalance\n    // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%)\n    _settleProtocolDebt(_protocol);\n    (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol);\n    if (able == false) revert InvalidConditions();\n\n    if (arbAmount != 0) {\n      // subtracts the amount that will be paid to the arb from the active balance\n      activeBalances[_protocol] -= arbAmount;\n    }\n\n    // Removes the protocol from coverage\n    // This function also pays the active balance to the protocol agent, so it\'s good we do this after subtracting arb amount above\n    _forceRemoveProtocol(_protocol, agent);\n\n    // Done after removing protocol to mitigate reentrency pattern\n    // (In case token allows callback)\n    if (arbAmount != 0) {\n      token.safeTransfer(msg.sender, arbAmount);\n    }\n    emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);\n  }\n\n  /// @notice Set premium of _protocol to _premium\n  /// @param _protocol Protocol identifier\n  /// @param _premium Amount of premium _protocol pays per second\n  /// @dev The value 0 would mean inactive coverage\n  /// @dev Only callable by governance\n  function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {\n    // Checks to see if protocol has a protocol agent\n    _verifyProtocolExists(_protocol);\n\n    // Updates individual protocol\'s premium and allPremiumsPerSecToStakers\n    _setSingleAndGlobalProtocolPremium(_protocol, _premium);\n  }\n\n  /// @notice Set premium of multiple protocols\n  /// @param _protocol Array of protocol identifiers\n  /// @param _premium Array of premium amounts protocols pay per second\n  /// @dev The value 0 would mean inactive coverage\n  /// @dev Only callable by governance\n  function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)\n    external\n    override\n    onlyOwner\n  {\n    // Checks to make sure there are an equal amount of entries in each array\n    if (_protocol.length != _premium.length) revert UnequalArrayLength();\n    if (_protocol.length == 0) revert InvalidArgument();\n\n    // Updates the global claimable amount for stakers\n    _settleTotalDebt();\n\n    uint256 allPremiumsPerSecToStakers = allPremiumsPerSecToStakers;\n\n    // Loops through the array of protocols and checks to make sure each has a protocol agent assigned\n    for (uint256 i; i &lt; protocol.length; i++) {\n      _verifyProtocolExists(_protocol[i]);\n\n      // Sets the protocol premium for that specific protocol\n      // Function returns the old premium and nonStakerPercentage for that specific protocol\n      (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(\n        _protocol[i],\n        _premium[i]\n      );\n\n      // Calculates the new global premium which adds up all premiums paid by all protocols\n      allPremiumsPerSecToStakers = calcGlobalPremiumPerSecForStakers(\n        oldPremiumPerSecond,\n        _premium[i],\n        nonStakerPercentage,\n        nonStakerPercentage,\n        allPremiumsPerSecToStakers\n      );\n    }\n\n    // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value\n    allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;\n  }\n\n  // This is how protocols pay for coverage by increasing their active balance\n  /// @notice Deposits _amount of token to the active balance of _protocol\n  /// @param _protocol Protocol identifier\n  /// @param _amount Amount of tokens to deposit\n  /// @dev Approval should be made before calling\n  function depositToActiveBalance(bytes32 _protocol, uint256 _amount)\n    external\n    override\n    whenNotPaused\n  {\n    if (_amount == uint256(0)) revert ZeroArgument();\n    _verifyProtocolExists(_protocol);\n\n    // Transfers _amount to this contract\n    token.safeTransferFrom(msg.sender, address(this), _amount);\n    // Increases the active balance of the protocol by _amount\n    activeBalances[_protocol] += _amount;\n\n    emit ProtocolBalanceDeposited(_protocol, _amount);\n  }\n\n  // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)\n  // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)\n  /// @notice Withdraws _amount of token from the active balance of _protocol\n  /// @param _protocol Protocol identifier\n  /// @param _amount Amount of tokens to withdraw\n  /// @dev Only protocol agent is able to withdraw\n  /// @dev Balance can be withdrawn up until 7 days worth of active balance\n  function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)\n    external\n    override\n    whenNotPaused\n  {\n    if (_amount == uint256(0)) revert ZeroArgument();\n    // Only the protocol agent can call this function\n    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();\n\n    // Updates the active balance of the protocol\n    _settleProtocolDebt(_protocol);\n\n    // Sets currentBalance to the active balance of the protocol\n    uint256 currentBalance = activeBalances[_protocol];\n    // Reverts if trying to withdraw more than the active balance\n    if (_amount &gt; currentBalance) revert InsufficientBalance(_protocol);\n\n    // Removes the _amount to be withdrawn from the active balance\n    activeBalances[_protocol] = currentBalance - _amount;\n    // Reverts if a protocol has less than 7 days worth of active balance left\n    if (_secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);\n\n    // Transfers the amount to the msg.sender (protocol agent)\n    token.safeTransfer(msg.sender, _amount);\n    emit ProtocolBalanceWithdrawn(_protocol, _amount);\n  }\n\n  /// @notice Transfer protocol agent role\n  /// @param _protocol Protocol identifier\n  /// @param _protocolAgent Account able to submit a claim on behalf of the protocol\n  /// @dev Only the active protocolAgent is able to transfer the role\n  function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)\n    external\n    override\n    whenNotPaused\n  {\n    if (_protocolAgent == address(0)) revert ZeroArgument();\n    // Can\'t set the new protocol agent to the caller address\n    if (msg.sender == _protocolAgent) revert InvalidArgument();\n    // Because the caller must be the current protocol agent\n    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();\n\n    // Sets the protocol agent to the new address\n    _setProtocolAgent(_protocol, msg.sender, _protocolAgent);\n  }\n\n  /// @notice Function used to check if this is the current active protocol manager\n  /// @return Boolean indicating it\'s active\n  /// @dev If inactive the owner can pull all ERC20s and ETH\n  /// @dev Will be checked by calling the sherlock contract\n  function isActive() public view returns (bool) {\n    return address(sherlockCore.sherlockProtocolManager()) == address(this);\n  }\n\n  // Only contract owner can call this\n  // Sends all specified tokens in this contract to the receiver\'s address (as well as ETH)\n  function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {\n    if (_receiver == address(0)) revert ZeroArgument();\n    // This contract must NOT be the current assigned protocol manager contract\n    if (isActive()) revert InvalidConditions();\n    // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH\n    _sweep(_receiver, _extraTokens);\n  }\n}\n', 'ideas': ' Security', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-25-08 10:59:38 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import './Manager.sol'; import '../interfaces/managers/ISherlockProtocolManager.sol'; /// @title Sherlock core interface for protocols /// @author Evert Kors // This is the contract that manages covered protocols contract SherlockProtocolManager is ISherlockProtocolManager, Manager {   using SafeERC20 for IERC20; // Represents the token that protocols pay with (currently USDC)   IERC20 public immutable token; // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed   uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc // A removed protocol is still able to make a claim for this amount of time after its removal   uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days; // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance   uint256 public constant MIN_SECONDS_LEFT = 7 days; // Convenient for percentage calculations   uint256 internal constant HUNDRED_PERCENT = 10**18; // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage   // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying   uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours; // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)   mapping(bytes32 =&gt; address) internal protocolAgent_; // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)   mapping(bytes32 =&gt; uint256) internal nonStakersPercentage; // The premium per second paid by each protocol is stored in this mapping   mapping(bytes32 =&gt; uint256) internal premiums_; // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.   // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not   mapping(bytes32 =&gt; uint256) internal activeBalances; // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol   mapping(bytes32 =&gt; uint256) internal lastAccountedEachProtocol; // The amount that can be claimed by nonstakers for each protocol   // We need this value so we can track how much payment is coming from each protocol   mapping(bytes32 =&gt; uint256) internal nonStakersClaimableByProtocol; // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)   uint256 internal lastAccountedGlobal; // This is the total amount of premiums paid (per second) by all the covered protocols (added up)   uint256 internal allPremiumsPerSecToStakers; // This is the amount that was claimable by stakers the last time the accounting was run   // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date   uint256 internal lastClaimablePremiumsForStakers; // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage   // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)   uint256 public override minActiveBalance; // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)   mapping(bytes32 =&gt; uint256) internal removedProtocolClaimDeadline; // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)   mapping(bytes32 =&gt; address) internal removedProtocolAgent; // Current amount of coverage (i.e. 20M USDC) for a protocol   mapping(bytes32 =&gt; uint256) internal currentCoverage; // Previous amount of coverage for a protocol   // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount   mapping(bytes32 =&gt; uint256) internal previousCoverage; // Setting the token to USDC   constructor(IERC20 _token) {     if (address(_token) == address(0)) revert ZeroArgument();     token = _token;   } // Modifier used to ensure a protocol exists (has been instantiated and not removed)   modifier protocolExists(bytes32 protocol) {     _verifyProtocolExists(_protocol);     ;   } /// @notice View current protocolAgent of _protocol   /// @param protocol Protocol identifier   /// @return Address able to submit claims   function protocolAgent(bytes32 _protocol) external view override returns (address) {     address agent = protocolAgent[_protocol];     if (agent != address(0)) return agent; // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned // Note: Old protocol agent will never be address(0) if (block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]) {   return removedProtocolAgent[_protocol]; }  // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned revert ProtocolNotExists(_protocol);  } // Checks if the protocol exists, then returns the current premium per second being charged   /// @notice View current premium of protocol   /// @param protocol Protocol identifier   /// @return Amount of premium _protocol pays per second   function premium(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return premiums[_protocol];   } // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)   // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)   function verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {     _protocolAgent = protocolAgent[_protocol];     if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);   } //   // View methods   // // Calcs the debt accrued by the protocol since it last had an accounting update   // This is the amount that needs to be removed from a protocol's active balance   function calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {     return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums[_protocol];   } /// @notice View the amount nonstakers can claim from this protocol   /// @param _protocol Protocol identifier   /// @return Amount of tokens claimable by nonstakers   /// @dev this reads from a storage variable + (now-lastsettled) * premiums   // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]   // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed   function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {     // Calcs the debt of a protocol since the last accounting update     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     // Gets the active balance of the protocol     uint256 balance = activeBalances[_protocol];     // The debt should never be higher than the balance (only happens if the arbitrages fail)     if (debt &gt; balance) debt = balance; // Adds the incremental claimable amount owed to nonstakers to the total claimable amount return   nonStakersClaimableByProtocol[_protocol] +   (nonStakersPercentage[_protocol] * debt) /   HUNDRED_PERCENT;  } /// @notice View current amount of all premiums that are owed to stakers   /// @return Premiums claimable   /// @dev Will increase every block   /// @dev base + (now - last_settled) * ps   function claimablePremiums() public view override returns (uint256) {     // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)     return       lastClaimablePremiumsForStakers +       (block.timestamp - lastAccountedGlobal) *       allPremiumsPerSecToStakers;   } /// @notice View seconds of coverage left for _protocol before it runs out of active balance   /// @param _protocol Protocol identifier   /// @return Seconds of coverage left   function secondsOfCoverageLeft(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return _secondsOfCoverageLeft(_protocol);   } // Helper function to return seconds of coverage left for a protocol   // Gets the current active balance of the protocol and divides by the premium per second for the protocol   function secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {     uint256 premium = premiums[_protocol];     if (premium == 0) return 0;     return _activeBalance(_protocol) / premium;   } /// @notice View current active balance of covered protocol   /// @param _protocol Protocol identifier   /// @return Active balance   /// @dev Accrued debt is subtracted from the stored active balance   function activeBalance(bytes32 _protocol)     external     view     override     protocolExists(_protocol)     returns (uint256)   {     return _activeBalance(_protocol);   } // Helper function to calc the active balance of a protocol at current time   function _activeBalance(bytes32 _protocol) internal view returns (uint256) {     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     uint256 balance = activeBalances[_protocol];     // The debt should never be higher than the balance (only happens if the arbitrages fail)     if (debt &gt; balance) return 0;     return balance - debt;   } //   // State methods   // /// @notice Helps set the premium per second for an individual protocol   /// @param protocol Protocol identifier   /// @param _premium New premium per second   /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function   function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)     internal     returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)   {     // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers     // Also updates the last accounted timestamp for this protocol     // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings     // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol     nonStakerPercentage = _settleProtocolDebt(_protocol);     // Stores the old premium before it gets updated     oldPremiumPerSecond = premiums[_protocol]; if (oldPremiumPerSecond != _premium) {   // Sets the protocol's premium per second to the new value   premiums_[_protocol] = _premium;   emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium); } // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point // Where arbs would no longer be incentivized to remove the protocol // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems if (_premium != 0 &amp;&amp; _secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_OF_COVERAGE) {   revert InsufficientBalance(_protocol); }  } /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second   /// @param _protocol Protocol identifier   /// @param _premium New premium per second   function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {     // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings     (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(       _protocol,       _premium     );     // Settling the total amount of premiums owed to stakers before a new premium per second gets set     _settleTotalDebt();     // This calculates the new global premium per second that gets paid to stakers     // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function     allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(       oldPremiumPerSecond,       _premium,       nonStakerPercentage,       nonStakerPercentage,       allPremiumsPerSecToStakers     );   } // Internal function to set a new protocolAgent for a specific protocol   // oldAgent is only included as part of emitting an event   function _setProtocolAgent(     bytes32 _protocol,     address _oldAgent,     address _protocolAgent   ) internal {     protocolAgent[_protocol] = _protocolAgent;     emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);   } // Subtracts the accrued debt from a protocol's active balance   // Credits the amount that can be claimed by nonstakers for this protocol   // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings   // Most of this function is dealing with an edge case related to a protocol not being removed by arbs   function settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {     // This calcs the accrued debt of the protocol since it was last updated     uint256 debt = _calcIncrementalProtocolDebt(_protocol);     // This pulls the percentage that is sent to nonstakers     _nonStakerPercentage = nonStakersPercentage[_protocol];     // In case the protocol has accrued debt, this code block will ensure the debt is settled properly     if (debt != 0) {       // Pulls the stored active balance of the protocol       uint256 balance = activeBalances[_protocol];       // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance       // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point       // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage       // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up       if (debt &gt; balance) {         // This error amount represents the magnitude of the mistake         uint256 error = debt - balance;         // Gets the latest value of claimable premiums for stakers         _settleTotalDebt();         // @note to production, set premium first to zero before solving accounting issue.         // otherwise the accounting error keeps increasing         uint256 lastClaimablePremiumsForStakers = lastClaimablePremiumsForStakers;     // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%     uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /       HUNDRED_PERCENT;      // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short     uint256 insufficientTokens;      // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally     // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error     // This first line can be true if claimPremiumsForStakers() has been called and     // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be &gt;0 still     if (claimablePremiumError &gt; lastClaimablePremiumsForStakers_) {       insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;       lastClaimablePremiumsForStakers = 0;     } else {       // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums       // By the amount that was added in error (error) and insufficientTokens = 0       lastClaimablePremiumsForStakers =         lastClaimablePremiumsForStakers_ -         claimablePremiumError;     }      // If two events are thrown, the values need to be summed up for the actual state.     // This means an error of this type will continue until it is handled     emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);     // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case     debt = balance;   }   // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance   activeBalances[_protocol] = balance - debt;   // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol   nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT; } // Updates the last accounted timestamp for this protocol lastAccountedEachProtocol[_protocol] = block.timestamp;  } // Multiplies the total premium per second * number of seconds since the last global accounting update   // And adds it to the total claimable amount for stakers   function _settleTotalDebt() internal {     lastClaimablePremiumsForStakers +=       (block.timestamp - lastAccountedGlobal) *       allPremiumsPerSecToStakers;     lastAccountedGlobal = block.timestamp;   } // Calculates the global premium per second for stakers   // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers   // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones   function _calcGlobalPremiumPerSecForStakers(     uint256 _premiumOld,     uint256 _premiumNew,     uint256 _nonStakerPercentageOld,     uint256 _nonStakerPercentageNew,     uint256 _inMemAllPremiumsPerSecToStakers   ) internal pure returns (uint256) {     return       _inMemAllPremiumsPerSecToStakers +       ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /       HUNDRED_PERCENT -       ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /       HUNDRED_PERCENT;   } // Helper function to remove and clean up a protocol from Sherlock   // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made   function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {     // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol     _setSingleAndGlobalProtocolPremium(_protocol, 0); // Grabs the protocol's active balance uint256 balance = activeBalances[_protocol];  // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent if (balance != 0) {   delete activeBalances[_protocol];   token.safeTransfer(_agent, balance);    emit ProtocolBalanceWithdrawn(_protocol, balance); }  // Sets the protocol agent to zero address (as part of clean up) _setProtocolAgent(_protocol, _agent, address(0));  // Cleans up other mappings for this protocol delete nonStakersPercentage[_protocol]; delete lastAccountedEachProtocol[_protocol]; // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above  // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;  // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked removedProtocolAgent[_protocol] = _agent;  emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0)); emit ProtocolRemoved(_protocol);  } /// @notice Sets the minimum active balance before an arb can remove a protocol   /// @param _minActiveBalance Minimum balance needed (in USDC)   /// @dev Only gov   function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {     // New value cannot be the same as current value     if (minActiveBalance == _minActiveBalance) revert InvalidArgument();     // Can't set a value that is too high to be reasonable     if (_minActiveBalance &gt;= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions(); emit MinBalance(minActiveBalance, _minActiveBalance); minActiveBalance = _minActiveBalance;  } // This function allows the nonstakers role to claim tokens owed to them by a specific protocol   /// @notice Choose an _amount of tokens that nonstakers (_receiver address) will receive from _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens   /// @param _receiver Address to receive tokens   /// @dev Only callable by nonstakers role   function nonStakersClaim(     bytes32 _protocol,     uint256 _amount,     address _receiver   ) external override whenNotPaused {     if (_protocol == bytes32(0)) revert ZeroArgument();     if (_amount == uint256(0)) revert ZeroArgument();     if (_receiver == address(0)) revert ZeroArgument();     // Only the nonstakers role (multisig or contract) can pull the funds     if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized(); // Call can't be executed on protocol that is removed if (protocolAgent_[_protocol] != address(0)) {   // Updates the amount that nonstakers can claim from this protocol   _settleProtocolDebt(_protocol); }  // Sets balance to the amount that is claimable by nonstakers for this specific protocol uint256 balance = nonStakersClaimableByProtocol[_protocol]; // If the amount requested is more than what's owed to nonstakers, revert if (_amount &gt; balance) revert InsufficientBalance(_protocol);  // Sets the claimable amount to whatever is left over after this amount is pulled nonStakersClaimableByProtocol[_protocol] = balance - _amount; // Transfers the amount requested to the `_receiver` address token.safeTransfer(_receiver, _amount);  } // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)   /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address   /// @dev Callable by everyone   /// @dev Funds will be transferred to Sherlock core contract   function claimPremiumsForStakers() external override whenNotPaused {     // Gets address of core Sherlock contract     address sherlock = address(sherlockCore);     // Revert if core Sherlock contract not initialized yet     if (sherlock == address(0)) revert InvalidConditions(); // claimablePremiums is different from _settleTotalDebt() because it does not change state // Retrieves current amount of all premiums that are owed to stakers uint256 amount = claimablePremiums();  // Transfers all the premiums owed to stakers to the Sherlock core contract if (amount != 0) {   // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out   lastClaimablePremiumsForStakers = 0;   lastAccountedGlobal = block.timestamp;   token.safeTransfer(sherlock, amount); }  } // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts   /// @param protocol Protocol identifier   /// @return current and previous are the current and previous coverage amounts for this protocol   // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)   function coverageAmounts(bytes32 _protocol)     external     view     override     returns (uint256 current, uint256 previous)   {     // Checks to see if the protocol has an active protocolAgent (protocol not removed)     // OR checks to see if the removed protocol is still within the claim window     // If so, gives the current and previous coverage, otherwise throws an error     if (       protocolAgent[_protocol] != address(0) ||       block.timestamp &lt;= removedProtocolClaimDeadline[_protocol]     ) {       return (currentCoverage[_protocol], previousCoverage[_protocol]);     } revert ProtocolNotExists(_protocol);  } /// @notice Add a new protocol to Sherlock   /// @param protocol Protocol identifier   /// @param _protocolAgent Address able to submit a claim on behalf of the protocol   /// @param _coverage Hash referencing the active coverage agreement   /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 1018   /// @param _coverageAmount Max amount claimable by this protocol   /// @dev Adding a protocol allows the _protocolAgent to submit a claim   /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point   /// @dev _nonStakers is scaled by 1018   /// @dev Only callable by governance   function protocolAdd(     bytes32 _protocol,     address _protocolAgent,     bytes32 _coverage,     uint256 _nonStakers,     uint256 _coverageAmount   ) external override onlyOwner {     if (_protocol == bytes32(0)) revert ZeroArgument();     if (_protocolAgent == address(0)) revert ZeroArgument();     // Checks to make sure the protocol doesn't exist already     if (protocolAgent[_protocol] != address(0)) revert InvalidConditions(); // Updates the protocol agent and passes in the old agent which is 0 address in this case _setProtocolAgent(_protocol, address(0), _protocolAgent);  // Delete mappings that are potentially non default values // From previous time protocol was added/removed delete removedProtocolClaimDeadline[_protocol]; delete removedProtocolAgent[_protocol]; delete currentCoverage[_protocol]; delete previousCoverage[_protocol];  emit ProtocolAdded(_protocol);  // Most of the logic for actually adding a protocol in this function protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);  } /// @notice Update info regarding a protocol   /// @param _protocol Protocol identifier   /// @param _coverage Hash referencing the active coverage agreement   /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18   /// @param _coverageAmount Max amount claimable by this protocol   /// @dev Only callable by governance   /// @dev _nonStakers can be 0   function protocolUpdate(     bytes32 _protocol,     bytes32 _coverage,     uint256 _nonStakers,     uint256 _coverageAmount   ) public override onlyOwner {     if (_coverage == bytes32(0)) revert ZeroArgument();     if (_nonStakers &gt; HUNDRED_PERCENT) revert InvalidArgument();     if (_coverageAmount == uint256(0)) revert ZeroArgument(); // Checks to make sure the protocol has been assigned a protocol agent _verifyProtocolExists(_protocol);  // Subtracts the accrued debt from a protocol's active balance (if any) // Updates the amount that can be claimed by nonstakers _settleProtocolDebt(_protocol);  // Updates the global claimable amount for stakers _settleTotalDebt();  // Gets the premium per second for this protocol uint256 premium = premiums_[_protocol];  // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be) allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(   premium,   premium,   nonStakersPercentage[_protocol],   _nonStakers,   allPremiumsPerSecToStakers );  // Updates the stored value of percentage of premiums that go to nonstakers nonStakersPercentage[_protocol] = _nonStakers;  // Updates previous coverage and current coverage amounts previousCoverage[_protocol] = currentCoverage[_protocol]; currentCoverage[_protocol] = _coverageAmount;  emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);  } /// @notice Remove a protocol from coverage   /// @param _protocol Protocol identifier   /// @dev Before removing a protocol the premium must be 0   /// @dev Removing a protocol basically stops the _protocolAgent from being active (can still submit claims until claim deadline though)   /// @dev Pays off debt + sends remaining balance to protocol agent   /// @dev This call should be subject to a timelock   /// @dev Only callable by governance   function protocolRemove(bytes32 _protocol) external override onlyOwner {     // checks to make sure the protocol actually has a protocol agent     address agent = _verifyProtocolExists(_protocol); // Removes a protocol from Sherlock and cleans up its data // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made _forceRemoveProtocol(_protocol, agent);  } /// @notice Remove a protocol with insufficient active balance   /// @param _protocol Protocol identifier   // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function   function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {     address agent = _verifyProtocolExists(_protocol); // Gets the latest value of the active balance at this protocol _settleProtocolDebt(_protocol); // Sets latest value of active balance to remainingBalance variable uint256 remainingBalance = activeBalances[_protocol];  // This means the protocol still has adequate active balance and thus cannot be removed if (remainingBalance &gt;= minActiveBalance) revert InvalidConditions();  // Sets the protocol's active balance to 0 delete activeBalances[_protocol]; // Removes the protocol from coverage _forceRemoveProtocol(_protocol, agent);  if (remainingBalance != 0) {   // sends the remaining balance to msg.sender   token.safeTransfer(msg.sender, remainingBalance); } emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);  } /// @notice Calculate if arb is possible and what the reward would be   /// @param _protocol Protocol identifier   /// @return arbAmount Amount reward for arbing   /// @return able Indicator if arb call is even possible   /// @dev Doesn't subtract the current protocol debt from the active balance   function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)     internal     view     returns (uint256 arbAmount, bool able)   {     uint256 secondsLeft = _secondsOfCoverageLeft(_protocol); // If arb is not possible return false if (secondsLeft &gt;= MIN_SECONDS_OF_COVERAGE) return (0, false);  // This percentage scales over time // Reaches 100% on 0 seconds of coverage left uint256 percentageScaled = HUNDRED_PERCENT -   (secondsLeft * HUNDRED_PERCENT) /   MIN_SECONDS_OF_COVERAGE;  able = true; arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;  } /// @notice Removes a protocol with insufficent seconds of coverage left   /// @param _protocol Protocol identifier   // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second   function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {     // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings     address agent = _verifyProtocolExists(_protocol); // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance() // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance() // But when removing based on seconds of coverage left, the remainingBalance could still be quite large // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%) _settleProtocolDebt(_protocol); (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol); if (able == false) revert InvalidConditions();  if (arbAmount != 0) {   // subtracts the amount that will be paid to the arb from the active balance   activeBalances[_protocol] -= arbAmount; }  // Removes the protocol from coverage // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above _forceRemoveProtocol(_protocol, agent);  // Done after removing protocol to mitigate reentrency pattern // (In case token allows callback) if (arbAmount != 0) {   token.safeTransfer(msg.sender, arbAmount); } emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);  } /// @notice Set premium of _protocol to _premium   /// @param _protocol Protocol identifier   /// @param _premium Amount of premium _protocol pays per second   /// @dev The value 0 would mean inactive coverage   /// @dev Only callable by governance   function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {     // Checks to see if protocol has a protocol agent     _verifyProtocolExists(_protocol); // Updates individual protocol's premium and allPremiumsPerSecToStakers _setSingleAndGlobalProtocolPremium(_protocol, _premium);  } /// @notice Set premium of multiple protocols   /// @param _protocol Array of protocol identifiers   /// @param _premium Array of premium amounts protocols pay per second   /// @dev The value 0 would mean inactive coverage   /// @dev Only callable by governance   function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)     external     override     onlyOwner   {     // Checks to make sure there are an equal amount of entries in each array     if (_protocol.length != _premium.length) revert UnequalArrayLength();     if (_protocol.length == 0) revert InvalidArgument(); // Updates the global claimable amount for stakers _settleTotalDebt();  uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;  // Loops through the array of protocols and checks to make sure each has a protocol agent assigned for (uint256 i; i &lt; _protocol.length; i++) {   _verifyProtocolExists(_protocol[i]);    // Sets the protocol premium for that specific protocol   // Function returns the old premium and nonStakerPercentage for that specific protocol   (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(     _protocol[i],     _premium[i]   );    // Calculates the new global premium which adds up all premiums paid by all protocols   allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(     oldPremiumPerSecond,     _premium[i],     nonStakerPercentage,     nonStakerPercentage,     allPremiumsPerSecToStakers_   ); }  // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;  } // This is how protocols pay for coverage by increasing their active balance   /// @notice Deposits _amount of token to the active balance of _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens to deposit   /// @dev Approval should be made before calling   function depositToActiveBalance(bytes32 _protocol, uint256 _amount)     external     override     whenNotPaused   {     if (_amount == uint256(0)) revert ZeroArgument();     _verifyProtocolExists(_protocol); // Transfers _amount to this contract token.safeTransferFrom(msg.sender, address(this), _amount); // Increases the active balance of the protocol by _amount activeBalances[_protocol] += _amount;  emit ProtocolBalanceDeposited(_protocol, _amount);  } // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)   // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)   /// @notice Withdraws _amount of token from the active balance of _protocol   /// @param _protocol Protocol identifier   /// @param _amount Amount of tokens to withdraw   /// @dev Only protocol agent is able to withdraw   /// @dev Balance can be withdrawn up until 7 days worth of active balance   function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)     external     override     whenNotPaused   {     if (_amount == uint256(0)) revert ZeroArgument();     // Only the protocol agent can call this function     if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized(); // Updates the active balance of the protocol _settleProtocolDebt(_protocol);  // Sets currentBalance to the active balance of the protocol uint256 currentBalance = activeBalances[_protocol]; // Reverts if trying to withdraw more than the active balance if (_amount &gt; currentBalance) revert InsufficientBalance(_protocol);  // Removes the _amount to be withdrawn from the active balance activeBalances[_protocol] = currentBalance - _amount; // Reverts if a protocol has less than 7 days worth of active balance left if (_secondsOfCoverageLeft(_protocol) &lt; MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);  // Transfers the amount to the msg.sender (protocol agent) token.safeTransfer(msg.sender, _amount); emit ProtocolBalanceWithdrawn(_protocol, _amount);  } /// @notice Transfer protocol agent role   /// @param _protocol Protocol identifier   /// @param _protocolAgent Account able to submit a claim on behalf of the protocol   /// @dev Only the active protocolAgent is able to transfer the role   function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)     external     override     whenNotPaused   {     if (_protocolAgent == address(0)) revert ZeroArgument();     // Can't set the new protocol agent to the caller address     if (msg.sender == _protocolAgent) revert InvalidArgument();     // Because the caller must be the current protocol agent     if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized(); // Sets the protocol agent to the new address _setProtocolAgent(_protocol, msg.sender, _protocolAgent);  } /// @notice Function used to check if this is the current active protocol manager   /// @return Boolean indicating it's active   /// @dev If inactive the owner can pull all ERC20s and ETH   /// @dev Will be checked by calling the sherlock contract   function isActive() public view returns (bool) {     return address(sherlockCore.sherlockProtocolManager()) == address(this);   } // Only contract owner can call this   // Sends all specified tokens in this contract to the receiver's address (as well as ETH)   function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {     if (_receiver == address(0)) revert ZeroArgument();     // This contract must NOT be the current assigned protocol manager contract     if (isActive()) revert InvalidConditions();     // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH     _sweep(_receiver, _extraTokens);   } } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-25-08 10:59:38 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import './Manager.sol';
import '../interfaces/managers/ISherlockProtocolManager.sol';

/// @title Sherlock core interface for protocols
/// @author Evert Kors
// This is the contract that manages covered protocols

contract SherlockProtocolManager is ISherlockProtocolManager, Manager {
  using SafeERC20 for IERC20;

  // Represents the token that protocols pay with (currently USDC)
  IERC20 public immutable token;

  // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed
  uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc

  // A removed protocol is still able to make a claim for this amount of time after its removal
  uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days;

  // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance
  uint256 public constant MIN_SECONDS_LEFT = 7 days;

  // Convenient for percentage calculations
  uint256 internal constant HUNDRED_PERCENT = 10**18;

  // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage
  // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying
  uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours;

  // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)
  mapping(bytes32 => address) internal protocolAgent_;

  // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)
  mapping(bytes32 => uint256) internal nonStakersPercentage;

  // The premium per second paid by each protocol is stored in this mapping
  mapping(bytes32 => uint256) internal premiums_;

  // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.
  // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not
  mapping(bytes32 => uint256) internal activeBalances;

  // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol
  mapping(bytes32 => uint256) internal lastAccountedEachProtocol;

  // The amount that can be claimed by nonstakers for each protocol
  // We need this value so we can track how much payment is coming from each protocol
  mapping(bytes32 => uint256) internal nonStakersClaimableByProtocol;

  // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)
  uint256 internal lastAccountedGlobal;

  // This is the total amount of premiums paid (per second) by all the covered protocols (added up)
  uint256 internal allPremiumsPerSecToStakers;

  // This is the amount that was claimable by stakers the last time the accounting was run
  // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date
  uint256 internal lastClaimablePremiumsForStakers;

  // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage
  // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)
  uint256 public override minActiveBalance;

  // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)
  mapping(bytes32 => uint256) internal removedProtocolClaimDeadline;

  // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)
  mapping(bytes32 => address) internal removedProtocolAgent;

  // Current amount of coverage (i.e. 20M USDC) for a protocol
  mapping(bytes32 => uint256) internal currentCoverage;

  // Previous amount of coverage for a protocol
  // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount
  mapping(bytes32 => uint256) internal previousCoverage;

  // Setting the token to USDC
  constructor(IERC20 _token) {
    if (address(_token) == address(0)) revert ZeroArgument();
    token = _token;
  }

  // Modifier used to ensure a protocol exists (has been instantiated and not removed)
  modifier protocolExists(bytes32 _protocol) {
    _verifyProtocolExists(_protocol);
    _;
  }

  /// @notice View current protocolAgent of `_protocol`
  /// @param _protocol Protocol identifier
  /// @return Address able to submit claims
  function protocolAgent(bytes32 _protocol) external view override returns (address) {
    address agent = protocolAgent_[_protocol];
    if (agent != address(0)) return agent;

    // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned
    // Note: Old protocol agent will never be address(0)
    if (block.timestamp <= removedProtocolClaimDeadline[_protocol]) {
      return removedProtocolAgent[_protocol];
    }

    // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned
    revert ProtocolNotExists(_protocol);
  }

  // Checks if the protocol exists, then returns the current premium per second being charged
  /// @notice View current premium of protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of premium `_protocol` pays per second
  function premium(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return premiums_[_protocol];
  }

  // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)
  // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)
  function _verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {
    _protocolAgent = protocolAgent_[_protocol];
    if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);
  }

  //
  // View methods
  //

  // Calcs the debt accrued by the protocol since it last had an accounting update
  // This is the amount that needs to be removed from a protocol's active balance
  function _calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {
    return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums_[_protocol];
  }

  /// @notice View the amount nonstakers can claim from this protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of tokens claimable by nonstakers
  /// @dev this reads from a storage variable + (now-lastsettled) * premiums
  // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]
  // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed
  function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {
    // Calcs the debt of a protocol since the last accounting update
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // Gets the active balance of the protocol
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) debt = balance;

    // Adds the incremental claimable amount owed to nonstakers to the total claimable amount
    return
      nonStakersClaimableByProtocol[_protocol] +
      (nonStakersPercentage[_protocol] * debt) /
      HUNDRED_PERCENT;
  }

  /// @notice View current amount of all premiums that are owed to stakers
  /// @return Premiums claimable
  /// @dev Will increase every block
  /// @dev base + (now - last_settled) * ps
  function claimablePremiums() public view override returns (uint256) {
    // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)
    return
      lastClaimablePremiumsForStakers +
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
  }

  /// @notice View seconds of coverage left for `_protocol` before it runs out of active balance
  /// @param _protocol Protocol identifier
  /// @return Seconds of coverage left
  function secondsOfCoverageLeft(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _secondsOfCoverageLeft(_protocol);
  }

  // Helper function to return seconds of coverage left for a protocol
  // Gets the current active balance of the protocol and divides by the premium per second for the protocol
  function _secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {
    uint256 premium = premiums_[_protocol];
    if (premium == 0) return 0;
    return _activeBalance(_protocol) / premium;
  }

  /// @notice View current active balance of covered protocol
  /// @param _protocol Protocol identifier
  /// @return Active balance
  /// @dev Accrued debt is subtracted from the stored active balance
  function activeBalance(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _activeBalance(_protocol);
  }

  // Helper function to calc the active balance of a protocol at current time
  function _activeBalance(bytes32 _protocol) internal view returns (uint256) {
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) return 0;
    return balance - debt;
  }

  //
  // State methods
  //

  /// @notice Helps set the premium per second for an individual protocol
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function
  function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)
    internal
    returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)
  {
    // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers
    // Also updates the last accounted timestamp for this protocol
    // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings
    // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol
    nonStakerPercentage = _settleProtocolDebt(_protocol);
    // Stores the old premium before it gets updated
    oldPremiumPerSecond = premiums_[_protocol];

    if (oldPremiumPerSecond != _premium) {
      // Sets the protocol's premium per second to the new value
      premiums_[_protocol] = _premium;
      emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium);
    }
    // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing
    // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes
    // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point
    // Where arbs would no longer be incentivized to remove the protocol
    // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems
    if (_premium != 0 && _secondsOfCoverageLeft(_protocol) < MIN_SECONDS_OF_COVERAGE) {
      revert InsufficientBalance(_protocol);
    }
  }

  /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {
    // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings
    (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
      _protocol,
      _premium
    );
    // Settling the total amount of premiums owed to stakers before a new premium per second gets set
    _settleTotalDebt();
    // This calculates the new global premium per second that gets paid to stakers
    // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      oldPremiumPerSecond,
      _premium,
      nonStakerPercentage,
      nonStakerPercentage,
      allPremiumsPerSecToStakers
    );
  }

  // Internal function to set a new protocolAgent for a specific protocol
  // _oldAgent is only included as part of emitting an event
  function _setProtocolAgent(
    bytes32 _protocol,
    address _oldAgent,
    address _protocolAgent
  ) internal {
    protocolAgent_[_protocol] = _protocolAgent;
    emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);
  }

  // Subtracts the accrued debt from a protocol's active balance
  // Credits the amount that can be claimed by nonstakers for this protocol
  // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings
  // Most of this function is dealing with an edge case related to a protocol not being removed by arbs
  function _settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {
    // This calcs the accrued debt of the protocol since it was last updated
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // This pulls the percentage that is sent to nonstakers
    _nonStakerPercentage = nonStakersPercentage[_protocol];
    // In case the protocol has accrued debt, this code block will ensure the debt is settled properly
    if (debt != 0) {
      // Pulls the stored active balance of the protocol
      uint256 balance = activeBalances[_protocol];
      // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance
      // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point
      // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage
      // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up
      if (debt > balance) {
        // This error amount represents the magnitude of the mistake
        uint256 error = debt - balance;
        // Gets the latest value of claimable premiums for stakers
        _settleTotalDebt();
        // @note to production, set premium first to zero before solving accounting issue.
        // otherwise the accounting error keeps increasing
        uint256 lastClaimablePremiumsForStakers_ = lastClaimablePremiumsForStakers;

        // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%
        uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /
          HUNDRED_PERCENT;

        // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short
        uint256 insufficientTokens;

        // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally
        // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error
        // This first line can be true if claimPremiumsForStakers() has been called and
        // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be >0 still
        if (claimablePremiumError > lastClaimablePremiumsForStakers_) {
          insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;
          lastClaimablePremiumsForStakers = 0;
        } else {
          // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums
          // By the amount that was added in error (error) and insufficientTokens = 0
          lastClaimablePremiumsForStakers =
            lastClaimablePremiumsForStakers_ -
            claimablePremiumError;
        }

        // If two events are thrown, the values need to be summed up for the actual state.
        // This means an error of this type will continue until it is handled
        emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);
        // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case
        debt = balance;
      }
      // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance
      activeBalances[_protocol] = balance - debt;
      // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol
      nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT;
    }
    // Updates the last accounted timestamp for this protocol
    lastAccountedEachProtocol[_protocol] = block.timestamp;
  }

  // Multiplies the total premium per second * number of seconds since the last global accounting update
  // And adds it to the total claimable amount for stakers
  function _settleTotalDebt() internal {
    lastClaimablePremiumsForStakers +=
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
    lastAccountedGlobal = block.timestamp;
  }

  // Calculates the global premium per second for stakers
  // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers
  // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones
  function _calcGlobalPremiumPerSecForStakers(
    uint256 _premiumOld,
    uint256 _premiumNew,
    uint256 _nonStakerPercentageOld,
    uint256 _nonStakerPercentageNew,
    uint256 _inMemAllPremiumsPerSecToStakers
  ) internal pure returns (uint256) {
    return
      _inMemAllPremiumsPerSecToStakers +
      ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /
      HUNDRED_PERCENT -
      ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /
      HUNDRED_PERCENT;
  }

  // Helper function to remove and clean up a protocol from Sherlock
  // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made
  function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {
    // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol
    _setSingleAndGlobalProtocolPremium(_protocol, 0);

    // Grabs the protocol's active balance
    uint256 balance = activeBalances[_protocol];

    // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent
    if (balance != 0) {
      delete activeBalances[_protocol];
      token.safeTransfer(_agent, balance);

      emit ProtocolBalanceWithdrawn(_protocol, balance);
    }

    // Sets the protocol agent to zero address (as part of clean up)
    _setProtocolAgent(_protocol, _agent, address(0));

    // Cleans up other mappings for this protocol
    delete nonStakersPercentage[_protocol];
    delete lastAccountedEachProtocol[_protocol];
    // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above

    // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol
    removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;

    // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed
    // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked
    removedProtocolAgent[_protocol] = _agent;

    emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0));
    emit ProtocolRemoved(_protocol);
  }

  /// @notice Sets the minimum active balance before an arb can remove a protocol
  /// @param _minActiveBalance Minimum balance needed (in USDC)
  /// @dev Only gov
  function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {
    // New value cannot be the same as current value
    if (minActiveBalance == _minActiveBalance) revert InvalidArgument();
    // Can't set a value that is too high to be reasonable
    if (_minActiveBalance >= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions();

    emit MinBalance(minActiveBalance, _minActiveBalance);
    minActiveBalance = _minActiveBalance;
  }

  // This function allows the nonstakers role to claim tokens owed to them by a specific protocol
  /// @notice Choose an `_amount` of tokens that nonstakers (`_receiver` address) will receive from `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens
  /// @param _receiver Address to receive tokens
  /// @dev Only callable by nonstakers role
  function nonStakersClaim(
    bytes32 _protocol,
    uint256 _amount,
    address _receiver
  ) external override whenNotPaused {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_amount == uint256(0)) revert ZeroArgument();
    if (_receiver == address(0)) revert ZeroArgument();
    // Only the nonstakers role (multisig or contract) can pull the funds
    if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized();

    // Call can't be executed on protocol that is removed
    if (protocolAgent_[_protocol] != address(0)) {
      // Updates the amount that nonstakers can claim from this protocol
      _settleProtocolDebt(_protocol);
    }

    // Sets balance to the amount that is claimable by nonstakers for this specific protocol
    uint256 balance = nonStakersClaimableByProtocol[_protocol];
    // If the amount requested is more than what's owed to nonstakers, revert
    if (_amount > balance) revert InsufficientBalance(_protocol);

    // Sets the claimable amount to whatever is left over after this amount is pulled
    nonStakersClaimableByProtocol[_protocol] = balance - _amount;
    // Transfers the amount requested to the `_receiver` address
    token.safeTransfer(_receiver, _amount);
  }

  // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)
  /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address
  /// @dev Callable by everyone
  /// @dev Funds will be transferred to Sherlock core contract
  function claimPremiumsForStakers() external override whenNotPaused {
    // Gets address of core Sherlock contract
    address sherlock = address(sherlockCore);
    // Revert if core Sherlock contract not initialized yet
    if (sherlock == address(0)) revert InvalidConditions();

    // claimablePremiums is different from _settleTotalDebt() because it does not change state
    // Retrieves current amount of all premiums that are owed to stakers
    uint256 amount = claimablePremiums();

    // Transfers all the premiums owed to stakers to the Sherlock core contract
    if (amount != 0) {
      // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out
      lastClaimablePremiumsForStakers = 0;
      lastAccountedGlobal = block.timestamp;
      token.safeTransfer(sherlock, amount);
    }
  }

  // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts
  /// @param _protocol Protocol identifier
  /// @return current and previous are the current and previous coverage amounts for this protocol
  // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)
  function coverageAmounts(bytes32 _protocol)
    external
    view
    override
    returns (uint256 current, uint256 previous)
  {
    // Checks to see if the protocol has an active protocolAgent (protocol not removed)
    // OR checks to see if the removed protocol is still within the claim window
    // If so, gives the current and previous coverage, otherwise throws an error
    if (
      protocolAgent_[_protocol] != address(0) ||
      block.timestamp <= removedProtocolClaimDeadline[_protocol]
    ) {
      return (currentCoverage[_protocol], previousCoverage[_protocol]);
    }

    revert ProtocolNotExists(_protocol);
  }

  /// @notice Add a new protocol to Sherlock
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Address able to submit a claim on behalf of the protocol
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Adding a protocol allows the `_protocolAgent` to submit a claim
  /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point
  /// @dev `_nonStakers` is scaled by 10**18
  /// @dev Only callable by governance
  function protocolAdd(
    bytes32 _protocol,
    address _protocolAgent,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) external override onlyOwner {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Checks to make sure the protocol doesn't exist already
    if (protocolAgent_[_protocol] != address(0)) revert InvalidConditions();

    // Updates the protocol agent and passes in the old agent which is 0 address in this case
    _setProtocolAgent(_protocol, address(0), _protocolAgent);

    // Delete mappings that are potentially non default values
    // From previous time protocol was added/removed
    delete removedProtocolClaimDeadline[_protocol];
    delete removedProtocolAgent[_protocol];
    delete currentCoverage[_protocol];
    delete previousCoverage[_protocol];

    emit ProtocolAdded(_protocol);

    // Most of the logic for actually adding a protocol in this function
    protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Update info regarding a protocol
  /// @param _protocol Protocol identifier
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Only callable by governance
  /// @dev `_nonStakers` can be 0
  function protocolUpdate(
    bytes32 _protocol,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) public override onlyOwner {
    if (_coverage == bytes32(0)) revert ZeroArgument();
    if (_nonStakers > HUNDRED_PERCENT) revert InvalidArgument();
    if (_coverageAmount == uint256(0)) revert ZeroArgument();

    // Checks to make sure the protocol has been assigned a protocol agent
    _verifyProtocolExists(_protocol);

    // Subtracts the accrued debt from a protocol's active balance (if any)
    // Updates the amount that can be claimed by nonstakers
    _settleProtocolDebt(_protocol);

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    // Gets the premium per second for this protocol
    uint256 premium = premiums_[_protocol];

    // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be)
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      premium,
      premium,
      nonStakersPercentage[_protocol],
      _nonStakers,
      allPremiumsPerSecToStakers
    );

    // Updates the stored value of percentage of premiums that go to nonstakers
    nonStakersPercentage[_protocol] = _nonStakers;

    // Updates previous coverage and current coverage amounts
    previousCoverage[_protocol] = currentCoverage[_protocol];
    currentCoverage[_protocol] = _coverageAmount;

    emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Remove a protocol from coverage
  /// @param _protocol Protocol identifier
  /// @dev Before removing a protocol the premium must be 0
  /// @dev Removing a protocol basically stops the `_protocolAgent` from being active (can still submit claims until claim deadline though)
  /// @dev Pays off debt + sends remaining balance to protocol agent
  /// @dev This call should be subject to a timelock
  /// @dev Only callable by governance
  function protocolRemove(bytes32 _protocol) external override onlyOwner {
    // checks to make sure the protocol actually has a protocol agent
    address agent = _verifyProtocolExists(_protocol);

    // Removes a protocol from Sherlock and cleans up its data
    // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made
    _forceRemoveProtocol(_protocol, agent);
  }

  /// @notice Remove a protocol with insufficient active balance
  /// @param _protocol Protocol identifier
  // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function
  function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {
    address agent = _verifyProtocolExists(_protocol);

    // Gets the latest value of the active balance at this protocol
    _settleProtocolDebt(_protocol);
    // Sets latest value of active balance to remainingBalance variable
    uint256 remainingBalance = activeBalances[_protocol];

    // This means the protocol still has adequate active balance and thus cannot be removed
    if (remainingBalance >= minActiveBalance) revert InvalidConditions();

    // Sets the protocol's active balance to 0
    delete activeBalances[_protocol];
    // Removes the protocol from coverage
    _forceRemoveProtocol(_protocol, agent);

    if (remainingBalance != 0) {
      // sends the remaining balance to msg.sender
      token.safeTransfer(msg.sender, remainingBalance);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);
  }

  /// @notice Calculate if arb is possible and what the reward would be
  /// @param _protocol Protocol identifier
  /// @return arbAmount Amount reward for arbing
  /// @return able Indicator if arb call is even possible
  /// @dev Doesn't subtract the current protocol debt from the active balance
  function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)
    internal
    view
    returns (uint256 arbAmount, bool able)
  {
    uint256 secondsLeft = _secondsOfCoverageLeft(_protocol);

    // If arb is not possible return false
    if (secondsLeft >= MIN_SECONDS_OF_COVERAGE) return (0, false);

    // This percentage scales over time
    // Reaches 100% on 0 seconds of coverage left
    uint256 percentageScaled = HUNDRED_PERCENT -
      (secondsLeft * HUNDRED_PERCENT) /
      MIN_SECONDS_OF_COVERAGE;

    able = true;
    arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;
  }

  /// @notice Removes a protocol with insufficent seconds of coverage left
  /// @param _protocol Protocol identifier
  // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second
  function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {
    // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings
    address agent = _verifyProtocolExists(_protocol);

    // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance()
    // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance()
    // But when removing based on seconds of coverage left, the remainingBalance could still be quite large
    // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance
    // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%)
    _settleProtocolDebt(_protocol);
    (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol);
    if (able == false) revert InvalidConditions();

    if (arbAmount != 0) {
      // subtracts the amount that will be paid to the arb from the active balance
      activeBalances[_protocol] -= arbAmount;
    }

    // Removes the protocol from coverage
    // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above
    _forceRemoveProtocol(_protocol, agent);

    // Done after removing protocol to mitigate reentrency pattern
    // (In case token allows callback)
    if (arbAmount != 0) {
      token.safeTransfer(msg.sender, arbAmount);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);
  }

  /// @notice Set premium of `_protocol` to `_premium`
  /// @param _protocol Protocol identifier
  /// @param _premium Amount of premium `_protocol` pays per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {
    // Checks to see if protocol has a protocol agent
    _verifyProtocolExists(_protocol);

    // Updates individual protocol's premium and allPremiumsPerSecToStakers
    _setSingleAndGlobalProtocolPremium(_protocol, _premium);
  }

  /// @notice Set premium of multiple protocols
  /// @param _protocol Array of protocol identifiers
  /// @param _premium Array of premium amounts protocols pay per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)
    external
    override
    onlyOwner
  {
    // Checks to make sure there are an equal amount of entries in each array
    if (_protocol.length != _premium.length) revert UnequalArrayLength();
    if (_protocol.length == 0) revert InvalidArgument();

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;

    // Loops through the array of protocols and checks to make sure each has a protocol agent assigned
    for (uint256 i; i < _protocol.length; i++) {
      _verifyProtocolExists(_protocol[i]);

      // Sets the protocol premium for that specific protocol
      // Function returns the old premium and nonStakerPercentage for that specific protocol
      (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
        _protocol[i],
        _premium[i]
      );

      // Calculates the new global premium which adds up all premiums paid by all protocols
      allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(
        oldPremiumPerSecond,
        _premium[i],
        nonStakerPercentage,
        nonStakerPercentage,
        allPremiumsPerSecToStakers_
      );
    }

    // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value
    allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;
  }

  // This is how protocols pay for coverage by increasing their active balance
  /// @notice Deposits `_amount` of token to the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to deposit
  /// @dev Approval should be made before calling
  function depositToActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    _verifyProtocolExists(_protocol);

    // Transfers _amount to this contract
    token.safeTransferFrom(msg.sender, address(this), _amount);
    // Increases the active balance of the protocol by _amount
    activeBalances[_protocol] += _amount;

    emit ProtocolBalanceDeposited(_protocol, _amount);
  }

  // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)
  // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)
  /// @notice Withdraws `_amount` of token from the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to withdraw
  /// @dev Only protocol agent is able to withdraw
  /// @dev Balance can be withdrawn up until 7 days worth of active balance
  function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    // Only the protocol agent can call this function
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Updates the active balance of the protocol
    _settleProtocolDebt(_protocol);

    // Sets currentBalance to the active balance of the protocol
    uint256 currentBalance = activeBalances[_protocol];
    // Reverts if trying to withdraw more than the active balance
    if (_amount > currentBalance) revert InsufficientBalance(_protocol);

    // Removes the _amount to be withdrawn from the active balance
    activeBalances[_protocol] = currentBalance - _amount;
    // Reverts if a protocol has less than 7 days worth of active balance left
    if (_secondsOfCoverageLeft(_protocol) < MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);

    // Transfers the amount to the msg.sender (protocol agent)
    token.safeTransfer(msg.sender, _amount);
    emit ProtocolBalanceWithdrawn(_protocol, _amount);
  }

  /// @notice Transfer protocol agent role
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Account able to submit a claim on behalf of the protocol
  /// @dev Only the active protocolAgent is able to transfer the role
  function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)
    external
    override
    whenNotPaused
  {
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Can't set the new protocol agent to the caller address
    if (msg.sender == _protocolAgent) revert InvalidArgument();
    // Because the caller must be the current protocol agent
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Sets the protocol agent to the new address
    _setProtocolAgent(_protocol, msg.sender, _protocolAgent);
  }

  /// @notice Function used to check if this is the current active protocol manager
  /// @return Boolean indicating it's active
  /// @dev If inactive the owner can pull all ERC20s and ETH
  /// @dev Will be checked by calling the sherlock contract
  function isActive() public view returns (bool) {
    return address(sherlockCore.sherlockProtocolManager()) == address(this);
  }

  // Only contract owner can call this
  // Sends all specified tokens in this contract to the receiver's address (as well as ETH)
  function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {
    if (_receiver == address(0)) revert ZeroArgument();
    // This contract must NOT be the current assigned protocol manager contract
    if (isActive()) revert InvalidConditions();
    // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH
    _sweep(_receiver, _extraTokens);
  }
}
.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import './Manager.sol';
import '../interfaces/managers/ISherlockProtocolManager.sol';

/// @title Sherlock core interface for protocols
/// @author Evert Kors
// This is the contract that manages covered protocols

contract SherlockProtocolManager is ISherlockProtocolManager, Manager {
  using SafeERC20 for IERC20;

  // Represents the token that protocols pay with (currently USDC)
  IERC20 public immutable token;

  // This is the ceiling value that can be set for the threshold (based on USDC balance) at which a protocol can get removed
  uint256 public constant MIN_BALANCE_SANITY_CEILING = 30_000 * 10**6; // 30k usdc

  // A removed protocol is still able to make a claim for this amount of time after its removal
  uint256 public constant PROTOCOL_CLAIM_DEADLINE = 7 days;

  // This is the amount that cannot be withdrawn (measured in seconds of payment) if a protocol wants to remove active balance
  uint256 public constant MIN_SECONDS_LEFT = 7 days;

  // Convenient for percentage calculations
  uint256 internal constant HUNDRED_PERCENT = 10**18;

  // The minimum active "seconds of coverage left" a protocol must have before arbitragers can remove the protocol from coverage
  // This value is calculated from a protocol's active balance divided by the premium per second the protocol is paying
  uint256 public constant MIN_SECONDS_OF_COVERAGE = 12 hours;

  // This is an address that is controlled by a covered protocol (maybe its a multisig used by that protocol, etc.)
  mapping(bytes32 => address) internal protocolAgent_;

  // The percentage of premiums that is NOT sent to stakers (set aside for security experts, reinsurance partners, etc.)
  mapping(bytes32 => uint256) internal nonStakersPercentage;

  // The premium per second paid by each protocol is stored in this mapping
  mapping(bytes32 => uint256) internal premiums_;

  // Each protocol should keep an active balance (in USDC) which is drawn against to pay stakers, nonstakers, etc.
  // This "active balance" is really just an accounting concept, doesn't mean tokens have been transferred or not
  mapping(bytes32 => uint256) internal activeBalances;

  // The timestamp at which Sherlock last ran this internal accounting (on the active balance) for each protocol
  mapping(bytes32 => uint256) internal lastAccountedEachProtocol;

  // The amount that can be claimed by nonstakers for each protocol
  // We need this value so we can track how much payment is coming from each protocol
  mapping(bytes32 => uint256) internal nonStakersClaimableByProtocol;

  // The last time where the global accounting was run (to calc allPremiumsPerSecToStakers below)
  uint256 internal lastAccountedGlobal;

  // This is the total amount of premiums paid (per second) by all the covered protocols (added up)
  uint256 internal allPremiumsPerSecToStakers;

  // This is the amount that was claimable by stakers the last time the accounting was run
  // The claimable amount presumably changes every second so this value is marked "last" because it is usually out-of-date
  uint256 internal lastClaimablePremiumsForStakers;

  // The minimum active balance (measured in USDC) a protocol must keep before arbitragers can remove the protocol from coverage
  // This is one of two criteria a protocol must meet in order to avoid removal (the other is MIN_SECONDS_OF_COVERAGE)
  uint256 public override minActiveBalance;

  // Removed protocols can still make a claim up until this timestamp (will be 10 days or something)
  mapping(bytes32 => uint256) internal removedProtocolClaimDeadline;

  // Mapping to store the protocolAgents for removed protocols (useful for claims made by a removed protocol)
  mapping(bytes32 => address) internal removedProtocolAgent;

  // Current amount of coverage (i.e. 20M USDC) for a protocol
  mapping(bytes32 => uint256) internal currentCoverage;

  // Previous amount of coverage for a protocol
  // Previous is also tracked in case a protocol lowers their coverage amount but still needs to make a claim on the old, higher amount
  mapping(bytes32 => uint256) internal previousCoverage;

  // Setting the token to USDC
  constructor(IERC20 _token) {
    if (address(_token) == address(0)) revert ZeroArgument();
    token = _token;
  }

  // Modifier used to ensure a protocol exists (has been instantiated and not removed)
  modifier protocolExists(bytes32 _protocol) {
    _verifyProtocolExists(_protocol);
    _;
  }

  /// @notice View current protocolAgent of `_protocol`
  /// @param _protocol Protocol identifier
  /// @return Address able to submit claims
  function protocolAgent(bytes32 _protocol) external view override returns (address) {
    address agent = protocolAgent_[_protocol];
    if (agent != address(0)) return agent;

    // If a protocol has been removed but is still within the claim deadline, the protocolAgent is returned
    // Note: Old protocol agent will never be address(0)
    if (block.timestamp <= removedProtocolClaimDeadline[_protocol]) {
      return removedProtocolAgent[_protocol];
    }

    // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned
    revert ProtocolNotExists(_protocol);
  }

  // Checks if the protocol exists, then returns the current premium per second being charged
  /// @notice View current premium of protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of premium `_protocol` pays per second
  function premium(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return premiums_[_protocol];
  }

  // Checks to see if a protocol has a protocolAgent assigned to it (we use this to check if a protocol exists)
  // If a protocol has been removed, it will throw an error here no matter what (even if still within claim window)
  function _verifyProtocolExists(bytes32 _protocol) internal view returns (address _protocolAgent) {
    _protocolAgent = protocolAgent_[_protocol];
    if (_protocolAgent == address(0)) revert ProtocolNotExists(_protocol);
  }

  //
  // View methods
  //

  // Calcs the debt accrued by the protocol since it last had an accounting update
  // This is the amount that needs to be removed from a protocol's active balance
  function _calcIncrementalProtocolDebt(bytes32 _protocol) internal view returns (uint256) {
    return (block.timestamp - lastAccountedEachProtocol[_protocol]) * premiums_[_protocol];
  }

  /// @notice View the amount nonstakers can claim from this protocol
  /// @param _protocol Protocol identifier
  /// @return Amount of tokens claimable by nonstakers
  /// @dev this reads from a storage variable + (now-lastsettled) * premiums
  // Note: This function works even for removed protocols because of nonStakersClaimableByProtocol[_protocol]
  // When a protocol gets removed, nonStakersClaimableByProtocol[_protocol] is updated and then doesn't change since the protocol has been removed
  function nonStakersClaimable(bytes32 _protocol) external view override returns (uint256) {
    // Calcs the debt of a protocol since the last accounting update
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // Gets the active balance of the protocol
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) debt = balance;

    // Adds the incremental claimable amount owed to nonstakers to the total claimable amount
    return
      nonStakersClaimableByProtocol[_protocol] +
      (nonStakersPercentage[_protocol] * debt) /
      HUNDRED_PERCENT;
  }

  /// @notice View current amount of all premiums that are owed to stakers
  /// @return Premiums claimable
  /// @dev Will increase every block
  /// @dev base + (now - last_settled) * ps
  function claimablePremiums() public view override returns (uint256) {
    // Takes last balance and adds (number of seconds since last accounting update * total premiums per second)
    return
      lastClaimablePremiumsForStakers +
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
  }

  /// @notice View seconds of coverage left for `_protocol` before it runs out of active balance
  /// @param _protocol Protocol identifier
  /// @return Seconds of coverage left
  function secondsOfCoverageLeft(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _secondsOfCoverageLeft(_protocol);
  }

  // Helper function to return seconds of coverage left for a protocol
  // Gets the current active balance of the protocol and divides by the premium per second for the protocol
  function _secondsOfCoverageLeft(bytes32 _protocol) internal view returns (uint256) {
    uint256 premium = premiums_[_protocol];
    if (premium == 0) return 0;
    return _activeBalance(_protocol) / premium;
  }

  /// @notice View current active balance of covered protocol
  /// @param _protocol Protocol identifier
  /// @return Active balance
  /// @dev Accrued debt is subtracted from the stored active balance
  function activeBalance(bytes32 _protocol)
    external
    view
    override
    protocolExists(_protocol)
    returns (uint256)
  {
    return _activeBalance(_protocol);
  }

  // Helper function to calc the active balance of a protocol at current time
  function _activeBalance(bytes32 _protocol) internal view returns (uint256) {
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    uint256 balance = activeBalances[_protocol];
    // The debt should never be higher than the balance (only happens if the arbitrages fail)
    if (debt > balance) return 0;
    return balance - debt;
  }

  //
  // State methods
  //

  /// @notice Helps set the premium per second for an individual protocol
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  /// @return oldPremiumPerSecond and nonStakerPercentage are returned for gas savings in the calling function
  function _setSingleProtocolPremium(bytes32 _protocol, uint256 _premium)
    internal
    returns (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage)
  {
    // _settleProtocolDebt() subtracts debt from the protocol's active balance and updates the % due to nonstakers
    // Also updates the last accounted timestamp for this protocol
    // nonStakerPercentage is carried over from _settleProtocolDebt() for gas savings
    // nonStakerPercentage represents the percentage that goes to nonstakers for this protocol
    nonStakerPercentage = _settleProtocolDebt(_protocol);
    // Stores the old premium before it gets updated
    oldPremiumPerSecond = premiums_[_protocol];

    if (oldPremiumPerSecond != _premium) {
      // Sets the protocol's premium per second to the new value
      premiums_[_protocol] = _premium;
      emit ProtocolPremiumChanged(_protocol, oldPremiumPerSecond, _premium);
    }
    // We check if the NEW premium causes the _secondsOfCoverageLeft for the protocol to be less than the threshold for arbing
    // We don't need to check the min balance requirement for arbs because that value doesn't change like secondsOfCoverageLeft changes
    // Effectively we just need to make sure we don't accidentally run a protocol's active balance down below the point
    // Where arbs would no longer be incentivized to remove the protocol
    // Because if a protocol is not removed by arbs before running out of active balance, this can cause problems
    if (_premium != 0 && _secondsOfCoverageLeft(_protocol) < MIN_SECONDS_OF_COVERAGE) {
      revert InsufficientBalance(_protocol);
    }
  }

  /// @notice Sets a single protocol's premium per second and also updates the global total of premiums per second
  /// @param _protocol Protocol identifier
  /// @param _premium New premium per second
  function _setSingleAndGlobalProtocolPremium(bytes32 _protocol, uint256 _premium) internal {
    // Sets the individual protocol's premium and returns oldPremiumPerSecond and nonStakerPercentage for gas savings
    (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
      _protocol,
      _premium
    );
    // Settling the total amount of premiums owed to stakers before a new premium per second gets set
    _settleTotalDebt();
    // This calculates the new global premium per second that gets paid to stakers
    // We input the same nonStakerPercentage twice because we simply aren't updating that value in this function
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      oldPremiumPerSecond,
      _premium,
      nonStakerPercentage,
      nonStakerPercentage,
      allPremiumsPerSecToStakers
    );
  }

  // Internal function to set a new protocolAgent for a specific protocol
  // _oldAgent is only included as part of emitting an event
  function _setProtocolAgent(
    bytes32 _protocol,
    address _oldAgent,
    address _protocolAgent
  ) internal {
    protocolAgent_[_protocol] = _protocolAgent;
    emit ProtocolAgentTransfer(_protocol, _oldAgent, _protocolAgent);
  }

  // Subtracts the accrued debt from a protocol's active balance
  // Credits the amount that can be claimed by nonstakers for this protocol
  // Takes the protocol ID as a param and returns the nonStakerPercentage for gas savings
  // Most of this function is dealing with an edge case related to a protocol not being removed by arbs
  function _settleProtocolDebt(bytes32 _protocol) internal returns (uint256 _nonStakerPercentage) {
    // This calcs the accrued debt of the protocol since it was last updated
    uint256 debt = _calcIncrementalProtocolDebt(_protocol);
    // This pulls the percentage that is sent to nonstakers
    _nonStakerPercentage = nonStakersPercentage[_protocol];
    // In case the protocol has accrued debt, this code block will ensure the debt is settled properly
    if (debt != 0) {
      // Pulls the stored active balance of the protocol
      uint256 balance = activeBalances[_protocol];
      // This is the start of handling an edge case where arbitragers don't remove this protocol before debt becomes greater than active balance
      // Economically speaking, this point should never be reached as arbs will get rewarded for removing the protocol before this point
      // The arb would use forceRemoveByActiveBalance and forceRemoveBySecondsOfCoverage
      // However, if arbs don't come in, the premium for this protocol should be set to 0 asap otherwise accounting for stakers/nonstakers gets messed up
      if (debt > balance) {
        // This error amount represents the magnitude of the mistake
        uint256 error = debt - balance;
        // Gets the latest value of claimable premiums for stakers
        _settleTotalDebt();
        // @note to production, set premium first to zero before solving accounting issue.
        // otherwise the accounting error keeps increasing
        uint256 lastClaimablePremiumsForStakers_ = lastClaimablePremiumsForStakers;

        // Figures out the amount due to stakers by subtracting the nonstaker percentage from 100%
        uint256 claimablePremiumError = ((HUNDRED_PERCENT - _nonStakerPercentage) * error) /
          HUNDRED_PERCENT;

        // This insufficient tokens var is simply how we know (emitted as an event) how many tokens the protocol is short
        uint256 insufficientTokens;

        // The idea here is that lastClaimablePremiumsForStakers has gotten too big accidentally
        // We need to decrease the balance of lastClaimablePremiumsForStakers by the amount that was added in error
        // This first line can be true if claimPremiumsForStakers() has been called and
        // lastClaimablePremiumsForStakers would be 0 but a faulty protocol could cause claimablePremiumError to be >0 still
        if (claimablePremiumError > lastClaimablePremiumsForStakers_) {
          insufficientTokens = claimablePremiumError - lastClaimablePremiumsForStakers_;
          lastClaimablePremiumsForStakers = 0;
        } else {
          // If the error is not bigger than the claimable premiums, then we just decrease claimable premiums
          // By the amount that was added in error (error) and insufficientTokens = 0
          lastClaimablePremiumsForStakers =
            lastClaimablePremiumsForStakers_ -
            claimablePremiumError;
        }

        // If two events are thrown, the values need to be summed up for the actual state.
        // This means an error of this type will continue until it is handled
        emit AccountingError(_protocol, claimablePremiumError, insufficientTokens);
        // We set the debt equal to the balance, and in the next line we effectively set the protocol's active balance to 0 in this case
        debt = balance;
      }
      // Subtracts the accrued debt (since last update) from the protocol's active balance and updates active balance
      activeBalances[_protocol] = balance - debt;
      // Adds the requisite amount of the debt to the balance claimable by nonstakers for this protocol
      nonStakersClaimableByProtocol[_protocol] += (_nonStakerPercentage * debt) / HUNDRED_PERCENT;
    }
    // Updates the last accounted timestamp for this protocol
    lastAccountedEachProtocol[_protocol] = block.timestamp;
  }

  // Multiplies the total premium per second * number of seconds since the last global accounting update
  // And adds it to the total claimable amount for stakers
  function _settleTotalDebt() internal {
    lastClaimablePremiumsForStakers +=
      (block.timestamp - lastAccountedGlobal) *
      allPremiumsPerSecToStakers;
    lastAccountedGlobal = block.timestamp;
  }

  // Calculates the global premium per second for stakers
  // Takes a specific protocol's old and new values for premium per second and nonstaker percentage and the old global premium per second to stakers
  // Subtracts out the old values of a protocol's premium per second and nonstaker percentage and adds the new ones
  function _calcGlobalPremiumPerSecForStakers(
    uint256 _premiumOld,
    uint256 _premiumNew,
    uint256 _nonStakerPercentageOld,
    uint256 _nonStakerPercentageNew,
    uint256 _inMemAllPremiumsPerSecToStakers
  ) internal pure returns (uint256) {
    return
      _inMemAllPremiumsPerSecToStakers +
      ((HUNDRED_PERCENT - _nonStakerPercentageNew) * _premiumNew) /
      HUNDRED_PERCENT -
      ((HUNDRED_PERCENT - _nonStakerPercentageOld) * _premiumOld) /
      HUNDRED_PERCENT;
  }

  // Helper function to remove and clean up a protocol from Sherlock
  // Params are the protocol ID and the protocol agent to which funds should be sent and from which post-removal claims can be made
  function _forceRemoveProtocol(bytes32 _protocol, address _agent) internal {
    // Sets the individual protocol's premium to zero and updates the global premium variable for a zero premium at this protocol
    _setSingleAndGlobalProtocolPremium(_protocol, 0);

    // Grabs the protocol's active balance
    uint256 balance = activeBalances[_protocol];

    // If there's still some active balance, delete the entry and send the remaining balance to the protocol agent
    if (balance != 0) {
      delete activeBalances[_protocol];
      token.safeTransfer(_agent, balance);

      emit ProtocolBalanceWithdrawn(_protocol, balance);
    }

    // Sets the protocol agent to zero address (as part of clean up)
    _setProtocolAgent(_protocol, _agent, address(0));

    // Cleans up other mappings for this protocol
    delete nonStakersPercentage[_protocol];
    delete lastAccountedEachProtocol[_protocol];
    // `premiums_` mapping is not deleted here as it's already 0 because of the `_setSingleAndGlobalProtocolPremium` call above

    // Sets a deadline in the future until which this protocol agent can still make claims for this removed protocol
    removedProtocolClaimDeadline[_protocol] = block.timestamp + PROTOCOL_CLAIM_DEADLINE;

    // This mapping allows Sherlock to verify the protocol agent making a claim after the protocol has been removed
    // Remember, only the protocol agent can make claims on behalf of the protocol, so this must be checked
    removedProtocolAgent[_protocol] = _agent;

    emit ProtocolUpdated(_protocol, bytes32(0), uint256(0), uint256(0));
    emit ProtocolRemoved(_protocol);
  }

  /// @notice Sets the minimum active balance before an arb can remove a protocol
  /// @param _minActiveBalance Minimum balance needed (in USDC)
  /// @dev Only gov
  function setMinActiveBalance(uint256 _minActiveBalance) external override onlyOwner {
    // New value cannot be the same as current value
    if (minActiveBalance == _minActiveBalance) revert InvalidArgument();
    // Can't set a value that is too high to be reasonable
    if (_minActiveBalance >= MIN_BALANCE_SANITY_CEILING) revert InvalidConditions();

    emit MinBalance(minActiveBalance, _minActiveBalance);
    minActiveBalance = _minActiveBalance;
  }

  // This function allows the nonstakers role to claim tokens owed to them by a specific protocol
  /// @notice Choose an `_amount` of tokens that nonstakers (`_receiver` address) will receive from `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens
  /// @param _receiver Address to receive tokens
  /// @dev Only callable by nonstakers role
  function nonStakersClaim(
    bytes32 _protocol,
    uint256 _amount,
    address _receiver
  ) external override whenNotPaused {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_amount == uint256(0)) revert ZeroArgument();
    if (_receiver == address(0)) revert ZeroArgument();
    // Only the nonstakers role (multisig or contract) can pull the funds
    if (msg.sender != sherlockCore.nonStakersAddress()) revert Unauthorized();

    // Call can't be executed on protocol that is removed
    if (protocolAgent_[_protocol] != address(0)) {
      // Updates the amount that nonstakers can claim from this protocol
      _settleProtocolDebt(_protocol);
    }

    // Sets balance to the amount that is claimable by nonstakers for this specific protocol
    uint256 balance = nonStakersClaimableByProtocol[_protocol];
    // If the amount requested is more than what's owed to nonstakers, revert
    if (_amount > balance) revert InsufficientBalance(_protocol);

    // Sets the claimable amount to whatever is left over after this amount is pulled
    nonStakersClaimableByProtocol[_protocol] = balance - _amount;
    // Transfers the amount requested to the `_receiver` address
    token.safeTransfer(_receiver, _amount);
  }

  // Transfers funds owed to stakers from this contract to the Sherlock core contract (where we handle paying out stakers)
  /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address
  /// @dev Callable by everyone
  /// @dev Funds will be transferred to Sherlock core contract
  function claimPremiumsForStakers() external override whenNotPaused {
    // Gets address of core Sherlock contract
    address sherlock = address(sherlockCore);
    // Revert if core Sherlock contract not initialized yet
    if (sherlock == address(0)) revert InvalidConditions();

    // claimablePremiums is different from _settleTotalDebt() because it does not change state
    // Retrieves current amount of all premiums that are owed to stakers
    uint256 amount = claimablePremiums();

    // Transfers all the premiums owed to stakers to the Sherlock core contract
    if (amount != 0) {
      // Global value of premiums owed to stakers is set to zero since we are transferring the entire amount out
      lastClaimablePremiumsForStakers = 0;
      lastAccountedGlobal = block.timestamp;
      token.safeTransfer(sherlock, amount);
    }
  }

  // Function is used in the SherlockClaimManager contract to decide if a proposed claim falls under either the current or previous coverage amounts
  /// @param _protocol Protocol identifier
  /// @return current and previous are the current and previous coverage amounts for this protocol
  // Note For this process to work, a protocol's coverage amount should not be set more than once in the span of claim delay period (7 days or something)
  function coverageAmounts(bytes32 _protocol)
    external
    view
    override
    returns (uint256 current, uint256 previous)
  {
    // Checks to see if the protocol has an active protocolAgent (protocol not removed)
    // OR checks to see if the removed protocol is still within the claim window
    // If so, gives the current and previous coverage, otherwise throws an error
    if (
      protocolAgent_[_protocol] != address(0) ||
      block.timestamp <= removedProtocolClaimDeadline[_protocol]
    ) {
      return (currentCoverage[_protocol], previousCoverage[_protocol]);
    }

    revert ProtocolNotExists(_protocol);
  }

  /// @notice Add a new protocol to Sherlock
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Address able to submit a claim on behalf of the protocol
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Adding a protocol allows the `_protocolAgent` to submit a claim
  /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point
  /// @dev `_nonStakers` is scaled by 10**18
  /// @dev Only callable by governance
  function protocolAdd(
    bytes32 _protocol,
    address _protocolAgent,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) external override onlyOwner {
    if (_protocol == bytes32(0)) revert ZeroArgument();
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Checks to make sure the protocol doesn't exist already
    if (protocolAgent_[_protocol] != address(0)) revert InvalidConditions();

    // Updates the protocol agent and passes in the old agent which is 0 address in this case
    _setProtocolAgent(_protocol, address(0), _protocolAgent);

    // Delete mappings that are potentially non default values
    // From previous time protocol was added/removed
    delete removedProtocolClaimDeadline[_protocol];
    delete removedProtocolAgent[_protocol];
    delete currentCoverage[_protocol];
    delete previousCoverage[_protocol];

    emit ProtocolAdded(_protocol);

    // Most of the logic for actually adding a protocol in this function
    protocolUpdate(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Update info regarding a protocol
  /// @param _protocol Protocol identifier
  /// @param _coverage Hash referencing the active coverage agreement
  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18
  /// @param _coverageAmount Max amount claimable by this protocol
  /// @dev Only callable by governance
  /// @dev `_nonStakers` can be 0
  function protocolUpdate(
    bytes32 _protocol,
    bytes32 _coverage,
    uint256 _nonStakers,
    uint256 _coverageAmount
  ) public override onlyOwner {
    if (_coverage == bytes32(0)) revert ZeroArgument();
    if (_nonStakers > HUNDRED_PERCENT) revert InvalidArgument();
    if (_coverageAmount == uint256(0)) revert ZeroArgument();

    // Checks to make sure the protocol has been assigned a protocol agent
    _verifyProtocolExists(_protocol);

    // Subtracts the accrued debt from a protocol's active balance (if any)
    // Updates the amount that can be claimed by nonstakers
    _settleProtocolDebt(_protocol);

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    // Gets the premium per second for this protocol
    uint256 premium = premiums_[_protocol];

    // Updates allPremiumsPerSecToStakers (premium is not able to be updated in this function, but percentage to nonstakers can be)
    allPremiumsPerSecToStakers = _calcGlobalPremiumPerSecForStakers(
      premium,
      premium,
      nonStakersPercentage[_protocol],
      _nonStakers,
      allPremiumsPerSecToStakers
    );

    // Updates the stored value of percentage of premiums that go to nonstakers
    nonStakersPercentage[_protocol] = _nonStakers;

    // Updates previous coverage and current coverage amounts
    previousCoverage[_protocol] = currentCoverage[_protocol];
    currentCoverage[_protocol] = _coverageAmount;

    emit ProtocolUpdated(_protocol, _coverage, _nonStakers, _coverageAmount);
  }

  /// @notice Remove a protocol from coverage
  /// @param _protocol Protocol identifier
  /// @dev Before removing a protocol the premium must be 0
  /// @dev Removing a protocol basically stops the `_protocolAgent` from being active (can still submit claims until claim deadline though)
  /// @dev Pays off debt + sends remaining balance to protocol agent
  /// @dev This call should be subject to a timelock
  /// @dev Only callable by governance
  function protocolRemove(bytes32 _protocol) external override onlyOwner {
    // checks to make sure the protocol actually has a protocol agent
    address agent = _verifyProtocolExists(_protocol);

    // Removes a protocol from Sherlock and cleans up its data
    // Params are the protocol ID and the protocol agent to which remaining active balance should be sent and from which post-removal claims can be made
    _forceRemoveProtocol(_protocol, agent);
  }

  /// @notice Remove a protocol with insufficient active balance
  /// @param _protocol Protocol identifier
  // msg.sender receives whatever is left of the insufficient active balance, this should incentivize arbs to call this function
  function forceRemoveByActiveBalance(bytes32 _protocol) external override whenNotPaused {
    address agent = _verifyProtocolExists(_protocol);

    // Gets the latest value of the active balance at this protocol
    _settleProtocolDebt(_protocol);
    // Sets latest value of active balance to remainingBalance variable
    uint256 remainingBalance = activeBalances[_protocol];

    // This means the protocol still has adequate active balance and thus cannot be removed
    if (remainingBalance >= minActiveBalance) revert InvalidConditions();

    // Sets the protocol's active balance to 0
    delete activeBalances[_protocol];
    // Removes the protocol from coverage
    _forceRemoveProtocol(_protocol, agent);

    if (remainingBalance != 0) {
      // sends the remaining balance to msg.sender
      token.safeTransfer(msg.sender, remainingBalance);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, remainingBalance);
  }

  /// @notice Calculate if arb is possible and what the reward would be
  /// @param _protocol Protocol identifier
  /// @return arbAmount Amount reward for arbing
  /// @return able Indicator if arb call is even possible
  /// @dev Doesn't subtract the current protocol debt from the active balance
  function _calcForceRemoveBySecondsOfCoverage(bytes32 _protocol)
    internal
    view
    returns (uint256 arbAmount, bool able)
  {
    uint256 secondsLeft = _secondsOfCoverageLeft(_protocol);

    // If arb is not possible return false
    if (secondsLeft >= MIN_SECONDS_OF_COVERAGE) return (0, false);

    // This percentage scales over time
    // Reaches 100% on 0 seconds of coverage left
    uint256 percentageScaled = HUNDRED_PERCENT -
      (secondsLeft * HUNDRED_PERCENT) /
      MIN_SECONDS_OF_COVERAGE;

    able = true;
    arbAmount = (activeBalances[_protocol] * percentageScaled) / HUNDRED_PERCENT;
  }

  /// @notice Removes a protocol with insufficent seconds of coverage left
  /// @param _protocol Protocol identifier
  // Seconds of coverage is defined by the active balance of the protocol divided by the protocol's premium per second
  function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external override whenNotPaused {
    // NOTE: We use _secondsOfCoverageLeft() below and include this check instead of secondsOfCoverageLeft() for gas savings
    address agent = _verifyProtocolExists(_protocol);

    // NOTE: We don't give the arb the full remaining balance like we do in forceRemoveByActiveBalance()
    // This is because we know the exact balance the arb will get in forceRemoveByActiveBalance()
    // But when removing based on seconds of coverage left, the remainingBalance could still be quite large
    // So it's better to scale the arb reward over time. It's a little complex because the remainingBalance
    // Decreases over time also but reward will be highest at the midpoint of percentageScaled (50%)
    _settleProtocolDebt(_protocol);
    (uint256 arbAmount, bool able) = _calcForceRemoveBySecondsOfCoverage(_protocol);
    if (able == false) revert InvalidConditions();

    if (arbAmount != 0) {
      // subtracts the amount that will be paid to the arb from the active balance
      activeBalances[_protocol] -= arbAmount;
    }

    // Removes the protocol from coverage
    // This function also pays the active balance to the protocol agent, so it's good we do this after subtracting arb amount above
    _forceRemoveProtocol(_protocol, agent);

    // Done after removing protocol to mitigate reentrency pattern
    // (In case token allows callback)
    if (arbAmount != 0) {
      token.safeTransfer(msg.sender, arbAmount);
    }
    emit ProtocolRemovedByArb(_protocol, msg.sender, arbAmount);
  }

  /// @notice Set premium of `_protocol` to `_premium`
  /// @param _protocol Protocol identifier
  /// @param _premium Amount of premium `_protocol` pays per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremium(bytes32 _protocol, uint256 _premium) external override onlyOwner {
    // Checks to see if protocol has a protocol agent
    _verifyProtocolExists(_protocol);

    // Updates individual protocol's premium and allPremiumsPerSecToStakers
    _setSingleAndGlobalProtocolPremium(_protocol, _premium);
  }

  /// @notice Set premium of multiple protocols
  /// @param _protocol Array of protocol identifiers
  /// @param _premium Array of premium amounts protocols pay per second
  /// @dev The value 0 would mean inactive coverage
  /// @dev Only callable by governance
  function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium)
    external
    override
    onlyOwner
  {
    // Checks to make sure there are an equal amount of entries in each array
    if (_protocol.length != _premium.length) revert UnequalArrayLength();
    if (_protocol.length == 0) revert InvalidArgument();

    // Updates the global claimable amount for stakers
    _settleTotalDebt();

    uint256 allPremiumsPerSecToStakers_ = allPremiumsPerSecToStakers;

    // Loops through the array of protocols and checks to make sure each has a protocol agent assigned
    for (uint256 i; i < _protocol.length; i++) {
      _verifyProtocolExists(_protocol[i]);

      // Sets the protocol premium for that specific protocol
      // Function returns the old premium and nonStakerPercentage for that specific protocol
      (uint256 oldPremiumPerSecond, uint256 nonStakerPercentage) = _setSingleProtocolPremium(
        _protocol[i],
        _premium[i]
      );

      // Calculates the new global premium which adds up all premiums paid by all protocols
      allPremiumsPerSecToStakers_ = _calcGlobalPremiumPerSecForStakers(
        oldPremiumPerSecond,
        _premium[i],
        nonStakerPercentage,
        nonStakerPercentage,
        allPremiumsPerSecToStakers_
      );
    }

    // After the loop has finished, sets allPremiumsPerSecToStakers to the final temp value
    allPremiumsPerSecToStakers = allPremiumsPerSecToStakers_;
  }

  // This is how protocols pay for coverage by increasing their active balance
  /// @notice Deposits `_amount` of token to the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to deposit
  /// @dev Approval should be made before calling
  function depositToActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    _verifyProtocolExists(_protocol);

    // Transfers _amount to this contract
    token.safeTransferFrom(msg.sender, address(this), _amount);
    // Increases the active balance of the protocol by _amount
    activeBalances[_protocol] += _amount;

    emit ProtocolBalanceDeposited(_protocol, _amount);
  }

  // If a protocol has paid too much into the active balance (which is how a protocol pays the premium)
  // Then the protocol can remove some of the active balance (up until there is 7 days worth of balance left)
  /// @notice Withdraws `_amount` of token from the active balance of `_protocol`
  /// @param _protocol Protocol identifier
  /// @param _amount Amount of tokens to withdraw
  /// @dev Only protocol agent is able to withdraw
  /// @dev Balance can be withdrawn up until 7 days worth of active balance
  function withdrawActiveBalance(bytes32 _protocol, uint256 _amount)
    external
    override
    whenNotPaused
  {
    if (_amount == uint256(0)) revert ZeroArgument();
    // Only the protocol agent can call this function
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Updates the active balance of the protocol
    _settleProtocolDebt(_protocol);

    // Sets currentBalance to the active balance of the protocol
    uint256 currentBalance = activeBalances[_protocol];
    // Reverts if trying to withdraw more than the active balance
    if (_amount > currentBalance) revert InsufficientBalance(_protocol);

    // Removes the _amount to be withdrawn from the active balance
    activeBalances[_protocol] = currentBalance - _amount;
    // Reverts if a protocol has less than 7 days worth of active balance left
    if (_secondsOfCoverageLeft(_protocol) < MIN_SECONDS_LEFT) revert InsufficientBalance(_protocol);

    // Transfers the amount to the msg.sender (protocol agent)
    token.safeTransfer(msg.sender, _amount);
    emit ProtocolBalanceWithdrawn(_protocol, _amount);
  }

  /// @notice Transfer protocol agent role
  /// @param _protocol Protocol identifier
  /// @param _protocolAgent Account able to submit a claim on behalf of the protocol
  /// @dev Only the active protocolAgent is able to transfer the role
  function transferProtocolAgent(bytes32 _protocol, address _protocolAgent)
    external
    override
    whenNotPaused
  {
    if (_protocolAgent == address(0)) revert ZeroArgument();
    // Can't set the new protocol agent to the caller address
    if (msg.sender == _protocolAgent) revert InvalidArgument();
    // Because the caller must be the current protocol agent
    if (msg.sender != _verifyProtocolExists(_protocol)) revert Unauthorized();

    // Sets the protocol agent to the new address
    _setProtocolAgent(_protocol, msg.sender, _protocolAgent);
  }

  /// @notice Function used to check if this is the current active protocol manager
  /// @return Boolean indicating it's active
  /// @dev If inactive the owner can pull all ERC20s and ETH
  /// @dev Will be checked by calling the sherlock contract
  function isActive() public view returns (bool) {
    return address(sherlockCore.sherlockProtocolManager()) == address(this);
  }

  // Only contract owner can call this
  // Sends all specified tokens in this contract to the receiver's address (as well as ETH)
  function sweep(address _receiver, IERC20[] memory _extraTokens) external onlyOwner {
    if (_receiver == address(0)) revert ZeroArgument();
    // This contract must NOT be the current assigned protocol manager contract
    if (isActive()) revert InvalidConditions();
    // Executes the sweep for ERC-20s specified in _extraTokens as well as for ETH
    _sweep(_receiver, _extraTokens);
  }
}
".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

