[2024-24-08 18:27:06 INFO] **[Preprocessing]**

**ChatDev Starts** (20240824182706)

**Timestamp**: 20240824182706

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;

pragma experimental ABIEncoderV2;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "./OpenLevInterface.sol";
import "./Types.sol";
import "./Adminable.sol";
import "./DelegateInterface.sol";
import "./ControllerInterface.sol";
import "./IWETH.sol";
import "./XOLEInterface.sol";
import "./Types.sol";
import "./OpenLevV1Lib.sol";

/// @title OpenLeverage margin trade logic
/// @author OpenLeverage
/// @notice Use this contract for margin trade.
/// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE.
contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {
    using SafeMath for uint;
    using TransferHelper for IERC20;
    using DexData for bytes;

    constructor ()
    {
    }

    /// @notice initialize proxy contract
    /// @dev This function is not supposed to call multiple times. All configs can be set through other functions.
    /// @param _controller Address of contract ControllerDelegator.
    /// @param _dexAggregator contract DexAggregatorDelegator.
    /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens.
    /// @param _wETH Address of wrapped native coin.
    /// @param _xOLE Address of XOLEDelegator.
    /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol.
    function initialize(
        address _controller,
        DexAggregatorInterface _dexAggregator,
        address[] memory depositTokens,
        address _wETH,
        address _xOLE,
        uint8[] memory _supportDexs
    ) public {
        depositTokens;
        require(msg.sender == admin, "NAD");
        addressConfig.controller = _controller;
        addressConfig.dexAggregator = _dexAggregator;
        addressConfig.wETH = _wETH;
        addressConfig.xOLE = _xOLE;
        for (uint i = 0; i < _supportDexs.length; i++) {
            supportDexs[_supportDexs[i]] = true;
        }
        OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig);
    }

    /// @notice Create new trading pair.
    /// @dev This function is typically called by ControllerDelegator.
    /// @param pool0 Contract LpoolDelegator, lending pool of token0.
    /// @param pool1 Contract LpoolDelegator, lending pool of token1.
    /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value.
    /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens.
    /// @return The new created pair ID.
    function addMarket(
        LPoolInterface pool0,
        LPoolInterface pool1,
        uint16 marginLimit,
        bytes memory dexData
    ) external override returns (uint16) {
        uint16 marketId = numPairs;
        OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);
        numPairs ++;
        return marketId;
    }

    /// @notice Margin trade or just add more deposit tokens.
    /// @dev To support token with tax and reward. Stores share of all token balances of this contract.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param depositToken Token to deposit. False for token0, true for token1.
    /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported.
    /// @param borrow Amount of ERC20 to borrow from the short token pool.
    /// @param minBuyAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function marginTrade(
        uint16 marketId,
        bool longToken,
        bool depositToken,
        uint deposit,
        uint borrow,
        uint minBuyAmount,
        bytes memory dexData
    ) external payable override nonReentrant onlySupportDex(dexData) {
        Types.TradeVars memory tv;
        Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);
        verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);
        (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);

        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);
        }

        tv.totalHeld = totalHelds[address(vars.buyToken)];
        tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;

        deposit = transferIn(msg.sender, tv.depositErc20, deposit);

        // Borrow
        uint borrowed;
        if (borrow > 0) {
            {
                uint balance = vars.sellToken.balanceOf(address(this));
                vars.sellPool.borrowBehalf(msg.sender, borrow);
                borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);
            }

            if (depositToken == longToken){
                (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);
                tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));
            }else{
                tv.borrowValue = borrow;
            }
        }

        require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) > vars.marginLimit, "MAM");
        tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);
        tv.depositAfterFees = deposit.sub(tv.fees);
        tv.dexDetail = dexData.toDexDetail();

        if (depositToken == longToken ){
            if (borrowed > 0){
                tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);
                tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);
            }
            tv.newHeld = tv.newHeld.add(tv.depositAfterFees);
        }else{
            tv.tradeSize = tv.depositAfterFees.add(borrowed);
            tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);
            tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);
        }

        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);
        trade.held = trade.held.add(tv.newHeld);
        trade.depositToken = depositToken;
        trade.deposited = trade.deposited.add(tv.depositAfterFees);
        trade.lastBlockNum = uint128(block.number);

        totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);

        require(OpenLevV1Lib.isPositionHealthy(
                msg.sender,
                true,
                OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),
                vars,
                dexData
            ), "PNH");

        emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail);
    }

    /// @notice Close trade by shares.
    /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param closeHeld Amount of shares to close.
    /// @param minOrMaxAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);

        //verify
        verifyCloseBefore(trade, marketVars, closeHeld, dexData);

        uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        Types.CloseTradeVars memory closeTradeVars;
        closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);
        closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);
        closeTradeVars.isPartialClose = closeHeld != trade.held;
        closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);
        closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        closeTradeVars.dexDetail = dexData.toDexDetail();

        //partial close
        if (closeTradeVars.isPartialClose) {
            closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);
            closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);
            trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);
        } else {
            closeTradeVars.depositDecrease = trade.deposited;
        }

        if (trade.depositToken != longToken) {
            minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);
            closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;
            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);

            closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);
            doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);
        } else {
            uint balance = marketVars.buyToken.balanceOf(address(this));
            minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);
            closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);
            closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);
            closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);
            require(marketVars.sellToken.balanceOf(address(this)) >= closeTradeVars.depositReturn, "ISB");
            doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);
        }

        uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));
        require(repayed >= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");

        if (!closeTradeVars.isPartialClose) {
            delete activeTrades[msg.sender][marketId][longToken];
        }else{
            trade.held = trade.held.sub(closeHeld);
            trade.lastBlockNum = uint128(block.number);
        }

        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);

        closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,
            closeTradeVars.token0Price, closeTradeVars.dexDetail);
    }

    /// @notice Liquidate if trade below margin limit.
    /// @dev For trades without sufficient funds to repay, use insurance.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param minBuy Slippage for Dex trading.
    /// @param maxSell Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade memory trade = activeTrades[owner][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());
        uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);
        require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");

        Types.LiquidateVars memory liquidateVars;
        liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);
        if (liquidateVars.penalty > 0) {
            doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);
        }
        liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);
        liquidateVars.dexDetail = dexData.toDexDetail();
        liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);
        liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        liquidateVars.marketId = marketId;
        liquidateVars.longToken = longToken;

        bool buySuccess;
        bytes memory sellAmountData;
        if (longToken == trade.depositToken) {
            maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);
            marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);
            (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(
                abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],
                taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)
            );
        }

        if (buySuccess) {
            {
                uint temp;
                assembly {
                    temp := mload(add(sellAmountData, 0x20))
                }
                liquidateVars.sellAmount = temp;
            }

            liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);
            marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
            liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);
            doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);
        } else {
            liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;
            liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);
            if (liquidateVars.receiveAmount >= liquidateVars.borrowed) {
                // fail if buy failed but sell succeeded
                require (longToken != trade.depositToken, "PH");
                marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
                liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);
                doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);
            } else {
                liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);
                liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);
                marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);
            }
        }

        liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);
        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);

        emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,
            trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);

        delete activeTrades[owner][marketId][longToken];
    }

    function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {
        return open == longToken ?
        Types.MarketVars(
            market.pool1,
            market.pool0,
            IERC20(market.token1),
            IERC20(market.token0),
            IERC20(market.token1).balanceOf(address(this)),
            IERC20(market.token0).balanceOf(address(this)),
            market.pool1Insurance,
            market.pool0Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs) :
        Types.MarketVars(
            market.pool0,
            market.pool1,
            IERC20(market.token0),
            IERC20(market.token1),
            IERC20(market.token0).balanceOf(address(this)),
            IERC20(market.token1).balanceOf(address(this)),
            market.pool0Insurance,
            market.pool1Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs);
    }

    /// @notice Get ratios of deposited token value to borrowed token value.
    /// @dev Caluclate ratio with current price and twap price.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param dexData Index and fee rate for the trading Dex.
    /// @return current Margin ratio calculated using current price.
    /// @return cAvg Margin ratio calculated using twap price.
    /// @return hAvg Margin ratio calculated using last recorded twap price.
    /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value.
    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {
        Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);
        limit = vars.marginLimit;
        (current, cAvg, hAvg,,) =
        OpenLevV1Lib.marginRatio(
            owner,
            activeTrades[owner][marketId][longToken].held,
            address(vars.sellToken),
            address(vars.buyToken),
            vars.buyPool,
            false,
            dexData
        );
    }

    /// @notice Check if a price update is required on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){
        Types.Market memory market = markets[marketId];
        return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData);
    }

    /// @notice Update price on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function updatePrice(uint16 marketId, bytes memory dexData) external override {
        OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData);
    }

    /// @notice List of all supporting Dexes.
    function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){
        return markets[marketId].dexs;
    }

    function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {
        Types.Market storage market = markets[marketId];
        uint needed = totalRepayment.sub(remaining);
        needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);
        maxCanRepayAmount = totalRepayment;
        if (longToken) {
            if (market.pool0Insurance >= needed) {
                market.pool0Insurance = market.pool0Insurance - needed;
                totalHelds[token] = totalHelds[token].sub(needed);
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);
                market.pool0Insurance = 0;
            }
        } else {
            if (market.pool1Insurance >= needed) {
                market.pool1Insurance = market.pool1Insurance - needed;
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);
                market.pool1Insurance = 0;
            }
        }
    }

    function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {
        // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);
        Types.Market storage market = markets[marketId];
        uint defaultFees = tradeSize.mul(market.feesRate).div(10000);
        uint newFees = defaultFees;
        // if trader holds more xOLE, then should enjoy trading discount.
        if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) > calculateConfig.feesDiscountThreshold) {
            newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));
        }
        // if trader update price, then should enjoy trading discount.
        if (market.priceUpdater == trader) {
            newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));
        }
        uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);
        IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));

        newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);
        if (token == market.token1) {
            market.pool1Insurance = market.pool1Insurance.add(newInsurance);
        } else {
            market.pool0Insurance = market.pool0Insurance.add(newInsurance);
        }

        totalHelds[token] = totalHelds[token].add(newInsurance);
        return newFees;
    }

    function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){
        if (sellAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);
            buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);
        }
    }

    function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){
        if (buyAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);
            sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);
        }
    }

    /// @dev All credited on this contract and share with all token holder if any rewards for the transfer.
    function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {
        return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount);
    }

    /// @dev All credited on "to" if any taxes for the transfer.
    function doTransferOut(address to, IERC20 token, uint amount) internal {
        OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount);
    }

    /*** Admin Functions ***/
    function setCalculateConfig(uint16 defaultFeesRate,
        uint8 insuranceRatio,
        uint16 defaultMarginLimit,
        uint16 priceDiffientRatio,
        uint16 updatePriceDiscount,
        uint16 feesDiscount,
        uint128 feesDiscountThreshold,
        uint16 penaltyRatio,
        uint8 maxLiquidationPriceDiffientRatio,
        uint16 twapDuration) external override onlyAdmin() {
        OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,
            feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);
        emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration);
    }

    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {
        OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);
        emit NewAddressConfig(controller, address(dexAggregator));
    }

    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {
        OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);
        emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs);
    }

    /// @notice List of all supporting Dexes.
    /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1
    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {
        Types.Market storage market = markets[marketId];
        if (poolIndex == 0) {
            market.pool0Insurance = market.pool0Insurance.sub(amount);
            (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));
            return;
        }
        market.pool1Insurance = market.pool1Insurance.sub(amount);
        (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this))));
    }

    function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {
        supportDexs[dex] = support;
    }

    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){
        taxes[marketId][token][index] = tax;
    }

    function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {
        Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];
        OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade);
    }

    function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {
        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());
        require(closeHeld <= trade.held, "CBH");
    }

    function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {
        require(held != 0 && lastBlockNumber != block.number && OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0");
    }

    modifier onlySupportDex(bytes memory dexData) {
        require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");
        _;
    }
}

**project_name**: RealWorld_BA_72_OpenLevV1

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_72_OpenLevV1_RealWord_20240824182706.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-24-08 18:27:06 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.7.6; pragma experimental ABIEncoderV2; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import "./OpenLevInterface.sol"; import "./Types.sol"; import "./Adminable.sol"; import "./DelegateInterface.sol"; import "./ControllerInterface.sol"; import "./IWETH.sol"; import "./XOLEInterface.sol"; import "./Types.sol"; import "./OpenLevV1Lib.sol"; /// @title OpenLeverage margin trade logic /// @author OpenLeverage /// @notice Use this contract for margin trade. /// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE. contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {     using SafeMath for uint;     using TransferHelper for IERC20;     using DexData for bytes; constructor () { }  /// @notice initialize proxy contract /// @dev This function is not supposed to call multiple times. All configs can be set through other functions. /// @param _controller Address of contract ControllerDelegator. /// @param _dexAggregator contract DexAggregatorDelegator. /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens. /// @param _wETH Address of wrapped native coin. /// @param _xOLE Address of XOLEDelegator. /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol. function initialize(     address _controller,     DexAggregatorInterface _dexAggregator,     address[] memory depositTokens,     address _wETH,     address _xOLE,     uint8[] memory _supportDexs ) public {     depositTokens;     require(msg.sender == admin, "NAD");     addressConfig.controller = _controller;     addressConfig.dexAggregator = _dexAggregator;     addressConfig.wETH = _wETH;     addressConfig.xOLE = _xOLE;     for (uint i = 0; i &lt; _supportDexs.length; i++) {         supportDexs[_supportDexs[i]] = true;     }     OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig); }  /// @notice Create new trading pair. /// @dev This function is typically called by ControllerDelegator. /// @param pool0 Contract LpoolDelegator, lending pool of token0. /// @param pool1 Contract LpoolDelegator, lending pool of token1. /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value. /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens. /// @return The new created pair ID. function addMarket(     LPoolInterface pool0,     LPoolInterface pool1,     uint16 marginLimit,     bytes memory dexData ) external override returns (uint16) {     uint16 marketId = numPairs;     OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);     numPairs ++;     return marketId; }  /// @notice Margin trade or just add more deposit tokens. /// @dev To support token with tax and reward. Stores share of all token balances of this contract. /// @param longToken Token to long. False for token0, true for token1. /// @param depositToken Token to deposit. False for token0, true for token1. /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported. /// @param borrow Amount of ERC20 to borrow from the short token pool. /// @param minBuyAmount Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function marginTrade(     uint16 marketId,     bool longToken,     bool depositToken,     uint deposit,     uint borrow,     uint minBuyAmount,     bytes memory dexData ) external payable override nonReentrant onlySupportDex(dexData) {     Types.TradeVars memory tv;     Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);     verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);     (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);      if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);     }      tv.totalHeld = totalHelds[address(vars.buyToken)];     tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;      deposit = transferIn(msg.sender, tv.depositErc20, deposit);      // Borrow     uint borrowed;     if (borrow &gt; 0) {         {             uint balance = vars.sellToken.balanceOf(address(this));             vars.sellPool.borrowBehalf(msg.sender, borrow);             borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);         }          if (depositToken == longToken){             (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);             tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));         }else{             tv.borrowValue = borrow;         }     }      require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) &gt; vars.marginLimit, "MAM");     tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);     tv.depositAfterFees = deposit.sub(tv.fees);     tv.dexDetail = dexData.toDexDetail();      if (depositToken == longToken ){         if (borrowed &gt; 0){             tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);             tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);         }         tv.newHeld = tv.newHeld.add(tv.depositAfterFees);     }else{         tv.tradeSize = tv.depositAfterFees.add(borrowed);         tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);         tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);     }      Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];     tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);     trade.held = trade.held.add(tv.newHeld);     trade.depositToken = depositToken;     trade.deposited = trade.deposited.add(tv.depositAfterFees);     trade.lastBlockNum = uint128(block.number);      totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);      require(OpenLevV1Lib.isPositionHealthy(             msg.sender,             true,             OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),             vars,             dexData         ), "PNH");      emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail); }  /// @notice Close trade by shares. /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed. /// @param longToken Token to long. False for token0, true for token1. /// @param closeHeld Amount of shares to close. /// @param minOrMaxAmount Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {     Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];     Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);      //verify     verifyCloseBefore(trade, marketVars, closeHeld, dexData);      uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);      Types.CloseTradeVars memory closeTradeVars;     closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);     closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);     closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);     closeTradeVars.isPartialClose = closeHeld != trade.held;     closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);     closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);     closeTradeVars.dexDetail = dexData.toDexDetail();      //partial close     if (closeTradeVars.isPartialClose) {         closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);         closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);         trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);     } else {         closeTradeVars.depositDecrease = trade.deposited;     }      if (trade.depositToken != longToken) {         minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);         closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);         require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");          closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;         marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);          closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);         doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);     } else {         uint balance = marketVars.buyToken.balanceOf(address(this));         minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);         closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);         closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);         require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");          marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);         closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);         require(marketVars.sellToken.balanceOf(address(this)) &gt;= closeTradeVars.depositReturn, "ISB");         doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);     }      uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));     require(repayed &gt;= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");      if (!closeTradeVars.isPartialClose) {         delete activeTrades[msg.sender][marketId][longToken];     }else{         trade.held = trade.held.sub(closeHeld);         trade.lastBlockNum = uint128(block.number);     }      totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);      closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);     if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);     }      emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,         closeTradeVars.token0Price, closeTradeVars.dexDetail); }  /// @notice Liquidate if trade below margin limit. /// @dev For trades without sufficient funds to repay, use insurance. /// @param owner Owner of the trade to liquidate. /// @param longToken Token to long. False for token0, true for token1. /// @param minBuy Slippage for Dex trading. /// @param maxSell Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {     Types.Trade memory trade = activeTrades[owner][marketId][longToken];     Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);     if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);     }      verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());     uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);      (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);     require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");      Types.LiquidateVars memory liquidateVars;     liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);     liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);     if (liquidateVars.penalty &gt; 0) {         doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);     }     liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);     liquidateVars.dexDetail = dexData.toDexDetail();     liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);     liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);     liquidateVars.marketId = marketId;     liquidateVars.longToken = longToken;      bool buySuccess;     bytes memory sellAmountData;     if (longToken == trade.depositToken) {         maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);         marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);         (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(             abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],             taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)         );     }      if (buySuccess) {         {             uint temp;             assembly {                 temp := mload(add(sellAmountData, 0x20))             }             liquidateVars.sellAmount = temp;         }          liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);         marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);         liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);         doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);     } else {         liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;         liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);         if (liquidateVars.receiveAmount &gt;= liquidateVars.borrowed) {             // fail if buy failed but sell succeeded             require (longToken != trade.depositToken, "PH");             marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);             liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);             doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);         } else {             liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);             liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);             marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);         }     }      liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);     totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);      emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,         trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);      delete activeTrades[owner][marketId][longToken]; }  function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {     return open == longToken ?     Types.MarketVars(         market.pool1,         market.pool0,         IERC20(market.token1),         IERC20(market.token0),         IERC20(market.token1).balanceOf(address(this)),         IERC20(market.token0).balanceOf(address(this)),         market.pool1Insurance,         market.pool0Insurance,         market.marginLimit,         market.priceDiffientRatio,         market.dexs) :     Types.MarketVars(         market.pool0,         market.pool1,         IERC20(market.token0),         IERC20(market.token1),         IERC20(market.token0).balanceOf(address(this)),         IERC20(market.token1).balanceOf(address(this)),         market.pool0Insurance,         market.pool1Insurance,         market.marginLimit,         market.priceDiffientRatio,         market.dexs); }  /// @notice Get ratios of deposited token value to borrowed token value. /// @dev Caluclate ratio with current price and twap price. /// @param owner Owner of the trade to liquidate. /// @param longToken Token to long. False for token0, true for token1. /// @param dexData Index and fee rate for the trading Dex. /// @return current Margin ratio calculated using current price. /// @return cAvg Margin ratio calculated using twap price. /// @return hAvg Margin ratio calculated using last recorded twap price. /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value. function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {     Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);     limit = vars.marginLimit;     (current, cAvg, hAvg,,) =     OpenLevV1Lib.marginRatio(         owner,         activeTrades[owner][marketId][longToken].held,         address(vars.sellToken),         address(vars.buyToken),         vars.buyPool,         false,         dexData     ); }  /// @notice Check if a price update is required on Dex. /// @param dexData Index and fee rate for the trading Dex. function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){     Types.Market memory market = markets[marketId];     return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData); }  /// @notice Update price on Dex. /// @param dexData Index and fee rate for the trading Dex. function updatePrice(uint16 marketId, bytes memory dexData) external override {     OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData); }  /// @notice List of all supporting Dexes. function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){     return markets[marketId].dexs; }  function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {     Types.Market storage market = markets[marketId];     uint needed = totalRepayment.sub(remaining);     needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);     maxCanRepayAmount = totalRepayment;     if (longToken) {         if (market.pool0Insurance &gt;= needed) {             market.pool0Insurance = market.pool0Insurance - needed;             totalHelds[token] = totalHelds[token].sub(needed);         } else {             maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);             maxCanRepayAmount = maxCanRepayAmount.add(remaining);             totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);             market.pool0Insurance = 0;         }     } else {         if (market.pool1Insurance &gt;= needed) {             market.pool1Insurance = market.pool1Insurance - needed;         } else {             maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);             maxCanRepayAmount = maxCanRepayAmount.add(remaining);             totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);             market.pool1Insurance = 0;         }     } }  function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {     // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);     Types.Market storage market = markets[marketId];     uint defaultFees = tradeSize.mul(market.feesRate).div(10000);     uint newFees = defaultFees;     // if trader holds more xOLE, then should enjoy trading discount.     if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) &gt; calculateConfig.feesDiscountThreshold) {         newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));     }     // if trader update price, then should enjoy trading discount.     if (market.priceUpdater == trader) {         newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));     }     uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);     IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));      newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);     if (token == market.token1) {         market.pool1Insurance = market.pool1Insurance.add(newInsurance);     } else {         market.pool0Insurance = market.pool0Insurance.add(newInsurance);     }      totalHelds[token] = totalHelds[token].add(newInsurance);     return newFees; }  function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){     if (sellAmount &gt; 0){         DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;         IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);         buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);     } }  function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){     if (buyAmount &gt; 0){         DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;         IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);         sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);     } }  /// @dev All credited on this contract and share with all token holder if any rewards for the transfer. function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {     return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount); }  /// @dev All credited on "to" if any taxes for the transfer. function doTransferOut(address to, IERC20 token, uint amount) internal {     OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount); }  /*** Admin Functions ***/ function setCalculateConfig(uint16 defaultFeesRate,     uint8 insuranceRatio,     uint16 defaultMarginLimit,     uint16 priceDiffientRatio,     uint16 updatePriceDiscount,     uint16 feesDiscount,     uint128 feesDiscountThreshold,     uint16 penaltyRatio,     uint8 maxLiquidationPriceDiffientRatio,     uint16 twapDuration) external override onlyAdmin() {     OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,         feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);     emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration); }  function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {     OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);     emit NewAddressConfig(controller, address(dexAggregator)); }  function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {     OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);     emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs); }  /// @notice List of all supporting Dexes. /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1 function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {     Types.Market storage market = markets[marketId];     if (poolIndex == 0) {         market.pool0Insurance = market.pool0Insurance.sub(amount);         (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));         return;     }     market.pool1Insurance = market.pool1Insurance.sub(amount);     (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this)))); }  function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {     supportDexs[dex] = support; }  function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){     taxes[marketId][token][index] = tax; }  function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {     Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];     OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade); }  function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {     verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());     require(closeHeld &lt;= trade.held, "CBH"); }  function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {     require(held != 0 &amp;&amp; lastBlockNumber != block.number &amp;&amp; OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0"); }  modifier onlySupportDex(bytes memory dexData) {     require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");     _; }  } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.7.6;\n\npragma experimental ABIEncoderV2;\n\nimport "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\nimport "./OpenLevInterface.sol";\nimport "./Types.sol";\nimport "./Adminable.sol";\nimport "./DelegateInterface.sol";\nimport "./ControllerInterface.sol";\nimport "./IWETH.sol";\nimport "./XOLEInterface.sol";\nimport "./Types.sol";\nimport "./OpenLevV1Lib.sol";\n\n/// @title OpenLeverage margin trade logic\n/// @author OpenLeverage\n/// @notice Use this contract for margin trade.\n/// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE.\ncontract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {\n    using SafeMath for uint;\n    using TransferHelper for IERC20;\n    using DexData for bytes;\n\n    constructor ()\n    {\n    }\n\n    /// @notice initialize proxy contract\n    /// @dev This function is not supposed to call multiple times. All configs can be set through other functions.\n    /// @param controller Address of contract ControllerDelegator.\n    /// @param _dexAggregator contract DexAggregatorDelegator.\n    /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens.\n    /// @param _wETH Address of wrapped native coin.\n    /// @param _xOLE Address of XOLEDelegator.\n    /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol.\n    function initialize(\n        address _controller,\n        DexAggregatorInterface _dexAggregator,\n        address[] memory depositTokens,\n        address _wETH,\n        address _xOLE,\n        uint8[] memory _supportDexs\n    ) public {\n        depositTokens;\n        require(msg.sender == admin, "NAD");\n        addressConfig.controller = _controller;\n        addressConfig.dexAggregator = _dexAggregator;\n        addressConfig.wETH = _wETH;\n        addressConfig.xOLE = _xOLE;\n        for (uint i = 0; i &lt; _supportDexs.length; i++) {\n            supportDexs[_supportDexs[i]] = true;\n        }\n        OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig);\n    }\n\n    /// @notice Create new trading pair.\n    /// @dev This function is typically called by ControllerDelegator.\n    /// @param pool0 Contract LpoolDelegator, lending pool of token0.\n    /// @param pool1 Contract LpoolDelegator, lending pool of token1.\n    /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value.\n    /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens.\n    /// @return The new created pair ID.\n    function addMarket(\n        LPoolInterface pool0,\n        LPoolInterface pool1,\n        uint16 marginLimit,\n        bytes memory dexData\n    ) external override returns (uint16) {\n        uint16 marketId = numPairs;\n        OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);\n        numPairs ++;\n        return marketId;\n    }\n\n    /// @notice Margin trade or just add more deposit tokens.\n    /// @dev To support token with tax and reward. Stores share of all token balances of this contract.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param depositToken Token to deposit. False for token0, true for token1.\n    /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported.\n    /// @param borrow Amount of ERC20 to borrow from the short token pool.\n    /// @param minBuyAmount Slippage for Dex trading.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function marginTrade(\n        uint16 marketId,\n        bool longToken,\n        bool depositToken,\n        uint deposit,\n        uint borrow,\n        uint minBuyAmount,\n        bytes memory dexData\n    ) external payable override nonReentrant onlySupportDex(dexData) {\n        Types.TradeVars memory tv;\n        Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);\n        verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);\n        (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);\n\n        if (dexData.isUniV2Class()) {\n            OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);\n        }\n\n        tv.totalHeld = totalHelds[address(vars.buyToken)];\n        tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;\n\n        deposit = transferIn(msg.sender, tv.depositErc20, deposit);\n\n        // Borrow\n        uint borrowed;\n        if (borrow &gt; 0) {\n            {\n                uint balance = vars.sellToken.balanceOf(address(this));\n                vars.sellPool.borrowBehalf(msg.sender, borrow);\n                borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);\n            }\n\n            if (depositToken == longToken){\n                (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);\n                tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));\n            }else{\n                tv.borrowValue = borrow;\n            }\n        }\n\n        require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) &gt; vars.marginLimit, "MAM");\n        tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);\n        tv.depositAfterFees = deposit.sub(tv.fees);\n        tv.dexDetail = dexData.toDexDetail();\n\n        if (depositToken == longToken ){\n            if (borrowed &gt; 0){\n                tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);\n                tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);\n            }\n            tv.newHeld = tv.newHeld.add(tv.depositAfterFees);\n        }else{\n            tv.tradeSize = tv.depositAfterFees.add(borrowed);\n            tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);\n            tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);\n        }\n\n        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];\n        tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);\n        trade.held = trade.held.add(tv.newHeld);\n        trade.depositToken = depositToken;\n        trade.deposited = trade.deposited.add(tv.depositAfterFees);\n        trade.lastBlockNum = uint128(block.number);\n\n        totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);\n\n        require(OpenLevV1Lib.isPositionHealthy(\n                msg.sender,\n                true,\n                OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),\n                vars,\n                dexData\n            ), "PNH");\n\n        emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail);\n    }\n\n    /// @notice Close trade by shares.\n    /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param closeHeld Amount of shares to close.\n    /// @param minOrMaxAmount Slippage for Dex trading.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {\n        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];\n        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);\n\n        //verify\n        verifyCloseBefore(trade, marketVars, closeHeld, dexData);\n\n        uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n\n        Types.CloseTradeVars memory closeTradeVars;\n        closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n        closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);\n        closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);\n        closeTradeVars.isPartialClose = closeHeld != trade.held;\n        closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);\n        closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);\n        closeTradeVars.dexDetail = dexData.toDexDetail();\n\n        //partial close\n        if (closeTradeVars.isPartialClose) {\n            closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);\n            closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);\n            trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);\n        } else {\n            closeTradeVars.depositDecrease = trade.deposited;\n        }\n\n        if (trade.depositToken != longToken) {\n            minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);\n            closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);\n            require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");\n\n            closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;\n            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);\n\n            closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);\n            doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);\n        } else {\n            uint balance = marketVars.buyToken.balanceOf(address(this));\n            minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);\n            closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);\n            closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);\n            require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");\n\n            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);\n            closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);\n            require(marketVars.sellToken.balanceOf(address(this)) &gt;= closeTradeVars.depositReturn, "ISB");\n            doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);\n        }\n\n        uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));\n        require(repayed &gt;= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");\n\n        if (!closeTradeVars.isPartialClose) {\n            delete activeTrades[msg.sender][marketId][longToken];\n        }else{\n            trade.held = trade.held.sub(closeHeld);\n            trade.lastBlockNum = uint128(block.number);\n        }\n\n        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);\n\n        closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);\n        if (dexData.isUniV2Class()) {\n            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);\n        }\n\n        emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,\n            closeTradeVars.token0Price, closeTradeVars.dexDetail);\n    }\n\n    /// @notice Liquidate if trade below margin limit.\n    /// @dev For trades without sufficient funds to repay, use insurance.\n    /// @param owner Owner of the trade to liquidate.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param minBuy Slippage for Dex trading.\n    /// @param maxSell Slippage for Dex trading.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {\n        Types.Trade memory trade = activeTrades[owner][marketId][longToken];\n        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);\n        if (dexData.isUniV2Class()) {\n            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);\n        }\n\n        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());\n        uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n\n        (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);\n        require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");\n\n        Types.LiquidateVars memory liquidateVars;\n        liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n        liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);\n        if (liquidateVars.penalty &gt; 0) {\n            doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);\n        }\n        liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);\n        liquidateVars.dexDetail = dexData.toDexDetail();\n        liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);\n        liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);\n        liquidateVars.marketId = marketId;\n        liquidateVars.longToken = longToken;\n\n        bool buySuccess;\n        bytes memory sellAmountData;\n        if (longToken == trade.depositToken) {\n            maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);\n            marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);\n            (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(\n                abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],\n                taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)\n            );\n        }\n\n        if (buySuccess) {\n            {\n                uint temp;\n                assembly {\n                    temp := mload(add(sellAmountData, 0x20))\n                }\n                liquidateVars.sellAmount = temp;\n            }\n\n            liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);\n            marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);\n            liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);\n            doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);\n        } else {\n            liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;\n            liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);\n            if (liquidateVars.receiveAmount &gt;= liquidateVars.borrowed) {\n                // fail if buy failed but sell succeeded\n                require (longToken != trade.depositToken, "PH");\n                marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);\n                liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);\n                doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);\n            } else {\n                liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);\n                liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);\n                marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);\n            }\n        }\n\n        liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);\n        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);\n\n        emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,\n            trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);\n\n        delete activeTrades[owner][marketId][longToken];\n    }\n\n    function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {\n        return open == longToken ?\n        Types.MarketVars(\n            market.pool1,\n            market.pool0,\n            IERC20(market.token1),\n            IERC20(market.token0),\n            IERC20(market.token1).balanceOf(address(this)),\n            IERC20(market.token0).balanceOf(address(this)),\n            market.pool1Insurance,\n            market.pool0Insurance,\n            market.marginLimit,\n            market.priceDiffientRatio,\n            market.dexs) :\n        Types.MarketVars(\n            market.pool0,\n            market.pool1,\n            IERC20(market.token0),\n            IERC20(market.token1),\n            IERC20(market.token0).balanceOf(address(this)),\n            IERC20(market.token1).balanceOf(address(this)),\n            market.pool0Insurance,\n            market.pool1Insurance,\n            market.marginLimit,\n            market.priceDiffientRatio,\n            market.dexs);\n    }\n\n    /// @notice Get ratios of deposited token value to borrowed token value.\n    /// @dev Caluclate ratio with current price and twap price.\n    /// @param owner Owner of the trade to liquidate.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param dexData Index and fee rate for the trading Dex.\n    /// @return current Margin ratio calculated using current price.\n    /// @return cAvg Margin ratio calculated using twap price.\n    /// @return hAvg Margin ratio calculated using last recorded twap price.\n    /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value.\n    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {\n        Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);\n        limit = vars.marginLimit;\n        (current, cAvg, hAvg,,) =\n        OpenLevV1Lib.marginRatio(\n            owner,\n            activeTrades[owner][marketId][longToken].held,\n            address(vars.sellToken),\n            address(vars.buyToken),\n            vars.buyPool,\n            false,\n            dexData\n        );\n    }\n\n    /// @notice Check if a price update is required on Dex.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){\n        Types.Market memory market = markets[marketId];\n        return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData);\n    }\n\n    /// @notice Update price on Dex.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function updatePrice(uint16 marketId, bytes memory dexData) external override {\n        OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData);\n    }\n\n    /// @notice List of all supporting Dexes.\n    function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){\n        return markets[marketId].dexs;\n    }\n\n    function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {\n        Types.Market storage market = markets[marketId];\n        uint needed = totalRepayment.sub(remaining);\n        needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);\n        maxCanRepayAmount = totalRepayment;\n        if (longToken) {\n            if (market.pool0Insurance &gt;= needed) {\n                market.pool0Insurance = market.pool0Insurance - needed;\n                totalHelds[token] = totalHelds[token].sub(needed);\n            } else {\n                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);\n                maxCanRepayAmount = maxCanRepayAmount.add(remaining);\n                totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);\n                market.pool0Insurance = 0;\n            }\n        } else {\n            if (market.pool1Insurance &gt;= needed) {\n                market.pool1Insurance = market.pool1Insurance - needed;\n            } else {\n                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);\n                maxCanRepayAmount = maxCanRepayAmount.add(remaining);\n                totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);\n                market.pool1Insurance = 0;\n            }\n        }\n    }\n\n    function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {\n        // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);\n        Types.Market storage market = markets[marketId];\n        uint defaultFees = tradeSize.mul(market.feesRate).div(10000);\n        uint newFees = defaultFees;\n        // if trader holds more xOLE, then should enjoy trading discount.\n        if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) &gt; calculateConfig.feesDiscountThreshold) {\n            newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));\n        }\n        // if trader update price, then should enjoy trading discount.\n        if (market.priceUpdater == trader) {\n            newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));\n        }\n        uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);\n        IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));\n\n        newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);\n        if (token == market.token1) {\n            market.pool1Insurance = market.pool1Insurance.add(newInsurance);\n        } else {\n            market.pool0Insurance = market.pool0Insurance.add(newInsurance);\n        }\n\n        totalHelds[token] = totalHelds[token].add(newInsurance);\n        return newFees;\n    }\n\n    function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){\n        if (sellAmount &gt; 0){\n            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;\n            IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);\n            buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);\n        }\n    }\n\n    function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){\n        if (buyAmount &gt; 0){\n            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;\n            IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);\n            sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);\n        }\n    }\n\n    /// @dev All credited on this contract and share with all token holder if any rewards for the transfer.\n    function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {\n        return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount);\n    }\n\n    /// @dev All credited on "to" if any taxes for the transfer.\n    function doTransferOut(address to, IERC20 token, uint amount) internal {\n        OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount);\n    }\n\n    / Admin Functions /\n    function setCalculateConfig(uint16 defaultFeesRate,\n        uint8 insuranceRatio,\n        uint16 defaultMarginLimit,\n        uint16 priceDiffientRatio,\n        uint16 updatePriceDiscount,\n        uint16 feesDiscount,\n        uint128 feesDiscountThreshold,\n        uint16 penaltyRatio,\n        uint8 maxLiquidationPriceDiffientRatio,\n        uint16 twapDuration) external override onlyAdmin() {\n        OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,\n            feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);\n        emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration);\n    }\n\n    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {\n        OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);\n        emit NewAddressConfig(controller, address(dexAggregator));\n    }\n\n    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {\n        OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);\n        emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs);\n    }\n\n    /// @notice List of all supporting Dexes.\n    /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1\n    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {\n        Types.Market storage market = markets[marketId];\n        if (poolIndex == 0) {\n            market.pool0Insurance = market.pool0Insurance.sub(amount);\n            (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));\n            return;\n        }\n        market.pool1Insurance = market.pool1Insurance.sub(amount);\n        (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this))));\n    }\n\n    function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {\n        supportDexs[dex] = support;\n    }\n\n    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){\n        taxes[marketId][token][index] = tax;\n    }\n\n    function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {\n        Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];\n        OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade);\n    }\n\n    function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {\n        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());\n        require(closeHeld &lt;= trade.held, "CBH");\n    }\n\n    function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {\n        require(held != 0 &amp;&amp; lastBlockNumber != block.number &amp;&amp; OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0");\n    }\n\n    modifier onlySupportDex(bytes memory dexData) {\n        require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");\n        ;\n    }\n}'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-24-08 18:27:06 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.7.6; pragma experimental ABIEncoderV2; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import "./OpenLevInterface.sol"; import "./Types.sol"; import "./Adminable.sol"; import "./DelegateInterface.sol"; import "./ControllerInterface.sol"; import "./IWETH.sol"; import "./XOLEInterface.sol"; import "./Types.sol"; import "./OpenLevV1Lib.sol"; /// @title OpenLeverage margin trade logic /// @author OpenLeverage /// @notice Use this contract for margin trade. /// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE. contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {     using SafeMath for uint;     using TransferHelper for IERC20;     using DexData for bytes; constructor () { }  /// @notice initialize proxy contract /// @dev This function is not supposed to call multiple times. All configs can be set through other functions. /// @param _controller Address of contract ControllerDelegator. /// @param _dexAggregator contract DexAggregatorDelegator. /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens. /// @param _wETH Address of wrapped native coin. /// @param _xOLE Address of XOLEDelegator. /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol. function initialize(     address _controller,     DexAggregatorInterface _dexAggregator,     address[] memory depositTokens,     address _wETH,     address _xOLE,     uint8[] memory _supportDexs ) public {     depositTokens;     require(msg.sender == admin, "NAD");     addressConfig.controller = _controller;     addressConfig.dexAggregator = _dexAggregator;     addressConfig.wETH = _wETH;     addressConfig.xOLE = _xOLE;     for (uint i = 0; i &lt; _supportDexs.length; i++) {         supportDexs[_supportDexs[i]] = true;     }     OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig); }  /// @notice Create new trading pair. /// @dev This function is typically called by ControllerDelegator. /// @param pool0 Contract LpoolDelegator, lending pool of token0. /// @param pool1 Contract LpoolDelegator, lending pool of token1. /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value. /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens. /// @return The new created pair ID. function addMarket(     LPoolInterface pool0,     LPoolInterface pool1,     uint16 marginLimit,     bytes memory dexData ) external override returns (uint16) {     uint16 marketId = numPairs;     OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);     numPairs ++;     return marketId; }  /// @notice Margin trade or just add more deposit tokens. /// @dev To support token with tax and reward. Stores share of all token balances of this contract. /// @param longToken Token to long. False for token0, true for token1. /// @param depositToken Token to deposit. False for token0, true for token1. /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported. /// @param borrow Amount of ERC20 to borrow from the short token pool. /// @param minBuyAmount Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function marginTrade(     uint16 marketId,     bool longToken,     bool depositToken,     uint deposit,     uint borrow,     uint minBuyAmount,     bytes memory dexData ) external payable override nonReentrant onlySupportDex(dexData) {     Types.TradeVars memory tv;     Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);     verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);     (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);      if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);     }      tv.totalHeld = totalHelds[address(vars.buyToken)];     tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;      deposit = transferIn(msg.sender, tv.depositErc20, deposit);      // Borrow     uint borrowed;     if (borrow &gt; 0) {         {             uint balance = vars.sellToken.balanceOf(address(this));             vars.sellPool.borrowBehalf(msg.sender, borrow);             borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);         }          if (depositToken == longToken){             (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);             tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));         }else{             tv.borrowValue = borrow;         }     }      require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) &gt; vars.marginLimit, "MAM");     tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);     tv.depositAfterFees = deposit.sub(tv.fees);     tv.dexDetail = dexData.toDexDetail();      if (depositToken == longToken ){         if (borrowed &gt; 0){             tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);             tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);         }         tv.newHeld = tv.newHeld.add(tv.depositAfterFees);     }else{         tv.tradeSize = tv.depositAfterFees.add(borrowed);         tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);         tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);     }      Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];     tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);     trade.held = trade.held.add(tv.newHeld);     trade.depositToken = depositToken;     trade.deposited = trade.deposited.add(tv.depositAfterFees);     trade.lastBlockNum = uint128(block.number);      totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);      require(OpenLevV1Lib.isPositionHealthy(             msg.sender,             true,             OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),             vars,             dexData         ), "PNH");      emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail); }  /// @notice Close trade by shares. /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed. /// @param longToken Token to long. False for token0, true for token1. /// @param closeHeld Amount of shares to close. /// @param minOrMaxAmount Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {     Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];     Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);      //verify     verifyCloseBefore(trade, marketVars, closeHeld, dexData);      uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);      Types.CloseTradeVars memory closeTradeVars;     closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);     closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);     closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);     closeTradeVars.isPartialClose = closeHeld != trade.held;     closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);     closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);     closeTradeVars.dexDetail = dexData.toDexDetail();      //partial close     if (closeTradeVars.isPartialClose) {         closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);         closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);         trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);     } else {         closeTradeVars.depositDecrease = trade.deposited;     }      if (trade.depositToken != longToken) {         minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);         closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);         require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");          closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;         marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);          closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);         doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);     } else {         uint balance = marketVars.buyToken.balanceOf(address(this));         minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);         closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);         closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);         require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");          marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);         closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);         require(marketVars.sellToken.balanceOf(address(this)) &gt;= closeTradeVars.depositReturn, "ISB");         doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);     }      uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));     require(repayed &gt;= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");      if (!closeTradeVars.isPartialClose) {         delete activeTrades[msg.sender][marketId][longToken];     }else{         trade.held = trade.held.sub(closeHeld);         trade.lastBlockNum = uint128(block.number);     }      totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);      closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);     if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);     }      emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,         closeTradeVars.token0Price, closeTradeVars.dexDetail); }  /// @notice Liquidate if trade below margin limit. /// @dev For trades without sufficient funds to repay, use insurance. /// @param owner Owner of the trade to liquidate. /// @param longToken Token to long. False for token0, true for token1. /// @param minBuy Slippage for Dex trading. /// @param maxSell Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {     Types.Trade memory trade = activeTrades[owner][marketId][longToken];     Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);     if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);     }      verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());     uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);      (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);     require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");      Types.LiquidateVars memory liquidateVars;     liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);     liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);     if (liquidateVars.penalty &gt; 0) {         doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);     }     liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);     liquidateVars.dexDetail = dexData.toDexDetail();     liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);     liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);     liquidateVars.marketId = marketId;     liquidateVars.longToken = longToken;      bool buySuccess;     bytes memory sellAmountData;     if (longToken == trade.depositToken) {         maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);         marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);         (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(             abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],             taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)         );     }      if (buySuccess) {         {             uint temp;             assembly {                 temp := mload(add(sellAmountData, 0x20))             }             liquidateVars.sellAmount = temp;         }          liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);         marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);         liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);         doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);     } else {         liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;         liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);         if (liquidateVars.receiveAmount &gt;= liquidateVars.borrowed) {             // fail if buy failed but sell succeeded             require (longToken != trade.depositToken, "PH");             marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);             liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);             doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);         } else {             liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);             liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);             marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);         }     }      liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);     totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);      emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,         trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);      delete activeTrades[owner][marketId][longToken]; }  function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {     return open == longToken ?     Types.MarketVars(         market.pool1,         market.pool0,         IERC20(market.token1),         IERC20(market.token0),         IERC20(market.token1).balanceOf(address(this)),         IERC20(market.token0).balanceOf(address(this)),         market.pool1Insurance,         market.pool0Insurance,         market.marginLimit,         market.priceDiffientRatio,         market.dexs) :     Types.MarketVars(         market.pool0,         market.pool1,         IERC20(market.token0),         IERC20(market.token1),         IERC20(market.token0).balanceOf(address(this)),         IERC20(market.token1).balanceOf(address(this)),         market.pool0Insurance,         market.pool1Insurance,         market.marginLimit,         market.priceDiffientRatio,         market.dexs); }  /// @notice Get ratios of deposited token value to borrowed token value. /// @dev Caluclate ratio with current price and twap price. /// @param owner Owner of the trade to liquidate. /// @param longToken Token to long. False for token0, true for token1. /// @param dexData Index and fee rate for the trading Dex. /// @return current Margin ratio calculated using current price. /// @return cAvg Margin ratio calculated using twap price. /// @return hAvg Margin ratio calculated using last recorded twap price. /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value. function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {     Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);     limit = vars.marginLimit;     (current, cAvg, hAvg,,) =     OpenLevV1Lib.marginRatio(         owner,         activeTrades[owner][marketId][longToken].held,         address(vars.sellToken),         address(vars.buyToken),         vars.buyPool,         false,         dexData     ); }  /// @notice Check if a price update is required on Dex. /// @param dexData Index and fee rate for the trading Dex. function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){     Types.Market memory market = markets[marketId];     return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData); }  /// @notice Update price on Dex. /// @param dexData Index and fee rate for the trading Dex. function updatePrice(uint16 marketId, bytes memory dexData) external override {     OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData); }  /// @notice List of all supporting Dexes. function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){     return markets[marketId].dexs; }  function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {     Types.Market storage market = markets[marketId];     uint needed = totalRepayment.sub(remaining);     needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);     maxCanRepayAmount = totalRepayment;     if (longToken) {         if (market.pool0Insurance &gt;= needed) {             market.pool0Insurance = market.pool0Insurance - needed;             totalHelds[token] = totalHelds[token].sub(needed);         } else {             maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);             maxCanRepayAmount = maxCanRepayAmount.add(remaining);             totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);             market.pool0Insurance = 0;         }     } else {         if (market.pool1Insurance &gt;= needed) {             market.pool1Insurance = market.pool1Insurance - needed;         } else {             maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);             maxCanRepayAmount = maxCanRepayAmount.add(remaining);             totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);             market.pool1Insurance = 0;         }     } }  function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {     // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);     Types.Market storage market = markets[marketId];     uint defaultFees = tradeSize.mul(market.feesRate).div(10000);     uint newFees = defaultFees;     // if trader holds more xOLE, then should enjoy trading discount.     if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) &gt; calculateConfig.feesDiscountThreshold) {         newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));     }     // if trader update price, then should enjoy trading discount.     if (market.priceUpdater == trader) {         newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));     }     uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);     IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));      newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);     if (token == market.token1) {         market.pool1Insurance = market.pool1Insurance.add(newInsurance);     } else {         market.pool0Insurance = market.pool0Insurance.add(newInsurance);     }      totalHelds[token] = totalHelds[token].add(newInsurance);     return newFees; }  function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){     if (sellAmount &gt; 0){         DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;         IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);         buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);     } }  function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){     if (buyAmount &gt; 0){         DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;         IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);         sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);     } }  /// @dev All credited on this contract and share with all token holder if any rewards for the transfer. function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {     return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount); }  /// @dev All credited on "to" if any taxes for the transfer. function doTransferOut(address to, IERC20 token, uint amount) internal {     OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount); }  /*** Admin Functions ***/ function setCalculateConfig(uint16 defaultFeesRate,     uint8 insuranceRatio,     uint16 defaultMarginLimit,     uint16 priceDiffientRatio,     uint16 updatePriceDiscount,     uint16 feesDiscount,     uint128 feesDiscountThreshold,     uint16 penaltyRatio,     uint8 maxLiquidationPriceDiffientRatio,     uint16 twapDuration) external override onlyAdmin() {     OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,         feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);     emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration); }  function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {     OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);     emit NewAddressConfig(controller, address(dexAggregator)); }  function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {     OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);     emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs); }  /// @notice List of all supporting Dexes. /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1 function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {     Types.Market storage market = markets[marketId];     if (poolIndex == 0) {         market.pool0Insurance = market.pool0Insurance.sub(amount);         (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));         return;     }     market.pool1Insurance = market.pool1Insurance.sub(amount);     (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this)))); }  function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {     supportDexs[dex] = support; }  function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){     taxes[marketId][token][index] = tax; }  function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {     Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];     OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade); }  function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {     verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());     require(closeHeld &lt;= trade.held, "CBH"); }  function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {     require(held != 0 &amp;&amp; lastBlockNumber != block.number &amp;&amp; OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0"); }  modifier onlySupportDex(bytes memory dexData) {     require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");     _; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-24-08 18:27:06 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;

pragma experimental ABIEncoderV2;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "./OpenLevInterface.sol";
import "./Types.sol";
import "./Adminable.sol";
import "./DelegateInterface.sol";
import "./ControllerInterface.sol";
import "./IWETH.sol";
import "./XOLEInterface.sol";
import "./Types.sol";
import "./OpenLevV1Lib.sol";

/// @title OpenLeverage margin trade logic
/// @author OpenLeverage
/// @notice Use this contract for margin trade.
/// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE.
contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {
    using SafeMath for uint;
    using TransferHelper for IERC20;
    using DexData for bytes;

    constructor ()
    {
    }

    /// @notice initialize proxy contract
    /// @dev This function is not supposed to call multiple times. All configs can be set through other functions.
    /// @param _controller Address of contract ControllerDelegator.
    /// @param _dexAggregator contract DexAggregatorDelegator.
    /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens.
    /// @param _wETH Address of wrapped native coin.
    /// @param _xOLE Address of XOLEDelegator.
    /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol.
    function initialize(
        address _controller,
        DexAggregatorInterface _dexAggregator,
        address[] memory depositTokens,
        address _wETH,
        address _xOLE,
        uint8[] memory _supportDexs
    ) public {
        depositTokens;
        require(msg.sender == admin, "NAD");
        addressConfig.controller = _controller;
        addressConfig.dexAggregator = _dexAggregator;
        addressConfig.wETH = _wETH;
        addressConfig.xOLE = _xOLE;
        for (uint i = 0; i < _supportDexs.length; i++) {
            supportDexs[_supportDexs[i]] = true;
        }
        OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig);
    }

    /// @notice Create new trading pair.
    /// @dev This function is typically called by ControllerDelegator.
    /// @param pool0 Contract LpoolDelegator, lending pool of token0.
    /// @param pool1 Contract LpoolDelegator, lending pool of token1.
    /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value.
    /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens.
    /// @return The new created pair ID.
    function addMarket(
        LPoolInterface pool0,
        LPoolInterface pool1,
        uint16 marginLimit,
        bytes memory dexData
    ) external override returns (uint16) {
        uint16 marketId = numPairs;
        OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);
        numPairs ++;
        return marketId;
    }

    /// @notice Margin trade or just add more deposit tokens.
    /// @dev To support token with tax and reward. Stores share of all token balances of this contract.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param depositToken Token to deposit. False for token0, true for token1.
    /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported.
    /// @param borrow Amount of ERC20 to borrow from the short token pool.
    /// @param minBuyAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function marginTrade(
        uint16 marketId,
        bool longToken,
        bool depositToken,
        uint deposit,
        uint borrow,
        uint minBuyAmount,
        bytes memory dexData
    ) external payable override nonReentrant onlySupportDex(dexData) {
        Types.TradeVars memory tv;
        Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);
        verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);
        (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);

        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);
        }

        tv.totalHeld = totalHelds[address(vars.buyToken)];
        tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;

        deposit = transferIn(msg.sender, tv.depositErc20, deposit);

        // Borrow
        uint borrowed;
        if (borrow > 0) {
            {
                uint balance = vars.sellToken.balanceOf(address(this));
                vars.sellPool.borrowBehalf(msg.sender, borrow);
                borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);
            }

            if (depositToken == longToken){
                (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);
                tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));
            }else{
                tv.borrowValue = borrow;
            }
        }

        require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) > vars.marginLimit, "MAM");
        tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);
        tv.depositAfterFees = deposit.sub(tv.fees);
        tv.dexDetail = dexData.toDexDetail();

        if (depositToken == longToken ){
            if (borrowed > 0){
                tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);
                tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);
            }
            tv.newHeld = tv.newHeld.add(tv.depositAfterFees);
        }else{
            tv.tradeSize = tv.depositAfterFees.add(borrowed);
            tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);
            tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);
        }

        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);
        trade.held = trade.held.add(tv.newHeld);
        trade.depositToken = depositToken;
        trade.deposited = trade.deposited.add(tv.depositAfterFees);
        trade.lastBlockNum = uint128(block.number);

        totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);

        require(OpenLevV1Lib.isPositionHealthy(
                msg.sender,
                true,
                OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),
                vars,
                dexData
            ), "PNH");

        emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail);
    }

    /// @notice Close trade by shares.
    /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param closeHeld Amount of shares to close.
    /// @param minOrMaxAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);

        //verify
        verifyCloseBefore(trade, marketVars, closeHeld, dexData);

        uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        Types.CloseTradeVars memory closeTradeVars;
        closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);
        closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);
        closeTradeVars.isPartialClose = closeHeld != trade.held;
        closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);
        closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        closeTradeVars.dexDetail = dexData.toDexDetail();

        //partial close
        if (closeTradeVars.isPartialClose) {
            closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);
            closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);
            trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);
        } else {
            closeTradeVars.depositDecrease = trade.deposited;
        }

        if (trade.depositToken != longToken) {
            minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);
            closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;
            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);

            closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);
            doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);
        } else {
            uint balance = marketVars.buyToken.balanceOf(address(this));
            minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);
            closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);
            closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);
            closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);
            require(marketVars.sellToken.balanceOf(address(this)) >= closeTradeVars.depositReturn, "ISB");
            doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);
        }

        uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));
        require(repayed >= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");

        if (!closeTradeVars.isPartialClose) {
            delete activeTrades[msg.sender][marketId][longToken];
        }else{
            trade.held = trade.held.sub(closeHeld);
            trade.lastBlockNum = uint128(block.number);
        }

        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);

        closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,
            closeTradeVars.token0Price, closeTradeVars.dexDetail);
    }

    /// @notice Liquidate if trade below margin limit.
    /// @dev For trades without sufficient funds to repay, use insurance.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param minBuy Slippage for Dex trading.
    /// @param maxSell Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade memory trade = activeTrades[owner][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());
        uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);
        require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");

        Types.LiquidateVars memory liquidateVars;
        liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);
        if (liquidateVars.penalty > 0) {
            doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);
        }
        liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);
        liquidateVars.dexDetail = dexData.toDexDetail();
        liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);
        liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        liquidateVars.marketId = marketId;
        liquidateVars.longToken = longToken;

        bool buySuccess;
        bytes memory sellAmountData;
        if (longToken == trade.depositToken) {
            maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);
            marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);
            (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(
                abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],
                taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)
            );
        }

        if (buySuccess) {
            {
                uint temp;
                assembly {
                    temp := mload(add(sellAmountData, 0x20))
                }
                liquidateVars.sellAmount = temp;
            }

            liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);
            marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
            liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);
            doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);
        } else {
            liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;
            liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);
            if (liquidateVars.receiveAmount >= liquidateVars.borrowed) {
                // fail if buy failed but sell succeeded
                require (longToken != trade.depositToken, "PH");
                marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
                liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);
                doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);
            } else {
                liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);
                liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);
                marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);
            }
        }

        liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);
        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);

        emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,
            trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);

        delete activeTrades[owner][marketId][longToken];
    }

    function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {
        return open == longToken ?
        Types.MarketVars(
            market.pool1,
            market.pool0,
            IERC20(market.token1),
            IERC20(market.token0),
            IERC20(market.token1).balanceOf(address(this)),
            IERC20(market.token0).balanceOf(address(this)),
            market.pool1Insurance,
            market.pool0Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs) :
        Types.MarketVars(
            market.pool0,
            market.pool1,
            IERC20(market.token0),
            IERC20(market.token1),
            IERC20(market.token0).balanceOf(address(this)),
            IERC20(market.token1).balanceOf(address(this)),
            market.pool0Insurance,
            market.pool1Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs);
    }

    /// @notice Get ratios of deposited token value to borrowed token value.
    /// @dev Caluclate ratio with current price and twap price.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param dexData Index and fee rate for the trading Dex.
    /// @return current Margin ratio calculated using current price.
    /// @return cAvg Margin ratio calculated using twap price.
    /// @return hAvg Margin ratio calculated using last recorded twap price.
    /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value.
    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {
        Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);
        limit = vars.marginLimit;
        (current, cAvg, hAvg,,) =
        OpenLevV1Lib.marginRatio(
            owner,
            activeTrades[owner][marketId][longToken].held,
            address(vars.sellToken),
            address(vars.buyToken),
            vars.buyPool,
            false,
            dexData
        );
    }

    /// @notice Check if a price update is required on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){
        Types.Market memory market = markets[marketId];
        return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData);
    }

    /// @notice Update price on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function updatePrice(uint16 marketId, bytes memory dexData) external override {
        OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData);
    }

    /// @notice List of all supporting Dexes.
    function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){
        return markets[marketId].dexs;
    }

    function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {
        Types.Market storage market = markets[marketId];
        uint needed = totalRepayment.sub(remaining);
        needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);
        maxCanRepayAmount = totalRepayment;
        if (longToken) {
            if (market.pool0Insurance >= needed) {
                market.pool0Insurance = market.pool0Insurance - needed;
                totalHelds[token] = totalHelds[token].sub(needed);
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);
                market.pool0Insurance = 0;
            }
        } else {
            if (market.pool1Insurance >= needed) {
                market.pool1Insurance = market.pool1Insurance - needed;
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);
                market.pool1Insurance = 0;
            }
        }
    }

    function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {
        // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);
        Types.Market storage market = markets[marketId];
        uint defaultFees = tradeSize.mul(market.feesRate).div(10000);
        uint newFees = defaultFees;
        // if trader holds more xOLE, then should enjoy trading discount.
        if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) > calculateConfig.feesDiscountThreshold) {
            newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));
        }
        // if trader update price, then should enjoy trading discount.
        if (market.priceUpdater == trader) {
            newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));
        }
        uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);
        IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));

        newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);
        if (token == market.token1) {
            market.pool1Insurance = market.pool1Insurance.add(newInsurance);
        } else {
            market.pool0Insurance = market.pool0Insurance.add(newInsurance);
        }

        totalHelds[token] = totalHelds[token].add(newInsurance);
        return newFees;
    }

    function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){
        if (sellAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);
            buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);
        }
    }

    function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){
        if (buyAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);
            sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);
        }
    }

    /// @dev All credited on this contract and share with all token holder if any rewards for the transfer.
    function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {
        return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount);
    }

    /// @dev All credited on "to" if any taxes for the transfer.
    function doTransferOut(address to, IERC20 token, uint amount) internal {
        OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount);
    }

    /*** Admin Functions ***/
    function setCalculateConfig(uint16 defaultFeesRate,
        uint8 insuranceRatio,
        uint16 defaultMarginLimit,
        uint16 priceDiffientRatio,
        uint16 updatePriceDiscount,
        uint16 feesDiscount,
        uint128 feesDiscountThreshold,
        uint16 penaltyRatio,
        uint8 maxLiquidationPriceDiffientRatio,
        uint16 twapDuration) external override onlyAdmin() {
        OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,
            feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);
        emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration);
    }

    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {
        OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);
        emit NewAddressConfig(controller, address(dexAggregator));
    }

    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {
        OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);
        emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs);
    }

    /// @notice List of all supporting Dexes.
    /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1
    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {
        Types.Market storage market = markets[marketId];
        if (poolIndex == 0) {
            market.pool0Insurance = market.pool0Insurance.sub(amount);
            (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));
            return;
        }
        market.pool1Insurance = market.pool1Insurance.sub(amount);
        (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this))));
    }

    function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {
        supportDexs[dex] = support;
    }

    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){
        taxes[marketId][token][index] = tax;
    }

    function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {
        Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];
        OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade);
    }

    function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {
        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());
        require(closeHeld <= trade.held, "CBH");
    }

    function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {
        require(held != 0 && lastBlockNumber != block.number && OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0");
    }

    modifier onlySupportDex(bytes memory dexData) {
        require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");
        _;
    }
}.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;

pragma experimental ABIEncoderV2;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "./OpenLevInterface.sol";
import "./Types.sol";
import "./Adminable.sol";
import "./DelegateInterface.sol";
import "./ControllerInterface.sol";
import "./IWETH.sol";
import "./XOLEInterface.sol";
import "./Types.sol";
import "./OpenLevV1Lib.sol";

/// @title OpenLeverage margin trade logic
/// @author OpenLeverage
/// @notice Use this contract for margin trade.
/// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE.
contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {
    using SafeMath for uint;
    using TransferHelper for IERC20;
    using DexData for bytes;

    constructor ()
    {
    }

    /// @notice initialize proxy contract
    /// @dev This function is not supposed to call multiple times. All configs can be set through other functions.
    /// @param _controller Address of contract ControllerDelegator.
    /// @param _dexAggregator contract DexAggregatorDelegator.
    /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens.
    /// @param _wETH Address of wrapped native coin.
    /// @param _xOLE Address of XOLEDelegator.
    /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol.
    function initialize(
        address _controller,
        DexAggregatorInterface _dexAggregator,
        address[] memory depositTokens,
        address _wETH,
        address _xOLE,
        uint8[] memory _supportDexs
    ) public {
        depositTokens;
        require(msg.sender == admin, "NAD");
        addressConfig.controller = _controller;
        addressConfig.dexAggregator = _dexAggregator;
        addressConfig.wETH = _wETH;
        addressConfig.xOLE = _xOLE;
        for (uint i = 0; i < _supportDexs.length; i++) {
            supportDexs[_supportDexs[i]] = true;
        }
        OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig);
    }

    /// @notice Create new trading pair.
    /// @dev This function is typically called by ControllerDelegator.
    /// @param pool0 Contract LpoolDelegator, lending pool of token0.
    /// @param pool1 Contract LpoolDelegator, lending pool of token1.
    /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value.
    /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens.
    /// @return The new created pair ID.
    function addMarket(
        LPoolInterface pool0,
        LPoolInterface pool1,
        uint16 marginLimit,
        bytes memory dexData
    ) external override returns (uint16) {
        uint16 marketId = numPairs;
        OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);
        numPairs ++;
        return marketId;
    }

    /// @notice Margin trade or just add more deposit tokens.
    /// @dev To support token with tax and reward. Stores share of all token balances of this contract.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param depositToken Token to deposit. False for token0, true for token1.
    /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported.
    /// @param borrow Amount of ERC20 to borrow from the short token pool.
    /// @param minBuyAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function marginTrade(
        uint16 marketId,
        bool longToken,
        bool depositToken,
        uint deposit,
        uint borrow,
        uint minBuyAmount,
        bytes memory dexData
    ) external payable override nonReentrant onlySupportDex(dexData) {
        Types.TradeVars memory tv;
        Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);
        verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);
        (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);

        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);
        }

        tv.totalHeld = totalHelds[address(vars.buyToken)];
        tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;

        deposit = transferIn(msg.sender, tv.depositErc20, deposit);

        // Borrow
        uint borrowed;
        if (borrow > 0) {
            {
                uint balance = vars.sellToken.balanceOf(address(this));
                vars.sellPool.borrowBehalf(msg.sender, borrow);
                borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);
            }

            if (depositToken == longToken){
                (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);
                tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));
            }else{
                tv.borrowValue = borrow;
            }
        }

        require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) > vars.marginLimit, "MAM");
        tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);
        tv.depositAfterFees = deposit.sub(tv.fees);
        tv.dexDetail = dexData.toDexDetail();

        if (depositToken == longToken ){
            if (borrowed > 0){
                tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);
                tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);
            }
            tv.newHeld = tv.newHeld.add(tv.depositAfterFees);
        }else{
            tv.tradeSize = tv.depositAfterFees.add(borrowed);
            tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);
            tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);
        }

        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);
        trade.held = trade.held.add(tv.newHeld);
        trade.depositToken = depositToken;
        trade.deposited = trade.deposited.add(tv.depositAfterFees);
        trade.lastBlockNum = uint128(block.number);

        totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);

        require(OpenLevV1Lib.isPositionHealthy(
                msg.sender,
                true,
                OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),
                vars,
                dexData
            ), "PNH");

        emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail);
    }

    /// @notice Close trade by shares.
    /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param closeHeld Amount of shares to close.
    /// @param minOrMaxAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);

        //verify
        verifyCloseBefore(trade, marketVars, closeHeld, dexData);

        uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        Types.CloseTradeVars memory closeTradeVars;
        closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);
        closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);
        closeTradeVars.isPartialClose = closeHeld != trade.held;
        closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);
        closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        closeTradeVars.dexDetail = dexData.toDexDetail();

        //partial close
        if (closeTradeVars.isPartialClose) {
            closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);
            closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);
            trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);
        } else {
            closeTradeVars.depositDecrease = trade.deposited;
        }

        if (trade.depositToken != longToken) {
            minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);
            closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;
            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);

            closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);
            doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);
        } else {
            uint balance = marketVars.buyToken.balanceOf(address(this));
            minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);
            closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);
            closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);
            closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);
            require(marketVars.sellToken.balanceOf(address(this)) >= closeTradeVars.depositReturn, "ISB");
            doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);
        }

        uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));
        require(repayed >= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");

        if (!closeTradeVars.isPartialClose) {
            delete activeTrades[msg.sender][marketId][longToken];
        }else{
            trade.held = trade.held.sub(closeHeld);
            trade.lastBlockNum = uint128(block.number);
        }

        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);

        closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,
            closeTradeVars.token0Price, closeTradeVars.dexDetail);
    }

    /// @notice Liquidate if trade below margin limit.
    /// @dev For trades without sufficient funds to repay, use insurance.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param minBuy Slippage for Dex trading.
    /// @param maxSell Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade memory trade = activeTrades[owner][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());
        uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);
        require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");

        Types.LiquidateVars memory liquidateVars;
        liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);
        if (liquidateVars.penalty > 0) {
            doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);
        }
        liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);
        liquidateVars.dexDetail = dexData.toDexDetail();
        liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);
        liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        liquidateVars.marketId = marketId;
        liquidateVars.longToken = longToken;

        bool buySuccess;
        bytes memory sellAmountData;
        if (longToken == trade.depositToken) {
            maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);
            marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);
            (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(
                abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],
                taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)
            );
        }

        if (buySuccess) {
            {
                uint temp;
                assembly {
                    temp := mload(add(sellAmountData, 0x20))
                }
                liquidateVars.sellAmount = temp;
            }

            liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);
            marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
            liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);
            doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);
        } else {
            liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;
            liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);
            if (liquidateVars.receiveAmount >= liquidateVars.borrowed) {
                // fail if buy failed but sell succeeded
                require (longToken != trade.depositToken, "PH");
                marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
                liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);
                doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);
            } else {
                liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);
                liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);
                marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);
            }
        }

        liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);
        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);

        emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,
            trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);

        delete activeTrades[owner][marketId][longToken];
    }

    function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {
        return open == longToken ?
        Types.MarketVars(
            market.pool1,
            market.pool0,
            IERC20(market.token1),
            IERC20(market.token0),
            IERC20(market.token1).balanceOf(address(this)),
            IERC20(market.token0).balanceOf(address(this)),
            market.pool1Insurance,
            market.pool0Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs) :
        Types.MarketVars(
            market.pool0,
            market.pool1,
            IERC20(market.token0),
            IERC20(market.token1),
            IERC20(market.token0).balanceOf(address(this)),
            IERC20(market.token1).balanceOf(address(this)),
            market.pool0Insurance,
            market.pool1Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs);
    }

    /// @notice Get ratios of deposited token value to borrowed token value.
    /// @dev Caluclate ratio with current price and twap price.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param dexData Index and fee rate for the trading Dex.
    /// @return current Margin ratio calculated using current price.
    /// @return cAvg Margin ratio calculated using twap price.
    /// @return hAvg Margin ratio calculated using last recorded twap price.
    /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value.
    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {
        Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);
        limit = vars.marginLimit;
        (current, cAvg, hAvg,,) =
        OpenLevV1Lib.marginRatio(
            owner,
            activeTrades[owner][marketId][longToken].held,
            address(vars.sellToken),
            address(vars.buyToken),
            vars.buyPool,
            false,
            dexData
        );
    }

    /// @notice Check if a price update is required on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){
        Types.Market memory market = markets[marketId];
        return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData);
    }

    /// @notice Update price on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function updatePrice(uint16 marketId, bytes memory dexData) external override {
        OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData);
    }

    /// @notice List of all supporting Dexes.
    function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){
        return markets[marketId].dexs;
    }

    function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {
        Types.Market storage market = markets[marketId];
        uint needed = totalRepayment.sub(remaining);
        needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);
        maxCanRepayAmount = totalRepayment;
        if (longToken) {
            if (market.pool0Insurance >= needed) {
                market.pool0Insurance = market.pool0Insurance - needed;
                totalHelds[token] = totalHelds[token].sub(needed);
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);
                market.pool0Insurance = 0;
            }
        } else {
            if (market.pool1Insurance >= needed) {
                market.pool1Insurance = market.pool1Insurance - needed;
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);
                market.pool1Insurance = 0;
            }
        }
    }

    function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {
        // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);
        Types.Market storage market = markets[marketId];
        uint defaultFees = tradeSize.mul(market.feesRate).div(10000);
        uint newFees = defaultFees;
        // if trader holds more xOLE, then should enjoy trading discount.
        if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) > calculateConfig.feesDiscountThreshold) {
            newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));
        }
        // if trader update price, then should enjoy trading discount.
        if (market.priceUpdater == trader) {
            newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));
        }
        uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);
        IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));

        newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);
        if (token == market.token1) {
            market.pool1Insurance = market.pool1Insurance.add(newInsurance);
        } else {
            market.pool0Insurance = market.pool0Insurance.add(newInsurance);
        }

        totalHelds[token] = totalHelds[token].add(newInsurance);
        return newFees;
    }

    function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){
        if (sellAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);
            buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);
        }
    }

    function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){
        if (buyAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);
            sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);
        }
    }

    /// @dev All credited on this contract and share with all token holder if any rewards for the transfer.
    function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {
        return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount);
    }

    /// @dev All credited on "to" if any taxes for the transfer.
    function doTransferOut(address to, IERC20 token, uint amount) internal {
        OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount);
    }

    /*** Admin Functions ***/
    function setCalculateConfig(uint16 defaultFeesRate,
        uint8 insuranceRatio,
        uint16 defaultMarginLimit,
        uint16 priceDiffientRatio,
        uint16 updatePriceDiscount,
        uint16 feesDiscount,
        uint128 feesDiscountThreshold,
        uint16 penaltyRatio,
        uint8 maxLiquidationPriceDiffientRatio,
        uint16 twapDuration) external override onlyAdmin() {
        OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,
            feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);
        emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration);
    }

    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {
        OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);
        emit NewAddressConfig(controller, address(dexAggregator));
    }

    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {
        OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);
        emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs);
    }

    /// @notice List of all supporting Dexes.
    /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1
    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {
        Types.Market storage market = markets[marketId];
        if (poolIndex == 0) {
            market.pool0Insurance = market.pool0Insurance.sub(amount);
            (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));
            return;
        }
        market.pool1Insurance = market.pool1Insurance.sub(amount);
        (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this))));
    }

    function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {
        supportDexs[dex] = support;
    }

    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){
        taxes[marketId][token][index] = tax;
    }

    function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {
        Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];
        OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade);
    }

    function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {
        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());
        require(closeHeld <= trade.held, "CBH");
    }

    function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {
        require(held != 0 && lastBlockNumber != block.number && OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0");
    }

    modifier onlySupportDex(bytes memory dexData) {
        require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");
        _;
    }
}".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-24-08 18:27:14 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-24-08 18:27:14 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 13719
completion_tokens: 469
total_tokens: 14188
cost: $-1.000000


[2024-24-08 18:27:14 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;

pragma experimental ABIEncoderV2;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "./OpenLevInterface.sol";
import "./Types.sol";
import "./Adminable.sol";
import "./DelegateInterface.sol";
import "./ControllerInterface.sol";
import "./IWETH.sol";
import "./XOLEInterface.sol";
import "./Types.sol";
import "./OpenLevV1Lib.sol";

/// @title OpenLeverage margin trade logic
/// @author OpenLeverage
/// @notice Use this contract for margin trade.
/// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE.
contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {
    using SafeMath for uint;
    using TransferHelper for IERC20;
    using DexData for bytes;

    constructor ()
    {
    }

    /// @notice initialize proxy contract
    /// @dev This function is not supposed to call multiple times. All configs can be set through other functions.
    /// @param _controller Address of contract ControllerDelegator.
    /// @param _dexAggregator contract DexAggregatorDelegator.
    /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens.
    /// @param _wETH Address of wrapped native coin.
    /// @param _xOLE Address of XOLEDelegator.
    /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol.
    function initialize(
        address _controller,
        DexAggregatorInterface _dexAggregator,
        address[] memory depositTokens,
        address _wETH,
        address _xOLE,
        uint8[] memory _supportDexs
    ) public {
        depositTokens;
        require(msg.sender == admin, "NAD");
        addressConfig.controller = _controller;
        addressConfig.dexAggregator = _dexAggregator;
        addressConfig.wETH = _wETH;
        addressConfig.xOLE = _xOLE;
        for (uint i = 0; i < _supportDexs.length; i++) {
            supportDexs[_supportDexs[i]] = true;
        }
        OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig);
    }

    /// @notice Create new trading pair.
    /// @dev This function is typically called by ControllerDelegator.
    /// @param pool0 Contract LpoolDelegator, lending pool of token0.
    /// @param pool1 Contract LpoolDelegator, lending pool of token1.
    /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value.
    /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens.
    /// @return The new created pair ID.
    function addMarket(
        LPoolInterface pool0,
        LPoolInterface pool1,
        uint16 marginLimit,
        bytes memory dexData
    ) external override returns (uint16) {
        uint16 marketId = numPairs;
        OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);
        numPairs ++;
        return marketId;
    }

    /// @notice Margin trade or just add more deposit tokens.
    /// @dev To support token with tax and reward. Stores share of all token balances of this contract.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param depositToken Token to deposit. False for token0, true for token1.
    /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported.
    /// @param borrow Amount of ERC20 to borrow from the short token pool.
    /// @param minBuyAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function marginTrade(
        uint16 marketId,
        bool longToken,
        bool depositToken,
        uint deposit,
        uint borrow,
        uint minBuyAmount,
        bytes memory dexData
    ) external payable override nonReentrant onlySupportDex(dexData) {
        Types.TradeVars memory tv;
        Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);
        verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);
        (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);

        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);
        }

        tv.totalHeld = totalHelds[address(vars.buyToken)];
        tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;

        deposit = transferIn(msg.sender, tv.depositErc20, deposit);

        // Borrow
        uint borrowed;
        if (borrow > 0) {
            {
                uint balance = vars.sellToken.balanceOf(address(this));
                vars.sellPool.borrowBehalf(msg.sender, borrow);
                borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);
            }

            if (depositToken == longToken){
                (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);
                tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));
            }else{
                tv.borrowValue = borrow;
            }
        }

        require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) > vars.marginLimit, "MAM");
        tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);
        tv.depositAfterFees = deposit.sub(tv.fees);
        tv.dexDetail = dexData.toDexDetail();

        if (depositToken == longToken ){
            if (borrowed > 0){
                tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);
                tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);
            }
            tv.newHeld = tv.newHeld.add(tv.depositAfterFees);
        }else{
            tv.tradeSize = tv.depositAfterFees.add(borrowed);
            tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);
            tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);
        }

        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);
        trade.held = trade.held.add(tv.newHeld);
        trade.depositToken = depositToken;
        trade.deposited = trade.deposited.add(tv.depositAfterFees);
        trade.lastBlockNum = uint128(block.number);

        totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);

        require(OpenLevV1Lib.isPositionHealthy(
                msg.sender,
                true,
                OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),
                vars,
                dexData
            ), "PNH");

        emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail);
    }

    /// @notice Close trade by shares.
    /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param closeHeld Amount of shares to close.
    /// @param minOrMaxAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);

        //verify
        verifyCloseBefore(trade, marketVars, closeHeld, dexData);

        uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        Types.CloseTradeVars memory closeTradeVars;
        closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);
        closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);
        closeTradeVars.isPartialClose = closeHeld != trade.held;
        closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);
        closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        closeTradeVars.dexDetail = dexData.toDexDetail();

        //partial close
        if (closeTradeVars.isPartialClose) {
            closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);
            closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);
            trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);
        } else {
            closeTradeVars.depositDecrease = trade.deposited;
        }

        if (trade.depositToken != longToken) {
            minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);
            closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;
            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);

            closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);
            doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);
        } else {
            uint balance = marketVars.buyToken.balanceOf(address(this));
            minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);
            closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);
            closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);
            closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);
            require(marketVars.sellToken.balanceOf(address(this)) >= closeTradeVars.depositReturn, "ISB");
            doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);
        }

        uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));
        require(repayed >= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");

        if (!closeTradeVars.isPartialClose) {
            delete activeTrades[msg.sender][marketId][longToken];
        }else{
            trade.held = trade.held.sub(closeHeld);
            trade.lastBlockNum = uint128(block.number);
        }

        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);

        closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,
            closeTradeVars.token0Price, closeTradeVars.dexDetail);
    }

    /// @notice Liquidate if trade below margin limit.
    /// @dev For trades without sufficient funds to repay, use insurance.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param minBuy Slippage for Dex trading.
    /// @param maxSell Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade memory trade = activeTrades[owner][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());
        uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);
        require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");

        Types.LiquidateVars memory liquidateVars;
        liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);
        if (liquidateVars.penalty > 0) {
            doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);
        }
        liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);
        liquidateVars.dexDetail = dexData.toDexDetail();
        liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);
        liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        liquidateVars.marketId = marketId;
        liquidateVars.longToken = longToken;

        bool buySuccess;
        bytes memory sellAmountData;
        if (longToken == trade.depositToken) {
            maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);
            marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);
            (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(
                abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],
                taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)
            );
        }

        if (buySuccess) {
            {
                uint temp;
                assembly {
                    temp := mload(add(sellAmountData, 0x20))
                }
                liquidateVars.sellAmount = temp;
            }

            liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);
            marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
            liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);
            doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);
        } else {
            liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;
            liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);
            if (liquidateVars.receiveAmount >= liquidateVars.borrowed) {
                // fail if buy failed but sell succeeded
                require (longToken != trade.depositToken, "PH");
                marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
                liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);
                doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);
            } else {
                liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);
                liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);
                marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);
            }
        }

        liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);
        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);

        emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,
            trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);

        delete activeTrades[owner][marketId][longToken];
    }

    function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {
        return open == longToken ?
        Types.MarketVars(
            market.pool1,
            market.pool0,
            IERC20(market.token1),
            IERC20(market.token0),
            IERC20(market.token1).balanceOf(address(this)),
            IERC20(market.token0).balanceOf(address(this)),
            market.pool1Insurance,
            market.pool0Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs) :
        Types.MarketVars(
            market.pool0,
            market.pool1,
            IERC20(market.token0),
            IERC20(market.token1),
            IERC20(market.token0).balanceOf(address(this)),
            IERC20(market.token1).balanceOf(address(this)),
            market.pool0Insurance,
            market.pool1Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs);
    }

    /// @notice Get ratios of deposited token value to borrowed token value.
    /// @dev Caluclate ratio with current price and twap price.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param dexData Index and fee rate for the trading Dex.
    /// @return current Margin ratio calculated using current price.
    /// @return cAvg Margin ratio calculated using twap price.
    /// @return hAvg Margin ratio calculated using last recorded twap price.
    /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value.
    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {
        Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);
        limit = vars.marginLimit;
        (current, cAvg, hAvg,,) =
        OpenLevV1Lib.marginRatio(
            owner,
            activeTrades[owner][marketId][longToken].held,
            address(vars.sellToken),
            address(vars.buyToken),
            vars.buyPool,
            false,
            dexData
        );
    }

    /// @notice Check if a price update is required on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){
        Types.Market memory market = markets[marketId];
        return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData);
    }

    /// @notice Update price on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function updatePrice(uint16 marketId, bytes memory dexData) external override {
        OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData);
    }

    /// @notice List of all supporting Dexes.
    function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){
        return markets[marketId].dexs;
    }

    function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {
        Types.Market storage market = markets[marketId];
        uint needed = totalRepayment.sub(remaining);
        needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);
        maxCanRepayAmount = totalRepayment;
        if (longToken) {
            if (market.pool0Insurance >= needed) {
                market.pool0Insurance = market.pool0Insurance - needed;
                totalHelds[token] = totalHelds[token].sub(needed);
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);
                market.pool0Insurance = 0;
            }
        } else {
            if (market.pool1Insurance >= needed) {
                market.pool1Insurance = market.pool1Insurance - needed;
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);
                market.pool1Insurance = 0;
            }
        }
    }

    function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {
        // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);
        Types.Market storage market = markets[marketId];
        uint defaultFees = tradeSize.mul(market.feesRate).div(10000);
        uint newFees = defaultFees;
        // if trader holds more xOLE, then should enjoy trading discount.
        if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) > calculateConfig.feesDiscountThreshold) {
            newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));
        }
        // if trader update price, then should enjoy trading discount.
        if (market.priceUpdater == trader) {
            newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));
        }
        uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);
        IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));

        newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);
        if (token == market.token1) {
            market.pool1Insurance = market.pool1Insurance.add(newInsurance);
        } else {
            market.pool0Insurance = market.pool0Insurance.add(newInsurance);
        }

        totalHelds[token] = totalHelds[token].add(newInsurance);
        return newFees;
    }

    function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){
        if (sellAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);
            buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);
        }
    }

    function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){
        if (buyAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);
            sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);
        }
    }

    /// @dev All credited on this contract and share with all token holder if any rewards for the transfer.
    function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {
        return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount);
    }

    /// @dev All credited on "to" if any taxes for the transfer.
    function doTransferOut(address to, IERC20 token, uint amount) internal {
        OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount);
    }

    /*** Admin Functions ***/
    function setCalculateConfig(uint16 defaultFeesRate,
        uint8 insuranceRatio,
        uint16 defaultMarginLimit,
        uint16 priceDiffientRatio,
        uint16 updatePriceDiscount,
        uint16 feesDiscount,
        uint128 feesDiscountThreshold,
        uint16 penaltyRatio,
        uint8 maxLiquidationPriceDiffientRatio,
        uint16 twapDuration) external override onlyAdmin() {
        OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,
            feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);
        emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration);
    }

    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {
        OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);
        emit NewAddressConfig(controller, address(dexAggregator));
    }

    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {
        OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);
        emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs);
    }

    /// @notice List of all supporting Dexes.
    /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1
    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {
        Types.Market storage market = markets[marketId];
        if (poolIndex == 0) {
            market.pool0Insurance = market.pool0Insurance.sub(amount);
            (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));
            return;
        }
        market.pool1Insurance = market.pool1Insurance.sub(amount);
        (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this))));
    }

    function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {
        supportDexs[dex] = support;
    }

    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){
        taxes[marketId][token][index] = tax;
    }

    function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {
        Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];
        OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade);
    }

    function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {
        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());
        require(closeHeld <= trade.held, "CBH");
    }

    function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {
        require(held != 0 && lastBlockNumber != block.number && OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0");
    }

    modifier onlySupportDex(bytes memory dexData) {
        require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");
        _;
    }
}.]

Let's start by analyzing the provided Solidity contract code. Here are some potential areas for improvement or enhancement:

1. **Access Control**: The contract uses a single admin for critical functions. Implementing a multi-signature wallet for administrative functions could enhance security by requiring multiple approvals for sensitive actions.

2. **Gas Optimization**: There are several places where the code could be optimized for gas usage. For example, using `memory` instead of `storage` where appropriate, or minimizing the number of state variable updates in functions could help reduce gas costs.

3. **Error Handling**: The contract uses `require` statements for error handling, which is good, but it could benefit from more descriptive error messages. This would make debugging easier and provide clearer feedback to users.

4. **Event Emission**: While there are some events emitted, ensuring that all state-changing functions emit relevant events can improve transparency and allow for better tracking of contract activity.

5. **Reentrancy Protection**: The contract uses `ReentrancyGuard`, which is great. However, we should ensure that all external calls are made at the end of the function to minimize the risk of reentrancy attacks.

6. **Upgradeability**: Consider implementing a proxy pattern for upgradeability. This would allow the contract to be upgraded in the future without losing state or requiring users to migrate to a new contract.

7. **Testing and Auditing**: Ensure comprehensive unit tests are in place, especially for critical functions like `marginTrade`, `closeTrade`, and `liquidate`. Additionally, a third-party audit could help identify vulnerabilities that may not be apparent during internal testing.

8. **Input Validation**: More rigorous input validation could be added, especially for parameters like `marketId`, `deposit`, and `borrow`. This would help prevent unexpected behavior from invalid inputs.

9. **Documentation**: While there are comments in the code, enhancing the documentation to include more detailed explanations of complex functions and their parameters would be beneficial for future developers.

10. **Emergency Mechanism**: Implementing an emergency stop mechanism (circuit breaker) would allow the admin to pause contract operations in case of a detected vulnerability or exploit.

Which of these suggestions resonates most with you, or do you have any other specific areas you would like to focus on?

[2024-24-08 18:27:14 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.7.6; pragma experimental ABIEncoderV2; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import "./OpenLevInterface.sol"; import "./Types.sol"; import "./Adminable.sol"; import "./DelegateInterface.sol"; import "./ControllerInterface.sol"; import "./IWETH.sol"; import "./XOLEInterface.sol"; import "./Types.sol"; import "./OpenLevV1Lib.sol"; /// @title OpenLeverage margin trade logic /// @author OpenLeverage /// @notice Use this contract for margin trade. /// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE. contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {     using SafeMath for uint;     using TransferHelper for IERC20;     using DexData for bytes; constructor () { }  /// @notice initialize proxy contract /// @dev This function is not supposed to call multiple times. All configs can be set through other functions. /// @param _controller Address of contract ControllerDelegator. /// @param _dexAggregator contract DexAggregatorDelegator. /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens. /// @param _wETH Address of wrapped native coin. /// @param _xOLE Address of XOLEDelegator. /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol. function initialize(     address _controller,     DexAggregatorInterface _dexAggregator,     address[] memory depositTokens,     address _wETH,     address _xOLE,     uint8[] memory _supportDexs ) public {     depositTokens;     require(msg.sender == admin, "NAD");     addressConfig.controller = _controller;     addressConfig.dexAggregator = _dexAggregator;     addressConfig.wETH = _wETH;     addressConfig.xOLE = _xOLE;     for (uint i = 0; i &lt; _supportDexs.length; i++) {         supportDexs[_supportDexs[i]] = true;     }     OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig); }  /// @notice Create new trading pair. /// @dev This function is typically called by ControllerDelegator. /// @param pool0 Contract LpoolDelegator, lending pool of token0. /// @param pool1 Contract LpoolDelegator, lending pool of token1. /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value. /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens. /// @return The new created pair ID. function addMarket(     LPoolInterface pool0,     LPoolInterface pool1,     uint16 marginLimit,     bytes memory dexData ) external override returns (uint16) {     uint16 marketId = numPairs;     OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);     numPairs ++;     return marketId; }  /// @notice Margin trade or just add more deposit tokens. /// @dev To support token with tax and reward. Stores share of all token balances of this contract. /// @param longToken Token to long. False for token0, true for token1. /// @param depositToken Token to deposit. False for token0, true for token1. /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported. /// @param borrow Amount of ERC20 to borrow from the short token pool. /// @param minBuyAmount Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function marginTrade(     uint16 marketId,     bool longToken,     bool depositToken,     uint deposit,     uint borrow,     uint minBuyAmount,     bytes memory dexData ) external payable override nonReentrant onlySupportDex(dexData) {     Types.TradeVars memory tv;     Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);     verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);     (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);      if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);     }      tv.totalHeld = totalHelds[address(vars.buyToken)];     tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;      deposit = transferIn(msg.sender, tv.depositErc20, deposit);      // Borrow     uint borrowed;     if (borrow &gt; 0) {         {             uint balance = vars.sellToken.balanceOf(address(this));             vars.sellPool.borrowBehalf(msg.sender, borrow);             borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);         }          if (depositToken == longToken){             (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);             tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));         }else{             tv.borrowValue = borrow;         }     }      require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) &gt; vars.marginLimit, "MAM");     tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);     tv.depositAfterFees = deposit.sub(tv.fees);     tv.dexDetail = dexData.toDexDetail();      if (depositToken == longToken ){         if (borrowed &gt; 0){             tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);             tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);         }         tv.newHeld = tv.newHeld.add(tv.depositAfterFees);     }else{         tv.tradeSize = tv.depositAfterFees.add(borrowed);         tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);         tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);     }      Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];     tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);     trade.held = trade.held.add(tv.newHeld);     trade.depositToken = depositToken;     trade.deposited = trade.deposited.add(tv.depositAfterFees);     trade.lastBlockNum = uint128(block.number);      totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);      require(OpenLevV1Lib.isPositionHealthy(             msg.sender,             true,             OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),             vars,             dexData         ), "PNH");      emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail); }  /// @notice Close trade by shares. /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed. /// @param longToken Token to long. False for token0, true for token1. /// @param closeHeld Amount of shares to close. /// @param minOrMaxAmount Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {     Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];     Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);      //verify     verifyCloseBefore(trade, marketVars, closeHeld, dexData);      uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);      Types.CloseTradeVars memory closeTradeVars;     closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);     closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);     closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);     closeTradeVars.isPartialClose = closeHeld != trade.held;     closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);     closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);     closeTradeVars.dexDetail = dexData.toDexDetail();      //partial close     if (closeTradeVars.isPartialClose) {         closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);         closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);         trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);     } else {         closeTradeVars.depositDecrease = trade.deposited;     }      if (trade.depositToken != longToken) {         minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);         closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);         require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");          closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;         marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);          closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);         doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);     } else {         uint balance = marketVars.buyToken.balanceOf(address(this));         minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);         closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);         closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);         require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");          marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);         closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);         require(marketVars.sellToken.balanceOf(address(this)) &gt;= closeTradeVars.depositReturn, "ISB");         doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);     }      uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));     require(repayed &gt;= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");      if (!closeTradeVars.isPartialClose) {         delete activeTrades[msg.sender][marketId][longToken];     }else{         trade.held = trade.held.sub(closeHeld);         trade.lastBlockNum = uint128(block.number);     }      totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);      closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);     if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);     }      emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,         closeTradeVars.token0Price, closeTradeVars.dexDetail); }  /// @notice Liquidate if trade below margin limit. /// @dev For trades without sufficient funds to repay, use insurance. /// @param owner Owner of the trade to liquidate. /// @param longToken Token to long. False for token0, true for token1. /// @param minBuy Slippage for Dex trading. /// @param maxSell Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {     Types.Trade memory trade = activeTrades[owner][marketId][longToken];     Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);     if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);     }      verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());     uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);      (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);     require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");      Types.LiquidateVars memory liquidateVars;     liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);     liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);     if (liquidateVars.penalty &gt; 0) {         doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);     }     liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);     liquidateVars.dexDetail = dexData.toDexDetail();     liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);     liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);     liquidateVars.marketId = marketId;     liquidateVars.longToken = longToken;      bool buySuccess;     bytes memory sellAmountData;     if (longToken == trade.depositToken) {         maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);         marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);         (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(             abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],             taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)         );     }      if (buySuccess) {         {             uint temp;             assembly {                 temp := mload(add(sellAmountData, 0x20))             }             liquidateVars.sellAmount = temp;         }          liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);         marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);         liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);         doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);     } else {         liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;         liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);         if (liquidateVars.receiveAmount &gt;= liquidateVars.borrowed) {             // fail if buy failed but sell succeeded             require (longToken != trade.depositToken, "PH");             marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);             liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);             doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);         } else {             liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);             liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);             marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);         }     }      liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);     totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);      emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,         trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);      delete activeTrades[owner][marketId][longToken]; }  function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {     return open == longToken ?     Types.MarketVars(         market.pool1,         market.pool0,         IERC20(market.token1),         IERC20(market.token0),         IERC20(market.token1).balanceOf(address(this)),         IERC20(market.token0).balanceOf(address(this)),         market.pool1Insurance,         market.pool0Insurance,         market.marginLimit,         market.priceDiffientRatio,         market.dexs) :     Types.MarketVars(         market.pool0,         market.pool1,         IERC20(market.token0),         IERC20(market.token1),         IERC20(market.token0).balanceOf(address(this)),         IERC20(market.token1).balanceOf(address(this)),         market.pool0Insurance,         market.pool1Insurance,         market.marginLimit,         market.priceDiffientRatio,         market.dexs); }  /// @notice Get ratios of deposited token value to borrowed token value. /// @dev Caluclate ratio with current price and twap price. /// @param owner Owner of the trade to liquidate. /// @param longToken Token to long. False for token0, true for token1. /// @param dexData Index and fee rate for the trading Dex. /// @return current Margin ratio calculated using current price. /// @return cAvg Margin ratio calculated using twap price. /// @return hAvg Margin ratio calculated using last recorded twap price. /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value. function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {     Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);     limit = vars.marginLimit;     (current, cAvg, hAvg,,) =     OpenLevV1Lib.marginRatio(         owner,         activeTrades[owner][marketId][longToken].held,         address(vars.sellToken),         address(vars.buyToken),         vars.buyPool,         false,         dexData     ); }  /// @notice Check if a price update is required on Dex. /// @param dexData Index and fee rate for the trading Dex. function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){     Types.Market memory market = markets[marketId];     return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData); }  /// @notice Update price on Dex. /// @param dexData Index and fee rate for the trading Dex. function updatePrice(uint16 marketId, bytes memory dexData) external override {     OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData); }  /// @notice List of all supporting Dexes. function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){     return markets[marketId].dexs; }  function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {     Types.Market storage market = markets[marketId];     uint needed = totalRepayment.sub(remaining);     needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);     maxCanRepayAmount = totalRepayment;     if (longToken) {         if (market.pool0Insurance &gt;= needed) {             market.pool0Insurance = market.pool0Insurance - needed;             totalHelds[token] = totalHelds[token].sub(needed);         } else {             maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);             maxCanRepayAmount = maxCanRepayAmount.add(remaining);             totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);             market.pool0Insurance = 0;         }     } else {         if (market.pool1Insurance &gt;= needed) {             market.pool1Insurance = market.pool1Insurance - needed;         } else {             maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);             maxCanRepayAmount = maxCanRepayAmount.add(remaining);             totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);             market.pool1Insurance = 0;         }     } }  function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {     // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);     Types.Market storage market = markets[marketId];     uint defaultFees = tradeSize.mul(market.feesRate).div(10000);     uint newFees = defaultFees;     // if trader holds more xOLE, then should enjoy trading discount.     if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) &gt; calculateConfig.feesDiscountThreshold) {         newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));     }     // if trader update price, then should enjoy trading discount.     if (market.priceUpdater == trader) {         newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));     }     uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);     IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));      newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);     if (token == market.token1) {         market.pool1Insurance = market.pool1Insurance.add(newInsurance);     } else {         market.pool0Insurance = market.pool0Insurance.add(newInsurance);     }      totalHelds[token] = totalHelds[token].add(newInsurance);     return newFees; }  function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){     if (sellAmount &gt; 0){         DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;         IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);         buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);     } }  function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){     if (buyAmount &gt; 0){         DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;         IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);         sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);     } }  /// @dev All credited on this contract and share with all token holder if any rewards for the transfer. function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {     return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount); }  /// @dev All credited on "to" if any taxes for the transfer. function doTransferOut(address to, IERC20 token, uint amount) internal {     OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount); }  /*** Admin Functions ***/ function setCalculateConfig(uint16 defaultFeesRate,     uint8 insuranceRatio,     uint16 defaultMarginLimit,     uint16 priceDiffientRatio,     uint16 updatePriceDiscount,     uint16 feesDiscount,     uint128 feesDiscountThreshold,     uint16 penaltyRatio,     uint8 maxLiquidationPriceDiffientRatio,     uint16 twapDuration) external override onlyAdmin() {     OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,         feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);     emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration); }  function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {     OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);     emit NewAddressConfig(controller, address(dexAggregator)); }  function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {     OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);     emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs); }  /// @notice List of all supporting Dexes. /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1 function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {     Types.Market storage market = markets[marketId];     if (poolIndex == 0) {         market.pool0Insurance = market.pool0Insurance.sub(amount);         (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));         return;     }     market.pool1Insurance = market.pool1Insurance.sub(amount);     (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this)))); }  function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {     supportDexs[dex] = support; }  function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){     taxes[marketId][token][index] = tax; }  function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {     Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];     OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade); }  function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {     verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());     require(closeHeld &lt;= trade.held, "CBH"); }  function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {     require(held != 0 &amp;&amp; lastBlockNumber != block.number &amp;&amp; OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0"); }  modifier onlySupportDex(bytes memory dexData) {     require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");     _; }  } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: // SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\nimport "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\nimport "./OpenLevInterface.sol";\nimport "./Types.sol";\nimport "./Adminable.sol";\nimport "./DelegateInterface.sol";\nimport "./ControllerInterface.sol";\nimport "./IWETH.sol";\nimport "./XOLEInterface.sol";\nimport "./Types.sol";\nimport "./OpenLevV1Lib.sol";\n/// @title OpenLeverage margin trade logic\n/// @author OpenLeverage\n/// @notice Use this contract for margin trade.\n/// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE.\ncontract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {\n    using SafeMath for uint;\n    using TransferHelper for IERC20;\n    using DexData for bytes;\n    constructor ()\n    {\n    }\n    /// @notice initialize proxy contract\n    /// @dev This function is not supposed to call multiple times. All configs can be set through other functions.\n    /// @param controller Address of contract ControllerDelegator.\n    /// @param _dexAggregator contract DexAggregatorDelegator.\n    /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens.\n    /// @param _wETH Address of wrapped native coin.\n    /// @param _xOLE Address of XOLEDelegator.\n    /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol.\n    function initialize(\n        address _controller,\n        DexAggregatorInterface _dexAggregator,\n        address[] memory depositTokens,\n        address _wETH,\n        address _xOLE,\n        uint8[] memory _supportDexs\n    ) public {\n        depositTokens;\n        require(msg.sender == admin, "NAD");\n        addressConfig.controller = _controller;\n        addressConfig.dexAggregator = _dexAggregator;\n        addressConfig.wETH = _wETH;\n        addressConfig.xOLE = _xOLE;\n        for (uint i = 0; i &lt; _supportDexs.length; i++) {\n            supportDexs[_supportDexs[i]] = true;\n        }\n        OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig);\n    }\n    /// @notice Create new trading pair.\n    /// @dev This function is typically called by ControllerDelegator.\n    /// @param pool0 Contract LpoolDelegator, lending pool of token0.\n    /// @param pool1 Contract LpoolDelegator, lending pool of token1.\n    /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value.\n    /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens.\n    /// @return The new created pair ID.\n    function addMarket(\n        LPoolInterface pool0,\n        LPoolInterface pool1,\n        uint16 marginLimit,\n        bytes memory dexData\n    ) external override returns (uint16) {\n        uint16 marketId = numPairs;\n        OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);\n        numPairs ++;\n        return marketId;\n    }\n    /// @notice Margin trade or just add more deposit tokens.\n    /// @dev To support token with tax and reward. Stores share of all token balances of this contract.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param depositToken Token to deposit. False for token0, true for token1.\n    /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported.\n    /// @param borrow Amount of ERC20 to borrow from the short token pool.\n    /// @param minBuyAmount Slippage for Dex trading.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function marginTrade(\n        uint16 marketId,\n        bool longToken,\n        bool depositToken,\n        uint deposit,\n        uint borrow,\n        uint minBuyAmount,\n        bytes memory dexData\n    ) external payable override nonReentrant onlySupportDex(dexData) {\n        Types.TradeVars memory tv;\n        Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);\n        verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);\n        (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);\n        if (dexData.isUniV2Class()) {\n            OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);\n        }\n        tv.totalHeld = totalHelds[address(vars.buyToken)];\n        tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;\n        deposit = transferIn(msg.sender, tv.depositErc20, deposit);\n        // Borrow\n        uint borrowed;\n        if (borrow &gt; 0) {\n            {\n                uint balance = vars.sellToken.balanceOf(address(this));\n                vars.sellPool.borrowBehalf(msg.sender, borrow);\n                borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);\n            }\n            if (depositToken == longToken){\n                (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);\n                tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));\n            }else{\n                tv.borrowValue = borrow;\n            }\n        }\n        require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) &gt; vars.marginLimit, "MAM");\n        tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);\n        tv.depositAfterFees = deposit.sub(tv.fees);\n        tv.dexDetail = dexData.toDexDetail();\n        if (depositToken == longToken ){\n            if (borrowed &gt; 0){\n                tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);\n                tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);\n            }\n            tv.newHeld = tv.newHeld.add(tv.depositAfterFees);\n        }else{\n            tv.tradeSize = tv.depositAfterFees.add(borrowed);\n            tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);\n            tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);\n        }\n        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];\n        tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);\n        trade.held = trade.held.add(tv.newHeld);\n        trade.depositToken = depositToken;\n        trade.deposited = trade.deposited.add(tv.depositAfterFees);\n        trade.lastBlockNum = uint128(block.number);\n        totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);\n        require(OpenLevV1Lib.isPositionHealthy(\n                msg.sender,\n                true,\n                OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),\n                vars,\n                dexData\n            ), "PNH");\n        emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail);\n    }\n    /// @notice Close trade by shares.\n    /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param closeHeld Amount of shares to close.\n    /// @param minOrMaxAmount Slippage for Dex trading.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {\n        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];\n        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);\n        //verify\n        verifyCloseBefore(trade, marketVars, closeHeld, dexData);\n        uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n        Types.CloseTradeVars memory closeTradeVars;\n        closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n        closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);\n        closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);\n        closeTradeVars.isPartialClose = closeHeld != trade.held;\n        closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);\n        closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);\n        closeTradeVars.dexDetail = dexData.toDexDetail();\n        //partial close\n        if (closeTradeVars.isPartialClose) {\n            closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);\n            closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);\n            trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);\n        } else {\n            closeTradeVars.depositDecrease = trade.deposited;\n        }\n        if (trade.depositToken != longToken) {\n            minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);\n            closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);\n            require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");\n            closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;\n            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);\n            closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);\n            doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);\n        } else {\n            uint balance = marketVars.buyToken.balanceOf(address(this));\n            minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);\n            closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);\n            closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);\n            require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");\n            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);\n            closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);\n            require(marketVars.sellToken.balanceOf(address(this)) &gt;= closeTradeVars.depositReturn, "ISB");\n            doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);\n        }\n        uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));\n        require(repayed &gt;= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");\n        if (!closeTradeVars.isPartialClose) {\n            delete activeTrades[msg.sender][marketId][longToken];\n        }else{\n            trade.held = trade.held.sub(closeHeld);\n            trade.lastBlockNum = uint128(block.number);\n        }\n        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);\n        closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);\n        if (dexData.isUniV2Class()) {\n            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);\n        }\n        emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,\n            closeTradeVars.token0Price, closeTradeVars.dexDetail);\n    }\n    /// @notice Liquidate if trade below margin limit.\n    /// @dev For trades without sufficient funds to repay, use insurance.\n    /// @param owner Owner of the trade to liquidate.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param minBuy Slippage for Dex trading.\n    /// @param maxSell Slippage for Dex trading.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {\n        Types.Trade memory trade = activeTrades[owner][marketId][longToken];\n        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);\n        if (dexData.isUniV2Class()) {\n            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);\n        }\n        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());\n        uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n        (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);\n        require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");\n        Types.LiquidateVars memory liquidateVars;\n        liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n        liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);\n        if (liquidateVars.penalty &gt; 0) {\n            doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);\n        }\n        liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);\n        liquidateVars.dexDetail = dexData.toDexDetail();\n        liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);\n        liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);\n        liquidateVars.marketId = marketId;\n        liquidateVars.longToken = longToken;\n        bool buySuccess;\n        bytes memory sellAmountData;\n        if (longToken == trade.depositToken) {\n            maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);\n            marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);\n            (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(\n                abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],\n                taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)\n            );\n        }\n        if (buySuccess) {\n            {\n                uint temp;\n                assembly {\n                    temp := mload(add(sellAmountData, 0x20))\n                }\n                liquidateVars.sellAmount = temp;\n            }\n            liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);\n            marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);\n            liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);\n            doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);\n        } else {\n            liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;\n            liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);\n            if (liquidateVars.receiveAmount &gt;= liquidateVars.borrowed) {\n                // fail if buy failed but sell succeeded\n                require (longToken != trade.depositToken, "PH");\n                marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);\n                liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);\n                doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);\n            } else {\n                liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);\n                liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);\n                marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);\n            }\n        }\n        liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);\n        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);\n        emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,\n            trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);\n        delete activeTrades[owner][marketId][longToken];\n    }\n    function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {\n        return open == longToken ?\n        Types.MarketVars(\n            market.pool1,\n            market.pool0,\n            IERC20(market.token1),\n            IERC20(market.token0),\n            IERC20(market.token1).balanceOf(address(this)),\n            IERC20(market.token0).balanceOf(address(this)),\n            market.pool1Insurance,\n            market.pool0Insurance,\n            market.marginLimit,\n            market.priceDiffientRatio,\n            market.dexs) :\n        Types.MarketVars(\n            market.pool0,\n            market.pool1,\n            IERC20(market.token0),\n            IERC20(market.token1),\n            IERC20(market.token0).balanceOf(address(this)),\n            IERC20(market.token1).balanceOf(address(this)),\n            market.pool0Insurance,\n            market.pool1Insurance,\n            market.marginLimit,\n            market.priceDiffientRatio,\n            market.dexs);\n    }\n    /// @notice Get ratios of deposited token value to borrowed token value.\n    /// @dev Caluclate ratio with current price and twap price.\n    /// @param owner Owner of the trade to liquidate.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param dexData Index and fee rate for the trading Dex.\n    /// @return current Margin ratio calculated using current price.\n    /// @return cAvg Margin ratio calculated using twap price.\n    /// @return hAvg Margin ratio calculated using last recorded twap price.\n    /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value.\n    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {\n        Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);\n        limit = vars.marginLimit;\n        (current, cAvg, hAvg,,) =\n        OpenLevV1Lib.marginRatio(\n            owner,\n            activeTrades[owner][marketId][longToken].held,\n            address(vars.sellToken),\n            address(vars.buyToken),\n            vars.buyPool,\n            false,\n            dexData\n        );\n    }\n    /// @notice Check if a price update is required on Dex.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){\n        Types.Market memory market = markets[marketId];\n        return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData);\n    }\n    /// @notice Update price on Dex.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function updatePrice(uint16 marketId, bytes memory dexData) external override {\n        OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData);\n    }\n    /// @notice List of all supporting Dexes.\n    function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){\n        return markets[marketId].dexs;\n    }\n    function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {\n        Types.Market storage market = markets[marketId];\n        uint needed = totalRepayment.sub(remaining);\n        needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);\n        maxCanRepayAmount = totalRepayment;\n        if (longToken) {\n            if (market.pool0Insurance &gt;= needed) {\n                market.pool0Insurance = market.pool0Insurance - needed;\n                totalHelds[token] = totalHelds[token].sub(needed);\n            } else {\n                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);\n                maxCanRepayAmount = maxCanRepayAmount.add(remaining);\n                totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);\n                market.pool0Insurance = 0;\n            }\n        } else {\n            if (market.pool1Insurance &gt;= needed) {\n                market.pool1Insurance = market.pool1Insurance - needed;\n            } else {\n                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);\n                maxCanRepayAmount = maxCanRepayAmount.add(remaining);\n                totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);\n                market.pool1Insurance = 0;\n            }\n        }\n    }\n    function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {\n        // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);\n        Types.Market storage market = markets[marketId];\n        uint defaultFees = tradeSize.mul(market.feesRate).div(10000);\n        uint newFees = defaultFees;\n        // if trader holds more xOLE, then should enjoy trading discount.\n        if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) &gt; calculateConfig.feesDiscountThreshold) {\n            newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));\n        }\n        // if trader update price, then should enjoy trading discount.\n        if (market.priceUpdater == trader) {\n            newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));\n        }\n        uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);\n        IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));\n        newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);\n        if (token == market.token1) {\n            market.pool1Insurance = market.pool1Insurance.add(newInsurance);\n        } else {\n            market.pool0Insurance = market.pool0Insurance.add(newInsurance);\n        }\n        totalHelds[token] = totalHelds[token].add(newInsurance);\n        return newFees;\n    }\n    function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){\n        if (sellAmount &gt; 0){\n            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;\n            IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);\n            buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);\n        }\n    }\n    function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){\n        if (buyAmount &gt; 0){\n            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;\n            IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);\n            sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);\n        }\n    }\n    /// @dev All credited on this contract and share with all token holder if any rewards for the transfer.\n    function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {\n        return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount);\n    }\n    /// @dev All credited on "to" if any taxes for the transfer.\n    function doTransferOut(address to, IERC20 token, uint amount) internal {\n        OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount);\n    }\n    / Admin Functions /\n    function setCalculateConfig(uint16 defaultFeesRate,\n        uint8 insuranceRatio,\n        uint16 defaultMarginLimit,\n        uint16 priceDiffientRatio,\n        uint16 updatePriceDiscount,\n        uint16 feesDiscount,\n        uint128 feesDiscountThreshold,\n        uint16 penaltyRatio,\n        uint8 maxLiquidationPriceDiffientRatio,\n        uint16 twapDuration) external override onlyAdmin() {\n        OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,\n            feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);\n        emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration);\n    }\n    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {\n        OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);\n        emit NewAddressConfig(controller, address(dexAggregator));\n    }\n    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {\n        OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);\n        emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs);\n    }\n    /// @notice List of all supporting Dexes.\n    /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1\n    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {\n        Types.Market storage market = markets[marketId];\n        if (poolIndex == 0) {\n            market.pool0Insurance = market.pool0Insurance.sub(amount);\n            (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));\n            return;\n        }\n        market.pool1Insurance = market.pool1Insurance.sub(amount);\n        (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this))));\n    }\n    function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {\n        supportDexs[dex] = support;\n    }\n    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){\n        taxes[marketId][token][index] = tax;\n    }\n    function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {\n        Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];\n        OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade);\n    }\n    function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {\n        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());\n        require(closeHeld &lt;= trade.held, "CBH");\n    }\n    function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {\n        require(held != 0 &amp;&amp; lastBlockNumber != block.number &amp;&amp; OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0");\n    }\n    modifier onlySupportDex(bytes memory dexData) {\n        require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");\n        ;\n    }\n}.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\nimport "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\nimport "./OpenLevInterface.sol";\nimport "./Types.sol";\nimport "./Adminable.sol";\nimport "./DelegateInterface.sol";\nimport "./ControllerInterface.sol";\nimport "./IWETH.sol";\nimport "./XOLEInterface.sol";\nimport "./Types.sol";\nimport "./OpenLevV1Lib.sol";\n/// @title OpenLeverage margin trade logic\n/// @author OpenLeverage\n/// @notice Use this contract for margin trade.\n/// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE.\ncontract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {\n    using SafeMath for uint;\n    using TransferHelper for IERC20;\n    using DexData for bytes;\n    constructor ()\n    {\n    }\n    /// @notice initialize proxy contract\n    /// @dev This function is not supposed to call multiple times. All configs can be set through other functions.\n    /// @param controller Address of contract ControllerDelegator.\n    /// @param _dexAggregator contract DexAggregatorDelegator.\n    /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens.\n    /// @param _wETH Address of wrapped native coin.\n    /// @param _xOLE Address of XOLEDelegator.\n    /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol.\n    function initialize(\n        address _controller,\n        DexAggregatorInterface _dexAggregator,\n        address[] memory depositTokens,\n        address _wETH,\n        address _xOLE,\n        uint8[] memory _supportDexs\n    ) public {\n        depositTokens;\n        require(msg.sender == admin, "NAD");\n        addressConfig.controller = _controller;\n        addressConfig.dexAggregator = _dexAggregator;\n        addressConfig.wETH = _wETH;\n        addressConfig.xOLE = _xOLE;\n        for (uint i = 0; i &lt; _supportDexs.length; i++) {\n            supportDexs[_supportDexs[i]] = true;\n        }\n        OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig);\n    }\n    /// @notice Create new trading pair.\n    /// @dev This function is typically called by ControllerDelegator.\n    /// @param pool0 Contract LpoolDelegator, lending pool of token0.\n    /// @param pool1 Contract LpoolDelegator, lending pool of token1.\n    /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value.\n    /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens.\n    /// @return The new created pair ID.\n    function addMarket(\n        LPoolInterface pool0,\n        LPoolInterface pool1,\n        uint16 marginLimit,\n        bytes memory dexData\n    ) external override returns (uint16) {\n        uint16 marketId = numPairs;\n        OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);\n        numPairs ++;\n        return marketId;\n    }\n    /// @notice Margin trade or just add more deposit tokens.\n    /// @dev To support token with tax and reward. Stores share of all token balances of this contract.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param depositToken Token to deposit. False for token0, true for token1.\n    /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported.\n    /// @param borrow Amount of ERC20 to borrow from the short token pool.\n    /// @param minBuyAmount Slippage for Dex trading.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function marginTrade(\n        uint16 marketId,\n        bool longToken,\n        bool depositToken,\n        uint deposit,\n        uint borrow,\n        uint minBuyAmount,\n        bytes memory dexData\n    ) external payable override nonReentrant onlySupportDex(dexData) {\n        Types.TradeVars memory tv;\n        Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);\n        verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);\n        (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);\n        if (dexData.isUniV2Class()) {\n            OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);\n        }\n        tv.totalHeld = totalHelds[address(vars.buyToken)];\n        tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;\n        deposit = transferIn(msg.sender, tv.depositErc20, deposit);\n        // Borrow\n        uint borrowed;\n        if (borrow &gt; 0) {\n            {\n                uint balance = vars.sellToken.balanceOf(address(this));\n                vars.sellPool.borrowBehalf(msg.sender, borrow);\n                borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);\n            }\n            if (depositToken == longToken){\n                (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);\n                tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));\n            }else{\n                tv.borrowValue = borrow;\n            }\n        }\n        require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) &gt; vars.marginLimit, "MAM");\n        tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);\n        tv.depositAfterFees = deposit.sub(tv.fees);\n        tv.dexDetail = dexData.toDexDetail();\n        if (depositToken == longToken ){\n            if (borrowed &gt; 0){\n                tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);\n                tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);\n            }\n            tv.newHeld = tv.newHeld.add(tv.depositAfterFees);\n        }else{\n            tv.tradeSize = tv.depositAfterFees.add(borrowed);\n            tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);\n            tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);\n        }\n        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];\n        tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);\n        trade.held = trade.held.add(tv.newHeld);\n        trade.depositToken = depositToken;\n        trade.deposited = trade.deposited.add(tv.depositAfterFees);\n        trade.lastBlockNum = uint128(block.number);\n        totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);\n        require(OpenLevV1Lib.isPositionHealthy(\n                msg.sender,\n                true,\n                OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),\n                vars,\n                dexData\n            ), "PNH");\n        emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail);\n    }\n    /// @notice Close trade by shares.\n    /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param closeHeld Amount of shares to close.\n    /// @param minOrMaxAmount Slippage for Dex trading.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {\n        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];\n        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);\n        //verify\n        verifyCloseBefore(trade, marketVars, closeHeld, dexData);\n        uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n        Types.CloseTradeVars memory closeTradeVars;\n        closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n        closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);\n        closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);\n        closeTradeVars.isPartialClose = closeHeld != trade.held;\n        closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);\n        closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);\n        closeTradeVars.dexDetail = dexData.toDexDetail();\n        //partial close\n        if (closeTradeVars.isPartialClose) {\n            closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);\n            closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);\n            trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);\n        } else {\n            closeTradeVars.depositDecrease = trade.deposited;\n        }\n        if (trade.depositToken != longToken) {\n            minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);\n            closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);\n            require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");\n            closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;\n            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);\n            closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);\n            doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);\n        } else {\n            uint balance = marketVars.buyToken.balanceOf(address(this));\n            minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);\n            closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);\n            closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);\n            require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");\n            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);\n            closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);\n            require(marketVars.sellToken.balanceOf(address(this)) &gt;= closeTradeVars.depositReturn, "ISB");\n            doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);\n        }\n        uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));\n        require(repayed &gt;= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");\n        if (!closeTradeVars.isPartialClose) {\n            delete activeTrades[msg.sender][marketId][longToken];\n        }else{\n            trade.held = trade.held.sub(closeHeld);\n            trade.lastBlockNum = uint128(block.number);\n        }\n        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);\n        closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);\n        if (dexData.isUniV2Class()) {\n            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);\n        }\n        emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,\n            closeTradeVars.token0Price, closeTradeVars.dexDetail);\n    }\n    /// @notice Liquidate if trade below margin limit.\n    /// @dev For trades without sufficient funds to repay, use insurance.\n    /// @param owner Owner of the trade to liquidate.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param minBuy Slippage for Dex trading.\n    /// @param maxSell Slippage for Dex trading.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {\n        Types.Trade memory trade = activeTrades[owner][marketId][longToken];\n        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);\n        if (dexData.isUniV2Class()) {\n            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);\n        }\n        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());\n        uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n        (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);\n        require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");\n        Types.LiquidateVars memory liquidateVars;\n        liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n        liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);\n        if (liquidateVars.penalty &gt; 0) {\n            doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);\n        }\n        liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);\n        liquidateVars.dexDetail = dexData.toDexDetail();\n        liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);\n        liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);\n        liquidateVars.marketId = marketId;\n        liquidateVars.longToken = longToken;\n        bool buySuccess;\n        bytes memory sellAmountData;\n        if (longToken == trade.depositToken) {\n            maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);\n            marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);\n            (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(\n                abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],\n                taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)\n            );\n        }\n        if (buySuccess) {\n            {\n                uint temp;\n                assembly {\n                    temp := mload(add(sellAmountData, 0x20))\n                }\n                liquidateVars.sellAmount = temp;\n            }\n            liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);\n            marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);\n            liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);\n            doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);\n        } else {\n            liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;\n            liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);\n            if (liquidateVars.receiveAmount &gt;= liquidateVars.borrowed) {\n                // fail if buy failed but sell succeeded\n                require (longToken != trade.depositToken, "PH");\n                marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);\n                liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);\n                doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);\n            } else {\n                liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);\n                liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);\n                marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);\n            }\n        }\n        liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);\n        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);\n        emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,\n            trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);\n        delete activeTrades[owner][marketId][longToken];\n    }\n    function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {\n        return open == longToken ?\n        Types.MarketVars(\n            market.pool1,\n            market.pool0,\n            IERC20(market.token1),\n            IERC20(market.token0),\n            IERC20(market.token1).balanceOf(address(this)),\n            IERC20(market.token0).balanceOf(address(this)),\n            market.pool1Insurance,\n            market.pool0Insurance,\n            market.marginLimit,\n            market.priceDiffientRatio,\n            market.dexs) :\n        Types.MarketVars(\n            market.pool0,\n            market.pool1,\n            IERC20(market.token0),\n            IERC20(market.token1),\n            IERC20(market.token0).balanceOf(address(this)),\n            IERC20(market.token1).balanceOf(address(this)),\n            market.pool0Insurance,\n            market.pool1Insurance,\n            market.marginLimit,\n            market.priceDiffientRatio,\n            market.dexs);\n    }\n    /// @notice Get ratios of deposited token value to borrowed token value.\n    /// @dev Caluclate ratio with current price and twap price.\n    /// @param owner Owner of the trade to liquidate.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param dexData Index and fee rate for the trading Dex.\n    /// @return current Margin ratio calculated using current price.\n    /// @return cAvg Margin ratio calculated using twap price.\n    /// @return hAvg Margin ratio calculated using last recorded twap price.\n    /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value.\n    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {\n        Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);\n        limit = vars.marginLimit;\n        (current, cAvg, hAvg,,) =\n        OpenLevV1Lib.marginRatio(\n            owner,\n            activeTrades[owner][marketId][longToken].held,\n            address(vars.sellToken),\n            address(vars.buyToken),\n            vars.buyPool,\n            false,\n            dexData\n        );\n    }\n    /// @notice Check if a price update is required on Dex.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){\n        Types.Market memory market = markets[marketId];\n        return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData);\n    }\n    /// @notice Update price on Dex.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function updatePrice(uint16 marketId, bytes memory dexData) external override {\n        OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData);\n    }\n    /// @notice List of all supporting Dexes.\n    function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){\n        return markets[marketId].dexs;\n    }\n    function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {\n        Types.Market storage market = markets[marketId];\n        uint needed = totalRepayment.sub(remaining);\n        needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);\n        maxCanRepayAmount = totalRepayment;\n        if (longToken) {\n            if (market.pool0Insurance &gt;= needed) {\n                market.pool0Insurance = market.pool0Insurance - needed;\n                totalHelds[token] = totalHelds[token].sub(needed);\n            } else {\n                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);\n                maxCanRepayAmount = maxCanRepayAmount.add(remaining);\n                totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);\n                market.pool0Insurance = 0;\n            }\n        } else {\n            if (market.pool1Insurance &gt;= needed) {\n                market.pool1Insurance = market.pool1Insurance - needed;\n            } else {\n                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);\n                maxCanRepayAmount = maxCanRepayAmount.add(remaining);\n                totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);\n                market.pool1Insurance = 0;\n            }\n        }\n    }\n    function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {\n        // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);\n        Types.Market storage market = markets[marketId];\n        uint defaultFees = tradeSize.mul(market.feesRate).div(10000);\n        uint newFees = defaultFees;\n        // if trader holds more xOLE, then should enjoy trading discount.\n        if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) &gt; calculateConfig.feesDiscountThreshold) {\n            newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));\n        }\n        // if trader update price, then should enjoy trading discount.\n        if (market.priceUpdater == trader) {\n            newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));\n        }\n        uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);\n        IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));\n        newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);\n        if (token == market.token1) {\n            market.pool1Insurance = market.pool1Insurance.add(newInsurance);\n        } else {\n            market.pool0Insurance = market.pool0Insurance.add(newInsurance);\n        }\n        totalHelds[token] = totalHelds[token].add(newInsurance);\n        return newFees;\n    }\n    function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){\n        if (sellAmount &gt; 0){\n            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;\n            IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);\n            buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);\n        }\n    }\n    function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){\n        if (buyAmount &gt; 0){\n            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;\n            IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);\n            sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);\n        }\n    }\n    /// @dev All credited on this contract and share with all token holder if any rewards for the transfer.\n    function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {\n        return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount);\n    }\n    /// @dev All credited on "to" if any taxes for the transfer.\n    function doTransferOut(address to, IERC20 token, uint amount) internal {\n        OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount);\n    }\n    / Admin Functions /\n    function setCalculateConfig(uint16 defaultFeesRate,\n        uint8 insuranceRatio,\n        uint16 defaultMarginLimit,\n        uint16 priceDiffientRatio,\n        uint16 updatePriceDiscount,\n        uint16 feesDiscount,\n        uint128 feesDiscountThreshold,\n        uint16 penaltyRatio,\n        uint8 maxLiquidationPriceDiffientRatio,\n        uint16 twapDuration) external override onlyAdmin() {\n        OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,\n            feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);\n        emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration);\n    }\n    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {\n        OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);\n        emit NewAddressConfig(controller, address(dexAggregator));\n    }\n    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {\n        OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);\n        emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs);\n    }\n    /// @notice List of all supporting Dexes.\n    /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1\n    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {\n        Types.Market storage market = markets[marketId];\n        if (poolIndex == 0) {\n            market.pool0Insurance = market.pool0Insurance.sub(amount);\n            (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));\n            return;\n        }\n        market.pool1Insurance = market.pool1Insurance.sub(amount);\n        (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this))));\n    }\n    function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {\n        supportDexs[dex] = support;\n    }\n    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){\n        taxes[marketId][token][index] = tax;\n    }\n    function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {\n        Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];\n        OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade);\n    }\n    function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {\n        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());\n        require(closeHeld &lt;= trade.held, "CBH");\n    }\n    function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {\n        require(held != 0 &amp;&amp; lastBlockNumber != block.number &amp;&amp; OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0");\n    }\n    modifier onlySupportDex(bytes memory dexData) {\n        require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");\n        ;\n    }\n}".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Let\'s start by analyzing the provided Solidity contract code. Here are some potential areas for improvement or enhancement:\n1. Access Control: The contract uses a single admin for critical functions. Implementing a multi-signature wallet for administrative functions could enhance security by requiring multiple approvals for sensitive actions.\n2. Gas Optimization: There are several places where the code could be optimized for gas usage. For example, using memory instead of storage where appropriate, or minimizing the number of state variable updates in functions could help reduce gas costs.\n3. Error Handling: The contract uses require statements for error handling, which is good, but it could benefit from more descriptive error messages. This would make debugging easier and provide clearer feedback to users.\n4. Event Emission: While there are some events emitted, ensuring that all state-changing functions emit relevant events can improve transparency and allow for better tracking of contract activity.\n5. Reentrancy Protection: The contract uses ReentrancyGuard, which is great. However, we should ensure that all external calls are made at the end of the function to minimize the risk of reentrancy attacks.\n6. Upgradeability: Consider implementing a proxy pattern for upgradeability. This would allow the contract to be upgraded in the future without losing state or requiring users to migrate to a new contract.\n7. Testing and Auditing: Ensure comprehensive unit tests are in place, especially for critical functions like marginTrade, closeTrade, and liquidate. Additionally, a third-party audit could help identify vulnerabilities that may not be apparent during internal testing.\n8. Input Validation: More rigorous input validation could be added, especially for parameters like marketId, deposit, and borrow. This would help prevent unexpected behavior from invalid inputs.\n9. Documentation: While there are comments in the code, enhancing the documentation to include more detailed explanations of complex functions and their parameters would be beneficial for future developers.\n10. Emergency Mechanism: Implementing an emergency stop mechanism (circuit breaker) would allow the admin to pause contract operations in case of a detected vulnerability or exploit.\nWhich of these suggestions resonates most with you, or do you have any other specific areas you would like to focus on?', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-24-08 18:27:14 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.7.6; pragma experimental ABIEncoderV2; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import "./OpenLevInterface.sol"; import "./Types.sol"; import "./Adminable.sol"; import "./DelegateInterface.sol"; import "./ControllerInterface.sol"; import "./IWETH.sol"; import "./XOLEInterface.sol"; import "./Types.sol"; import "./OpenLevV1Lib.sol"; /// @title OpenLeverage margin trade logic /// @author OpenLeverage /// @notice Use this contract for margin trade. /// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE. contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {     using SafeMath for uint;     using TransferHelper for IERC20;     using DexData for bytes; constructor () { }  /// @notice initialize proxy contract /// @dev This function is not supposed to call multiple times. All configs can be set through other functions. /// @param _controller Address of contract ControllerDelegator. /// @param _dexAggregator contract DexAggregatorDelegator. /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens. /// @param _wETH Address of wrapped native coin. /// @param _xOLE Address of XOLEDelegator. /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol. function initialize(     address _controller,     DexAggregatorInterface _dexAggregator,     address[] memory depositTokens,     address _wETH,     address _xOLE,     uint8[] memory _supportDexs ) public {     depositTokens;     require(msg.sender == admin, "NAD");     addressConfig.controller = _controller;     addressConfig.dexAggregator = _dexAggregator;     addressConfig.wETH = _wETH;     addressConfig.xOLE = _xOLE;     for (uint i = 0; i &lt; _supportDexs.length; i++) {         supportDexs[_supportDexs[i]] = true;     }     OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig); }  /// @notice Create new trading pair. /// @dev This function is typically called by ControllerDelegator. /// @param pool0 Contract LpoolDelegator, lending pool of token0. /// @param pool1 Contract LpoolDelegator, lending pool of token1. /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value. /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens. /// @return The new created pair ID. function addMarket(     LPoolInterface pool0,     LPoolInterface pool1,     uint16 marginLimit,     bytes memory dexData ) external override returns (uint16) {     uint16 marketId = numPairs;     OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);     numPairs ++;     return marketId; }  /// @notice Margin trade or just add more deposit tokens. /// @dev To support token with tax and reward. Stores share of all token balances of this contract. /// @param longToken Token to long. False for token0, true for token1. /// @param depositToken Token to deposit. False for token0, true for token1. /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported. /// @param borrow Amount of ERC20 to borrow from the short token pool. /// @param minBuyAmount Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function marginTrade(     uint16 marketId,     bool longToken,     bool depositToken,     uint deposit,     uint borrow,     uint minBuyAmount,     bytes memory dexData ) external payable override nonReentrant onlySupportDex(dexData) {     Types.TradeVars memory tv;     Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);     verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);     (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);      if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);     }      tv.totalHeld = totalHelds[address(vars.buyToken)];     tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;      deposit = transferIn(msg.sender, tv.depositErc20, deposit);      // Borrow     uint borrowed;     if (borrow &gt; 0) {         {             uint balance = vars.sellToken.balanceOf(address(this));             vars.sellPool.borrowBehalf(msg.sender, borrow);             borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);         }          if (depositToken == longToken){             (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);             tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));         }else{             tv.borrowValue = borrow;         }     }      require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) &gt; vars.marginLimit, "MAM");     tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);     tv.depositAfterFees = deposit.sub(tv.fees);     tv.dexDetail = dexData.toDexDetail();      if (depositToken == longToken ){         if (borrowed &gt; 0){             tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);             tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);         }         tv.newHeld = tv.newHeld.add(tv.depositAfterFees);     }else{         tv.tradeSize = tv.depositAfterFees.add(borrowed);         tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);         tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);     }      Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];     tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);     trade.held = trade.held.add(tv.newHeld);     trade.depositToken = depositToken;     trade.deposited = trade.deposited.add(tv.depositAfterFees);     trade.lastBlockNum = uint128(block.number);      totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);      require(OpenLevV1Lib.isPositionHealthy(             msg.sender,             true,             OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),             vars,             dexData         ), "PNH");      emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail); }  /// @notice Close trade by shares. /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed. /// @param longToken Token to long. False for token0, true for token1. /// @param closeHeld Amount of shares to close. /// @param minOrMaxAmount Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {     Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];     Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);      //verify     verifyCloseBefore(trade, marketVars, closeHeld, dexData);      uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);      Types.CloseTradeVars memory closeTradeVars;     closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);     closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);     closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);     closeTradeVars.isPartialClose = closeHeld != trade.held;     closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);     closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);     closeTradeVars.dexDetail = dexData.toDexDetail();      //partial close     if (closeTradeVars.isPartialClose) {         closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);         closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);         trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);     } else {         closeTradeVars.depositDecrease = trade.deposited;     }      if (trade.depositToken != longToken) {         minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);         closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);         require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");          closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;         marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);          closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);         doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);     } else {         uint balance = marketVars.buyToken.balanceOf(address(this));         minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);         closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);         closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);         require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");          marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);         closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);         require(marketVars.sellToken.balanceOf(address(this)) &gt;= closeTradeVars.depositReturn, "ISB");         doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);     }      uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));     require(repayed &gt;= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");      if (!closeTradeVars.isPartialClose) {         delete activeTrades[msg.sender][marketId][longToken];     }else{         trade.held = trade.held.sub(closeHeld);         trade.lastBlockNum = uint128(block.number);     }      totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);      closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);     if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);     }      emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,         closeTradeVars.token0Price, closeTradeVars.dexDetail); }  /// @notice Liquidate if trade below margin limit. /// @dev For trades without sufficient funds to repay, use insurance. /// @param owner Owner of the trade to liquidate. /// @param longToken Token to long. False for token0, true for token1. /// @param minBuy Slippage for Dex trading. /// @param maxSell Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {     Types.Trade memory trade = activeTrades[owner][marketId][longToken];     Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);     if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);     }      verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());     uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);      (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);     require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");      Types.LiquidateVars memory liquidateVars;     liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);     liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);     if (liquidateVars.penalty &gt; 0) {         doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);     }     liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);     liquidateVars.dexDetail = dexData.toDexDetail();     liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);     liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);     liquidateVars.marketId = marketId;     liquidateVars.longToken = longToken;      bool buySuccess;     bytes memory sellAmountData;     if (longToken == trade.depositToken) {         maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);         marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);         (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(             abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],             taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)         );     }      if (buySuccess) {         {             uint temp;             assembly {                 temp := mload(add(sellAmountData, 0x20))             }             liquidateVars.sellAmount = temp;         }          liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);         marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);         liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);         doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);     } else {         liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;         liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);         if (liquidateVars.receiveAmount &gt;= liquidateVars.borrowed) {             // fail if buy failed but sell succeeded             require (longToken != trade.depositToken, "PH");             marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);             liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);             doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);         } else {             liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);             liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);             marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);         }     }      liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);     totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);      emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,         trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);      delete activeTrades[owner][marketId][longToken]; }  function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {     return open == longToken ?     Types.MarketVars(         market.pool1,         market.pool0,         IERC20(market.token1),         IERC20(market.token0),         IERC20(market.token1).balanceOf(address(this)),         IERC20(market.token0).balanceOf(address(this)),         market.pool1Insurance,         market.pool0Insurance,         market.marginLimit,         market.priceDiffientRatio,         market.dexs) :     Types.MarketVars(         market.pool0,         market.pool1,         IERC20(market.token0),         IERC20(market.token1),         IERC20(market.token0).balanceOf(address(this)),         IERC20(market.token1).balanceOf(address(this)),         market.pool0Insurance,         market.pool1Insurance,         market.marginLimit,         market.priceDiffientRatio,         market.dexs); }  /// @notice Get ratios of deposited token value to borrowed token value. /// @dev Caluclate ratio with current price and twap price. /// @param owner Owner of the trade to liquidate. /// @param longToken Token to long. False for token0, true for token1. /// @param dexData Index and fee rate for the trading Dex. /// @return current Margin ratio calculated using current price. /// @return cAvg Margin ratio calculated using twap price. /// @return hAvg Margin ratio calculated using last recorded twap price. /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value. function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {     Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);     limit = vars.marginLimit;     (current, cAvg, hAvg,,) =     OpenLevV1Lib.marginRatio(         owner,         activeTrades[owner][marketId][longToken].held,         address(vars.sellToken),         address(vars.buyToken),         vars.buyPool,         false,         dexData     ); }  /// @notice Check if a price update is required on Dex. /// @param dexData Index and fee rate for the trading Dex. function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){     Types.Market memory market = markets[marketId];     return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData); }  /// @notice Update price on Dex. /// @param dexData Index and fee rate for the trading Dex. function updatePrice(uint16 marketId, bytes memory dexData) external override {     OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData); }  /// @notice List of all supporting Dexes. function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){     return markets[marketId].dexs; }  function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {     Types.Market storage market = markets[marketId];     uint needed = totalRepayment.sub(remaining);     needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);     maxCanRepayAmount = totalRepayment;     if (longToken) {         if (market.pool0Insurance &gt;= needed) {             market.pool0Insurance = market.pool0Insurance - needed;             totalHelds[token] = totalHelds[token].sub(needed);         } else {             maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);             maxCanRepayAmount = maxCanRepayAmount.add(remaining);             totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);             market.pool0Insurance = 0;         }     } else {         if (market.pool1Insurance &gt;= needed) {             market.pool1Insurance = market.pool1Insurance - needed;         } else {             maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);             maxCanRepayAmount = maxCanRepayAmount.add(remaining);             totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);             market.pool1Insurance = 0;         }     } }  function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {     // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);     Types.Market storage market = markets[marketId];     uint defaultFees = tradeSize.mul(market.feesRate).div(10000);     uint newFees = defaultFees;     // if trader holds more xOLE, then should enjoy trading discount.     if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) &gt; calculateConfig.feesDiscountThreshold) {         newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));     }     // if trader update price, then should enjoy trading discount.     if (market.priceUpdater == trader) {         newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));     }     uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);     IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));      newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);     if (token == market.token1) {         market.pool1Insurance = market.pool1Insurance.add(newInsurance);     } else {         market.pool0Insurance = market.pool0Insurance.add(newInsurance);     }      totalHelds[token] = totalHelds[token].add(newInsurance);     return newFees; }  function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){     if (sellAmount &gt; 0){         DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;         IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);         buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);     } }  function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){     if (buyAmount &gt; 0){         DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;         IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);         sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);     } }  /// @dev All credited on this contract and share with all token holder if any rewards for the transfer. function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {     return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount); }  /// @dev All credited on "to" if any taxes for the transfer. function doTransferOut(address to, IERC20 token, uint amount) internal {     OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount); }  /*** Admin Functions ***/ function setCalculateConfig(uint16 defaultFeesRate,     uint8 insuranceRatio,     uint16 defaultMarginLimit,     uint16 priceDiffientRatio,     uint16 updatePriceDiscount,     uint16 feesDiscount,     uint128 feesDiscountThreshold,     uint16 penaltyRatio,     uint8 maxLiquidationPriceDiffientRatio,     uint16 twapDuration) external override onlyAdmin() {     OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,         feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);     emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration); }  function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {     OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);     emit NewAddressConfig(controller, address(dexAggregator)); }  function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {     OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);     emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs); }  /// @notice List of all supporting Dexes. /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1 function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {     Types.Market storage market = markets[marketId];     if (poolIndex == 0) {         market.pool0Insurance = market.pool0Insurance.sub(amount);         (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));         return;     }     market.pool1Insurance = market.pool1Insurance.sub(amount);     (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this)))); }  function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {     supportDexs[dex] = support; }  function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){     taxes[marketId][token][index] = tax; }  function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {     Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];     OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade); }  function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {     verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());     require(closeHeld &lt;= trade.held, "CBH"); }  function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {     require(held != 0 &amp;&amp; lastBlockNumber != block.number &amp;&amp; OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0"); }  modifier onlySupportDex(bytes memory dexData) {     require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");     _; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-24-08 18:27:14 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;

pragma experimental ABIEncoderV2;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "./OpenLevInterface.sol";
import "./Types.sol";
import "./Adminable.sol";
import "./DelegateInterface.sol";
import "./ControllerInterface.sol";
import "./IWETH.sol";
import "./XOLEInterface.sol";
import "./Types.sol";
import "./OpenLevV1Lib.sol";

/// @title OpenLeverage margin trade logic
/// @author OpenLeverage
/// @notice Use this contract for margin trade.
/// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE.
contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {
    using SafeMath for uint;
    using TransferHelper for IERC20;
    using DexData for bytes;

    constructor ()
    {
    }

    /// @notice initialize proxy contract
    /// @dev This function is not supposed to call multiple times. All configs can be set through other functions.
    /// @param _controller Address of contract ControllerDelegator.
    /// @param _dexAggregator contract DexAggregatorDelegator.
    /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens.
    /// @param _wETH Address of wrapped native coin.
    /// @param _xOLE Address of XOLEDelegator.
    /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol.
    function initialize(
        address _controller,
        DexAggregatorInterface _dexAggregator,
        address[] memory depositTokens,
        address _wETH,
        address _xOLE,
        uint8[] memory _supportDexs
    ) public {
        depositTokens;
        require(msg.sender == admin, "NAD");
        addressConfig.controller = _controller;
        addressConfig.dexAggregator = _dexAggregator;
        addressConfig.wETH = _wETH;
        addressConfig.xOLE = _xOLE;
        for (uint i = 0; i < _supportDexs.length; i++) {
            supportDexs[_supportDexs[i]] = true;
        }
        OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig);
    }

    /// @notice Create new trading pair.
    /// @dev This function is typically called by ControllerDelegator.
    /// @param pool0 Contract LpoolDelegator, lending pool of token0.
    /// @param pool1 Contract LpoolDelegator, lending pool of token1.
    /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value.
    /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens.
    /// @return The new created pair ID.
    function addMarket(
        LPoolInterface pool0,
        LPoolInterface pool1,
        uint16 marginLimit,
        bytes memory dexData
    ) external override returns (uint16) {
        uint16 marketId = numPairs;
        OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);
        numPairs ++;
        return marketId;
    }

    /// @notice Margin trade or just add more deposit tokens.
    /// @dev To support token with tax and reward. Stores share of all token balances of this contract.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param depositToken Token to deposit. False for token0, true for token1.
    /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported.
    /// @param borrow Amount of ERC20 to borrow from the short token pool.
    /// @param minBuyAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function marginTrade(
        uint16 marketId,
        bool longToken,
        bool depositToken,
        uint deposit,
        uint borrow,
        uint minBuyAmount,
        bytes memory dexData
    ) external payable override nonReentrant onlySupportDex(dexData) {
        Types.TradeVars memory tv;
        Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);
        verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);
        (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);

        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);
        }

        tv.totalHeld = totalHelds[address(vars.buyToken)];
        tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;

        deposit = transferIn(msg.sender, tv.depositErc20, deposit);

        // Borrow
        uint borrowed;
        if (borrow > 0) {
            {
                uint balance = vars.sellToken.balanceOf(address(this));
                vars.sellPool.borrowBehalf(msg.sender, borrow);
                borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);
            }

            if (depositToken == longToken){
                (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);
                tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));
            }else{
                tv.borrowValue = borrow;
            }
        }

        require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) > vars.marginLimit, "MAM");
        tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);
        tv.depositAfterFees = deposit.sub(tv.fees);
        tv.dexDetail = dexData.toDexDetail();

        if (depositToken == longToken ){
            if (borrowed > 0){
                tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);
                tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);
            }
            tv.newHeld = tv.newHeld.add(tv.depositAfterFees);
        }else{
            tv.tradeSize = tv.depositAfterFees.add(borrowed);
            tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);
            tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);
        }

        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);
        trade.held = trade.held.add(tv.newHeld);
        trade.depositToken = depositToken;
        trade.deposited = trade.deposited.add(tv.depositAfterFees);
        trade.lastBlockNum = uint128(block.number);

        totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);

        require(OpenLevV1Lib.isPositionHealthy(
                msg.sender,
                true,
                OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),
                vars,
                dexData
            ), "PNH");

        emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail);
    }

    /// @notice Close trade by shares.
    /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param closeHeld Amount of shares to close.
    /// @param minOrMaxAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);

        //verify
        verifyCloseBefore(trade, marketVars, closeHeld, dexData);

        uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        Types.CloseTradeVars memory closeTradeVars;
        closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);
        closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);
        closeTradeVars.isPartialClose = closeHeld != trade.held;
        closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);
        closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        closeTradeVars.dexDetail = dexData.toDexDetail();

        //partial close
        if (closeTradeVars.isPartialClose) {
            closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);
            closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);
            trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);
        } else {
            closeTradeVars.depositDecrease = trade.deposited;
        }

        if (trade.depositToken != longToken) {
            minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);
            closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;
            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);

            closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);
            doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);
        } else {
            uint balance = marketVars.buyToken.balanceOf(address(this));
            minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);
            closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);
            closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);
            closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);
            require(marketVars.sellToken.balanceOf(address(this)) >= closeTradeVars.depositReturn, "ISB");
            doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);
        }

        uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));
        require(repayed >= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");

        if (!closeTradeVars.isPartialClose) {
            delete activeTrades[msg.sender][marketId][longToken];
        }else{
            trade.held = trade.held.sub(closeHeld);
            trade.lastBlockNum = uint128(block.number);
        }

        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);

        closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,
            closeTradeVars.token0Price, closeTradeVars.dexDetail);
    }

    /// @notice Liquidate if trade below margin limit.
    /// @dev For trades without sufficient funds to repay, use insurance.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param minBuy Slippage for Dex trading.
    /// @param maxSell Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade memory trade = activeTrades[owner][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());
        uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);
        require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");

        Types.LiquidateVars memory liquidateVars;
        liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);
        if (liquidateVars.penalty > 0) {
            doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);
        }
        liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);
        liquidateVars.dexDetail = dexData.toDexDetail();
        liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);
        liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        liquidateVars.marketId = marketId;
        liquidateVars.longToken = longToken;

        bool buySuccess;
        bytes memory sellAmountData;
        if (longToken == trade.depositToken) {
            maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);
            marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);
            (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(
                abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],
                taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)
            );
        }

        if (buySuccess) {
            {
                uint temp;
                assembly {
                    temp := mload(add(sellAmountData, 0x20))
                }
                liquidateVars.sellAmount = temp;
            }

            liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);
            marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
            liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);
            doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);
        } else {
            liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;
            liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);
            if (liquidateVars.receiveAmount >= liquidateVars.borrowed) {
                // fail if buy failed but sell succeeded
                require (longToken != trade.depositToken, "PH");
                marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
                liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);
                doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);
            } else {
                liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);
                liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);
                marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);
            }
        }

        liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);
        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);

        emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,
            trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);

        delete activeTrades[owner][marketId][longToken];
    }

    function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {
        return open == longToken ?
        Types.MarketVars(
            market.pool1,
            market.pool0,
            IERC20(market.token1),
            IERC20(market.token0),
            IERC20(market.token1).balanceOf(address(this)),
            IERC20(market.token0).balanceOf(address(this)),
            market.pool1Insurance,
            market.pool0Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs) :
        Types.MarketVars(
            market.pool0,
            market.pool1,
            IERC20(market.token0),
            IERC20(market.token1),
            IERC20(market.token0).balanceOf(address(this)),
            IERC20(market.token1).balanceOf(address(this)),
            market.pool0Insurance,
            market.pool1Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs);
    }

    /// @notice Get ratios of deposited token value to borrowed token value.
    /// @dev Caluclate ratio with current price and twap price.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param dexData Index and fee rate for the trading Dex.
    /// @return current Margin ratio calculated using current price.
    /// @return cAvg Margin ratio calculated using twap price.
    /// @return hAvg Margin ratio calculated using last recorded twap price.
    /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value.
    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {
        Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);
        limit = vars.marginLimit;
        (current, cAvg, hAvg,,) =
        OpenLevV1Lib.marginRatio(
            owner,
            activeTrades[owner][marketId][longToken].held,
            address(vars.sellToken),
            address(vars.buyToken),
            vars.buyPool,
            false,
            dexData
        );
    }

    /// @notice Check if a price update is required on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){
        Types.Market memory market = markets[marketId];
        return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData);
    }

    /// @notice Update price on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function updatePrice(uint16 marketId, bytes memory dexData) external override {
        OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData);
    }

    /// @notice List of all supporting Dexes.
    function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){
        return markets[marketId].dexs;
    }

    function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {
        Types.Market storage market = markets[marketId];
        uint needed = totalRepayment.sub(remaining);
        needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);
        maxCanRepayAmount = totalRepayment;
        if (longToken) {
            if (market.pool0Insurance >= needed) {
                market.pool0Insurance = market.pool0Insurance - needed;
                totalHelds[token] = totalHelds[token].sub(needed);
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);
                market.pool0Insurance = 0;
            }
        } else {
            if (market.pool1Insurance >= needed) {
                market.pool1Insurance = market.pool1Insurance - needed;
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);
                market.pool1Insurance = 0;
            }
        }
    }

    function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {
        // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);
        Types.Market storage market = markets[marketId];
        uint defaultFees = tradeSize.mul(market.feesRate).div(10000);
        uint newFees = defaultFees;
        // if trader holds more xOLE, then should enjoy trading discount.
        if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) > calculateConfig.feesDiscountThreshold) {
            newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));
        }
        // if trader update price, then should enjoy trading discount.
        if (market.priceUpdater == trader) {
            newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));
        }
        uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);
        IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));

        newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);
        if (token == market.token1) {
            market.pool1Insurance = market.pool1Insurance.add(newInsurance);
        } else {
            market.pool0Insurance = market.pool0Insurance.add(newInsurance);
        }

        totalHelds[token] = totalHelds[token].add(newInsurance);
        return newFees;
    }

    function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){
        if (sellAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);
            buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);
        }
    }

    function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){
        if (buyAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);
            sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);
        }
    }

    /// @dev All credited on this contract and share with all token holder if any rewards for the transfer.
    function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {
        return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount);
    }

    /// @dev All credited on "to" if any taxes for the transfer.
    function doTransferOut(address to, IERC20 token, uint amount) internal {
        OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount);
    }

    /*** Admin Functions ***/
    function setCalculateConfig(uint16 defaultFeesRate,
        uint8 insuranceRatio,
        uint16 defaultMarginLimit,
        uint16 priceDiffientRatio,
        uint16 updatePriceDiscount,
        uint16 feesDiscount,
        uint128 feesDiscountThreshold,
        uint16 penaltyRatio,
        uint8 maxLiquidationPriceDiffientRatio,
        uint16 twapDuration) external override onlyAdmin() {
        OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,
            feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);
        emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration);
    }

    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {
        OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);
        emit NewAddressConfig(controller, address(dexAggregator));
    }

    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {
        OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);
        emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs);
    }

    /// @notice List of all supporting Dexes.
    /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1
    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {
        Types.Market storage market = markets[marketId];
        if (poolIndex == 0) {
            market.pool0Insurance = market.pool0Insurance.sub(amount);
            (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));
            return;
        }
        market.pool1Insurance = market.pool1Insurance.sub(amount);
        (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this))));
    }

    function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {
        supportDexs[dex] = support;
    }

    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){
        taxes[marketId][token][index] = tax;
    }

    function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {
        Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];
        OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade);
    }

    function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {
        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());
        require(closeHeld <= trade.held, "CBH");
    }

    function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {
        require(held != 0 && lastBlockNumber != block.number && OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0");
    }

    modifier onlySupportDex(bytes memory dexData) {
        require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");
        _;
    }
}.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;
pragma experimental ABIEncoderV2;
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "./OpenLevInterface.sol";
import "./Types.sol";
import "./Adminable.sol";
import "./DelegateInterface.sol";
import "./ControllerInterface.sol";
import "./IWETH.sol";
import "./XOLEInterface.sol";
import "./Types.sol";
import "./OpenLevV1Lib.sol";
/// @title OpenLeverage margin trade logic
/// @author OpenLeverage
/// @notice Use this contract for margin trade.
/// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE.
contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {
    using SafeMath for uint;
    using TransferHelper for IERC20;
    using DexData for bytes;
    constructor ()
    {
    }
    /// @notice initialize proxy contract
    /// @dev This function is not supposed to call multiple times. All configs can be set through other functions.
    /// @param _controller Address of contract ControllerDelegator.
    /// @param _dexAggregator contract DexAggregatorDelegator.
    /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens.
    /// @param _wETH Address of wrapped native coin.
    /// @param _xOLE Address of XOLEDelegator.
    /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol.
    function initialize(
        address _controller,
        DexAggregatorInterface _dexAggregator,
        address[] memory depositTokens,
        address _wETH,
        address _xOLE,
        uint8[] memory _supportDexs
    ) public {
        depositTokens;
        require(msg.sender == admin, "NAD");
        addressConfig.controller = _controller;
        addressConfig.dexAggregator = _dexAggregator;
        addressConfig.wETH = _wETH;
        addressConfig.xOLE = _xOLE;
        for (uint i = 0; i < _supportDexs.length; i++) {
            supportDexs[_supportDexs[i]] = true;
        }
        OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig);
    }
    /// @notice Create new trading pair.
    /// @dev This function is typically called by ControllerDelegator.
    /// @param pool0 Contract LpoolDelegator, lending pool of token0.
    /// @param pool1 Contract LpoolDelegator, lending pool of token1.
    /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value.
    /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens.
    /// @return The new created pair ID.
    function addMarket(
        LPoolInterface pool0,
        LPoolInterface pool1,
        uint16 marginLimit,
        bytes memory dexData
    ) external override returns (uint16) {
        uint16 marketId = numPairs;
        OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);
        numPairs ++;
        return marketId;
    }
    /// @notice Margin trade or just add more deposit tokens.
    /// @dev To support token with tax and reward. Stores share of all token balances of this contract.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param depositToken Token to deposit. False for token0, true for token1.
    /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported.
    /// @param borrow Amount of ERC20 to borrow from the short token pool.
    /// @param minBuyAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function marginTrade(
        uint16 marketId,
        bool longToken,
        bool depositToken,
        uint deposit,
        uint borrow,
        uint minBuyAmount,
        bytes memory dexData
    ) external payable override nonReentrant onlySupportDex(dexData) {
        Types.TradeVars memory tv;
        Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);
        verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);
        (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);
        }
        tv.totalHeld = totalHelds[address(vars.buyToken)];
        tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;
        deposit = transferIn(msg.sender, tv.depositErc20, deposit);
        // Borrow
        uint borrowed;
        if (borrow > 0) {
            {
                uint balance = vars.sellToken.balanceOf(address(this));
                vars.sellPool.borrowBehalf(msg.sender, borrow);
                borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);
            }
            if (depositToken == longToken){
                (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);
                tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));
            }else{
                tv.borrowValue = borrow;
            }
        }
        require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) > vars.marginLimit, "MAM");
        tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);
        tv.depositAfterFees = deposit.sub(tv.fees);
        tv.dexDetail = dexData.toDexDetail();
        if (depositToken == longToken ){
            if (borrowed > 0){
                tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);
                tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);
            }
            tv.newHeld = tv.newHeld.add(tv.depositAfterFees);
        }else{
            tv.tradeSize = tv.depositAfterFees.add(borrowed);
            tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);
            tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);
        }
        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);
        trade.held = trade.held.add(tv.newHeld);
        trade.depositToken = depositToken;
        trade.deposited = trade.deposited.add(tv.depositAfterFees);
        trade.lastBlockNum = uint128(block.number);
        totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);
        require(OpenLevV1Lib.isPositionHealthy(
                msg.sender,
                true,
                OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),
                vars,
                dexData
            ), "PNH");
        emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail);
    }
    /// @notice Close trade by shares.
    /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param closeHeld Amount of shares to close.
    /// @param minOrMaxAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);
        //verify
        verifyCloseBefore(trade, marketVars, closeHeld, dexData);
        uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        Types.CloseTradeVars memory closeTradeVars;
        closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);
        closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);
        closeTradeVars.isPartialClose = closeHeld != trade.held;
        closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);
        closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        closeTradeVars.dexDetail = dexData.toDexDetail();
        //partial close
        if (closeTradeVars.isPartialClose) {
            closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);
            closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);
            trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);
        } else {
            closeTradeVars.depositDecrease = trade.deposited;
        }
        if (trade.depositToken != longToken) {
            minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);
            closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");
            closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;
            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);
            closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);
            doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);
        } else {
            uint balance = marketVars.buyToken.balanceOf(address(this));
            minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);
            closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);
            closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");
            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);
            closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);
            require(marketVars.sellToken.balanceOf(address(this)) >= closeTradeVars.depositReturn, "ISB");
            doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);
        }
        uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));
        require(repayed >= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");
        if (!closeTradeVars.isPartialClose) {
            delete activeTrades[msg.sender][marketId][longToken];
        }else{
            trade.held = trade.held.sub(closeHeld);
            trade.lastBlockNum = uint128(block.number);
        }
        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);
        closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }
        emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,
            closeTradeVars.token0Price, closeTradeVars.dexDetail);
    }
    /// @notice Liquidate if trade below margin limit.
    /// @dev For trades without sufficient funds to repay, use insurance.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param minBuy Slippage for Dex trading.
    /// @param maxSell Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade memory trade = activeTrades[owner][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }
        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());
        uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);
        require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");
        Types.LiquidateVars memory liquidateVars;
        liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);
        if (liquidateVars.penalty > 0) {
            doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);
        }
        liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);
        liquidateVars.dexDetail = dexData.toDexDetail();
        liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);
        liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        liquidateVars.marketId = marketId;
        liquidateVars.longToken = longToken;
        bool buySuccess;
        bytes memory sellAmountData;
        if (longToken == trade.depositToken) {
            maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);
            marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);
            (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(
                abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],
                taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)
            );
        }
        if (buySuccess) {
            {
                uint temp;
                assembly {
                    temp := mload(add(sellAmountData, 0x20))
                }
                liquidateVars.sellAmount = temp;
            }
            liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);
            marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
            liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);
            doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);
        } else {
            liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;
            liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);
            if (liquidateVars.receiveAmount >= liquidateVars.borrowed) {
                // fail if buy failed but sell succeeded
                require (longToken != trade.depositToken, "PH");
                marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
                liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);
                doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);
            } else {
                liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);
                liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);
                marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);
            }
        }
        liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);
        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);
        emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,
            trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);
        delete activeTrades[owner][marketId][longToken];
    }
    function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {
        return open == longToken ?
        Types.MarketVars(
            market.pool1,
            market.pool0,
            IERC20(market.token1),
            IERC20(market.token0),
            IERC20(market.token1).balanceOf(address(this)),
            IERC20(market.token0).balanceOf(address(this)),
            market.pool1Insurance,
            market.pool0Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs) :
        Types.MarketVars(
            market.pool0,
            market.pool1,
            IERC20(market.token0),
            IERC20(market.token1),
            IERC20(market.token0).balanceOf(address(this)),
            IERC20(market.token1).balanceOf(address(this)),
            market.pool0Insurance,
            market.pool1Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs);
    }
    /// @notice Get ratios of deposited token value to borrowed token value.
    /// @dev Caluclate ratio with current price and twap price.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param dexData Index and fee rate for the trading Dex.
    /// @return current Margin ratio calculated using current price.
    /// @return cAvg Margin ratio calculated using twap price.
    /// @return hAvg Margin ratio calculated using last recorded twap price.
    /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value.
    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {
        Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);
        limit = vars.marginLimit;
        (current, cAvg, hAvg,,) =
        OpenLevV1Lib.marginRatio(
            owner,
            activeTrades[owner][marketId][longToken].held,
            address(vars.sellToken),
            address(vars.buyToken),
            vars.buyPool,
            false,
            dexData
        );
    }
    /// @notice Check if a price update is required on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){
        Types.Market memory market = markets[marketId];
        return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData);
    }
    /// @notice Update price on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function updatePrice(uint16 marketId, bytes memory dexData) external override {
        OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData);
    }
    /// @notice List of all supporting Dexes.
    function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){
        return markets[marketId].dexs;
    }
    function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {
        Types.Market storage market = markets[marketId];
        uint needed = totalRepayment.sub(remaining);
        needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);
        maxCanRepayAmount = totalRepayment;
        if (longToken) {
            if (market.pool0Insurance >= needed) {
                market.pool0Insurance = market.pool0Insurance - needed;
                totalHelds[token] = totalHelds[token].sub(needed);
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);
                market.pool0Insurance = 0;
            }
        } else {
            if (market.pool1Insurance >= needed) {
                market.pool1Insurance = market.pool1Insurance - needed;
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);
                market.pool1Insurance = 0;
            }
        }
    }
    function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {
        // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);
        Types.Market storage market = markets[marketId];
        uint defaultFees = tradeSize.mul(market.feesRate).div(10000);
        uint newFees = defaultFees;
        // if trader holds more xOLE, then should enjoy trading discount.
        if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) > calculateConfig.feesDiscountThreshold) {
            newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));
        }
        // if trader update price, then should enjoy trading discount.
        if (market.priceUpdater == trader) {
            newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));
        }
        uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);
        IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));
        newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);
        if (token == market.token1) {
            market.pool1Insurance = market.pool1Insurance.add(newInsurance);
        } else {
            market.pool0Insurance = market.pool0Insurance.add(newInsurance);
        }
        totalHelds[token] = totalHelds[token].add(newInsurance);
        return newFees;
    }
    function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){
        if (sellAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);
            buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);
        }
    }
    function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){
        if (buyAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);
            sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);
        }
    }
    /// @dev All credited on this contract and share with all token holder if any rewards for the transfer.
    function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {
        return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount);
    }
    /// @dev All credited on "to" if any taxes for the transfer.
    function doTransferOut(address to, IERC20 token, uint amount) internal {
        OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount);
    }
    /*** Admin Functions ***/
    function setCalculateConfig(uint16 defaultFeesRate,
        uint8 insuranceRatio,
        uint16 defaultMarginLimit,
        uint16 priceDiffientRatio,
        uint16 updatePriceDiscount,
        uint16 feesDiscount,
        uint128 feesDiscountThreshold,
        uint16 penaltyRatio,
        uint8 maxLiquidationPriceDiffientRatio,
        uint16 twapDuration) external override onlyAdmin() {
        OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,
            feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);
        emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration);
    }
    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {
        OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);
        emit NewAddressConfig(controller, address(dexAggregator));
    }
    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {
        OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);
        emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs);
    }
    /// @notice List of all supporting Dexes.
    /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1
    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {
        Types.Market storage market = markets[marketId];
        if (poolIndex == 0) {
            market.pool0Insurance = market.pool0Insurance.sub(amount);
            (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));
            return;
        }
        market.pool1Insurance = market.pool1Insurance.sub(amount);
        (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this))));
    }
    function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {
        supportDexs[dex] = support;
    }
    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){
        taxes[marketId][token][index] = tax;
    }
    function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {
        Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];
        OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade);
    }
    function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {
        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());
        require(closeHeld <= trade.held, "CBH");
    }
    function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {
        require(held != 0 && lastBlockNumber != block.number && OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0");
    }
    modifier onlySupportDex(bytes memory dexData) {
        require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");
        _;
    }
}.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;
pragma experimental ABIEncoderV2;
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "./OpenLevInterface.sol";
import "./Types.sol";
import "./Adminable.sol";
import "./DelegateInterface.sol";
import "./ControllerInterface.sol";
import "./IWETH.sol";
import "./XOLEInterface.sol";
import "./Types.sol";
import "./OpenLevV1Lib.sol";
/// @title OpenLeverage margin trade logic
/// @author OpenLeverage
/// @notice Use this contract for margin trade.
/// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE.
contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {
    using SafeMath for uint;
    using TransferHelper for IERC20;
    using DexData for bytes;
    constructor ()
    {
    }
    /// @notice initialize proxy contract
    /// @dev This function is not supposed to call multiple times. All configs can be set through other functions.
    /// @param _controller Address of contract ControllerDelegator.
    /// @param _dexAggregator contract DexAggregatorDelegator.
    /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens.
    /// @param _wETH Address of wrapped native coin.
    /// @param _xOLE Address of XOLEDelegator.
    /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol.
    function initialize(
        address _controller,
        DexAggregatorInterface _dexAggregator,
        address[] memory depositTokens,
        address _wETH,
        address _xOLE,
        uint8[] memory _supportDexs
    ) public {
        depositTokens;
        require(msg.sender == admin, "NAD");
        addressConfig.controller = _controller;
        addressConfig.dexAggregator = _dexAggregator;
        addressConfig.wETH = _wETH;
        addressConfig.xOLE = _xOLE;
        for (uint i = 0; i < _supportDexs.length; i++) {
            supportDexs[_supportDexs[i]] = true;
        }
        OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig);
    }
    /// @notice Create new trading pair.
    /// @dev This function is typically called by ControllerDelegator.
    /// @param pool0 Contract LpoolDelegator, lending pool of token0.
    /// @param pool1 Contract LpoolDelegator, lending pool of token1.
    /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value.
    /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens.
    /// @return The new created pair ID.
    function addMarket(
        LPoolInterface pool0,
        LPoolInterface pool1,
        uint16 marginLimit,
        bytes memory dexData
    ) external override returns (uint16) {
        uint16 marketId = numPairs;
        OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);
        numPairs ++;
        return marketId;
    }
    /// @notice Margin trade or just add more deposit tokens.
    /// @dev To support token with tax and reward. Stores share of all token balances of this contract.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param depositToken Token to deposit. False for token0, true for token1.
    /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported.
    /// @param borrow Amount of ERC20 to borrow from the short token pool.
    /// @param minBuyAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function marginTrade(
        uint16 marketId,
        bool longToken,
        bool depositToken,
        uint deposit,
        uint borrow,
        uint minBuyAmount,
        bytes memory dexData
    ) external payable override nonReentrant onlySupportDex(dexData) {
        Types.TradeVars memory tv;
        Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);
        verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);
        (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);
        }
        tv.totalHeld = totalHelds[address(vars.buyToken)];
        tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;
        deposit = transferIn(msg.sender, tv.depositErc20, deposit);
        // Borrow
        uint borrowed;
        if (borrow > 0) {
            {
                uint balance = vars.sellToken.balanceOf(address(this));
                vars.sellPool.borrowBehalf(msg.sender, borrow);
                borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);
            }
            if (depositToken == longToken){
                (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);
                tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));
            }else{
                tv.borrowValue = borrow;
            }
        }
        require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) > vars.marginLimit, "MAM");
        tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);
        tv.depositAfterFees = deposit.sub(tv.fees);
        tv.dexDetail = dexData.toDexDetail();
        if (depositToken == longToken ){
            if (borrowed > 0){
                tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);
                tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);
            }
            tv.newHeld = tv.newHeld.add(tv.depositAfterFees);
        }else{
            tv.tradeSize = tv.depositAfterFees.add(borrowed);
            tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);
            tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);
        }
        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);
        trade.held = trade.held.add(tv.newHeld);
        trade.depositToken = depositToken;
        trade.deposited = trade.deposited.add(tv.depositAfterFees);
        trade.lastBlockNum = uint128(block.number);
        totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);
        require(OpenLevV1Lib.isPositionHealthy(
                msg.sender,
                true,
                OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),
                vars,
                dexData
            ), "PNH");
        emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail);
    }
    /// @notice Close trade by shares.
    /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param closeHeld Amount of shares to close.
    /// @param minOrMaxAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);
        //verify
        verifyCloseBefore(trade, marketVars, closeHeld, dexData);
        uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        Types.CloseTradeVars memory closeTradeVars;
        closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);
        closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);
        closeTradeVars.isPartialClose = closeHeld != trade.held;
        closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);
        closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        closeTradeVars.dexDetail = dexData.toDexDetail();
        //partial close
        if (closeTradeVars.isPartialClose) {
            closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);
            closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);
            trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);
        } else {
            closeTradeVars.depositDecrease = trade.deposited;
        }
        if (trade.depositToken != longToken) {
            minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);
            closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");
            closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;
            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);
            closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);
            doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);
        } else {
            uint balance = marketVars.buyToken.balanceOf(address(this));
            minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);
            closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);
            closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");
            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);
            closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);
            require(marketVars.sellToken.balanceOf(address(this)) >= closeTradeVars.depositReturn, "ISB");
            doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);
        }
        uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));
        require(repayed >= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");
        if (!closeTradeVars.isPartialClose) {
            delete activeTrades[msg.sender][marketId][longToken];
        }else{
            trade.held = trade.held.sub(closeHeld);
            trade.lastBlockNum = uint128(block.number);
        }
        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);
        closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }
        emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,
            closeTradeVars.token0Price, closeTradeVars.dexDetail);
    }
    /// @notice Liquidate if trade below margin limit.
    /// @dev For trades without sufficient funds to repay, use insurance.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param minBuy Slippage for Dex trading.
    /// @param maxSell Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade memory trade = activeTrades[owner][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }
        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());
        uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);
        require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");
        Types.LiquidateVars memory liquidateVars;
        liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);
        if (liquidateVars.penalty > 0) {
            doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);
        }
        liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);
        liquidateVars.dexDetail = dexData.toDexDetail();
        liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);
        liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        liquidateVars.marketId = marketId;
        liquidateVars.longToken = longToken;
        bool buySuccess;
        bytes memory sellAmountData;
        if (longToken == trade.depositToken) {
            maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);
            marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);
            (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(
                abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],
                taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)
            );
        }
        if (buySuccess) {
            {
                uint temp;
                assembly {
                    temp := mload(add(sellAmountData, 0x20))
                }
                liquidateVars.sellAmount = temp;
            }
            liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);
            marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
            liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);
            doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);
        } else {
            liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;
            liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);
            if (liquidateVars.receiveAmount >= liquidateVars.borrowed) {
                // fail if buy failed but sell succeeded
                require (longToken != trade.depositToken, "PH");
                marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
                liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);
                doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);
            } else {
                liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);
                liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);
                marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);
            }
        }
        liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);
        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);
        emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,
            trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);
        delete activeTrades[owner][marketId][longToken];
    }
    function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {
        return open == longToken ?
        Types.MarketVars(
            market.pool1,
            market.pool0,
            IERC20(market.token1),
            IERC20(market.token0),
            IERC20(market.token1).balanceOf(address(this)),
            IERC20(market.token0).balanceOf(address(this)),
            market.pool1Insurance,
            market.pool0Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs) :
        Types.MarketVars(
            market.pool0,
            market.pool1,
            IERC20(market.token0),
            IERC20(market.token1),
            IERC20(market.token0).balanceOf(address(this)),
            IERC20(market.token1).balanceOf(address(this)),
            market.pool0Insurance,
            market.pool1Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs);
    }
    /// @notice Get ratios of deposited token value to borrowed token value.
    /// @dev Caluclate ratio with current price and twap price.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param dexData Index and fee rate for the trading Dex.
    /// @return current Margin ratio calculated using current price.
    /// @return cAvg Margin ratio calculated using twap price.
    /// @return hAvg Margin ratio calculated using last recorded twap price.
    /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value.
    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {
        Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);
        limit = vars.marginLimit;
        (current, cAvg, hAvg,,) =
        OpenLevV1Lib.marginRatio(
            owner,
            activeTrades[owner][marketId][longToken].held,
            address(vars.sellToken),
            address(vars.buyToken),
            vars.buyPool,
            false,
            dexData
        );
    }
    /// @notice Check if a price update is required on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){
        Types.Market memory market = markets[marketId];
        return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData);
    }
    /// @notice Update price on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function updatePrice(uint16 marketId, bytes memory dexData) external override {
        OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData);
    }
    /// @notice List of all supporting Dexes.
    function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){
        return markets[marketId].dexs;
    }
    function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {
        Types.Market storage market = markets[marketId];
        uint needed = totalRepayment.sub(remaining);
        needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);
        maxCanRepayAmount = totalRepayment;
        if (longToken) {
            if (market.pool0Insurance >= needed) {
                market.pool0Insurance = market.pool0Insurance - needed;
                totalHelds[token] = totalHelds[token].sub(needed);
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);
                market.pool0Insurance = 0;
            }
        } else {
            if (market.pool1Insurance >= needed) {
                market.pool1Insurance = market.pool1Insurance - needed;
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);
                market.pool1Insurance = 0;
            }
        }
    }
    function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {
        // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);
        Types.Market storage market = markets[marketId];
        uint defaultFees = tradeSize.mul(market.feesRate).div(10000);
        uint newFees = defaultFees;
        // if trader holds more xOLE, then should enjoy trading discount.
        if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) > calculateConfig.feesDiscountThreshold) {
            newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));
        }
        // if trader update price, then should enjoy trading discount.
        if (market.priceUpdater == trader) {
            newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));
        }
        uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);
        IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));
        newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);
        if (token == market.token1) {
            market.pool1Insurance = market.pool1Insurance.add(newInsurance);
        } else {
            market.pool0Insurance = market.pool0Insurance.add(newInsurance);
        }
        totalHelds[token] = totalHelds[token].add(newInsurance);
        return newFees;
    }
    function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){
        if (sellAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);
            buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);
        }
    }
    function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){
        if (buyAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);
            sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);
        }
    }
    /// @dev All credited on this contract and share with all token holder if any rewards for the transfer.
    function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {
        return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount);
    }
    /// @dev All credited on "to" if any taxes for the transfer.
    function doTransferOut(address to, IERC20 token, uint amount) internal {
        OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount);
    }
    /*** Admin Functions ***/
    function setCalculateConfig(uint16 defaultFeesRate,
        uint8 insuranceRatio,
        uint16 defaultMarginLimit,
        uint16 priceDiffientRatio,
        uint16 updatePriceDiscount,
        uint16 feesDiscount,
        uint128 feesDiscountThreshold,
        uint16 penaltyRatio,
        uint8 maxLiquidationPriceDiffientRatio,
        uint16 twapDuration) external override onlyAdmin() {
        OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,
            feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);
        emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration);
    }
    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {
        OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);
        emit NewAddressConfig(controller, address(dexAggregator));
    }
    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {
        OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);
        emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs);
    }
    /// @notice List of all supporting Dexes.
    /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1
    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {
        Types.Market storage market = markets[marketId];
        if (poolIndex == 0) {
            market.pool0Insurance = market.pool0Insurance.sub(amount);
            (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));
            return;
        }
        market.pool1Insurance = market.pool1Insurance.sub(amount);
        (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this))));
    }
    function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {
        supportDexs[dex] = support;
    }
    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){
        taxes[marketId][token][index] = tax;
    }
    function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {
        Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];
        OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade);
    }
    function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {
        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());
        require(closeHeld <= trade.held, "CBH");
    }
    function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {
        require(held != 0 && lastBlockNumber != block.number && OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0");
    }
    modifier onlySupportDex(bytes memory dexData) {
        require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");
        _;
    }
}".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Let's start by analyzing the provided Solidity contract code. Here are some potential areas for improvement or enhancement:
1. **Access Control**: The contract uses a single admin for critical functions. Implementing a multi-signature wallet for administrative functions could enhance security by requiring multiple approvals for sensitive actions.
2. **Gas Optimization**: There are several places where the code could be optimized for gas usage. For example, using `memory` instead of `storage` where appropriate, or minimizing the number of state variable updates in functions could help reduce gas costs.
3. **Error Handling**: The contract uses `require` statements for error handling, which is good, but it could benefit from more descriptive error messages. This would make debugging easier and provide clearer feedback to users.
4. **Event Emission**: While there are some events emitted, ensuring that all state-changing functions emit relevant events can improve transparency and allow for better tracking of contract activity.
5. **Reentrancy Protection**: The contract uses `ReentrancyGuard`, which is great. However, we should ensure that all external calls are made at the end of the function to minimize the risk of reentrancy attacks.
6. **Upgradeability**: Consider implementing a proxy pattern for upgradeability. This would allow the contract to be upgraded in the future without losing state or requiring users to migrate to a new contract.
7. **Testing and Auditing**: Ensure comprehensive unit tests are in place, especially for critical functions like `marginTrade`, `closeTrade`, and `liquidate`. Additionally, a third-party audit could help identify vulnerabilities that may not be apparent during internal testing.
8. **Input Validation**: More rigorous input validation could be added, especially for parameters like `marketId`, `deposit`, and `borrow`. This would help prevent unexpected behavior from invalid inputs.
9. **Documentation**: While there are comments in the code, enhancing the documentation to include more detailed explanations of complex functions and their parameters would be beneficial for future developers.
10. **Emergency Mechanism**: Implementing an emergency stop mechanism (circuit breaker) would allow the admin to pause contract operations in case of a detected vulnerability or exploit.
Which of these suggestions resonates most with you, or do you have any other specific areas you would like to focus on? Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-24-08 18:27:18 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-24-08 18:27:18 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 21102
completion_tokens: 1
total_tokens: 21103
cost: $-1.000000


[2024-24-08 18:27:18 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;

pragma experimental ABIEncoderV2;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "./OpenLevInterface.sol";
import "./Types.sol";
import "./Adminable.sol";
import "./DelegateInterface.sol";
import "./ControllerInterface.sol";
import "./IWETH.sol";
import "./XOLEInterface.sol";
import "./Types.sol";
import "./OpenLevV1Lib.sol";

/// @title OpenLeverage margin trade logic
/// @author OpenLeverage
/// @notice Use this contract for margin trade.
/// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE.
contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {
    using SafeMath for uint;
    using TransferHelper for IERC20;
    using DexData for bytes;

    constructor ()
    {
    }

    /// @notice initialize proxy contract
    /// @dev This function is not supposed to call multiple times. All configs can be set through other functions.
    /// @param _controller Address of contract ControllerDelegator.
    /// @param _dexAggregator contract DexAggregatorDelegator.
    /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens.
    /// @param _wETH Address of wrapped native coin.
    /// @param _xOLE Address of XOLEDelegator.
    /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol.
    function initialize(
        address _controller,
        DexAggregatorInterface _dexAggregator,
        address[] memory depositTokens,
        address _wETH,
        address _xOLE,
        uint8[] memory _supportDexs
    ) public {
        depositTokens;
        require(msg.sender == admin, "NAD");
        addressConfig.controller = _controller;
        addressConfig.dexAggregator = _dexAggregator;
        addressConfig.wETH = _wETH;
        addressConfig.xOLE = _xOLE;
        for (uint i = 0; i < _supportDexs.length; i++) {
            supportDexs[_supportDexs[i]] = true;
        }
        OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig);
    }

    /// @notice Create new trading pair.
    /// @dev This function is typically called by ControllerDelegator.
    /// @param pool0 Contract LpoolDelegator, lending pool of token0.
    /// @param pool1 Contract LpoolDelegator, lending pool of token1.
    /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value.
    /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens.
    /// @return The new created pair ID.
    function addMarket(
        LPoolInterface pool0,
        LPoolInterface pool1,
        uint16 marginLimit,
        bytes memory dexData
    ) external override returns (uint16) {
        uint16 marketId = numPairs;
        OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);
        numPairs ++;
        return marketId;
    }

    /// @notice Margin trade or just add more deposit tokens.
    /// @dev To support token with tax and reward. Stores share of all token balances of this contract.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param depositToken Token to deposit. False for token0, true for token1.
    /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported.
    /// @param borrow Amount of ERC20 to borrow from the short token pool.
    /// @param minBuyAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function marginTrade(
        uint16 marketId,
        bool longToken,
        bool depositToken,
        uint deposit,
        uint borrow,
        uint minBuyAmount,
        bytes memory dexData
    ) external payable override nonReentrant onlySupportDex(dexData) {
        Types.TradeVars memory tv;
        Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);
        verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);
        (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);

        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);
        }

        tv.totalHeld = totalHelds[address(vars.buyToken)];
        tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;

        deposit = transferIn(msg.sender, tv.depositErc20, deposit);

        // Borrow
        uint borrowed;
        if (borrow > 0) {
            {
                uint balance = vars.sellToken.balanceOf(address(this));
                vars.sellPool.borrowBehalf(msg.sender, borrow);
                borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);
            }

            if (depositToken == longToken){
                (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);
                tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));
            }else{
                tv.borrowValue = borrow;
            }
        }

        require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) > vars.marginLimit, "MAM");
        tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);
        tv.depositAfterFees = deposit.sub(tv.fees);
        tv.dexDetail = dexData.toDexDetail();

        if (depositToken == longToken ){
            if (borrowed > 0){
                tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);
                tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);
            }
            tv.newHeld = tv.newHeld.add(tv.depositAfterFees);
        }else{
            tv.tradeSize = tv.depositAfterFees.add(borrowed);
            tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);
            tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);
        }

        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);
        trade.held = trade.held.add(tv.newHeld);
        trade.depositToken = depositToken;
        trade.deposited = trade.deposited.add(tv.depositAfterFees);
        trade.lastBlockNum = uint128(block.number);

        totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);

        require(OpenLevV1Lib.isPositionHealthy(
                msg.sender,
                true,
                OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),
                vars,
                dexData
            ), "PNH");

        emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail);
    }

    /// @notice Close trade by shares.
    /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param closeHeld Amount of shares to close.
    /// @param minOrMaxAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);

        //verify
        verifyCloseBefore(trade, marketVars, closeHeld, dexData);

        uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        Types.CloseTradeVars memory closeTradeVars;
        closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);
        closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);
        closeTradeVars.isPartialClose = closeHeld != trade.held;
        closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);
        closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        closeTradeVars.dexDetail = dexData.toDexDetail();

        //partial close
        if (closeTradeVars.isPartialClose) {
            closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);
            closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);
            trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);
        } else {
            closeTradeVars.depositDecrease = trade.deposited;
        }

        if (trade.depositToken != longToken) {
            minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);
            closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;
            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);

            closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);
            doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);
        } else {
            uint balance = marketVars.buyToken.balanceOf(address(this));
            minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);
            closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);
            closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);
            closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);
            require(marketVars.sellToken.balanceOf(address(this)) >= closeTradeVars.depositReturn, "ISB");
            doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);
        }

        uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));
        require(repayed >= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");

        if (!closeTradeVars.isPartialClose) {
            delete activeTrades[msg.sender][marketId][longToken];
        }else{
            trade.held = trade.held.sub(closeHeld);
            trade.lastBlockNum = uint128(block.number);
        }

        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);

        closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,
            closeTradeVars.token0Price, closeTradeVars.dexDetail);
    }

    /// @notice Liquidate if trade below margin limit.
    /// @dev For trades without sufficient funds to repay, use insurance.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param minBuy Slippage for Dex trading.
    /// @param maxSell Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade memory trade = activeTrades[owner][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());
        uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);
        require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");

        Types.LiquidateVars memory liquidateVars;
        liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);
        if (liquidateVars.penalty > 0) {
            doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);
        }
        liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);
        liquidateVars.dexDetail = dexData.toDexDetail();
        liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);
        liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        liquidateVars.marketId = marketId;
        liquidateVars.longToken = longToken;

        bool buySuccess;
        bytes memory sellAmountData;
        if (longToken == trade.depositToken) {
            maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);
            marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);
            (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(
                abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],
                taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)
            );
        }

        if (buySuccess) {
            {
                uint temp;
                assembly {
                    temp := mload(add(sellAmountData, 0x20))
                }
                liquidateVars.sellAmount = temp;
            }

            liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);
            marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
            liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);
            doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);
        } else {
            liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;
            liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);
            if (liquidateVars.receiveAmount >= liquidateVars.borrowed) {
                // fail if buy failed but sell succeeded
                require (longToken != trade.depositToken, "PH");
                marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
                liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);
                doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);
            } else {
                liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);
                liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);
                marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);
            }
        }

        liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);
        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);

        emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,
            trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);

        delete activeTrades[owner][marketId][longToken];
    }

    function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {
        return open == longToken ?
        Types.MarketVars(
            market.pool1,
            market.pool0,
            IERC20(market.token1),
            IERC20(market.token0),
            IERC20(market.token1).balanceOf(address(this)),
            IERC20(market.token0).balanceOf(address(this)),
            market.pool1Insurance,
            market.pool0Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs) :
        Types.MarketVars(
            market.pool0,
            market.pool1,
            IERC20(market.token0),
            IERC20(market.token1),
            IERC20(market.token0).balanceOf(address(this)),
            IERC20(market.token1).balanceOf(address(this)),
            market.pool0Insurance,
            market.pool1Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs);
    }

    /// @notice Get ratios of deposited token value to borrowed token value.
    /// @dev Caluclate ratio with current price and twap price.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param dexData Index and fee rate for the trading Dex.
    /// @return current Margin ratio calculated using current price.
    /// @return cAvg Margin ratio calculated using twap price.
    /// @return hAvg Margin ratio calculated using last recorded twap price.
    /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value.
    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {
        Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);
        limit = vars.marginLimit;
        (current, cAvg, hAvg,,) =
        OpenLevV1Lib.marginRatio(
            owner,
            activeTrades[owner][marketId][longToken].held,
            address(vars.sellToken),
            address(vars.buyToken),
            vars.buyPool,
            false,
            dexData
        );
    }

    /// @notice Check if a price update is required on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){
        Types.Market memory market = markets[marketId];
        return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData);
    }

    /// @notice Update price on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function updatePrice(uint16 marketId, bytes memory dexData) external override {
        OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData);
    }

    /// @notice List of all supporting Dexes.
    function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){
        return markets[marketId].dexs;
    }

    function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {
        Types.Market storage market = markets[marketId];
        uint needed = totalRepayment.sub(remaining);
        needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);
        maxCanRepayAmount = totalRepayment;
        if (longToken) {
            if (market.pool0Insurance >= needed) {
                market.pool0Insurance = market.pool0Insurance - needed;
                totalHelds[token] = totalHelds[token].sub(needed);
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);
                market.pool0Insurance = 0;
            }
        } else {
            if (market.pool1Insurance >= needed) {
                market.pool1Insurance = market.pool1Insurance - needed;
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);
                market.pool1Insurance = 0;
            }
        }
    }

    function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {
        // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);
        Types.Market storage market = markets[marketId];
        uint defaultFees = tradeSize.mul(market.feesRate).div(10000);
        uint newFees = defaultFees;
        // if trader holds more xOLE, then should enjoy trading discount.
        if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) > calculateConfig.feesDiscountThreshold) {
            newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));
        }
        // if trader update price, then should enjoy trading discount.
        if (market.priceUpdater == trader) {
            newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));
        }
        uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);
        IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));

        newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);
        if (token == market.token1) {
            market.pool1Insurance = market.pool1Insurance.add(newInsurance);
        } else {
            market.pool0Insurance = market.pool0Insurance.add(newInsurance);
        }

        totalHelds[token] = totalHelds[token].add(newInsurance);
        return newFees;
    }

    function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){
        if (sellAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);
            buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);
        }
    }

    function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){
        if (buyAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);
            sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);
        }
    }

    /// @dev All credited on this contract and share with all token holder if any rewards for the transfer.
    function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {
        return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount);
    }

    /// @dev All credited on "to" if any taxes for the transfer.
    function doTransferOut(address to, IERC20 token, uint amount) internal {
        OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount);
    }

    /*** Admin Functions ***/
    function setCalculateConfig(uint16 defaultFeesRate,
        uint8 insuranceRatio,
        uint16 defaultMarginLimit,
        uint16 priceDiffientRatio,
        uint16 updatePriceDiscount,
        uint16 feesDiscount,
        uint128 feesDiscountThreshold,
        uint16 penaltyRatio,
        uint8 maxLiquidationPriceDiffientRatio,
        uint16 twapDuration) external override onlyAdmin() {
        OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,
            feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);
        emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration);
    }

    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {
        OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);
        emit NewAddressConfig(controller, address(dexAggregator));
    }

    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {
        OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);
        emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs);
    }

    /// @notice List of all supporting Dexes.
    /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1
    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {
        Types.Market storage market = markets[marketId];
        if (poolIndex == 0) {
            market.pool0Insurance = market.pool0Insurance.sub(amount);
            (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));
            return;
        }
        market.pool1Insurance = market.pool1Insurance.sub(amount);
        (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this))));
    }

    function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {
        supportDexs[dex] = support;
    }

    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){
        taxes[marketId][token][index] = tax;
    }

    function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {
        Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];
        OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade);
    }

    function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {
        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());
        require(closeHeld <= trade.held, "CBH");
    }

    function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {
        require(held != 0 && lastBlockNumber != block.number && OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0");
    }

    modifier onlySupportDex(bytes memory dexData) {
        require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");
        _;
    }
}.]

1

[2024-24-08 18:27:18 INFO] **[Seminar Conclusion]**:

 1

[2024-24-08 18:27:18 INFO] **[Seminar Conclusion]**:

 <INFO> 1

[2024-24-08 18:27:18 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-24-08 18:27:18 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.7.6; pragma experimental ABIEncoderV2; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import "./OpenLevInterface.sol"; import "./Types.sol"; import "./Adminable.sol"; import "./DelegateInterface.sol"; import "./ControllerInterface.sol"; import "./IWETH.sol"; import "./XOLEInterface.sol"; import "./Types.sol"; import "./OpenLevV1Lib.sol"; /// @title OpenLeverage margin trade logic /// @author OpenLeverage /// @notice Use this contract for margin trade. /// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE. contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {     using SafeMath for uint;     using TransferHelper for IERC20;     using DexData for bytes; constructor () { }  /// @notice initialize proxy contract /// @dev This function is not supposed to call multiple times. All configs can be set through other functions. /// @param _controller Address of contract ControllerDelegator. /// @param _dexAggregator contract DexAggregatorDelegator. /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens. /// @param _wETH Address of wrapped native coin. /// @param _xOLE Address of XOLEDelegator. /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol. function initialize(     address _controller,     DexAggregatorInterface _dexAggregator,     address[] memory depositTokens,     address _wETH,     address _xOLE,     uint8[] memory _supportDexs ) public {     depositTokens;     require(msg.sender == admin, "NAD");     addressConfig.controller = _controller;     addressConfig.dexAggregator = _dexAggregator;     addressConfig.wETH = _wETH;     addressConfig.xOLE = _xOLE;     for (uint i = 0; i &lt; _supportDexs.length; i++) {         supportDexs[_supportDexs[i]] = true;     }     OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig); }  /// @notice Create new trading pair. /// @dev This function is typically called by ControllerDelegator. /// @param pool0 Contract LpoolDelegator, lending pool of token0. /// @param pool1 Contract LpoolDelegator, lending pool of token1. /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value. /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens. /// @return The new created pair ID. function addMarket(     LPoolInterface pool0,     LPoolInterface pool1,     uint16 marginLimit,     bytes memory dexData ) external override returns (uint16) {     uint16 marketId = numPairs;     OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);     numPairs ++;     return marketId; }  /// @notice Margin trade or just add more deposit tokens. /// @dev To support token with tax and reward. Stores share of all token balances of this contract. /// @param longToken Token to long. False for token0, true for token1. /// @param depositToken Token to deposit. False for token0, true for token1. /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported. /// @param borrow Amount of ERC20 to borrow from the short token pool. /// @param minBuyAmount Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function marginTrade(     uint16 marketId,     bool longToken,     bool depositToken,     uint deposit,     uint borrow,     uint minBuyAmount,     bytes memory dexData ) external payable override nonReentrant onlySupportDex(dexData) {     Types.TradeVars memory tv;     Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);     verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);     (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);      if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);     }      tv.totalHeld = totalHelds[address(vars.buyToken)];     tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;      deposit = transferIn(msg.sender, tv.depositErc20, deposit);      // Borrow     uint borrowed;     if (borrow &gt; 0) {         {             uint balance = vars.sellToken.balanceOf(address(this));             vars.sellPool.borrowBehalf(msg.sender, borrow);             borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);         }          if (depositToken == longToken){             (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);             tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));         }else{             tv.borrowValue = borrow;         }     }      require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) &gt; vars.marginLimit, "MAM");     tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);     tv.depositAfterFees = deposit.sub(tv.fees);     tv.dexDetail = dexData.toDexDetail();      if (depositToken == longToken ){         if (borrowed &gt; 0){             tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);             tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);         }         tv.newHeld = tv.newHeld.add(tv.depositAfterFees);     }else{         tv.tradeSize = tv.depositAfterFees.add(borrowed);         tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);         tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);     }      Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];     tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);     trade.held = trade.held.add(tv.newHeld);     trade.depositToken = depositToken;     trade.deposited = trade.deposited.add(tv.depositAfterFees);     trade.lastBlockNum = uint128(block.number);      totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);      require(OpenLevV1Lib.isPositionHealthy(             msg.sender,             true,             OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),             vars,             dexData         ), "PNH");      emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail); }  /// @notice Close trade by shares. /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed. /// @param longToken Token to long. False for token0, true for token1. /// @param closeHeld Amount of shares to close. /// @param minOrMaxAmount Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {     Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];     Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);      //verify     verifyCloseBefore(trade, marketVars, closeHeld, dexData);      uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);      Types.CloseTradeVars memory closeTradeVars;     closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);     closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);     closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);     closeTradeVars.isPartialClose = closeHeld != trade.held;     closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);     closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);     closeTradeVars.dexDetail = dexData.toDexDetail();      //partial close     if (closeTradeVars.isPartialClose) {         closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);         closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);         trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);     } else {         closeTradeVars.depositDecrease = trade.deposited;     }      if (trade.depositToken != longToken) {         minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);         closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);         require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");          closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;         marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);          closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);         doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);     } else {         uint balance = marketVars.buyToken.balanceOf(address(this));         minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);         closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);         closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);         require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");          marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);         closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);         require(marketVars.sellToken.balanceOf(address(this)) &gt;= closeTradeVars.depositReturn, "ISB");         doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);     }      uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));     require(repayed &gt;= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");      if (!closeTradeVars.isPartialClose) {         delete activeTrades[msg.sender][marketId][longToken];     }else{         trade.held = trade.held.sub(closeHeld);         trade.lastBlockNum = uint128(block.number);     }      totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);      closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);     if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);     }      emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,         closeTradeVars.token0Price, closeTradeVars.dexDetail); }  /// @notice Liquidate if trade below margin limit. /// @dev For trades without sufficient funds to repay, use insurance. /// @param owner Owner of the trade to liquidate. /// @param longToken Token to long. False for token0, true for token1. /// @param minBuy Slippage for Dex trading. /// @param maxSell Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {     Types.Trade memory trade = activeTrades[owner][marketId][longToken];     Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);     if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);     }      verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());     uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);      (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);     require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");      Types.LiquidateVars memory liquidateVars;     liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);     liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);     if (liquidateVars.penalty &gt; 0) {         doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);     }     liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);     liquidateVars.dexDetail = dexData.toDexDetail();     liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);     liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);     liquidateVars.marketId = marketId;     liquidateVars.longToken = longToken;      bool buySuccess;     bytes memory sellAmountData;     if (longToken == trade.depositToken) {         maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);         marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);         (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(             abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],             taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)         );     }      if (buySuccess) {         {             uint temp;             assembly {                 temp := mload(add(sellAmountData, 0x20))             }             liquidateVars.sellAmount = temp;         }          liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);         marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);         liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);         doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);     } else {         liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;         liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);         if (liquidateVars.receiveAmount &gt;= liquidateVars.borrowed) {             // fail if buy failed but sell succeeded             require (longToken != trade.depositToken, "PH");             marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);             liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);             doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);         } else {             liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);             liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);             marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);         }     }      liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);     totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);      emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,         trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);      delete activeTrades[owner][marketId][longToken]; }  function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {     return open == longToken ?     Types.MarketVars(         market.pool1,         market.pool0,         IERC20(market.token1),         IERC20(market.token0),         IERC20(market.token1).balanceOf(address(this)),         IERC20(market.token0).balanceOf(address(this)),         market.pool1Insurance,         market.pool0Insurance,         market.marginLimit,         market.priceDiffientRatio,         market.dexs) :     Types.MarketVars(         market.pool0,         market.pool1,         IERC20(market.token0),         IERC20(market.token1),         IERC20(market.token0).balanceOf(address(this)),         IERC20(market.token1).balanceOf(address(this)),         market.pool0Insurance,         market.pool1Insurance,         market.marginLimit,         market.priceDiffientRatio,         market.dexs); }  /// @notice Get ratios of deposited token value to borrowed token value. /// @dev Caluclate ratio with current price and twap price. /// @param owner Owner of the trade to liquidate. /// @param longToken Token to long. False for token0, true for token1. /// @param dexData Index and fee rate for the trading Dex. /// @return current Margin ratio calculated using current price. /// @return cAvg Margin ratio calculated using twap price. /// @return hAvg Margin ratio calculated using last recorded twap price. /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value. function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {     Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);     limit = vars.marginLimit;     (current, cAvg, hAvg,,) =     OpenLevV1Lib.marginRatio(         owner,         activeTrades[owner][marketId][longToken].held,         address(vars.sellToken),         address(vars.buyToken),         vars.buyPool,         false,         dexData     ); }  /// @notice Check if a price update is required on Dex. /// @param dexData Index and fee rate for the trading Dex. function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){     Types.Market memory market = markets[marketId];     return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData); }  /// @notice Update price on Dex. /// @param dexData Index and fee rate for the trading Dex. function updatePrice(uint16 marketId, bytes memory dexData) external override {     OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData); }  /// @notice List of all supporting Dexes. function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){     return markets[marketId].dexs; }  function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {     Types.Market storage market = markets[marketId];     uint needed = totalRepayment.sub(remaining);     needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);     maxCanRepayAmount = totalRepayment;     if (longToken) {         if (market.pool0Insurance &gt;= needed) {             market.pool0Insurance = market.pool0Insurance - needed;             totalHelds[token] = totalHelds[token].sub(needed);         } else {             maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);             maxCanRepayAmount = maxCanRepayAmount.add(remaining);             totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);             market.pool0Insurance = 0;         }     } else {         if (market.pool1Insurance &gt;= needed) {             market.pool1Insurance = market.pool1Insurance - needed;         } else {             maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);             maxCanRepayAmount = maxCanRepayAmount.add(remaining);             totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);             market.pool1Insurance = 0;         }     } }  function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {     // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);     Types.Market storage market = markets[marketId];     uint defaultFees = tradeSize.mul(market.feesRate).div(10000);     uint newFees = defaultFees;     // if trader holds more xOLE, then should enjoy trading discount.     if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) &gt; calculateConfig.feesDiscountThreshold) {         newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));     }     // if trader update price, then should enjoy trading discount.     if (market.priceUpdater == trader) {         newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));     }     uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);     IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));      newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);     if (token == market.token1) {         market.pool1Insurance = market.pool1Insurance.add(newInsurance);     } else {         market.pool0Insurance = market.pool0Insurance.add(newInsurance);     }      totalHelds[token] = totalHelds[token].add(newInsurance);     return newFees; }  function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){     if (sellAmount &gt; 0){         DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;         IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);         buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);     } }  function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){     if (buyAmount &gt; 0){         DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;         IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);         sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);     } }  /// @dev All credited on this contract and share with all token holder if any rewards for the transfer. function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {     return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount); }  /// @dev All credited on "to" if any taxes for the transfer. function doTransferOut(address to, IERC20 token, uint amount) internal {     OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount); }  /*** Admin Functions ***/ function setCalculateConfig(uint16 defaultFeesRate,     uint8 insuranceRatio,     uint16 defaultMarginLimit,     uint16 priceDiffientRatio,     uint16 updatePriceDiscount,     uint16 feesDiscount,     uint128 feesDiscountThreshold,     uint16 penaltyRatio,     uint8 maxLiquidationPriceDiffientRatio,     uint16 twapDuration) external override onlyAdmin() {     OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,         feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);     emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration); }  function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {     OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);     emit NewAddressConfig(controller, address(dexAggregator)); }  function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {     OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);     emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs); }  /// @notice List of all supporting Dexes. /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1 function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {     Types.Market storage market = markets[marketId];     if (poolIndex == 0) {         market.pool0Insurance = market.pool0Insurance.sub(amount);         (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));         return;     }     market.pool1Insurance = market.pool1Insurance.sub(amount);     (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this)))); }  function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {     supportDexs[dex] = support; }  function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){     taxes[marketId][token][index] = tax; }  function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {     Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];     OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade); }  function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {     verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());     require(closeHeld &lt;= trade.held, "CBH"); }  function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {     require(held != 0 &amp;&amp; lastBlockNumber != block.number &amp;&amp; OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0"); }  modifier onlySupportDex(bytes memory dexData) {     require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");     _; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.7.6;\n\npragma experimental ABIEncoderV2;\n\nimport "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\nimport "./OpenLevInterface.sol";\nimport "./Types.sol";\nimport "./Adminable.sol";\nimport "./DelegateInterface.sol";\nimport "./ControllerInterface.sol";\nimport "./IWETH.sol";\nimport "./XOLEInterface.sol";\nimport "./Types.sol";\nimport "./OpenLevV1Lib.sol";\n\n/// @title OpenLeverage margin trade logic\n/// @author OpenLeverage\n/// @notice Use this contract for margin trade.\n/// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE.\ncontract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {\n    using SafeMath for uint;\n    using TransferHelper for IERC20;\n    using DexData for bytes;\n\n    constructor ()\n    {\n    }\n\n    /// @notice initialize proxy contract\n    /// @dev This function is not supposed to call multiple times. All configs can be set through other functions.\n    /// @param controller Address of contract ControllerDelegator.\n    /// @param _dexAggregator contract DexAggregatorDelegator.\n    /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens.\n    /// @param _wETH Address of wrapped native coin.\n    /// @param _xOLE Address of XOLEDelegator.\n    /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol.\n    function initialize(\n        address _controller,\n        DexAggregatorInterface _dexAggregator,\n        address[] memory depositTokens,\n        address _wETH,\n        address _xOLE,\n        uint8[] memory _supportDexs\n    ) public {\n        depositTokens;\n        require(msg.sender == admin, "NAD");\n        addressConfig.controller = _controller;\n        addressConfig.dexAggregator = _dexAggregator;\n        addressConfig.wETH = _wETH;\n        addressConfig.xOLE = _xOLE;\n        for (uint i = 0; i &lt; _supportDexs.length; i++) {\n            supportDexs[_supportDexs[i]] = true;\n        }\n        OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig);\n    }\n\n    /// @notice Create new trading pair.\n    /// @dev This function is typically called by ControllerDelegator.\n    /// @param pool0 Contract LpoolDelegator, lending pool of token0.\n    /// @param pool1 Contract LpoolDelegator, lending pool of token1.\n    /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value.\n    /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens.\n    /// @return The new created pair ID.\n    function addMarket(\n        LPoolInterface pool0,\n        LPoolInterface pool1,\n        uint16 marginLimit,\n        bytes memory dexData\n    ) external override returns (uint16) {\n        uint16 marketId = numPairs;\n        OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);\n        numPairs ++;\n        return marketId;\n    }\n\n    /// @notice Margin trade or just add more deposit tokens.\n    /// @dev To support token with tax and reward. Stores share of all token balances of this contract.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param depositToken Token to deposit. False for token0, true for token1.\n    /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported.\n    /// @param borrow Amount of ERC20 to borrow from the short token pool.\n    /// @param minBuyAmount Slippage for Dex trading.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function marginTrade(\n        uint16 marketId,\n        bool longToken,\n        bool depositToken,\n        uint deposit,\n        uint borrow,\n        uint minBuyAmount,\n        bytes memory dexData\n    ) external payable override nonReentrant onlySupportDex(dexData) {\n        Types.TradeVars memory tv;\n        Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);\n        verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);\n        (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);\n\n        if (dexData.isUniV2Class()) {\n            OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);\n        }\n\n        tv.totalHeld = totalHelds[address(vars.buyToken)];\n        tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;\n\n        deposit = transferIn(msg.sender, tv.depositErc20, deposit);\n\n        // Borrow\n        uint borrowed;\n        if (borrow &gt; 0) {\n            {\n                uint balance = vars.sellToken.balanceOf(address(this));\n                vars.sellPool.borrowBehalf(msg.sender, borrow);\n                borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);\n            }\n\n            if (depositToken == longToken){\n                (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);\n                tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));\n            }else{\n                tv.borrowValue = borrow;\n            }\n        }\n\n        require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) &gt; vars.marginLimit, "MAM");\n        tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);\n        tv.depositAfterFees = deposit.sub(tv.fees);\n        tv.dexDetail = dexData.toDexDetail();\n\n        if (depositToken == longToken ){\n            if (borrowed &gt; 0){\n                tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);\n                tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);\n            }\n            tv.newHeld = tv.newHeld.add(tv.depositAfterFees);\n        }else{\n            tv.tradeSize = tv.depositAfterFees.add(borrowed);\n            tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);\n            tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);\n        }\n\n        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];\n        tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);\n        trade.held = trade.held.add(tv.newHeld);\n        trade.depositToken = depositToken;\n        trade.deposited = trade.deposited.add(tv.depositAfterFees);\n        trade.lastBlockNum = uint128(block.number);\n\n        totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);\n\n        require(OpenLevV1Lib.isPositionHealthy(\n                msg.sender,\n                true,\n                OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),\n                vars,\n                dexData\n            ), "PNH");\n\n        emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail);\n    }\n\n    /// @notice Close trade by shares.\n    /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param closeHeld Amount of shares to close.\n    /// @param minOrMaxAmount Slippage for Dex trading.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {\n        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];\n        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);\n\n        //verify\n        verifyCloseBefore(trade, marketVars, closeHeld, dexData);\n\n        uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n\n        Types.CloseTradeVars memory closeTradeVars;\n        closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n        closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);\n        closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);\n        closeTradeVars.isPartialClose = closeHeld != trade.held;\n        closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);\n        closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);\n        closeTradeVars.dexDetail = dexData.toDexDetail();\n\n        //partial close\n        if (closeTradeVars.isPartialClose) {\n            closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);\n            closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);\n            trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);\n        } else {\n            closeTradeVars.depositDecrease = trade.deposited;\n        }\n\n        if (trade.depositToken != longToken) {\n            minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);\n            closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);\n            require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");\n\n            closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;\n            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);\n\n            closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);\n            doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);\n        } else {\n            uint balance = marketVars.buyToken.balanceOf(address(this));\n            minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);\n            closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);\n            closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);\n            require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");\n\n            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);\n            closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);\n            require(marketVars.sellToken.balanceOf(address(this)) &gt;= closeTradeVars.depositReturn, "ISB");\n            doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);\n        }\n\n        uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));\n        require(repayed &gt;= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");\n\n        if (!closeTradeVars.isPartialClose) {\n            delete activeTrades[msg.sender][marketId][longToken];\n        }else{\n            trade.held = trade.held.sub(closeHeld);\n            trade.lastBlockNum = uint128(block.number);\n        }\n\n        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);\n\n        closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);\n        if (dexData.isUniV2Class()) {\n            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);\n        }\n\n        emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,\n            closeTradeVars.token0Price, closeTradeVars.dexDetail);\n    }\n\n    /// @notice Liquidate if trade below margin limit.\n    /// @dev For trades without sufficient funds to repay, use insurance.\n    /// @param owner Owner of the trade to liquidate.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param minBuy Slippage for Dex trading.\n    /// @param maxSell Slippage for Dex trading.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {\n        Types.Trade memory trade = activeTrades[owner][marketId][longToken];\n        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);\n        if (dexData.isUniV2Class()) {\n            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);\n        }\n\n        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());\n        uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n\n        (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);\n        require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");\n\n        Types.LiquidateVars memory liquidateVars;\n        liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n        liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);\n        if (liquidateVars.penalty &gt; 0) {\n            doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);\n        }\n        liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);\n        liquidateVars.dexDetail = dexData.toDexDetail();\n        liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);\n        liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);\n        liquidateVars.marketId = marketId;\n        liquidateVars.longToken = longToken;\n\n        bool buySuccess;\n        bytes memory sellAmountData;\n        if (longToken == trade.depositToken) {\n            maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);\n            marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);\n            (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(\n                abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],\n                taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)\n            );\n        }\n\n        if (buySuccess) {\n            {\n                uint temp;\n                assembly {\n                    temp := mload(add(sellAmountData, 0x20))\n                }\n                liquidateVars.sellAmount = temp;\n            }\n\n            liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);\n            marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);\n            liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);\n            doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);\n        } else {\n            liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;\n            liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);\n            if (liquidateVars.receiveAmount &gt;= liquidateVars.borrowed) {\n                // fail if buy failed but sell succeeded\n                require (longToken != trade.depositToken, "PH");\n                marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);\n                liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);\n                doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);\n            } else {\n                liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);\n                liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);\n                marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);\n            }\n        }\n\n        liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);\n        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);\n\n        emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,\n            trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);\n\n        delete activeTrades[owner][marketId][longToken];\n    }\n\n    function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {\n        return open == longToken ?\n        Types.MarketVars(\n            market.pool1,\n            market.pool0,\n            IERC20(market.token1),\n            IERC20(market.token0),\n            IERC20(market.token1).balanceOf(address(this)),\n            IERC20(market.token0).balanceOf(address(this)),\n            market.pool1Insurance,\n            market.pool0Insurance,\n            market.marginLimit,\n            market.priceDiffientRatio,\n            market.dexs) :\n        Types.MarketVars(\n            market.pool0,\n            market.pool1,\n            IERC20(market.token0),\n            IERC20(market.token1),\n            IERC20(market.token0).balanceOf(address(this)),\n            IERC20(market.token1).balanceOf(address(this)),\n            market.pool0Insurance,\n            market.pool1Insurance,\n            market.marginLimit,\n            market.priceDiffientRatio,\n            market.dexs);\n    }\n\n    /// @notice Get ratios of deposited token value to borrowed token value.\n    /// @dev Caluclate ratio with current price and twap price.\n    /// @param owner Owner of the trade to liquidate.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param dexData Index and fee rate for the trading Dex.\n    /// @return current Margin ratio calculated using current price.\n    /// @return cAvg Margin ratio calculated using twap price.\n    /// @return hAvg Margin ratio calculated using last recorded twap price.\n    /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value.\n    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {\n        Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);\n        limit = vars.marginLimit;\n        (current, cAvg, hAvg,,) =\n        OpenLevV1Lib.marginRatio(\n            owner,\n            activeTrades[owner][marketId][longToken].held,\n            address(vars.sellToken),\n            address(vars.buyToken),\n            vars.buyPool,\n            false,\n            dexData\n        );\n    }\n\n    /// @notice Check if a price update is required on Dex.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){\n        Types.Market memory market = markets[marketId];\n        return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData);\n    }\n\n    /// @notice Update price on Dex.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function updatePrice(uint16 marketId, bytes memory dexData) external override {\n        OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData);\n    }\n\n    /// @notice List of all supporting Dexes.\n    function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){\n        return markets[marketId].dexs;\n    }\n\n    function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {\n        Types.Market storage market = markets[marketId];\n        uint needed = totalRepayment.sub(remaining);\n        needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);\n        maxCanRepayAmount = totalRepayment;\n        if (longToken) {\n            if (market.pool0Insurance &gt;= needed) {\n                market.pool0Insurance = market.pool0Insurance - needed;\n                totalHelds[token] = totalHelds[token].sub(needed);\n            } else {\n                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);\n                maxCanRepayAmount = maxCanRepayAmount.add(remaining);\n                totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);\n                market.pool0Insurance = 0;\n            }\n        } else {\n            if (market.pool1Insurance &gt;= needed) {\n                market.pool1Insurance = market.pool1Insurance - needed;\n            } else {\n                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);\n                maxCanRepayAmount = maxCanRepayAmount.add(remaining);\n                totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);\n                market.pool1Insurance = 0;\n            }\n        }\n    }\n\n    function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {\n        // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);\n        Types.Market storage market = markets[marketId];\n        uint defaultFees = tradeSize.mul(market.feesRate).div(10000);\n        uint newFees = defaultFees;\n        // if trader holds more xOLE, then should enjoy trading discount.\n        if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) &gt; calculateConfig.feesDiscountThreshold) {\n            newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));\n        }\n        // if trader update price, then should enjoy trading discount.\n        if (market.priceUpdater == trader) {\n            newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));\n        }\n        uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);\n        IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));\n\n        newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);\n        if (token == market.token1) {\n            market.pool1Insurance = market.pool1Insurance.add(newInsurance);\n        } else {\n            market.pool0Insurance = market.pool0Insurance.add(newInsurance);\n        }\n\n        totalHelds[token] = totalHelds[token].add(newInsurance);\n        return newFees;\n    }\n\n    function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){\n        if (sellAmount &gt; 0){\n            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;\n            IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);\n            buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);\n        }\n    }\n\n    function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){\n        if (buyAmount &gt; 0){\n            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;\n            IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);\n            sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);\n        }\n    }\n\n    /// @dev All credited on this contract and share with all token holder if any rewards for the transfer.\n    function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {\n        return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount);\n    }\n\n    /// @dev All credited on "to" if any taxes for the transfer.\n    function doTransferOut(address to, IERC20 token, uint amount) internal {\n        OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount);\n    }\n\n    / Admin Functions /\n    function setCalculateConfig(uint16 defaultFeesRate,\n        uint8 insuranceRatio,\n        uint16 defaultMarginLimit,\n        uint16 priceDiffientRatio,\n        uint16 updatePriceDiscount,\n        uint16 feesDiscount,\n        uint128 feesDiscountThreshold,\n        uint16 penaltyRatio,\n        uint8 maxLiquidationPriceDiffientRatio,\n        uint16 twapDuration) external override onlyAdmin() {\n        OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,\n            feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);\n        emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration);\n    }\n\n    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {\n        OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);\n        emit NewAddressConfig(controller, address(dexAggregator));\n    }\n\n    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {\n        OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);\n        emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs);\n    }\n\n    /// @notice List of all supporting Dexes.\n    /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1\n    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {\n        Types.Market storage market = markets[marketId];\n        if (poolIndex == 0) {\n            market.pool0Insurance = market.pool0Insurance.sub(amount);\n            (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));\n            return;\n        }\n        market.pool1Insurance = market.pool1Insurance.sub(amount);\n        (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this))));\n    }\n\n    function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {\n        supportDexs[dex] = support;\n    }\n\n    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){\n        taxes[marketId][token][index] = tax;\n    }\n\n    function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {\n        Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];\n        OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade);\n    }\n\n    function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {\n        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());\n        require(closeHeld &lt;= trade.held, "CBH");\n    }\n\n    function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {\n        require(held != 0 &amp;&amp; lastBlockNumber != block.number &amp;&amp; OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0");\n    }\n\n    modifier onlySupportDex(bytes memory dexData) {\n        require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");\n        ;\n    }\n}', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-24-08 18:27:18 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.7.6; pragma experimental ABIEncoderV2; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import "./OpenLevInterface.sol"; import "./Types.sol"; import "./Adminable.sol"; import "./DelegateInterface.sol"; import "./ControllerInterface.sol"; import "./IWETH.sol"; import "./XOLEInterface.sol"; import "./Types.sol"; import "./OpenLevV1Lib.sol"; /// @title OpenLeverage margin trade logic /// @author OpenLeverage /// @notice Use this contract for margin trade. /// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE. contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {     using SafeMath for uint;     using TransferHelper for IERC20;     using DexData for bytes; constructor () { }  /// @notice initialize proxy contract /// @dev This function is not supposed to call multiple times. All configs can be set through other functions. /// @param _controller Address of contract ControllerDelegator. /// @param _dexAggregator contract DexAggregatorDelegator. /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens. /// @param _wETH Address of wrapped native coin. /// @param _xOLE Address of XOLEDelegator. /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol. function initialize(     address _controller,     DexAggregatorInterface _dexAggregator,     address[] memory depositTokens,     address _wETH,     address _xOLE,     uint8[] memory _supportDexs ) public {     depositTokens;     require(msg.sender == admin, "NAD");     addressConfig.controller = _controller;     addressConfig.dexAggregator = _dexAggregator;     addressConfig.wETH = _wETH;     addressConfig.xOLE = _xOLE;     for (uint i = 0; i &lt; _supportDexs.length; i++) {         supportDexs[_supportDexs[i]] = true;     }     OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig); }  /// @notice Create new trading pair. /// @dev This function is typically called by ControllerDelegator. /// @param pool0 Contract LpoolDelegator, lending pool of token0. /// @param pool1 Contract LpoolDelegator, lending pool of token1. /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value. /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens. /// @return The new created pair ID. function addMarket(     LPoolInterface pool0,     LPoolInterface pool1,     uint16 marginLimit,     bytes memory dexData ) external override returns (uint16) {     uint16 marketId = numPairs;     OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);     numPairs ++;     return marketId; }  /// @notice Margin trade or just add more deposit tokens. /// @dev To support token with tax and reward. Stores share of all token balances of this contract. /// @param longToken Token to long. False for token0, true for token1. /// @param depositToken Token to deposit. False for token0, true for token1. /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported. /// @param borrow Amount of ERC20 to borrow from the short token pool. /// @param minBuyAmount Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function marginTrade(     uint16 marketId,     bool longToken,     bool depositToken,     uint deposit,     uint borrow,     uint minBuyAmount,     bytes memory dexData ) external payable override nonReentrant onlySupportDex(dexData) {     Types.TradeVars memory tv;     Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);     verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);     (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);      if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);     }      tv.totalHeld = totalHelds[address(vars.buyToken)];     tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;      deposit = transferIn(msg.sender, tv.depositErc20, deposit);      // Borrow     uint borrowed;     if (borrow &gt; 0) {         {             uint balance = vars.sellToken.balanceOf(address(this));             vars.sellPool.borrowBehalf(msg.sender, borrow);             borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);         }          if (depositToken == longToken){             (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);             tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));         }else{             tv.borrowValue = borrow;         }     }      require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) &gt; vars.marginLimit, "MAM");     tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);     tv.depositAfterFees = deposit.sub(tv.fees);     tv.dexDetail = dexData.toDexDetail();      if (depositToken == longToken ){         if (borrowed &gt; 0){             tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);             tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);         }         tv.newHeld = tv.newHeld.add(tv.depositAfterFees);     }else{         tv.tradeSize = tv.depositAfterFees.add(borrowed);         tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);         tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);     }      Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];     tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);     trade.held = trade.held.add(tv.newHeld);     trade.depositToken = depositToken;     trade.deposited = trade.deposited.add(tv.depositAfterFees);     trade.lastBlockNum = uint128(block.number);      totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);      require(OpenLevV1Lib.isPositionHealthy(             msg.sender,             true,             OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),             vars,             dexData         ), "PNH");      emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail); }  /// @notice Close trade by shares. /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed. /// @param longToken Token to long. False for token0, true for token1. /// @param closeHeld Amount of shares to close. /// @param minOrMaxAmount Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {     Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];     Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);      //verify     verifyCloseBefore(trade, marketVars, closeHeld, dexData);      uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);      Types.CloseTradeVars memory closeTradeVars;     closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);     closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);     closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);     closeTradeVars.isPartialClose = closeHeld != trade.held;     closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);     closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);     closeTradeVars.dexDetail = dexData.toDexDetail();      //partial close     if (closeTradeVars.isPartialClose) {         closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);         closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);         trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);     } else {         closeTradeVars.depositDecrease = trade.deposited;     }      if (trade.depositToken != longToken) {         minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);         closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);         require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");          closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;         marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);          closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);         doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);     } else {         uint balance = marketVars.buyToken.balanceOf(address(this));         minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);         closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);         closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);         require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");          marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);         closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);         require(marketVars.sellToken.balanceOf(address(this)) &gt;= closeTradeVars.depositReturn, "ISB");         doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);     }      uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));     require(repayed &gt;= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");      if (!closeTradeVars.isPartialClose) {         delete activeTrades[msg.sender][marketId][longToken];     }else{         trade.held = trade.held.sub(closeHeld);         trade.lastBlockNum = uint128(block.number);     }      totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);      closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);     if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);     }      emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,         closeTradeVars.token0Price, closeTradeVars.dexDetail); }  /// @notice Liquidate if trade below margin limit. /// @dev For trades without sufficient funds to repay, use insurance. /// @param owner Owner of the trade to liquidate. /// @param longToken Token to long. False for token0, true for token1. /// @param minBuy Slippage for Dex trading. /// @param maxSell Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {     Types.Trade memory trade = activeTrades[owner][marketId][longToken];     Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);     if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);     }      verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());     uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);      (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);     require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");      Types.LiquidateVars memory liquidateVars;     liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);     liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);     if (liquidateVars.penalty &gt; 0) {         doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);     }     liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);     liquidateVars.dexDetail = dexData.toDexDetail();     liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);     liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);     liquidateVars.marketId = marketId;     liquidateVars.longToken = longToken;      bool buySuccess;     bytes memory sellAmountData;     if (longToken == trade.depositToken) {         maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);         marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);         (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(             abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],             taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)         );     }      if (buySuccess) {         {             uint temp;             assembly {                 temp := mload(add(sellAmountData, 0x20))             }             liquidateVars.sellAmount = temp;         }          liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);         marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);         liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);         doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);     } else {         liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;         liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);         if (liquidateVars.receiveAmount &gt;= liquidateVars.borrowed) {             // fail if buy failed but sell succeeded             require (longToken != trade.depositToken, "PH");             marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);             liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);             doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);         } else {             liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);             liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);             marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);         }     }      liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);     totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);      emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,         trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);      delete activeTrades[owner][marketId][longToken]; }  function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {     return open == longToken ?     Types.MarketVars(         market.pool1,         market.pool0,         IERC20(market.token1),         IERC20(market.token0),         IERC20(market.token1).balanceOf(address(this)),         IERC20(market.token0).balanceOf(address(this)),         market.pool1Insurance,         market.pool0Insurance,         market.marginLimit,         market.priceDiffientRatio,         market.dexs) :     Types.MarketVars(         market.pool0,         market.pool1,         IERC20(market.token0),         IERC20(market.token1),         IERC20(market.token0).balanceOf(address(this)),         IERC20(market.token1).balanceOf(address(this)),         market.pool0Insurance,         market.pool1Insurance,         market.marginLimit,         market.priceDiffientRatio,         market.dexs); }  /// @notice Get ratios of deposited token value to borrowed token value. /// @dev Caluclate ratio with current price and twap price. /// @param owner Owner of the trade to liquidate. /// @param longToken Token to long. False for token0, true for token1. /// @param dexData Index and fee rate for the trading Dex. /// @return current Margin ratio calculated using current price. /// @return cAvg Margin ratio calculated using twap price. /// @return hAvg Margin ratio calculated using last recorded twap price. /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value. function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {     Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);     limit = vars.marginLimit;     (current, cAvg, hAvg,,) =     OpenLevV1Lib.marginRatio(         owner,         activeTrades[owner][marketId][longToken].held,         address(vars.sellToken),         address(vars.buyToken),         vars.buyPool,         false,         dexData     ); }  /// @notice Check if a price update is required on Dex. /// @param dexData Index and fee rate for the trading Dex. function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){     Types.Market memory market = markets[marketId];     return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData); }  /// @notice Update price on Dex. /// @param dexData Index and fee rate for the trading Dex. function updatePrice(uint16 marketId, bytes memory dexData) external override {     OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData); }  /// @notice List of all supporting Dexes. function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){     return markets[marketId].dexs; }  function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {     Types.Market storage market = markets[marketId];     uint needed = totalRepayment.sub(remaining);     needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);     maxCanRepayAmount = totalRepayment;     if (longToken) {         if (market.pool0Insurance &gt;= needed) {             market.pool0Insurance = market.pool0Insurance - needed;             totalHelds[token] = totalHelds[token].sub(needed);         } else {             maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);             maxCanRepayAmount = maxCanRepayAmount.add(remaining);             totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);             market.pool0Insurance = 0;         }     } else {         if (market.pool1Insurance &gt;= needed) {             market.pool1Insurance = market.pool1Insurance - needed;         } else {             maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);             maxCanRepayAmount = maxCanRepayAmount.add(remaining);             totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);             market.pool1Insurance = 0;         }     } }  function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {     // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);     Types.Market storage market = markets[marketId];     uint defaultFees = tradeSize.mul(market.feesRate).div(10000);     uint newFees = defaultFees;     // if trader holds more xOLE, then should enjoy trading discount.     if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) &gt; calculateConfig.feesDiscountThreshold) {         newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));     }     // if trader update price, then should enjoy trading discount.     if (market.priceUpdater == trader) {         newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));     }     uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);     IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));      newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);     if (token == market.token1) {         market.pool1Insurance = market.pool1Insurance.add(newInsurance);     } else {         market.pool0Insurance = market.pool0Insurance.add(newInsurance);     }      totalHelds[token] = totalHelds[token].add(newInsurance);     return newFees; }  function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){     if (sellAmount &gt; 0){         DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;         IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);         buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);     } }  function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){     if (buyAmount &gt; 0){         DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;         IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);         sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);     } }  /// @dev All credited on this contract and share with all token holder if any rewards for the transfer. function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {     return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount); }  /// @dev All credited on "to" if any taxes for the transfer. function doTransferOut(address to, IERC20 token, uint amount) internal {     OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount); }  /*** Admin Functions ***/ function setCalculateConfig(uint16 defaultFeesRate,     uint8 insuranceRatio,     uint16 defaultMarginLimit,     uint16 priceDiffientRatio,     uint16 updatePriceDiscount,     uint16 feesDiscount,     uint128 feesDiscountThreshold,     uint16 penaltyRatio,     uint8 maxLiquidationPriceDiffientRatio,     uint16 twapDuration) external override onlyAdmin() {     OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,         feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);     emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration); }  function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {     OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);     emit NewAddressConfig(controller, address(dexAggregator)); }  function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {     OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);     emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs); }  /// @notice List of all supporting Dexes. /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1 function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {     Types.Market storage market = markets[marketId];     if (poolIndex == 0) {         market.pool0Insurance = market.pool0Insurance.sub(amount);         (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));         return;     }     market.pool1Insurance = market.pool1Insurance.sub(amount);     (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this)))); }  function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {     supportDexs[dex] = support; }  function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){     taxes[marketId][token][index] = tax; }  function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {     Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];     OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade); }  function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {     verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());     require(closeHeld &lt;= trade.held, "CBH"); }  function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {     require(held != 0 &amp;&amp; lastBlockNumber != block.number &amp;&amp; OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0"); }  modifier onlySupportDex(bytes memory dexData) {     require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");     _; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-24-08 18:27:18 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;

pragma experimental ABIEncoderV2;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "./OpenLevInterface.sol";
import "./Types.sol";
import "./Adminable.sol";
import "./DelegateInterface.sol";
import "./ControllerInterface.sol";
import "./IWETH.sol";
import "./XOLEInterface.sol";
import "./Types.sol";
import "./OpenLevV1Lib.sol";

/// @title OpenLeverage margin trade logic
/// @author OpenLeverage
/// @notice Use this contract for margin trade.
/// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE.
contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {
    using SafeMath for uint;
    using TransferHelper for IERC20;
    using DexData for bytes;

    constructor ()
    {
    }

    /// @notice initialize proxy contract
    /// @dev This function is not supposed to call multiple times. All configs can be set through other functions.
    /// @param _controller Address of contract ControllerDelegator.
    /// @param _dexAggregator contract DexAggregatorDelegator.
    /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens.
    /// @param _wETH Address of wrapped native coin.
    /// @param _xOLE Address of XOLEDelegator.
    /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol.
    function initialize(
        address _controller,
        DexAggregatorInterface _dexAggregator,
        address[] memory depositTokens,
        address _wETH,
        address _xOLE,
        uint8[] memory _supportDexs
    ) public {
        depositTokens;
        require(msg.sender == admin, "NAD");
        addressConfig.controller = _controller;
        addressConfig.dexAggregator = _dexAggregator;
        addressConfig.wETH = _wETH;
        addressConfig.xOLE = _xOLE;
        for (uint i = 0; i < _supportDexs.length; i++) {
            supportDexs[_supportDexs[i]] = true;
        }
        OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig);
    }

    /// @notice Create new trading pair.
    /// @dev This function is typically called by ControllerDelegator.
    /// @param pool0 Contract LpoolDelegator, lending pool of token0.
    /// @param pool1 Contract LpoolDelegator, lending pool of token1.
    /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value.
    /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens.
    /// @return The new created pair ID.
    function addMarket(
        LPoolInterface pool0,
        LPoolInterface pool1,
        uint16 marginLimit,
        bytes memory dexData
    ) external override returns (uint16) {
        uint16 marketId = numPairs;
        OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);
        numPairs ++;
        return marketId;
    }

    /// @notice Margin trade or just add more deposit tokens.
    /// @dev To support token with tax and reward. Stores share of all token balances of this contract.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param depositToken Token to deposit. False for token0, true for token1.
    /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported.
    /// @param borrow Amount of ERC20 to borrow from the short token pool.
    /// @param minBuyAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function marginTrade(
        uint16 marketId,
        bool longToken,
        bool depositToken,
        uint deposit,
        uint borrow,
        uint minBuyAmount,
        bytes memory dexData
    ) external payable override nonReentrant onlySupportDex(dexData) {
        Types.TradeVars memory tv;
        Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);
        verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);
        (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);

        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);
        }

        tv.totalHeld = totalHelds[address(vars.buyToken)];
        tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;

        deposit = transferIn(msg.sender, tv.depositErc20, deposit);

        // Borrow
        uint borrowed;
        if (borrow > 0) {
            {
                uint balance = vars.sellToken.balanceOf(address(this));
                vars.sellPool.borrowBehalf(msg.sender, borrow);
                borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);
            }

            if (depositToken == longToken){
                (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);
                tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));
            }else{
                tv.borrowValue = borrow;
            }
        }

        require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) > vars.marginLimit, "MAM");
        tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);
        tv.depositAfterFees = deposit.sub(tv.fees);
        tv.dexDetail = dexData.toDexDetail();

        if (depositToken == longToken ){
            if (borrowed > 0){
                tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);
                tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);
            }
            tv.newHeld = tv.newHeld.add(tv.depositAfterFees);
        }else{
            tv.tradeSize = tv.depositAfterFees.add(borrowed);
            tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);
            tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);
        }

        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);
        trade.held = trade.held.add(tv.newHeld);
        trade.depositToken = depositToken;
        trade.deposited = trade.deposited.add(tv.depositAfterFees);
        trade.lastBlockNum = uint128(block.number);

        totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);

        require(OpenLevV1Lib.isPositionHealthy(
                msg.sender,
                true,
                OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),
                vars,
                dexData
            ), "PNH");

        emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail);
    }

    /// @notice Close trade by shares.
    /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param closeHeld Amount of shares to close.
    /// @param minOrMaxAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);

        //verify
        verifyCloseBefore(trade, marketVars, closeHeld, dexData);

        uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        Types.CloseTradeVars memory closeTradeVars;
        closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);
        closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);
        closeTradeVars.isPartialClose = closeHeld != trade.held;
        closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);
        closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        closeTradeVars.dexDetail = dexData.toDexDetail();

        //partial close
        if (closeTradeVars.isPartialClose) {
            closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);
            closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);
            trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);
        } else {
            closeTradeVars.depositDecrease = trade.deposited;
        }

        if (trade.depositToken != longToken) {
            minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);
            closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;
            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);

            closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);
            doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);
        } else {
            uint balance = marketVars.buyToken.balanceOf(address(this));
            minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);
            closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);
            closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);
            closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);
            require(marketVars.sellToken.balanceOf(address(this)) >= closeTradeVars.depositReturn, "ISB");
            doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);
        }

        uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));
        require(repayed >= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");

        if (!closeTradeVars.isPartialClose) {
            delete activeTrades[msg.sender][marketId][longToken];
        }else{
            trade.held = trade.held.sub(closeHeld);
            trade.lastBlockNum = uint128(block.number);
        }

        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);

        closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,
            closeTradeVars.token0Price, closeTradeVars.dexDetail);
    }

    /// @notice Liquidate if trade below margin limit.
    /// @dev For trades without sufficient funds to repay, use insurance.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param minBuy Slippage for Dex trading.
    /// @param maxSell Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade memory trade = activeTrades[owner][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());
        uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);
        require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");

        Types.LiquidateVars memory liquidateVars;
        liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);
        if (liquidateVars.penalty > 0) {
            doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);
        }
        liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);
        liquidateVars.dexDetail = dexData.toDexDetail();
        liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);
        liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        liquidateVars.marketId = marketId;
        liquidateVars.longToken = longToken;

        bool buySuccess;
        bytes memory sellAmountData;
        if (longToken == trade.depositToken) {
            maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);
            marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);
            (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(
                abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],
                taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)
            );
        }

        if (buySuccess) {
            {
                uint temp;
                assembly {
                    temp := mload(add(sellAmountData, 0x20))
                }
                liquidateVars.sellAmount = temp;
            }

            liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);
            marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
            liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);
            doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);
        } else {
            liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;
            liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);
            if (liquidateVars.receiveAmount >= liquidateVars.borrowed) {
                // fail if buy failed but sell succeeded
                require (longToken != trade.depositToken, "PH");
                marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
                liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);
                doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);
            } else {
                liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);
                liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);
                marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);
            }
        }

        liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);
        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);

        emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,
            trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);

        delete activeTrades[owner][marketId][longToken];
    }

    function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {
        return open == longToken ?
        Types.MarketVars(
            market.pool1,
            market.pool0,
            IERC20(market.token1),
            IERC20(market.token0),
            IERC20(market.token1).balanceOf(address(this)),
            IERC20(market.token0).balanceOf(address(this)),
            market.pool1Insurance,
            market.pool0Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs) :
        Types.MarketVars(
            market.pool0,
            market.pool1,
            IERC20(market.token0),
            IERC20(market.token1),
            IERC20(market.token0).balanceOf(address(this)),
            IERC20(market.token1).balanceOf(address(this)),
            market.pool0Insurance,
            market.pool1Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs);
    }

    /// @notice Get ratios of deposited token value to borrowed token value.
    /// @dev Caluclate ratio with current price and twap price.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param dexData Index and fee rate for the trading Dex.
    /// @return current Margin ratio calculated using current price.
    /// @return cAvg Margin ratio calculated using twap price.
    /// @return hAvg Margin ratio calculated using last recorded twap price.
    /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value.
    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {
        Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);
        limit = vars.marginLimit;
        (current, cAvg, hAvg,,) =
        OpenLevV1Lib.marginRatio(
            owner,
            activeTrades[owner][marketId][longToken].held,
            address(vars.sellToken),
            address(vars.buyToken),
            vars.buyPool,
            false,
            dexData
        );
    }

    /// @notice Check if a price update is required on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){
        Types.Market memory market = markets[marketId];
        return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData);
    }

    /// @notice Update price on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function updatePrice(uint16 marketId, bytes memory dexData) external override {
        OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData);
    }

    /// @notice List of all supporting Dexes.
    function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){
        return markets[marketId].dexs;
    }

    function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {
        Types.Market storage market = markets[marketId];
        uint needed = totalRepayment.sub(remaining);
        needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);
        maxCanRepayAmount = totalRepayment;
        if (longToken) {
            if (market.pool0Insurance >= needed) {
                market.pool0Insurance = market.pool0Insurance - needed;
                totalHelds[token] = totalHelds[token].sub(needed);
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);
                market.pool0Insurance = 0;
            }
        } else {
            if (market.pool1Insurance >= needed) {
                market.pool1Insurance = market.pool1Insurance - needed;
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);
                market.pool1Insurance = 0;
            }
        }
    }

    function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {
        // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);
        Types.Market storage market = markets[marketId];
        uint defaultFees = tradeSize.mul(market.feesRate).div(10000);
        uint newFees = defaultFees;
        // if trader holds more xOLE, then should enjoy trading discount.
        if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) > calculateConfig.feesDiscountThreshold) {
            newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));
        }
        // if trader update price, then should enjoy trading discount.
        if (market.priceUpdater == trader) {
            newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));
        }
        uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);
        IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));

        newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);
        if (token == market.token1) {
            market.pool1Insurance = market.pool1Insurance.add(newInsurance);
        } else {
            market.pool0Insurance = market.pool0Insurance.add(newInsurance);
        }

        totalHelds[token] = totalHelds[token].add(newInsurance);
        return newFees;
    }

    function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){
        if (sellAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);
            buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);
        }
    }

    function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){
        if (buyAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);
            sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);
        }
    }

    /// @dev All credited on this contract and share with all token holder if any rewards for the transfer.
    function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {
        return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount);
    }

    /// @dev All credited on "to" if any taxes for the transfer.
    function doTransferOut(address to, IERC20 token, uint amount) internal {
        OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount);
    }

    /*** Admin Functions ***/
    function setCalculateConfig(uint16 defaultFeesRate,
        uint8 insuranceRatio,
        uint16 defaultMarginLimit,
        uint16 priceDiffientRatio,
        uint16 updatePriceDiscount,
        uint16 feesDiscount,
        uint128 feesDiscountThreshold,
        uint16 penaltyRatio,
        uint8 maxLiquidationPriceDiffientRatio,
        uint16 twapDuration) external override onlyAdmin() {
        OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,
            feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);
        emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration);
    }

    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {
        OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);
        emit NewAddressConfig(controller, address(dexAggregator));
    }

    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {
        OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);
        emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs);
    }

    /// @notice List of all supporting Dexes.
    /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1
    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {
        Types.Market storage market = markets[marketId];
        if (poolIndex == 0) {
            market.pool0Insurance = market.pool0Insurance.sub(amount);
            (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));
            return;
        }
        market.pool1Insurance = market.pool1Insurance.sub(amount);
        (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this))));
    }

    function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {
        supportDexs[dex] = support;
    }

    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){
        taxes[marketId][token][index] = tax;
    }

    function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {
        Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];
        OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade);
    }

    function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {
        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());
        require(closeHeld <= trade.held, "CBH");
    }

    function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {
        require(held != 0 && lastBlockNumber != block.number && OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0");
    }

    modifier onlySupportDex(bytes memory dexData) {
        require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");
        _;
    }
}.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;

pragma experimental ABIEncoderV2;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "./OpenLevInterface.sol";
import "./Types.sol";
import "./Adminable.sol";
import "./DelegateInterface.sol";
import "./ControllerInterface.sol";
import "./IWETH.sol";
import "./XOLEInterface.sol";
import "./Types.sol";
import "./OpenLevV1Lib.sol";

/// @title OpenLeverage margin trade logic
/// @author OpenLeverage
/// @notice Use this contract for margin trade.
/// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE.
contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {
    using SafeMath for uint;
    using TransferHelper for IERC20;
    using DexData for bytes;

    constructor ()
    {
    }

    /// @notice initialize proxy contract
    /// @dev This function is not supposed to call multiple times. All configs can be set through other functions.
    /// @param _controller Address of contract ControllerDelegator.
    /// @param _dexAggregator contract DexAggregatorDelegator.
    /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens.
    /// @param _wETH Address of wrapped native coin.
    /// @param _xOLE Address of XOLEDelegator.
    /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol.
    function initialize(
        address _controller,
        DexAggregatorInterface _dexAggregator,
        address[] memory depositTokens,
        address _wETH,
        address _xOLE,
        uint8[] memory _supportDexs
    ) public {
        depositTokens;
        require(msg.sender == admin, "NAD");
        addressConfig.controller = _controller;
        addressConfig.dexAggregator = _dexAggregator;
        addressConfig.wETH = _wETH;
        addressConfig.xOLE = _xOLE;
        for (uint i = 0; i < _supportDexs.length; i++) {
            supportDexs[_supportDexs[i]] = true;
        }
        OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig);
    }

    /// @notice Create new trading pair.
    /// @dev This function is typically called by ControllerDelegator.
    /// @param pool0 Contract LpoolDelegator, lending pool of token0.
    /// @param pool1 Contract LpoolDelegator, lending pool of token1.
    /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value.
    /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens.
    /// @return The new created pair ID.
    function addMarket(
        LPoolInterface pool0,
        LPoolInterface pool1,
        uint16 marginLimit,
        bytes memory dexData
    ) external override returns (uint16) {
        uint16 marketId = numPairs;
        OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);
        numPairs ++;
        return marketId;
    }

    /// @notice Margin trade or just add more deposit tokens.
    /// @dev To support token with tax and reward. Stores share of all token balances of this contract.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param depositToken Token to deposit. False for token0, true for token1.
    /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported.
    /// @param borrow Amount of ERC20 to borrow from the short token pool.
    /// @param minBuyAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function marginTrade(
        uint16 marketId,
        bool longToken,
        bool depositToken,
        uint deposit,
        uint borrow,
        uint minBuyAmount,
        bytes memory dexData
    ) external payable override nonReentrant onlySupportDex(dexData) {
        Types.TradeVars memory tv;
        Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);
        verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);
        (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);

        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);
        }

        tv.totalHeld = totalHelds[address(vars.buyToken)];
        tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;

        deposit = transferIn(msg.sender, tv.depositErc20, deposit);

        // Borrow
        uint borrowed;
        if (borrow > 0) {
            {
                uint balance = vars.sellToken.balanceOf(address(this));
                vars.sellPool.borrowBehalf(msg.sender, borrow);
                borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);
            }

            if (depositToken == longToken){
                (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);
                tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));
            }else{
                tv.borrowValue = borrow;
            }
        }

        require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) > vars.marginLimit, "MAM");
        tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);
        tv.depositAfterFees = deposit.sub(tv.fees);
        tv.dexDetail = dexData.toDexDetail();

        if (depositToken == longToken ){
            if (borrowed > 0){
                tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);
                tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);
            }
            tv.newHeld = tv.newHeld.add(tv.depositAfterFees);
        }else{
            tv.tradeSize = tv.depositAfterFees.add(borrowed);
            tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);
            tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);
        }

        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);
        trade.held = trade.held.add(tv.newHeld);
        trade.depositToken = depositToken;
        trade.deposited = trade.deposited.add(tv.depositAfterFees);
        trade.lastBlockNum = uint128(block.number);

        totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);

        require(OpenLevV1Lib.isPositionHealthy(
                msg.sender,
                true,
                OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),
                vars,
                dexData
            ), "PNH");

        emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail);
    }

    /// @notice Close trade by shares.
    /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param closeHeld Amount of shares to close.
    /// @param minOrMaxAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);

        //verify
        verifyCloseBefore(trade, marketVars, closeHeld, dexData);

        uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        Types.CloseTradeVars memory closeTradeVars;
        closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);
        closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);
        closeTradeVars.isPartialClose = closeHeld != trade.held;
        closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);
        closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        closeTradeVars.dexDetail = dexData.toDexDetail();

        //partial close
        if (closeTradeVars.isPartialClose) {
            closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);
            closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);
            trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);
        } else {
            closeTradeVars.depositDecrease = trade.deposited;
        }

        if (trade.depositToken != longToken) {
            minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);
            closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;
            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);

            closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);
            doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);
        } else {
            uint balance = marketVars.buyToken.balanceOf(address(this));
            minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);
            closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);
            closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);
            closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);
            require(marketVars.sellToken.balanceOf(address(this)) >= closeTradeVars.depositReturn, "ISB");
            doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);
        }

        uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));
        require(repayed >= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");

        if (!closeTradeVars.isPartialClose) {
            delete activeTrades[msg.sender][marketId][longToken];
        }else{
            trade.held = trade.held.sub(closeHeld);
            trade.lastBlockNum = uint128(block.number);
        }

        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);

        closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,
            closeTradeVars.token0Price, closeTradeVars.dexDetail);
    }

    /// @notice Liquidate if trade below margin limit.
    /// @dev For trades without sufficient funds to repay, use insurance.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param minBuy Slippage for Dex trading.
    /// @param maxSell Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade memory trade = activeTrades[owner][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());
        uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);
        require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");

        Types.LiquidateVars memory liquidateVars;
        liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);
        if (liquidateVars.penalty > 0) {
            doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);
        }
        liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);
        liquidateVars.dexDetail = dexData.toDexDetail();
        liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);
        liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        liquidateVars.marketId = marketId;
        liquidateVars.longToken = longToken;

        bool buySuccess;
        bytes memory sellAmountData;
        if (longToken == trade.depositToken) {
            maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);
            marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);
            (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(
                abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],
                taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)
            );
        }

        if (buySuccess) {
            {
                uint temp;
                assembly {
                    temp := mload(add(sellAmountData, 0x20))
                }
                liquidateVars.sellAmount = temp;
            }

            liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);
            marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
            liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);
            doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);
        } else {
            liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;
            liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);
            if (liquidateVars.receiveAmount >= liquidateVars.borrowed) {
                // fail if buy failed but sell succeeded
                require (longToken != trade.depositToken, "PH");
                marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
                liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);
                doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);
            } else {
                liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);
                liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);
                marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);
            }
        }

        liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);
        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);

        emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,
            trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);

        delete activeTrades[owner][marketId][longToken];
    }

    function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {
        return open == longToken ?
        Types.MarketVars(
            market.pool1,
            market.pool0,
            IERC20(market.token1),
            IERC20(market.token0),
            IERC20(market.token1).balanceOf(address(this)),
            IERC20(market.token0).balanceOf(address(this)),
            market.pool1Insurance,
            market.pool0Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs) :
        Types.MarketVars(
            market.pool0,
            market.pool1,
            IERC20(market.token0),
            IERC20(market.token1),
            IERC20(market.token0).balanceOf(address(this)),
            IERC20(market.token1).balanceOf(address(this)),
            market.pool0Insurance,
            market.pool1Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs);
    }

    /// @notice Get ratios of deposited token value to borrowed token value.
    /// @dev Caluclate ratio with current price and twap price.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param dexData Index and fee rate for the trading Dex.
    /// @return current Margin ratio calculated using current price.
    /// @return cAvg Margin ratio calculated using twap price.
    /// @return hAvg Margin ratio calculated using last recorded twap price.
    /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value.
    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {
        Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);
        limit = vars.marginLimit;
        (current, cAvg, hAvg,,) =
        OpenLevV1Lib.marginRatio(
            owner,
            activeTrades[owner][marketId][longToken].held,
            address(vars.sellToken),
            address(vars.buyToken),
            vars.buyPool,
            false,
            dexData
        );
    }

    /// @notice Check if a price update is required on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){
        Types.Market memory market = markets[marketId];
        return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData);
    }

    /// @notice Update price on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function updatePrice(uint16 marketId, bytes memory dexData) external override {
        OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData);
    }

    /// @notice List of all supporting Dexes.
    function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){
        return markets[marketId].dexs;
    }

    function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {
        Types.Market storage market = markets[marketId];
        uint needed = totalRepayment.sub(remaining);
        needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);
        maxCanRepayAmount = totalRepayment;
        if (longToken) {
            if (market.pool0Insurance >= needed) {
                market.pool0Insurance = market.pool0Insurance - needed;
                totalHelds[token] = totalHelds[token].sub(needed);
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);
                market.pool0Insurance = 0;
            }
        } else {
            if (market.pool1Insurance >= needed) {
                market.pool1Insurance = market.pool1Insurance - needed;
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);
                market.pool1Insurance = 0;
            }
        }
    }

    function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {
        // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);
        Types.Market storage market = markets[marketId];
        uint defaultFees = tradeSize.mul(market.feesRate).div(10000);
        uint newFees = defaultFees;
        // if trader holds more xOLE, then should enjoy trading discount.
        if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) > calculateConfig.feesDiscountThreshold) {
            newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));
        }
        // if trader update price, then should enjoy trading discount.
        if (market.priceUpdater == trader) {
            newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));
        }
        uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);
        IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));

        newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);
        if (token == market.token1) {
            market.pool1Insurance = market.pool1Insurance.add(newInsurance);
        } else {
            market.pool0Insurance = market.pool0Insurance.add(newInsurance);
        }

        totalHelds[token] = totalHelds[token].add(newInsurance);
        return newFees;
    }

    function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){
        if (sellAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);
            buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);
        }
    }

    function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){
        if (buyAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);
            sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);
        }
    }

    /// @dev All credited on this contract and share with all token holder if any rewards for the transfer.
    function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {
        return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount);
    }

    /// @dev All credited on "to" if any taxes for the transfer.
    function doTransferOut(address to, IERC20 token, uint amount) internal {
        OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount);
    }

    /*** Admin Functions ***/
    function setCalculateConfig(uint16 defaultFeesRate,
        uint8 insuranceRatio,
        uint16 defaultMarginLimit,
        uint16 priceDiffientRatio,
        uint16 updatePriceDiscount,
        uint16 feesDiscount,
        uint128 feesDiscountThreshold,
        uint16 penaltyRatio,
        uint8 maxLiquidationPriceDiffientRatio,
        uint16 twapDuration) external override onlyAdmin() {
        OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,
            feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);
        emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration);
    }

    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {
        OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);
        emit NewAddressConfig(controller, address(dexAggregator));
    }

    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {
        OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);
        emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs);
    }

    /// @notice List of all supporting Dexes.
    /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1
    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {
        Types.Market storage market = markets[marketId];
        if (poolIndex == 0) {
            market.pool0Insurance = market.pool0Insurance.sub(amount);
            (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));
            return;
        }
        market.pool1Insurance = market.pool1Insurance.sub(amount);
        (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this))));
    }

    function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {
        supportDexs[dex] = support;
    }

    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){
        taxes[marketId][token][index] = tax;
    }

    function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {
        Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];
        OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade);
    }

    function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {
        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());
        require(closeHeld <= trade.held, "CBH");
    }

    function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {
        require(held != 0 && lastBlockNumber != block.number && OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0");
    }

    modifier onlySupportDex(bytes memory dexData) {
        require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");
        _;
    }
}".
Ideas: " 1".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-24-08 18:27:33 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-24-08 18:27:33 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 13711
completion_tokens: 1095
total_tokens: 14806
cost: $-1.000000


[2024-24-08 18:27:33 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;

pragma experimental ABIEncoderV2;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "./OpenLevInterface.sol";
import "./Types.sol";
import "./Adminable.sol";
import "./DelegateInterface.sol";
import "./ControllerInterface.sol";
import "./IWETH.sol";
import "./XOLEInterface.sol";
import "./Types.sol";
import "./OpenLevV1Lib.sol";

/// @title OpenLeverage margin trade logic
/// @author OpenLeverage
/// @notice Use this contract for margin trade.
/// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE.
contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {
    using SafeMath for uint;
    using TransferHelper for IERC20;
    using DexData for bytes;

    constructor ()
    {
    }

    /// @notice initialize proxy contract
    /// @dev This function is not supposed to call multiple times. All configs can be set through other functions.
    /// @param _controller Address of contract ControllerDelegator.
    /// @param _dexAggregator contract DexAggregatorDelegator.
    /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens.
    /// @param _wETH Address of wrapped native coin.
    /// @param _xOLE Address of XOLEDelegator.
    /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol.
    function initialize(
        address _controller,
        DexAggregatorInterface _dexAggregator,
        address[] memory depositTokens,
        address _wETH,
        address _xOLE,
        uint8[] memory _supportDexs
    ) public {
        depositTokens;
        require(msg.sender == admin, "NAD");
        addressConfig.controller = _controller;
        addressConfig.dexAggregator = _dexAggregator;
        addressConfig.wETH = _wETH;
        addressConfig.xOLE = _xOLE;
        for (uint i = 0; i < _supportDexs.length; i++) {
            supportDexs[_supportDexs[i]] = true;
        }
        OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig);
    }

    /// @notice Create new trading pair.
    /// @dev This function is typically called by ControllerDelegator.
    /// @param pool0 Contract LpoolDelegator, lending pool of token0.
    /// @param pool1 Contract LpoolDelegator, lending pool of token1.
    /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value.
    /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens.
    /// @return The new created pair ID.
    function addMarket(
        LPoolInterface pool0,
        LPoolInterface pool1,
        uint16 marginLimit,
        bytes memory dexData
    ) external override returns (uint16) {
        uint16 marketId = numPairs;
        OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);
        numPairs ++;
        return marketId;
    }

    /// @notice Margin trade or just add more deposit tokens.
    /// @dev To support token with tax and reward. Stores share of all token balances of this contract.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param depositToken Token to deposit. False for token0, true for token1.
    /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported.
    /// @param borrow Amount of ERC20 to borrow from the short token pool.
    /// @param minBuyAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function marginTrade(
        uint16 marketId,
        bool longToken,
        bool depositToken,
        uint deposit,
        uint borrow,
        uint minBuyAmount,
        bytes memory dexData
    ) external payable override nonReentrant onlySupportDex(dexData) {
        Types.TradeVars memory tv;
        Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);
        verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);
        (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);

        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);
        }

        tv.totalHeld = totalHelds[address(vars.buyToken)];
        tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;

        deposit = transferIn(msg.sender, tv.depositErc20, deposit);

        // Borrow
        uint borrowed;
        if (borrow > 0) {
            {
                uint balance = vars.sellToken.balanceOf(address(this));
                vars.sellPool.borrowBehalf(msg.sender, borrow);
                borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);
            }

            if (depositToken == longToken){
                (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);
                tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));
            }else{
                tv.borrowValue = borrow;
            }
        }

        require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) > vars.marginLimit, "MAM");
        tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);
        tv.depositAfterFees = deposit.sub(tv.fees);
        tv.dexDetail = dexData.toDexDetail();

        if (depositToken == longToken ){
            if (borrowed > 0){
                tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);
                tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);
            }
            tv.newHeld = tv.newHeld.add(tv.depositAfterFees);
        }else{
            tv.tradeSize = tv.depositAfterFees.add(borrowed);
            tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);
            tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);
        }

        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);
        trade.held = trade.held.add(tv.newHeld);
        trade.depositToken = depositToken;
        trade.deposited = trade.deposited.add(tv.depositAfterFees);
        trade.lastBlockNum = uint128(block.number);

        totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);

        require(OpenLevV1Lib.isPositionHealthy(
                msg.sender,
                true,
                OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),
                vars,
                dexData
            ), "PNH");

        emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail);
    }

    /// @notice Close trade by shares.
    /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param closeHeld Amount of shares to close.
    /// @param minOrMaxAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);

        //verify
        verifyCloseBefore(trade, marketVars, closeHeld, dexData);

        uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        Types.CloseTradeVars memory closeTradeVars;
        closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);
        closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);
        closeTradeVars.isPartialClose = closeHeld != trade.held;
        closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);
        closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        closeTradeVars.dexDetail = dexData.toDexDetail();

        //partial close
        if (closeTradeVars.isPartialClose) {
            closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);
            closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);
            trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);
        } else {
            closeTradeVars.depositDecrease = trade.deposited;
        }

        if (trade.depositToken != longToken) {
            minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);
            closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;
            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);

            closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);
            doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);
        } else {
            uint balance = marketVars.buyToken.balanceOf(address(this));
            minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);
            closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);
            closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);
            closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);
            require(marketVars.sellToken.balanceOf(address(this)) >= closeTradeVars.depositReturn, "ISB");
            doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);
        }

        uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));
        require(repayed >= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");

        if (!closeTradeVars.isPartialClose) {
            delete activeTrades[msg.sender][marketId][longToken];
        }else{
            trade.held = trade.held.sub(closeHeld);
            trade.lastBlockNum = uint128(block.number);
        }

        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);

        closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,
            closeTradeVars.token0Price, closeTradeVars.dexDetail);
    }

    /// @notice Liquidate if trade below margin limit.
    /// @dev For trades without sufficient funds to repay, use insurance.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param minBuy Slippage for Dex trading.
    /// @param maxSell Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade memory trade = activeTrades[owner][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());
        uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);
        require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");

        Types.LiquidateVars memory liquidateVars;
        liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);
        if (liquidateVars.penalty > 0) {
            doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);
        }
        liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);
        liquidateVars.dexDetail = dexData.toDexDetail();
        liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);
        liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        liquidateVars.marketId = marketId;
        liquidateVars.longToken = longToken;

        bool buySuccess;
        bytes memory sellAmountData;
        if (longToken == trade.depositToken) {
            maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);
            marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);
            (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(
                abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],
                taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)
            );
        }

        if (buySuccess) {
            {
                uint temp;
                assembly {
                    temp := mload(add(sellAmountData, 0x20))
                }
                liquidateVars.sellAmount = temp;
            }

            liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);
            marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
            liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);
            doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);
        } else {
            liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;
            liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);
            if (liquidateVars.receiveAmount >= liquidateVars.borrowed) {
                // fail if buy failed but sell succeeded
                require (longToken != trade.depositToken, "PH");
                marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
                liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);
                doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);
            } else {
                liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);
                liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);
                marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);
            }
        }

        liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);
        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);

        emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,
            trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);

        delete activeTrades[owner][marketId][longToken];
    }

    function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {
        return open == longToken ?
        Types.MarketVars(
            market.pool1,
            market.pool0,
            IERC20(market.token1),
            IERC20(market.token0),
            IERC20(market.token1).balanceOf(address(this)),
            IERC20(market.token0).balanceOf(address(this)),
            market.pool1Insurance,
            market.pool0Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs) :
        Types.MarketVars(
            market.pool0,
            market.pool1,
            IERC20(market.token0),
            IERC20(market.token1),
            IERC20(market.token0).balanceOf(address(this)),
            IERC20(market.token1).balanceOf(address(this)),
            market.pool0Insurance,
            market.pool1Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs);
    }

    /// @notice Get ratios of deposited token value to borrowed token value.
    /// @dev Caluclate ratio with current price and twap price.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param dexData Index and fee rate for the trading Dex.
    /// @return current Margin ratio calculated using current price.
    /// @return cAvg Margin ratio calculated using twap price.
    /// @return hAvg Margin ratio calculated using last recorded twap price.
    /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value.
    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {
        Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);
        limit = vars.marginLimit;
        (current, cAvg, hAvg,,) =
        OpenLevV1Lib.marginRatio(
            owner,
            activeTrades[owner][marketId][longToken].held,
            address(vars.sellToken),
            address(vars.buyToken),
            vars.buyPool,
            false,
            dexData
        );
    }

    /// @notice Check if a price update is required on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){
        Types.Market memory market = markets[marketId];
        return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData);
    }

    /// @notice Update price on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function updatePrice(uint16 marketId, bytes memory dexData) external override {
        OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData);
    }

    /// @notice List of all supporting Dexes.
    function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){
        return markets[marketId].dexs;
    }

    function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {
        Types.Market storage market = markets[marketId];
        uint needed = totalRepayment.sub(remaining);
        needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);
        maxCanRepayAmount = totalRepayment;
        if (longToken) {
            if (market.pool0Insurance >= needed) {
                market.pool0Insurance = market.pool0Insurance - needed;
                totalHelds[token] = totalHelds[token].sub(needed);
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);
                market.pool0Insurance = 0;
            }
        } else {
            if (market.pool1Insurance >= needed) {
                market.pool1Insurance = market.pool1Insurance - needed;
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);
                market.pool1Insurance = 0;
            }
        }
    }

    function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {
        // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);
        Types.Market storage market = markets[marketId];
        uint defaultFees = tradeSize.mul(market.feesRate).div(10000);
        uint newFees = defaultFees;
        // if trader holds more xOLE, then should enjoy trading discount.
        if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) > calculateConfig.feesDiscountThreshold) {
            newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));
        }
        // if trader update price, then should enjoy trading discount.
        if (market.priceUpdater == trader) {
            newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));
        }
        uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);
        IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));

        newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);
        if (token == market.token1) {
            market.pool1Insurance = market.pool1Insurance.add(newInsurance);
        } else {
            market.pool0Insurance = market.pool0Insurance.add(newInsurance);
        }

        totalHelds[token] = totalHelds[token].add(newInsurance);
        return newFees;
    }

    function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){
        if (sellAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);
            buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);
        }
    }

    function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){
        if (buyAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);
            sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);
        }
    }

    /// @dev All credited on this contract and share with all token holder if any rewards for the transfer.
    function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {
        return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount);
    }

    /// @dev All credited on "to" if any taxes for the transfer.
    function doTransferOut(address to, IERC20 token, uint amount) internal {
        OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount);
    }

    /*** Admin Functions ***/
    function setCalculateConfig(uint16 defaultFeesRate,
        uint8 insuranceRatio,
        uint16 defaultMarginLimit,
        uint16 priceDiffientRatio,
        uint16 updatePriceDiscount,
        uint16 feesDiscount,
        uint128 feesDiscountThreshold,
        uint16 penaltyRatio,
        uint8 maxLiquidationPriceDiffientRatio,
        uint16 twapDuration) external override onlyAdmin() {
        OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,
            feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);
        emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration);
    }

    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {
        OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);
        emit NewAddressConfig(controller, address(dexAggregator));
    }

    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {
        OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);
        emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs);
    }

    /// @notice List of all supporting Dexes.
    /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1
    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {
        Types.Market storage market = markets[marketId];
        if (poolIndex == 0) {
            market.pool0Insurance = market.pool0Insurance.sub(amount);
            (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));
            return;
        }
        market.pool1Insurance = market.pool1Insurance.sub(amount);
        (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this))));
    }

    function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {
        supportDexs[dex] = support;
    }

    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){
        taxes[marketId][token][index] = tax;
    }

    function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {
        Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];
        OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade);
    }

    function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {
        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());
        require(closeHeld <= trade.held, "CBH");
    }

    function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {
        require(held != 0 && lastBlockNumber != block.number && OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0");
    }

    modifier onlySupportDex(bytes memory dexData) {
        require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");
        _;
    }
}.]

### VULNERABILITY: Reentrancy Attack
```
DETAILED DESCRIPTION: The contract uses the `nonReentrant` modifier from the `ReentrancyGuard` contract to prevent reentrancy attacks. However, there are still areas in the code where reentrancy could be exploited, particularly in functions that involve external calls to other contracts (e.g., `flashSell`, `flashBuy`, `doTransferOut`). If an external contract is malicious, it could call back into the `OpenLevV1` contract during the execution of these functions, potentially leading to unexpected behavior or loss of funds.

RECOMMENDED MITIGATION: Ensure that all external calls are made at the end of the function execution or use checks-effects-interactions pattern. Additionally, consider using a more robust reentrancy guard that tracks the state of each function call.
```

### VULNERABILITY: Arithmetic Overflow/Underflow
```
DETAILED DESCRIPTION: Although the contract uses the `SafeMath` library to perform arithmetic operations, there are still instances where unchecked arithmetic could occur, especially when manipulating values that are derived from external calls or user inputs. If an arithmetic operation results in an overflow or underflow, it could lead to unexpected behavior, such as incorrect balances or unintended contract states.

RECOMMENDED MITIGATION: Ensure that all arithmetic operations are wrapped in `SafeMath` functions, especially when dealing with values that can be influenced by user input or external contracts. Regularly audit the code to ensure that no arithmetic operations are performed without proper checks.
```

### VULNERABILITY: Lack of Access Control
```
DETAILED DESCRIPTION: The contract has several functions that are marked with the `onlyAdmin` modifier, which restricts access to certain administrative functions. However, there are functions like `initialize`, `addMarket`, and `marginTrade` that do not have sufficient access control. This could allow unauthorized users to call these functions, potentially leading to malicious activities such as creating markets or executing trades without proper authorization.

RECOMMENDED MITIGATION: Implement proper access control for all functions that modify the state of the contract or its critical parameters. Ensure that only authorized addresses can call these functions. Consider using OpenZeppelin's `Ownable` or `AccessControl` contracts for better management of roles and permissions.
```

### VULNERABILITY: Insufficient Validation of External Data
```
DETAILED DESCRIPTION: The contract relies on external data from other contracts (e.g., prices from the `dexAggregator`). If these external contracts are compromised or provide malicious data, it could lead to incorrect calculations, such as in the `marginTrade` and `liquidate` functions. This could result in significant financial losses for users.

RECOMMENDED MITIGATION: Implement checks to validate the data received from external contracts. For example, set acceptable ranges for prices or implement a fallback mechanism to handle unexpected values. Additionally, consider using oracles that provide reliable and tamper-proof data.
```

### VULNERABILITY: Gas Limit and Loops
```
DETAILED DESCRIPTION: The contract contains loops, such as in the `initialize` function where it iterates over `_supportDexs`. If the input array is too large, it could exceed the gas limit, causing the transaction to fail. This could be exploited by an attacker to prevent the contract from being initialized or configured properly.

RECOMMENDED MITIGATION: Avoid using loops that can potentially iterate over large arrays. Instead, consider using mappings or other data structures that do not require iteration. If loops are necessary, ensure that they are capped at a reasonable size to prevent gas limit issues.
```

### VULNERABILITY: Lack of Event Emission for Critical Actions
```
DETAILED DESCRIPTION: The contract does not emit events for several critical actions, such as when a market is added or when a trade is executed. This lack of transparency can make it difficult for users to track important changes and could hinder debugging efforts.

RECOMMENDED MITIGATION: Ensure that all critical state changes are accompanied by event emissions. This will improve transparency and allow for better tracking of contract activity. Consider emitting events for actions like `addMarket`, `marginTrade`, and `liquidate`.
```

### VULNERABILITY: Potential for Front-Running
```
DETAILED DESCRIPTION: The contract allows users to submit trades and liquidations without any protection against front-running. Malicious actors could observe pending transactions and submit their own transactions with higher gas prices to execute trades before the original transaction, potentially leading to financial losses for the original trader.

RECOMMENDED MITIGATION: Implement measures to mitigate front-running, such as using commit-reveal schemes or time-locks on sensitive operations. Additionally, consider using techniques like transaction batching or implementing a priority gas auction mechanism.
```

### VULNERABILITY: Unchecked External Calls
```
DETAILED DESCRIPTION: The contract makes several external calls (e.g., to `dexAggregator` and `transferIn`) without checking the return values. If any of these calls fail, it could leave the contract in an inconsistent state, potentially leading to loss of funds or incorrect balances.

RECOMMENDED MITIGATION: Always check the return values of external calls and handle failures appropriately. Consider using `require` statements to ensure that external calls succeed before proceeding with further logic.
```

<INFO> Analysis Complete.

[2024-24-08 18:27:33 INFO] **[Seminar Conclusion]**:

 ### VULNERABILITY: Reentrancy Attack
```
DETAILED DESCRIPTION: The contract uses the `nonReentrant` modifier from the `ReentrancyGuard` contract to prevent reentrancy attacks. However, there are still areas in the code where reentrancy could be exploited, particularly in functions that involve external calls to other contracts (e.g., `flashSell`, `flashBuy`, `doTransferOut`). If an external contract is malicious, it could call back into the `OpenLevV1` contract during the execution of these functions, potentially leading to unexpected behavior or loss of funds.

RECOMMENDED MITIGATION: Ensure that all external calls are made at the end of the function execution or use checks-effects-interactions pattern. Additionally, consider using a more robust reentrancy guard that tracks the state of each function call.
```

### VULNERABILITY: Arithmetic Overflow/Underflow
```
DETAILED DESCRIPTION: Although the contract uses the `SafeMath` library to perform arithmetic operations, there are still instances where unchecked arithmetic could occur, especially when manipulating values that are derived from external calls or user inputs. If an arithmetic operation results in an overflow or underflow, it could lead to unexpected behavior, such as incorrect balances or unintended contract states.

RECOMMENDED MITIGATION: Ensure that all arithmetic operations are wrapped in `SafeMath` functions, especially when dealing with values that can be influenced by user input or external contracts. Regularly audit the code to ensure that no arithmetic operations are performed without proper checks.
```

### VULNERABILITY: Lack of Access Control
```
DETAILED DESCRIPTION: The contract has several functions that are marked with the `onlyAdmin` modifier, which restricts access to certain administrative functions. However, there are functions like `initialize`, `addMarket`, and `marginTrade` that do not have sufficient access control. This could allow unauthorized users to call these functions, potentially leading to malicious activities such as creating markets or executing trades without proper authorization.

RECOMMENDED MITIGATION: Implement proper access control for all functions that modify the state of the contract or its critical parameters. Ensure that only authorized addresses can call these functions. Consider using OpenZeppelin's `Ownable` or `AccessControl` contracts for better management of roles and permissions.
```

### VULNERABILITY: Insufficient Validation of External Data
```
DETAILED DESCRIPTION: The contract relies on external data from other contracts (e.g., prices from the `dexAggregator`). If these external contracts are compromised or provide malicious data, it could lead to incorrect calculations, such as in the `marginTrade` and `liquidate` functions. This could result in significant financial losses for users.

RECOMMENDED MITIGATION: Implement checks to validate the data received from external contracts. For example, set acceptable ranges for prices or implement a fallback mechanism to handle unexpected values. Additionally, consider using oracles that provide reliable and tamper-proof data.
```

### VULNERABILITY: Gas Limit and Loops
```
DETAILED DESCRIPTION: The contract contains loops, such as in the `initialize` function where it iterates over `_supportDexs`. If the input array is too large, it could exceed the gas limit, causing the transaction to fail. This could be exploited by an attacker to prevent the contract from being initialized or configured properly.

RECOMMENDED MITIGATION: Avoid using loops that can potentially iterate over large arrays. Instead, consider using mappings or other data structures that do not require iteration. If loops are necessary, ensure that they are capped at a reasonable size to prevent gas limit issues.
```

### VULNERABILITY: Lack of Event Emission for Critical Actions
```
DETAILED DESCRIPTION: The contract does not emit events for several critical actions, such as when a market is added or when a trade is executed. This lack of transparency can make it difficult for users to track important changes and could hinder debugging efforts.

RECOMMENDED MITIGATION: Ensure that all critical state changes are accompanied by event emissions. This will improve transparency and allow for better tracking of contract activity. Consider emitting events for actions like `addMarket`, `marginTrade`, and `liquidate`.
```

### VULNERABILITY: Potential for Front-Running
```
DETAILED DESCRIPTION: The contract allows users to submit trades and liquidations without any protection against front-running. Malicious actors could observe pending transactions and submit their own transactions with higher gas prices to execute trades before the original transaction, potentially leading to financial losses for the original trader.

RECOMMENDED MITIGATION: Implement measures to mitigate front-running, such as using commit-reveal schemes or time-locks on sensitive operations. Additionally, consider using techniques like transaction batching or implementing a priority gas auction mechanism.
```

### VULNERABILITY: Unchecked External Calls
```
DETAILED DESCRIPTION: The contract makes several external calls (e.g., to `dexAggregator` and `transferIn`) without checking the return values. If any of these calls fail, it could leave the contract in an inconsistent state, potentially leading to loss of funds or incorrect balances.

RECOMMENDED MITIGATION: Always check the return values of external calls and handle failures appropriately. Consider using `require` statements to ensure that external calls succeed before proceeding with further logic.
```

<INFO> Analysis Complete.

[2024-24-08 18:27:33 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-24-08 18:27:33 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.7.6; pragma experimental ABIEncoderV2; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import "./OpenLevInterface.sol"; import "./Types.sol"; import "./Adminable.sol"; import "./DelegateInterface.sol"; import "./ControllerInterface.sol"; import "./IWETH.sol"; import "./XOLEInterface.sol"; import "./Types.sol"; import "./OpenLevV1Lib.sol"; /// @title OpenLeverage margin trade logic /// @author OpenLeverage /// @notice Use this contract for margin trade. /// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE. contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {     using SafeMath for uint;     using TransferHelper for IERC20;     using DexData for bytes; constructor () { }  /// @notice initialize proxy contract /// @dev This function is not supposed to call multiple times. All configs can be set through other functions. /// @param _controller Address of contract ControllerDelegator. /// @param _dexAggregator contract DexAggregatorDelegator. /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens. /// @param _wETH Address of wrapped native coin. /// @param _xOLE Address of XOLEDelegator. /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol. function initialize(     address _controller,     DexAggregatorInterface _dexAggregator,     address[] memory depositTokens,     address _wETH,     address _xOLE,     uint8[] memory _supportDexs ) public {     depositTokens;     require(msg.sender == admin, "NAD");     addressConfig.controller = _controller;     addressConfig.dexAggregator = _dexAggregator;     addressConfig.wETH = _wETH;     addressConfig.xOLE = _xOLE;     for (uint i = 0; i &lt; _supportDexs.length; i++) {         supportDexs[_supportDexs[i]] = true;     }     OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig); }  /// @notice Create new trading pair. /// @dev This function is typically called by ControllerDelegator. /// @param pool0 Contract LpoolDelegator, lending pool of token0. /// @param pool1 Contract LpoolDelegator, lending pool of token1. /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value. /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens. /// @return The new created pair ID. function addMarket(     LPoolInterface pool0,     LPoolInterface pool1,     uint16 marginLimit,     bytes memory dexData ) external override returns (uint16) {     uint16 marketId = numPairs;     OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);     numPairs ++;     return marketId; }  /// @notice Margin trade or just add more deposit tokens. /// @dev To support token with tax and reward. Stores share of all token balances of this contract. /// @param longToken Token to long. False for token0, true for token1. /// @param depositToken Token to deposit. False for token0, true for token1. /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported. /// @param borrow Amount of ERC20 to borrow from the short token pool. /// @param minBuyAmount Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function marginTrade(     uint16 marketId,     bool longToken,     bool depositToken,     uint deposit,     uint borrow,     uint minBuyAmount,     bytes memory dexData ) external payable override nonReentrant onlySupportDex(dexData) {     Types.TradeVars memory tv;     Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);     verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);     (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);      if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);     }      tv.totalHeld = totalHelds[address(vars.buyToken)];     tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;      deposit = transferIn(msg.sender, tv.depositErc20, deposit);      // Borrow     uint borrowed;     if (borrow &gt; 0) {         {             uint balance = vars.sellToken.balanceOf(address(this));             vars.sellPool.borrowBehalf(msg.sender, borrow);             borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);         }          if (depositToken == longToken){             (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);             tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));         }else{             tv.borrowValue = borrow;         }     }      require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) &gt; vars.marginLimit, "MAM");     tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);     tv.depositAfterFees = deposit.sub(tv.fees);     tv.dexDetail = dexData.toDexDetail();      if (depositToken == longToken ){         if (borrowed &gt; 0){             tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);             tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);         }         tv.newHeld = tv.newHeld.add(tv.depositAfterFees);     }else{         tv.tradeSize = tv.depositAfterFees.add(borrowed);         tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);         tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);     }      Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];     tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);     trade.held = trade.held.add(tv.newHeld);     trade.depositToken = depositToken;     trade.deposited = trade.deposited.add(tv.depositAfterFees);     trade.lastBlockNum = uint128(block.number);      totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);      require(OpenLevV1Lib.isPositionHealthy(             msg.sender,             true,             OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),             vars,             dexData         ), "PNH");      emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail); }  /// @notice Close trade by shares. /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed. /// @param longToken Token to long. False for token0, true for token1. /// @param closeHeld Amount of shares to close. /// @param minOrMaxAmount Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {     Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];     Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);      //verify     verifyCloseBefore(trade, marketVars, closeHeld, dexData);      uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);      Types.CloseTradeVars memory closeTradeVars;     closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);     closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);     closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);     closeTradeVars.isPartialClose = closeHeld != trade.held;     closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);     closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);     closeTradeVars.dexDetail = dexData.toDexDetail();      //partial close     if (closeTradeVars.isPartialClose) {         closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);         closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);         trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);     } else {         closeTradeVars.depositDecrease = trade.deposited;     }      if (trade.depositToken != longToken) {         minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);         closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);         require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");          closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;         marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);          closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);         doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);     } else {         uint balance = marketVars.buyToken.balanceOf(address(this));         minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);         closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);         closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);         require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");          marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);         closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);         require(marketVars.sellToken.balanceOf(address(this)) &gt;= closeTradeVars.depositReturn, "ISB");         doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);     }      uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));     require(repayed &gt;= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");      if (!closeTradeVars.isPartialClose) {         delete activeTrades[msg.sender][marketId][longToken];     }else{         trade.held = trade.held.sub(closeHeld);         trade.lastBlockNum = uint128(block.number);     }      totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);      closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);     if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);     }      emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,         closeTradeVars.token0Price, closeTradeVars.dexDetail); }  /// @notice Liquidate if trade below margin limit. /// @dev For trades without sufficient funds to repay, use insurance. /// @param owner Owner of the trade to liquidate. /// @param longToken Token to long. False for token0, true for token1. /// @param minBuy Slippage for Dex trading. /// @param maxSell Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {     Types.Trade memory trade = activeTrades[owner][marketId][longToken];     Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);     if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);     }      verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());     uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);      (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);     require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");      Types.LiquidateVars memory liquidateVars;     liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);     liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);     if (liquidateVars.penalty &gt; 0) {         doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);     }     liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);     liquidateVars.dexDetail = dexData.toDexDetail();     liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);     liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);     liquidateVars.marketId = marketId;     liquidateVars.longToken = longToken;      bool buySuccess;     bytes memory sellAmountData;     if (longToken == trade.depositToken) {         maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);         marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);         (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(             abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],             taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)         );     }      if (buySuccess) {         {             uint temp;             assembly {                 temp := mload(add(sellAmountData, 0x20))             }             liquidateVars.sellAmount = temp;         }          liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);         marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);         liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);         doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);     } else {         liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;         liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);         if (liquidateVars.receiveAmount &gt;= liquidateVars.borrowed) {             // fail if buy failed but sell succeeded             require (longToken != trade.depositToken, "PH");             marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);             liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);             doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);         } else {             liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);             liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);             marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);         }     }      liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);     totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);      emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,         trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);      delete activeTrades[owner][marketId][longToken]; }  function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {     return open == longToken ?     Types.MarketVars(         market.pool1,         market.pool0,         IERC20(market.token1),         IERC20(market.token0),         IERC20(market.token1).balanceOf(address(this)),         IERC20(market.token0).balanceOf(address(this)),         market.pool1Insurance,         market.pool0Insurance,         market.marginLimit,         market.priceDiffientRatio,         market.dexs) :     Types.MarketVars(         market.pool0,         market.pool1,         IERC20(market.token0),         IERC20(market.token1),         IERC20(market.token0).balanceOf(address(this)),         IERC20(market.token1).balanceOf(address(this)),         market.pool0Insurance,         market.pool1Insurance,         market.marginLimit,         market.priceDiffientRatio,         market.dexs); }  /// @notice Get ratios of deposited token value to borrowed token value. /// @dev Caluclate ratio with current price and twap price. /// @param owner Owner of the trade to liquidate. /// @param longToken Token to long. False for token0, true for token1. /// @param dexData Index and fee rate for the trading Dex. /// @return current Margin ratio calculated using current price. /// @return cAvg Margin ratio calculated using twap price. /// @return hAvg Margin ratio calculated using last recorded twap price. /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value. function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {     Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);     limit = vars.marginLimit;     (current, cAvg, hAvg,,) =     OpenLevV1Lib.marginRatio(         owner,         activeTrades[owner][marketId][longToken].held,         address(vars.sellToken),         address(vars.buyToken),         vars.buyPool,         false,         dexData     ); }  /// @notice Check if a price update is required on Dex. /// @param dexData Index and fee rate for the trading Dex. function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){     Types.Market memory market = markets[marketId];     return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData); }  /// @notice Update price on Dex. /// @param dexData Index and fee rate for the trading Dex. function updatePrice(uint16 marketId, bytes memory dexData) external override {     OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData); }  /// @notice List of all supporting Dexes. function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){     return markets[marketId].dexs; }  function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {     Types.Market storage market = markets[marketId];     uint needed = totalRepayment.sub(remaining);     needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);     maxCanRepayAmount = totalRepayment;     if (longToken) {         if (market.pool0Insurance &gt;= needed) {             market.pool0Insurance = market.pool0Insurance - needed;             totalHelds[token] = totalHelds[token].sub(needed);         } else {             maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);             maxCanRepayAmount = maxCanRepayAmount.add(remaining);             totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);             market.pool0Insurance = 0;         }     } else {         if (market.pool1Insurance &gt;= needed) {             market.pool1Insurance = market.pool1Insurance - needed;         } else {             maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);             maxCanRepayAmount = maxCanRepayAmount.add(remaining);             totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);             market.pool1Insurance = 0;         }     } }  function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {     // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);     Types.Market storage market = markets[marketId];     uint defaultFees = tradeSize.mul(market.feesRate).div(10000);     uint newFees = defaultFees;     // if trader holds more xOLE, then should enjoy trading discount.     if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) &gt; calculateConfig.feesDiscountThreshold) {         newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));     }     // if trader update price, then should enjoy trading discount.     if (market.priceUpdater == trader) {         newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));     }     uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);     IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));      newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);     if (token == market.token1) {         market.pool1Insurance = market.pool1Insurance.add(newInsurance);     } else {         market.pool0Insurance = market.pool0Insurance.add(newInsurance);     }      totalHelds[token] = totalHelds[token].add(newInsurance);     return newFees; }  function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){     if (sellAmount &gt; 0){         DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;         IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);         buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);     } }  function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){     if (buyAmount &gt; 0){         DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;         IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);         sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);     } }  /// @dev All credited on this contract and share with all token holder if any rewards for the transfer. function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {     return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount); }  /// @dev All credited on "to" if any taxes for the transfer. function doTransferOut(address to, IERC20 token, uint amount) internal {     OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount); }  /*** Admin Functions ***/ function setCalculateConfig(uint16 defaultFeesRate,     uint8 insuranceRatio,     uint16 defaultMarginLimit,     uint16 priceDiffientRatio,     uint16 updatePriceDiscount,     uint16 feesDiscount,     uint128 feesDiscountThreshold,     uint16 penaltyRatio,     uint8 maxLiquidationPriceDiffientRatio,     uint16 twapDuration) external override onlyAdmin() {     OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,         feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);     emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration); }  function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {     OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);     emit NewAddressConfig(controller, address(dexAggregator)); }  function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {     OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);     emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs); }  /// @notice List of all supporting Dexes. /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1 function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {     Types.Market storage market = markets[marketId];     if (poolIndex == 0) {         market.pool0Insurance = market.pool0Insurance.sub(amount);         (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));         return;     }     market.pool1Insurance = market.pool1Insurance.sub(amount);     (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this)))); }  function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {     supportDexs[dex] = support; }  function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){     taxes[marketId][token][index] = tax; }  function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {     Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];     OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade); }  function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {     verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());     require(closeHeld &lt;= trade.held, "CBH"); }  function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {     require(held != 0 &amp;&amp; lastBlockNumber != block.number &amp;&amp; OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0"); }  modifier onlySupportDex(bytes memory dexData) {     require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");     _; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-24-08 18:27:33 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.7.6; pragma experimental ABIEncoderV2; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import "./OpenLevInterface.sol"; import "./Types.sol"; import "./Adminable.sol"; import "./DelegateInterface.sol"; import "./ControllerInterface.sol"; import "./IWETH.sol"; import "./XOLEInterface.sol"; import "./Types.sol"; import "./OpenLevV1Lib.sol"; /// @title OpenLeverage margin trade logic /// @author OpenLeverage /// @notice Use this contract for margin trade. /// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE. contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {     using SafeMath for uint;     using TransferHelper for IERC20;     using DexData for bytes; constructor () { }  /// @notice initialize proxy contract /// @dev This function is not supposed to call multiple times. All configs can be set through other functions. /// @param _controller Address of contract ControllerDelegator. /// @param _dexAggregator contract DexAggregatorDelegator. /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens. /// @param _wETH Address of wrapped native coin. /// @param _xOLE Address of XOLEDelegator. /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol. function initialize(     address _controller,     DexAggregatorInterface _dexAggregator,     address[] memory depositTokens,     address _wETH,     address _xOLE,     uint8[] memory _supportDexs ) public {     depositTokens;     require(msg.sender == admin, "NAD");     addressConfig.controller = _controller;     addressConfig.dexAggregator = _dexAggregator;     addressConfig.wETH = _wETH;     addressConfig.xOLE = _xOLE;     for (uint i = 0; i &lt; _supportDexs.length; i++) {         supportDexs[_supportDexs[i]] = true;     }     OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig); }  /// @notice Create new trading pair. /// @dev This function is typically called by ControllerDelegator. /// @param pool0 Contract LpoolDelegator, lending pool of token0. /// @param pool1 Contract LpoolDelegator, lending pool of token1. /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value. /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens. /// @return The new created pair ID. function addMarket(     LPoolInterface pool0,     LPoolInterface pool1,     uint16 marginLimit,     bytes memory dexData ) external override returns (uint16) {     uint16 marketId = numPairs;     OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);     numPairs ++;     return marketId; }  /// @notice Margin trade or just add more deposit tokens. /// @dev To support token with tax and reward. Stores share of all token balances of this contract. /// @param longToken Token to long. False for token0, true for token1. /// @param depositToken Token to deposit. False for token0, true for token1. /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported. /// @param borrow Amount of ERC20 to borrow from the short token pool. /// @param minBuyAmount Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function marginTrade(     uint16 marketId,     bool longToken,     bool depositToken,     uint deposit,     uint borrow,     uint minBuyAmount,     bytes memory dexData ) external payable override nonReentrant onlySupportDex(dexData) {     Types.TradeVars memory tv;     Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);     verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);     (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);      if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);     }      tv.totalHeld = totalHelds[address(vars.buyToken)];     tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;      deposit = transferIn(msg.sender, tv.depositErc20, deposit);      // Borrow     uint borrowed;     if (borrow &gt; 0) {         {             uint balance = vars.sellToken.balanceOf(address(this));             vars.sellPool.borrowBehalf(msg.sender, borrow);             borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);         }          if (depositToken == longToken){             (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);             tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));         }else{             tv.borrowValue = borrow;         }     }      require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) &gt; vars.marginLimit, "MAM");     tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);     tv.depositAfterFees = deposit.sub(tv.fees);     tv.dexDetail = dexData.toDexDetail();      if (depositToken == longToken ){         if (borrowed &gt; 0){             tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);             tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);         }         tv.newHeld = tv.newHeld.add(tv.depositAfterFees);     }else{         tv.tradeSize = tv.depositAfterFees.add(borrowed);         tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);         tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);     }      Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];     tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);     trade.held = trade.held.add(tv.newHeld);     trade.depositToken = depositToken;     trade.deposited = trade.deposited.add(tv.depositAfterFees);     trade.lastBlockNum = uint128(block.number);      totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);      require(OpenLevV1Lib.isPositionHealthy(             msg.sender,             true,             OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),             vars,             dexData         ), "PNH");      emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail); }  /// @notice Close trade by shares. /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed. /// @param longToken Token to long. False for token0, true for token1. /// @param closeHeld Amount of shares to close. /// @param minOrMaxAmount Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {     Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];     Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);      //verify     verifyCloseBefore(trade, marketVars, closeHeld, dexData);      uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);      Types.CloseTradeVars memory closeTradeVars;     closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);     closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);     closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);     closeTradeVars.isPartialClose = closeHeld != trade.held;     closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);     closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);     closeTradeVars.dexDetail = dexData.toDexDetail();      //partial close     if (closeTradeVars.isPartialClose) {         closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);         closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);         trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);     } else {         closeTradeVars.depositDecrease = trade.deposited;     }      if (trade.depositToken != longToken) {         minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);         closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);         require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");          closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;         marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);          closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);         doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);     } else {         uint balance = marketVars.buyToken.balanceOf(address(this));         minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);         closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);         closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);         require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");          marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);         closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);         require(marketVars.sellToken.balanceOf(address(this)) &gt;= closeTradeVars.depositReturn, "ISB");         doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);     }      uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));     require(repayed &gt;= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");      if (!closeTradeVars.isPartialClose) {         delete activeTrades[msg.sender][marketId][longToken];     }else{         trade.held = trade.held.sub(closeHeld);         trade.lastBlockNum = uint128(block.number);     }      totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);      closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);     if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);     }      emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,         closeTradeVars.token0Price, closeTradeVars.dexDetail); }  /// @notice Liquidate if trade below margin limit. /// @dev For trades without sufficient funds to repay, use insurance. /// @param owner Owner of the trade to liquidate. /// @param longToken Token to long. False for token0, true for token1. /// @param minBuy Slippage for Dex trading. /// @param maxSell Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {     Types.Trade memory trade = activeTrades[owner][marketId][longToken];     Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);     if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);     }      verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());     uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);      (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);     require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");      Types.LiquidateVars memory liquidateVars;     liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);     liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);     if (liquidateVars.penalty &gt; 0) {         doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);     }     liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);     liquidateVars.dexDetail = dexData.toDexDetail();     liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);     liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);     liquidateVars.marketId = marketId;     liquidateVars.longToken = longToken;      bool buySuccess;     bytes memory sellAmountData;     if (longToken == trade.depositToken) {         maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);         marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);         (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(             abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],             taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)         );     }      if (buySuccess) {         {             uint temp;             assembly {                 temp := mload(add(sellAmountData, 0x20))             }             liquidateVars.sellAmount = temp;         }          liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);         marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);         liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);         doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);     } else {         liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;         liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);         if (liquidateVars.receiveAmount &gt;= liquidateVars.borrowed) {             // fail if buy failed but sell succeeded             require (longToken != trade.depositToken, "PH");             marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);             liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);             doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);         } else {             liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);             liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);             marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);         }     }      liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);     totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);      emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,         trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);      delete activeTrades[owner][marketId][longToken]; }  function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {     return open == longToken ?     Types.MarketVars(         market.pool1,         market.pool0,         IERC20(market.token1),         IERC20(market.token0),         IERC20(market.token1).balanceOf(address(this)),         IERC20(market.token0).balanceOf(address(this)),         market.pool1Insurance,         market.pool0Insurance,         market.marginLimit,         market.priceDiffientRatio,         market.dexs) :     Types.MarketVars(         market.pool0,         market.pool1,         IERC20(market.token0),         IERC20(market.token1),         IERC20(market.token0).balanceOf(address(this)),         IERC20(market.token1).balanceOf(address(this)),         market.pool0Insurance,         market.pool1Insurance,         market.marginLimit,         market.priceDiffientRatio,         market.dexs); }  /// @notice Get ratios of deposited token value to borrowed token value. /// @dev Caluclate ratio with current price and twap price. /// @param owner Owner of the trade to liquidate. /// @param longToken Token to long. False for token0, true for token1. /// @param dexData Index and fee rate for the trading Dex. /// @return current Margin ratio calculated using current price. /// @return cAvg Margin ratio calculated using twap price. /// @return hAvg Margin ratio calculated using last recorded twap price. /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value. function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {     Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);     limit = vars.marginLimit;     (current, cAvg, hAvg,,) =     OpenLevV1Lib.marginRatio(         owner,         activeTrades[owner][marketId][longToken].held,         address(vars.sellToken),         address(vars.buyToken),         vars.buyPool,         false,         dexData     ); }  /// @notice Check if a price update is required on Dex. /// @param dexData Index and fee rate for the trading Dex. function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){     Types.Market memory market = markets[marketId];     return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData); }  /// @notice Update price on Dex. /// @param dexData Index and fee rate for the trading Dex. function updatePrice(uint16 marketId, bytes memory dexData) external override {     OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData); }  /// @notice List of all supporting Dexes. function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){     return markets[marketId].dexs; }  function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {     Types.Market storage market = markets[marketId];     uint needed = totalRepayment.sub(remaining);     needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);     maxCanRepayAmount = totalRepayment;     if (longToken) {         if (market.pool0Insurance &gt;= needed) {             market.pool0Insurance = market.pool0Insurance - needed;             totalHelds[token] = totalHelds[token].sub(needed);         } else {             maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);             maxCanRepayAmount = maxCanRepayAmount.add(remaining);             totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);             market.pool0Insurance = 0;         }     } else {         if (market.pool1Insurance &gt;= needed) {             market.pool1Insurance = market.pool1Insurance - needed;         } else {             maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);             maxCanRepayAmount = maxCanRepayAmount.add(remaining);             totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);             market.pool1Insurance = 0;         }     } }  function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {     // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);     Types.Market storage market = markets[marketId];     uint defaultFees = tradeSize.mul(market.feesRate).div(10000);     uint newFees = defaultFees;     // if trader holds more xOLE, then should enjoy trading discount.     if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) &gt; calculateConfig.feesDiscountThreshold) {         newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));     }     // if trader update price, then should enjoy trading discount.     if (market.priceUpdater == trader) {         newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));     }     uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);     IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));      newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);     if (token == market.token1) {         market.pool1Insurance = market.pool1Insurance.add(newInsurance);     } else {         market.pool0Insurance = market.pool0Insurance.add(newInsurance);     }      totalHelds[token] = totalHelds[token].add(newInsurance);     return newFees; }  function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){     if (sellAmount &gt; 0){         DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;         IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);         buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);     } }  function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){     if (buyAmount &gt; 0){         DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;         IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);         sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);     } }  /// @dev All credited on this contract and share with all token holder if any rewards for the transfer. function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {     return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount); }  /// @dev All credited on "to" if any taxes for the transfer. function doTransferOut(address to, IERC20 token, uint amount) internal {     OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount); }  /*** Admin Functions ***/ function setCalculateConfig(uint16 defaultFeesRate,     uint8 insuranceRatio,     uint16 defaultMarginLimit,     uint16 priceDiffientRatio,     uint16 updatePriceDiscount,     uint16 feesDiscount,     uint128 feesDiscountThreshold,     uint16 penaltyRatio,     uint8 maxLiquidationPriceDiffientRatio,     uint16 twapDuration) external override onlyAdmin() {     OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,         feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);     emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration); }  function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {     OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);     emit NewAddressConfig(controller, address(dexAggregator)); }  function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {     OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);     emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs); }  /// @notice List of all supporting Dexes. /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1 function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {     Types.Market storage market = markets[marketId];     if (poolIndex == 0) {         market.pool0Insurance = market.pool0Insurance.sub(amount);         (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));         return;     }     market.pool1Insurance = market.pool1Insurance.sub(amount);     (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this)))); }  function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {     supportDexs[dex] = support; }  function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){     taxes[marketId][token][index] = tax; }  function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {     Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];     OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade); }  function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {     verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());     require(closeHeld &lt;= trade.held, "CBH"); }  function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {     require(held != 0 &amp;&amp; lastBlockNumber != block.number &amp;&amp; OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0"); }  modifier onlySupportDex(bytes memory dexData) {     require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");     _; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-24-08 18:27:33 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;

pragma experimental ABIEncoderV2;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "./OpenLevInterface.sol";
import "./Types.sol";
import "./Adminable.sol";
import "./DelegateInterface.sol";
import "./ControllerInterface.sol";
import "./IWETH.sol";
import "./XOLEInterface.sol";
import "./Types.sol";
import "./OpenLevV1Lib.sol";

/// @title OpenLeverage margin trade logic
/// @author OpenLeverage
/// @notice Use this contract for margin trade.
/// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE.
contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {
    using SafeMath for uint;
    using TransferHelper for IERC20;
    using DexData for bytes;

    constructor ()
    {
    }

    /// @notice initialize proxy contract
    /// @dev This function is not supposed to call multiple times. All configs can be set through other functions.
    /// @param _controller Address of contract ControllerDelegator.
    /// @param _dexAggregator contract DexAggregatorDelegator.
    /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens.
    /// @param _wETH Address of wrapped native coin.
    /// @param _xOLE Address of XOLEDelegator.
    /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol.
    function initialize(
        address _controller,
        DexAggregatorInterface _dexAggregator,
        address[] memory depositTokens,
        address _wETH,
        address _xOLE,
        uint8[] memory _supportDexs
    ) public {
        depositTokens;
        require(msg.sender == admin, "NAD");
        addressConfig.controller = _controller;
        addressConfig.dexAggregator = _dexAggregator;
        addressConfig.wETH = _wETH;
        addressConfig.xOLE = _xOLE;
        for (uint i = 0; i < _supportDexs.length; i++) {
            supportDexs[_supportDexs[i]] = true;
        }
        OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig);
    }

    /// @notice Create new trading pair.
    /// @dev This function is typically called by ControllerDelegator.
    /// @param pool0 Contract LpoolDelegator, lending pool of token0.
    /// @param pool1 Contract LpoolDelegator, lending pool of token1.
    /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value.
    /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens.
    /// @return The new created pair ID.
    function addMarket(
        LPoolInterface pool0,
        LPoolInterface pool1,
        uint16 marginLimit,
        bytes memory dexData
    ) external override returns (uint16) {
        uint16 marketId = numPairs;
        OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);
        numPairs ++;
        return marketId;
    }

    /// @notice Margin trade or just add more deposit tokens.
    /// @dev To support token with tax and reward. Stores share of all token balances of this contract.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param depositToken Token to deposit. False for token0, true for token1.
    /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported.
    /// @param borrow Amount of ERC20 to borrow from the short token pool.
    /// @param minBuyAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function marginTrade(
        uint16 marketId,
        bool longToken,
        bool depositToken,
        uint deposit,
        uint borrow,
        uint minBuyAmount,
        bytes memory dexData
    ) external payable override nonReentrant onlySupportDex(dexData) {
        Types.TradeVars memory tv;
        Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);
        verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);
        (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);

        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);
        }

        tv.totalHeld = totalHelds[address(vars.buyToken)];
        tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;

        deposit = transferIn(msg.sender, tv.depositErc20, deposit);

        // Borrow
        uint borrowed;
        if (borrow > 0) {
            {
                uint balance = vars.sellToken.balanceOf(address(this));
                vars.sellPool.borrowBehalf(msg.sender, borrow);
                borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);
            }

            if (depositToken == longToken){
                (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);
                tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));
            }else{
                tv.borrowValue = borrow;
            }
        }

        require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) > vars.marginLimit, "MAM");
        tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);
        tv.depositAfterFees = deposit.sub(tv.fees);
        tv.dexDetail = dexData.toDexDetail();

        if (depositToken == longToken ){
            if (borrowed > 0){
                tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);
                tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);
            }
            tv.newHeld = tv.newHeld.add(tv.depositAfterFees);
        }else{
            tv.tradeSize = tv.depositAfterFees.add(borrowed);
            tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);
            tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);
        }

        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);
        trade.held = trade.held.add(tv.newHeld);
        trade.depositToken = depositToken;
        trade.deposited = trade.deposited.add(tv.depositAfterFees);
        trade.lastBlockNum = uint128(block.number);

        totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);

        require(OpenLevV1Lib.isPositionHealthy(
                msg.sender,
                true,
                OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),
                vars,
                dexData
            ), "PNH");

        emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail);
    }

    /// @notice Close trade by shares.
    /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param closeHeld Amount of shares to close.
    /// @param minOrMaxAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);

        //verify
        verifyCloseBefore(trade, marketVars, closeHeld, dexData);

        uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        Types.CloseTradeVars memory closeTradeVars;
        closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);
        closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);
        closeTradeVars.isPartialClose = closeHeld != trade.held;
        closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);
        closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        closeTradeVars.dexDetail = dexData.toDexDetail();

        //partial close
        if (closeTradeVars.isPartialClose) {
            closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);
            closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);
            trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);
        } else {
            closeTradeVars.depositDecrease = trade.deposited;
        }

        if (trade.depositToken != longToken) {
            minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);
            closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;
            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);

            closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);
            doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);
        } else {
            uint balance = marketVars.buyToken.balanceOf(address(this));
            minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);
            closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);
            closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);
            closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);
            require(marketVars.sellToken.balanceOf(address(this)) >= closeTradeVars.depositReturn, "ISB");
            doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);
        }

        uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));
        require(repayed >= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");

        if (!closeTradeVars.isPartialClose) {
            delete activeTrades[msg.sender][marketId][longToken];
        }else{
            trade.held = trade.held.sub(closeHeld);
            trade.lastBlockNum = uint128(block.number);
        }

        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);

        closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,
            closeTradeVars.token0Price, closeTradeVars.dexDetail);
    }

    /// @notice Liquidate if trade below margin limit.
    /// @dev For trades without sufficient funds to repay, use insurance.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param minBuy Slippage for Dex trading.
    /// @param maxSell Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade memory trade = activeTrades[owner][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());
        uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);
        require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");

        Types.LiquidateVars memory liquidateVars;
        liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);
        if (liquidateVars.penalty > 0) {
            doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);
        }
        liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);
        liquidateVars.dexDetail = dexData.toDexDetail();
        liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);
        liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        liquidateVars.marketId = marketId;
        liquidateVars.longToken = longToken;

        bool buySuccess;
        bytes memory sellAmountData;
        if (longToken == trade.depositToken) {
            maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);
            marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);
            (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(
                abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],
                taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)
            );
        }

        if (buySuccess) {
            {
                uint temp;
                assembly {
                    temp := mload(add(sellAmountData, 0x20))
                }
                liquidateVars.sellAmount = temp;
            }

            liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);
            marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
            liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);
            doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);
        } else {
            liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;
            liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);
            if (liquidateVars.receiveAmount >= liquidateVars.borrowed) {
                // fail if buy failed but sell succeeded
                require (longToken != trade.depositToken, "PH");
                marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
                liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);
                doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);
            } else {
                liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);
                liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);
                marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);
            }
        }

        liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);
        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);

        emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,
            trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);

        delete activeTrades[owner][marketId][longToken];
    }

    function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {
        return open == longToken ?
        Types.MarketVars(
            market.pool1,
            market.pool0,
            IERC20(market.token1),
            IERC20(market.token0),
            IERC20(market.token1).balanceOf(address(this)),
            IERC20(market.token0).balanceOf(address(this)),
            market.pool1Insurance,
            market.pool0Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs) :
        Types.MarketVars(
            market.pool0,
            market.pool1,
            IERC20(market.token0),
            IERC20(market.token1),
            IERC20(market.token0).balanceOf(address(this)),
            IERC20(market.token1).balanceOf(address(this)),
            market.pool0Insurance,
            market.pool1Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs);
    }

    /// @notice Get ratios of deposited token value to borrowed token value.
    /// @dev Caluclate ratio with current price and twap price.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param dexData Index and fee rate for the trading Dex.
    /// @return current Margin ratio calculated using current price.
    /// @return cAvg Margin ratio calculated using twap price.
    /// @return hAvg Margin ratio calculated using last recorded twap price.
    /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value.
    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {
        Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);
        limit = vars.marginLimit;
        (current, cAvg, hAvg,,) =
        OpenLevV1Lib.marginRatio(
            owner,
            activeTrades[owner][marketId][longToken].held,
            address(vars.sellToken),
            address(vars.buyToken),
            vars.buyPool,
            false,
            dexData
        );
    }

    /// @notice Check if a price update is required on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){
        Types.Market memory market = markets[marketId];
        return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData);
    }

    /// @notice Update price on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function updatePrice(uint16 marketId, bytes memory dexData) external override {
        OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData);
    }

    /// @notice List of all supporting Dexes.
    function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){
        return markets[marketId].dexs;
    }

    function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {
        Types.Market storage market = markets[marketId];
        uint needed = totalRepayment.sub(remaining);
        needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);
        maxCanRepayAmount = totalRepayment;
        if (longToken) {
            if (market.pool0Insurance >= needed) {
                market.pool0Insurance = market.pool0Insurance - needed;
                totalHelds[token] = totalHelds[token].sub(needed);
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);
                market.pool0Insurance = 0;
            }
        } else {
            if (market.pool1Insurance >= needed) {
                market.pool1Insurance = market.pool1Insurance - needed;
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);
                market.pool1Insurance = 0;
            }
        }
    }

    function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {
        // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);
        Types.Market storage market = markets[marketId];
        uint defaultFees = tradeSize.mul(market.feesRate).div(10000);
        uint newFees = defaultFees;
        // if trader holds more xOLE, then should enjoy trading discount.
        if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) > calculateConfig.feesDiscountThreshold) {
            newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));
        }
        // if trader update price, then should enjoy trading discount.
        if (market.priceUpdater == trader) {
            newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));
        }
        uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);
        IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));

        newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);
        if (token == market.token1) {
            market.pool1Insurance = market.pool1Insurance.add(newInsurance);
        } else {
            market.pool0Insurance = market.pool0Insurance.add(newInsurance);
        }

        totalHelds[token] = totalHelds[token].add(newInsurance);
        return newFees;
    }

    function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){
        if (sellAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);
            buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);
        }
    }

    function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){
        if (buyAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);
            sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);
        }
    }

    /// @dev All credited on this contract and share with all token holder if any rewards for the transfer.
    function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {
        return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount);
    }

    /// @dev All credited on "to" if any taxes for the transfer.
    function doTransferOut(address to, IERC20 token, uint amount) internal {
        OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount);
    }

    /*** Admin Functions ***/
    function setCalculateConfig(uint16 defaultFeesRate,
        uint8 insuranceRatio,
        uint16 defaultMarginLimit,
        uint16 priceDiffientRatio,
        uint16 updatePriceDiscount,
        uint16 feesDiscount,
        uint128 feesDiscountThreshold,
        uint16 penaltyRatio,
        uint8 maxLiquidationPriceDiffientRatio,
        uint16 twapDuration) external override onlyAdmin() {
        OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,
            feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);
        emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration);
    }

    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {
        OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);
        emit NewAddressConfig(controller, address(dexAggregator));
    }

    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {
        OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);
        emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs);
    }

    /// @notice List of all supporting Dexes.
    /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1
    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {
        Types.Market storage market = markets[marketId];
        if (poolIndex == 0) {
            market.pool0Insurance = market.pool0Insurance.sub(amount);
            (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));
            return;
        }
        market.pool1Insurance = market.pool1Insurance.sub(amount);
        (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this))));
    }

    function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {
        supportDexs[dex] = support;
    }

    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){
        taxes[marketId][token][index] = tax;
    }

    function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {
        Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];
        OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade);
    }

    function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {
        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());
        require(closeHeld <= trade.held, "CBH");
    }

    function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {
        require(held != 0 && lastBlockNumber != block.number && OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0");
    }

    modifier onlySupportDex(bytes memory dexData) {
        require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");
        _;
    }
}.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-24-08 18:27:45 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-24-08 18:27:45 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 6914
completion_tokens: 770
total_tokens: 7684
cost: $-1.000000


[2024-24-08 18:27:45 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;

pragma experimental ABIEncoderV2;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "./OpenLevInterface.sol";
import "./Types.sol";
import "./Adminable.sol";
import "./DelegateInterface.sol";
import "./ControllerInterface.sol";
import "./IWETH.sol";
import "./XOLEInterface.sol";
import "./Types.sol";
import "./OpenLevV1Lib.sol";

/// @title OpenLeverage margin trade logic
/// @author OpenLeverage
/// @notice Use this contract for margin trade.
/// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE.
contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {
    using SafeMath for uint;
    using TransferHelper for IERC20;
    using DexData for bytes;

    constructor ()
    {
    }

    /// @notice initialize proxy contract
    /// @dev This function is not supposed to call multiple times. All configs can be set through other functions.
    /// @param _controller Address of contract ControllerDelegator.
    /// @param _dexAggregator contract DexAggregatorDelegator.
    /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens.
    /// @param _wETH Address of wrapped native coin.
    /// @param _xOLE Address of XOLEDelegator.
    /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol.
    function initialize(
        address _controller,
        DexAggregatorInterface _dexAggregator,
        address[] memory depositTokens,
        address _wETH,
        address _xOLE,
        uint8[] memory _supportDexs
    ) public {
        depositTokens;
        require(msg.sender == admin, "NAD");
        addressConfig.controller = _controller;
        addressConfig.dexAggregator = _dexAggregator;
        addressConfig.wETH = _wETH;
        addressConfig.xOLE = _xOLE;
        for (uint i = 0; i < _supportDexs.length; i++) {
            supportDexs[_supportDexs[i]] = true;
        }
        OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig);
    }

    /// @notice Create new trading pair.
    /// @dev This function is typically called by ControllerDelegator.
    /// @param pool0 Contract LpoolDelegator, lending pool of token0.
    /// @param pool1 Contract LpoolDelegator, lending pool of token1.
    /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value.
    /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens.
    /// @return The new created pair ID.
    function addMarket(
        LPoolInterface pool0,
        LPoolInterface pool1,
        uint16 marginLimit,
        bytes memory dexData
    ) external override returns (uint16) {
        uint16 marketId = numPairs;
        OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);
        numPairs ++;
        return marketId;
    }

    /// @notice Margin trade or just add more deposit tokens.
    /// @dev To support token with tax and reward. Stores share of all token balances of this contract.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param depositToken Token to deposit. False for token0, true for token1.
    /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported.
    /// @param borrow Amount of ERC20 to borrow from the short token pool.
    /// @param minBuyAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function marginTrade(
        uint16 marketId,
        bool longToken,
        bool depositToken,
        uint deposit,
        uint borrow,
        uint minBuyAmount,
        bytes memory dexData
    ) external payable override nonReentrant onlySupportDex(dexData) {
        Types.TradeVars memory tv;
        Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);
        verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);
        (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);

        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);
        }

        tv.totalHeld = totalHelds[address(vars.buyToken)];
        tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;

        deposit = transferIn(msg.sender, tv.depositErc20, deposit);

        // Borrow
        uint borrowed;
        if (borrow > 0) {
            {
                uint balance = vars.sellToken.balanceOf(address(this));
                vars.sellPool.borrowBehalf(msg.sender, borrow);
                borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);
            }

            if (depositToken == longToken){
                (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);
                tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));
            }else{
                tv.borrowValue = borrow;
            }
        }

        require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) > vars.marginLimit, "MAM");
        tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);
        tv.depositAfterFees = deposit.sub(tv.fees);
        tv.dexDetail = dexData.toDexDetail();

        if (depositToken == longToken ){
            if (borrowed > 0){
                tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);
                tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);
            }
            tv.newHeld = tv.newHeld.add(tv.depositAfterFees);
        }else{
            tv.tradeSize = tv.depositAfterFees.add(borrowed);
            tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);
            tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);
        }

        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);
        trade.held = trade.held.add(tv.newHeld);
        trade.depositToken = depositToken;
        trade.deposited = trade.deposited.add(tv.depositAfterFees);
        trade.lastBlockNum = uint128(block.number);

        totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);

        require(OpenLevV1Lib.isPositionHealthy(
                msg.sender,
                true,
                OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),
                vars,
                dexData
            ), "PNH");

        emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail);
    }

    /// @notice Close trade by shares.
    /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param closeHeld Amount of shares to close.
    /// @param minOrMaxAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);

        //verify
        verifyCloseBefore(trade, marketVars, closeHeld, dexData);

        uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        Types.CloseTradeVars memory closeTradeVars;
        closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);
        closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);
        closeTradeVars.isPartialClose = closeHeld != trade.held;
        closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);
        closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        closeTradeVars.dexDetail = dexData.toDexDetail();

        //partial close
        if (closeTradeVars.isPartialClose) {
            closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);
            closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);
            trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);
        } else {
            closeTradeVars.depositDecrease = trade.deposited;
        }

        if (trade.depositToken != longToken) {
            minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);
            closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;
            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);

            closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);
            doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);
        } else {
            uint balance = marketVars.buyToken.balanceOf(address(this));
            minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);
            closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);
            closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);
            closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);
            require(marketVars.sellToken.balanceOf(address(this)) >= closeTradeVars.depositReturn, "ISB");
            doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);
        }

        uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));
        require(repayed >= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");

        if (!closeTradeVars.isPartialClose) {
            delete activeTrades[msg.sender][marketId][longToken];
        }else{
            trade.held = trade.held.sub(closeHeld);
            trade.lastBlockNum = uint128(block.number);
        }

        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);

        closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,
            closeTradeVars.token0Price, closeTradeVars.dexDetail);
    }

    /// @notice Liquidate if trade below margin limit.
    /// @dev For trades without sufficient funds to repay, use insurance.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param minBuy Slippage for Dex trading.
    /// @param maxSell Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade memory trade = activeTrades[owner][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());
        uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);
        require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");

        Types.LiquidateVars memory liquidateVars;
        liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);
        if (liquidateVars.penalty > 0) {
            doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);
        }
        liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);
        liquidateVars.dexDetail = dexData.toDexDetail();
        liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);
        liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        liquidateVars.marketId = marketId;
        liquidateVars.longToken = longToken;

        bool buySuccess;
        bytes memory sellAmountData;
        if (longToken == trade.depositToken) {
            maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);
            marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);
            (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(
                abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],
                taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)
            );
        }

        if (buySuccess) {
            {
                uint temp;
                assembly {
                    temp := mload(add(sellAmountData, 0x20))
                }
                liquidateVars.sellAmount = temp;
            }

            liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);
            marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
            liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);
            doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);
        } else {
            liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;
            liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);
            if (liquidateVars.receiveAmount >= liquidateVars.borrowed) {
                // fail if buy failed but sell succeeded
                require (longToken != trade.depositToken, "PH");
                marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
                liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);
                doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);
            } else {
                liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);
                liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);
                marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);
            }
        }

        liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);
        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);

        emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,
            trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);

        delete activeTrades[owner][marketId][longToken];
    }

    function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {
        return open == longToken ?
        Types.MarketVars(
            market.pool1,
            market.pool0,
            IERC20(market.token1),
            IERC20(market.token0),
            IERC20(market.token1).balanceOf(address(this)),
            IERC20(market.token0).balanceOf(address(this)),
            market.pool1Insurance,
            market.pool0Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs) :
        Types.MarketVars(
            market.pool0,
            market.pool1,
            IERC20(market.token0),
            IERC20(market.token1),
            IERC20(market.token0).balanceOf(address(this)),
            IERC20(market.token1).balanceOf(address(this)),
            market.pool0Insurance,
            market.pool1Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs);
    }

    /// @notice Get ratios of deposited token value to borrowed token value.
    /// @dev Caluclate ratio with current price and twap price.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param dexData Index and fee rate for the trading Dex.
    /// @return current Margin ratio calculated using current price.
    /// @return cAvg Margin ratio calculated using twap price.
    /// @return hAvg Margin ratio calculated using last recorded twap price.
    /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value.
    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {
        Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);
        limit = vars.marginLimit;
        (current, cAvg, hAvg,,) =
        OpenLevV1Lib.marginRatio(
            owner,
            activeTrades[owner][marketId][longToken].held,
            address(vars.sellToken),
            address(vars.buyToken),
            vars.buyPool,
            false,
            dexData
        );
    }

    /// @notice Check if a price update is required on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){
        Types.Market memory market = markets[marketId];
        return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData);
    }

    /// @notice Update price on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function updatePrice(uint16 marketId, bytes memory dexData) external override {
        OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData);
    }

    /// @notice List of all supporting Dexes.
    function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){
        return markets[marketId].dexs;
    }

    function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {
        Types.Market storage market = markets[marketId];
        uint needed = totalRepayment.sub(remaining);
        needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);
        maxCanRepayAmount = totalRepayment;
        if (longToken) {
            if (market.pool0Insurance >= needed) {
                market.pool0Insurance = market.pool0Insurance - needed;
                totalHelds[token] = totalHelds[token].sub(needed);
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);
                market.pool0Insurance = 0;
            }
        } else {
            if (market.pool1Insurance >= needed) {
                market.pool1Insurance = market.pool1Insurance - needed;
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);
                market.pool1Insurance = 0;
            }
        }
    }

    function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {
        // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);
        Types.Market storage market = markets[marketId];
        uint defaultFees = tradeSize.mul(market.feesRate).div(10000);
        uint newFees = defaultFees;
        // if trader holds more xOLE, then should enjoy trading discount.
        if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) > calculateConfig.feesDiscountThreshold) {
            newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));
        }
        // if trader update price, then should enjoy trading discount.
        if (market.priceUpdater == trader) {
            newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));
        }
        uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);
        IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));

        newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);
        if (token == market.token1) {
            market.pool1Insurance = market.pool1Insurance.add(newInsurance);
        } else {
            market.pool0Insurance = market.pool0Insurance.add(newInsurance);
        }

        totalHelds[token] = totalHelds[token].add(newInsurance);
        return newFees;
    }

    function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){
        if (sellAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);
            buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);
        }
    }

    function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){
        if (buyAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);
            sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);
        }
    }

    /// @dev All credited on this contract and share with all token holder if any rewards for the transfer.
    function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {
        return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount);
    }

    /// @dev All credited on "to" if any taxes for the transfer.
    function doTransferOut(address to, IERC20 token, uint amount) internal {
        OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount);
    }

    /*** Admin Functions ***/
    function setCalculateConfig(uint16 defaultFeesRate,
        uint8 insuranceRatio,
        uint16 defaultMarginLimit,
        uint16 priceDiffientRatio,
        uint16 updatePriceDiscount,
        uint16 feesDiscount,
        uint128 feesDiscountThreshold,
        uint16 penaltyRatio,
        uint8 maxLiquidationPriceDiffientRatio,
        uint16 twapDuration) external override onlyAdmin() {
        OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,
            feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);
        emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration);
    }

    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {
        OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);
        emit NewAddressConfig(controller, address(dexAggregator));
    }

    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {
        OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);
        emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs);
    }

    /// @notice List of all supporting Dexes.
    /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1
    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {
        Types.Market storage market = markets[marketId];
        if (poolIndex == 0) {
            market.pool0Insurance = market.pool0Insurance.sub(amount);
            (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));
            return;
        }
        market.pool1Insurance = market.pool1Insurance.sub(amount);
        (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this))));
    }

    function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {
        supportDexs[dex] = support;
    }

    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){
        taxes[marketId][token][index] = tax;
    }

    function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {
        Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];
        OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade);
    }

    function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {
        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());
        require(closeHeld <= trade.held, "CBH");
    }

    function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {
        require(held != 0 && lastBlockNumber != block.number && OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0");
    }

    modifier onlySupportDex(bytes memory dexData) {
        require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");
        _;
    }
}.]

### Summary of Security Vulnerabilities in the OpenLevV1 Smart Contract

1. **Reentrancy Vulnerability**:
   - Although the contract uses `ReentrancyGuard`, there are multiple external calls (e.g., `safeTransfer`, `call`) that could potentially lead to reentrancy attacks if not properly managed. The `marginTrade`, `closeTrade`, and `liquidate` functions involve external calls that could be exploited if the state changes are not handled correctly.

2. **Access Control Issues**:
   - The `initialize` function can only be called by the admin, but there are several functions that do not have proper access control checks, which could allow unauthorized users to execute sensitive operations.

3. **Arithmetic Vulnerabilities**:
   - Although the contract uses `SafeMath`, there are still areas where arithmetic operations could lead to unexpected results, especially in functions that involve multiple calculations (e.g., `feesAndInsurance`, `liquidate`). If not handled correctly, this could lead to underflows or overflows.

4. **Lack of Input Validation**:
   - Functions like `addMarket`, `marginTrade`, and `closeTrade` do not sufficiently validate input parameters. For example, there are no checks to ensure that the amounts being deposited or borrowed are greater than zero, which could lead to unintended behavior.

5. **Potential for Front-Running**:
   - The contract does not implement any mechanisms to prevent front-running attacks, particularly in trading functions where the execution order can be manipulated by malicious actors.

6. **Gas Limit and Block Size Issues**:
   - Functions that involve loops (e.g., iterating through supported Dexes) could run into gas limit issues if the number of Dexes grows significantly. This could lead to failed transactions.

7. **Insurance Pool Management**:
   - The logic for managing insurance pools could lead to situations where the insurance is insufficient to cover losses, especially if the market conditions change rapidly.

8. **Event Emission**:
   - Not all state-changing functions emit events, which could hinder tracking and debugging of contract interactions. For example, functions that modify trade states should emit corresponding events.

9. **Token Approval Risks**:
   - The contract uses `safeApprove` for token transfers, which can lead to issues if not handled correctly. If a user sets an approval to a non-zero value and then calls `safeApprove` again with a non-zero value, it could lead to race conditions.

### Comprehensive Analysis Report

The OpenLevV1 smart contract exhibits several security vulnerabilities that could potentially be exploited by malicious actors. The use of `ReentrancyGuard` is a positive step towards mitigating reentrancy attacks; however, the presence of multiple external calls still poses a risk. Access control measures are not uniformly applied, allowing unauthorized access to critical functions.

Arithmetic operations are safeguarded by `SafeMath`, but the potential for unexpected results remains if input validation is not adequately enforced. The lack of checks on input parameters could lead to erroneous states, particularly in financial transactions.

Front-running remains a significant concern, as the contract does not implement any protective measures against it. Additionally, the potential for gas limit issues in functions that iterate through arrays could lead to transaction failures.

The management of insurance pools requires careful consideration, as insufficient coverage could lead to significant losses during volatile market conditions. Furthermore, the contract's event emission strategy is lacking, which complicates the tracking of state changes and debugging efforts.

Overall, while the OpenLevV1 contract has a solid foundation, it requires enhancements in access control, input validation, event emissions, and protection against front-running and gas limit issues to ensure a robust and secure trading environment. A thorough audit and implementation of best practices in smart contract development are recommended to address these vulnerabilities.

[2024-24-08 18:27:45 INFO] **[Seminar Conclusion]**:

 ### Summary of Security Vulnerabilities in the OpenLevV1 Smart Contract

1. **Reentrancy Vulnerability**:
   - Although the contract uses `ReentrancyGuard`, there are multiple external calls (e.g., `safeTransfer`, `call`) that could potentially lead to reentrancy attacks if not properly managed. The `marginTrade`, `closeTrade`, and `liquidate` functions involve external calls that could be exploited if the state changes are not handled correctly.

2. **Access Control Issues**:
   - The `initialize` function can only be called by the admin, but there are several functions that do not have proper access control checks, which could allow unauthorized users to execute sensitive operations.

3. **Arithmetic Vulnerabilities**:
   - Although the contract uses `SafeMath`, there are still areas where arithmetic operations could lead to unexpected results, especially in functions that involve multiple calculations (e.g., `feesAndInsurance`, `liquidate`). If not handled correctly, this could lead to underflows or overflows.

4. **Lack of Input Validation**:
   - Functions like `addMarket`, `marginTrade`, and `closeTrade` do not sufficiently validate input parameters. For example, there are no checks to ensure that the amounts being deposited or borrowed are greater than zero, which could lead to unintended behavior.

5. **Potential for Front-Running**:
   - The contract does not implement any mechanisms to prevent front-running attacks, particularly in trading functions where the execution order can be manipulated by malicious actors.

6. **Gas Limit and Block Size Issues**:
   - Functions that involve loops (e.g., iterating through supported Dexes) could run into gas limit issues if the number of Dexes grows significantly. This could lead to failed transactions.

7. **Insurance Pool Management**:
   - The logic for managing insurance pools could lead to situations where the insurance is insufficient to cover losses, especially if the market conditions change rapidly.

8. **Event Emission**:
   - Not all state-changing functions emit events, which could hinder tracking and debugging of contract interactions. For example, functions that modify trade states should emit corresponding events.

9. **Token Approval Risks**:
   - The contract uses `safeApprove` for token transfers, which can lead to issues if not handled correctly. If a user sets an approval to a non-zero value and then calls `safeApprove` again with a non-zero value, it could lead to race conditions.

### Comprehensive Analysis Report

The OpenLevV1 smart contract exhibits several security vulnerabilities that could potentially be exploited by malicious actors. The use of `ReentrancyGuard` is a positive step towards mitigating reentrancy attacks; however, the presence of multiple external calls still poses a risk. Access control measures are not uniformly applied, allowing unauthorized access to critical functions.

Arithmetic operations are safeguarded by `SafeMath`, but the potential for unexpected results remains if input validation is not adequately enforced. The lack of checks on input parameters could lead to erroneous states, particularly in financial transactions.

Front-running remains a significant concern, as the contract does not implement any protective measures against it. Additionally, the potential for gas limit issues in functions that iterate through arrays could lead to transaction failures.

The management of insurance pools requires careful consideration, as insufficient coverage could lead to significant losses during volatile market conditions. Furthermore, the contract's event emission strategy is lacking, which complicates the tracking of state changes and debugging efforts.

Overall, while the OpenLevV1 contract has a solid foundation, it requires enhancements in access control, input validation, event emissions, and protection against front-running and gas limit issues to ensure a robust and secure trading environment. A thorough audit and implementation of best practices in smart contract development are recommended to address these vulnerabilities.

[2024-24-08 18:27:45 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-24-08 18:27:45 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.7.6; pragma experimental ABIEncoderV2; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import "./OpenLevInterface.sol"; import "./Types.sol"; import "./Adminable.sol"; import "./DelegateInterface.sol"; import "./ControllerInterface.sol"; import "./IWETH.sol"; import "./XOLEInterface.sol"; import "./Types.sol"; import "./OpenLevV1Lib.sol"; /// @title OpenLeverage margin trade logic /// @author OpenLeverage /// @notice Use this contract for margin trade. /// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE. contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {     using SafeMath for uint;     using TransferHelper for IERC20;     using DexData for bytes; constructor () { }  /// @notice initialize proxy contract /// @dev This function is not supposed to call multiple times. All configs can be set through other functions. /// @param _controller Address of contract ControllerDelegator. /// @param _dexAggregator contract DexAggregatorDelegator. /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens. /// @param _wETH Address of wrapped native coin. /// @param _xOLE Address of XOLEDelegator. /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol. function initialize(     address _controller,     DexAggregatorInterface _dexAggregator,     address[] memory depositTokens,     address _wETH,     address _xOLE,     uint8[] memory _supportDexs ) public {     depositTokens;     require(msg.sender == admin, "NAD");     addressConfig.controller = _controller;     addressConfig.dexAggregator = _dexAggregator;     addressConfig.wETH = _wETH;     addressConfig.xOLE = _xOLE;     for (uint i = 0; i &lt; _supportDexs.length; i++) {         supportDexs[_supportDexs[i]] = true;     }     OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig); }  /// @notice Create new trading pair. /// @dev This function is typically called by ControllerDelegator. /// @param pool0 Contract LpoolDelegator, lending pool of token0. /// @param pool1 Contract LpoolDelegator, lending pool of token1. /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value. /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens. /// @return The new created pair ID. function addMarket(     LPoolInterface pool0,     LPoolInterface pool1,     uint16 marginLimit,     bytes memory dexData ) external override returns (uint16) {     uint16 marketId = numPairs;     OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);     numPairs ++;     return marketId; }  /// @notice Margin trade or just add more deposit tokens. /// @dev To support token with tax and reward. Stores share of all token balances of this contract. /// @param longToken Token to long. False for token0, true for token1. /// @param depositToken Token to deposit. False for token0, true for token1. /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported. /// @param borrow Amount of ERC20 to borrow from the short token pool. /// @param minBuyAmount Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function marginTrade(     uint16 marketId,     bool longToken,     bool depositToken,     uint deposit,     uint borrow,     uint minBuyAmount,     bytes memory dexData ) external payable override nonReentrant onlySupportDex(dexData) {     Types.TradeVars memory tv;     Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);     verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);     (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);      if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);     }      tv.totalHeld = totalHelds[address(vars.buyToken)];     tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;      deposit = transferIn(msg.sender, tv.depositErc20, deposit);      // Borrow     uint borrowed;     if (borrow &gt; 0) {         {             uint balance = vars.sellToken.balanceOf(address(this));             vars.sellPool.borrowBehalf(msg.sender, borrow);             borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);         }          if (depositToken == longToken){             (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);             tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));         }else{             tv.borrowValue = borrow;         }     }      require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) &gt; vars.marginLimit, "MAM");     tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);     tv.depositAfterFees = deposit.sub(tv.fees);     tv.dexDetail = dexData.toDexDetail();      if (depositToken == longToken ){         if (borrowed &gt; 0){             tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);             tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);         }         tv.newHeld = tv.newHeld.add(tv.depositAfterFees);     }else{         tv.tradeSize = tv.depositAfterFees.add(borrowed);         tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);         tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);     }      Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];     tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);     trade.held = trade.held.add(tv.newHeld);     trade.depositToken = depositToken;     trade.deposited = trade.deposited.add(tv.depositAfterFees);     trade.lastBlockNum = uint128(block.number);      totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);      require(OpenLevV1Lib.isPositionHealthy(             msg.sender,             true,             OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),             vars,             dexData         ), "PNH");      emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail); }  /// @notice Close trade by shares. /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed. /// @param longToken Token to long. False for token0, true for token1. /// @param closeHeld Amount of shares to close. /// @param minOrMaxAmount Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {     Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];     Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);      //verify     verifyCloseBefore(trade, marketVars, closeHeld, dexData);      uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);      Types.CloseTradeVars memory closeTradeVars;     closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);     closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);     closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);     closeTradeVars.isPartialClose = closeHeld != trade.held;     closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);     closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);     closeTradeVars.dexDetail = dexData.toDexDetail();      //partial close     if (closeTradeVars.isPartialClose) {         closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);         closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);         trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);     } else {         closeTradeVars.depositDecrease = trade.deposited;     }      if (trade.depositToken != longToken) {         minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);         closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);         require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");          closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;         marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);          closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);         doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);     } else {         uint balance = marketVars.buyToken.balanceOf(address(this));         minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);         closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);         closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);         require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");          marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);         closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);         require(marketVars.sellToken.balanceOf(address(this)) &gt;= closeTradeVars.depositReturn, "ISB");         doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);     }      uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));     require(repayed &gt;= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");      if (!closeTradeVars.isPartialClose) {         delete activeTrades[msg.sender][marketId][longToken];     }else{         trade.held = trade.held.sub(closeHeld);         trade.lastBlockNum = uint128(block.number);     }      totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);      closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);     if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);     }      emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,         closeTradeVars.token0Price, closeTradeVars.dexDetail); }  /// @notice Liquidate if trade below margin limit. /// @dev For trades without sufficient funds to repay, use insurance. /// @param owner Owner of the trade to liquidate. /// @param longToken Token to long. False for token0, true for token1. /// @param minBuy Slippage for Dex trading. /// @param maxSell Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {     Types.Trade memory trade = activeTrades[owner][marketId][longToken];     Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);     if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);     }      verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());     uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);      (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);     require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");      Types.LiquidateVars memory liquidateVars;     liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);     liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);     if (liquidateVars.penalty &gt; 0) {         doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);     }     liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);     liquidateVars.dexDetail = dexData.toDexDetail();     liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);     liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);     liquidateVars.marketId = marketId;     liquidateVars.longToken = longToken;      bool buySuccess;     bytes memory sellAmountData;     if (longToken == trade.depositToken) {         maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);         marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);         (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(             abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],             taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)         );     }      if (buySuccess) {         {             uint temp;             assembly {                 temp := mload(add(sellAmountData, 0x20))             }             liquidateVars.sellAmount = temp;         }          liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);         marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);         liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);         doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);     } else {         liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;         liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);         if (liquidateVars.receiveAmount &gt;= liquidateVars.borrowed) {             // fail if buy failed but sell succeeded             require (longToken != trade.depositToken, "PH");             marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);             liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);             doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);         } else {             liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);             liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);             marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);         }     }      liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);     totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);      emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,         trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);      delete activeTrades[owner][marketId][longToken]; }  function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {     return open == longToken ?     Types.MarketVars(         market.pool1,         market.pool0,         IERC20(market.token1),         IERC20(market.token0),         IERC20(market.token1).balanceOf(address(this)),         IERC20(market.token0).balanceOf(address(this)),         market.pool1Insurance,         market.pool0Insurance,         market.marginLimit,         market.priceDiffientRatio,         market.dexs) :     Types.MarketVars(         market.pool0,         market.pool1,         IERC20(market.token0),         IERC20(market.token1),         IERC20(market.token0).balanceOf(address(this)),         IERC20(market.token1).balanceOf(address(this)),         market.pool0Insurance,         market.pool1Insurance,         market.marginLimit,         market.priceDiffientRatio,         market.dexs); }  /// @notice Get ratios of deposited token value to borrowed token value. /// @dev Caluclate ratio with current price and twap price. /// @param owner Owner of the trade to liquidate. /// @param longToken Token to long. False for token0, true for token1. /// @param dexData Index and fee rate for the trading Dex. /// @return current Margin ratio calculated using current price. /// @return cAvg Margin ratio calculated using twap price. /// @return hAvg Margin ratio calculated using last recorded twap price. /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value. function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {     Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);     limit = vars.marginLimit;     (current, cAvg, hAvg,,) =     OpenLevV1Lib.marginRatio(         owner,         activeTrades[owner][marketId][longToken].held,         address(vars.sellToken),         address(vars.buyToken),         vars.buyPool,         false,         dexData     ); }  /// @notice Check if a price update is required on Dex. /// @param dexData Index and fee rate for the trading Dex. function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){     Types.Market memory market = markets[marketId];     return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData); }  /// @notice Update price on Dex. /// @param dexData Index and fee rate for the trading Dex. function updatePrice(uint16 marketId, bytes memory dexData) external override {     OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData); }  /// @notice List of all supporting Dexes. function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){     return markets[marketId].dexs; }  function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {     Types.Market storage market = markets[marketId];     uint needed = totalRepayment.sub(remaining);     needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);     maxCanRepayAmount = totalRepayment;     if (longToken) {         if (market.pool0Insurance &gt;= needed) {             market.pool0Insurance = market.pool0Insurance - needed;             totalHelds[token] = totalHelds[token].sub(needed);         } else {             maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);             maxCanRepayAmount = maxCanRepayAmount.add(remaining);             totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);             market.pool0Insurance = 0;         }     } else {         if (market.pool1Insurance &gt;= needed) {             market.pool1Insurance = market.pool1Insurance - needed;         } else {             maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);             maxCanRepayAmount = maxCanRepayAmount.add(remaining);             totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);             market.pool1Insurance = 0;         }     } }  function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {     // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);     Types.Market storage market = markets[marketId];     uint defaultFees = tradeSize.mul(market.feesRate).div(10000);     uint newFees = defaultFees;     // if trader holds more xOLE, then should enjoy trading discount.     if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) &gt; calculateConfig.feesDiscountThreshold) {         newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));     }     // if trader update price, then should enjoy trading discount.     if (market.priceUpdater == trader) {         newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));     }     uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);     IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));      newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);     if (token == market.token1) {         market.pool1Insurance = market.pool1Insurance.add(newInsurance);     } else {         market.pool0Insurance = market.pool0Insurance.add(newInsurance);     }      totalHelds[token] = totalHelds[token].add(newInsurance);     return newFees; }  function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){     if (sellAmount &gt; 0){         DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;         IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);         buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);     } }  function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){     if (buyAmount &gt; 0){         DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;         IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);         sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);     } }  /// @dev All credited on this contract and share with all token holder if any rewards for the transfer. function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {     return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount); }  /// @dev All credited on "to" if any taxes for the transfer. function doTransferOut(address to, IERC20 token, uint amount) internal {     OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount); }  /*** Admin Functions ***/ function setCalculateConfig(uint16 defaultFeesRate,     uint8 insuranceRatio,     uint16 defaultMarginLimit,     uint16 priceDiffientRatio,     uint16 updatePriceDiscount,     uint16 feesDiscount,     uint128 feesDiscountThreshold,     uint16 penaltyRatio,     uint8 maxLiquidationPriceDiffientRatio,     uint16 twapDuration) external override onlyAdmin() {     OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,         feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);     emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration); }  function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {     OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);     emit NewAddressConfig(controller, address(dexAggregator)); }  function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {     OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);     emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs); }  /// @notice List of all supporting Dexes. /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1 function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {     Types.Market storage market = markets[marketId];     if (poolIndex == 0) {         market.pool0Insurance = market.pool0Insurance.sub(amount);         (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));         return;     }     market.pool1Insurance = market.pool1Insurance.sub(amount);     (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this)))); }  function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {     supportDexs[dex] = support; }  function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){     taxes[marketId][token][index] = tax; }  function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {     Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];     OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade); }  function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {     verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());     require(closeHeld &lt;= trade.held, "CBH"); }  function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {     require(held != 0 &amp;&amp; lastBlockNumber != block.number &amp;&amp; OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0"); }  modifier onlySupportDex(bytes memory dexData) {     require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");     _; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.7.6;\n\npragma experimental ABIEncoderV2;\n\nimport "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\nimport "./OpenLevInterface.sol";\nimport "./Types.sol";\nimport "./Adminable.sol";\nimport "./DelegateInterface.sol";\nimport "./ControllerInterface.sol";\nimport "./IWETH.sol";\nimport "./XOLEInterface.sol";\nimport "./Types.sol";\nimport "./OpenLevV1Lib.sol";\n\n/// @title OpenLeverage margin trade logic\n/// @author OpenLeverage\n/// @notice Use this contract for margin trade.\n/// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE.\ncontract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {\n    using SafeMath for uint;\n    using TransferHelper for IERC20;\n    using DexData for bytes;\n\n    constructor ()\n    {\n    }\n\n    /// @notice initialize proxy contract\n    /// @dev This function is not supposed to call multiple times. All configs can be set through other functions.\n    /// @param controller Address of contract ControllerDelegator.\n    /// @param _dexAggregator contract DexAggregatorDelegator.\n    /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens.\n    /// @param _wETH Address of wrapped native coin.\n    /// @param _xOLE Address of XOLEDelegator.\n    /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol.\n    function initialize(\n        address _controller,\n        DexAggregatorInterface _dexAggregator,\n        address[] memory depositTokens,\n        address _wETH,\n        address _xOLE,\n        uint8[] memory _supportDexs\n    ) public {\n        depositTokens;\n        require(msg.sender == admin, "NAD");\n        addressConfig.controller = _controller;\n        addressConfig.dexAggregator = _dexAggregator;\n        addressConfig.wETH = _wETH;\n        addressConfig.xOLE = _xOLE;\n        for (uint i = 0; i &lt; _supportDexs.length; i++) {\n            supportDexs[_supportDexs[i]] = true;\n        }\n        OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig);\n    }\n\n    /// @notice Create new trading pair.\n    /// @dev This function is typically called by ControllerDelegator.\n    /// @param pool0 Contract LpoolDelegator, lending pool of token0.\n    /// @param pool1 Contract LpoolDelegator, lending pool of token1.\n    /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value.\n    /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens.\n    /// @return The new created pair ID.\n    function addMarket(\n        LPoolInterface pool0,\n        LPoolInterface pool1,\n        uint16 marginLimit,\n        bytes memory dexData\n    ) external override returns (uint16) {\n        uint16 marketId = numPairs;\n        OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);\n        numPairs ++;\n        return marketId;\n    }\n\n    /// @notice Margin trade or just add more deposit tokens.\n    /// @dev To support token with tax and reward. Stores share of all token balances of this contract.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param depositToken Token to deposit. False for token0, true for token1.\n    /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported.\n    /// @param borrow Amount of ERC20 to borrow from the short token pool.\n    /// @param minBuyAmount Slippage for Dex trading.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function marginTrade(\n        uint16 marketId,\n        bool longToken,\n        bool depositToken,\n        uint deposit,\n        uint borrow,\n        uint minBuyAmount,\n        bytes memory dexData\n    ) external payable override nonReentrant onlySupportDex(dexData) {\n        Types.TradeVars memory tv;\n        Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);\n        verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);\n        (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);\n\n        if (dexData.isUniV2Class()) {\n            OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);\n        }\n\n        tv.totalHeld = totalHelds[address(vars.buyToken)];\n        tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;\n\n        deposit = transferIn(msg.sender, tv.depositErc20, deposit);\n\n        // Borrow\n        uint borrowed;\n        if (borrow &gt; 0) {\n            {\n                uint balance = vars.sellToken.balanceOf(address(this));\n                vars.sellPool.borrowBehalf(msg.sender, borrow);\n                borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);\n            }\n\n            if (depositToken == longToken){\n                (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);\n                tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));\n            }else{\n                tv.borrowValue = borrow;\n            }\n        }\n\n        require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) &gt; vars.marginLimit, "MAM");\n        tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);\n        tv.depositAfterFees = deposit.sub(tv.fees);\n        tv.dexDetail = dexData.toDexDetail();\n\n        if (depositToken == longToken ){\n            if (borrowed &gt; 0){\n                tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);\n                tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);\n            }\n            tv.newHeld = tv.newHeld.add(tv.depositAfterFees);\n        }else{\n            tv.tradeSize = tv.depositAfterFees.add(borrowed);\n            tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);\n            tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);\n        }\n\n        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];\n        tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);\n        trade.held = trade.held.add(tv.newHeld);\n        trade.depositToken = depositToken;\n        trade.deposited = trade.deposited.add(tv.depositAfterFees);\n        trade.lastBlockNum = uint128(block.number);\n\n        totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);\n\n        require(OpenLevV1Lib.isPositionHealthy(\n                msg.sender,\n                true,\n                OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),\n                vars,\n                dexData\n            ), "PNH");\n\n        emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail);\n    }\n\n    /// @notice Close trade by shares.\n    /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param closeHeld Amount of shares to close.\n    /// @param minOrMaxAmount Slippage for Dex trading.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {\n        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];\n        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);\n\n        //verify\n        verifyCloseBefore(trade, marketVars, closeHeld, dexData);\n\n        uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n\n        Types.CloseTradeVars memory closeTradeVars;\n        closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n        closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);\n        closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);\n        closeTradeVars.isPartialClose = closeHeld != trade.held;\n        closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);\n        closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);\n        closeTradeVars.dexDetail = dexData.toDexDetail();\n\n        //partial close\n        if (closeTradeVars.isPartialClose) {\n            closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);\n            closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);\n            trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);\n        } else {\n            closeTradeVars.depositDecrease = trade.deposited;\n        }\n\n        if (trade.depositToken != longToken) {\n            minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);\n            closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);\n            require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");\n\n            closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;\n            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);\n\n            closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);\n            doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);\n        } else {\n            uint balance = marketVars.buyToken.balanceOf(address(this));\n            minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);\n            closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);\n            closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);\n            require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");\n\n            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);\n            closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);\n            require(marketVars.sellToken.balanceOf(address(this)) &gt;= closeTradeVars.depositReturn, "ISB");\n            doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);\n        }\n\n        uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));\n        require(repayed &gt;= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");\n\n        if (!closeTradeVars.isPartialClose) {\n            delete activeTrades[msg.sender][marketId][longToken];\n        }else{\n            trade.held = trade.held.sub(closeHeld);\n            trade.lastBlockNum = uint128(block.number);\n        }\n\n        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);\n\n        closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);\n        if (dexData.isUniV2Class()) {\n            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);\n        }\n\n        emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,\n            closeTradeVars.token0Price, closeTradeVars.dexDetail);\n    }\n\n    /// @notice Liquidate if trade below margin limit.\n    /// @dev For trades without sufficient funds to repay, use insurance.\n    /// @param owner Owner of the trade to liquidate.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param minBuy Slippage for Dex trading.\n    /// @param maxSell Slippage for Dex trading.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {\n        Types.Trade memory trade = activeTrades[owner][marketId][longToken];\n        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);\n        if (dexData.isUniV2Class()) {\n            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);\n        }\n\n        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());\n        uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n\n        (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);\n        require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");\n\n        Types.LiquidateVars memory liquidateVars;\n        liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n        liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);\n        if (liquidateVars.penalty &gt; 0) {\n            doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);\n        }\n        liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);\n        liquidateVars.dexDetail = dexData.toDexDetail();\n        liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);\n        liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);\n        liquidateVars.marketId = marketId;\n        liquidateVars.longToken = longToken;\n\n        bool buySuccess;\n        bytes memory sellAmountData;\n        if (longToken == trade.depositToken) {\n            maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);\n            marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);\n            (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(\n                abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],\n                taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)\n            );\n        }\n\n        if (buySuccess) {\n            {\n                uint temp;\n                assembly {\n                    temp := mload(add(sellAmountData, 0x20))\n                }\n                liquidateVars.sellAmount = temp;\n            }\n\n            liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);\n            marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);\n            liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);\n            doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);\n        } else {\n            liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;\n            liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);\n            if (liquidateVars.receiveAmount &gt;= liquidateVars.borrowed) {\n                // fail if buy failed but sell succeeded\n                require (longToken != trade.depositToken, "PH");\n                marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);\n                liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);\n                doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);\n            } else {\n                liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);\n                liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);\n                marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);\n            }\n        }\n\n        liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);\n        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);\n\n        emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,\n            trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);\n\n        delete activeTrades[owner][marketId][longToken];\n    }\n\n    function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {\n        return open == longToken ?\n        Types.MarketVars(\n            market.pool1,\n            market.pool0,\n            IERC20(market.token1),\n            IERC20(market.token0),\n            IERC20(market.token1).balanceOf(address(this)),\n            IERC20(market.token0).balanceOf(address(this)),\n            market.pool1Insurance,\n            market.pool0Insurance,\n            market.marginLimit,\n            market.priceDiffientRatio,\n            market.dexs) :\n        Types.MarketVars(\n            market.pool0,\n            market.pool1,\n            IERC20(market.token0),\n            IERC20(market.token1),\n            IERC20(market.token0).balanceOf(address(this)),\n            IERC20(market.token1).balanceOf(address(this)),\n            market.pool0Insurance,\n            market.pool1Insurance,\n            market.marginLimit,\n            market.priceDiffientRatio,\n            market.dexs);\n    }\n\n    /// @notice Get ratios of deposited token value to borrowed token value.\n    /// @dev Caluclate ratio with current price and twap price.\n    /// @param owner Owner of the trade to liquidate.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param dexData Index and fee rate for the trading Dex.\n    /// @return current Margin ratio calculated using current price.\n    /// @return cAvg Margin ratio calculated using twap price.\n    /// @return hAvg Margin ratio calculated using last recorded twap price.\n    /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value.\n    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {\n        Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);\n        limit = vars.marginLimit;\n        (current, cAvg, hAvg,,) =\n        OpenLevV1Lib.marginRatio(\n            owner,\n            activeTrades[owner][marketId][longToken].held,\n            address(vars.sellToken),\n            address(vars.buyToken),\n            vars.buyPool,\n            false,\n            dexData\n        );\n    }\n\n    /// @notice Check if a price update is required on Dex.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){\n        Types.Market memory market = markets[marketId];\n        return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData);\n    }\n\n    /// @notice Update price on Dex.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function updatePrice(uint16 marketId, bytes memory dexData) external override {\n        OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData);\n    }\n\n    /// @notice List of all supporting Dexes.\n    function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){\n        return markets[marketId].dexs;\n    }\n\n    function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {\n        Types.Market storage market = markets[marketId];\n        uint needed = totalRepayment.sub(remaining);\n        needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);\n        maxCanRepayAmount = totalRepayment;\n        if (longToken) {\n            if (market.pool0Insurance &gt;= needed) {\n                market.pool0Insurance = market.pool0Insurance - needed;\n                totalHelds[token] = totalHelds[token].sub(needed);\n            } else {\n                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);\n                maxCanRepayAmount = maxCanRepayAmount.add(remaining);\n                totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);\n                market.pool0Insurance = 0;\n            }\n        } else {\n            if (market.pool1Insurance &gt;= needed) {\n                market.pool1Insurance = market.pool1Insurance - needed;\n            } else {\n                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);\n                maxCanRepayAmount = maxCanRepayAmount.add(remaining);\n                totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);\n                market.pool1Insurance = 0;\n            }\n        }\n    }\n\n    function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {\n        // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);\n        Types.Market storage market = markets[marketId];\n        uint defaultFees = tradeSize.mul(market.feesRate).div(10000);\n        uint newFees = defaultFees;\n        // if trader holds more xOLE, then should enjoy trading discount.\n        if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) &gt; calculateConfig.feesDiscountThreshold) {\n            newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));\n        }\n        // if trader update price, then should enjoy trading discount.\n        if (market.priceUpdater == trader) {\n            newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));\n        }\n        uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);\n        IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));\n\n        newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);\n        if (token == market.token1) {\n            market.pool1Insurance = market.pool1Insurance.add(newInsurance);\n        } else {\n            market.pool0Insurance = market.pool0Insurance.add(newInsurance);\n        }\n\n        totalHelds[token] = totalHelds[token].add(newInsurance);\n        return newFees;\n    }\n\n    function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){\n        if (sellAmount &gt; 0){\n            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;\n            IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);\n            buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);\n        }\n    }\n\n    function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){\n        if (buyAmount &gt; 0){\n            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;\n            IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);\n            sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);\n        }\n    }\n\n    /// @dev All credited on this contract and share with all token holder if any rewards for the transfer.\n    function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {\n        return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount);\n    }\n\n    /// @dev All credited on "to" if any taxes for the transfer.\n    function doTransferOut(address to, IERC20 token, uint amount) internal {\n        OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount);\n    }\n\n    / Admin Functions /\n    function setCalculateConfig(uint16 defaultFeesRate,\n        uint8 insuranceRatio,\n        uint16 defaultMarginLimit,\n        uint16 priceDiffientRatio,\n        uint16 updatePriceDiscount,\n        uint16 feesDiscount,\n        uint128 feesDiscountThreshold,\n        uint16 penaltyRatio,\n        uint8 maxLiquidationPriceDiffientRatio,\n        uint16 twapDuration) external override onlyAdmin() {\n        OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,\n            feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);\n        emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration);\n    }\n\n    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {\n        OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);\n        emit NewAddressConfig(controller, address(dexAggregator));\n    }\n\n    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {\n        OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);\n        emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs);\n    }\n\n    /// @notice List of all supporting Dexes.\n    /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1\n    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {\n        Types.Market storage market = markets[marketId];\n        if (poolIndex == 0) {\n            market.pool0Insurance = market.pool0Insurance.sub(amount);\n            (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));\n            return;\n        }\n        market.pool1Insurance = market.pool1Insurance.sub(amount);\n        (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this))));\n    }\n\n    function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {\n        supportDexs[dex] = support;\n    }\n\n    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){\n        taxes[marketId][token][index] = tax;\n    }\n\n    function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {\n        Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];\n        OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade);\n    }\n\n    function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {\n        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());\n        require(closeHeld &lt;= trade.held, "CBH");\n    }\n\n    function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {\n        require(held != 0 &amp;&amp; lastBlockNumber != block.number &amp;&amp; OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0");\n    }\n\n    modifier onlySupportDex(bytes memory dexData) {\n        require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");\n        ;\n    }\n}', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-24-08 18:27:45 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.7.6; pragma experimental ABIEncoderV2; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import "./OpenLevInterface.sol"; import "./Types.sol"; import "./Adminable.sol"; import "./DelegateInterface.sol"; import "./ControllerInterface.sol"; import "./IWETH.sol"; import "./XOLEInterface.sol"; import "./Types.sol"; import "./OpenLevV1Lib.sol"; /// @title OpenLeverage margin trade logic /// @author OpenLeverage /// @notice Use this contract for margin trade. /// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE. contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {     using SafeMath for uint;     using TransferHelper for IERC20;     using DexData for bytes; constructor () { }  /// @notice initialize proxy contract /// @dev This function is not supposed to call multiple times. All configs can be set through other functions. /// @param _controller Address of contract ControllerDelegator. /// @param _dexAggregator contract DexAggregatorDelegator. /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens. /// @param _wETH Address of wrapped native coin. /// @param _xOLE Address of XOLEDelegator. /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol. function initialize(     address _controller,     DexAggregatorInterface _dexAggregator,     address[] memory depositTokens,     address _wETH,     address _xOLE,     uint8[] memory _supportDexs ) public {     depositTokens;     require(msg.sender == admin, "NAD");     addressConfig.controller = _controller;     addressConfig.dexAggregator = _dexAggregator;     addressConfig.wETH = _wETH;     addressConfig.xOLE = _xOLE;     for (uint i = 0; i &lt; _supportDexs.length; i++) {         supportDexs[_supportDexs[i]] = true;     }     OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig); }  /// @notice Create new trading pair. /// @dev This function is typically called by ControllerDelegator. /// @param pool0 Contract LpoolDelegator, lending pool of token0. /// @param pool1 Contract LpoolDelegator, lending pool of token1. /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value. /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens. /// @return The new created pair ID. function addMarket(     LPoolInterface pool0,     LPoolInterface pool1,     uint16 marginLimit,     bytes memory dexData ) external override returns (uint16) {     uint16 marketId = numPairs;     OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);     numPairs ++;     return marketId; }  /// @notice Margin trade or just add more deposit tokens. /// @dev To support token with tax and reward. Stores share of all token balances of this contract. /// @param longToken Token to long. False for token0, true for token1. /// @param depositToken Token to deposit. False for token0, true for token1. /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported. /// @param borrow Amount of ERC20 to borrow from the short token pool. /// @param minBuyAmount Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function marginTrade(     uint16 marketId,     bool longToken,     bool depositToken,     uint deposit,     uint borrow,     uint minBuyAmount,     bytes memory dexData ) external payable override nonReentrant onlySupportDex(dexData) {     Types.TradeVars memory tv;     Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);     verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);     (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);      if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);     }      tv.totalHeld = totalHelds[address(vars.buyToken)];     tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;      deposit = transferIn(msg.sender, tv.depositErc20, deposit);      // Borrow     uint borrowed;     if (borrow &gt; 0) {         {             uint balance = vars.sellToken.balanceOf(address(this));             vars.sellPool.borrowBehalf(msg.sender, borrow);             borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);         }          if (depositToken == longToken){             (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);             tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));         }else{             tv.borrowValue = borrow;         }     }      require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) &gt; vars.marginLimit, "MAM");     tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);     tv.depositAfterFees = deposit.sub(tv.fees);     tv.dexDetail = dexData.toDexDetail();      if (depositToken == longToken ){         if (borrowed &gt; 0){             tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);             tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);         }         tv.newHeld = tv.newHeld.add(tv.depositAfterFees);     }else{         tv.tradeSize = tv.depositAfterFees.add(borrowed);         tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);         tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);     }      Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];     tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);     trade.held = trade.held.add(tv.newHeld);     trade.depositToken = depositToken;     trade.deposited = trade.deposited.add(tv.depositAfterFees);     trade.lastBlockNum = uint128(block.number);      totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);      require(OpenLevV1Lib.isPositionHealthy(             msg.sender,             true,             OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),             vars,             dexData         ), "PNH");      emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail); }  /// @notice Close trade by shares. /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed. /// @param longToken Token to long. False for token0, true for token1. /// @param closeHeld Amount of shares to close. /// @param minOrMaxAmount Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {     Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];     Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);      //verify     verifyCloseBefore(trade, marketVars, closeHeld, dexData);      uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);      Types.CloseTradeVars memory closeTradeVars;     closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);     closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);     closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);     closeTradeVars.isPartialClose = closeHeld != trade.held;     closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);     closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);     closeTradeVars.dexDetail = dexData.toDexDetail();      //partial close     if (closeTradeVars.isPartialClose) {         closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);         closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);         trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);     } else {         closeTradeVars.depositDecrease = trade.deposited;     }      if (trade.depositToken != longToken) {         minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);         closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);         require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");          closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;         marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);          closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);         doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);     } else {         uint balance = marketVars.buyToken.balanceOf(address(this));         minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);         closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);         closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);         require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");          marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);         closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);         require(marketVars.sellToken.balanceOf(address(this)) &gt;= closeTradeVars.depositReturn, "ISB");         doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);     }      uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));     require(repayed &gt;= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");      if (!closeTradeVars.isPartialClose) {         delete activeTrades[msg.sender][marketId][longToken];     }else{         trade.held = trade.held.sub(closeHeld);         trade.lastBlockNum = uint128(block.number);     }      totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);      closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);     if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);     }      emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,         closeTradeVars.token0Price, closeTradeVars.dexDetail); }  /// @notice Liquidate if trade below margin limit. /// @dev For trades without sufficient funds to repay, use insurance. /// @param owner Owner of the trade to liquidate. /// @param longToken Token to long. False for token0, true for token1. /// @param minBuy Slippage for Dex trading. /// @param maxSell Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {     Types.Trade memory trade = activeTrades[owner][marketId][longToken];     Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);     if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);     }      verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());     uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);      (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);     require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");      Types.LiquidateVars memory liquidateVars;     liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);     liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);     if (liquidateVars.penalty &gt; 0) {         doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);     }     liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);     liquidateVars.dexDetail = dexData.toDexDetail();     liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);     liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);     liquidateVars.marketId = marketId;     liquidateVars.longToken = longToken;      bool buySuccess;     bytes memory sellAmountData;     if (longToken == trade.depositToken) {         maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);         marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);         (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(             abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],             taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)         );     }      if (buySuccess) {         {             uint temp;             assembly {                 temp := mload(add(sellAmountData, 0x20))             }             liquidateVars.sellAmount = temp;         }          liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);         marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);         liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);         doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);     } else {         liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;         liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);         if (liquidateVars.receiveAmount &gt;= liquidateVars.borrowed) {             // fail if buy failed but sell succeeded             require (longToken != trade.depositToken, "PH");             marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);             liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);             doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);         } else {             liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);             liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);             marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);         }     }      liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);     totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);      emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,         trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);      delete activeTrades[owner][marketId][longToken]; }  function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {     return open == longToken ?     Types.MarketVars(         market.pool1,         market.pool0,         IERC20(market.token1),         IERC20(market.token0),         IERC20(market.token1).balanceOf(address(this)),         IERC20(market.token0).balanceOf(address(this)),         market.pool1Insurance,         market.pool0Insurance,         market.marginLimit,         market.priceDiffientRatio,         market.dexs) :     Types.MarketVars(         market.pool0,         market.pool1,         IERC20(market.token0),         IERC20(market.token1),         IERC20(market.token0).balanceOf(address(this)),         IERC20(market.token1).balanceOf(address(this)),         market.pool0Insurance,         market.pool1Insurance,         market.marginLimit,         market.priceDiffientRatio,         market.dexs); }  /// @notice Get ratios of deposited token value to borrowed token value. /// @dev Caluclate ratio with current price and twap price. /// @param owner Owner of the trade to liquidate. /// @param longToken Token to long. False for token0, true for token1. /// @param dexData Index and fee rate for the trading Dex. /// @return current Margin ratio calculated using current price. /// @return cAvg Margin ratio calculated using twap price. /// @return hAvg Margin ratio calculated using last recorded twap price. /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value. function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {     Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);     limit = vars.marginLimit;     (current, cAvg, hAvg,,) =     OpenLevV1Lib.marginRatio(         owner,         activeTrades[owner][marketId][longToken].held,         address(vars.sellToken),         address(vars.buyToken),         vars.buyPool,         false,         dexData     ); }  /// @notice Check if a price update is required on Dex. /// @param dexData Index and fee rate for the trading Dex. function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){     Types.Market memory market = markets[marketId];     return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData); }  /// @notice Update price on Dex. /// @param dexData Index and fee rate for the trading Dex. function updatePrice(uint16 marketId, bytes memory dexData) external override {     OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData); }  /// @notice List of all supporting Dexes. function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){     return markets[marketId].dexs; }  function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {     Types.Market storage market = markets[marketId];     uint needed = totalRepayment.sub(remaining);     needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);     maxCanRepayAmount = totalRepayment;     if (longToken) {         if (market.pool0Insurance &gt;= needed) {             market.pool0Insurance = market.pool0Insurance - needed;             totalHelds[token] = totalHelds[token].sub(needed);         } else {             maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);             maxCanRepayAmount = maxCanRepayAmount.add(remaining);             totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);             market.pool0Insurance = 0;         }     } else {         if (market.pool1Insurance &gt;= needed) {             market.pool1Insurance = market.pool1Insurance - needed;         } else {             maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);             maxCanRepayAmount = maxCanRepayAmount.add(remaining);             totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);             market.pool1Insurance = 0;         }     } }  function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {     // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);     Types.Market storage market = markets[marketId];     uint defaultFees = tradeSize.mul(market.feesRate).div(10000);     uint newFees = defaultFees;     // if trader holds more xOLE, then should enjoy trading discount.     if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) &gt; calculateConfig.feesDiscountThreshold) {         newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));     }     // if trader update price, then should enjoy trading discount.     if (market.priceUpdater == trader) {         newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));     }     uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);     IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));      newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);     if (token == market.token1) {         market.pool1Insurance = market.pool1Insurance.add(newInsurance);     } else {         market.pool0Insurance = market.pool0Insurance.add(newInsurance);     }      totalHelds[token] = totalHelds[token].add(newInsurance);     return newFees; }  function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){     if (sellAmount &gt; 0){         DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;         IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);         buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);     } }  function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){     if (buyAmount &gt; 0){         DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;         IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);         sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);     } }  /// @dev All credited on this contract and share with all token holder if any rewards for the transfer. function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {     return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount); }  /// @dev All credited on "to" if any taxes for the transfer. function doTransferOut(address to, IERC20 token, uint amount) internal {     OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount); }  /*** Admin Functions ***/ function setCalculateConfig(uint16 defaultFeesRate,     uint8 insuranceRatio,     uint16 defaultMarginLimit,     uint16 priceDiffientRatio,     uint16 updatePriceDiscount,     uint16 feesDiscount,     uint128 feesDiscountThreshold,     uint16 penaltyRatio,     uint8 maxLiquidationPriceDiffientRatio,     uint16 twapDuration) external override onlyAdmin() {     OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,         feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);     emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration); }  function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {     OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);     emit NewAddressConfig(controller, address(dexAggregator)); }  function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {     OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);     emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs); }  /// @notice List of all supporting Dexes. /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1 function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {     Types.Market storage market = markets[marketId];     if (poolIndex == 0) {         market.pool0Insurance = market.pool0Insurance.sub(amount);         (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));         return;     }     market.pool1Insurance = market.pool1Insurance.sub(amount);     (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this)))); }  function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {     supportDexs[dex] = support; }  function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){     taxes[marketId][token][index] = tax; }  function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {     Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];     OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade); }  function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {     verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());     require(closeHeld &lt;= trade.held, "CBH"); }  function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {     require(held != 0 &amp;&amp; lastBlockNumber != block.number &amp;&amp; OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0"); }  modifier onlySupportDex(bytes memory dexData) {     require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");     _; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-24-08 18:27:45 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;

pragma experimental ABIEncoderV2;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "./OpenLevInterface.sol";
import "./Types.sol";
import "./Adminable.sol";
import "./DelegateInterface.sol";
import "./ControllerInterface.sol";
import "./IWETH.sol";
import "./XOLEInterface.sol";
import "./Types.sol";
import "./OpenLevV1Lib.sol";

/// @title OpenLeverage margin trade logic
/// @author OpenLeverage
/// @notice Use this contract for margin trade.
/// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE.
contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {
    using SafeMath for uint;
    using TransferHelper for IERC20;
    using DexData for bytes;

    constructor ()
    {
    }

    /// @notice initialize proxy contract
    /// @dev This function is not supposed to call multiple times. All configs can be set through other functions.
    /// @param _controller Address of contract ControllerDelegator.
    /// @param _dexAggregator contract DexAggregatorDelegator.
    /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens.
    /// @param _wETH Address of wrapped native coin.
    /// @param _xOLE Address of XOLEDelegator.
    /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol.
    function initialize(
        address _controller,
        DexAggregatorInterface _dexAggregator,
        address[] memory depositTokens,
        address _wETH,
        address _xOLE,
        uint8[] memory _supportDexs
    ) public {
        depositTokens;
        require(msg.sender == admin, "NAD");
        addressConfig.controller = _controller;
        addressConfig.dexAggregator = _dexAggregator;
        addressConfig.wETH = _wETH;
        addressConfig.xOLE = _xOLE;
        for (uint i = 0; i < _supportDexs.length; i++) {
            supportDexs[_supportDexs[i]] = true;
        }
        OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig);
    }

    /// @notice Create new trading pair.
    /// @dev This function is typically called by ControllerDelegator.
    /// @param pool0 Contract LpoolDelegator, lending pool of token0.
    /// @param pool1 Contract LpoolDelegator, lending pool of token1.
    /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value.
    /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens.
    /// @return The new created pair ID.
    function addMarket(
        LPoolInterface pool0,
        LPoolInterface pool1,
        uint16 marginLimit,
        bytes memory dexData
    ) external override returns (uint16) {
        uint16 marketId = numPairs;
        OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);
        numPairs ++;
        return marketId;
    }

    /// @notice Margin trade or just add more deposit tokens.
    /// @dev To support token with tax and reward. Stores share of all token balances of this contract.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param depositToken Token to deposit. False for token0, true for token1.
    /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported.
    /// @param borrow Amount of ERC20 to borrow from the short token pool.
    /// @param minBuyAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function marginTrade(
        uint16 marketId,
        bool longToken,
        bool depositToken,
        uint deposit,
        uint borrow,
        uint minBuyAmount,
        bytes memory dexData
    ) external payable override nonReentrant onlySupportDex(dexData) {
        Types.TradeVars memory tv;
        Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);
        verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);
        (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);

        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);
        }

        tv.totalHeld = totalHelds[address(vars.buyToken)];
        tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;

        deposit = transferIn(msg.sender, tv.depositErc20, deposit);

        // Borrow
        uint borrowed;
        if (borrow > 0) {
            {
                uint balance = vars.sellToken.balanceOf(address(this));
                vars.sellPool.borrowBehalf(msg.sender, borrow);
                borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);
            }

            if (depositToken == longToken){
                (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);
                tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));
            }else{
                tv.borrowValue = borrow;
            }
        }

        require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) > vars.marginLimit, "MAM");
        tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);
        tv.depositAfterFees = deposit.sub(tv.fees);
        tv.dexDetail = dexData.toDexDetail();

        if (depositToken == longToken ){
            if (borrowed > 0){
                tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);
                tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);
            }
            tv.newHeld = tv.newHeld.add(tv.depositAfterFees);
        }else{
            tv.tradeSize = tv.depositAfterFees.add(borrowed);
            tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);
            tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);
        }

        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);
        trade.held = trade.held.add(tv.newHeld);
        trade.depositToken = depositToken;
        trade.deposited = trade.deposited.add(tv.depositAfterFees);
        trade.lastBlockNum = uint128(block.number);

        totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);

        require(OpenLevV1Lib.isPositionHealthy(
                msg.sender,
                true,
                OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),
                vars,
                dexData
            ), "PNH");

        emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail);
    }

    /// @notice Close trade by shares.
    /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param closeHeld Amount of shares to close.
    /// @param minOrMaxAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);

        //verify
        verifyCloseBefore(trade, marketVars, closeHeld, dexData);

        uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        Types.CloseTradeVars memory closeTradeVars;
        closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);
        closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);
        closeTradeVars.isPartialClose = closeHeld != trade.held;
        closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);
        closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        closeTradeVars.dexDetail = dexData.toDexDetail();

        //partial close
        if (closeTradeVars.isPartialClose) {
            closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);
            closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);
            trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);
        } else {
            closeTradeVars.depositDecrease = trade.deposited;
        }

        if (trade.depositToken != longToken) {
            minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);
            closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;
            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);

            closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);
            doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);
        } else {
            uint balance = marketVars.buyToken.balanceOf(address(this));
            minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);
            closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);
            closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);
            closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);
            require(marketVars.sellToken.balanceOf(address(this)) >= closeTradeVars.depositReturn, "ISB");
            doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);
        }

        uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));
        require(repayed >= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");

        if (!closeTradeVars.isPartialClose) {
            delete activeTrades[msg.sender][marketId][longToken];
        }else{
            trade.held = trade.held.sub(closeHeld);
            trade.lastBlockNum = uint128(block.number);
        }

        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);

        closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,
            closeTradeVars.token0Price, closeTradeVars.dexDetail);
    }

    /// @notice Liquidate if trade below margin limit.
    /// @dev For trades without sufficient funds to repay, use insurance.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param minBuy Slippage for Dex trading.
    /// @param maxSell Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade memory trade = activeTrades[owner][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());
        uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);
        require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");

        Types.LiquidateVars memory liquidateVars;
        liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);
        if (liquidateVars.penalty > 0) {
            doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);
        }
        liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);
        liquidateVars.dexDetail = dexData.toDexDetail();
        liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);
        liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        liquidateVars.marketId = marketId;
        liquidateVars.longToken = longToken;

        bool buySuccess;
        bytes memory sellAmountData;
        if (longToken == trade.depositToken) {
            maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);
            marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);
            (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(
                abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],
                taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)
            );
        }

        if (buySuccess) {
            {
                uint temp;
                assembly {
                    temp := mload(add(sellAmountData, 0x20))
                }
                liquidateVars.sellAmount = temp;
            }

            liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);
            marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
            liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);
            doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);
        } else {
            liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;
            liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);
            if (liquidateVars.receiveAmount >= liquidateVars.borrowed) {
                // fail if buy failed but sell succeeded
                require (longToken != trade.depositToken, "PH");
                marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
                liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);
                doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);
            } else {
                liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);
                liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);
                marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);
            }
        }

        liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);
        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);

        emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,
            trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);

        delete activeTrades[owner][marketId][longToken];
    }

    function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {
        return open == longToken ?
        Types.MarketVars(
            market.pool1,
            market.pool0,
            IERC20(market.token1),
            IERC20(market.token0),
            IERC20(market.token1).balanceOf(address(this)),
            IERC20(market.token0).balanceOf(address(this)),
            market.pool1Insurance,
            market.pool0Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs) :
        Types.MarketVars(
            market.pool0,
            market.pool1,
            IERC20(market.token0),
            IERC20(market.token1),
            IERC20(market.token0).balanceOf(address(this)),
            IERC20(market.token1).balanceOf(address(this)),
            market.pool0Insurance,
            market.pool1Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs);
    }

    /// @notice Get ratios of deposited token value to borrowed token value.
    /// @dev Caluclate ratio with current price and twap price.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param dexData Index and fee rate for the trading Dex.
    /// @return current Margin ratio calculated using current price.
    /// @return cAvg Margin ratio calculated using twap price.
    /// @return hAvg Margin ratio calculated using last recorded twap price.
    /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value.
    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {
        Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);
        limit = vars.marginLimit;
        (current, cAvg, hAvg,,) =
        OpenLevV1Lib.marginRatio(
            owner,
            activeTrades[owner][marketId][longToken].held,
            address(vars.sellToken),
            address(vars.buyToken),
            vars.buyPool,
            false,
            dexData
        );
    }

    /// @notice Check if a price update is required on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){
        Types.Market memory market = markets[marketId];
        return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData);
    }

    /// @notice Update price on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function updatePrice(uint16 marketId, bytes memory dexData) external override {
        OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData);
    }

    /// @notice List of all supporting Dexes.
    function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){
        return markets[marketId].dexs;
    }

    function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {
        Types.Market storage market = markets[marketId];
        uint needed = totalRepayment.sub(remaining);
        needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);
        maxCanRepayAmount = totalRepayment;
        if (longToken) {
            if (market.pool0Insurance >= needed) {
                market.pool0Insurance = market.pool0Insurance - needed;
                totalHelds[token] = totalHelds[token].sub(needed);
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);
                market.pool0Insurance = 0;
            }
        } else {
            if (market.pool1Insurance >= needed) {
                market.pool1Insurance = market.pool1Insurance - needed;
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);
                market.pool1Insurance = 0;
            }
        }
    }

    function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {
        // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);
        Types.Market storage market = markets[marketId];
        uint defaultFees = tradeSize.mul(market.feesRate).div(10000);
        uint newFees = defaultFees;
        // if trader holds more xOLE, then should enjoy trading discount.
        if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) > calculateConfig.feesDiscountThreshold) {
            newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));
        }
        // if trader update price, then should enjoy trading discount.
        if (market.priceUpdater == trader) {
            newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));
        }
        uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);
        IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));

        newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);
        if (token == market.token1) {
            market.pool1Insurance = market.pool1Insurance.add(newInsurance);
        } else {
            market.pool0Insurance = market.pool0Insurance.add(newInsurance);
        }

        totalHelds[token] = totalHelds[token].add(newInsurance);
        return newFees;
    }

    function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){
        if (sellAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);
            buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);
        }
    }

    function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){
        if (buyAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);
            sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);
        }
    }

    /// @dev All credited on this contract and share with all token holder if any rewards for the transfer.
    function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {
        return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount);
    }

    /// @dev All credited on "to" if any taxes for the transfer.
    function doTransferOut(address to, IERC20 token, uint amount) internal {
        OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount);
    }

    /*** Admin Functions ***/
    function setCalculateConfig(uint16 defaultFeesRate,
        uint8 insuranceRatio,
        uint16 defaultMarginLimit,
        uint16 priceDiffientRatio,
        uint16 updatePriceDiscount,
        uint16 feesDiscount,
        uint128 feesDiscountThreshold,
        uint16 penaltyRatio,
        uint8 maxLiquidationPriceDiffientRatio,
        uint16 twapDuration) external override onlyAdmin() {
        OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,
            feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);
        emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration);
    }

    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {
        OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);
        emit NewAddressConfig(controller, address(dexAggregator));
    }

    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {
        OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);
        emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs);
    }

    /// @notice List of all supporting Dexes.
    /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1
    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {
        Types.Market storage market = markets[marketId];
        if (poolIndex == 0) {
            market.pool0Insurance = market.pool0Insurance.sub(amount);
            (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));
            return;
        }
        market.pool1Insurance = market.pool1Insurance.sub(amount);
        (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this))));
    }

    function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {
        supportDexs[dex] = support;
    }

    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){
        taxes[marketId][token][index] = tax;
    }

    function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {
        Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];
        OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade);
    }

    function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {
        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());
        require(closeHeld <= trade.held, "CBH");
    }

    function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {
        require(held != 0 && lastBlockNumber != block.number && OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0");
    }

    modifier onlySupportDex(bytes memory dexData) {
        require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");
        _;
    }
}.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;

pragma experimental ABIEncoderV2;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "./OpenLevInterface.sol";
import "./Types.sol";
import "./Adminable.sol";
import "./DelegateInterface.sol";
import "./ControllerInterface.sol";
import "./IWETH.sol";
import "./XOLEInterface.sol";
import "./Types.sol";
import "./OpenLevV1Lib.sol";

/// @title OpenLeverage margin trade logic
/// @author OpenLeverage
/// @notice Use this contract for margin trade.
/// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE.
contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {
    using SafeMath for uint;
    using TransferHelper for IERC20;
    using DexData for bytes;

    constructor ()
    {
    }

    /// @notice initialize proxy contract
    /// @dev This function is not supposed to call multiple times. All configs can be set through other functions.
    /// @param _controller Address of contract ControllerDelegator.
    /// @param _dexAggregator contract DexAggregatorDelegator.
    /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens.
    /// @param _wETH Address of wrapped native coin.
    /// @param _xOLE Address of XOLEDelegator.
    /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol.
    function initialize(
        address _controller,
        DexAggregatorInterface _dexAggregator,
        address[] memory depositTokens,
        address _wETH,
        address _xOLE,
        uint8[] memory _supportDexs
    ) public {
        depositTokens;
        require(msg.sender == admin, "NAD");
        addressConfig.controller = _controller;
        addressConfig.dexAggregator = _dexAggregator;
        addressConfig.wETH = _wETH;
        addressConfig.xOLE = _xOLE;
        for (uint i = 0; i < _supportDexs.length; i++) {
            supportDexs[_supportDexs[i]] = true;
        }
        OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig);
    }

    /// @notice Create new trading pair.
    /// @dev This function is typically called by ControllerDelegator.
    /// @param pool0 Contract LpoolDelegator, lending pool of token0.
    /// @param pool1 Contract LpoolDelegator, lending pool of token1.
    /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value.
    /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens.
    /// @return The new created pair ID.
    function addMarket(
        LPoolInterface pool0,
        LPoolInterface pool1,
        uint16 marginLimit,
        bytes memory dexData
    ) external override returns (uint16) {
        uint16 marketId = numPairs;
        OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);
        numPairs ++;
        return marketId;
    }

    /// @notice Margin trade or just add more deposit tokens.
    /// @dev To support token with tax and reward. Stores share of all token balances of this contract.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param depositToken Token to deposit. False for token0, true for token1.
    /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported.
    /// @param borrow Amount of ERC20 to borrow from the short token pool.
    /// @param minBuyAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function marginTrade(
        uint16 marketId,
        bool longToken,
        bool depositToken,
        uint deposit,
        uint borrow,
        uint minBuyAmount,
        bytes memory dexData
    ) external payable override nonReentrant onlySupportDex(dexData) {
        Types.TradeVars memory tv;
        Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);
        verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);
        (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);

        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);
        }

        tv.totalHeld = totalHelds[address(vars.buyToken)];
        tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;

        deposit = transferIn(msg.sender, tv.depositErc20, deposit);

        // Borrow
        uint borrowed;
        if (borrow > 0) {
            {
                uint balance = vars.sellToken.balanceOf(address(this));
                vars.sellPool.borrowBehalf(msg.sender, borrow);
                borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);
            }

            if (depositToken == longToken){
                (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);
                tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));
            }else{
                tv.borrowValue = borrow;
            }
        }

        require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) > vars.marginLimit, "MAM");
        tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);
        tv.depositAfterFees = deposit.sub(tv.fees);
        tv.dexDetail = dexData.toDexDetail();

        if (depositToken == longToken ){
            if (borrowed > 0){
                tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);
                tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);
            }
            tv.newHeld = tv.newHeld.add(tv.depositAfterFees);
        }else{
            tv.tradeSize = tv.depositAfterFees.add(borrowed);
            tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);
            tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);
        }

        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);
        trade.held = trade.held.add(tv.newHeld);
        trade.depositToken = depositToken;
        trade.deposited = trade.deposited.add(tv.depositAfterFees);
        trade.lastBlockNum = uint128(block.number);

        totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);

        require(OpenLevV1Lib.isPositionHealthy(
                msg.sender,
                true,
                OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),
                vars,
                dexData
            ), "PNH");

        emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail);
    }

    /// @notice Close trade by shares.
    /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param closeHeld Amount of shares to close.
    /// @param minOrMaxAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);

        //verify
        verifyCloseBefore(trade, marketVars, closeHeld, dexData);

        uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        Types.CloseTradeVars memory closeTradeVars;
        closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);
        closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);
        closeTradeVars.isPartialClose = closeHeld != trade.held;
        closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);
        closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        closeTradeVars.dexDetail = dexData.toDexDetail();

        //partial close
        if (closeTradeVars.isPartialClose) {
            closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);
            closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);
            trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);
        } else {
            closeTradeVars.depositDecrease = trade.deposited;
        }

        if (trade.depositToken != longToken) {
            minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);
            closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;
            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);

            closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);
            doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);
        } else {
            uint balance = marketVars.buyToken.balanceOf(address(this));
            minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);
            closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);
            closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);
            closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);
            require(marketVars.sellToken.balanceOf(address(this)) >= closeTradeVars.depositReturn, "ISB");
            doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);
        }

        uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));
        require(repayed >= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");

        if (!closeTradeVars.isPartialClose) {
            delete activeTrades[msg.sender][marketId][longToken];
        }else{
            trade.held = trade.held.sub(closeHeld);
            trade.lastBlockNum = uint128(block.number);
        }

        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);

        closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,
            closeTradeVars.token0Price, closeTradeVars.dexDetail);
    }

    /// @notice Liquidate if trade below margin limit.
    /// @dev For trades without sufficient funds to repay, use insurance.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param minBuy Slippage for Dex trading.
    /// @param maxSell Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade memory trade = activeTrades[owner][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());
        uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);
        require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");

        Types.LiquidateVars memory liquidateVars;
        liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);
        if (liquidateVars.penalty > 0) {
            doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);
        }
        liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);
        liquidateVars.dexDetail = dexData.toDexDetail();
        liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);
        liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        liquidateVars.marketId = marketId;
        liquidateVars.longToken = longToken;

        bool buySuccess;
        bytes memory sellAmountData;
        if (longToken == trade.depositToken) {
            maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);
            marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);
            (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(
                abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],
                taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)
            );
        }

        if (buySuccess) {
            {
                uint temp;
                assembly {
                    temp := mload(add(sellAmountData, 0x20))
                }
                liquidateVars.sellAmount = temp;
            }

            liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);
            marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
            liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);
            doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);
        } else {
            liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;
            liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);
            if (liquidateVars.receiveAmount >= liquidateVars.borrowed) {
                // fail if buy failed but sell succeeded
                require (longToken != trade.depositToken, "PH");
                marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
                liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);
                doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);
            } else {
                liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);
                liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);
                marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);
            }
        }

        liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);
        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);

        emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,
            trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);

        delete activeTrades[owner][marketId][longToken];
    }

    function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {
        return open == longToken ?
        Types.MarketVars(
            market.pool1,
            market.pool0,
            IERC20(market.token1),
            IERC20(market.token0),
            IERC20(market.token1).balanceOf(address(this)),
            IERC20(market.token0).balanceOf(address(this)),
            market.pool1Insurance,
            market.pool0Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs) :
        Types.MarketVars(
            market.pool0,
            market.pool1,
            IERC20(market.token0),
            IERC20(market.token1),
            IERC20(market.token0).balanceOf(address(this)),
            IERC20(market.token1).balanceOf(address(this)),
            market.pool0Insurance,
            market.pool1Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs);
    }

    /// @notice Get ratios of deposited token value to borrowed token value.
    /// @dev Caluclate ratio with current price and twap price.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param dexData Index and fee rate for the trading Dex.
    /// @return current Margin ratio calculated using current price.
    /// @return cAvg Margin ratio calculated using twap price.
    /// @return hAvg Margin ratio calculated using last recorded twap price.
    /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value.
    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {
        Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);
        limit = vars.marginLimit;
        (current, cAvg, hAvg,,) =
        OpenLevV1Lib.marginRatio(
            owner,
            activeTrades[owner][marketId][longToken].held,
            address(vars.sellToken),
            address(vars.buyToken),
            vars.buyPool,
            false,
            dexData
        );
    }

    /// @notice Check if a price update is required on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){
        Types.Market memory market = markets[marketId];
        return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData);
    }

    /// @notice Update price on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function updatePrice(uint16 marketId, bytes memory dexData) external override {
        OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData);
    }

    /// @notice List of all supporting Dexes.
    function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){
        return markets[marketId].dexs;
    }

    function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {
        Types.Market storage market = markets[marketId];
        uint needed = totalRepayment.sub(remaining);
        needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);
        maxCanRepayAmount = totalRepayment;
        if (longToken) {
            if (market.pool0Insurance >= needed) {
                market.pool0Insurance = market.pool0Insurance - needed;
                totalHelds[token] = totalHelds[token].sub(needed);
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);
                market.pool0Insurance = 0;
            }
        } else {
            if (market.pool1Insurance >= needed) {
                market.pool1Insurance = market.pool1Insurance - needed;
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);
                market.pool1Insurance = 0;
            }
        }
    }

    function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {
        // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);
        Types.Market storage market = markets[marketId];
        uint defaultFees = tradeSize.mul(market.feesRate).div(10000);
        uint newFees = defaultFees;
        // if trader holds more xOLE, then should enjoy trading discount.
        if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) > calculateConfig.feesDiscountThreshold) {
            newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));
        }
        // if trader update price, then should enjoy trading discount.
        if (market.priceUpdater == trader) {
            newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));
        }
        uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);
        IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));

        newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);
        if (token == market.token1) {
            market.pool1Insurance = market.pool1Insurance.add(newInsurance);
        } else {
            market.pool0Insurance = market.pool0Insurance.add(newInsurance);
        }

        totalHelds[token] = totalHelds[token].add(newInsurance);
        return newFees;
    }

    function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){
        if (sellAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);
            buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);
        }
    }

    function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){
        if (buyAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);
            sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);
        }
    }

    /// @dev All credited on this contract and share with all token holder if any rewards for the transfer.
    function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {
        return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount);
    }

    /// @dev All credited on "to" if any taxes for the transfer.
    function doTransferOut(address to, IERC20 token, uint amount) internal {
        OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount);
    }

    /*** Admin Functions ***/
    function setCalculateConfig(uint16 defaultFeesRate,
        uint8 insuranceRatio,
        uint16 defaultMarginLimit,
        uint16 priceDiffientRatio,
        uint16 updatePriceDiscount,
        uint16 feesDiscount,
        uint128 feesDiscountThreshold,
        uint16 penaltyRatio,
        uint8 maxLiquidationPriceDiffientRatio,
        uint16 twapDuration) external override onlyAdmin() {
        OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,
            feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);
        emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration);
    }

    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {
        OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);
        emit NewAddressConfig(controller, address(dexAggregator));
    }

    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {
        OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);
        emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs);
    }

    /// @notice List of all supporting Dexes.
    /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1
    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {
        Types.Market storage market = markets[marketId];
        if (poolIndex == 0) {
            market.pool0Insurance = market.pool0Insurance.sub(amount);
            (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));
            return;
        }
        market.pool1Insurance = market.pool1Insurance.sub(amount);
        (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this))));
    }

    function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {
        supportDexs[dex] = support;
    }

    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){
        taxes[marketId][token][index] = tax;
    }

    function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {
        Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];
        OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade);
    }

    function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {
        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());
        require(closeHeld <= trade.held, "CBH");
    }

    function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {
        require(held != 0 && lastBlockNumber != block.number && OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0");
    }

    modifier onlySupportDex(bytes memory dexData) {
        require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");
        _;
    }
}".
Ideas: " 1".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-24-08 18:27:57 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-24-08 18:27:57 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 13711
completion_tokens: 986
total_tokens: 14697
cost: $-1.000000


[2024-24-08 18:27:57 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;

pragma experimental ABIEncoderV2;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "./OpenLevInterface.sol";
import "./Types.sol";
import "./Adminable.sol";
import "./DelegateInterface.sol";
import "./ControllerInterface.sol";
import "./IWETH.sol";
import "./XOLEInterface.sol";
import "./Types.sol";
import "./OpenLevV1Lib.sol";

/// @title OpenLeverage margin trade logic
/// @author OpenLeverage
/// @notice Use this contract for margin trade.
/// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE.
contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {
    using SafeMath for uint;
    using TransferHelper for IERC20;
    using DexData for bytes;

    constructor ()
    {
    }

    /// @notice initialize proxy contract
    /// @dev This function is not supposed to call multiple times. All configs can be set through other functions.
    /// @param _controller Address of contract ControllerDelegator.
    /// @param _dexAggregator contract DexAggregatorDelegator.
    /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens.
    /// @param _wETH Address of wrapped native coin.
    /// @param _xOLE Address of XOLEDelegator.
    /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol.
    function initialize(
        address _controller,
        DexAggregatorInterface _dexAggregator,
        address[] memory depositTokens,
        address _wETH,
        address _xOLE,
        uint8[] memory _supportDexs
    ) public {
        depositTokens;
        require(msg.sender == admin, "NAD");
        addressConfig.controller = _controller;
        addressConfig.dexAggregator = _dexAggregator;
        addressConfig.wETH = _wETH;
        addressConfig.xOLE = _xOLE;
        for (uint i = 0; i < _supportDexs.length; i++) {
            supportDexs[_supportDexs[i]] = true;
        }
        OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig);
    }

    /// @notice Create new trading pair.
    /// @dev This function is typically called by ControllerDelegator.
    /// @param pool0 Contract LpoolDelegator, lending pool of token0.
    /// @param pool1 Contract LpoolDelegator, lending pool of token1.
    /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value.
    /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens.
    /// @return The new created pair ID.
    function addMarket(
        LPoolInterface pool0,
        LPoolInterface pool1,
        uint16 marginLimit,
        bytes memory dexData
    ) external override returns (uint16) {
        uint16 marketId = numPairs;
        OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);
        numPairs ++;
        return marketId;
    }

    /// @notice Margin trade or just add more deposit tokens.
    /// @dev To support token with tax and reward. Stores share of all token balances of this contract.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param depositToken Token to deposit. False for token0, true for token1.
    /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported.
    /// @param borrow Amount of ERC20 to borrow from the short token pool.
    /// @param minBuyAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function marginTrade(
        uint16 marketId,
        bool longToken,
        bool depositToken,
        uint deposit,
        uint borrow,
        uint minBuyAmount,
        bytes memory dexData
    ) external payable override nonReentrant onlySupportDex(dexData) {
        Types.TradeVars memory tv;
        Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);
        verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);
        (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);

        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);
        }

        tv.totalHeld = totalHelds[address(vars.buyToken)];
        tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;

        deposit = transferIn(msg.sender, tv.depositErc20, deposit);

        // Borrow
        uint borrowed;
        if (borrow > 0) {
            {
                uint balance = vars.sellToken.balanceOf(address(this));
                vars.sellPool.borrowBehalf(msg.sender, borrow);
                borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);
            }

            if (depositToken == longToken){
                (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);
                tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));
            }else{
                tv.borrowValue = borrow;
            }
        }

        require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) > vars.marginLimit, "MAM");
        tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);
        tv.depositAfterFees = deposit.sub(tv.fees);
        tv.dexDetail = dexData.toDexDetail();

        if (depositToken == longToken ){
            if (borrowed > 0){
                tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);
                tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);
            }
            tv.newHeld = tv.newHeld.add(tv.depositAfterFees);
        }else{
            tv.tradeSize = tv.depositAfterFees.add(borrowed);
            tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);
            tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);
        }

        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);
        trade.held = trade.held.add(tv.newHeld);
        trade.depositToken = depositToken;
        trade.deposited = trade.deposited.add(tv.depositAfterFees);
        trade.lastBlockNum = uint128(block.number);

        totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);

        require(OpenLevV1Lib.isPositionHealthy(
                msg.sender,
                true,
                OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),
                vars,
                dexData
            ), "PNH");

        emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail);
    }

    /// @notice Close trade by shares.
    /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param closeHeld Amount of shares to close.
    /// @param minOrMaxAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);

        //verify
        verifyCloseBefore(trade, marketVars, closeHeld, dexData);

        uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        Types.CloseTradeVars memory closeTradeVars;
        closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);
        closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);
        closeTradeVars.isPartialClose = closeHeld != trade.held;
        closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);
        closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        closeTradeVars.dexDetail = dexData.toDexDetail();

        //partial close
        if (closeTradeVars.isPartialClose) {
            closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);
            closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);
            trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);
        } else {
            closeTradeVars.depositDecrease = trade.deposited;
        }

        if (trade.depositToken != longToken) {
            minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);
            closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;
            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);

            closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);
            doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);
        } else {
            uint balance = marketVars.buyToken.balanceOf(address(this));
            minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);
            closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);
            closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);
            closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);
            require(marketVars.sellToken.balanceOf(address(this)) >= closeTradeVars.depositReturn, "ISB");
            doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);
        }

        uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));
        require(repayed >= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");

        if (!closeTradeVars.isPartialClose) {
            delete activeTrades[msg.sender][marketId][longToken];
        }else{
            trade.held = trade.held.sub(closeHeld);
            trade.lastBlockNum = uint128(block.number);
        }

        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);

        closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,
            closeTradeVars.token0Price, closeTradeVars.dexDetail);
    }

    /// @notice Liquidate if trade below margin limit.
    /// @dev For trades without sufficient funds to repay, use insurance.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param minBuy Slippage for Dex trading.
    /// @param maxSell Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade memory trade = activeTrades[owner][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());
        uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);
        require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");

        Types.LiquidateVars memory liquidateVars;
        liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);
        if (liquidateVars.penalty > 0) {
            doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);
        }
        liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);
        liquidateVars.dexDetail = dexData.toDexDetail();
        liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);
        liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        liquidateVars.marketId = marketId;
        liquidateVars.longToken = longToken;

        bool buySuccess;
        bytes memory sellAmountData;
        if (longToken == trade.depositToken) {
            maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);
            marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);
            (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(
                abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],
                taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)
            );
        }

        if (buySuccess) {
            {
                uint temp;
                assembly {
                    temp := mload(add(sellAmountData, 0x20))
                }
                liquidateVars.sellAmount = temp;
            }

            liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);
            marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
            liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);
            doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);
        } else {
            liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;
            liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);
            if (liquidateVars.receiveAmount >= liquidateVars.borrowed) {
                // fail if buy failed but sell succeeded
                require (longToken != trade.depositToken, "PH");
                marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
                liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);
                doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);
            } else {
                liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);
                liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);
                marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);
            }
        }

        liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);
        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);

        emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,
            trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);

        delete activeTrades[owner][marketId][longToken];
    }

    function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {
        return open == longToken ?
        Types.MarketVars(
            market.pool1,
            market.pool0,
            IERC20(market.token1),
            IERC20(market.token0),
            IERC20(market.token1).balanceOf(address(this)),
            IERC20(market.token0).balanceOf(address(this)),
            market.pool1Insurance,
            market.pool0Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs) :
        Types.MarketVars(
            market.pool0,
            market.pool1,
            IERC20(market.token0),
            IERC20(market.token1),
            IERC20(market.token0).balanceOf(address(this)),
            IERC20(market.token1).balanceOf(address(this)),
            market.pool0Insurance,
            market.pool1Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs);
    }

    /// @notice Get ratios of deposited token value to borrowed token value.
    /// @dev Caluclate ratio with current price and twap price.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param dexData Index and fee rate for the trading Dex.
    /// @return current Margin ratio calculated using current price.
    /// @return cAvg Margin ratio calculated using twap price.
    /// @return hAvg Margin ratio calculated using last recorded twap price.
    /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value.
    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {
        Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);
        limit = vars.marginLimit;
        (current, cAvg, hAvg,,) =
        OpenLevV1Lib.marginRatio(
            owner,
            activeTrades[owner][marketId][longToken].held,
            address(vars.sellToken),
            address(vars.buyToken),
            vars.buyPool,
            false,
            dexData
        );
    }

    /// @notice Check if a price update is required on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){
        Types.Market memory market = markets[marketId];
        return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData);
    }

    /// @notice Update price on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function updatePrice(uint16 marketId, bytes memory dexData) external override {
        OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData);
    }

    /// @notice List of all supporting Dexes.
    function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){
        return markets[marketId].dexs;
    }

    function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {
        Types.Market storage market = markets[marketId];
        uint needed = totalRepayment.sub(remaining);
        needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);
        maxCanRepayAmount = totalRepayment;
        if (longToken) {
            if (market.pool0Insurance >= needed) {
                market.pool0Insurance = market.pool0Insurance - needed;
                totalHelds[token] = totalHelds[token].sub(needed);
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);
                market.pool0Insurance = 0;
            }
        } else {
            if (market.pool1Insurance >= needed) {
                market.pool1Insurance = market.pool1Insurance - needed;
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);
                market.pool1Insurance = 0;
            }
        }
    }

    function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {
        // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);
        Types.Market storage market = markets[marketId];
        uint defaultFees = tradeSize.mul(market.feesRate).div(10000);
        uint newFees = defaultFees;
        // if trader holds more xOLE, then should enjoy trading discount.
        if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) > calculateConfig.feesDiscountThreshold) {
            newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));
        }
        // if trader update price, then should enjoy trading discount.
        if (market.priceUpdater == trader) {
            newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));
        }
        uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);
        IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));

        newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);
        if (token == market.token1) {
            market.pool1Insurance = market.pool1Insurance.add(newInsurance);
        } else {
            market.pool0Insurance = market.pool0Insurance.add(newInsurance);
        }

        totalHelds[token] = totalHelds[token].add(newInsurance);
        return newFees;
    }

    function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){
        if (sellAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);
            buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);
        }
    }

    function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){
        if (buyAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);
            sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);
        }
    }

    /// @dev All credited on this contract and share with all token holder if any rewards for the transfer.
    function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {
        return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount);
    }

    /// @dev All credited on "to" if any taxes for the transfer.
    function doTransferOut(address to, IERC20 token, uint amount) internal {
        OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount);
    }

    /*** Admin Functions ***/
    function setCalculateConfig(uint16 defaultFeesRate,
        uint8 insuranceRatio,
        uint16 defaultMarginLimit,
        uint16 priceDiffientRatio,
        uint16 updatePriceDiscount,
        uint16 feesDiscount,
        uint128 feesDiscountThreshold,
        uint16 penaltyRatio,
        uint8 maxLiquidationPriceDiffientRatio,
        uint16 twapDuration) external override onlyAdmin() {
        OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,
            feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);
        emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration);
    }

    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {
        OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);
        emit NewAddressConfig(controller, address(dexAggregator));
    }

    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {
        OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);
        emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs);
    }

    /// @notice List of all supporting Dexes.
    /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1
    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {
        Types.Market storage market = markets[marketId];
        if (poolIndex == 0) {
            market.pool0Insurance = market.pool0Insurance.sub(amount);
            (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));
            return;
        }
        market.pool1Insurance = market.pool1Insurance.sub(amount);
        (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this))));
    }

    function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {
        supportDexs[dex] = support;
    }

    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){
        taxes[marketId][token][index] = tax;
    }

    function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {
        Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];
        OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade);
    }

    function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {
        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());
        require(closeHeld <= trade.held, "CBH");
    }

    function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {
        require(held != 0 && lastBlockNumber != block.number && OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0");
    }

    modifier onlySupportDex(bytes memory dexData) {
        require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");
        _;
    }
}.]

### VULNERABILITY: Reentrancy Attack
```
DETAILED DESCRIPTION: The contract uses the `nonReentrant` modifier from the `ReentrancyGuard` contract to protect against reentrancy attacks. However, there are several functions, such as `marginTrade`, `closeTrade`, and `liquidate`, that involve external calls (like `flashSell`, `flashBuy`, and `doTransferOut`). If any of these external calls are not properly protected or if they call back into the contract, it could lead to a reentrancy vulnerability.

RECOMMENDED MITIGATION: Ensure that all external calls are made after all state changes are completed. Additionally, consider using checks-effects-interactions pattern to minimize the risk of reentrancy. Review all external calls to ensure they cannot lead back into the contract in a way that could exploit the state.
```

### VULNERABILITY: Arithmetic Underflow/Overflow
```
DETAILED DESCRIPTION: Although the contract uses `SafeMath` for arithmetic operations, there are still places where arithmetic could potentially lead to underflows or overflows, particularly in calculations involving user inputs or external data. For example, the calculation of `borrowValue` and `fees` could lead to unexpected results if not properly validated.

RECOMMENDED MITIGATION: Ensure that all user inputs are validated before performing arithmetic operations. Additionally, consider using `SafeMath` consistently throughout the contract to prevent any potential underflow or overflow issues.
```

### VULNERABILITY: Lack of Input Validation
```
DETAILED DESCRIPTION: The contract does not perform sufficient validation on inputs in several functions, such as `marginTrade`, `closeTrade`, and `liquidate`. For instance, there is no check to ensure that the `deposit`, `borrow`, or `closeHeld` amounts are greater than zero, which could lead to unexpected behavior or state corruption.

RECOMMENDED MITIGATION: Implement input validation checks to ensure that all parameters are within acceptable ranges and are not zero where applicable. This will help prevent unexpected behavior and ensure the integrity of the contract's state.
```

### VULNERABILITY: Improper Access Control
```
DETAILED DESCRIPTION: The contract relies on the `onlyAdmin` modifier for several administrative functions, but there is no mechanism to ensure that the `admin` address is secure or that it cannot be compromised. If the admin key is compromised, an attacker could manipulate critical contract parameters.

RECOMMENDED MITIGATION: Consider implementing a multi-signature wallet for administrative functions to enhance security. Additionally, provide a mechanism for the admin to be changed or revoked in case of a security breach.
```

### VULNERABILITY: Price Manipulation
```
DETAILED DESCRIPTION: The contract allows for price updates based on external data sources (e.g., `dexAggregator`). If the price feed is manipulated or if the contract does not properly validate the price data, it could lead to significant financial losses for users.

RECOMMENDED MITIGATION: Implement checks to validate the price data received from external sources. Consider using oracles with a reputation system or multiple data sources to ensure the integrity of the price data.
```

### VULNERABILITY: Insufficient Event Emission
```
DETAILED DESCRIPTION: The contract emits events for certain actions (like `MarginTrade`, `TradeClosed`, and `Liquidation`), but there are other critical actions (like state changes in `feesAndInsurance` and `reduceInsurance`) that do not emit events. This could lead to difficulties in tracking contract activity and debugging issues.

RECOMMENDED MITIGATION: Ensure that all significant state changes and actions emit appropriate events. This will enhance transparency and allow for better monitoring of contract activity.
```

### VULNERABILITY: Gas Limit Issues
```
DETAILED DESCRIPTION: The contract contains loops that iterate over arrays (e.g., in the `initialize` function for `_supportDexs`). If the array size is large, it could lead to exceeding the gas limit during execution, causing transactions to fail.

RECOMMENDED MITIGATION: Limit the size of input arrays or implement checks to ensure that the contract can handle the expected number of iterations without exceeding gas limits. Consider using alternative data structures that do not require extensive looping.
```

### VULNERABILITY: Potential for Front-Running
```
DETAILED DESCRIPTION: The contract allows users to perform trades based on market conditions, but it does not implement any mechanisms to prevent front-running attacks. An attacker could observe pending transactions and execute their own transactions to exploit the price changes.

RECOMMENDED MITIGATION: Implement measures such as commit-reveal schemes or time-locks to mitigate the risk of front-running. This will help ensure that users cannot exploit the timing of transactions to gain an unfair advantage.
```

<INFO> Analysis Complete.

[2024-24-08 18:27:57 INFO] **[Seminar Conclusion]**:

 ### VULNERABILITY: Reentrancy Attack
```
DETAILED DESCRIPTION: The contract uses the `nonReentrant` modifier from the `ReentrancyGuard` contract to protect against reentrancy attacks. However, there are several functions, such as `marginTrade`, `closeTrade`, and `liquidate`, that involve external calls (like `flashSell`, `flashBuy`, and `doTransferOut`). If any of these external calls are not properly protected or if they call back into the contract, it could lead to a reentrancy vulnerability.

RECOMMENDED MITIGATION: Ensure that all external calls are made after all state changes are completed. Additionally, consider using checks-effects-interactions pattern to minimize the risk of reentrancy. Review all external calls to ensure they cannot lead back into the contract in a way that could exploit the state.
```

### VULNERABILITY: Arithmetic Underflow/Overflow
```
DETAILED DESCRIPTION: Although the contract uses `SafeMath` for arithmetic operations, there are still places where arithmetic could potentially lead to underflows or overflows, particularly in calculations involving user inputs or external data. For example, the calculation of `borrowValue` and `fees` could lead to unexpected results if not properly validated.

RECOMMENDED MITIGATION: Ensure that all user inputs are validated before performing arithmetic operations. Additionally, consider using `SafeMath` consistently throughout the contract to prevent any potential underflow or overflow issues.
```

### VULNERABILITY: Lack of Input Validation
```
DETAILED DESCRIPTION: The contract does not perform sufficient validation on inputs in several functions, such as `marginTrade`, `closeTrade`, and `liquidate`. For instance, there is no check to ensure that the `deposit`, `borrow`, or `closeHeld` amounts are greater than zero, which could lead to unexpected behavior or state corruption.

RECOMMENDED MITIGATION: Implement input validation checks to ensure that all parameters are within acceptable ranges and are not zero where applicable. This will help prevent unexpected behavior and ensure the integrity of the contract's state.
```

### VULNERABILITY: Improper Access Control
```
DETAILED DESCRIPTION: The contract relies on the `onlyAdmin` modifier for several administrative functions, but there is no mechanism to ensure that the `admin` address is secure or that it cannot be compromised. If the admin key is compromised, an attacker could manipulate critical contract parameters.

RECOMMENDED MITIGATION: Consider implementing a multi-signature wallet for administrative functions to enhance security. Additionally, provide a mechanism for the admin to be changed or revoked in case of a security breach.
```

### VULNERABILITY: Price Manipulation
```
DETAILED DESCRIPTION: The contract allows for price updates based on external data sources (e.g., `dexAggregator`). If the price feed is manipulated or if the contract does not properly validate the price data, it could lead to significant financial losses for users.

RECOMMENDED MITIGATION: Implement checks to validate the price data received from external sources. Consider using oracles with a reputation system or multiple data sources to ensure the integrity of the price data.
```

### VULNERABILITY: Insufficient Event Emission
```
DETAILED DESCRIPTION: The contract emits events for certain actions (like `MarginTrade`, `TradeClosed`, and `Liquidation`), but there are other critical actions (like state changes in `feesAndInsurance` and `reduceInsurance`) that do not emit events. This could lead to difficulties in tracking contract activity and debugging issues.

RECOMMENDED MITIGATION: Ensure that all significant state changes and actions emit appropriate events. This will enhance transparency and allow for better monitoring of contract activity.
```

### VULNERABILITY: Gas Limit Issues
```
DETAILED DESCRIPTION: The contract contains loops that iterate over arrays (e.g., in the `initialize` function for `_supportDexs`). If the array size is large, it could lead to exceeding the gas limit during execution, causing transactions to fail.

RECOMMENDED MITIGATION: Limit the size of input arrays or implement checks to ensure that the contract can handle the expected number of iterations without exceeding gas limits. Consider using alternative data structures that do not require extensive looping.
```

### VULNERABILITY: Potential for Front-Running
```
DETAILED DESCRIPTION: The contract allows users to perform trades based on market conditions, but it does not implement any mechanisms to prevent front-running attacks. An attacker could observe pending transactions and execute their own transactions to exploit the price changes.

RECOMMENDED MITIGATION: Implement measures such as commit-reveal schemes or time-locks to mitigate the risk of front-running. This will help ensure that users cannot exploit the timing of transactions to gain an unfair advantage.
```

<INFO> Analysis Complete.

[2024-24-08 18:27:57 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-24-08 18:27:57 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.7.6; pragma experimental ABIEncoderV2; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import "./OpenLevInterface.sol"; import "./Types.sol"; import "./Adminable.sol"; import "./DelegateInterface.sol"; import "./ControllerInterface.sol"; import "./IWETH.sol"; import "./XOLEInterface.sol"; import "./Types.sol"; import "./OpenLevV1Lib.sol"; /// @title OpenLeverage margin trade logic /// @author OpenLeverage /// @notice Use this contract for margin trade. /// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE. contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {     using SafeMath for uint;     using TransferHelper for IERC20;     using DexData for bytes; constructor () { }  /// @notice initialize proxy contract /// @dev This function is not supposed to call multiple times. All configs can be set through other functions. /// @param _controller Address of contract ControllerDelegator. /// @param _dexAggregator contract DexAggregatorDelegator. /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens. /// @param _wETH Address of wrapped native coin. /// @param _xOLE Address of XOLEDelegator. /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol. function initialize(     address _controller,     DexAggregatorInterface _dexAggregator,     address[] memory depositTokens,     address _wETH,     address _xOLE,     uint8[] memory _supportDexs ) public {     depositTokens;     require(msg.sender == admin, "NAD");     addressConfig.controller = _controller;     addressConfig.dexAggregator = _dexAggregator;     addressConfig.wETH = _wETH;     addressConfig.xOLE = _xOLE;     for (uint i = 0; i &lt; _supportDexs.length; i++) {         supportDexs[_supportDexs[i]] = true;     }     OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig); }  /// @notice Create new trading pair. /// @dev This function is typically called by ControllerDelegator. /// @param pool0 Contract LpoolDelegator, lending pool of token0. /// @param pool1 Contract LpoolDelegator, lending pool of token1. /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value. /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens. /// @return The new created pair ID. function addMarket(     LPoolInterface pool0,     LPoolInterface pool1,     uint16 marginLimit,     bytes memory dexData ) external override returns (uint16) {     uint16 marketId = numPairs;     OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);     numPairs ++;     return marketId; }  /// @notice Margin trade or just add more deposit tokens. /// @dev To support token with tax and reward. Stores share of all token balances of this contract. /// @param longToken Token to long. False for token0, true for token1. /// @param depositToken Token to deposit. False for token0, true for token1. /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported. /// @param borrow Amount of ERC20 to borrow from the short token pool. /// @param minBuyAmount Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function marginTrade(     uint16 marketId,     bool longToken,     bool depositToken,     uint deposit,     uint borrow,     uint minBuyAmount,     bytes memory dexData ) external payable override nonReentrant onlySupportDex(dexData) {     Types.TradeVars memory tv;     Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);     verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);     (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);      if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);     }      tv.totalHeld = totalHelds[address(vars.buyToken)];     tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;      deposit = transferIn(msg.sender, tv.depositErc20, deposit);      // Borrow     uint borrowed;     if (borrow &gt; 0) {         {             uint balance = vars.sellToken.balanceOf(address(this));             vars.sellPool.borrowBehalf(msg.sender, borrow);             borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);         }          if (depositToken == longToken){             (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);             tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));         }else{             tv.borrowValue = borrow;         }     }      require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) &gt; vars.marginLimit, "MAM");     tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);     tv.depositAfterFees = deposit.sub(tv.fees);     tv.dexDetail = dexData.toDexDetail();      if (depositToken == longToken ){         if (borrowed &gt; 0){             tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);             tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);         }         tv.newHeld = tv.newHeld.add(tv.depositAfterFees);     }else{         tv.tradeSize = tv.depositAfterFees.add(borrowed);         tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);         tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);     }      Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];     tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);     trade.held = trade.held.add(tv.newHeld);     trade.depositToken = depositToken;     trade.deposited = trade.deposited.add(tv.depositAfterFees);     trade.lastBlockNum = uint128(block.number);      totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);      require(OpenLevV1Lib.isPositionHealthy(             msg.sender,             true,             OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),             vars,             dexData         ), "PNH");      emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail); }  /// @notice Close trade by shares. /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed. /// @param longToken Token to long. False for token0, true for token1. /// @param closeHeld Amount of shares to close. /// @param minOrMaxAmount Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {     Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];     Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);      //verify     verifyCloseBefore(trade, marketVars, closeHeld, dexData);      uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);      Types.CloseTradeVars memory closeTradeVars;     closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);     closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);     closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);     closeTradeVars.isPartialClose = closeHeld != trade.held;     closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);     closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);     closeTradeVars.dexDetail = dexData.toDexDetail();      //partial close     if (closeTradeVars.isPartialClose) {         closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);         closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);         trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);     } else {         closeTradeVars.depositDecrease = trade.deposited;     }      if (trade.depositToken != longToken) {         minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);         closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);         require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");          closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;         marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);          closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);         doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);     } else {         uint balance = marketVars.buyToken.balanceOf(address(this));         minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);         closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);         closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);         require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");          marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);         closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);         require(marketVars.sellToken.balanceOf(address(this)) &gt;= closeTradeVars.depositReturn, "ISB");         doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);     }      uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));     require(repayed &gt;= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");      if (!closeTradeVars.isPartialClose) {         delete activeTrades[msg.sender][marketId][longToken];     }else{         trade.held = trade.held.sub(closeHeld);         trade.lastBlockNum = uint128(block.number);     }      totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);      closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);     if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);     }      emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,         closeTradeVars.token0Price, closeTradeVars.dexDetail); }  /// @notice Liquidate if trade below margin limit. /// @dev For trades without sufficient funds to repay, use insurance. /// @param owner Owner of the trade to liquidate. /// @param longToken Token to long. False for token0, true for token1. /// @param minBuy Slippage for Dex trading. /// @param maxSell Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {     Types.Trade memory trade = activeTrades[owner][marketId][longToken];     Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);     if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);     }      verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());     uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);      (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);     require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");      Types.LiquidateVars memory liquidateVars;     liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);     liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);     if (liquidateVars.penalty &gt; 0) {         doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);     }     liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);     liquidateVars.dexDetail = dexData.toDexDetail();     liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);     liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);     liquidateVars.marketId = marketId;     liquidateVars.longToken = longToken;      bool buySuccess;     bytes memory sellAmountData;     if (longToken == trade.depositToken) {         maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);         marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);         (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(             abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],             taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)         );     }      if (buySuccess) {         {             uint temp;             assembly {                 temp := mload(add(sellAmountData, 0x20))             }             liquidateVars.sellAmount = temp;         }          liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);         marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);         liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);         doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);     } else {         liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;         liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);         if (liquidateVars.receiveAmount &gt;= liquidateVars.borrowed) {             // fail if buy failed but sell succeeded             require (longToken != trade.depositToken, "PH");             marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);             liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);             doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);         } else {             liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);             liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);             marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);         }     }      liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);     totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);      emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,         trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);      delete activeTrades[owner][marketId][longToken]; }  function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {     return open == longToken ?     Types.MarketVars(         market.pool1,         market.pool0,         IERC20(market.token1),         IERC20(market.token0),         IERC20(market.token1).balanceOf(address(this)),         IERC20(market.token0).balanceOf(address(this)),         market.pool1Insurance,         market.pool0Insurance,         market.marginLimit,         market.priceDiffientRatio,         market.dexs) :     Types.MarketVars(         market.pool0,         market.pool1,         IERC20(market.token0),         IERC20(market.token1),         IERC20(market.token0).balanceOf(address(this)),         IERC20(market.token1).balanceOf(address(this)),         market.pool0Insurance,         market.pool1Insurance,         market.marginLimit,         market.priceDiffientRatio,         market.dexs); }  /// @notice Get ratios of deposited token value to borrowed token value. /// @dev Caluclate ratio with current price and twap price. /// @param owner Owner of the trade to liquidate. /// @param longToken Token to long. False for token0, true for token1. /// @param dexData Index and fee rate for the trading Dex. /// @return current Margin ratio calculated using current price. /// @return cAvg Margin ratio calculated using twap price. /// @return hAvg Margin ratio calculated using last recorded twap price. /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value. function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {     Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);     limit = vars.marginLimit;     (current, cAvg, hAvg,,) =     OpenLevV1Lib.marginRatio(         owner,         activeTrades[owner][marketId][longToken].held,         address(vars.sellToken),         address(vars.buyToken),         vars.buyPool,         false,         dexData     ); }  /// @notice Check if a price update is required on Dex. /// @param dexData Index and fee rate for the trading Dex. function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){     Types.Market memory market = markets[marketId];     return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData); }  /// @notice Update price on Dex. /// @param dexData Index and fee rate for the trading Dex. function updatePrice(uint16 marketId, bytes memory dexData) external override {     OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData); }  /// @notice List of all supporting Dexes. function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){     return markets[marketId].dexs; }  function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {     Types.Market storage market = markets[marketId];     uint needed = totalRepayment.sub(remaining);     needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);     maxCanRepayAmount = totalRepayment;     if (longToken) {         if (market.pool0Insurance &gt;= needed) {             market.pool0Insurance = market.pool0Insurance - needed;             totalHelds[token] = totalHelds[token].sub(needed);         } else {             maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);             maxCanRepayAmount = maxCanRepayAmount.add(remaining);             totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);             market.pool0Insurance = 0;         }     } else {         if (market.pool1Insurance &gt;= needed) {             market.pool1Insurance = market.pool1Insurance - needed;         } else {             maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);             maxCanRepayAmount = maxCanRepayAmount.add(remaining);             totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);             market.pool1Insurance = 0;         }     } }  function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {     // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);     Types.Market storage market = markets[marketId];     uint defaultFees = tradeSize.mul(market.feesRate).div(10000);     uint newFees = defaultFees;     // if trader holds more xOLE, then should enjoy trading discount.     if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) &gt; calculateConfig.feesDiscountThreshold) {         newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));     }     // if trader update price, then should enjoy trading discount.     if (market.priceUpdater == trader) {         newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));     }     uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);     IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));      newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);     if (token == market.token1) {         market.pool1Insurance = market.pool1Insurance.add(newInsurance);     } else {         market.pool0Insurance = market.pool0Insurance.add(newInsurance);     }      totalHelds[token] = totalHelds[token].add(newInsurance);     return newFees; }  function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){     if (sellAmount &gt; 0){         DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;         IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);         buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);     } }  function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){     if (buyAmount &gt; 0){         DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;         IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);         sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);     } }  /// @dev All credited on this contract and share with all token holder if any rewards for the transfer. function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {     return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount); }  /// @dev All credited on "to" if any taxes for the transfer. function doTransferOut(address to, IERC20 token, uint amount) internal {     OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount); }  /*** Admin Functions ***/ function setCalculateConfig(uint16 defaultFeesRate,     uint8 insuranceRatio,     uint16 defaultMarginLimit,     uint16 priceDiffientRatio,     uint16 updatePriceDiscount,     uint16 feesDiscount,     uint128 feesDiscountThreshold,     uint16 penaltyRatio,     uint8 maxLiquidationPriceDiffientRatio,     uint16 twapDuration) external override onlyAdmin() {     OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,         feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);     emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration); }  function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {     OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);     emit NewAddressConfig(controller, address(dexAggregator)); }  function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {     OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);     emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs); }  /// @notice List of all supporting Dexes. /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1 function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {     Types.Market storage market = markets[marketId];     if (poolIndex == 0) {         market.pool0Insurance = market.pool0Insurance.sub(amount);         (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));         return;     }     market.pool1Insurance = market.pool1Insurance.sub(amount);     (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this)))); }  function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {     supportDexs[dex] = support; }  function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){     taxes[marketId][token][index] = tax; }  function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {     Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];     OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade); }  function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {     verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());     require(closeHeld &lt;= trade.held, "CBH"); }  function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {     require(held != 0 &amp;&amp; lastBlockNumber != block.number &amp;&amp; OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0"); }  modifier onlySupportDex(bytes memory dexData) {     require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");     _; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-24-08 18:27:57 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.7.6; pragma experimental ABIEncoderV2; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import "./OpenLevInterface.sol"; import "./Types.sol"; import "./Adminable.sol"; import "./DelegateInterface.sol"; import "./ControllerInterface.sol"; import "./IWETH.sol"; import "./XOLEInterface.sol"; import "./Types.sol"; import "./OpenLevV1Lib.sol"; /// @title OpenLeverage margin trade logic /// @author OpenLeverage /// @notice Use this contract for margin trade. /// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE. contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {     using SafeMath for uint;     using TransferHelper for IERC20;     using DexData for bytes; constructor () { }  /// @notice initialize proxy contract /// @dev This function is not supposed to call multiple times. All configs can be set through other functions. /// @param _controller Address of contract ControllerDelegator. /// @param _dexAggregator contract DexAggregatorDelegator. /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens. /// @param _wETH Address of wrapped native coin. /// @param _xOLE Address of XOLEDelegator. /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol. function initialize(     address _controller,     DexAggregatorInterface _dexAggregator,     address[] memory depositTokens,     address _wETH,     address _xOLE,     uint8[] memory _supportDexs ) public {     depositTokens;     require(msg.sender == admin, "NAD");     addressConfig.controller = _controller;     addressConfig.dexAggregator = _dexAggregator;     addressConfig.wETH = _wETH;     addressConfig.xOLE = _xOLE;     for (uint i = 0; i &lt; _supportDexs.length; i++) {         supportDexs[_supportDexs[i]] = true;     }     OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig); }  /// @notice Create new trading pair. /// @dev This function is typically called by ControllerDelegator. /// @param pool0 Contract LpoolDelegator, lending pool of token0. /// @param pool1 Contract LpoolDelegator, lending pool of token1. /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value. /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens. /// @return The new created pair ID. function addMarket(     LPoolInterface pool0,     LPoolInterface pool1,     uint16 marginLimit,     bytes memory dexData ) external override returns (uint16) {     uint16 marketId = numPairs;     OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);     numPairs ++;     return marketId; }  /// @notice Margin trade or just add more deposit tokens. /// @dev To support token with tax and reward. Stores share of all token balances of this contract. /// @param longToken Token to long. False for token0, true for token1. /// @param depositToken Token to deposit. False for token0, true for token1. /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported. /// @param borrow Amount of ERC20 to borrow from the short token pool. /// @param minBuyAmount Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function marginTrade(     uint16 marketId,     bool longToken,     bool depositToken,     uint deposit,     uint borrow,     uint minBuyAmount,     bytes memory dexData ) external payable override nonReentrant onlySupportDex(dexData) {     Types.TradeVars memory tv;     Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);     verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);     (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);      if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);     }      tv.totalHeld = totalHelds[address(vars.buyToken)];     tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;      deposit = transferIn(msg.sender, tv.depositErc20, deposit);      // Borrow     uint borrowed;     if (borrow &gt; 0) {         {             uint balance = vars.sellToken.balanceOf(address(this));             vars.sellPool.borrowBehalf(msg.sender, borrow);             borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);         }          if (depositToken == longToken){             (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);             tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));         }else{             tv.borrowValue = borrow;         }     }      require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) &gt; vars.marginLimit, "MAM");     tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);     tv.depositAfterFees = deposit.sub(tv.fees);     tv.dexDetail = dexData.toDexDetail();      if (depositToken == longToken ){         if (borrowed &gt; 0){             tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);             tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);         }         tv.newHeld = tv.newHeld.add(tv.depositAfterFees);     }else{         tv.tradeSize = tv.depositAfterFees.add(borrowed);         tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);         tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);     }      Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];     tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);     trade.held = trade.held.add(tv.newHeld);     trade.depositToken = depositToken;     trade.deposited = trade.deposited.add(tv.depositAfterFees);     trade.lastBlockNum = uint128(block.number);      totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);      require(OpenLevV1Lib.isPositionHealthy(             msg.sender,             true,             OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),             vars,             dexData         ), "PNH");      emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail); }  /// @notice Close trade by shares. /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed. /// @param longToken Token to long. False for token0, true for token1. /// @param closeHeld Amount of shares to close. /// @param minOrMaxAmount Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {     Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];     Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);      //verify     verifyCloseBefore(trade, marketVars, closeHeld, dexData);      uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);      Types.CloseTradeVars memory closeTradeVars;     closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);     closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);     closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);     closeTradeVars.isPartialClose = closeHeld != trade.held;     closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);     closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);     closeTradeVars.dexDetail = dexData.toDexDetail();      //partial close     if (closeTradeVars.isPartialClose) {         closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);         closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);         trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);     } else {         closeTradeVars.depositDecrease = trade.deposited;     }      if (trade.depositToken != longToken) {         minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);         closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);         require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");          closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;         marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);          closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);         doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);     } else {         uint balance = marketVars.buyToken.balanceOf(address(this));         minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);         closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);         closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);         require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");          marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);         closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);         require(marketVars.sellToken.balanceOf(address(this)) &gt;= closeTradeVars.depositReturn, "ISB");         doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);     }      uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));     require(repayed &gt;= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");      if (!closeTradeVars.isPartialClose) {         delete activeTrades[msg.sender][marketId][longToken];     }else{         trade.held = trade.held.sub(closeHeld);         trade.lastBlockNum = uint128(block.number);     }      totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);      closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);     if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);     }      emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,         closeTradeVars.token0Price, closeTradeVars.dexDetail); }  /// @notice Liquidate if trade below margin limit. /// @dev For trades without sufficient funds to repay, use insurance. /// @param owner Owner of the trade to liquidate. /// @param longToken Token to long. False for token0, true for token1. /// @param minBuy Slippage for Dex trading. /// @param maxSell Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {     Types.Trade memory trade = activeTrades[owner][marketId][longToken];     Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);     if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);     }      verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());     uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);      (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);     require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");      Types.LiquidateVars memory liquidateVars;     liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);     liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);     if (liquidateVars.penalty &gt; 0) {         doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);     }     liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);     liquidateVars.dexDetail = dexData.toDexDetail();     liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);     liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);     liquidateVars.marketId = marketId;     liquidateVars.longToken = longToken;      bool buySuccess;     bytes memory sellAmountData;     if (longToken == trade.depositToken) {         maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);         marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);         (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(             abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],             taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)         );     }      if (buySuccess) {         {             uint temp;             assembly {                 temp := mload(add(sellAmountData, 0x20))             }             liquidateVars.sellAmount = temp;         }          liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);         marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);         liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);         doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);     } else {         liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;         liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);         if (liquidateVars.receiveAmount &gt;= liquidateVars.borrowed) {             // fail if buy failed but sell succeeded             require (longToken != trade.depositToken, "PH");             marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);             liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);             doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);         } else {             liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);             liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);             marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);         }     }      liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);     totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);      emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,         trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);      delete activeTrades[owner][marketId][longToken]; }  function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {     return open == longToken ?     Types.MarketVars(         market.pool1,         market.pool0,         IERC20(market.token1),         IERC20(market.token0),         IERC20(market.token1).balanceOf(address(this)),         IERC20(market.token0).balanceOf(address(this)),         market.pool1Insurance,         market.pool0Insurance,         market.marginLimit,         market.priceDiffientRatio,         market.dexs) :     Types.MarketVars(         market.pool0,         market.pool1,         IERC20(market.token0),         IERC20(market.token1),         IERC20(market.token0).balanceOf(address(this)),         IERC20(market.token1).balanceOf(address(this)),         market.pool0Insurance,         market.pool1Insurance,         market.marginLimit,         market.priceDiffientRatio,         market.dexs); }  /// @notice Get ratios of deposited token value to borrowed token value. /// @dev Caluclate ratio with current price and twap price. /// @param owner Owner of the trade to liquidate. /// @param longToken Token to long. False for token0, true for token1. /// @param dexData Index and fee rate for the trading Dex. /// @return current Margin ratio calculated using current price. /// @return cAvg Margin ratio calculated using twap price. /// @return hAvg Margin ratio calculated using last recorded twap price. /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value. function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {     Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);     limit = vars.marginLimit;     (current, cAvg, hAvg,,) =     OpenLevV1Lib.marginRatio(         owner,         activeTrades[owner][marketId][longToken].held,         address(vars.sellToken),         address(vars.buyToken),         vars.buyPool,         false,         dexData     ); }  /// @notice Check if a price update is required on Dex. /// @param dexData Index and fee rate for the trading Dex. function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){     Types.Market memory market = markets[marketId];     return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData); }  /// @notice Update price on Dex. /// @param dexData Index and fee rate for the trading Dex. function updatePrice(uint16 marketId, bytes memory dexData) external override {     OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData); }  /// @notice List of all supporting Dexes. function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){     return markets[marketId].dexs; }  function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {     Types.Market storage market = markets[marketId];     uint needed = totalRepayment.sub(remaining);     needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);     maxCanRepayAmount = totalRepayment;     if (longToken) {         if (market.pool0Insurance &gt;= needed) {             market.pool0Insurance = market.pool0Insurance - needed;             totalHelds[token] = totalHelds[token].sub(needed);         } else {             maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);             maxCanRepayAmount = maxCanRepayAmount.add(remaining);             totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);             market.pool0Insurance = 0;         }     } else {         if (market.pool1Insurance &gt;= needed) {             market.pool1Insurance = market.pool1Insurance - needed;         } else {             maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);             maxCanRepayAmount = maxCanRepayAmount.add(remaining);             totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);             market.pool1Insurance = 0;         }     } }  function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {     // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);     Types.Market storage market = markets[marketId];     uint defaultFees = tradeSize.mul(market.feesRate).div(10000);     uint newFees = defaultFees;     // if trader holds more xOLE, then should enjoy trading discount.     if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) &gt; calculateConfig.feesDiscountThreshold) {         newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));     }     // if trader update price, then should enjoy trading discount.     if (market.priceUpdater == trader) {         newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));     }     uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);     IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));      newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);     if (token == market.token1) {         market.pool1Insurance = market.pool1Insurance.add(newInsurance);     } else {         market.pool0Insurance = market.pool0Insurance.add(newInsurance);     }      totalHelds[token] = totalHelds[token].add(newInsurance);     return newFees; }  function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){     if (sellAmount &gt; 0){         DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;         IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);         buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);     } }  function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){     if (buyAmount &gt; 0){         DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;         IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);         sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);     } }  /// @dev All credited on this contract and share with all token holder if any rewards for the transfer. function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {     return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount); }  /// @dev All credited on "to" if any taxes for the transfer. function doTransferOut(address to, IERC20 token, uint amount) internal {     OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount); }  /*** Admin Functions ***/ function setCalculateConfig(uint16 defaultFeesRate,     uint8 insuranceRatio,     uint16 defaultMarginLimit,     uint16 priceDiffientRatio,     uint16 updatePriceDiscount,     uint16 feesDiscount,     uint128 feesDiscountThreshold,     uint16 penaltyRatio,     uint8 maxLiquidationPriceDiffientRatio,     uint16 twapDuration) external override onlyAdmin() {     OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,         feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);     emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration); }  function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {     OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);     emit NewAddressConfig(controller, address(dexAggregator)); }  function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {     OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);     emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs); }  /// @notice List of all supporting Dexes. /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1 function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {     Types.Market storage market = markets[marketId];     if (poolIndex == 0) {         market.pool0Insurance = market.pool0Insurance.sub(amount);         (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));         return;     }     market.pool1Insurance = market.pool1Insurance.sub(amount);     (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this)))); }  function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {     supportDexs[dex] = support; }  function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){     taxes[marketId][token][index] = tax; }  function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {     Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];     OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade); }  function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {     verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());     require(closeHeld &lt;= trade.held, "CBH"); }  function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {     require(held != 0 &amp;&amp; lastBlockNumber != block.number &amp;&amp; OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0"); }  modifier onlySupportDex(bytes memory dexData) {     require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");     _; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-24-08 18:27:57 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;

pragma experimental ABIEncoderV2;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "./OpenLevInterface.sol";
import "./Types.sol";
import "./Adminable.sol";
import "./DelegateInterface.sol";
import "./ControllerInterface.sol";
import "./IWETH.sol";
import "./XOLEInterface.sol";
import "./Types.sol";
import "./OpenLevV1Lib.sol";

/// @title OpenLeverage margin trade logic
/// @author OpenLeverage
/// @notice Use this contract for margin trade.
/// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE.
contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {
    using SafeMath for uint;
    using TransferHelper for IERC20;
    using DexData for bytes;

    constructor ()
    {
    }

    /// @notice initialize proxy contract
    /// @dev This function is not supposed to call multiple times. All configs can be set through other functions.
    /// @param _controller Address of contract ControllerDelegator.
    /// @param _dexAggregator contract DexAggregatorDelegator.
    /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens.
    /// @param _wETH Address of wrapped native coin.
    /// @param _xOLE Address of XOLEDelegator.
    /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol.
    function initialize(
        address _controller,
        DexAggregatorInterface _dexAggregator,
        address[] memory depositTokens,
        address _wETH,
        address _xOLE,
        uint8[] memory _supportDexs
    ) public {
        depositTokens;
        require(msg.sender == admin, "NAD");
        addressConfig.controller = _controller;
        addressConfig.dexAggregator = _dexAggregator;
        addressConfig.wETH = _wETH;
        addressConfig.xOLE = _xOLE;
        for (uint i = 0; i < _supportDexs.length; i++) {
            supportDexs[_supportDexs[i]] = true;
        }
        OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig);
    }

    /// @notice Create new trading pair.
    /// @dev This function is typically called by ControllerDelegator.
    /// @param pool0 Contract LpoolDelegator, lending pool of token0.
    /// @param pool1 Contract LpoolDelegator, lending pool of token1.
    /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value.
    /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens.
    /// @return The new created pair ID.
    function addMarket(
        LPoolInterface pool0,
        LPoolInterface pool1,
        uint16 marginLimit,
        bytes memory dexData
    ) external override returns (uint16) {
        uint16 marketId = numPairs;
        OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);
        numPairs ++;
        return marketId;
    }

    /// @notice Margin trade or just add more deposit tokens.
    /// @dev To support token with tax and reward. Stores share of all token balances of this contract.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param depositToken Token to deposit. False for token0, true for token1.
    /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported.
    /// @param borrow Amount of ERC20 to borrow from the short token pool.
    /// @param minBuyAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function marginTrade(
        uint16 marketId,
        bool longToken,
        bool depositToken,
        uint deposit,
        uint borrow,
        uint minBuyAmount,
        bytes memory dexData
    ) external payable override nonReentrant onlySupportDex(dexData) {
        Types.TradeVars memory tv;
        Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);
        verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);
        (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);

        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);
        }

        tv.totalHeld = totalHelds[address(vars.buyToken)];
        tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;

        deposit = transferIn(msg.sender, tv.depositErc20, deposit);

        // Borrow
        uint borrowed;
        if (borrow > 0) {
            {
                uint balance = vars.sellToken.balanceOf(address(this));
                vars.sellPool.borrowBehalf(msg.sender, borrow);
                borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);
            }

            if (depositToken == longToken){
                (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);
                tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));
            }else{
                tv.borrowValue = borrow;
            }
        }

        require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) > vars.marginLimit, "MAM");
        tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);
        tv.depositAfterFees = deposit.sub(tv.fees);
        tv.dexDetail = dexData.toDexDetail();

        if (depositToken == longToken ){
            if (borrowed > 0){
                tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);
                tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);
            }
            tv.newHeld = tv.newHeld.add(tv.depositAfterFees);
        }else{
            tv.tradeSize = tv.depositAfterFees.add(borrowed);
            tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);
            tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);
        }

        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);
        trade.held = trade.held.add(tv.newHeld);
        trade.depositToken = depositToken;
        trade.deposited = trade.deposited.add(tv.depositAfterFees);
        trade.lastBlockNum = uint128(block.number);

        totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);

        require(OpenLevV1Lib.isPositionHealthy(
                msg.sender,
                true,
                OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),
                vars,
                dexData
            ), "PNH");

        emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail);
    }

    /// @notice Close trade by shares.
    /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param closeHeld Amount of shares to close.
    /// @param minOrMaxAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);

        //verify
        verifyCloseBefore(trade, marketVars, closeHeld, dexData);

        uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        Types.CloseTradeVars memory closeTradeVars;
        closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);
        closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);
        closeTradeVars.isPartialClose = closeHeld != trade.held;
        closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);
        closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        closeTradeVars.dexDetail = dexData.toDexDetail();

        //partial close
        if (closeTradeVars.isPartialClose) {
            closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);
            closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);
            trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);
        } else {
            closeTradeVars.depositDecrease = trade.deposited;
        }

        if (trade.depositToken != longToken) {
            minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);
            closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;
            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);

            closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);
            doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);
        } else {
            uint balance = marketVars.buyToken.balanceOf(address(this));
            minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);
            closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);
            closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);
            closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);
            require(marketVars.sellToken.balanceOf(address(this)) >= closeTradeVars.depositReturn, "ISB");
            doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);
        }

        uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));
        require(repayed >= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");

        if (!closeTradeVars.isPartialClose) {
            delete activeTrades[msg.sender][marketId][longToken];
        }else{
            trade.held = trade.held.sub(closeHeld);
            trade.lastBlockNum = uint128(block.number);
        }

        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);

        closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,
            closeTradeVars.token0Price, closeTradeVars.dexDetail);
    }

    /// @notice Liquidate if trade below margin limit.
    /// @dev For trades without sufficient funds to repay, use insurance.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param minBuy Slippage for Dex trading.
    /// @param maxSell Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade memory trade = activeTrades[owner][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());
        uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);
        require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");

        Types.LiquidateVars memory liquidateVars;
        liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);
        if (liquidateVars.penalty > 0) {
            doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);
        }
        liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);
        liquidateVars.dexDetail = dexData.toDexDetail();
        liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);
        liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        liquidateVars.marketId = marketId;
        liquidateVars.longToken = longToken;

        bool buySuccess;
        bytes memory sellAmountData;
        if (longToken == trade.depositToken) {
            maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);
            marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);
            (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(
                abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],
                taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)
            );
        }

        if (buySuccess) {
            {
                uint temp;
                assembly {
                    temp := mload(add(sellAmountData, 0x20))
                }
                liquidateVars.sellAmount = temp;
            }

            liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);
            marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
            liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);
            doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);
        } else {
            liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;
            liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);
            if (liquidateVars.receiveAmount >= liquidateVars.borrowed) {
                // fail if buy failed but sell succeeded
                require (longToken != trade.depositToken, "PH");
                marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
                liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);
                doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);
            } else {
                liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);
                liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);
                marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);
            }
        }

        liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);
        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);

        emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,
            trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);

        delete activeTrades[owner][marketId][longToken];
    }

    function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {
        return open == longToken ?
        Types.MarketVars(
            market.pool1,
            market.pool0,
            IERC20(market.token1),
            IERC20(market.token0),
            IERC20(market.token1).balanceOf(address(this)),
            IERC20(market.token0).balanceOf(address(this)),
            market.pool1Insurance,
            market.pool0Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs) :
        Types.MarketVars(
            market.pool0,
            market.pool1,
            IERC20(market.token0),
            IERC20(market.token1),
            IERC20(market.token0).balanceOf(address(this)),
            IERC20(market.token1).balanceOf(address(this)),
            market.pool0Insurance,
            market.pool1Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs);
    }

    /// @notice Get ratios of deposited token value to borrowed token value.
    /// @dev Caluclate ratio with current price and twap price.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param dexData Index and fee rate for the trading Dex.
    /// @return current Margin ratio calculated using current price.
    /// @return cAvg Margin ratio calculated using twap price.
    /// @return hAvg Margin ratio calculated using last recorded twap price.
    /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value.
    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {
        Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);
        limit = vars.marginLimit;
        (current, cAvg, hAvg,,) =
        OpenLevV1Lib.marginRatio(
            owner,
            activeTrades[owner][marketId][longToken].held,
            address(vars.sellToken),
            address(vars.buyToken),
            vars.buyPool,
            false,
            dexData
        );
    }

    /// @notice Check if a price update is required on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){
        Types.Market memory market = markets[marketId];
        return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData);
    }

    /// @notice Update price on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function updatePrice(uint16 marketId, bytes memory dexData) external override {
        OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData);
    }

    /// @notice List of all supporting Dexes.
    function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){
        return markets[marketId].dexs;
    }

    function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {
        Types.Market storage market = markets[marketId];
        uint needed = totalRepayment.sub(remaining);
        needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);
        maxCanRepayAmount = totalRepayment;
        if (longToken) {
            if (market.pool0Insurance >= needed) {
                market.pool0Insurance = market.pool0Insurance - needed;
                totalHelds[token] = totalHelds[token].sub(needed);
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);
                market.pool0Insurance = 0;
            }
        } else {
            if (market.pool1Insurance >= needed) {
                market.pool1Insurance = market.pool1Insurance - needed;
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);
                market.pool1Insurance = 0;
            }
        }
    }

    function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {
        // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);
        Types.Market storage market = markets[marketId];
        uint defaultFees = tradeSize.mul(market.feesRate).div(10000);
        uint newFees = defaultFees;
        // if trader holds more xOLE, then should enjoy trading discount.
        if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) > calculateConfig.feesDiscountThreshold) {
            newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));
        }
        // if trader update price, then should enjoy trading discount.
        if (market.priceUpdater == trader) {
            newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));
        }
        uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);
        IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));

        newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);
        if (token == market.token1) {
            market.pool1Insurance = market.pool1Insurance.add(newInsurance);
        } else {
            market.pool0Insurance = market.pool0Insurance.add(newInsurance);
        }

        totalHelds[token] = totalHelds[token].add(newInsurance);
        return newFees;
    }

    function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){
        if (sellAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);
            buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);
        }
    }

    function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){
        if (buyAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);
            sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);
        }
    }

    /// @dev All credited on this contract and share with all token holder if any rewards for the transfer.
    function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {
        return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount);
    }

    /// @dev All credited on "to" if any taxes for the transfer.
    function doTransferOut(address to, IERC20 token, uint amount) internal {
        OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount);
    }

    /*** Admin Functions ***/
    function setCalculateConfig(uint16 defaultFeesRate,
        uint8 insuranceRatio,
        uint16 defaultMarginLimit,
        uint16 priceDiffientRatio,
        uint16 updatePriceDiscount,
        uint16 feesDiscount,
        uint128 feesDiscountThreshold,
        uint16 penaltyRatio,
        uint8 maxLiquidationPriceDiffientRatio,
        uint16 twapDuration) external override onlyAdmin() {
        OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,
            feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);
        emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration);
    }

    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {
        OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);
        emit NewAddressConfig(controller, address(dexAggregator));
    }

    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {
        OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);
        emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs);
    }

    /// @notice List of all supporting Dexes.
    /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1
    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {
        Types.Market storage market = markets[marketId];
        if (poolIndex == 0) {
            market.pool0Insurance = market.pool0Insurance.sub(amount);
            (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));
            return;
        }
        market.pool1Insurance = market.pool1Insurance.sub(amount);
        (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this))));
    }

    function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {
        supportDexs[dex] = support;
    }

    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){
        taxes[marketId][token][index] = tax;
    }

    function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {
        Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];
        OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade);
    }

    function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {
        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());
        require(closeHeld <= trade.held, "CBH");
    }

    function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {
        require(held != 0 && lastBlockNumber != block.number && OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0");
    }

    modifier onlySupportDex(bytes memory dexData) {
        require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");
        _;
    }
}.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-24-08 18:28:07 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-24-08 18:28:07 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 6914
completion_tokens: 909
total_tokens: 7823
cost: $-1.000000


[2024-24-08 18:28:07 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;

pragma experimental ABIEncoderV2;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "./OpenLevInterface.sol";
import "./Types.sol";
import "./Adminable.sol";
import "./DelegateInterface.sol";
import "./ControllerInterface.sol";
import "./IWETH.sol";
import "./XOLEInterface.sol";
import "./Types.sol";
import "./OpenLevV1Lib.sol";

/// @title OpenLeverage margin trade logic
/// @author OpenLeverage
/// @notice Use this contract for margin trade.
/// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE.
contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {
    using SafeMath for uint;
    using TransferHelper for IERC20;
    using DexData for bytes;

    constructor ()
    {
    }

    /// @notice initialize proxy contract
    /// @dev This function is not supposed to call multiple times. All configs can be set through other functions.
    /// @param _controller Address of contract ControllerDelegator.
    /// @param _dexAggregator contract DexAggregatorDelegator.
    /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens.
    /// @param _wETH Address of wrapped native coin.
    /// @param _xOLE Address of XOLEDelegator.
    /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol.
    function initialize(
        address _controller,
        DexAggregatorInterface _dexAggregator,
        address[] memory depositTokens,
        address _wETH,
        address _xOLE,
        uint8[] memory _supportDexs
    ) public {
        depositTokens;
        require(msg.sender == admin, "NAD");
        addressConfig.controller = _controller;
        addressConfig.dexAggregator = _dexAggregator;
        addressConfig.wETH = _wETH;
        addressConfig.xOLE = _xOLE;
        for (uint i = 0; i < _supportDexs.length; i++) {
            supportDexs[_supportDexs[i]] = true;
        }
        OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig);
    }

    /// @notice Create new trading pair.
    /// @dev This function is typically called by ControllerDelegator.
    /// @param pool0 Contract LpoolDelegator, lending pool of token0.
    /// @param pool1 Contract LpoolDelegator, lending pool of token1.
    /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value.
    /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens.
    /// @return The new created pair ID.
    function addMarket(
        LPoolInterface pool0,
        LPoolInterface pool1,
        uint16 marginLimit,
        bytes memory dexData
    ) external override returns (uint16) {
        uint16 marketId = numPairs;
        OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);
        numPairs ++;
        return marketId;
    }

    /// @notice Margin trade or just add more deposit tokens.
    /// @dev To support token with tax and reward. Stores share of all token balances of this contract.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param depositToken Token to deposit. False for token0, true for token1.
    /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported.
    /// @param borrow Amount of ERC20 to borrow from the short token pool.
    /// @param minBuyAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function marginTrade(
        uint16 marketId,
        bool longToken,
        bool depositToken,
        uint deposit,
        uint borrow,
        uint minBuyAmount,
        bytes memory dexData
    ) external payable override nonReentrant onlySupportDex(dexData) {
        Types.TradeVars memory tv;
        Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);
        verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);
        (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);

        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);
        }

        tv.totalHeld = totalHelds[address(vars.buyToken)];
        tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;

        deposit = transferIn(msg.sender, tv.depositErc20, deposit);

        // Borrow
        uint borrowed;
        if (borrow > 0) {
            {
                uint balance = vars.sellToken.balanceOf(address(this));
                vars.sellPool.borrowBehalf(msg.sender, borrow);
                borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);
            }

            if (depositToken == longToken){
                (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);
                tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));
            }else{
                tv.borrowValue = borrow;
            }
        }

        require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) > vars.marginLimit, "MAM");
        tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);
        tv.depositAfterFees = deposit.sub(tv.fees);
        tv.dexDetail = dexData.toDexDetail();

        if (depositToken == longToken ){
            if (borrowed > 0){
                tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);
                tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);
            }
            tv.newHeld = tv.newHeld.add(tv.depositAfterFees);
        }else{
            tv.tradeSize = tv.depositAfterFees.add(borrowed);
            tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);
            tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);
        }

        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);
        trade.held = trade.held.add(tv.newHeld);
        trade.depositToken = depositToken;
        trade.deposited = trade.deposited.add(tv.depositAfterFees);
        trade.lastBlockNum = uint128(block.number);

        totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);

        require(OpenLevV1Lib.isPositionHealthy(
                msg.sender,
                true,
                OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),
                vars,
                dexData
            ), "PNH");

        emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail);
    }

    /// @notice Close trade by shares.
    /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param closeHeld Amount of shares to close.
    /// @param minOrMaxAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);

        //verify
        verifyCloseBefore(trade, marketVars, closeHeld, dexData);

        uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        Types.CloseTradeVars memory closeTradeVars;
        closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);
        closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);
        closeTradeVars.isPartialClose = closeHeld != trade.held;
        closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);
        closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        closeTradeVars.dexDetail = dexData.toDexDetail();

        //partial close
        if (closeTradeVars.isPartialClose) {
            closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);
            closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);
            trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);
        } else {
            closeTradeVars.depositDecrease = trade.deposited;
        }

        if (trade.depositToken != longToken) {
            minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);
            closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;
            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);

            closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);
            doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);
        } else {
            uint balance = marketVars.buyToken.balanceOf(address(this));
            minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);
            closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);
            closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);
            closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);
            require(marketVars.sellToken.balanceOf(address(this)) >= closeTradeVars.depositReturn, "ISB");
            doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);
        }

        uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));
        require(repayed >= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");

        if (!closeTradeVars.isPartialClose) {
            delete activeTrades[msg.sender][marketId][longToken];
        }else{
            trade.held = trade.held.sub(closeHeld);
            trade.lastBlockNum = uint128(block.number);
        }

        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);

        closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,
            closeTradeVars.token0Price, closeTradeVars.dexDetail);
    }

    /// @notice Liquidate if trade below margin limit.
    /// @dev For trades without sufficient funds to repay, use insurance.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param minBuy Slippage for Dex trading.
    /// @param maxSell Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade memory trade = activeTrades[owner][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());
        uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);
        require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");

        Types.LiquidateVars memory liquidateVars;
        liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);
        if (liquidateVars.penalty > 0) {
            doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);
        }
        liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);
        liquidateVars.dexDetail = dexData.toDexDetail();
        liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);
        liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        liquidateVars.marketId = marketId;
        liquidateVars.longToken = longToken;

        bool buySuccess;
        bytes memory sellAmountData;
        if (longToken == trade.depositToken) {
            maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);
            marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);
            (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(
                abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],
                taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)
            );
        }

        if (buySuccess) {
            {
                uint temp;
                assembly {
                    temp := mload(add(sellAmountData, 0x20))
                }
                liquidateVars.sellAmount = temp;
            }

            liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);
            marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
            liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);
            doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);
        } else {
            liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;
            liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);
            if (liquidateVars.receiveAmount >= liquidateVars.borrowed) {
                // fail if buy failed but sell succeeded
                require (longToken != trade.depositToken, "PH");
                marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
                liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);
                doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);
            } else {
                liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);
                liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);
                marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);
            }
        }

        liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);
        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);

        emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,
            trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);

        delete activeTrades[owner][marketId][longToken];
    }

    function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {
        return open == longToken ?
        Types.MarketVars(
            market.pool1,
            market.pool0,
            IERC20(market.token1),
            IERC20(market.token0),
            IERC20(market.token1).balanceOf(address(this)),
            IERC20(market.token0).balanceOf(address(this)),
            market.pool1Insurance,
            market.pool0Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs) :
        Types.MarketVars(
            market.pool0,
            market.pool1,
            IERC20(market.token0),
            IERC20(market.token1),
            IERC20(market.token0).balanceOf(address(this)),
            IERC20(market.token1).balanceOf(address(this)),
            market.pool0Insurance,
            market.pool1Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs);
    }

    /// @notice Get ratios of deposited token value to borrowed token value.
    /// @dev Caluclate ratio with current price and twap price.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param dexData Index and fee rate for the trading Dex.
    /// @return current Margin ratio calculated using current price.
    /// @return cAvg Margin ratio calculated using twap price.
    /// @return hAvg Margin ratio calculated using last recorded twap price.
    /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value.
    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {
        Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);
        limit = vars.marginLimit;
        (current, cAvg, hAvg,,) =
        OpenLevV1Lib.marginRatio(
            owner,
            activeTrades[owner][marketId][longToken].held,
            address(vars.sellToken),
            address(vars.buyToken),
            vars.buyPool,
            false,
            dexData
        );
    }

    /// @notice Check if a price update is required on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){
        Types.Market memory market = markets[marketId];
        return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData);
    }

    /// @notice Update price on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function updatePrice(uint16 marketId, bytes memory dexData) external override {
        OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData);
    }

    /// @notice List of all supporting Dexes.
    function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){
        return markets[marketId].dexs;
    }

    function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {
        Types.Market storage market = markets[marketId];
        uint needed = totalRepayment.sub(remaining);
        needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);
        maxCanRepayAmount = totalRepayment;
        if (longToken) {
            if (market.pool0Insurance >= needed) {
                market.pool0Insurance = market.pool0Insurance - needed;
                totalHelds[token] = totalHelds[token].sub(needed);
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);
                market.pool0Insurance = 0;
            }
        } else {
            if (market.pool1Insurance >= needed) {
                market.pool1Insurance = market.pool1Insurance - needed;
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);
                market.pool1Insurance = 0;
            }
        }
    }

    function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {
        // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);
        Types.Market storage market = markets[marketId];
        uint defaultFees = tradeSize.mul(market.feesRate).div(10000);
        uint newFees = defaultFees;
        // if trader holds more xOLE, then should enjoy trading discount.
        if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) > calculateConfig.feesDiscountThreshold) {
            newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));
        }
        // if trader update price, then should enjoy trading discount.
        if (market.priceUpdater == trader) {
            newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));
        }
        uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);
        IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));

        newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);
        if (token == market.token1) {
            market.pool1Insurance = market.pool1Insurance.add(newInsurance);
        } else {
            market.pool0Insurance = market.pool0Insurance.add(newInsurance);
        }

        totalHelds[token] = totalHelds[token].add(newInsurance);
        return newFees;
    }

    function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){
        if (sellAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);
            buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);
        }
    }

    function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){
        if (buyAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);
            sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);
        }
    }

    /// @dev All credited on this contract and share with all token holder if any rewards for the transfer.
    function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {
        return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount);
    }

    /// @dev All credited on "to" if any taxes for the transfer.
    function doTransferOut(address to, IERC20 token, uint amount) internal {
        OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount);
    }

    /*** Admin Functions ***/
    function setCalculateConfig(uint16 defaultFeesRate,
        uint8 insuranceRatio,
        uint16 defaultMarginLimit,
        uint16 priceDiffientRatio,
        uint16 updatePriceDiscount,
        uint16 feesDiscount,
        uint128 feesDiscountThreshold,
        uint16 penaltyRatio,
        uint8 maxLiquidationPriceDiffientRatio,
        uint16 twapDuration) external override onlyAdmin() {
        OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,
            feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);
        emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration);
    }

    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {
        OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);
        emit NewAddressConfig(controller, address(dexAggregator));
    }

    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {
        OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);
        emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs);
    }

    /// @notice List of all supporting Dexes.
    /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1
    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {
        Types.Market storage market = markets[marketId];
        if (poolIndex == 0) {
            market.pool0Insurance = market.pool0Insurance.sub(amount);
            (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));
            return;
        }
        market.pool1Insurance = market.pool1Insurance.sub(amount);
        (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this))));
    }

    function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {
        supportDexs[dex] = support;
    }

    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){
        taxes[marketId][token][index] = tax;
    }

    function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {
        Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];
        OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade);
    }

    function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {
        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());
        require(closeHeld <= trade.held, "CBH");
    }

    function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {
        require(held != 0 && lastBlockNumber != block.number && OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0");
    }

    modifier onlySupportDex(bytes memory dexData) {
        require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");
        _;
    }
}.]

Based on the provided smart contract code for the OpenLevV1 contract, here is a succinct summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - Although the contract uses `ReentrancyGuard`, there are multiple external calls (e.g., `doTransferOut`, `flashSell`, `flashBuy`) that could potentially lead to reentrancy attacks if not properly managed. Care should be taken to ensure that state changes occur before external calls.

2. **Access Control Issues**:
   - The `initialize` function can be called by any address, which could lead to unauthorized configuration of the contract. This function should be restricted to the admin or a designated initializer.
   - The `setSupportDex` function can be called by any address, which could allow unauthorized changes to the supported DEXes.

3. **Lack of Input Validation**:
   - Several functions (e.g., `marginTrade`, `closeTrade`, `liquidate`) do not sufficiently validate inputs, such as ensuring that amounts are greater than zero or that the caller has sufficient balance. This could lead to unexpected behavior or loss of funds.

4. **Potential Integer Overflow/Underflow**:
   - Although the contract uses SafeMath, it is essential to ensure that all arithmetic operations are protected, especially in critical functions that handle financial transactions.

5. **Gas Limit and Loops**:
   - The use of loops (e.g., in the `initialize` function for setting supported DEXes) could lead to gas limit issues if the input size is too large. This could prevent the function from executing successfully.

6. **Improper Handling of External Calls**:
   - The contract relies on external contracts (e.g., DEX aggregators) for critical operations. If these contracts are compromised or behave unexpectedly, it could lead to loss of funds or unexpected behavior.

7. **Lack of Event Emission**:
   - Some critical state changes (e.g., in `liquidate`, `closeTrade`) do not emit events, which could hinder tracking and auditing of contract activity.

8. **Potential for Front-Running**:
   - The contract does not implement any mechanisms to protect against front-running attacks, which could allow malicious actors to exploit the timing of transactions for profit.

### Comprehensive Analysis Report:

The OpenLevV1 contract is designed for margin trading and includes various functionalities such as adding markets, executing trades, and liquidating positions. However, several security vulnerabilities have been identified that could potentially compromise the integrity and safety of the contract.

1. **Reentrancy Protection**: While the use of `ReentrancyGuard` is a positive measure, it is crucial to ensure that all external calls are carefully managed to prevent reentrancy attacks. State changes should occur before any external calls to mitigate this risk.

2. **Access Control**: The contract should implement stricter access control measures, especially for functions that modify critical configurations. Utilizing modifiers to restrict access to only authorized addresses is essential.

3. **Input Validation**: Comprehensive input validation is necessary to ensure that all parameters passed to functions are within acceptable ranges and that the caller has sufficient balances. This will help prevent unexpected behavior and potential loss of funds.

4. **Arithmetic Safety**: Although SafeMath is used, it is vital to ensure that all arithmetic operations are protected, especially in financial calculations. This will help prevent integer overflow or underflow issues.

5. **Gas Limit Considerations**: The use of loops in functions should be minimized or carefully managed to avoid gas limit issues. Consider implementing checks to ensure that the input size is manageable.

6. **External Call Management**: Given the reliance on external contracts, it is crucial to ensure that these contracts are secure and that the contract has fallback mechanisms in case of unexpected behavior.

7. **Event Emission**: Emitting events for all significant state changes will enhance transparency and allow for better tracking of contract activity, which is essential for auditing purposes.

8. **Front-Running Mitigation**: Implementing mechanisms to protect against front-running attacks will enhance the security of the trading functionalities and protect users from potential exploitation.

In conclusion, while the OpenLevV1 contract provides a robust framework for margin trading, addressing the identified vulnerabilities is critical to ensuring the security and reliability of the contract. A thorough audit and implementation of best practices in smart contract development are recommended to mitigate these risks effectively.

[2024-24-08 18:28:07 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for the OpenLevV1 contract, here is a succinct summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - Although the contract uses `ReentrancyGuard`, there are multiple external calls (e.g., `doTransferOut`, `flashSell`, `flashBuy`) that could potentially lead to reentrancy attacks if not properly managed. Care should be taken to ensure that state changes occur before external calls.

2. **Access Control Issues**:
   - The `initialize` function can be called by any address, which could lead to unauthorized configuration of the contract. This function should be restricted to the admin or a designated initializer.
   - The `setSupportDex` function can be called by any address, which could allow unauthorized changes to the supported DEXes.

3. **Lack of Input Validation**:
   - Several functions (e.g., `marginTrade`, `closeTrade`, `liquidate`) do not sufficiently validate inputs, such as ensuring that amounts are greater than zero or that the caller has sufficient balance. This could lead to unexpected behavior or loss of funds.

4. **Potential Integer Overflow/Underflow**:
   - Although the contract uses SafeMath, it is essential to ensure that all arithmetic operations are protected, especially in critical functions that handle financial transactions.

5. **Gas Limit and Loops**:
   - The use of loops (e.g., in the `initialize` function for setting supported DEXes) could lead to gas limit issues if the input size is too large. This could prevent the function from executing successfully.

6. **Improper Handling of External Calls**:
   - The contract relies on external contracts (e.g., DEX aggregators) for critical operations. If these contracts are compromised or behave unexpectedly, it could lead to loss of funds or unexpected behavior.

7. **Lack of Event Emission**:
   - Some critical state changes (e.g., in `liquidate`, `closeTrade`) do not emit events, which could hinder tracking and auditing of contract activity.

8. **Potential for Front-Running**:
   - The contract does not implement any mechanisms to protect against front-running attacks, which could allow malicious actors to exploit the timing of transactions for profit.

### Comprehensive Analysis Report:

The OpenLevV1 contract is designed for margin trading and includes various functionalities such as adding markets, executing trades, and liquidating positions. However, several security vulnerabilities have been identified that could potentially compromise the integrity and safety of the contract.

1. **Reentrancy Protection**: While the use of `ReentrancyGuard` is a positive measure, it is crucial to ensure that all external calls are carefully managed to prevent reentrancy attacks. State changes should occur before any external calls to mitigate this risk.

2. **Access Control**: The contract should implement stricter access control measures, especially for functions that modify critical configurations. Utilizing modifiers to restrict access to only authorized addresses is essential.

3. **Input Validation**: Comprehensive input validation is necessary to ensure that all parameters passed to functions are within acceptable ranges and that the caller has sufficient balances. This will help prevent unexpected behavior and potential loss of funds.

4. **Arithmetic Safety**: Although SafeMath is used, it is vital to ensure that all arithmetic operations are protected, especially in financial calculations. This will help prevent integer overflow or underflow issues.

5. **Gas Limit Considerations**: The use of loops in functions should be minimized or carefully managed to avoid gas limit issues. Consider implementing checks to ensure that the input size is manageable.

6. **External Call Management**: Given the reliance on external contracts, it is crucial to ensure that these contracts are secure and that the contract has fallback mechanisms in case of unexpected behavior.

7. **Event Emission**: Emitting events for all significant state changes will enhance transparency and allow for better tracking of contract activity, which is essential for auditing purposes.

8. **Front-Running Mitigation**: Implementing mechanisms to protect against front-running attacks will enhance the security of the trading functionalities and protect users from potential exploitation.

In conclusion, while the OpenLevV1 contract provides a robust framework for margin trading, addressing the identified vulnerabilities is critical to ensuring the security and reliability of the contract. A thorough audit and implementation of best practices in smart contract development are recommended to mitigate these risks effectively.

[2024-24-08 18:28:07 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-24-08 18:28:08 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.7.6; pragma experimental ABIEncoderV2; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import "./OpenLevInterface.sol"; import "./Types.sol"; import "./Adminable.sol"; import "./DelegateInterface.sol"; import "./ControllerInterface.sol"; import "./IWETH.sol"; import "./XOLEInterface.sol"; import "./Types.sol"; import "./OpenLevV1Lib.sol"; /// @title OpenLeverage margin trade logic /// @author OpenLeverage /// @notice Use this contract for margin trade. /// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE. contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {     using SafeMath for uint;     using TransferHelper for IERC20;     using DexData for bytes; constructor () { }  /// @notice initialize proxy contract /// @dev This function is not supposed to call multiple times. All configs can be set through other functions. /// @param _controller Address of contract ControllerDelegator. /// @param _dexAggregator contract DexAggregatorDelegator. /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens. /// @param _wETH Address of wrapped native coin. /// @param _xOLE Address of XOLEDelegator. /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol. function initialize(     address _controller,     DexAggregatorInterface _dexAggregator,     address[] memory depositTokens,     address _wETH,     address _xOLE,     uint8[] memory _supportDexs ) public {     depositTokens;     require(msg.sender == admin, "NAD");     addressConfig.controller = _controller;     addressConfig.dexAggregator = _dexAggregator;     addressConfig.wETH = _wETH;     addressConfig.xOLE = _xOLE;     for (uint i = 0; i &lt; _supportDexs.length; i++) {         supportDexs[_supportDexs[i]] = true;     }     OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig); }  /// @notice Create new trading pair. /// @dev This function is typically called by ControllerDelegator. /// @param pool0 Contract LpoolDelegator, lending pool of token0. /// @param pool1 Contract LpoolDelegator, lending pool of token1. /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value. /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens. /// @return The new created pair ID. function addMarket(     LPoolInterface pool0,     LPoolInterface pool1,     uint16 marginLimit,     bytes memory dexData ) external override returns (uint16) {     uint16 marketId = numPairs;     OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);     numPairs ++;     return marketId; }  /// @notice Margin trade or just add more deposit tokens. /// @dev To support token with tax and reward. Stores share of all token balances of this contract. /// @param longToken Token to long. False for token0, true for token1. /// @param depositToken Token to deposit. False for token0, true for token1. /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported. /// @param borrow Amount of ERC20 to borrow from the short token pool. /// @param minBuyAmount Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function marginTrade(     uint16 marketId,     bool longToken,     bool depositToken,     uint deposit,     uint borrow,     uint minBuyAmount,     bytes memory dexData ) external payable override nonReentrant onlySupportDex(dexData) {     Types.TradeVars memory tv;     Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);     verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);     (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);      if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);     }      tv.totalHeld = totalHelds[address(vars.buyToken)];     tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;      deposit = transferIn(msg.sender, tv.depositErc20, deposit);      // Borrow     uint borrowed;     if (borrow &gt; 0) {         {             uint balance = vars.sellToken.balanceOf(address(this));             vars.sellPool.borrowBehalf(msg.sender, borrow);             borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);         }          if (depositToken == longToken){             (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);             tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));         }else{             tv.borrowValue = borrow;         }     }      require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) &gt; vars.marginLimit, "MAM");     tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);     tv.depositAfterFees = deposit.sub(tv.fees);     tv.dexDetail = dexData.toDexDetail();      if (depositToken == longToken ){         if (borrowed &gt; 0){             tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);             tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);         }         tv.newHeld = tv.newHeld.add(tv.depositAfterFees);     }else{         tv.tradeSize = tv.depositAfterFees.add(borrowed);         tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);         tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);     }      Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];     tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);     trade.held = trade.held.add(tv.newHeld);     trade.depositToken = depositToken;     trade.deposited = trade.deposited.add(tv.depositAfterFees);     trade.lastBlockNum = uint128(block.number);      totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);      require(OpenLevV1Lib.isPositionHealthy(             msg.sender,             true,             OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),             vars,             dexData         ), "PNH");      emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail); }  /// @notice Close trade by shares. /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed. /// @param longToken Token to long. False for token0, true for token1. /// @param closeHeld Amount of shares to close. /// @param minOrMaxAmount Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {     Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];     Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);      //verify     verifyCloseBefore(trade, marketVars, closeHeld, dexData);      uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);      Types.CloseTradeVars memory closeTradeVars;     closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);     closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);     closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);     closeTradeVars.isPartialClose = closeHeld != trade.held;     closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);     closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);     closeTradeVars.dexDetail = dexData.toDexDetail();      //partial close     if (closeTradeVars.isPartialClose) {         closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);         closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);         trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);     } else {         closeTradeVars.depositDecrease = trade.deposited;     }      if (trade.depositToken != longToken) {         minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);         closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);         require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");          closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;         marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);          closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);         doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);     } else {         uint balance = marketVars.buyToken.balanceOf(address(this));         minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);         closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);         closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);         require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");          marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);         closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);         require(marketVars.sellToken.balanceOf(address(this)) &gt;= closeTradeVars.depositReturn, "ISB");         doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);     }      uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));     require(repayed &gt;= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");      if (!closeTradeVars.isPartialClose) {         delete activeTrades[msg.sender][marketId][longToken];     }else{         trade.held = trade.held.sub(closeHeld);         trade.lastBlockNum = uint128(block.number);     }      totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);      closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);     if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);     }      emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,         closeTradeVars.token0Price, closeTradeVars.dexDetail); }  /// @notice Liquidate if trade below margin limit. /// @dev For trades without sufficient funds to repay, use insurance. /// @param owner Owner of the trade to liquidate. /// @param longToken Token to long. False for token0, true for token1. /// @param minBuy Slippage for Dex trading. /// @param maxSell Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {     Types.Trade memory trade = activeTrades[owner][marketId][longToken];     Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);     if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);     }      verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());     uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);      (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);     require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");      Types.LiquidateVars memory liquidateVars;     liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);     liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);     if (liquidateVars.penalty &gt; 0) {         doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);     }     liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);     liquidateVars.dexDetail = dexData.toDexDetail();     liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);     liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);     liquidateVars.marketId = marketId;     liquidateVars.longToken = longToken;      bool buySuccess;     bytes memory sellAmountData;     if (longToken == trade.depositToken) {         maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);         marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);         (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(             abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],             taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)         );     }      if (buySuccess) {         {             uint temp;             assembly {                 temp := mload(add(sellAmountData, 0x20))             }             liquidateVars.sellAmount = temp;         }          liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);         marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);         liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);         doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);     } else {         liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;         liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);         if (liquidateVars.receiveAmount &gt;= liquidateVars.borrowed) {             // fail if buy failed but sell succeeded             require (longToken != trade.depositToken, "PH");             marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);             liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);             doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);         } else {             liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);             liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);             marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);         }     }      liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);     totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);      emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,         trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);      delete activeTrades[owner][marketId][longToken]; }  function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {     return open == longToken ?     Types.MarketVars(         market.pool1,         market.pool0,         IERC20(market.token1),         IERC20(market.token0),         IERC20(market.token1).balanceOf(address(this)),         IERC20(market.token0).balanceOf(address(this)),         market.pool1Insurance,         market.pool0Insurance,         market.marginLimit,         market.priceDiffientRatio,         market.dexs) :     Types.MarketVars(         market.pool0,         market.pool1,         IERC20(market.token0),         IERC20(market.token1),         IERC20(market.token0).balanceOf(address(this)),         IERC20(market.token1).balanceOf(address(this)),         market.pool0Insurance,         market.pool1Insurance,         market.marginLimit,         market.priceDiffientRatio,         market.dexs); }  /// @notice Get ratios of deposited token value to borrowed token value. /// @dev Caluclate ratio with current price and twap price. /// @param owner Owner of the trade to liquidate. /// @param longToken Token to long. False for token0, true for token1. /// @param dexData Index and fee rate for the trading Dex. /// @return current Margin ratio calculated using current price. /// @return cAvg Margin ratio calculated using twap price. /// @return hAvg Margin ratio calculated using last recorded twap price. /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value. function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {     Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);     limit = vars.marginLimit;     (current, cAvg, hAvg,,) =     OpenLevV1Lib.marginRatio(         owner,         activeTrades[owner][marketId][longToken].held,         address(vars.sellToken),         address(vars.buyToken),         vars.buyPool,         false,         dexData     ); }  /// @notice Check if a price update is required on Dex. /// @param dexData Index and fee rate for the trading Dex. function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){     Types.Market memory market = markets[marketId];     return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData); }  /// @notice Update price on Dex. /// @param dexData Index and fee rate for the trading Dex. function updatePrice(uint16 marketId, bytes memory dexData) external override {     OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData); }  /// @notice List of all supporting Dexes. function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){     return markets[marketId].dexs; }  function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {     Types.Market storage market = markets[marketId];     uint needed = totalRepayment.sub(remaining);     needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);     maxCanRepayAmount = totalRepayment;     if (longToken) {         if (market.pool0Insurance &gt;= needed) {             market.pool0Insurance = market.pool0Insurance - needed;             totalHelds[token] = totalHelds[token].sub(needed);         } else {             maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);             maxCanRepayAmount = maxCanRepayAmount.add(remaining);             totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);             market.pool0Insurance = 0;         }     } else {         if (market.pool1Insurance &gt;= needed) {             market.pool1Insurance = market.pool1Insurance - needed;         } else {             maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);             maxCanRepayAmount = maxCanRepayAmount.add(remaining);             totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);             market.pool1Insurance = 0;         }     } }  function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {     // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);     Types.Market storage market = markets[marketId];     uint defaultFees = tradeSize.mul(market.feesRate).div(10000);     uint newFees = defaultFees;     // if trader holds more xOLE, then should enjoy trading discount.     if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) &gt; calculateConfig.feesDiscountThreshold) {         newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));     }     // if trader update price, then should enjoy trading discount.     if (market.priceUpdater == trader) {         newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));     }     uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);     IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));      newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);     if (token == market.token1) {         market.pool1Insurance = market.pool1Insurance.add(newInsurance);     } else {         market.pool0Insurance = market.pool0Insurance.add(newInsurance);     }      totalHelds[token] = totalHelds[token].add(newInsurance);     return newFees; }  function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){     if (sellAmount &gt; 0){         DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;         IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);         buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);     } }  function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){     if (buyAmount &gt; 0){         DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;         IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);         sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);     } }  /// @dev All credited on this contract and share with all token holder if any rewards for the transfer. function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {     return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount); }  /// @dev All credited on "to" if any taxes for the transfer. function doTransferOut(address to, IERC20 token, uint amount) internal {     OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount); }  /*** Admin Functions ***/ function setCalculateConfig(uint16 defaultFeesRate,     uint8 insuranceRatio,     uint16 defaultMarginLimit,     uint16 priceDiffientRatio,     uint16 updatePriceDiscount,     uint16 feesDiscount,     uint128 feesDiscountThreshold,     uint16 penaltyRatio,     uint8 maxLiquidationPriceDiffientRatio,     uint16 twapDuration) external override onlyAdmin() {     OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,         feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);     emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration); }  function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {     OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);     emit NewAddressConfig(controller, address(dexAggregator)); }  function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {     OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);     emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs); }  /// @notice List of all supporting Dexes. /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1 function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {     Types.Market storage market = markets[marketId];     if (poolIndex == 0) {         market.pool0Insurance = market.pool0Insurance.sub(amount);         (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));         return;     }     market.pool1Insurance = market.pool1Insurance.sub(amount);     (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this)))); }  function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {     supportDexs[dex] = support; }  function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){     taxes[marketId][token][index] = tax; }  function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {     Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];     OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade); }  function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {     verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());     require(closeHeld &lt;= trade.held, "CBH"); }  function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {     require(held != 0 &amp;&amp; lastBlockNumber != block.number &amp;&amp; OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0"); }  modifier onlySupportDex(bytes memory dexData) {     require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");     _; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.7.6;\n\npragma experimental ABIEncoderV2;\n\nimport "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\nimport "./OpenLevInterface.sol";\nimport "./Types.sol";\nimport "./Adminable.sol";\nimport "./DelegateInterface.sol";\nimport "./ControllerInterface.sol";\nimport "./IWETH.sol";\nimport "./XOLEInterface.sol";\nimport "./Types.sol";\nimport "./OpenLevV1Lib.sol";\n\n/// @title OpenLeverage margin trade logic\n/// @author OpenLeverage\n/// @notice Use this contract for margin trade.\n/// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE.\ncontract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {\n    using SafeMath for uint;\n    using TransferHelper for IERC20;\n    using DexData for bytes;\n\n    constructor ()\n    {\n    }\n\n    /// @notice initialize proxy contract\n    /// @dev This function is not supposed to call multiple times. All configs can be set through other functions.\n    /// @param controller Address of contract ControllerDelegator.\n    /// @param _dexAggregator contract DexAggregatorDelegator.\n    /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens.\n    /// @param _wETH Address of wrapped native coin.\n    /// @param _xOLE Address of XOLEDelegator.\n    /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol.\n    function initialize(\n        address _controller,\n        DexAggregatorInterface _dexAggregator,\n        address[] memory depositTokens,\n        address _wETH,\n        address _xOLE,\n        uint8[] memory _supportDexs\n    ) public {\n        depositTokens;\n        require(msg.sender == admin, "NAD");\n        addressConfig.controller = _controller;\n        addressConfig.dexAggregator = _dexAggregator;\n        addressConfig.wETH = _wETH;\n        addressConfig.xOLE = _xOLE;\n        for (uint i = 0; i &lt; _supportDexs.length; i++) {\n            supportDexs[_supportDexs[i]] = true;\n        }\n        OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig);\n    }\n\n    /// @notice Create new trading pair.\n    /// @dev This function is typically called by ControllerDelegator.\n    /// @param pool0 Contract LpoolDelegator, lending pool of token0.\n    /// @param pool1 Contract LpoolDelegator, lending pool of token1.\n    /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value.\n    /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens.\n    /// @return The new created pair ID.\n    function addMarket(\n        LPoolInterface pool0,\n        LPoolInterface pool1,\n        uint16 marginLimit,\n        bytes memory dexData\n    ) external override returns (uint16) {\n        uint16 marketId = numPairs;\n        OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);\n        numPairs ++;\n        return marketId;\n    }\n\n    /// @notice Margin trade or just add more deposit tokens.\n    /// @dev To support token with tax and reward. Stores share of all token balances of this contract.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param depositToken Token to deposit. False for token0, true for token1.\n    /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported.\n    /// @param borrow Amount of ERC20 to borrow from the short token pool.\n    /// @param minBuyAmount Slippage for Dex trading.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function marginTrade(\n        uint16 marketId,\n        bool longToken,\n        bool depositToken,\n        uint deposit,\n        uint borrow,\n        uint minBuyAmount,\n        bytes memory dexData\n    ) external payable override nonReentrant onlySupportDex(dexData) {\n        Types.TradeVars memory tv;\n        Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);\n        verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);\n        (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);\n\n        if (dexData.isUniV2Class()) {\n            OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);\n        }\n\n        tv.totalHeld = totalHelds[address(vars.buyToken)];\n        tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;\n\n        deposit = transferIn(msg.sender, tv.depositErc20, deposit);\n\n        // Borrow\n        uint borrowed;\n        if (borrow &gt; 0) {\n            {\n                uint balance = vars.sellToken.balanceOf(address(this));\n                vars.sellPool.borrowBehalf(msg.sender, borrow);\n                borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);\n            }\n\n            if (depositToken == longToken){\n                (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);\n                tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));\n            }else{\n                tv.borrowValue = borrow;\n            }\n        }\n\n        require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) &gt; vars.marginLimit, "MAM");\n        tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);\n        tv.depositAfterFees = deposit.sub(tv.fees);\n        tv.dexDetail = dexData.toDexDetail();\n\n        if (depositToken == longToken ){\n            if (borrowed &gt; 0){\n                tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);\n                tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);\n            }\n            tv.newHeld = tv.newHeld.add(tv.depositAfterFees);\n        }else{\n            tv.tradeSize = tv.depositAfterFees.add(borrowed);\n            tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);\n            tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);\n        }\n\n        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];\n        tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);\n        trade.held = trade.held.add(tv.newHeld);\n        trade.depositToken = depositToken;\n        trade.deposited = trade.deposited.add(tv.depositAfterFees);\n        trade.lastBlockNum = uint128(block.number);\n\n        totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);\n\n        require(OpenLevV1Lib.isPositionHealthy(\n                msg.sender,\n                true,\n                OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),\n                vars,\n                dexData\n            ), "PNH");\n\n        emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail);\n    }\n\n    /// @notice Close trade by shares.\n    /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param closeHeld Amount of shares to close.\n    /// @param minOrMaxAmount Slippage for Dex trading.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {\n        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];\n        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);\n\n        //verify\n        verifyCloseBefore(trade, marketVars, closeHeld, dexData);\n\n        uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n\n        Types.CloseTradeVars memory closeTradeVars;\n        closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n        closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);\n        closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);\n        closeTradeVars.isPartialClose = closeHeld != trade.held;\n        closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);\n        closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);\n        closeTradeVars.dexDetail = dexData.toDexDetail();\n\n        //partial close\n        if (closeTradeVars.isPartialClose) {\n            closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);\n            closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);\n            trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);\n        } else {\n            closeTradeVars.depositDecrease = trade.deposited;\n        }\n\n        if (trade.depositToken != longToken) {\n            minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);\n            closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);\n            require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");\n\n            closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;\n            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);\n\n            closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);\n            doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);\n        } else {\n            uint balance = marketVars.buyToken.balanceOf(address(this));\n            minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);\n            closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);\n            closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);\n            require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");\n\n            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);\n            closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);\n            require(marketVars.sellToken.balanceOf(address(this)) &gt;= closeTradeVars.depositReturn, "ISB");\n            doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);\n        }\n\n        uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));\n        require(repayed &gt;= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");\n\n        if (!closeTradeVars.isPartialClose) {\n            delete activeTrades[msg.sender][marketId][longToken];\n        }else{\n            trade.held = trade.held.sub(closeHeld);\n            trade.lastBlockNum = uint128(block.number);\n        }\n\n        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);\n\n        closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);\n        if (dexData.isUniV2Class()) {\n            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);\n        }\n\n        emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,\n            closeTradeVars.token0Price, closeTradeVars.dexDetail);\n    }\n\n    /// @notice Liquidate if trade below margin limit.\n    /// @dev For trades without sufficient funds to repay, use insurance.\n    /// @param owner Owner of the trade to liquidate.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param minBuy Slippage for Dex trading.\n    /// @param maxSell Slippage for Dex trading.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {\n        Types.Trade memory trade = activeTrades[owner][marketId][longToken];\n        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);\n        if (dexData.isUniV2Class()) {\n            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);\n        }\n\n        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());\n        uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n\n        (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);\n        require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");\n\n        Types.LiquidateVars memory liquidateVars;\n        liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n        liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);\n        if (liquidateVars.penalty &gt; 0) {\n            doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);\n        }\n        liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);\n        liquidateVars.dexDetail = dexData.toDexDetail();\n        liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);\n        liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);\n        liquidateVars.marketId = marketId;\n        liquidateVars.longToken = longToken;\n\n        bool buySuccess;\n        bytes memory sellAmountData;\n        if (longToken == trade.depositToken) {\n            maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);\n            marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);\n            (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(\n                abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],\n                taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)\n            );\n        }\n\n        if (buySuccess) {\n            {\n                uint temp;\n                assembly {\n                    temp := mload(add(sellAmountData, 0x20))\n                }\n                liquidateVars.sellAmount = temp;\n            }\n\n            liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);\n            marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);\n            liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);\n            doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);\n        } else {\n            liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;\n            liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);\n            if (liquidateVars.receiveAmount &gt;= liquidateVars.borrowed) {\n                // fail if buy failed but sell succeeded\n                require (longToken != trade.depositToken, "PH");\n                marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);\n                liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);\n                doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);\n            } else {\n                liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);\n                liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);\n                marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);\n            }\n        }\n\n        liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);\n        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);\n\n        emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,\n            trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);\n\n        delete activeTrades[owner][marketId][longToken];\n    }\n\n    function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {\n        return open == longToken ?\n        Types.MarketVars(\n            market.pool1,\n            market.pool0,\n            IERC20(market.token1),\n            IERC20(market.token0),\n            IERC20(market.token1).balanceOf(address(this)),\n            IERC20(market.token0).balanceOf(address(this)),\n            market.pool1Insurance,\n            market.pool0Insurance,\n            market.marginLimit,\n            market.priceDiffientRatio,\n            market.dexs) :\n        Types.MarketVars(\n            market.pool0,\n            market.pool1,\n            IERC20(market.token0),\n            IERC20(market.token1),\n            IERC20(market.token0).balanceOf(address(this)),\n            IERC20(market.token1).balanceOf(address(this)),\n            market.pool0Insurance,\n            market.pool1Insurance,\n            market.marginLimit,\n            market.priceDiffientRatio,\n            market.dexs);\n    }\n\n    /// @notice Get ratios of deposited token value to borrowed token value.\n    /// @dev Caluclate ratio with current price and twap price.\n    /// @param owner Owner of the trade to liquidate.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param dexData Index and fee rate for the trading Dex.\n    /// @return current Margin ratio calculated using current price.\n    /// @return cAvg Margin ratio calculated using twap price.\n    /// @return hAvg Margin ratio calculated using last recorded twap price.\n    /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value.\n    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {\n        Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);\n        limit = vars.marginLimit;\n        (current, cAvg, hAvg,,) =\n        OpenLevV1Lib.marginRatio(\n            owner,\n            activeTrades[owner][marketId][longToken].held,\n            address(vars.sellToken),\n            address(vars.buyToken),\n            vars.buyPool,\n            false,\n            dexData\n        );\n    }\n\n    /// @notice Check if a price update is required on Dex.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){\n        Types.Market memory market = markets[marketId];\n        return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData);\n    }\n\n    /// @notice Update price on Dex.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function updatePrice(uint16 marketId, bytes memory dexData) external override {\n        OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData);\n    }\n\n    /// @notice List of all supporting Dexes.\n    function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){\n        return markets[marketId].dexs;\n    }\n\n    function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {\n        Types.Market storage market = markets[marketId];\n        uint needed = totalRepayment.sub(remaining);\n        needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);\n        maxCanRepayAmount = totalRepayment;\n        if (longToken) {\n            if (market.pool0Insurance &gt;= needed) {\n                market.pool0Insurance = market.pool0Insurance - needed;\n                totalHelds[token] = totalHelds[token].sub(needed);\n            } else {\n                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);\n                maxCanRepayAmount = maxCanRepayAmount.add(remaining);\n                totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);\n                market.pool0Insurance = 0;\n            }\n        } else {\n            if (market.pool1Insurance &gt;= needed) {\n                market.pool1Insurance = market.pool1Insurance - needed;\n            } else {\n                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);\n                maxCanRepayAmount = maxCanRepayAmount.add(remaining);\n                totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);\n                market.pool1Insurance = 0;\n            }\n        }\n    }\n\n    function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {\n        // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);\n        Types.Market storage market = markets[marketId];\n        uint defaultFees = tradeSize.mul(market.feesRate).div(10000);\n        uint newFees = defaultFees;\n        // if trader holds more xOLE, then should enjoy trading discount.\n        if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) &gt; calculateConfig.feesDiscountThreshold) {\n            newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));\n        }\n        // if trader update price, then should enjoy trading discount.\n        if (market.priceUpdater == trader) {\n            newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));\n        }\n        uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);\n        IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));\n\n        newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);\n        if (token == market.token1) {\n            market.pool1Insurance = market.pool1Insurance.add(newInsurance);\n        } else {\n            market.pool0Insurance = market.pool0Insurance.add(newInsurance);\n        }\n\n        totalHelds[token] = totalHelds[token].add(newInsurance);\n        return newFees;\n    }\n\n    function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){\n        if (sellAmount &gt; 0){\n            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;\n            IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);\n            buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);\n        }\n    }\n\n    function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){\n        if (buyAmount &gt; 0){\n            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;\n            IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);\n            sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);\n        }\n    }\n\n    /// @dev All credited on this contract and share with all token holder if any rewards for the transfer.\n    function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {\n        return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount);\n    }\n\n    /// @dev All credited on "to" if any taxes for the transfer.\n    function doTransferOut(address to, IERC20 token, uint amount) internal {\n        OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount);\n    }\n\n    / Admin Functions /\n    function setCalculateConfig(uint16 defaultFeesRate,\n        uint8 insuranceRatio,\n        uint16 defaultMarginLimit,\n        uint16 priceDiffientRatio,\n        uint16 updatePriceDiscount,\n        uint16 feesDiscount,\n        uint128 feesDiscountThreshold,\n        uint16 penaltyRatio,\n        uint8 maxLiquidationPriceDiffientRatio,\n        uint16 twapDuration) external override onlyAdmin() {\n        OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,\n            feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);\n        emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration);\n    }\n\n    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {\n        OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);\n        emit NewAddressConfig(controller, address(dexAggregator));\n    }\n\n    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {\n        OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);\n        emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs);\n    }\n\n    /// @notice List of all supporting Dexes.\n    /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1\n    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {\n        Types.Market storage market = markets[marketId];\n        if (poolIndex == 0) {\n            market.pool0Insurance = market.pool0Insurance.sub(amount);\n            (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));\n            return;\n        }\n        market.pool1Insurance = market.pool1Insurance.sub(amount);\n        (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this))));\n    }\n\n    function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {\n        supportDexs[dex] = support;\n    }\n\n    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){\n        taxes[marketId][token][index] = tax;\n    }\n\n    function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {\n        Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];\n        OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade);\n    }\n\n    function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {\n        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());\n        require(closeHeld &lt;= trade.held, "CBH");\n    }\n\n    function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {\n        require(held != 0 &amp;&amp; lastBlockNumber != block.number &amp;&amp; OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0");\n    }\n\n    modifier onlySupportDex(bytes memory dexData) {\n        require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");\n        ;\n    }\n}', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-24-08 18:28:08 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.7.6; pragma experimental ABIEncoderV2; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import "./OpenLevInterface.sol"; import "./Types.sol"; import "./Adminable.sol"; import "./DelegateInterface.sol"; import "./ControllerInterface.sol"; import "./IWETH.sol"; import "./XOLEInterface.sol"; import "./Types.sol"; import "./OpenLevV1Lib.sol"; /// @title OpenLeverage margin trade logic /// @author OpenLeverage /// @notice Use this contract for margin trade. /// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE. contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {     using SafeMath for uint;     using TransferHelper for IERC20;     using DexData for bytes; constructor () { }  /// @notice initialize proxy contract /// @dev This function is not supposed to call multiple times. All configs can be set through other functions. /// @param _controller Address of contract ControllerDelegator. /// @param _dexAggregator contract DexAggregatorDelegator. /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens. /// @param _wETH Address of wrapped native coin. /// @param _xOLE Address of XOLEDelegator. /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol. function initialize(     address _controller,     DexAggregatorInterface _dexAggregator,     address[] memory depositTokens,     address _wETH,     address _xOLE,     uint8[] memory _supportDexs ) public {     depositTokens;     require(msg.sender == admin, "NAD");     addressConfig.controller = _controller;     addressConfig.dexAggregator = _dexAggregator;     addressConfig.wETH = _wETH;     addressConfig.xOLE = _xOLE;     for (uint i = 0; i &lt; _supportDexs.length; i++) {         supportDexs[_supportDexs[i]] = true;     }     OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig); }  /// @notice Create new trading pair. /// @dev This function is typically called by ControllerDelegator. /// @param pool0 Contract LpoolDelegator, lending pool of token0. /// @param pool1 Contract LpoolDelegator, lending pool of token1. /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value. /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens. /// @return The new created pair ID. function addMarket(     LPoolInterface pool0,     LPoolInterface pool1,     uint16 marginLimit,     bytes memory dexData ) external override returns (uint16) {     uint16 marketId = numPairs;     OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);     numPairs ++;     return marketId; }  /// @notice Margin trade or just add more deposit tokens. /// @dev To support token with tax and reward. Stores share of all token balances of this contract. /// @param longToken Token to long. False for token0, true for token1. /// @param depositToken Token to deposit. False for token0, true for token1. /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported. /// @param borrow Amount of ERC20 to borrow from the short token pool. /// @param minBuyAmount Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function marginTrade(     uint16 marketId,     bool longToken,     bool depositToken,     uint deposit,     uint borrow,     uint minBuyAmount,     bytes memory dexData ) external payable override nonReentrant onlySupportDex(dexData) {     Types.TradeVars memory tv;     Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);     verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);     (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);      if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);     }      tv.totalHeld = totalHelds[address(vars.buyToken)];     tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;      deposit = transferIn(msg.sender, tv.depositErc20, deposit);      // Borrow     uint borrowed;     if (borrow &gt; 0) {         {             uint balance = vars.sellToken.balanceOf(address(this));             vars.sellPool.borrowBehalf(msg.sender, borrow);             borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);         }          if (depositToken == longToken){             (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);             tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));         }else{             tv.borrowValue = borrow;         }     }      require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) &gt; vars.marginLimit, "MAM");     tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);     tv.depositAfterFees = deposit.sub(tv.fees);     tv.dexDetail = dexData.toDexDetail();      if (depositToken == longToken ){         if (borrowed &gt; 0){             tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);             tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);         }         tv.newHeld = tv.newHeld.add(tv.depositAfterFees);     }else{         tv.tradeSize = tv.depositAfterFees.add(borrowed);         tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);         tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);     }      Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];     tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);     trade.held = trade.held.add(tv.newHeld);     trade.depositToken = depositToken;     trade.deposited = trade.deposited.add(tv.depositAfterFees);     trade.lastBlockNum = uint128(block.number);      totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);      require(OpenLevV1Lib.isPositionHealthy(             msg.sender,             true,             OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),             vars,             dexData         ), "PNH");      emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail); }  /// @notice Close trade by shares. /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed. /// @param longToken Token to long. False for token0, true for token1. /// @param closeHeld Amount of shares to close. /// @param minOrMaxAmount Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {     Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];     Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);      //verify     verifyCloseBefore(trade, marketVars, closeHeld, dexData);      uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);      Types.CloseTradeVars memory closeTradeVars;     closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);     closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);     closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);     closeTradeVars.isPartialClose = closeHeld != trade.held;     closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);     closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);     closeTradeVars.dexDetail = dexData.toDexDetail();      //partial close     if (closeTradeVars.isPartialClose) {         closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);         closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);         trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);     } else {         closeTradeVars.depositDecrease = trade.deposited;     }      if (trade.depositToken != longToken) {         minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);         closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);         require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");          closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;         marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);          closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);         doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);     } else {         uint balance = marketVars.buyToken.balanceOf(address(this));         minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);         closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);         closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);         require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");          marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);         closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);         require(marketVars.sellToken.balanceOf(address(this)) &gt;= closeTradeVars.depositReturn, "ISB");         doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);     }      uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));     require(repayed &gt;= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");      if (!closeTradeVars.isPartialClose) {         delete activeTrades[msg.sender][marketId][longToken];     }else{         trade.held = trade.held.sub(closeHeld);         trade.lastBlockNum = uint128(block.number);     }      totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);      closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);     if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);     }      emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,         closeTradeVars.token0Price, closeTradeVars.dexDetail); }  /// @notice Liquidate if trade below margin limit. /// @dev For trades without sufficient funds to repay, use insurance. /// @param owner Owner of the trade to liquidate. /// @param longToken Token to long. False for token0, true for token1. /// @param minBuy Slippage for Dex trading. /// @param maxSell Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {     Types.Trade memory trade = activeTrades[owner][marketId][longToken];     Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);     if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);     }      verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());     uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);      (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);     require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");      Types.LiquidateVars memory liquidateVars;     liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);     liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);     if (liquidateVars.penalty &gt; 0) {         doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);     }     liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);     liquidateVars.dexDetail = dexData.toDexDetail();     liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);     liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);     liquidateVars.marketId = marketId;     liquidateVars.longToken = longToken;      bool buySuccess;     bytes memory sellAmountData;     if (longToken == trade.depositToken) {         maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);         marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);         (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(             abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],             taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)         );     }      if (buySuccess) {         {             uint temp;             assembly {                 temp := mload(add(sellAmountData, 0x20))             }             liquidateVars.sellAmount = temp;         }          liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);         marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);         liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);         doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);     } else {         liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;         liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);         if (liquidateVars.receiveAmount &gt;= liquidateVars.borrowed) {             // fail if buy failed but sell succeeded             require (longToken != trade.depositToken, "PH");             marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);             liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);             doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);         } else {             liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);             liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);             marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);         }     }      liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);     totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);      emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,         trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);      delete activeTrades[owner][marketId][longToken]; }  function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {     return open == longToken ?     Types.MarketVars(         market.pool1,         market.pool0,         IERC20(market.token1),         IERC20(market.token0),         IERC20(market.token1).balanceOf(address(this)),         IERC20(market.token0).balanceOf(address(this)),         market.pool1Insurance,         market.pool0Insurance,         market.marginLimit,         market.priceDiffientRatio,         market.dexs) :     Types.MarketVars(         market.pool0,         market.pool1,         IERC20(market.token0),         IERC20(market.token1),         IERC20(market.token0).balanceOf(address(this)),         IERC20(market.token1).balanceOf(address(this)),         market.pool0Insurance,         market.pool1Insurance,         market.marginLimit,         market.priceDiffientRatio,         market.dexs); }  /// @notice Get ratios of deposited token value to borrowed token value. /// @dev Caluclate ratio with current price and twap price. /// @param owner Owner of the trade to liquidate. /// @param longToken Token to long. False for token0, true for token1. /// @param dexData Index and fee rate for the trading Dex. /// @return current Margin ratio calculated using current price. /// @return cAvg Margin ratio calculated using twap price. /// @return hAvg Margin ratio calculated using last recorded twap price. /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value. function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {     Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);     limit = vars.marginLimit;     (current, cAvg, hAvg,,) =     OpenLevV1Lib.marginRatio(         owner,         activeTrades[owner][marketId][longToken].held,         address(vars.sellToken),         address(vars.buyToken),         vars.buyPool,         false,         dexData     ); }  /// @notice Check if a price update is required on Dex. /// @param dexData Index and fee rate for the trading Dex. function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){     Types.Market memory market = markets[marketId];     return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData); }  /// @notice Update price on Dex. /// @param dexData Index and fee rate for the trading Dex. function updatePrice(uint16 marketId, bytes memory dexData) external override {     OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData); }  /// @notice List of all supporting Dexes. function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){     return markets[marketId].dexs; }  function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {     Types.Market storage market = markets[marketId];     uint needed = totalRepayment.sub(remaining);     needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);     maxCanRepayAmount = totalRepayment;     if (longToken) {         if (market.pool0Insurance &gt;= needed) {             market.pool0Insurance = market.pool0Insurance - needed;             totalHelds[token] = totalHelds[token].sub(needed);         } else {             maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);             maxCanRepayAmount = maxCanRepayAmount.add(remaining);             totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);             market.pool0Insurance = 0;         }     } else {         if (market.pool1Insurance &gt;= needed) {             market.pool1Insurance = market.pool1Insurance - needed;         } else {             maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);             maxCanRepayAmount = maxCanRepayAmount.add(remaining);             totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);             market.pool1Insurance = 0;         }     } }  function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {     // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);     Types.Market storage market = markets[marketId];     uint defaultFees = tradeSize.mul(market.feesRate).div(10000);     uint newFees = defaultFees;     // if trader holds more xOLE, then should enjoy trading discount.     if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) &gt; calculateConfig.feesDiscountThreshold) {         newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));     }     // if trader update price, then should enjoy trading discount.     if (market.priceUpdater == trader) {         newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));     }     uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);     IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));      newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);     if (token == market.token1) {         market.pool1Insurance = market.pool1Insurance.add(newInsurance);     } else {         market.pool0Insurance = market.pool0Insurance.add(newInsurance);     }      totalHelds[token] = totalHelds[token].add(newInsurance);     return newFees; }  function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){     if (sellAmount &gt; 0){         DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;         IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);         buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);     } }  function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){     if (buyAmount &gt; 0){         DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;         IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);         sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);     } }  /// @dev All credited on this contract and share with all token holder if any rewards for the transfer. function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {     return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount); }  /// @dev All credited on "to" if any taxes for the transfer. function doTransferOut(address to, IERC20 token, uint amount) internal {     OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount); }  /*** Admin Functions ***/ function setCalculateConfig(uint16 defaultFeesRate,     uint8 insuranceRatio,     uint16 defaultMarginLimit,     uint16 priceDiffientRatio,     uint16 updatePriceDiscount,     uint16 feesDiscount,     uint128 feesDiscountThreshold,     uint16 penaltyRatio,     uint8 maxLiquidationPriceDiffientRatio,     uint16 twapDuration) external override onlyAdmin() {     OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,         feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);     emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration); }  function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {     OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);     emit NewAddressConfig(controller, address(dexAggregator)); }  function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {     OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);     emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs); }  /// @notice List of all supporting Dexes. /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1 function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {     Types.Market storage market = markets[marketId];     if (poolIndex == 0) {         market.pool0Insurance = market.pool0Insurance.sub(amount);         (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));         return;     }     market.pool1Insurance = market.pool1Insurance.sub(amount);     (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this)))); }  function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {     supportDexs[dex] = support; }  function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){     taxes[marketId][token][index] = tax; }  function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {     Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];     OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade); }  function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {     verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());     require(closeHeld &lt;= trade.held, "CBH"); }  function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {     require(held != 0 &amp;&amp; lastBlockNumber != block.number &amp;&amp; OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0"); }  modifier onlySupportDex(bytes memory dexData) {     require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");     _; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-24-08 18:28:08 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;

pragma experimental ABIEncoderV2;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "./OpenLevInterface.sol";
import "./Types.sol";
import "./Adminable.sol";
import "./DelegateInterface.sol";
import "./ControllerInterface.sol";
import "./IWETH.sol";
import "./XOLEInterface.sol";
import "./Types.sol";
import "./OpenLevV1Lib.sol";

/// @title OpenLeverage margin trade logic
/// @author OpenLeverage
/// @notice Use this contract for margin trade.
/// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE.
contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {
    using SafeMath for uint;
    using TransferHelper for IERC20;
    using DexData for bytes;

    constructor ()
    {
    }

    /// @notice initialize proxy contract
    /// @dev This function is not supposed to call multiple times. All configs can be set through other functions.
    /// @param _controller Address of contract ControllerDelegator.
    /// @param _dexAggregator contract DexAggregatorDelegator.
    /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens.
    /// @param _wETH Address of wrapped native coin.
    /// @param _xOLE Address of XOLEDelegator.
    /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol.
    function initialize(
        address _controller,
        DexAggregatorInterface _dexAggregator,
        address[] memory depositTokens,
        address _wETH,
        address _xOLE,
        uint8[] memory _supportDexs
    ) public {
        depositTokens;
        require(msg.sender == admin, "NAD");
        addressConfig.controller = _controller;
        addressConfig.dexAggregator = _dexAggregator;
        addressConfig.wETH = _wETH;
        addressConfig.xOLE = _xOLE;
        for (uint i = 0; i < _supportDexs.length; i++) {
            supportDexs[_supportDexs[i]] = true;
        }
        OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig);
    }

    /// @notice Create new trading pair.
    /// @dev This function is typically called by ControllerDelegator.
    /// @param pool0 Contract LpoolDelegator, lending pool of token0.
    /// @param pool1 Contract LpoolDelegator, lending pool of token1.
    /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value.
    /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens.
    /// @return The new created pair ID.
    function addMarket(
        LPoolInterface pool0,
        LPoolInterface pool1,
        uint16 marginLimit,
        bytes memory dexData
    ) external override returns (uint16) {
        uint16 marketId = numPairs;
        OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);
        numPairs ++;
        return marketId;
    }

    /// @notice Margin trade or just add more deposit tokens.
    /// @dev To support token with tax and reward. Stores share of all token balances of this contract.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param depositToken Token to deposit. False for token0, true for token1.
    /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported.
    /// @param borrow Amount of ERC20 to borrow from the short token pool.
    /// @param minBuyAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function marginTrade(
        uint16 marketId,
        bool longToken,
        bool depositToken,
        uint deposit,
        uint borrow,
        uint minBuyAmount,
        bytes memory dexData
    ) external payable override nonReentrant onlySupportDex(dexData) {
        Types.TradeVars memory tv;
        Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);
        verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);
        (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);

        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);
        }

        tv.totalHeld = totalHelds[address(vars.buyToken)];
        tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;

        deposit = transferIn(msg.sender, tv.depositErc20, deposit);

        // Borrow
        uint borrowed;
        if (borrow > 0) {
            {
                uint balance = vars.sellToken.balanceOf(address(this));
                vars.sellPool.borrowBehalf(msg.sender, borrow);
                borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);
            }

            if (depositToken == longToken){
                (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);
                tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));
            }else{
                tv.borrowValue = borrow;
            }
        }

        require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) > vars.marginLimit, "MAM");
        tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);
        tv.depositAfterFees = deposit.sub(tv.fees);
        tv.dexDetail = dexData.toDexDetail();

        if (depositToken == longToken ){
            if (borrowed > 0){
                tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);
                tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);
            }
            tv.newHeld = tv.newHeld.add(tv.depositAfterFees);
        }else{
            tv.tradeSize = tv.depositAfterFees.add(borrowed);
            tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);
            tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);
        }

        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);
        trade.held = trade.held.add(tv.newHeld);
        trade.depositToken = depositToken;
        trade.deposited = trade.deposited.add(tv.depositAfterFees);
        trade.lastBlockNum = uint128(block.number);

        totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);

        require(OpenLevV1Lib.isPositionHealthy(
                msg.sender,
                true,
                OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),
                vars,
                dexData
            ), "PNH");

        emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail);
    }

    /// @notice Close trade by shares.
    /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param closeHeld Amount of shares to close.
    /// @param minOrMaxAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);

        //verify
        verifyCloseBefore(trade, marketVars, closeHeld, dexData);

        uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        Types.CloseTradeVars memory closeTradeVars;
        closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);
        closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);
        closeTradeVars.isPartialClose = closeHeld != trade.held;
        closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);
        closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        closeTradeVars.dexDetail = dexData.toDexDetail();

        //partial close
        if (closeTradeVars.isPartialClose) {
            closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);
            closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);
            trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);
        } else {
            closeTradeVars.depositDecrease = trade.deposited;
        }

        if (trade.depositToken != longToken) {
            minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);
            closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;
            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);

            closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);
            doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);
        } else {
            uint balance = marketVars.buyToken.balanceOf(address(this));
            minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);
            closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);
            closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);
            closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);
            require(marketVars.sellToken.balanceOf(address(this)) >= closeTradeVars.depositReturn, "ISB");
            doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);
        }

        uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));
        require(repayed >= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");

        if (!closeTradeVars.isPartialClose) {
            delete activeTrades[msg.sender][marketId][longToken];
        }else{
            trade.held = trade.held.sub(closeHeld);
            trade.lastBlockNum = uint128(block.number);
        }

        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);

        closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,
            closeTradeVars.token0Price, closeTradeVars.dexDetail);
    }

    /// @notice Liquidate if trade below margin limit.
    /// @dev For trades without sufficient funds to repay, use insurance.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param minBuy Slippage for Dex trading.
    /// @param maxSell Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade memory trade = activeTrades[owner][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());
        uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);
        require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");

        Types.LiquidateVars memory liquidateVars;
        liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);
        if (liquidateVars.penalty > 0) {
            doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);
        }
        liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);
        liquidateVars.dexDetail = dexData.toDexDetail();
        liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);
        liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        liquidateVars.marketId = marketId;
        liquidateVars.longToken = longToken;

        bool buySuccess;
        bytes memory sellAmountData;
        if (longToken == trade.depositToken) {
            maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);
            marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);
            (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(
                abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],
                taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)
            );
        }

        if (buySuccess) {
            {
                uint temp;
                assembly {
                    temp := mload(add(sellAmountData, 0x20))
                }
                liquidateVars.sellAmount = temp;
            }

            liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);
            marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
            liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);
            doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);
        } else {
            liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;
            liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);
            if (liquidateVars.receiveAmount >= liquidateVars.borrowed) {
                // fail if buy failed but sell succeeded
                require (longToken != trade.depositToken, "PH");
                marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
                liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);
                doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);
            } else {
                liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);
                liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);
                marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);
            }
        }

        liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);
        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);

        emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,
            trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);

        delete activeTrades[owner][marketId][longToken];
    }

    function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {
        return open == longToken ?
        Types.MarketVars(
            market.pool1,
            market.pool0,
            IERC20(market.token1),
            IERC20(market.token0),
            IERC20(market.token1).balanceOf(address(this)),
            IERC20(market.token0).balanceOf(address(this)),
            market.pool1Insurance,
            market.pool0Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs) :
        Types.MarketVars(
            market.pool0,
            market.pool1,
            IERC20(market.token0),
            IERC20(market.token1),
            IERC20(market.token0).balanceOf(address(this)),
            IERC20(market.token1).balanceOf(address(this)),
            market.pool0Insurance,
            market.pool1Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs);
    }

    /// @notice Get ratios of deposited token value to borrowed token value.
    /// @dev Caluclate ratio with current price and twap price.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param dexData Index and fee rate for the trading Dex.
    /// @return current Margin ratio calculated using current price.
    /// @return cAvg Margin ratio calculated using twap price.
    /// @return hAvg Margin ratio calculated using last recorded twap price.
    /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value.
    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {
        Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);
        limit = vars.marginLimit;
        (current, cAvg, hAvg,,) =
        OpenLevV1Lib.marginRatio(
            owner,
            activeTrades[owner][marketId][longToken].held,
            address(vars.sellToken),
            address(vars.buyToken),
            vars.buyPool,
            false,
            dexData
        );
    }

    /// @notice Check if a price update is required on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){
        Types.Market memory market = markets[marketId];
        return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData);
    }

    /// @notice Update price on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function updatePrice(uint16 marketId, bytes memory dexData) external override {
        OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData);
    }

    /// @notice List of all supporting Dexes.
    function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){
        return markets[marketId].dexs;
    }

    function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {
        Types.Market storage market = markets[marketId];
        uint needed = totalRepayment.sub(remaining);
        needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);
        maxCanRepayAmount = totalRepayment;
        if (longToken) {
            if (market.pool0Insurance >= needed) {
                market.pool0Insurance = market.pool0Insurance - needed;
                totalHelds[token] = totalHelds[token].sub(needed);
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);
                market.pool0Insurance = 0;
            }
        } else {
            if (market.pool1Insurance >= needed) {
                market.pool1Insurance = market.pool1Insurance - needed;
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);
                market.pool1Insurance = 0;
            }
        }
    }

    function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {
        // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);
        Types.Market storage market = markets[marketId];
        uint defaultFees = tradeSize.mul(market.feesRate).div(10000);
        uint newFees = defaultFees;
        // if trader holds more xOLE, then should enjoy trading discount.
        if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) > calculateConfig.feesDiscountThreshold) {
            newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));
        }
        // if trader update price, then should enjoy trading discount.
        if (market.priceUpdater == trader) {
            newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));
        }
        uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);
        IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));

        newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);
        if (token == market.token1) {
            market.pool1Insurance = market.pool1Insurance.add(newInsurance);
        } else {
            market.pool0Insurance = market.pool0Insurance.add(newInsurance);
        }

        totalHelds[token] = totalHelds[token].add(newInsurance);
        return newFees;
    }

    function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){
        if (sellAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);
            buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);
        }
    }

    function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){
        if (buyAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);
            sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);
        }
    }

    /// @dev All credited on this contract and share with all token holder if any rewards for the transfer.
    function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {
        return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount);
    }

    /// @dev All credited on "to" if any taxes for the transfer.
    function doTransferOut(address to, IERC20 token, uint amount) internal {
        OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount);
    }

    /*** Admin Functions ***/
    function setCalculateConfig(uint16 defaultFeesRate,
        uint8 insuranceRatio,
        uint16 defaultMarginLimit,
        uint16 priceDiffientRatio,
        uint16 updatePriceDiscount,
        uint16 feesDiscount,
        uint128 feesDiscountThreshold,
        uint16 penaltyRatio,
        uint8 maxLiquidationPriceDiffientRatio,
        uint16 twapDuration) external override onlyAdmin() {
        OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,
            feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);
        emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration);
    }

    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {
        OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);
        emit NewAddressConfig(controller, address(dexAggregator));
    }

    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {
        OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);
        emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs);
    }

    /// @notice List of all supporting Dexes.
    /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1
    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {
        Types.Market storage market = markets[marketId];
        if (poolIndex == 0) {
            market.pool0Insurance = market.pool0Insurance.sub(amount);
            (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));
            return;
        }
        market.pool1Insurance = market.pool1Insurance.sub(amount);
        (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this))));
    }

    function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {
        supportDexs[dex] = support;
    }

    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){
        taxes[marketId][token][index] = tax;
    }

    function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {
        Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];
        OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade);
    }

    function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {
        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());
        require(closeHeld <= trade.held, "CBH");
    }

    function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {
        require(held != 0 && lastBlockNumber != block.number && OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0");
    }

    modifier onlySupportDex(bytes memory dexData) {
        require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");
        _;
    }
}.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;

pragma experimental ABIEncoderV2;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "./OpenLevInterface.sol";
import "./Types.sol";
import "./Adminable.sol";
import "./DelegateInterface.sol";
import "./ControllerInterface.sol";
import "./IWETH.sol";
import "./XOLEInterface.sol";
import "./Types.sol";
import "./OpenLevV1Lib.sol";

/// @title OpenLeverage margin trade logic
/// @author OpenLeverage
/// @notice Use this contract for margin trade.
/// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE.
contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {
    using SafeMath for uint;
    using TransferHelper for IERC20;
    using DexData for bytes;

    constructor ()
    {
    }

    /// @notice initialize proxy contract
    /// @dev This function is not supposed to call multiple times. All configs can be set through other functions.
    /// @param _controller Address of contract ControllerDelegator.
    /// @param _dexAggregator contract DexAggregatorDelegator.
    /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens.
    /// @param _wETH Address of wrapped native coin.
    /// @param _xOLE Address of XOLEDelegator.
    /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol.
    function initialize(
        address _controller,
        DexAggregatorInterface _dexAggregator,
        address[] memory depositTokens,
        address _wETH,
        address _xOLE,
        uint8[] memory _supportDexs
    ) public {
        depositTokens;
        require(msg.sender == admin, "NAD");
        addressConfig.controller = _controller;
        addressConfig.dexAggregator = _dexAggregator;
        addressConfig.wETH = _wETH;
        addressConfig.xOLE = _xOLE;
        for (uint i = 0; i < _supportDexs.length; i++) {
            supportDexs[_supportDexs[i]] = true;
        }
        OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig);
    }

    /// @notice Create new trading pair.
    /// @dev This function is typically called by ControllerDelegator.
    /// @param pool0 Contract LpoolDelegator, lending pool of token0.
    /// @param pool1 Contract LpoolDelegator, lending pool of token1.
    /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value.
    /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens.
    /// @return The new created pair ID.
    function addMarket(
        LPoolInterface pool0,
        LPoolInterface pool1,
        uint16 marginLimit,
        bytes memory dexData
    ) external override returns (uint16) {
        uint16 marketId = numPairs;
        OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);
        numPairs ++;
        return marketId;
    }

    /// @notice Margin trade or just add more deposit tokens.
    /// @dev To support token with tax and reward. Stores share of all token balances of this contract.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param depositToken Token to deposit. False for token0, true for token1.
    /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported.
    /// @param borrow Amount of ERC20 to borrow from the short token pool.
    /// @param minBuyAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function marginTrade(
        uint16 marketId,
        bool longToken,
        bool depositToken,
        uint deposit,
        uint borrow,
        uint minBuyAmount,
        bytes memory dexData
    ) external payable override nonReentrant onlySupportDex(dexData) {
        Types.TradeVars memory tv;
        Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);
        verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);
        (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);

        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);
        }

        tv.totalHeld = totalHelds[address(vars.buyToken)];
        tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;

        deposit = transferIn(msg.sender, tv.depositErc20, deposit);

        // Borrow
        uint borrowed;
        if (borrow > 0) {
            {
                uint balance = vars.sellToken.balanceOf(address(this));
                vars.sellPool.borrowBehalf(msg.sender, borrow);
                borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);
            }

            if (depositToken == longToken){
                (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);
                tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));
            }else{
                tv.borrowValue = borrow;
            }
        }

        require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) > vars.marginLimit, "MAM");
        tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);
        tv.depositAfterFees = deposit.sub(tv.fees);
        tv.dexDetail = dexData.toDexDetail();

        if (depositToken == longToken ){
            if (borrowed > 0){
                tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);
                tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);
            }
            tv.newHeld = tv.newHeld.add(tv.depositAfterFees);
        }else{
            tv.tradeSize = tv.depositAfterFees.add(borrowed);
            tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);
            tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);
        }

        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);
        trade.held = trade.held.add(tv.newHeld);
        trade.depositToken = depositToken;
        trade.deposited = trade.deposited.add(tv.depositAfterFees);
        trade.lastBlockNum = uint128(block.number);

        totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);

        require(OpenLevV1Lib.isPositionHealthy(
                msg.sender,
                true,
                OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),
                vars,
                dexData
            ), "PNH");

        emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail);
    }

    /// @notice Close trade by shares.
    /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param closeHeld Amount of shares to close.
    /// @param minOrMaxAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);

        //verify
        verifyCloseBefore(trade, marketVars, closeHeld, dexData);

        uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        Types.CloseTradeVars memory closeTradeVars;
        closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);
        closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);
        closeTradeVars.isPartialClose = closeHeld != trade.held;
        closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);
        closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        closeTradeVars.dexDetail = dexData.toDexDetail();

        //partial close
        if (closeTradeVars.isPartialClose) {
            closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);
            closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);
            trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);
        } else {
            closeTradeVars.depositDecrease = trade.deposited;
        }

        if (trade.depositToken != longToken) {
            minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);
            closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;
            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);

            closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);
            doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);
        } else {
            uint balance = marketVars.buyToken.balanceOf(address(this));
            minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);
            closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);
            closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);
            closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);
            require(marketVars.sellToken.balanceOf(address(this)) >= closeTradeVars.depositReturn, "ISB");
            doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);
        }

        uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));
        require(repayed >= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");

        if (!closeTradeVars.isPartialClose) {
            delete activeTrades[msg.sender][marketId][longToken];
        }else{
            trade.held = trade.held.sub(closeHeld);
            trade.lastBlockNum = uint128(block.number);
        }

        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);

        closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,
            closeTradeVars.token0Price, closeTradeVars.dexDetail);
    }

    /// @notice Liquidate if trade below margin limit.
    /// @dev For trades without sufficient funds to repay, use insurance.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param minBuy Slippage for Dex trading.
    /// @param maxSell Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade memory trade = activeTrades[owner][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());
        uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);
        require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");

        Types.LiquidateVars memory liquidateVars;
        liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);
        if (liquidateVars.penalty > 0) {
            doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);
        }
        liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);
        liquidateVars.dexDetail = dexData.toDexDetail();
        liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);
        liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        liquidateVars.marketId = marketId;
        liquidateVars.longToken = longToken;

        bool buySuccess;
        bytes memory sellAmountData;
        if (longToken == trade.depositToken) {
            maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);
            marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);
            (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(
                abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],
                taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)
            );
        }

        if (buySuccess) {
            {
                uint temp;
                assembly {
                    temp := mload(add(sellAmountData, 0x20))
                }
                liquidateVars.sellAmount = temp;
            }

            liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);
            marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
            liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);
            doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);
        } else {
            liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;
            liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);
            if (liquidateVars.receiveAmount >= liquidateVars.borrowed) {
                // fail if buy failed but sell succeeded
                require (longToken != trade.depositToken, "PH");
                marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
                liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);
                doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);
            } else {
                liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);
                liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);
                marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);
            }
        }

        liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);
        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);

        emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,
            trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);

        delete activeTrades[owner][marketId][longToken];
    }

    function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {
        return open == longToken ?
        Types.MarketVars(
            market.pool1,
            market.pool0,
            IERC20(market.token1),
            IERC20(market.token0),
            IERC20(market.token1).balanceOf(address(this)),
            IERC20(market.token0).balanceOf(address(this)),
            market.pool1Insurance,
            market.pool0Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs) :
        Types.MarketVars(
            market.pool0,
            market.pool1,
            IERC20(market.token0),
            IERC20(market.token1),
            IERC20(market.token0).balanceOf(address(this)),
            IERC20(market.token1).balanceOf(address(this)),
            market.pool0Insurance,
            market.pool1Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs);
    }

    /// @notice Get ratios of deposited token value to borrowed token value.
    /// @dev Caluclate ratio with current price and twap price.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param dexData Index and fee rate for the trading Dex.
    /// @return current Margin ratio calculated using current price.
    /// @return cAvg Margin ratio calculated using twap price.
    /// @return hAvg Margin ratio calculated using last recorded twap price.
    /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value.
    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {
        Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);
        limit = vars.marginLimit;
        (current, cAvg, hAvg,,) =
        OpenLevV1Lib.marginRatio(
            owner,
            activeTrades[owner][marketId][longToken].held,
            address(vars.sellToken),
            address(vars.buyToken),
            vars.buyPool,
            false,
            dexData
        );
    }

    /// @notice Check if a price update is required on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){
        Types.Market memory market = markets[marketId];
        return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData);
    }

    /// @notice Update price on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function updatePrice(uint16 marketId, bytes memory dexData) external override {
        OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData);
    }

    /// @notice List of all supporting Dexes.
    function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){
        return markets[marketId].dexs;
    }

    function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {
        Types.Market storage market = markets[marketId];
        uint needed = totalRepayment.sub(remaining);
        needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);
        maxCanRepayAmount = totalRepayment;
        if (longToken) {
            if (market.pool0Insurance >= needed) {
                market.pool0Insurance = market.pool0Insurance - needed;
                totalHelds[token] = totalHelds[token].sub(needed);
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);
                market.pool0Insurance = 0;
            }
        } else {
            if (market.pool1Insurance >= needed) {
                market.pool1Insurance = market.pool1Insurance - needed;
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);
                market.pool1Insurance = 0;
            }
        }
    }

    function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {
        // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);
        Types.Market storage market = markets[marketId];
        uint defaultFees = tradeSize.mul(market.feesRate).div(10000);
        uint newFees = defaultFees;
        // if trader holds more xOLE, then should enjoy trading discount.
        if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) > calculateConfig.feesDiscountThreshold) {
            newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));
        }
        // if trader update price, then should enjoy trading discount.
        if (market.priceUpdater == trader) {
            newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));
        }
        uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);
        IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));

        newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);
        if (token == market.token1) {
            market.pool1Insurance = market.pool1Insurance.add(newInsurance);
        } else {
            market.pool0Insurance = market.pool0Insurance.add(newInsurance);
        }

        totalHelds[token] = totalHelds[token].add(newInsurance);
        return newFees;
    }

    function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){
        if (sellAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);
            buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);
        }
    }

    function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){
        if (buyAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);
            sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);
        }
    }

    /// @dev All credited on this contract and share with all token holder if any rewards for the transfer.
    function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {
        return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount);
    }

    /// @dev All credited on "to" if any taxes for the transfer.
    function doTransferOut(address to, IERC20 token, uint amount) internal {
        OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount);
    }

    /*** Admin Functions ***/
    function setCalculateConfig(uint16 defaultFeesRate,
        uint8 insuranceRatio,
        uint16 defaultMarginLimit,
        uint16 priceDiffientRatio,
        uint16 updatePriceDiscount,
        uint16 feesDiscount,
        uint128 feesDiscountThreshold,
        uint16 penaltyRatio,
        uint8 maxLiquidationPriceDiffientRatio,
        uint16 twapDuration) external override onlyAdmin() {
        OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,
            feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);
        emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration);
    }

    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {
        OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);
        emit NewAddressConfig(controller, address(dexAggregator));
    }

    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {
        OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);
        emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs);
    }

    /// @notice List of all supporting Dexes.
    /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1
    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {
        Types.Market storage market = markets[marketId];
        if (poolIndex == 0) {
            market.pool0Insurance = market.pool0Insurance.sub(amount);
            (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));
            return;
        }
        market.pool1Insurance = market.pool1Insurance.sub(amount);
        (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this))));
    }

    function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {
        supportDexs[dex] = support;
    }

    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){
        taxes[marketId][token][index] = tax;
    }

    function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {
        Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];
        OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade);
    }

    function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {
        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());
        require(closeHeld <= trade.held, "CBH");
    }

    function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {
        require(held != 0 && lastBlockNumber != block.number && OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0");
    }

    modifier onlySupportDex(bytes memory dexData) {
        require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");
        _;
    }
}".
Ideas: " 1".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-24-08 18:28:19 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-24-08 18:28:19 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 13711
completion_tokens: 964
total_tokens: 14675
cost: $-1.000000


[2024-24-08 18:28:19 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;

pragma experimental ABIEncoderV2;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "./OpenLevInterface.sol";
import "./Types.sol";
import "./Adminable.sol";
import "./DelegateInterface.sol";
import "./ControllerInterface.sol";
import "./IWETH.sol";
import "./XOLEInterface.sol";
import "./Types.sol";
import "./OpenLevV1Lib.sol";

/// @title OpenLeverage margin trade logic
/// @author OpenLeverage
/// @notice Use this contract for margin trade.
/// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE.
contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {
    using SafeMath for uint;
    using TransferHelper for IERC20;
    using DexData for bytes;

    constructor ()
    {
    }

    /// @notice initialize proxy contract
    /// @dev This function is not supposed to call multiple times. All configs can be set through other functions.
    /// @param _controller Address of contract ControllerDelegator.
    /// @param _dexAggregator contract DexAggregatorDelegator.
    /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens.
    /// @param _wETH Address of wrapped native coin.
    /// @param _xOLE Address of XOLEDelegator.
    /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol.
    function initialize(
        address _controller,
        DexAggregatorInterface _dexAggregator,
        address[] memory depositTokens,
        address _wETH,
        address _xOLE,
        uint8[] memory _supportDexs
    ) public {
        depositTokens;
        require(msg.sender == admin, "NAD");
        addressConfig.controller = _controller;
        addressConfig.dexAggregator = _dexAggregator;
        addressConfig.wETH = _wETH;
        addressConfig.xOLE = _xOLE;
        for (uint i = 0; i < _supportDexs.length; i++) {
            supportDexs[_supportDexs[i]] = true;
        }
        OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig);
    }

    /// @notice Create new trading pair.
    /// @dev This function is typically called by ControllerDelegator.
    /// @param pool0 Contract LpoolDelegator, lending pool of token0.
    /// @param pool1 Contract LpoolDelegator, lending pool of token1.
    /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value.
    /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens.
    /// @return The new created pair ID.
    function addMarket(
        LPoolInterface pool0,
        LPoolInterface pool1,
        uint16 marginLimit,
        bytes memory dexData
    ) external override returns (uint16) {
        uint16 marketId = numPairs;
        OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);
        numPairs ++;
        return marketId;
    }

    /// @notice Margin trade or just add more deposit tokens.
    /// @dev To support token with tax and reward. Stores share of all token balances of this contract.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param depositToken Token to deposit. False for token0, true for token1.
    /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported.
    /// @param borrow Amount of ERC20 to borrow from the short token pool.
    /// @param minBuyAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function marginTrade(
        uint16 marketId,
        bool longToken,
        bool depositToken,
        uint deposit,
        uint borrow,
        uint minBuyAmount,
        bytes memory dexData
    ) external payable override nonReentrant onlySupportDex(dexData) {
        Types.TradeVars memory tv;
        Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);
        verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);
        (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);

        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);
        }

        tv.totalHeld = totalHelds[address(vars.buyToken)];
        tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;

        deposit = transferIn(msg.sender, tv.depositErc20, deposit);

        // Borrow
        uint borrowed;
        if (borrow > 0) {
            {
                uint balance = vars.sellToken.balanceOf(address(this));
                vars.sellPool.borrowBehalf(msg.sender, borrow);
                borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);
            }

            if (depositToken == longToken){
                (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);
                tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));
            }else{
                tv.borrowValue = borrow;
            }
        }

        require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) > vars.marginLimit, "MAM");
        tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);
        tv.depositAfterFees = deposit.sub(tv.fees);
        tv.dexDetail = dexData.toDexDetail();

        if (depositToken == longToken ){
            if (borrowed > 0){
                tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);
                tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);
            }
            tv.newHeld = tv.newHeld.add(tv.depositAfterFees);
        }else{
            tv.tradeSize = tv.depositAfterFees.add(borrowed);
            tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);
            tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);
        }

        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);
        trade.held = trade.held.add(tv.newHeld);
        trade.depositToken = depositToken;
        trade.deposited = trade.deposited.add(tv.depositAfterFees);
        trade.lastBlockNum = uint128(block.number);

        totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);

        require(OpenLevV1Lib.isPositionHealthy(
                msg.sender,
                true,
                OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),
                vars,
                dexData
            ), "PNH");

        emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail);
    }

    /// @notice Close trade by shares.
    /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param closeHeld Amount of shares to close.
    /// @param minOrMaxAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);

        //verify
        verifyCloseBefore(trade, marketVars, closeHeld, dexData);

        uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        Types.CloseTradeVars memory closeTradeVars;
        closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);
        closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);
        closeTradeVars.isPartialClose = closeHeld != trade.held;
        closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);
        closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        closeTradeVars.dexDetail = dexData.toDexDetail();

        //partial close
        if (closeTradeVars.isPartialClose) {
            closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);
            closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);
            trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);
        } else {
            closeTradeVars.depositDecrease = trade.deposited;
        }

        if (trade.depositToken != longToken) {
            minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);
            closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;
            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);

            closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);
            doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);
        } else {
            uint balance = marketVars.buyToken.balanceOf(address(this));
            minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);
            closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);
            closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);
            closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);
            require(marketVars.sellToken.balanceOf(address(this)) >= closeTradeVars.depositReturn, "ISB");
            doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);
        }

        uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));
        require(repayed >= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");

        if (!closeTradeVars.isPartialClose) {
            delete activeTrades[msg.sender][marketId][longToken];
        }else{
            trade.held = trade.held.sub(closeHeld);
            trade.lastBlockNum = uint128(block.number);
        }

        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);

        closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,
            closeTradeVars.token0Price, closeTradeVars.dexDetail);
    }

    /// @notice Liquidate if trade below margin limit.
    /// @dev For trades without sufficient funds to repay, use insurance.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param minBuy Slippage for Dex trading.
    /// @param maxSell Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade memory trade = activeTrades[owner][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());
        uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);
        require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");

        Types.LiquidateVars memory liquidateVars;
        liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);
        if (liquidateVars.penalty > 0) {
            doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);
        }
        liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);
        liquidateVars.dexDetail = dexData.toDexDetail();
        liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);
        liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        liquidateVars.marketId = marketId;
        liquidateVars.longToken = longToken;

        bool buySuccess;
        bytes memory sellAmountData;
        if (longToken == trade.depositToken) {
            maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);
            marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);
            (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(
                abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],
                taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)
            );
        }

        if (buySuccess) {
            {
                uint temp;
                assembly {
                    temp := mload(add(sellAmountData, 0x20))
                }
                liquidateVars.sellAmount = temp;
            }

            liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);
            marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
            liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);
            doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);
        } else {
            liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;
            liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);
            if (liquidateVars.receiveAmount >= liquidateVars.borrowed) {
                // fail if buy failed but sell succeeded
                require (longToken != trade.depositToken, "PH");
                marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
                liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);
                doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);
            } else {
                liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);
                liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);
                marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);
            }
        }

        liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);
        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);

        emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,
            trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);

        delete activeTrades[owner][marketId][longToken];
    }

    function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {
        return open == longToken ?
        Types.MarketVars(
            market.pool1,
            market.pool0,
            IERC20(market.token1),
            IERC20(market.token0),
            IERC20(market.token1).balanceOf(address(this)),
            IERC20(market.token0).balanceOf(address(this)),
            market.pool1Insurance,
            market.pool0Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs) :
        Types.MarketVars(
            market.pool0,
            market.pool1,
            IERC20(market.token0),
            IERC20(market.token1),
            IERC20(market.token0).balanceOf(address(this)),
            IERC20(market.token1).balanceOf(address(this)),
            market.pool0Insurance,
            market.pool1Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs);
    }

    /// @notice Get ratios of deposited token value to borrowed token value.
    /// @dev Caluclate ratio with current price and twap price.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param dexData Index and fee rate for the trading Dex.
    /// @return current Margin ratio calculated using current price.
    /// @return cAvg Margin ratio calculated using twap price.
    /// @return hAvg Margin ratio calculated using last recorded twap price.
    /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value.
    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {
        Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);
        limit = vars.marginLimit;
        (current, cAvg, hAvg,,) =
        OpenLevV1Lib.marginRatio(
            owner,
            activeTrades[owner][marketId][longToken].held,
            address(vars.sellToken),
            address(vars.buyToken),
            vars.buyPool,
            false,
            dexData
        );
    }

    /// @notice Check if a price update is required on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){
        Types.Market memory market = markets[marketId];
        return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData);
    }

    /// @notice Update price on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function updatePrice(uint16 marketId, bytes memory dexData) external override {
        OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData);
    }

    /// @notice List of all supporting Dexes.
    function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){
        return markets[marketId].dexs;
    }

    function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {
        Types.Market storage market = markets[marketId];
        uint needed = totalRepayment.sub(remaining);
        needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);
        maxCanRepayAmount = totalRepayment;
        if (longToken) {
            if (market.pool0Insurance >= needed) {
                market.pool0Insurance = market.pool0Insurance - needed;
                totalHelds[token] = totalHelds[token].sub(needed);
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);
                market.pool0Insurance = 0;
            }
        } else {
            if (market.pool1Insurance >= needed) {
                market.pool1Insurance = market.pool1Insurance - needed;
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);
                market.pool1Insurance = 0;
            }
        }
    }

    function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {
        // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);
        Types.Market storage market = markets[marketId];
        uint defaultFees = tradeSize.mul(market.feesRate).div(10000);
        uint newFees = defaultFees;
        // if trader holds more xOLE, then should enjoy trading discount.
        if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) > calculateConfig.feesDiscountThreshold) {
            newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));
        }
        // if trader update price, then should enjoy trading discount.
        if (market.priceUpdater == trader) {
            newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));
        }
        uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);
        IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));

        newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);
        if (token == market.token1) {
            market.pool1Insurance = market.pool1Insurance.add(newInsurance);
        } else {
            market.pool0Insurance = market.pool0Insurance.add(newInsurance);
        }

        totalHelds[token] = totalHelds[token].add(newInsurance);
        return newFees;
    }

    function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){
        if (sellAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);
            buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);
        }
    }

    function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){
        if (buyAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);
            sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);
        }
    }

    /// @dev All credited on this contract and share with all token holder if any rewards for the transfer.
    function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {
        return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount);
    }

    /// @dev All credited on "to" if any taxes for the transfer.
    function doTransferOut(address to, IERC20 token, uint amount) internal {
        OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount);
    }

    /*** Admin Functions ***/
    function setCalculateConfig(uint16 defaultFeesRate,
        uint8 insuranceRatio,
        uint16 defaultMarginLimit,
        uint16 priceDiffientRatio,
        uint16 updatePriceDiscount,
        uint16 feesDiscount,
        uint128 feesDiscountThreshold,
        uint16 penaltyRatio,
        uint8 maxLiquidationPriceDiffientRatio,
        uint16 twapDuration) external override onlyAdmin() {
        OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,
            feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);
        emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration);
    }

    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {
        OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);
        emit NewAddressConfig(controller, address(dexAggregator));
    }

    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {
        OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);
        emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs);
    }

    /// @notice List of all supporting Dexes.
    /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1
    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {
        Types.Market storage market = markets[marketId];
        if (poolIndex == 0) {
            market.pool0Insurance = market.pool0Insurance.sub(amount);
            (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));
            return;
        }
        market.pool1Insurance = market.pool1Insurance.sub(amount);
        (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this))));
    }

    function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {
        supportDexs[dex] = support;
    }

    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){
        taxes[marketId][token][index] = tax;
    }

    function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {
        Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];
        OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade);
    }

    function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {
        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());
        require(closeHeld <= trade.held, "CBH");
    }

    function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {
        require(held != 0 && lastBlockNumber != block.number && OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0");
    }

    modifier onlySupportDex(bytes memory dexData) {
        require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");
        _;
    }
}.]

### VULNERABILITY: Reentrancy Attack
```
DETAILED DESCRIPTION: The contract uses the `nonReentrant` modifier from the `ReentrancyGuard` contract to prevent reentrancy attacks. However, there are still areas in the `marginTrade`, `closeTrade`, and `liquidate` functions where external calls are made before state changes. If an attacker can manipulate the flow of funds through these external calls, they could potentially exploit the contract.

RECOMMENDED MITIGATION: Ensure that all state changes are made before any external calls. This can be achieved by reordering the logic in these functions to update the state first and then perform any external calls. Additionally, consider using checks-effects-interactions pattern consistently throughout the contract.
```

### VULNERABILITY: Lack of Input Validation
```
DETAILED DESCRIPTION: Several functions, such as `marginTrade`, `closeTrade`, and `liquidate`, do not adequately validate input parameters. For instance, the `borrow` amount in `marginTrade` is not checked against the available balance or the maximum allowable limit, which could lead to unexpected behavior or excessive borrowing.

RECOMMENDED MITIGATION: Implement input validation checks to ensure that all parameters are within acceptable limits. For example, check that `borrow` does not exceed the available balance in the pool and that `deposit` amounts are positive and within the expected range.
```

### VULNERABILITY: Arithmetic Underflow/Overflow
```
DETAILED DESCRIPTION: Although the contract uses the `SafeMath` library to prevent arithmetic overflows and underflows, there are still areas where arithmetic operations could lead to unexpected results if not handled properly. For example, in the `feesAndInsurance` function, if `tradeSize` is zero, it could lead to division by zero when calculating `defaultFees`.

RECOMMENDED MITIGATION: Ensure that all arithmetic operations are safeguarded by checks that prevent division by zero and that inputs are validated before performing calculations. Consider using `SafeMath` consistently across all arithmetic operations.
```

### VULNERABILITY: Improper Access Control
```
DETAILED DESCRIPTION: The contract relies on the `onlyAdmin` modifier for critical functions such as `setCalculateConfig`, `setAddressConfig`, and `moveInsurance`. If the admin key is compromised, an attacker could manipulate the contract's configuration and potentially drain funds.

RECOMMENDED MITIGATION: Implement a multi-signature wallet for admin functions to ensure that critical changes require approval from multiple parties. Additionally, consider implementing time-lock mechanisms for sensitive operations to provide a window for users to react to potential malicious actions.
```

### VULNERABILITY: Insufficient Liquidation Mechanism
```
DETAILED DESCRIPTION: The liquidation mechanism in the `liquidate` function may not adequately protect against market volatility. If the market price changes significantly during the liquidation process, it could lead to insufficient funds being available to cover the borrowed amount.

RECOMMENDED MITIGATION: Enhance the liquidation logic to include price oracles that provide real-time price feeds. This will help ensure that liquidations are executed at fair market prices and reduce the risk of losses due to price slippage.
```

### VULNERABILITY: Gas Limit Issues
```
DETAILED DESCRIPTION: The contract performs multiple operations in a single transaction, which could lead to exceeding the gas limit, especially during complex operations like `marginTrade` or `liquidate`. If the gas limit is exceeded, the transaction will fail, potentially locking funds.

RECOMMENDED MITIGATION: Break down complex functions into smaller, more manageable functions that can be called separately. This will help ensure that each transaction remains within the gas limit and can be executed successfully.
```

### VULNERABILITY: Lack of Event Emission
```
DETAILED DESCRIPTION: While some functions emit events, others do not, such as `addMarket` and `setMarketConfig`. This lack of event emission can make it difficult to track changes and actions taken on the contract, which is crucial for transparency and auditing.

RECOMMENDED MITIGATION: Ensure that all state-changing functions emit appropriate events to log significant actions. This will improve the contract's transparency and allow for better tracking of its state changes.
```

### VULNERABILITY: Potential for Front-Running
```
DETAILED DESCRIPTION: The contract does not implement any mechanisms to prevent front-running attacks, where an attacker could observe pending transactions and place their own transactions with higher gas prices to gain an advantage.

RECOMMENDED MITIGATION: Consider implementing commit-reveal schemes or other mechanisms to obscure transaction details until they are finalized. This will help mitigate the risk of front-running attacks.
```

<INFO> Analysis Complete.

[2024-24-08 18:28:19 INFO] **[Seminar Conclusion]**:

 ### VULNERABILITY: Reentrancy Attack
```
DETAILED DESCRIPTION: The contract uses the `nonReentrant` modifier from the `ReentrancyGuard` contract to prevent reentrancy attacks. However, there are still areas in the `marginTrade`, `closeTrade`, and `liquidate` functions where external calls are made before state changes. If an attacker can manipulate the flow of funds through these external calls, they could potentially exploit the contract.

RECOMMENDED MITIGATION: Ensure that all state changes are made before any external calls. This can be achieved by reordering the logic in these functions to update the state first and then perform any external calls. Additionally, consider using checks-effects-interactions pattern consistently throughout the contract.
```

### VULNERABILITY: Lack of Input Validation
```
DETAILED DESCRIPTION: Several functions, such as `marginTrade`, `closeTrade`, and `liquidate`, do not adequately validate input parameters. For instance, the `borrow` amount in `marginTrade` is not checked against the available balance or the maximum allowable limit, which could lead to unexpected behavior or excessive borrowing.

RECOMMENDED MITIGATION: Implement input validation checks to ensure that all parameters are within acceptable limits. For example, check that `borrow` does not exceed the available balance in the pool and that `deposit` amounts are positive and within the expected range.
```

### VULNERABILITY: Arithmetic Underflow/Overflow
```
DETAILED DESCRIPTION: Although the contract uses the `SafeMath` library to prevent arithmetic overflows and underflows, there are still areas where arithmetic operations could lead to unexpected results if not handled properly. For example, in the `feesAndInsurance` function, if `tradeSize` is zero, it could lead to division by zero when calculating `defaultFees`.

RECOMMENDED MITIGATION: Ensure that all arithmetic operations are safeguarded by checks that prevent division by zero and that inputs are validated before performing calculations. Consider using `SafeMath` consistently across all arithmetic operations.
```

### VULNERABILITY: Improper Access Control
```
DETAILED DESCRIPTION: The contract relies on the `onlyAdmin` modifier for critical functions such as `setCalculateConfig`, `setAddressConfig`, and `moveInsurance`. If the admin key is compromised, an attacker could manipulate the contract's configuration and potentially drain funds.

RECOMMENDED MITIGATION: Implement a multi-signature wallet for admin functions to ensure that critical changes require approval from multiple parties. Additionally, consider implementing time-lock mechanisms for sensitive operations to provide a window for users to react to potential malicious actions.
```

### VULNERABILITY: Insufficient Liquidation Mechanism
```
DETAILED DESCRIPTION: The liquidation mechanism in the `liquidate` function may not adequately protect against market volatility. If the market price changes significantly during the liquidation process, it could lead to insufficient funds being available to cover the borrowed amount.

RECOMMENDED MITIGATION: Enhance the liquidation logic to include price oracles that provide real-time price feeds. This will help ensure that liquidations are executed at fair market prices and reduce the risk of losses due to price slippage.
```

### VULNERABILITY: Gas Limit Issues
```
DETAILED DESCRIPTION: The contract performs multiple operations in a single transaction, which could lead to exceeding the gas limit, especially during complex operations like `marginTrade` or `liquidate`. If the gas limit is exceeded, the transaction will fail, potentially locking funds.

RECOMMENDED MITIGATION: Break down complex functions into smaller, more manageable functions that can be called separately. This will help ensure that each transaction remains within the gas limit and can be executed successfully.
```

### VULNERABILITY: Lack of Event Emission
```
DETAILED DESCRIPTION: While some functions emit events, others do not, such as `addMarket` and `setMarketConfig`. This lack of event emission can make it difficult to track changes and actions taken on the contract, which is crucial for transparency and auditing.

RECOMMENDED MITIGATION: Ensure that all state-changing functions emit appropriate events to log significant actions. This will improve the contract's transparency and allow for better tracking of its state changes.
```

### VULNERABILITY: Potential for Front-Running
```
DETAILED DESCRIPTION: The contract does not implement any mechanisms to prevent front-running attacks, where an attacker could observe pending transactions and place their own transactions with higher gas prices to gain an advantage.

RECOMMENDED MITIGATION: Consider implementing commit-reveal schemes or other mechanisms to obscure transaction details until they are finalized. This will help mitigate the risk of front-running attacks.
```

<INFO> Analysis Complete.

[2024-24-08 18:28:19 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-24-08 18:28:19 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.7.6; pragma experimental ABIEncoderV2; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import "./OpenLevInterface.sol"; import "./Types.sol"; import "./Adminable.sol"; import "./DelegateInterface.sol"; import "./ControllerInterface.sol"; import "./IWETH.sol"; import "./XOLEInterface.sol"; import "./Types.sol"; import "./OpenLevV1Lib.sol"; /// @title OpenLeverage margin trade logic /// @author OpenLeverage /// @notice Use this contract for margin trade. /// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE. contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {     using SafeMath for uint;     using TransferHelper for IERC20;     using DexData for bytes; constructor () { }  /// @notice initialize proxy contract /// @dev This function is not supposed to call multiple times. All configs can be set through other functions. /// @param _controller Address of contract ControllerDelegator. /// @param _dexAggregator contract DexAggregatorDelegator. /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens. /// @param _wETH Address of wrapped native coin. /// @param _xOLE Address of XOLEDelegator. /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol. function initialize(     address _controller,     DexAggregatorInterface _dexAggregator,     address[] memory depositTokens,     address _wETH,     address _xOLE,     uint8[] memory _supportDexs ) public {     depositTokens;     require(msg.sender == admin, "NAD");     addressConfig.controller = _controller;     addressConfig.dexAggregator = _dexAggregator;     addressConfig.wETH = _wETH;     addressConfig.xOLE = _xOLE;     for (uint i = 0; i &lt; _supportDexs.length; i++) {         supportDexs[_supportDexs[i]] = true;     }     OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig); }  /// @notice Create new trading pair. /// @dev This function is typically called by ControllerDelegator. /// @param pool0 Contract LpoolDelegator, lending pool of token0. /// @param pool1 Contract LpoolDelegator, lending pool of token1. /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value. /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens. /// @return The new created pair ID. function addMarket(     LPoolInterface pool0,     LPoolInterface pool1,     uint16 marginLimit,     bytes memory dexData ) external override returns (uint16) {     uint16 marketId = numPairs;     OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);     numPairs ++;     return marketId; }  /// @notice Margin trade or just add more deposit tokens. /// @dev To support token with tax and reward. Stores share of all token balances of this contract. /// @param longToken Token to long. False for token0, true for token1. /// @param depositToken Token to deposit. False for token0, true for token1. /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported. /// @param borrow Amount of ERC20 to borrow from the short token pool. /// @param minBuyAmount Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function marginTrade(     uint16 marketId,     bool longToken,     bool depositToken,     uint deposit,     uint borrow,     uint minBuyAmount,     bytes memory dexData ) external payable override nonReentrant onlySupportDex(dexData) {     Types.TradeVars memory tv;     Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);     verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);     (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);      if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);     }      tv.totalHeld = totalHelds[address(vars.buyToken)];     tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;      deposit = transferIn(msg.sender, tv.depositErc20, deposit);      // Borrow     uint borrowed;     if (borrow &gt; 0) {         {             uint balance = vars.sellToken.balanceOf(address(this));             vars.sellPool.borrowBehalf(msg.sender, borrow);             borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);         }          if (depositToken == longToken){             (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);             tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));         }else{             tv.borrowValue = borrow;         }     }      require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) &gt; vars.marginLimit, "MAM");     tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);     tv.depositAfterFees = deposit.sub(tv.fees);     tv.dexDetail = dexData.toDexDetail();      if (depositToken == longToken ){         if (borrowed &gt; 0){             tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);             tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);         }         tv.newHeld = tv.newHeld.add(tv.depositAfterFees);     }else{         tv.tradeSize = tv.depositAfterFees.add(borrowed);         tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);         tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);     }      Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];     tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);     trade.held = trade.held.add(tv.newHeld);     trade.depositToken = depositToken;     trade.deposited = trade.deposited.add(tv.depositAfterFees);     trade.lastBlockNum = uint128(block.number);      totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);      require(OpenLevV1Lib.isPositionHealthy(             msg.sender,             true,             OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),             vars,             dexData         ), "PNH");      emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail); }  /// @notice Close trade by shares. /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed. /// @param longToken Token to long. False for token0, true for token1. /// @param closeHeld Amount of shares to close. /// @param minOrMaxAmount Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {     Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];     Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);      //verify     verifyCloseBefore(trade, marketVars, closeHeld, dexData);      uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);      Types.CloseTradeVars memory closeTradeVars;     closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);     closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);     closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);     closeTradeVars.isPartialClose = closeHeld != trade.held;     closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);     closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);     closeTradeVars.dexDetail = dexData.toDexDetail();      //partial close     if (closeTradeVars.isPartialClose) {         closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);         closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);         trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);     } else {         closeTradeVars.depositDecrease = trade.deposited;     }      if (trade.depositToken != longToken) {         minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);         closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);         require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");          closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;         marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);          closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);         doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);     } else {         uint balance = marketVars.buyToken.balanceOf(address(this));         minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);         closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);         closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);         require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");          marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);         closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);         require(marketVars.sellToken.balanceOf(address(this)) &gt;= closeTradeVars.depositReturn, "ISB");         doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);     }      uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));     require(repayed &gt;= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");      if (!closeTradeVars.isPartialClose) {         delete activeTrades[msg.sender][marketId][longToken];     }else{         trade.held = trade.held.sub(closeHeld);         trade.lastBlockNum = uint128(block.number);     }      totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);      closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);     if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);     }      emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,         closeTradeVars.token0Price, closeTradeVars.dexDetail); }  /// @notice Liquidate if trade below margin limit. /// @dev For trades without sufficient funds to repay, use insurance. /// @param owner Owner of the trade to liquidate. /// @param longToken Token to long. False for token0, true for token1. /// @param minBuy Slippage for Dex trading. /// @param maxSell Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {     Types.Trade memory trade = activeTrades[owner][marketId][longToken];     Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);     if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);     }      verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());     uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);      (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);     require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");      Types.LiquidateVars memory liquidateVars;     liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);     liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);     if (liquidateVars.penalty &gt; 0) {         doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);     }     liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);     liquidateVars.dexDetail = dexData.toDexDetail();     liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);     liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);     liquidateVars.marketId = marketId;     liquidateVars.longToken = longToken;      bool buySuccess;     bytes memory sellAmountData;     if (longToken == trade.depositToken) {         maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);         marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);         (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(             abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],             taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)         );     }      if (buySuccess) {         {             uint temp;             assembly {                 temp := mload(add(sellAmountData, 0x20))             }             liquidateVars.sellAmount = temp;         }          liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);         marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);         liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);         doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);     } else {         liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;         liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);         if (liquidateVars.receiveAmount &gt;= liquidateVars.borrowed) {             // fail if buy failed but sell succeeded             require (longToken != trade.depositToken, "PH");             marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);             liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);             doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);         } else {             liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);             liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);             marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);         }     }      liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);     totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);      emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,         trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);      delete activeTrades[owner][marketId][longToken]; }  function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {     return open == longToken ?     Types.MarketVars(         market.pool1,         market.pool0,         IERC20(market.token1),         IERC20(market.token0),         IERC20(market.token1).balanceOf(address(this)),         IERC20(market.token0).balanceOf(address(this)),         market.pool1Insurance,         market.pool0Insurance,         market.marginLimit,         market.priceDiffientRatio,         market.dexs) :     Types.MarketVars(         market.pool0,         market.pool1,         IERC20(market.token0),         IERC20(market.token1),         IERC20(market.token0).balanceOf(address(this)),         IERC20(market.token1).balanceOf(address(this)),         market.pool0Insurance,         market.pool1Insurance,         market.marginLimit,         market.priceDiffientRatio,         market.dexs); }  /// @notice Get ratios of deposited token value to borrowed token value. /// @dev Caluclate ratio with current price and twap price. /// @param owner Owner of the trade to liquidate. /// @param longToken Token to long. False for token0, true for token1. /// @param dexData Index and fee rate for the trading Dex. /// @return current Margin ratio calculated using current price. /// @return cAvg Margin ratio calculated using twap price. /// @return hAvg Margin ratio calculated using last recorded twap price. /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value. function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {     Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);     limit = vars.marginLimit;     (current, cAvg, hAvg,,) =     OpenLevV1Lib.marginRatio(         owner,         activeTrades[owner][marketId][longToken].held,         address(vars.sellToken),         address(vars.buyToken),         vars.buyPool,         false,         dexData     ); }  /// @notice Check if a price update is required on Dex. /// @param dexData Index and fee rate for the trading Dex. function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){     Types.Market memory market = markets[marketId];     return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData); }  /// @notice Update price on Dex. /// @param dexData Index and fee rate for the trading Dex. function updatePrice(uint16 marketId, bytes memory dexData) external override {     OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData); }  /// @notice List of all supporting Dexes. function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){     return markets[marketId].dexs; }  function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {     Types.Market storage market = markets[marketId];     uint needed = totalRepayment.sub(remaining);     needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);     maxCanRepayAmount = totalRepayment;     if (longToken) {         if (market.pool0Insurance &gt;= needed) {             market.pool0Insurance = market.pool0Insurance - needed;             totalHelds[token] = totalHelds[token].sub(needed);         } else {             maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);             maxCanRepayAmount = maxCanRepayAmount.add(remaining);             totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);             market.pool0Insurance = 0;         }     } else {         if (market.pool1Insurance &gt;= needed) {             market.pool1Insurance = market.pool1Insurance - needed;         } else {             maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);             maxCanRepayAmount = maxCanRepayAmount.add(remaining);             totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);             market.pool1Insurance = 0;         }     } }  function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {     // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);     Types.Market storage market = markets[marketId];     uint defaultFees = tradeSize.mul(market.feesRate).div(10000);     uint newFees = defaultFees;     // if trader holds more xOLE, then should enjoy trading discount.     if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) &gt; calculateConfig.feesDiscountThreshold) {         newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));     }     // if trader update price, then should enjoy trading discount.     if (market.priceUpdater == trader) {         newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));     }     uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);     IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));      newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);     if (token == market.token1) {         market.pool1Insurance = market.pool1Insurance.add(newInsurance);     } else {         market.pool0Insurance = market.pool0Insurance.add(newInsurance);     }      totalHelds[token] = totalHelds[token].add(newInsurance);     return newFees; }  function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){     if (sellAmount &gt; 0){         DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;         IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);         buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);     } }  function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){     if (buyAmount &gt; 0){         DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;         IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);         sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);     } }  /// @dev All credited on this contract and share with all token holder if any rewards for the transfer. function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {     return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount); }  /// @dev All credited on "to" if any taxes for the transfer. function doTransferOut(address to, IERC20 token, uint amount) internal {     OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount); }  /*** Admin Functions ***/ function setCalculateConfig(uint16 defaultFeesRate,     uint8 insuranceRatio,     uint16 defaultMarginLimit,     uint16 priceDiffientRatio,     uint16 updatePriceDiscount,     uint16 feesDiscount,     uint128 feesDiscountThreshold,     uint16 penaltyRatio,     uint8 maxLiquidationPriceDiffientRatio,     uint16 twapDuration) external override onlyAdmin() {     OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,         feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);     emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration); }  function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {     OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);     emit NewAddressConfig(controller, address(dexAggregator)); }  function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {     OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);     emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs); }  /// @notice List of all supporting Dexes. /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1 function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {     Types.Market storage market = markets[marketId];     if (poolIndex == 0) {         market.pool0Insurance = market.pool0Insurance.sub(amount);         (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));         return;     }     market.pool1Insurance = market.pool1Insurance.sub(amount);     (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this)))); }  function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {     supportDexs[dex] = support; }  function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){     taxes[marketId][token][index] = tax; }  function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {     Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];     OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade); }  function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {     verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());     require(closeHeld &lt;= trade.held, "CBH"); }  function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {     require(held != 0 &amp;&amp; lastBlockNumber != block.number &amp;&amp; OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0"); }  modifier onlySupportDex(bytes memory dexData) {     require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");     _; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-24-08 18:28:19 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.7.6; pragma experimental ABIEncoderV2; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import "./OpenLevInterface.sol"; import "./Types.sol"; import "./Adminable.sol"; import "./DelegateInterface.sol"; import "./ControllerInterface.sol"; import "./IWETH.sol"; import "./XOLEInterface.sol"; import "./Types.sol"; import "./OpenLevV1Lib.sol"; /// @title OpenLeverage margin trade logic /// @author OpenLeverage /// @notice Use this contract for margin trade. /// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE. contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {     using SafeMath for uint;     using TransferHelper for IERC20;     using DexData for bytes; constructor () { }  /// @notice initialize proxy contract /// @dev This function is not supposed to call multiple times. All configs can be set through other functions. /// @param _controller Address of contract ControllerDelegator. /// @param _dexAggregator contract DexAggregatorDelegator. /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens. /// @param _wETH Address of wrapped native coin. /// @param _xOLE Address of XOLEDelegator. /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol. function initialize(     address _controller,     DexAggregatorInterface _dexAggregator,     address[] memory depositTokens,     address _wETH,     address _xOLE,     uint8[] memory _supportDexs ) public {     depositTokens;     require(msg.sender == admin, "NAD");     addressConfig.controller = _controller;     addressConfig.dexAggregator = _dexAggregator;     addressConfig.wETH = _wETH;     addressConfig.xOLE = _xOLE;     for (uint i = 0; i &lt; _supportDexs.length; i++) {         supportDexs[_supportDexs[i]] = true;     }     OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig); }  /// @notice Create new trading pair. /// @dev This function is typically called by ControllerDelegator. /// @param pool0 Contract LpoolDelegator, lending pool of token0. /// @param pool1 Contract LpoolDelegator, lending pool of token1. /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value. /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens. /// @return The new created pair ID. function addMarket(     LPoolInterface pool0,     LPoolInterface pool1,     uint16 marginLimit,     bytes memory dexData ) external override returns (uint16) {     uint16 marketId = numPairs;     OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);     numPairs ++;     return marketId; }  /// @notice Margin trade or just add more deposit tokens. /// @dev To support token with tax and reward. Stores share of all token balances of this contract. /// @param longToken Token to long. False for token0, true for token1. /// @param depositToken Token to deposit. False for token0, true for token1. /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported. /// @param borrow Amount of ERC20 to borrow from the short token pool. /// @param minBuyAmount Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function marginTrade(     uint16 marketId,     bool longToken,     bool depositToken,     uint deposit,     uint borrow,     uint minBuyAmount,     bytes memory dexData ) external payable override nonReentrant onlySupportDex(dexData) {     Types.TradeVars memory tv;     Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);     verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);     (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);      if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);     }      tv.totalHeld = totalHelds[address(vars.buyToken)];     tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;      deposit = transferIn(msg.sender, tv.depositErc20, deposit);      // Borrow     uint borrowed;     if (borrow &gt; 0) {         {             uint balance = vars.sellToken.balanceOf(address(this));             vars.sellPool.borrowBehalf(msg.sender, borrow);             borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);         }          if (depositToken == longToken){             (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);             tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));         }else{             tv.borrowValue = borrow;         }     }      require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) &gt; vars.marginLimit, "MAM");     tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);     tv.depositAfterFees = deposit.sub(tv.fees);     tv.dexDetail = dexData.toDexDetail();      if (depositToken == longToken ){         if (borrowed &gt; 0){             tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);             tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);         }         tv.newHeld = tv.newHeld.add(tv.depositAfterFees);     }else{         tv.tradeSize = tv.depositAfterFees.add(borrowed);         tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);         tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);     }      Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];     tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);     trade.held = trade.held.add(tv.newHeld);     trade.depositToken = depositToken;     trade.deposited = trade.deposited.add(tv.depositAfterFees);     trade.lastBlockNum = uint128(block.number);      totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);      require(OpenLevV1Lib.isPositionHealthy(             msg.sender,             true,             OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),             vars,             dexData         ), "PNH");      emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail); }  /// @notice Close trade by shares. /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed. /// @param longToken Token to long. False for token0, true for token1. /// @param closeHeld Amount of shares to close. /// @param minOrMaxAmount Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {     Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];     Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);      //verify     verifyCloseBefore(trade, marketVars, closeHeld, dexData);      uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);      Types.CloseTradeVars memory closeTradeVars;     closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);     closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);     closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);     closeTradeVars.isPartialClose = closeHeld != trade.held;     closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);     closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);     closeTradeVars.dexDetail = dexData.toDexDetail();      //partial close     if (closeTradeVars.isPartialClose) {         closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);         closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);         trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);     } else {         closeTradeVars.depositDecrease = trade.deposited;     }      if (trade.depositToken != longToken) {         minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);         closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);         require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");          closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;         marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);          closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);         doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);     } else {         uint balance = marketVars.buyToken.balanceOf(address(this));         minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);         closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);         closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);         require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");          marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);         closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);         require(marketVars.sellToken.balanceOf(address(this)) &gt;= closeTradeVars.depositReturn, "ISB");         doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);     }      uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));     require(repayed &gt;= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");      if (!closeTradeVars.isPartialClose) {         delete activeTrades[msg.sender][marketId][longToken];     }else{         trade.held = trade.held.sub(closeHeld);         trade.lastBlockNum = uint128(block.number);     }      totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);      closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);     if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);     }      emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,         closeTradeVars.token0Price, closeTradeVars.dexDetail); }  /// @notice Liquidate if trade below margin limit. /// @dev For trades without sufficient funds to repay, use insurance. /// @param owner Owner of the trade to liquidate. /// @param longToken Token to long. False for token0, true for token1. /// @param minBuy Slippage for Dex trading. /// @param maxSell Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {     Types.Trade memory trade = activeTrades[owner][marketId][longToken];     Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);     if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);     }      verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());     uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);      (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);     require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");      Types.LiquidateVars memory liquidateVars;     liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);     liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);     if (liquidateVars.penalty &gt; 0) {         doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);     }     liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);     liquidateVars.dexDetail = dexData.toDexDetail();     liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);     liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);     liquidateVars.marketId = marketId;     liquidateVars.longToken = longToken;      bool buySuccess;     bytes memory sellAmountData;     if (longToken == trade.depositToken) {         maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);         marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);         (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(             abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],             taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)         );     }      if (buySuccess) {         {             uint temp;             assembly {                 temp := mload(add(sellAmountData, 0x20))             }             liquidateVars.sellAmount = temp;         }          liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);         marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);         liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);         doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);     } else {         liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;         liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);         if (liquidateVars.receiveAmount &gt;= liquidateVars.borrowed) {             // fail if buy failed but sell succeeded             require (longToken != trade.depositToken, "PH");             marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);             liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);             doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);         } else {             liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);             liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);             marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);         }     }      liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);     totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);      emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,         trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);      delete activeTrades[owner][marketId][longToken]; }  function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {     return open == longToken ?     Types.MarketVars(         market.pool1,         market.pool0,         IERC20(market.token1),         IERC20(market.token0),         IERC20(market.token1).balanceOf(address(this)),         IERC20(market.token0).balanceOf(address(this)),         market.pool1Insurance,         market.pool0Insurance,         market.marginLimit,         market.priceDiffientRatio,         market.dexs) :     Types.MarketVars(         market.pool0,         market.pool1,         IERC20(market.token0),         IERC20(market.token1),         IERC20(market.token0).balanceOf(address(this)),         IERC20(market.token1).balanceOf(address(this)),         market.pool0Insurance,         market.pool1Insurance,         market.marginLimit,         market.priceDiffientRatio,         market.dexs); }  /// @notice Get ratios of deposited token value to borrowed token value. /// @dev Caluclate ratio with current price and twap price. /// @param owner Owner of the trade to liquidate. /// @param longToken Token to long. False for token0, true for token1. /// @param dexData Index and fee rate for the trading Dex. /// @return current Margin ratio calculated using current price. /// @return cAvg Margin ratio calculated using twap price. /// @return hAvg Margin ratio calculated using last recorded twap price. /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value. function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {     Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);     limit = vars.marginLimit;     (current, cAvg, hAvg,,) =     OpenLevV1Lib.marginRatio(         owner,         activeTrades[owner][marketId][longToken].held,         address(vars.sellToken),         address(vars.buyToken),         vars.buyPool,         false,         dexData     ); }  /// @notice Check if a price update is required on Dex. /// @param dexData Index and fee rate for the trading Dex. function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){     Types.Market memory market = markets[marketId];     return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData); }  /// @notice Update price on Dex. /// @param dexData Index and fee rate for the trading Dex. function updatePrice(uint16 marketId, bytes memory dexData) external override {     OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData); }  /// @notice List of all supporting Dexes. function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){     return markets[marketId].dexs; }  function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {     Types.Market storage market = markets[marketId];     uint needed = totalRepayment.sub(remaining);     needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);     maxCanRepayAmount = totalRepayment;     if (longToken) {         if (market.pool0Insurance &gt;= needed) {             market.pool0Insurance = market.pool0Insurance - needed;             totalHelds[token] = totalHelds[token].sub(needed);         } else {             maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);             maxCanRepayAmount = maxCanRepayAmount.add(remaining);             totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);             market.pool0Insurance = 0;         }     } else {         if (market.pool1Insurance &gt;= needed) {             market.pool1Insurance = market.pool1Insurance - needed;         } else {             maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);             maxCanRepayAmount = maxCanRepayAmount.add(remaining);             totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);             market.pool1Insurance = 0;         }     } }  function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {     // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);     Types.Market storage market = markets[marketId];     uint defaultFees = tradeSize.mul(market.feesRate).div(10000);     uint newFees = defaultFees;     // if trader holds more xOLE, then should enjoy trading discount.     if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) &gt; calculateConfig.feesDiscountThreshold) {         newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));     }     // if trader update price, then should enjoy trading discount.     if (market.priceUpdater == trader) {         newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));     }     uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);     IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));      newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);     if (token == market.token1) {         market.pool1Insurance = market.pool1Insurance.add(newInsurance);     } else {         market.pool0Insurance = market.pool0Insurance.add(newInsurance);     }      totalHelds[token] = totalHelds[token].add(newInsurance);     return newFees; }  function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){     if (sellAmount &gt; 0){         DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;         IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);         buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);     } }  function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){     if (buyAmount &gt; 0){         DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;         IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);         sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);     } }  /// @dev All credited on this contract and share with all token holder if any rewards for the transfer. function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {     return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount); }  /// @dev All credited on "to" if any taxes for the transfer. function doTransferOut(address to, IERC20 token, uint amount) internal {     OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount); }  /*** Admin Functions ***/ function setCalculateConfig(uint16 defaultFeesRate,     uint8 insuranceRatio,     uint16 defaultMarginLimit,     uint16 priceDiffientRatio,     uint16 updatePriceDiscount,     uint16 feesDiscount,     uint128 feesDiscountThreshold,     uint16 penaltyRatio,     uint8 maxLiquidationPriceDiffientRatio,     uint16 twapDuration) external override onlyAdmin() {     OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,         feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);     emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration); }  function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {     OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);     emit NewAddressConfig(controller, address(dexAggregator)); }  function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {     OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);     emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs); }  /// @notice List of all supporting Dexes. /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1 function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {     Types.Market storage market = markets[marketId];     if (poolIndex == 0) {         market.pool0Insurance = market.pool0Insurance.sub(amount);         (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));         return;     }     market.pool1Insurance = market.pool1Insurance.sub(amount);     (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this)))); }  function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {     supportDexs[dex] = support; }  function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){     taxes[marketId][token][index] = tax; }  function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {     Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];     OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade); }  function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {     verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());     require(closeHeld &lt;= trade.held, "CBH"); }  function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {     require(held != 0 &amp;&amp; lastBlockNumber != block.number &amp;&amp; OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0"); }  modifier onlySupportDex(bytes memory dexData) {     require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");     _; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-24-08 18:28:19 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;

pragma experimental ABIEncoderV2;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "./OpenLevInterface.sol";
import "./Types.sol";
import "./Adminable.sol";
import "./DelegateInterface.sol";
import "./ControllerInterface.sol";
import "./IWETH.sol";
import "./XOLEInterface.sol";
import "./Types.sol";
import "./OpenLevV1Lib.sol";

/// @title OpenLeverage margin trade logic
/// @author OpenLeverage
/// @notice Use this contract for margin trade.
/// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE.
contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {
    using SafeMath for uint;
    using TransferHelper for IERC20;
    using DexData for bytes;

    constructor ()
    {
    }

    /// @notice initialize proxy contract
    /// @dev This function is not supposed to call multiple times. All configs can be set through other functions.
    /// @param _controller Address of contract ControllerDelegator.
    /// @param _dexAggregator contract DexAggregatorDelegator.
    /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens.
    /// @param _wETH Address of wrapped native coin.
    /// @param _xOLE Address of XOLEDelegator.
    /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol.
    function initialize(
        address _controller,
        DexAggregatorInterface _dexAggregator,
        address[] memory depositTokens,
        address _wETH,
        address _xOLE,
        uint8[] memory _supportDexs
    ) public {
        depositTokens;
        require(msg.sender == admin, "NAD");
        addressConfig.controller = _controller;
        addressConfig.dexAggregator = _dexAggregator;
        addressConfig.wETH = _wETH;
        addressConfig.xOLE = _xOLE;
        for (uint i = 0; i < _supportDexs.length; i++) {
            supportDexs[_supportDexs[i]] = true;
        }
        OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig);
    }

    /// @notice Create new trading pair.
    /// @dev This function is typically called by ControllerDelegator.
    /// @param pool0 Contract LpoolDelegator, lending pool of token0.
    /// @param pool1 Contract LpoolDelegator, lending pool of token1.
    /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value.
    /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens.
    /// @return The new created pair ID.
    function addMarket(
        LPoolInterface pool0,
        LPoolInterface pool1,
        uint16 marginLimit,
        bytes memory dexData
    ) external override returns (uint16) {
        uint16 marketId = numPairs;
        OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);
        numPairs ++;
        return marketId;
    }

    /// @notice Margin trade or just add more deposit tokens.
    /// @dev To support token with tax and reward. Stores share of all token balances of this contract.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param depositToken Token to deposit. False for token0, true for token1.
    /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported.
    /// @param borrow Amount of ERC20 to borrow from the short token pool.
    /// @param minBuyAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function marginTrade(
        uint16 marketId,
        bool longToken,
        bool depositToken,
        uint deposit,
        uint borrow,
        uint minBuyAmount,
        bytes memory dexData
    ) external payable override nonReentrant onlySupportDex(dexData) {
        Types.TradeVars memory tv;
        Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);
        verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);
        (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);

        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);
        }

        tv.totalHeld = totalHelds[address(vars.buyToken)];
        tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;

        deposit = transferIn(msg.sender, tv.depositErc20, deposit);

        // Borrow
        uint borrowed;
        if (borrow > 0) {
            {
                uint balance = vars.sellToken.balanceOf(address(this));
                vars.sellPool.borrowBehalf(msg.sender, borrow);
                borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);
            }

            if (depositToken == longToken){
                (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);
                tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));
            }else{
                tv.borrowValue = borrow;
            }
        }

        require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) > vars.marginLimit, "MAM");
        tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);
        tv.depositAfterFees = deposit.sub(tv.fees);
        tv.dexDetail = dexData.toDexDetail();

        if (depositToken == longToken ){
            if (borrowed > 0){
                tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);
                tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);
            }
            tv.newHeld = tv.newHeld.add(tv.depositAfterFees);
        }else{
            tv.tradeSize = tv.depositAfterFees.add(borrowed);
            tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);
            tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);
        }

        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);
        trade.held = trade.held.add(tv.newHeld);
        trade.depositToken = depositToken;
        trade.deposited = trade.deposited.add(tv.depositAfterFees);
        trade.lastBlockNum = uint128(block.number);

        totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);

        require(OpenLevV1Lib.isPositionHealthy(
                msg.sender,
                true,
                OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),
                vars,
                dexData
            ), "PNH");

        emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail);
    }

    /// @notice Close trade by shares.
    /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param closeHeld Amount of shares to close.
    /// @param minOrMaxAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);

        //verify
        verifyCloseBefore(trade, marketVars, closeHeld, dexData);

        uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        Types.CloseTradeVars memory closeTradeVars;
        closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);
        closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);
        closeTradeVars.isPartialClose = closeHeld != trade.held;
        closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);
        closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        closeTradeVars.dexDetail = dexData.toDexDetail();

        //partial close
        if (closeTradeVars.isPartialClose) {
            closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);
            closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);
            trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);
        } else {
            closeTradeVars.depositDecrease = trade.deposited;
        }

        if (trade.depositToken != longToken) {
            minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);
            closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;
            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);

            closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);
            doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);
        } else {
            uint balance = marketVars.buyToken.balanceOf(address(this));
            minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);
            closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);
            closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);
            closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);
            require(marketVars.sellToken.balanceOf(address(this)) >= closeTradeVars.depositReturn, "ISB");
            doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);
        }

        uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));
        require(repayed >= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");

        if (!closeTradeVars.isPartialClose) {
            delete activeTrades[msg.sender][marketId][longToken];
        }else{
            trade.held = trade.held.sub(closeHeld);
            trade.lastBlockNum = uint128(block.number);
        }

        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);

        closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,
            closeTradeVars.token0Price, closeTradeVars.dexDetail);
    }

    /// @notice Liquidate if trade below margin limit.
    /// @dev For trades without sufficient funds to repay, use insurance.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param minBuy Slippage for Dex trading.
    /// @param maxSell Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade memory trade = activeTrades[owner][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());
        uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);
        require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");

        Types.LiquidateVars memory liquidateVars;
        liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);
        if (liquidateVars.penalty > 0) {
            doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);
        }
        liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);
        liquidateVars.dexDetail = dexData.toDexDetail();
        liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);
        liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        liquidateVars.marketId = marketId;
        liquidateVars.longToken = longToken;

        bool buySuccess;
        bytes memory sellAmountData;
        if (longToken == trade.depositToken) {
            maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);
            marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);
            (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(
                abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],
                taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)
            );
        }

        if (buySuccess) {
            {
                uint temp;
                assembly {
                    temp := mload(add(sellAmountData, 0x20))
                }
                liquidateVars.sellAmount = temp;
            }

            liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);
            marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
            liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);
            doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);
        } else {
            liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;
            liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);
            if (liquidateVars.receiveAmount >= liquidateVars.borrowed) {
                // fail if buy failed but sell succeeded
                require (longToken != trade.depositToken, "PH");
                marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
                liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);
                doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);
            } else {
                liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);
                liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);
                marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);
            }
        }

        liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);
        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);

        emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,
            trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);

        delete activeTrades[owner][marketId][longToken];
    }

    function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {
        return open == longToken ?
        Types.MarketVars(
            market.pool1,
            market.pool0,
            IERC20(market.token1),
            IERC20(market.token0),
            IERC20(market.token1).balanceOf(address(this)),
            IERC20(market.token0).balanceOf(address(this)),
            market.pool1Insurance,
            market.pool0Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs) :
        Types.MarketVars(
            market.pool0,
            market.pool1,
            IERC20(market.token0),
            IERC20(market.token1),
            IERC20(market.token0).balanceOf(address(this)),
            IERC20(market.token1).balanceOf(address(this)),
            market.pool0Insurance,
            market.pool1Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs);
    }

    /// @notice Get ratios of deposited token value to borrowed token value.
    /// @dev Caluclate ratio with current price and twap price.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param dexData Index and fee rate for the trading Dex.
    /// @return current Margin ratio calculated using current price.
    /// @return cAvg Margin ratio calculated using twap price.
    /// @return hAvg Margin ratio calculated using last recorded twap price.
    /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value.
    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {
        Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);
        limit = vars.marginLimit;
        (current, cAvg, hAvg,,) =
        OpenLevV1Lib.marginRatio(
            owner,
            activeTrades[owner][marketId][longToken].held,
            address(vars.sellToken),
            address(vars.buyToken),
            vars.buyPool,
            false,
            dexData
        );
    }

    /// @notice Check if a price update is required on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){
        Types.Market memory market = markets[marketId];
        return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData);
    }

    /// @notice Update price on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function updatePrice(uint16 marketId, bytes memory dexData) external override {
        OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData);
    }

    /// @notice List of all supporting Dexes.
    function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){
        return markets[marketId].dexs;
    }

    function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {
        Types.Market storage market = markets[marketId];
        uint needed = totalRepayment.sub(remaining);
        needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);
        maxCanRepayAmount = totalRepayment;
        if (longToken) {
            if (market.pool0Insurance >= needed) {
                market.pool0Insurance = market.pool0Insurance - needed;
                totalHelds[token] = totalHelds[token].sub(needed);
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);
                market.pool0Insurance = 0;
            }
        } else {
            if (market.pool1Insurance >= needed) {
                market.pool1Insurance = market.pool1Insurance - needed;
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);
                market.pool1Insurance = 0;
            }
        }
    }

    function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {
        // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);
        Types.Market storage market = markets[marketId];
        uint defaultFees = tradeSize.mul(market.feesRate).div(10000);
        uint newFees = defaultFees;
        // if trader holds more xOLE, then should enjoy trading discount.
        if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) > calculateConfig.feesDiscountThreshold) {
            newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));
        }
        // if trader update price, then should enjoy trading discount.
        if (market.priceUpdater == trader) {
            newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));
        }
        uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);
        IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));

        newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);
        if (token == market.token1) {
            market.pool1Insurance = market.pool1Insurance.add(newInsurance);
        } else {
            market.pool0Insurance = market.pool0Insurance.add(newInsurance);
        }

        totalHelds[token] = totalHelds[token].add(newInsurance);
        return newFees;
    }

    function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){
        if (sellAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);
            buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);
        }
    }

    function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){
        if (buyAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);
            sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);
        }
    }

    /// @dev All credited on this contract and share with all token holder if any rewards for the transfer.
    function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {
        return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount);
    }

    /// @dev All credited on "to" if any taxes for the transfer.
    function doTransferOut(address to, IERC20 token, uint amount) internal {
        OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount);
    }

    /*** Admin Functions ***/
    function setCalculateConfig(uint16 defaultFeesRate,
        uint8 insuranceRatio,
        uint16 defaultMarginLimit,
        uint16 priceDiffientRatio,
        uint16 updatePriceDiscount,
        uint16 feesDiscount,
        uint128 feesDiscountThreshold,
        uint16 penaltyRatio,
        uint8 maxLiquidationPriceDiffientRatio,
        uint16 twapDuration) external override onlyAdmin() {
        OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,
            feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);
        emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration);
    }

    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {
        OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);
        emit NewAddressConfig(controller, address(dexAggregator));
    }

    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {
        OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);
        emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs);
    }

    /// @notice List of all supporting Dexes.
    /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1
    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {
        Types.Market storage market = markets[marketId];
        if (poolIndex == 0) {
            market.pool0Insurance = market.pool0Insurance.sub(amount);
            (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));
            return;
        }
        market.pool1Insurance = market.pool1Insurance.sub(amount);
        (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this))));
    }

    function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {
        supportDexs[dex] = support;
    }

    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){
        taxes[marketId][token][index] = tax;
    }

    function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {
        Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];
        OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade);
    }

    function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {
        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());
        require(closeHeld <= trade.held, "CBH");
    }

    function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {
        require(held != 0 && lastBlockNumber != block.number && OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0");
    }

    modifier onlySupportDex(bytes memory dexData) {
        require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");
        _;
    }
}.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-24-08 18:28:27 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-24-08 18:28:27 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 6914
completion_tokens: 689
total_tokens: 7603
cost: $-1.000000


[2024-24-08 18:28:27 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;

pragma experimental ABIEncoderV2;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "./OpenLevInterface.sol";
import "./Types.sol";
import "./Adminable.sol";
import "./DelegateInterface.sol";
import "./ControllerInterface.sol";
import "./IWETH.sol";
import "./XOLEInterface.sol";
import "./Types.sol";
import "./OpenLevV1Lib.sol";

/// @title OpenLeverage margin trade logic
/// @author OpenLeverage
/// @notice Use this contract for margin trade.
/// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE.
contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {
    using SafeMath for uint;
    using TransferHelper for IERC20;
    using DexData for bytes;

    constructor ()
    {
    }

    /// @notice initialize proxy contract
    /// @dev This function is not supposed to call multiple times. All configs can be set through other functions.
    /// @param _controller Address of contract ControllerDelegator.
    /// @param _dexAggregator contract DexAggregatorDelegator.
    /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens.
    /// @param _wETH Address of wrapped native coin.
    /// @param _xOLE Address of XOLEDelegator.
    /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol.
    function initialize(
        address _controller,
        DexAggregatorInterface _dexAggregator,
        address[] memory depositTokens,
        address _wETH,
        address _xOLE,
        uint8[] memory _supportDexs
    ) public {
        depositTokens;
        require(msg.sender == admin, "NAD");
        addressConfig.controller = _controller;
        addressConfig.dexAggregator = _dexAggregator;
        addressConfig.wETH = _wETH;
        addressConfig.xOLE = _xOLE;
        for (uint i = 0; i < _supportDexs.length; i++) {
            supportDexs[_supportDexs[i]] = true;
        }
        OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig);
    }

    /// @notice Create new trading pair.
    /// @dev This function is typically called by ControllerDelegator.
    /// @param pool0 Contract LpoolDelegator, lending pool of token0.
    /// @param pool1 Contract LpoolDelegator, lending pool of token1.
    /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value.
    /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens.
    /// @return The new created pair ID.
    function addMarket(
        LPoolInterface pool0,
        LPoolInterface pool1,
        uint16 marginLimit,
        bytes memory dexData
    ) external override returns (uint16) {
        uint16 marketId = numPairs;
        OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);
        numPairs ++;
        return marketId;
    }

    /// @notice Margin trade or just add more deposit tokens.
    /// @dev To support token with tax and reward. Stores share of all token balances of this contract.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param depositToken Token to deposit. False for token0, true for token1.
    /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported.
    /// @param borrow Amount of ERC20 to borrow from the short token pool.
    /// @param minBuyAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function marginTrade(
        uint16 marketId,
        bool longToken,
        bool depositToken,
        uint deposit,
        uint borrow,
        uint minBuyAmount,
        bytes memory dexData
    ) external payable override nonReentrant onlySupportDex(dexData) {
        Types.TradeVars memory tv;
        Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);
        verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);
        (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);

        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);
        }

        tv.totalHeld = totalHelds[address(vars.buyToken)];
        tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;

        deposit = transferIn(msg.sender, tv.depositErc20, deposit);

        // Borrow
        uint borrowed;
        if (borrow > 0) {
            {
                uint balance = vars.sellToken.balanceOf(address(this));
                vars.sellPool.borrowBehalf(msg.sender, borrow);
                borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);
            }

            if (depositToken == longToken){
                (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);
                tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));
            }else{
                tv.borrowValue = borrow;
            }
        }

        require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) > vars.marginLimit, "MAM");
        tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);
        tv.depositAfterFees = deposit.sub(tv.fees);
        tv.dexDetail = dexData.toDexDetail();

        if (depositToken == longToken ){
            if (borrowed > 0){
                tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);
                tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);
            }
            tv.newHeld = tv.newHeld.add(tv.depositAfterFees);
        }else{
            tv.tradeSize = tv.depositAfterFees.add(borrowed);
            tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);
            tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);
        }

        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);
        trade.held = trade.held.add(tv.newHeld);
        trade.depositToken = depositToken;
        trade.deposited = trade.deposited.add(tv.depositAfterFees);
        trade.lastBlockNum = uint128(block.number);

        totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);

        require(OpenLevV1Lib.isPositionHealthy(
                msg.sender,
                true,
                OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),
                vars,
                dexData
            ), "PNH");

        emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail);
    }

    /// @notice Close trade by shares.
    /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param closeHeld Amount of shares to close.
    /// @param minOrMaxAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);

        //verify
        verifyCloseBefore(trade, marketVars, closeHeld, dexData);

        uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        Types.CloseTradeVars memory closeTradeVars;
        closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);
        closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);
        closeTradeVars.isPartialClose = closeHeld != trade.held;
        closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);
        closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        closeTradeVars.dexDetail = dexData.toDexDetail();

        //partial close
        if (closeTradeVars.isPartialClose) {
            closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);
            closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);
            trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);
        } else {
            closeTradeVars.depositDecrease = trade.deposited;
        }

        if (trade.depositToken != longToken) {
            minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);
            closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;
            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);

            closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);
            doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);
        } else {
            uint balance = marketVars.buyToken.balanceOf(address(this));
            minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);
            closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);
            closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);
            closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);
            require(marketVars.sellToken.balanceOf(address(this)) >= closeTradeVars.depositReturn, "ISB");
            doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);
        }

        uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));
        require(repayed >= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");

        if (!closeTradeVars.isPartialClose) {
            delete activeTrades[msg.sender][marketId][longToken];
        }else{
            trade.held = trade.held.sub(closeHeld);
            trade.lastBlockNum = uint128(block.number);
        }

        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);

        closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,
            closeTradeVars.token0Price, closeTradeVars.dexDetail);
    }

    /// @notice Liquidate if trade below margin limit.
    /// @dev For trades without sufficient funds to repay, use insurance.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param minBuy Slippage for Dex trading.
    /// @param maxSell Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade memory trade = activeTrades[owner][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());
        uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);
        require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");

        Types.LiquidateVars memory liquidateVars;
        liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);
        if (liquidateVars.penalty > 0) {
            doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);
        }
        liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);
        liquidateVars.dexDetail = dexData.toDexDetail();
        liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);
        liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        liquidateVars.marketId = marketId;
        liquidateVars.longToken = longToken;

        bool buySuccess;
        bytes memory sellAmountData;
        if (longToken == trade.depositToken) {
            maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);
            marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);
            (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(
                abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],
                taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)
            );
        }

        if (buySuccess) {
            {
                uint temp;
                assembly {
                    temp := mload(add(sellAmountData, 0x20))
                }
                liquidateVars.sellAmount = temp;
            }

            liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);
            marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
            liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);
            doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);
        } else {
            liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;
            liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);
            if (liquidateVars.receiveAmount >= liquidateVars.borrowed) {
                // fail if buy failed but sell succeeded
                require (longToken != trade.depositToken, "PH");
                marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
                liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);
                doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);
            } else {
                liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);
                liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);
                marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);
            }
        }

        liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);
        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);

        emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,
            trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);

        delete activeTrades[owner][marketId][longToken];
    }

    function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {
        return open == longToken ?
        Types.MarketVars(
            market.pool1,
            market.pool0,
            IERC20(market.token1),
            IERC20(market.token0),
            IERC20(market.token1).balanceOf(address(this)),
            IERC20(market.token0).balanceOf(address(this)),
            market.pool1Insurance,
            market.pool0Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs) :
        Types.MarketVars(
            market.pool0,
            market.pool1,
            IERC20(market.token0),
            IERC20(market.token1),
            IERC20(market.token0).balanceOf(address(this)),
            IERC20(market.token1).balanceOf(address(this)),
            market.pool0Insurance,
            market.pool1Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs);
    }

    /// @notice Get ratios of deposited token value to borrowed token value.
    /// @dev Caluclate ratio with current price and twap price.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param dexData Index and fee rate for the trading Dex.
    /// @return current Margin ratio calculated using current price.
    /// @return cAvg Margin ratio calculated using twap price.
    /// @return hAvg Margin ratio calculated using last recorded twap price.
    /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value.
    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {
        Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);
        limit = vars.marginLimit;
        (current, cAvg, hAvg,,) =
        OpenLevV1Lib.marginRatio(
            owner,
            activeTrades[owner][marketId][longToken].held,
            address(vars.sellToken),
            address(vars.buyToken),
            vars.buyPool,
            false,
            dexData
        );
    }

    /// @notice Check if a price update is required on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){
        Types.Market memory market = markets[marketId];
        return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData);
    }

    /// @notice Update price on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function updatePrice(uint16 marketId, bytes memory dexData) external override {
        OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData);
    }

    /// @notice List of all supporting Dexes.
    function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){
        return markets[marketId].dexs;
    }

    function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {
        Types.Market storage market = markets[marketId];
        uint needed = totalRepayment.sub(remaining);
        needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);
        maxCanRepayAmount = totalRepayment;
        if (longToken) {
            if (market.pool0Insurance >= needed) {
                market.pool0Insurance = market.pool0Insurance - needed;
                totalHelds[token] = totalHelds[token].sub(needed);
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);
                market.pool0Insurance = 0;
            }
        } else {
            if (market.pool1Insurance >= needed) {
                market.pool1Insurance = market.pool1Insurance - needed;
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);
                market.pool1Insurance = 0;
            }
        }
    }

    function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {
        // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);
        Types.Market storage market = markets[marketId];
        uint defaultFees = tradeSize.mul(market.feesRate).div(10000);
        uint newFees = defaultFees;
        // if trader holds more xOLE, then should enjoy trading discount.
        if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) > calculateConfig.feesDiscountThreshold) {
            newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));
        }
        // if trader update price, then should enjoy trading discount.
        if (market.priceUpdater == trader) {
            newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));
        }
        uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);
        IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));

        newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);
        if (token == market.token1) {
            market.pool1Insurance = market.pool1Insurance.add(newInsurance);
        } else {
            market.pool0Insurance = market.pool0Insurance.add(newInsurance);
        }

        totalHelds[token] = totalHelds[token].add(newInsurance);
        return newFees;
    }

    function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){
        if (sellAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);
            buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);
        }
    }

    function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){
        if (buyAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);
            sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);
        }
    }

    /// @dev All credited on this contract and share with all token holder if any rewards for the transfer.
    function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {
        return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount);
    }

    /// @dev All credited on "to" if any taxes for the transfer.
    function doTransferOut(address to, IERC20 token, uint amount) internal {
        OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount);
    }

    /*** Admin Functions ***/
    function setCalculateConfig(uint16 defaultFeesRate,
        uint8 insuranceRatio,
        uint16 defaultMarginLimit,
        uint16 priceDiffientRatio,
        uint16 updatePriceDiscount,
        uint16 feesDiscount,
        uint128 feesDiscountThreshold,
        uint16 penaltyRatio,
        uint8 maxLiquidationPriceDiffientRatio,
        uint16 twapDuration) external override onlyAdmin() {
        OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,
            feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);
        emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration);
    }

    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {
        OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);
        emit NewAddressConfig(controller, address(dexAggregator));
    }

    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {
        OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);
        emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs);
    }

    /// @notice List of all supporting Dexes.
    /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1
    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {
        Types.Market storage market = markets[marketId];
        if (poolIndex == 0) {
            market.pool0Insurance = market.pool0Insurance.sub(amount);
            (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));
            return;
        }
        market.pool1Insurance = market.pool1Insurance.sub(amount);
        (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this))));
    }

    function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {
        supportDexs[dex] = support;
    }

    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){
        taxes[marketId][token][index] = tax;
    }

    function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {
        Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];
        OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade);
    }

    function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {
        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());
        require(closeHeld <= trade.held, "CBH");
    }

    function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {
        require(held != 0 && lastBlockNumber != block.number && OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0");
    }

    modifier onlySupportDex(bytes memory dexData) {
        require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");
        _;
    }
}.]

### Summary of Security Vulnerabilities in OpenLevV1 Contract

1. **Reentrancy Vulnerability**: 
   - Although the contract inherits from `ReentrancyGuard`, there are several functions that involve external calls (e.g., `doTransferOut`, `flashSell`, `flashBuy`) which could potentially be exploited if not properly guarded. Careful attention is needed to ensure that state changes occur before external calls.

2. **Access Control Issues**:
   - The `initialize` function can be called by any address, but it should only be callable by the admin. This could lead to unauthorized configuration changes.
   - Functions such as `setCalculateConfig`, `setAddressConfig`, and `setMarketConfig` are protected by the `onlyAdmin` modifier, but there is a risk if the admin key is compromised.

3. **Lack of Input Validation**:
   - Several functions do not adequately validate input parameters, such as `addMarket`, `marginTrade`, and `closeTrade`. This could lead to unexpected behavior or state corruption if invalid data is passed.

4. **Potential Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath`, there are instances where arithmetic operations could lead to overflow or underflow if not properly handled, especially in the context of external calls where the state might change unexpectedly.

5. **Insufficient Slippage Protection**:
   - The `minBuyAmount` and `maxSell` parameters in trading functions do not have sufficient checks to prevent significant slippage, which could lead to losses for users.

6. **Gas Limit Issues**:
   - Functions that involve loops (e.g., iterating over `supportDexs`) could run into gas limit issues if the number of supported DEXs grows significantly.

7. **Potential for Front-Running**:
   - The contract does not implement any mechanisms to prevent front-running attacks, particularly in trading functions where the order of transactions can significantly impact the outcome.

8. **Insurance Pool Management**:
   - The logic for managing insurance pools could lead to situations where the insurance is insufficient to cover losses, particularly in volatile market conditions.

9. **Event Emission**:
   - Not all state-changing functions emit events, which could hinder tracking and auditing of contract activity.

### Comprehensive Analysis Report

The OpenLevV1 contract exhibits several security vulnerabilities that could potentially be exploited by malicious actors. The most pressing concerns include reentrancy vulnerabilities, access control issues, and insufficient input validation. The reliance on external calls without adequate state management poses a significant risk, particularly in functions that handle financial transactions.

Moreover, the lack of robust slippage protection and the potential for integer overflow/underflow highlight the need for thorough input validation and careful arithmetic handling. The contract's design does not adequately mitigate front-running risks, which could lead to financial losses for users.

The management of insurance pools also requires careful consideration, as inadequate coverage could expose the protocol to significant risks during market volatility. Additionally, the absence of event emissions in certain functions could complicate the auditing process and hinder transparency.

In conclusion, while the OpenLevV1 contract provides a framework for margin trading, it requires substantial improvements in security practices, including enhanced access control, input validation, and protection against common vulnerabilities. A thorough audit and subsequent remediation of identified issues are strongly recommended before deployment to ensure the safety and integrity of user funds.

[2024-24-08 18:28:27 INFO] **[Seminar Conclusion]**:

 ### Summary of Security Vulnerabilities in OpenLevV1 Contract

1. **Reentrancy Vulnerability**: 
   - Although the contract inherits from `ReentrancyGuard`, there are several functions that involve external calls (e.g., `doTransferOut`, `flashSell`, `flashBuy`) which could potentially be exploited if not properly guarded. Careful attention is needed to ensure that state changes occur before external calls.

2. **Access Control Issues**:
   - The `initialize` function can be called by any address, but it should only be callable by the admin. This could lead to unauthorized configuration changes.
   - Functions such as `setCalculateConfig`, `setAddressConfig`, and `setMarketConfig` are protected by the `onlyAdmin` modifier, but there is a risk if the admin key is compromised.

3. **Lack of Input Validation**:
   - Several functions do not adequately validate input parameters, such as `addMarket`, `marginTrade`, and `closeTrade`. This could lead to unexpected behavior or state corruption if invalid data is passed.

4. **Potential Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath`, there are instances where arithmetic operations could lead to overflow or underflow if not properly handled, especially in the context of external calls where the state might change unexpectedly.

5. **Insufficient Slippage Protection**:
   - The `minBuyAmount` and `maxSell` parameters in trading functions do not have sufficient checks to prevent significant slippage, which could lead to losses for users.

6. **Gas Limit Issues**:
   - Functions that involve loops (e.g., iterating over `supportDexs`) could run into gas limit issues if the number of supported DEXs grows significantly.

7. **Potential for Front-Running**:
   - The contract does not implement any mechanisms to prevent front-running attacks, particularly in trading functions where the order of transactions can significantly impact the outcome.

8. **Insurance Pool Management**:
   - The logic for managing insurance pools could lead to situations where the insurance is insufficient to cover losses, particularly in volatile market conditions.

9. **Event Emission**:
   - Not all state-changing functions emit events, which could hinder tracking and auditing of contract activity.

### Comprehensive Analysis Report

The OpenLevV1 contract exhibits several security vulnerabilities that could potentially be exploited by malicious actors. The most pressing concerns include reentrancy vulnerabilities, access control issues, and insufficient input validation. The reliance on external calls without adequate state management poses a significant risk, particularly in functions that handle financial transactions.

Moreover, the lack of robust slippage protection and the potential for integer overflow/underflow highlight the need for thorough input validation and careful arithmetic handling. The contract's design does not adequately mitigate front-running risks, which could lead to financial losses for users.

The management of insurance pools also requires careful consideration, as inadequate coverage could expose the protocol to significant risks during market volatility. Additionally, the absence of event emissions in certain functions could complicate the auditing process and hinder transparency.

In conclusion, while the OpenLevV1 contract provides a framework for margin trading, it requires substantial improvements in security practices, including enhanced access control, input validation, and protection against common vulnerabilities. A thorough audit and subsequent remediation of identified issues are strongly recommended before deployment to ensure the safety and integrity of user funds.

[2024-24-08 18:28:30 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.7.6; pragma experimental ABIEncoderV2; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import "./OpenLevInterface.sol"; import "./Types.sol"; import "./Adminable.sol"; import "./DelegateInterface.sol"; import "./ControllerInterface.sol"; import "./IWETH.sol"; import "./XOLEInterface.sol"; import "./Types.sol"; import "./OpenLevV1Lib.sol"; /// @title OpenLeverage margin trade logic /// @author OpenLeverage /// @notice Use this contract for margin trade. /// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE. contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {     using SafeMath for uint;     using TransferHelper for IERC20;     using DexData for bytes; constructor () { }  /// @notice initialize proxy contract /// @dev This function is not supposed to call multiple times. All configs can be set through other functions. /// @param _controller Address of contract ControllerDelegator. /// @param _dexAggregator contract DexAggregatorDelegator. /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens. /// @param _wETH Address of wrapped native coin. /// @param _xOLE Address of XOLEDelegator. /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol. function initialize(     address _controller,     DexAggregatorInterface _dexAggregator,     address[] memory depositTokens,     address _wETH,     address _xOLE,     uint8[] memory _supportDexs ) public {     depositTokens;     require(msg.sender == admin, "NAD");     addressConfig.controller = _controller;     addressConfig.dexAggregator = _dexAggregator;     addressConfig.wETH = _wETH;     addressConfig.xOLE = _xOLE;     for (uint i = 0; i &lt; _supportDexs.length; i++) {         supportDexs[_supportDexs[i]] = true;     }     OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig); }  /// @notice Create new trading pair. /// @dev This function is typically called by ControllerDelegator. /// @param pool0 Contract LpoolDelegator, lending pool of token0. /// @param pool1 Contract LpoolDelegator, lending pool of token1. /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value. /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens. /// @return The new created pair ID. function addMarket(     LPoolInterface pool0,     LPoolInterface pool1,     uint16 marginLimit,     bytes memory dexData ) external override returns (uint16) {     uint16 marketId = numPairs;     OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);     numPairs ++;     return marketId; }  /// @notice Margin trade or just add more deposit tokens. /// @dev To support token with tax and reward. Stores share of all token balances of this contract. /// @param longToken Token to long. False for token0, true for token1. /// @param depositToken Token to deposit. False for token0, true for token1. /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported. /// @param borrow Amount of ERC20 to borrow from the short token pool. /// @param minBuyAmount Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function marginTrade(     uint16 marketId,     bool longToken,     bool depositToken,     uint deposit,     uint borrow,     uint minBuyAmount,     bytes memory dexData ) external payable override nonReentrant onlySupportDex(dexData) {     Types.TradeVars memory tv;     Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);     verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);     (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);      if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);     }      tv.totalHeld = totalHelds[address(vars.buyToken)];     tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;      deposit = transferIn(msg.sender, tv.depositErc20, deposit);      // Borrow     uint borrowed;     if (borrow &gt; 0) {         {             uint balance = vars.sellToken.balanceOf(address(this));             vars.sellPool.borrowBehalf(msg.sender, borrow);             borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);         }          if (depositToken == longToken){             (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);             tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));         }else{             tv.borrowValue = borrow;         }     }      require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) &gt; vars.marginLimit, "MAM");     tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);     tv.depositAfterFees = deposit.sub(tv.fees);     tv.dexDetail = dexData.toDexDetail();      if (depositToken == longToken ){         if (borrowed &gt; 0){             tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);             tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);         }         tv.newHeld = tv.newHeld.add(tv.depositAfterFees);     }else{         tv.tradeSize = tv.depositAfterFees.add(borrowed);         tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);         tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);     }      Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];     tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);     trade.held = trade.held.add(tv.newHeld);     trade.depositToken = depositToken;     trade.deposited = trade.deposited.add(tv.depositAfterFees);     trade.lastBlockNum = uint128(block.number);      totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);      require(OpenLevV1Lib.isPositionHealthy(             msg.sender,             true,             OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),             vars,             dexData         ), "PNH");      emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail); }  /// @notice Close trade by shares. /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed. /// @param longToken Token to long. False for token0, true for token1. /// @param closeHeld Amount of shares to close. /// @param minOrMaxAmount Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {     Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];     Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);      //verify     verifyCloseBefore(trade, marketVars, closeHeld, dexData);      uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);      Types.CloseTradeVars memory closeTradeVars;     closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);     closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);     closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);     closeTradeVars.isPartialClose = closeHeld != trade.held;     closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);     closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);     closeTradeVars.dexDetail = dexData.toDexDetail();      //partial close     if (closeTradeVars.isPartialClose) {         closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);         closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);         trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);     } else {         closeTradeVars.depositDecrease = trade.deposited;     }      if (trade.depositToken != longToken) {         minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);         closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);         require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");          closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;         marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);          closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);         doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);     } else {         uint balance = marketVars.buyToken.balanceOf(address(this));         minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);         closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);         closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);         require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");          marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);         closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);         require(marketVars.sellToken.balanceOf(address(this)) &gt;= closeTradeVars.depositReturn, "ISB");         doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);     }      uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));     require(repayed &gt;= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");      if (!closeTradeVars.isPartialClose) {         delete activeTrades[msg.sender][marketId][longToken];     }else{         trade.held = trade.held.sub(closeHeld);         trade.lastBlockNum = uint128(block.number);     }      totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);      closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);     if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);     }      emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,         closeTradeVars.token0Price, closeTradeVars.dexDetail); }  /// @notice Liquidate if trade below margin limit. /// @dev For trades without sufficient funds to repay, use insurance. /// @param owner Owner of the trade to liquidate. /// @param longToken Token to long. False for token0, true for token1. /// @param minBuy Slippage for Dex trading. /// @param maxSell Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {     Types.Trade memory trade = activeTrades[owner][marketId][longToken];     Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);     if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);     }      verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());     uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);      (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);     require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");      Types.LiquidateVars memory liquidateVars;     liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);     liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);     if (liquidateVars.penalty &gt; 0) {         doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);     }     liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);     liquidateVars.dexDetail = dexData.toDexDetail();     liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);     liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);     liquidateVars.marketId = marketId;     liquidateVars.longToken = longToken;      bool buySuccess;     bytes memory sellAmountData;     if (longToken == trade.depositToken) {         maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);         marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);         (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(             abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],             taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)         );     }      if (buySuccess) {         {             uint temp;             assembly {                 temp := mload(add(sellAmountData, 0x20))             }             liquidateVars.sellAmount = temp;         }          liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);         marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);         liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);         doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);     } else {         liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;         liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);         if (liquidateVars.receiveAmount &gt;= liquidateVars.borrowed) {             // fail if buy failed but sell succeeded             require (longToken != trade.depositToken, "PH");             marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);             liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);             doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);         } else {             liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);             liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);             marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);         }     }      liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);     totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);      emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,         trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);      delete activeTrades[owner][marketId][longToken]; }  function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {     return open == longToken ?     Types.MarketVars(         market.pool1,         market.pool0,         IERC20(market.token1),         IERC20(market.token0),         IERC20(market.token1).balanceOf(address(this)),         IERC20(market.token0).balanceOf(address(this)),         market.pool1Insurance,         market.pool0Insurance,         market.marginLimit,         market.priceDiffientRatio,         market.dexs) :     Types.MarketVars(         market.pool0,         market.pool1,         IERC20(market.token0),         IERC20(market.token1),         IERC20(market.token0).balanceOf(address(this)),         IERC20(market.token1).balanceOf(address(this)),         market.pool0Insurance,         market.pool1Insurance,         market.marginLimit,         market.priceDiffientRatio,         market.dexs); }  /// @notice Get ratios of deposited token value to borrowed token value. /// @dev Caluclate ratio with current price and twap price. /// @param owner Owner of the trade to liquidate. /// @param longToken Token to long. False for token0, true for token1. /// @param dexData Index and fee rate for the trading Dex. /// @return current Margin ratio calculated using current price. /// @return cAvg Margin ratio calculated using twap price. /// @return hAvg Margin ratio calculated using last recorded twap price. /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value. function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {     Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);     limit = vars.marginLimit;     (current, cAvg, hAvg,,) =     OpenLevV1Lib.marginRatio(         owner,         activeTrades[owner][marketId][longToken].held,         address(vars.sellToken),         address(vars.buyToken),         vars.buyPool,         false,         dexData     ); }  /// @notice Check if a price update is required on Dex. /// @param dexData Index and fee rate for the trading Dex. function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){     Types.Market memory market = markets[marketId];     return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData); }  /// @notice Update price on Dex. /// @param dexData Index and fee rate for the trading Dex. function updatePrice(uint16 marketId, bytes memory dexData) external override {     OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData); }  /// @notice List of all supporting Dexes. function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){     return markets[marketId].dexs; }  function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {     Types.Market storage market = markets[marketId];     uint needed = totalRepayment.sub(remaining);     needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);     maxCanRepayAmount = totalRepayment;     if (longToken) {         if (market.pool0Insurance &gt;= needed) {             market.pool0Insurance = market.pool0Insurance - needed;             totalHelds[token] = totalHelds[token].sub(needed);         } else {             maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);             maxCanRepayAmount = maxCanRepayAmount.add(remaining);             totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);             market.pool0Insurance = 0;         }     } else {         if (market.pool1Insurance &gt;= needed) {             market.pool1Insurance = market.pool1Insurance - needed;         } else {             maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);             maxCanRepayAmount = maxCanRepayAmount.add(remaining);             totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);             market.pool1Insurance = 0;         }     } }  function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {     // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);     Types.Market storage market = markets[marketId];     uint defaultFees = tradeSize.mul(market.feesRate).div(10000);     uint newFees = defaultFees;     // if trader holds more xOLE, then should enjoy trading discount.     if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) &gt; calculateConfig.feesDiscountThreshold) {         newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));     }     // if trader update price, then should enjoy trading discount.     if (market.priceUpdater == trader) {         newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));     }     uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);     IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));      newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);     if (token == market.token1) {         market.pool1Insurance = market.pool1Insurance.add(newInsurance);     } else {         market.pool0Insurance = market.pool0Insurance.add(newInsurance);     }      totalHelds[token] = totalHelds[token].add(newInsurance);     return newFees; }  function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){     if (sellAmount &gt; 0){         DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;         IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);         buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);     } }  function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){     if (buyAmount &gt; 0){         DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;         IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);         sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);     } }  /// @dev All credited on this contract and share with all token holder if any rewards for the transfer. function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {     return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount); }  /// @dev All credited on "to" if any taxes for the transfer. function doTransferOut(address to, IERC20 token, uint amount) internal {     OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount); }  /*** Admin Functions ***/ function setCalculateConfig(uint16 defaultFeesRate,     uint8 insuranceRatio,     uint16 defaultMarginLimit,     uint16 priceDiffientRatio,     uint16 updatePriceDiscount,     uint16 feesDiscount,     uint128 feesDiscountThreshold,     uint16 penaltyRatio,     uint8 maxLiquidationPriceDiffientRatio,     uint16 twapDuration) external override onlyAdmin() {     OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,         feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);     emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration); }  function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {     OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);     emit NewAddressConfig(controller, address(dexAggregator)); }  function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {     OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);     emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs); }  /// @notice List of all supporting Dexes. /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1 function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {     Types.Market storage market = markets[marketId];     if (poolIndex == 0) {         market.pool0Insurance = market.pool0Insurance.sub(amount);         (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));         return;     }     market.pool1Insurance = market.pool1Insurance.sub(amount);     (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this)))); }  function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {     supportDexs[dex] = support; }  function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){     taxes[marketId][token][index] = tax; }  function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {     Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];     OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade); }  function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {     verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());     require(closeHeld &lt;= trade.held, "CBH"); }  function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {     require(held != 0 &amp;&amp; lastBlockNumber != block.number &amp;&amp; OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0"); }  modifier onlySupportDex(bytes memory dexData) {     require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");     _; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.7.6;\n\npragma experimental ABIEncoderV2;\n\nimport "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\nimport "./OpenLevInterface.sol";\nimport "./Types.sol";\nimport "./Adminable.sol";\nimport "./DelegateInterface.sol";\nimport "./ControllerInterface.sol";\nimport "./IWETH.sol";\nimport "./XOLEInterface.sol";\nimport "./Types.sol";\nimport "./OpenLevV1Lib.sol";\n\n/// @title OpenLeverage margin trade logic\n/// @author OpenLeverage\n/// @notice Use this contract for margin trade.\n/// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE.\ncontract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {\n    using SafeMath for uint;\n    using TransferHelper for IERC20;\n    using DexData for bytes;\n\n    constructor ()\n    {\n    }\n\n    /// @notice initialize proxy contract\n    /// @dev This function is not supposed to call multiple times. All configs can be set through other functions.\n    /// @param controller Address of contract ControllerDelegator.\n    /// @param _dexAggregator contract DexAggregatorDelegator.\n    /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens.\n    /// @param _wETH Address of wrapped native coin.\n    /// @param _xOLE Address of XOLEDelegator.\n    /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol.\n    function initialize(\n        address _controller,\n        DexAggregatorInterface _dexAggregator,\n        address[] memory depositTokens,\n        address _wETH,\n        address _xOLE,\n        uint8[] memory _supportDexs\n    ) public {\n        depositTokens;\n        require(msg.sender == admin, "NAD");\n        addressConfig.controller = _controller;\n        addressConfig.dexAggregator = _dexAggregator;\n        addressConfig.wETH = _wETH;\n        addressConfig.xOLE = _xOLE;\n        for (uint i = 0; i &lt; _supportDexs.length; i++) {\n            supportDexs[_supportDexs[i]] = true;\n        }\n        OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig);\n    }\n\n    /// @notice Create new trading pair.\n    /// @dev This function is typically called by ControllerDelegator.\n    /// @param pool0 Contract LpoolDelegator, lending pool of token0.\n    /// @param pool1 Contract LpoolDelegator, lending pool of token1.\n    /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value.\n    /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens.\n    /// @return The new created pair ID.\n    function addMarket(\n        LPoolInterface pool0,\n        LPoolInterface pool1,\n        uint16 marginLimit,\n        bytes memory dexData\n    ) external override returns (uint16) {\n        uint16 marketId = numPairs;\n        OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);\n        numPairs ++;\n        return marketId;\n    }\n\n    /// @notice Margin trade or just add more deposit tokens.\n    /// @dev To support token with tax and reward. Stores share of all token balances of this contract.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param depositToken Token to deposit. False for token0, true for token1.\n    /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported.\n    /// @param borrow Amount of ERC20 to borrow from the short token pool.\n    /// @param minBuyAmount Slippage for Dex trading.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function marginTrade(\n        uint16 marketId,\n        bool longToken,\n        bool depositToken,\n        uint deposit,\n        uint borrow,\n        uint minBuyAmount,\n        bytes memory dexData\n    ) external payable override nonReentrant onlySupportDex(dexData) {\n        Types.TradeVars memory tv;\n        Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);\n        verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);\n        (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);\n\n        if (dexData.isUniV2Class()) {\n            OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);\n        }\n\n        tv.totalHeld = totalHelds[address(vars.buyToken)];\n        tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;\n\n        deposit = transferIn(msg.sender, tv.depositErc20, deposit);\n\n        // Borrow\n        uint borrowed;\n        if (borrow &gt; 0) {\n            {\n                uint balance = vars.sellToken.balanceOf(address(this));\n                vars.sellPool.borrowBehalf(msg.sender, borrow);\n                borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);\n            }\n\n            if (depositToken == longToken){\n                (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);\n                tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));\n            }else{\n                tv.borrowValue = borrow;\n            }\n        }\n\n        require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) &gt; vars.marginLimit, "MAM");\n        tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);\n        tv.depositAfterFees = deposit.sub(tv.fees);\n        tv.dexDetail = dexData.toDexDetail();\n\n        if (depositToken == longToken ){\n            if (borrowed &gt; 0){\n                tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);\n                tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);\n            }\n            tv.newHeld = tv.newHeld.add(tv.depositAfterFees);\n        }else{\n            tv.tradeSize = tv.depositAfterFees.add(borrowed);\n            tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);\n            tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);\n        }\n\n        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];\n        tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);\n        trade.held = trade.held.add(tv.newHeld);\n        trade.depositToken = depositToken;\n        trade.deposited = trade.deposited.add(tv.depositAfterFees);\n        trade.lastBlockNum = uint128(block.number);\n\n        totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);\n\n        require(OpenLevV1Lib.isPositionHealthy(\n                msg.sender,\n                true,\n                OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),\n                vars,\n                dexData\n            ), "PNH");\n\n        emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail);\n    }\n\n    /// @notice Close trade by shares.\n    /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param closeHeld Amount of shares to close.\n    /// @param minOrMaxAmount Slippage for Dex trading.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {\n        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];\n        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);\n\n        //verify\n        verifyCloseBefore(trade, marketVars, closeHeld, dexData);\n\n        uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n\n        Types.CloseTradeVars memory closeTradeVars;\n        closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n        closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);\n        closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);\n        closeTradeVars.isPartialClose = closeHeld != trade.held;\n        closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);\n        closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);\n        closeTradeVars.dexDetail = dexData.toDexDetail();\n\n        //partial close\n        if (closeTradeVars.isPartialClose) {\n            closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);\n            closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);\n            trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);\n        } else {\n            closeTradeVars.depositDecrease = trade.deposited;\n        }\n\n        if (trade.depositToken != longToken) {\n            minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);\n            closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);\n            require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");\n\n            closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;\n            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);\n\n            closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);\n            doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);\n        } else {\n            uint balance = marketVars.buyToken.balanceOf(address(this));\n            minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);\n            closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);\n            closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);\n            require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");\n\n            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);\n            closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);\n            require(marketVars.sellToken.balanceOf(address(this)) &gt;= closeTradeVars.depositReturn, "ISB");\n            doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);\n        }\n\n        uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));\n        require(repayed &gt;= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");\n\n        if (!closeTradeVars.isPartialClose) {\n            delete activeTrades[msg.sender][marketId][longToken];\n        }else{\n            trade.held = trade.held.sub(closeHeld);\n            trade.lastBlockNum = uint128(block.number);\n        }\n\n        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);\n\n        closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);\n        if (dexData.isUniV2Class()) {\n            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);\n        }\n\n        emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,\n            closeTradeVars.token0Price, closeTradeVars.dexDetail);\n    }\n\n    /// @notice Liquidate if trade below margin limit.\n    /// @dev For trades without sufficient funds to repay, use insurance.\n    /// @param owner Owner of the trade to liquidate.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param minBuy Slippage for Dex trading.\n    /// @param maxSell Slippage for Dex trading.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {\n        Types.Trade memory trade = activeTrades[owner][marketId][longToken];\n        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);\n        if (dexData.isUniV2Class()) {\n            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);\n        }\n\n        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());\n        uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n\n        (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);\n        require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");\n\n        Types.LiquidateVars memory liquidateVars;\n        liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);\n        liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);\n        if (liquidateVars.penalty &gt; 0) {\n            doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);\n        }\n        liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);\n        liquidateVars.dexDetail = dexData.toDexDetail();\n        liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);\n        liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);\n        liquidateVars.marketId = marketId;\n        liquidateVars.longToken = longToken;\n\n        bool buySuccess;\n        bytes memory sellAmountData;\n        if (longToken == trade.depositToken) {\n            maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);\n            marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);\n            (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(\n                abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],\n                taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)\n            );\n        }\n\n        if (buySuccess) {\n            {\n                uint temp;\n                assembly {\n                    temp := mload(add(sellAmountData, 0x20))\n                }\n                liquidateVars.sellAmount = temp;\n            }\n\n            liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);\n            marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);\n            liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);\n            doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);\n        } else {\n            liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;\n            liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);\n            if (liquidateVars.receiveAmount &gt;= liquidateVars.borrowed) {\n                // fail if buy failed but sell succeeded\n                require (longToken != trade.depositToken, "PH");\n                marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);\n                liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);\n                doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);\n            } else {\n                liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);\n                liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);\n                marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);\n            }\n        }\n\n        liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);\n        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);\n\n        emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,\n            trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);\n\n        delete activeTrades[owner][marketId][longToken];\n    }\n\n    function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {\n        return open == longToken ?\n        Types.MarketVars(\n            market.pool1,\n            market.pool0,\n            IERC20(market.token1),\n            IERC20(market.token0),\n            IERC20(market.token1).balanceOf(address(this)),\n            IERC20(market.token0).balanceOf(address(this)),\n            market.pool1Insurance,\n            market.pool0Insurance,\n            market.marginLimit,\n            market.priceDiffientRatio,\n            market.dexs) :\n        Types.MarketVars(\n            market.pool0,\n            market.pool1,\n            IERC20(market.token0),\n            IERC20(market.token1),\n            IERC20(market.token0).balanceOf(address(this)),\n            IERC20(market.token1).balanceOf(address(this)),\n            market.pool0Insurance,\n            market.pool1Insurance,\n            market.marginLimit,\n            market.priceDiffientRatio,\n            market.dexs);\n    }\n\n    /// @notice Get ratios of deposited token value to borrowed token value.\n    /// @dev Caluclate ratio with current price and twap price.\n    /// @param owner Owner of the trade to liquidate.\n    /// @param longToken Token to long. False for token0, true for token1.\n    /// @param dexData Index and fee rate for the trading Dex.\n    /// @return current Margin ratio calculated using current price.\n    /// @return cAvg Margin ratio calculated using twap price.\n    /// @return hAvg Margin ratio calculated using last recorded twap price.\n    /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value.\n    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {\n        Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);\n        limit = vars.marginLimit;\n        (current, cAvg, hAvg,,) =\n        OpenLevV1Lib.marginRatio(\n            owner,\n            activeTrades[owner][marketId][longToken].held,\n            address(vars.sellToken),\n            address(vars.buyToken),\n            vars.buyPool,\n            false,\n            dexData\n        );\n    }\n\n    /// @notice Check if a price update is required on Dex.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){\n        Types.Market memory market = markets[marketId];\n        return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData);\n    }\n\n    /// @notice Update price on Dex.\n    /// @param dexData Index and fee rate for the trading Dex.\n    function updatePrice(uint16 marketId, bytes memory dexData) external override {\n        OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData);\n    }\n\n    /// @notice List of all supporting Dexes.\n    function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){\n        return markets[marketId].dexs;\n    }\n\n    function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {\n        Types.Market storage market = markets[marketId];\n        uint needed = totalRepayment.sub(remaining);\n        needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);\n        maxCanRepayAmount = totalRepayment;\n        if (longToken) {\n            if (market.pool0Insurance &gt;= needed) {\n                market.pool0Insurance = market.pool0Insurance - needed;\n                totalHelds[token] = totalHelds[token].sub(needed);\n            } else {\n                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);\n                maxCanRepayAmount = maxCanRepayAmount.add(remaining);\n                totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);\n                market.pool0Insurance = 0;\n            }\n        } else {\n            if (market.pool1Insurance &gt;= needed) {\n                market.pool1Insurance = market.pool1Insurance - needed;\n            } else {\n                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);\n                maxCanRepayAmount = maxCanRepayAmount.add(remaining);\n                totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);\n                market.pool1Insurance = 0;\n            }\n        }\n    }\n\n    function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {\n        // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);\n        Types.Market storage market = markets[marketId];\n        uint defaultFees = tradeSize.mul(market.feesRate).div(10000);\n        uint newFees = defaultFees;\n        // if trader holds more xOLE, then should enjoy trading discount.\n        if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) &gt; calculateConfig.feesDiscountThreshold) {\n            newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));\n        }\n        // if trader update price, then should enjoy trading discount.\n        if (market.priceUpdater == trader) {\n            newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));\n        }\n        uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);\n        IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));\n\n        newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);\n        if (token == market.token1) {\n            market.pool1Insurance = market.pool1Insurance.add(newInsurance);\n        } else {\n            market.pool0Insurance = market.pool0Insurance.add(newInsurance);\n        }\n\n        totalHelds[token] = totalHelds[token].add(newInsurance);\n        return newFees;\n    }\n\n    function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){\n        if (sellAmount &gt; 0){\n            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;\n            IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);\n            buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);\n        }\n    }\n\n    function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){\n        if (buyAmount &gt; 0){\n            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;\n            IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);\n            sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);\n        }\n    }\n\n    /// @dev All credited on this contract and share with all token holder if any rewards for the transfer.\n    function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {\n        return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount);\n    }\n\n    /// @dev All credited on "to" if any taxes for the transfer.\n    function doTransferOut(address to, IERC20 token, uint amount) internal {\n        OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount);\n    }\n\n    / Admin Functions /\n    function setCalculateConfig(uint16 defaultFeesRate,\n        uint8 insuranceRatio,\n        uint16 defaultMarginLimit,\n        uint16 priceDiffientRatio,\n        uint16 updatePriceDiscount,\n        uint16 feesDiscount,\n        uint128 feesDiscountThreshold,\n        uint16 penaltyRatio,\n        uint8 maxLiquidationPriceDiffientRatio,\n        uint16 twapDuration) external override onlyAdmin() {\n        OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,\n            feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);\n        emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration);\n    }\n\n    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {\n        OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);\n        emit NewAddressConfig(controller, address(dexAggregator));\n    }\n\n    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {\n        OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);\n        emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs);\n    }\n\n    /// @notice List of all supporting Dexes.\n    /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1\n    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {\n        Types.Market storage market = markets[marketId];\n        if (poolIndex == 0) {\n            market.pool0Insurance = market.pool0Insurance.sub(amount);\n            (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));\n            return;\n        }\n        market.pool1Insurance = market.pool1Insurance.sub(amount);\n        (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this))));\n    }\n\n    function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {\n        supportDexs[dex] = support;\n    }\n\n    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){\n        taxes[marketId][token][index] = tax;\n    }\n\n    function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {\n        Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];\n        OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade);\n    }\n\n    function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {\n        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());\n        require(closeHeld &lt;= trade.held, "CBH");\n    }\n\n    function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {\n        require(held != 0 &amp;&amp; lastBlockNumber != block.number &amp;&amp; OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0");\n    }\n\n    modifier onlySupportDex(bytes memory dexData) {\n        require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");\n        ;\n    }\n}', 'ideas': ' 1', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-24-08 18:28:30 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.7.6; pragma experimental ABIEncoderV2; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import "./OpenLevInterface.sol"; import "./Types.sol"; import "./Adminable.sol"; import "./DelegateInterface.sol"; import "./ControllerInterface.sol"; import "./IWETH.sol"; import "./XOLEInterface.sol"; import "./Types.sol"; import "./OpenLevV1Lib.sol"; /// @title OpenLeverage margin trade logic /// @author OpenLeverage /// @notice Use this contract for margin trade. /// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE. contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {     using SafeMath for uint;     using TransferHelper for IERC20;     using DexData for bytes; constructor () { }  /// @notice initialize proxy contract /// @dev This function is not supposed to call multiple times. All configs can be set through other functions. /// @param _controller Address of contract ControllerDelegator. /// @param _dexAggregator contract DexAggregatorDelegator. /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens. /// @param _wETH Address of wrapped native coin. /// @param _xOLE Address of XOLEDelegator. /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol. function initialize(     address _controller,     DexAggregatorInterface _dexAggregator,     address[] memory depositTokens,     address _wETH,     address _xOLE,     uint8[] memory _supportDexs ) public {     depositTokens;     require(msg.sender == admin, "NAD");     addressConfig.controller = _controller;     addressConfig.dexAggregator = _dexAggregator;     addressConfig.wETH = _wETH;     addressConfig.xOLE = _xOLE;     for (uint i = 0; i &lt; _supportDexs.length; i++) {         supportDexs[_supportDexs[i]] = true;     }     OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig); }  /// @notice Create new trading pair. /// @dev This function is typically called by ControllerDelegator. /// @param pool0 Contract LpoolDelegator, lending pool of token0. /// @param pool1 Contract LpoolDelegator, lending pool of token1. /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value. /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens. /// @return The new created pair ID. function addMarket(     LPoolInterface pool0,     LPoolInterface pool1,     uint16 marginLimit,     bytes memory dexData ) external override returns (uint16) {     uint16 marketId = numPairs;     OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);     numPairs ++;     return marketId; }  /// @notice Margin trade or just add more deposit tokens. /// @dev To support token with tax and reward. Stores share of all token balances of this contract. /// @param longToken Token to long. False for token0, true for token1. /// @param depositToken Token to deposit. False for token0, true for token1. /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported. /// @param borrow Amount of ERC20 to borrow from the short token pool. /// @param minBuyAmount Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function marginTrade(     uint16 marketId,     bool longToken,     bool depositToken,     uint deposit,     uint borrow,     uint minBuyAmount,     bytes memory dexData ) external payable override nonReentrant onlySupportDex(dexData) {     Types.TradeVars memory tv;     Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);     verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);     (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);      if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);     }      tv.totalHeld = totalHelds[address(vars.buyToken)];     tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;      deposit = transferIn(msg.sender, tv.depositErc20, deposit);      // Borrow     uint borrowed;     if (borrow &gt; 0) {         {             uint balance = vars.sellToken.balanceOf(address(this));             vars.sellPool.borrowBehalf(msg.sender, borrow);             borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);         }          if (depositToken == longToken){             (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);             tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));         }else{             tv.borrowValue = borrow;         }     }      require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) &gt; vars.marginLimit, "MAM");     tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);     tv.depositAfterFees = deposit.sub(tv.fees);     tv.dexDetail = dexData.toDexDetail();      if (depositToken == longToken ){         if (borrowed &gt; 0){             tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);             tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);         }         tv.newHeld = tv.newHeld.add(tv.depositAfterFees);     }else{         tv.tradeSize = tv.depositAfterFees.add(borrowed);         tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);         tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);     }      Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];     tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);     trade.held = trade.held.add(tv.newHeld);     trade.depositToken = depositToken;     trade.deposited = trade.deposited.add(tv.depositAfterFees);     trade.lastBlockNum = uint128(block.number);      totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);      require(OpenLevV1Lib.isPositionHealthy(             msg.sender,             true,             OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),             vars,             dexData         ), "PNH");      emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail); }  /// @notice Close trade by shares. /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed. /// @param longToken Token to long. False for token0, true for token1. /// @param closeHeld Amount of shares to close. /// @param minOrMaxAmount Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {     Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];     Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);      //verify     verifyCloseBefore(trade, marketVars, closeHeld, dexData);      uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);      Types.CloseTradeVars memory closeTradeVars;     closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);     closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);     closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);     closeTradeVars.isPartialClose = closeHeld != trade.held;     closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);     closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);     closeTradeVars.dexDetail = dexData.toDexDetail();      //partial close     if (closeTradeVars.isPartialClose) {         closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);         closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);         trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);     } else {         closeTradeVars.depositDecrease = trade.deposited;     }      if (trade.depositToken != longToken) {         minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);         closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);         require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");          closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;         marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);          closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);         doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);     } else {         uint balance = marketVars.buyToken.balanceOf(address(this));         minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);         closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);         closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);         require(closeTradeVars.receiveAmount &gt;= closeTradeVars.repayAmount, "ISR");          marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);         closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);         require(marketVars.sellToken.balanceOf(address(this)) &gt;= closeTradeVars.depositReturn, "ISB");         doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);     }      uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));     require(repayed &gt;= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");      if (!closeTradeVars.isPartialClose) {         delete activeTrades[msg.sender][marketId][longToken];     }else{         trade.held = trade.held.sub(closeHeld);         trade.lastBlockNum = uint128(block.number);     }      totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);      closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);     if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);     }      emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,         closeTradeVars.token0Price, closeTradeVars.dexDetail); }  /// @notice Liquidate if trade below margin limit. /// @dev For trades without sufficient funds to repay, use insurance. /// @param owner Owner of the trade to liquidate. /// @param longToken Token to long. False for token0, true for token1. /// @param minBuy Slippage for Dex trading. /// @param maxSell Slippage for Dex trading. /// @param dexData Index and fee rate for the trading Dex. function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {     Types.Trade memory trade = activeTrades[owner][marketId][longToken];     Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);     if (dexData.isUniV2Class()) {         OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);     }      verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());     uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);      (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);     require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");      Types.LiquidateVars memory liquidateVars;     liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);     liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);     if (liquidateVars.penalty &gt; 0) {         doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);     }     liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);     liquidateVars.dexDetail = dexData.toDexDetail();     liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);     liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);     liquidateVars.marketId = marketId;     liquidateVars.longToken = longToken;      bool buySuccess;     bytes memory sellAmountData;     if (longToken == trade.depositToken) {         maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);         marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);         (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(             abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],             taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)         );     }      if (buySuccess) {         {             uint temp;             assembly {                 temp := mload(add(sellAmountData, 0x20))             }             liquidateVars.sellAmount = temp;         }          liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);         marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);         liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);         doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);     } else {         liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;         liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);         if (liquidateVars.receiveAmount &gt;= liquidateVars.borrowed) {             // fail if buy failed but sell succeeded             require (longToken != trade.depositToken, "PH");             marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);             liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);             doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);         } else {             liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);             liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);             marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);         }     }      liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);     totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);      emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,         trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);      delete activeTrades[owner][marketId][longToken]; }  function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {     return open == longToken ?     Types.MarketVars(         market.pool1,         market.pool0,         IERC20(market.token1),         IERC20(market.token0),         IERC20(market.token1).balanceOf(address(this)),         IERC20(market.token0).balanceOf(address(this)),         market.pool1Insurance,         market.pool0Insurance,         market.marginLimit,         market.priceDiffientRatio,         market.dexs) :     Types.MarketVars(         market.pool0,         market.pool1,         IERC20(market.token0),         IERC20(market.token1),         IERC20(market.token0).balanceOf(address(this)),         IERC20(market.token1).balanceOf(address(this)),         market.pool0Insurance,         market.pool1Insurance,         market.marginLimit,         market.priceDiffientRatio,         market.dexs); }  /// @notice Get ratios of deposited token value to borrowed token value. /// @dev Caluclate ratio with current price and twap price. /// @param owner Owner of the trade to liquidate. /// @param longToken Token to long. False for token0, true for token1. /// @param dexData Index and fee rate for the trading Dex. /// @return current Margin ratio calculated using current price. /// @return cAvg Margin ratio calculated using twap price. /// @return hAvg Margin ratio calculated using last recorded twap price. /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value. function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {     Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);     limit = vars.marginLimit;     (current, cAvg, hAvg,,) =     OpenLevV1Lib.marginRatio(         owner,         activeTrades[owner][marketId][longToken].held,         address(vars.sellToken),         address(vars.buyToken),         vars.buyPool,         false,         dexData     ); }  /// @notice Check if a price update is required on Dex. /// @param dexData Index and fee rate for the trading Dex. function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){     Types.Market memory market = markets[marketId];     return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData); }  /// @notice Update price on Dex. /// @param dexData Index and fee rate for the trading Dex. function updatePrice(uint16 marketId, bytes memory dexData) external override {     OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData); }  /// @notice List of all supporting Dexes. function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){     return markets[marketId].dexs; }  function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {     Types.Market storage market = markets[marketId];     uint needed = totalRepayment.sub(remaining);     needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);     maxCanRepayAmount = totalRepayment;     if (longToken) {         if (market.pool0Insurance &gt;= needed) {             market.pool0Insurance = market.pool0Insurance - needed;             totalHelds[token] = totalHelds[token].sub(needed);         } else {             maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);             maxCanRepayAmount = maxCanRepayAmount.add(remaining);             totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);             market.pool0Insurance = 0;         }     } else {         if (market.pool1Insurance &gt;= needed) {             market.pool1Insurance = market.pool1Insurance - needed;         } else {             maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);             maxCanRepayAmount = maxCanRepayAmount.add(remaining);             totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);             market.pool1Insurance = 0;         }     } }  function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {     // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);     Types.Market storage market = markets[marketId];     uint defaultFees = tradeSize.mul(market.feesRate).div(10000);     uint newFees = defaultFees;     // if trader holds more xOLE, then should enjoy trading discount.     if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) &gt; calculateConfig.feesDiscountThreshold) {         newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));     }     // if trader update price, then should enjoy trading discount.     if (market.priceUpdater == trader) {         newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));     }     uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);     IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));      newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);     if (token == market.token1) {         market.pool1Insurance = market.pool1Insurance.add(newInsurance);     } else {         market.pool0Insurance = market.pool0Insurance.add(newInsurance);     }      totalHelds[token] = totalHelds[token].add(newInsurance);     return newFees; }  function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){     if (sellAmount &gt; 0){         DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;         IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);         buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);     } }  function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){     if (buyAmount &gt; 0){         DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;         IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);         sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);     } }  /// @dev All credited on this contract and share with all token holder if any rewards for the transfer. function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {     return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount); }  /// @dev All credited on "to" if any taxes for the transfer. function doTransferOut(address to, IERC20 token, uint amount) internal {     OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount); }  /*** Admin Functions ***/ function setCalculateConfig(uint16 defaultFeesRate,     uint8 insuranceRatio,     uint16 defaultMarginLimit,     uint16 priceDiffientRatio,     uint16 updatePriceDiscount,     uint16 feesDiscount,     uint128 feesDiscountThreshold,     uint16 penaltyRatio,     uint8 maxLiquidationPriceDiffientRatio,     uint16 twapDuration) external override onlyAdmin() {     OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,         feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);     emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration); }  function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {     OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);     emit NewAddressConfig(controller, address(dexAggregator)); }  function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {     OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);     emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs); }  /// @notice List of all supporting Dexes. /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1 function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {     Types.Market storage market = markets[marketId];     if (poolIndex == 0) {         market.pool0Insurance = market.pool0Insurance.sub(amount);         (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));         return;     }     market.pool1Insurance = market.pool1Insurance.sub(amount);     (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this)))); }  function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {     supportDexs[dex] = support; }  function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){     taxes[marketId][token][index] = tax; }  function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {     Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];     OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade); }  function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {     verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());     require(closeHeld &lt;= trade.held, "CBH"); }  function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {     require(held != 0 &amp;&amp; lastBlockNumber != block.number &amp;&amp; OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0"); }  modifier onlySupportDex(bytes memory dexData) {     require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");     _; }  } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-24-08 18:28:30 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;

pragma experimental ABIEncoderV2;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "./OpenLevInterface.sol";
import "./Types.sol";
import "./Adminable.sol";
import "./DelegateInterface.sol";
import "./ControllerInterface.sol";
import "./IWETH.sol";
import "./XOLEInterface.sol";
import "./Types.sol";
import "./OpenLevV1Lib.sol";

/// @title OpenLeverage margin trade logic
/// @author OpenLeverage
/// @notice Use this contract for margin trade.
/// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE.
contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {
    using SafeMath for uint;
    using TransferHelper for IERC20;
    using DexData for bytes;

    constructor ()
    {
    }

    /// @notice initialize proxy contract
    /// @dev This function is not supposed to call multiple times. All configs can be set through other functions.
    /// @param _controller Address of contract ControllerDelegator.
    /// @param _dexAggregator contract DexAggregatorDelegator.
    /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens.
    /// @param _wETH Address of wrapped native coin.
    /// @param _xOLE Address of XOLEDelegator.
    /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol.
    function initialize(
        address _controller,
        DexAggregatorInterface _dexAggregator,
        address[] memory depositTokens,
        address _wETH,
        address _xOLE,
        uint8[] memory _supportDexs
    ) public {
        depositTokens;
        require(msg.sender == admin, "NAD");
        addressConfig.controller = _controller;
        addressConfig.dexAggregator = _dexAggregator;
        addressConfig.wETH = _wETH;
        addressConfig.xOLE = _xOLE;
        for (uint i = 0; i < _supportDexs.length; i++) {
            supportDexs[_supportDexs[i]] = true;
        }
        OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig);
    }

    /// @notice Create new trading pair.
    /// @dev This function is typically called by ControllerDelegator.
    /// @param pool0 Contract LpoolDelegator, lending pool of token0.
    /// @param pool1 Contract LpoolDelegator, lending pool of token1.
    /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value.
    /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens.
    /// @return The new created pair ID.
    function addMarket(
        LPoolInterface pool0,
        LPoolInterface pool1,
        uint16 marginLimit,
        bytes memory dexData
    ) external override returns (uint16) {
        uint16 marketId = numPairs;
        OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);
        numPairs ++;
        return marketId;
    }

    /// @notice Margin trade or just add more deposit tokens.
    /// @dev To support token with tax and reward. Stores share of all token balances of this contract.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param depositToken Token to deposit. False for token0, true for token1.
    /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported.
    /// @param borrow Amount of ERC20 to borrow from the short token pool.
    /// @param minBuyAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function marginTrade(
        uint16 marketId,
        bool longToken,
        bool depositToken,
        uint deposit,
        uint borrow,
        uint minBuyAmount,
        bytes memory dexData
    ) external payable override nonReentrant onlySupportDex(dexData) {
        Types.TradeVars memory tv;
        Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);
        verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);
        (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);

        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);
        }

        tv.totalHeld = totalHelds[address(vars.buyToken)];
        tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;

        deposit = transferIn(msg.sender, tv.depositErc20, deposit);

        // Borrow
        uint borrowed;
        if (borrow > 0) {
            {
                uint balance = vars.sellToken.balanceOf(address(this));
                vars.sellPool.borrowBehalf(msg.sender, borrow);
                borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);
            }

            if (depositToken == longToken){
                (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);
                tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));
            }else{
                tv.borrowValue = borrow;
            }
        }

        require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) > vars.marginLimit, "MAM");
        tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);
        tv.depositAfterFees = deposit.sub(tv.fees);
        tv.dexDetail = dexData.toDexDetail();

        if (depositToken == longToken ){
            if (borrowed > 0){
                tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);
                tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);
            }
            tv.newHeld = tv.newHeld.add(tv.depositAfterFees);
        }else{
            tv.tradeSize = tv.depositAfterFees.add(borrowed);
            tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);
            tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);
        }

        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);
        trade.held = trade.held.add(tv.newHeld);
        trade.depositToken = depositToken;
        trade.deposited = trade.deposited.add(tv.depositAfterFees);
        trade.lastBlockNum = uint128(block.number);

        totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);

        require(OpenLevV1Lib.isPositionHealthy(
                msg.sender,
                true,
                OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),
                vars,
                dexData
            ), "PNH");

        emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail);
    }

    /// @notice Close trade by shares.
    /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param closeHeld Amount of shares to close.
    /// @param minOrMaxAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);

        //verify
        verifyCloseBefore(trade, marketVars, closeHeld, dexData);

        uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        Types.CloseTradeVars memory closeTradeVars;
        closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);
        closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);
        closeTradeVars.isPartialClose = closeHeld != trade.held;
        closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);
        closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        closeTradeVars.dexDetail = dexData.toDexDetail();

        //partial close
        if (closeTradeVars.isPartialClose) {
            closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);
            closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);
            trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);
        } else {
            closeTradeVars.depositDecrease = trade.deposited;
        }

        if (trade.depositToken != longToken) {
            minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);
            closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;
            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);

            closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);
            doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);
        } else {
            uint balance = marketVars.buyToken.balanceOf(address(this));
            minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);
            closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);
            closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);
            closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);
            require(marketVars.sellToken.balanceOf(address(this)) >= closeTradeVars.depositReturn, "ISB");
            doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);
        }

        uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));
        require(repayed >= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");

        if (!closeTradeVars.isPartialClose) {
            delete activeTrades[msg.sender][marketId][longToken];
        }else{
            trade.held = trade.held.sub(closeHeld);
            trade.lastBlockNum = uint128(block.number);
        }

        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);

        closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,
            closeTradeVars.token0Price, closeTradeVars.dexDetail);
    }

    /// @notice Liquidate if trade below margin limit.
    /// @dev For trades without sufficient funds to repay, use insurance.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param minBuy Slippage for Dex trading.
    /// @param maxSell Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade memory trade = activeTrades[owner][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());
        uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);
        require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");

        Types.LiquidateVars memory liquidateVars;
        liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);
        if (liquidateVars.penalty > 0) {
            doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);
        }
        liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);
        liquidateVars.dexDetail = dexData.toDexDetail();
        liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);
        liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        liquidateVars.marketId = marketId;
        liquidateVars.longToken = longToken;

        bool buySuccess;
        bytes memory sellAmountData;
        if (longToken == trade.depositToken) {
            maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);
            marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);
            (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(
                abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],
                taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)
            );
        }

        if (buySuccess) {
            {
                uint temp;
                assembly {
                    temp := mload(add(sellAmountData, 0x20))
                }
                liquidateVars.sellAmount = temp;
            }

            liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);
            marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
            liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);
            doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);
        } else {
            liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;
            liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);
            if (liquidateVars.receiveAmount >= liquidateVars.borrowed) {
                // fail if buy failed but sell succeeded
                require (longToken != trade.depositToken, "PH");
                marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
                liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);
                doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);
            } else {
                liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);
                liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);
                marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);
            }
        }

        liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);
        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);

        emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,
            trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);

        delete activeTrades[owner][marketId][longToken];
    }

    function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {
        return open == longToken ?
        Types.MarketVars(
            market.pool1,
            market.pool0,
            IERC20(market.token1),
            IERC20(market.token0),
            IERC20(market.token1).balanceOf(address(this)),
            IERC20(market.token0).balanceOf(address(this)),
            market.pool1Insurance,
            market.pool0Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs) :
        Types.MarketVars(
            market.pool0,
            market.pool1,
            IERC20(market.token0),
            IERC20(market.token1),
            IERC20(market.token0).balanceOf(address(this)),
            IERC20(market.token1).balanceOf(address(this)),
            market.pool0Insurance,
            market.pool1Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs);
    }

    /// @notice Get ratios of deposited token value to borrowed token value.
    /// @dev Caluclate ratio with current price and twap price.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param dexData Index and fee rate for the trading Dex.
    /// @return current Margin ratio calculated using current price.
    /// @return cAvg Margin ratio calculated using twap price.
    /// @return hAvg Margin ratio calculated using last recorded twap price.
    /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value.
    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {
        Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);
        limit = vars.marginLimit;
        (current, cAvg, hAvg,,) =
        OpenLevV1Lib.marginRatio(
            owner,
            activeTrades[owner][marketId][longToken].held,
            address(vars.sellToken),
            address(vars.buyToken),
            vars.buyPool,
            false,
            dexData
        );
    }

    /// @notice Check if a price update is required on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){
        Types.Market memory market = markets[marketId];
        return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData);
    }

    /// @notice Update price on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function updatePrice(uint16 marketId, bytes memory dexData) external override {
        OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData);
    }

    /// @notice List of all supporting Dexes.
    function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){
        return markets[marketId].dexs;
    }

    function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {
        Types.Market storage market = markets[marketId];
        uint needed = totalRepayment.sub(remaining);
        needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);
        maxCanRepayAmount = totalRepayment;
        if (longToken) {
            if (market.pool0Insurance >= needed) {
                market.pool0Insurance = market.pool0Insurance - needed;
                totalHelds[token] = totalHelds[token].sub(needed);
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);
                market.pool0Insurance = 0;
            }
        } else {
            if (market.pool1Insurance >= needed) {
                market.pool1Insurance = market.pool1Insurance - needed;
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);
                market.pool1Insurance = 0;
            }
        }
    }

    function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {
        // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);
        Types.Market storage market = markets[marketId];
        uint defaultFees = tradeSize.mul(market.feesRate).div(10000);
        uint newFees = defaultFees;
        // if trader holds more xOLE, then should enjoy trading discount.
        if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) > calculateConfig.feesDiscountThreshold) {
            newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));
        }
        // if trader update price, then should enjoy trading discount.
        if (market.priceUpdater == trader) {
            newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));
        }
        uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);
        IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));

        newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);
        if (token == market.token1) {
            market.pool1Insurance = market.pool1Insurance.add(newInsurance);
        } else {
            market.pool0Insurance = market.pool0Insurance.add(newInsurance);
        }

        totalHelds[token] = totalHelds[token].add(newInsurance);
        return newFees;
    }

    function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){
        if (sellAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);
            buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);
        }
    }

    function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){
        if (buyAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);
            sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);
        }
    }

    /// @dev All credited on this contract and share with all token holder if any rewards for the transfer.
    function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {
        return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount);
    }

    /// @dev All credited on "to" if any taxes for the transfer.
    function doTransferOut(address to, IERC20 token, uint amount) internal {
        OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount);
    }

    /*** Admin Functions ***/
    function setCalculateConfig(uint16 defaultFeesRate,
        uint8 insuranceRatio,
        uint16 defaultMarginLimit,
        uint16 priceDiffientRatio,
        uint16 updatePriceDiscount,
        uint16 feesDiscount,
        uint128 feesDiscountThreshold,
        uint16 penaltyRatio,
        uint8 maxLiquidationPriceDiffientRatio,
        uint16 twapDuration) external override onlyAdmin() {
        OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,
            feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);
        emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration);
    }

    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {
        OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);
        emit NewAddressConfig(controller, address(dexAggregator));
    }

    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {
        OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);
        emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs);
    }

    /// @notice List of all supporting Dexes.
    /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1
    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {
        Types.Market storage market = markets[marketId];
        if (poolIndex == 0) {
            market.pool0Insurance = market.pool0Insurance.sub(amount);
            (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));
            return;
        }
        market.pool1Insurance = market.pool1Insurance.sub(amount);
        (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this))));
    }

    function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {
        supportDexs[dex] = support;
    }

    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){
        taxes[marketId][token][index] = tax;
    }

    function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {
        Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];
        OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade);
    }

    function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {
        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());
        require(closeHeld <= trade.held, "CBH");
    }

    function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {
        require(held != 0 && lastBlockNumber != block.number && OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0");
    }

    modifier onlySupportDex(bytes memory dexData) {
        require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");
        _;
    }
}.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;

pragma experimental ABIEncoderV2;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "./OpenLevInterface.sol";
import "./Types.sol";
import "./Adminable.sol";
import "./DelegateInterface.sol";
import "./ControllerInterface.sol";
import "./IWETH.sol";
import "./XOLEInterface.sol";
import "./Types.sol";
import "./OpenLevV1Lib.sol";

/// @title OpenLeverage margin trade logic
/// @author OpenLeverage
/// @notice Use this contract for margin trade.
/// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE.
contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {
    using SafeMath for uint;
    using TransferHelper for IERC20;
    using DexData for bytes;

    constructor ()
    {
    }

    /// @notice initialize proxy contract
    /// @dev This function is not supposed to call multiple times. All configs can be set through other functions.
    /// @param _controller Address of contract ControllerDelegator.
    /// @param _dexAggregator contract DexAggregatorDelegator.
    /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens.
    /// @param _wETH Address of wrapped native coin.
    /// @param _xOLE Address of XOLEDelegator.
    /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol.
    function initialize(
        address _controller,
        DexAggregatorInterface _dexAggregator,
        address[] memory depositTokens,
        address _wETH,
        address _xOLE,
        uint8[] memory _supportDexs
    ) public {
        depositTokens;
        require(msg.sender == admin, "NAD");
        addressConfig.controller = _controller;
        addressConfig.dexAggregator = _dexAggregator;
        addressConfig.wETH = _wETH;
        addressConfig.xOLE = _xOLE;
        for (uint i = 0; i < _supportDexs.length; i++) {
            supportDexs[_supportDexs[i]] = true;
        }
        OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig);
    }

    /// @notice Create new trading pair.
    /// @dev This function is typically called by ControllerDelegator.
    /// @param pool0 Contract LpoolDelegator, lending pool of token0.
    /// @param pool1 Contract LpoolDelegator, lending pool of token1.
    /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value.
    /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens.
    /// @return The new created pair ID.
    function addMarket(
        LPoolInterface pool0,
        LPoolInterface pool1,
        uint16 marginLimit,
        bytes memory dexData
    ) external override returns (uint16) {
        uint16 marketId = numPairs;
        OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);
        numPairs ++;
        return marketId;
    }

    /// @notice Margin trade or just add more deposit tokens.
    /// @dev To support token with tax and reward. Stores share of all token balances of this contract.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param depositToken Token to deposit. False for token0, true for token1.
    /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported.
    /// @param borrow Amount of ERC20 to borrow from the short token pool.
    /// @param minBuyAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function marginTrade(
        uint16 marketId,
        bool longToken,
        bool depositToken,
        uint deposit,
        uint borrow,
        uint minBuyAmount,
        bytes memory dexData
    ) external payable override nonReentrant onlySupportDex(dexData) {
        Types.TradeVars memory tv;
        Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);
        verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);
        (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);

        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);
        }

        tv.totalHeld = totalHelds[address(vars.buyToken)];
        tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;

        deposit = transferIn(msg.sender, tv.depositErc20, deposit);

        // Borrow
        uint borrowed;
        if (borrow > 0) {
            {
                uint balance = vars.sellToken.balanceOf(address(this));
                vars.sellPool.borrowBehalf(msg.sender, borrow);
                borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);
            }

            if (depositToken == longToken){
                (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);
                tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));
            }else{
                tv.borrowValue = borrow;
            }
        }

        require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) > vars.marginLimit, "MAM");
        tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);
        tv.depositAfterFees = deposit.sub(tv.fees);
        tv.dexDetail = dexData.toDexDetail();

        if (depositToken == longToken ){
            if (borrowed > 0){
                tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);
                tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);
            }
            tv.newHeld = tv.newHeld.add(tv.depositAfterFees);
        }else{
            tv.tradeSize = tv.depositAfterFees.add(borrowed);
            tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);
            tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);
        }

        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);
        trade.held = trade.held.add(tv.newHeld);
        trade.depositToken = depositToken;
        trade.deposited = trade.deposited.add(tv.depositAfterFees);
        trade.lastBlockNum = uint128(block.number);

        totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);

        require(OpenLevV1Lib.isPositionHealthy(
                msg.sender,
                true,
                OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),
                vars,
                dexData
            ), "PNH");

        emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail);
    }

    /// @notice Close trade by shares.
    /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param closeHeld Amount of shares to close.
    /// @param minOrMaxAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);

        //verify
        verifyCloseBefore(trade, marketVars, closeHeld, dexData);

        uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        Types.CloseTradeVars memory closeTradeVars;
        closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);
        closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);
        closeTradeVars.isPartialClose = closeHeld != trade.held;
        closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);
        closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        closeTradeVars.dexDetail = dexData.toDexDetail();

        //partial close
        if (closeTradeVars.isPartialClose) {
            closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);
            closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);
            trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);
        } else {
            closeTradeVars.depositDecrease = trade.deposited;
        }

        if (trade.depositToken != longToken) {
            minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);
            closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;
            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);

            closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);
            doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);
        } else {
            uint balance = marketVars.buyToken.balanceOf(address(this));
            minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);
            closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);
            closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);
            closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);
            require(marketVars.sellToken.balanceOf(address(this)) >= closeTradeVars.depositReturn, "ISB");
            doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);
        }

        uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));
        require(repayed >= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");

        if (!closeTradeVars.isPartialClose) {
            delete activeTrades[msg.sender][marketId][longToken];
        }else{
            trade.held = trade.held.sub(closeHeld);
            trade.lastBlockNum = uint128(block.number);
        }

        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);

        closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,
            closeTradeVars.token0Price, closeTradeVars.dexDetail);
    }

    /// @notice Liquidate if trade below margin limit.
    /// @dev For trades without sufficient funds to repay, use insurance.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param minBuy Slippage for Dex trading.
    /// @param maxSell Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade memory trade = activeTrades[owner][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());
        uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);
        require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");

        Types.LiquidateVars memory liquidateVars;
        liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);
        if (liquidateVars.penalty > 0) {
            doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);
        }
        liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);
        liquidateVars.dexDetail = dexData.toDexDetail();
        liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);
        liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        liquidateVars.marketId = marketId;
        liquidateVars.longToken = longToken;

        bool buySuccess;
        bytes memory sellAmountData;
        if (longToken == trade.depositToken) {
            maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);
            marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);
            (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(
                abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],
                taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)
            );
        }

        if (buySuccess) {
            {
                uint temp;
                assembly {
                    temp := mload(add(sellAmountData, 0x20))
                }
                liquidateVars.sellAmount = temp;
            }

            liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);
            marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
            liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);
            doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);
        } else {
            liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;
            liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);
            if (liquidateVars.receiveAmount >= liquidateVars.borrowed) {
                // fail if buy failed but sell succeeded
                require (longToken != trade.depositToken, "PH");
                marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
                liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);
                doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);
            } else {
                liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);
                liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);
                marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);
            }
        }

        liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);
        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);

        emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,
            trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);

        delete activeTrades[owner][marketId][longToken];
    }

    function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {
        return open == longToken ?
        Types.MarketVars(
            market.pool1,
            market.pool0,
            IERC20(market.token1),
            IERC20(market.token0),
            IERC20(market.token1).balanceOf(address(this)),
            IERC20(market.token0).balanceOf(address(this)),
            market.pool1Insurance,
            market.pool0Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs) :
        Types.MarketVars(
            market.pool0,
            market.pool1,
            IERC20(market.token0),
            IERC20(market.token1),
            IERC20(market.token0).balanceOf(address(this)),
            IERC20(market.token1).balanceOf(address(this)),
            market.pool0Insurance,
            market.pool1Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs);
    }

    /// @notice Get ratios of deposited token value to borrowed token value.
    /// @dev Caluclate ratio with current price and twap price.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param dexData Index and fee rate for the trading Dex.
    /// @return current Margin ratio calculated using current price.
    /// @return cAvg Margin ratio calculated using twap price.
    /// @return hAvg Margin ratio calculated using last recorded twap price.
    /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value.
    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {
        Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);
        limit = vars.marginLimit;
        (current, cAvg, hAvg,,) =
        OpenLevV1Lib.marginRatio(
            owner,
            activeTrades[owner][marketId][longToken].held,
            address(vars.sellToken),
            address(vars.buyToken),
            vars.buyPool,
            false,
            dexData
        );
    }

    /// @notice Check if a price update is required on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){
        Types.Market memory market = markets[marketId];
        return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData);
    }

    /// @notice Update price on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function updatePrice(uint16 marketId, bytes memory dexData) external override {
        OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData);
    }

    /// @notice List of all supporting Dexes.
    function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){
        return markets[marketId].dexs;
    }

    function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {
        Types.Market storage market = markets[marketId];
        uint needed = totalRepayment.sub(remaining);
        needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);
        maxCanRepayAmount = totalRepayment;
        if (longToken) {
            if (market.pool0Insurance >= needed) {
                market.pool0Insurance = market.pool0Insurance - needed;
                totalHelds[token] = totalHelds[token].sub(needed);
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);
                market.pool0Insurance = 0;
            }
        } else {
            if (market.pool1Insurance >= needed) {
                market.pool1Insurance = market.pool1Insurance - needed;
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);
                market.pool1Insurance = 0;
            }
        }
    }

    function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {
        // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);
        Types.Market storage market = markets[marketId];
        uint defaultFees = tradeSize.mul(market.feesRate).div(10000);
        uint newFees = defaultFees;
        // if trader holds more xOLE, then should enjoy trading discount.
        if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) > calculateConfig.feesDiscountThreshold) {
            newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));
        }
        // if trader update price, then should enjoy trading discount.
        if (market.priceUpdater == trader) {
            newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));
        }
        uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);
        IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));

        newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);
        if (token == market.token1) {
            market.pool1Insurance = market.pool1Insurance.add(newInsurance);
        } else {
            market.pool0Insurance = market.pool0Insurance.add(newInsurance);
        }

        totalHelds[token] = totalHelds[token].add(newInsurance);
        return newFees;
    }

    function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){
        if (sellAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);
            buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);
        }
    }

    function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){
        if (buyAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);
            sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);
        }
    }

    /// @dev All credited on this contract and share with all token holder if any rewards for the transfer.
    function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {
        return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount);
    }

    /// @dev All credited on "to" if any taxes for the transfer.
    function doTransferOut(address to, IERC20 token, uint amount) internal {
        OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount);
    }

    /*** Admin Functions ***/
    function setCalculateConfig(uint16 defaultFeesRate,
        uint8 insuranceRatio,
        uint16 defaultMarginLimit,
        uint16 priceDiffientRatio,
        uint16 updatePriceDiscount,
        uint16 feesDiscount,
        uint128 feesDiscountThreshold,
        uint16 penaltyRatio,
        uint8 maxLiquidationPriceDiffientRatio,
        uint16 twapDuration) external override onlyAdmin() {
        OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,
            feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);
        emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration);
    }

    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {
        OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);
        emit NewAddressConfig(controller, address(dexAggregator));
    }

    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {
        OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);
        emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs);
    }

    /// @notice List of all supporting Dexes.
    /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1
    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {
        Types.Market storage market = markets[marketId];
        if (poolIndex == 0) {
            market.pool0Insurance = market.pool0Insurance.sub(amount);
            (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));
            return;
        }
        market.pool1Insurance = market.pool1Insurance.sub(amount);
        (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this))));
    }

    function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {
        supportDexs[dex] = support;
    }

    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){
        taxes[marketId][token][index] = tax;
    }

    function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {
        Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];
        OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade);
    }

    function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {
        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());
        require(closeHeld <= trade.held, "CBH");
    }

    function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {
        require(held != 0 && lastBlockNumber != block.number && OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0");
    }

    modifier onlySupportDex(bytes memory dexData) {
        require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");
        _;
    }
}".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

[2024-24-08 18:28:32 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-24-08 18:28:32 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 14196
completion_tokens: 1
total_tokens: 14197
cost: $0.042592


[2024-24-08 18:28:32 INFO] Security Testing Engineer: **Security Testing Engineer<->Solidity Programming Expert on : TestBugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;

pragma experimental ABIEncoderV2;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "./OpenLevInterface.sol";
import "./Types.sol";
import "./Adminable.sol";
import "./DelegateInterface.sol";
import "./ControllerInterface.sol";
import "./IWETH.sol";
import "./XOLEInterface.sol";
import "./Types.sol";
import "./OpenLevV1Lib.sol";

/// @title OpenLeverage margin trade logic
/// @author OpenLeverage
/// @notice Use this contract for margin trade.
/// @dev Admin of this contract is the address of Timelock. Admin set configs and transfer insurance expected to XOLE.
contract OpenLevV1 is DelegateInterface, Adminable, ReentrancyGuard, OpenLevInterface, OpenLevStorage {
    using SafeMath for uint;
    using TransferHelper for IERC20;
    using DexData for bytes;

    constructor ()
    {
    }

    /// @notice initialize proxy contract
    /// @dev This function is not supposed to call multiple times. All configs can be set through other functions.
    /// @param _controller Address of contract ControllerDelegator.
    /// @param _dexAggregator contract DexAggregatorDelegator.
    /// @param depositTokens Tokens allowed to deposit. Removed from logic. Allows all tokens.
    /// @param _wETH Address of wrapped native coin.
    /// @param _xOLE Address of XOLEDelegator.
    /// @param _supportDexs Indexes of Dexes supported. Indexes are listed in contracts/lib/DexData.sol.
    function initialize(
        address _controller,
        DexAggregatorInterface _dexAggregator,
        address[] memory depositTokens,
        address _wETH,
        address _xOLE,
        uint8[] memory _supportDexs
    ) public {
        depositTokens;
        require(msg.sender == admin, "NAD");
        addressConfig.controller = _controller;
        addressConfig.dexAggregator = _dexAggregator;
        addressConfig.wETH = _wETH;
        addressConfig.xOLE = _xOLE;
        for (uint i = 0; i < _supportDexs.length; i++) {
            supportDexs[_supportDexs[i]] = true;
        }
        OpenLevV1Lib.setCalculateConfigInternal(22, 33, 2500, 5, 25, 25, 5000e18, 500, 5, 60, calculateConfig);
    }

    /// @notice Create new trading pair.
    /// @dev This function is typically called by ControllerDelegator.
    /// @param pool0 Contract LpoolDelegator, lending pool of token0.
    /// @param pool1 Contract LpoolDelegator, lending pool of token1.
    /// @param marginLimit The liquidation trigger ratio of deposited token value to borrowed token value.
    /// @param dexData Pair initiate data including index, feeRate of the Dex and tax rate of the underlying tokens.
    /// @return The new created pair ID.
    function addMarket(
        LPoolInterface pool0,
        LPoolInterface pool1,
        uint16 marginLimit,
        bytes memory dexData
    ) external override returns (uint16) {
        uint16 marketId = numPairs;
        OpenLevV1Lib.addMarket(pool0, pool1, marginLimit, dexData, marketId, markets, calculateConfig, addressConfig, supportDexs, taxes);
        numPairs ++;
        return marketId;
    }

    /// @notice Margin trade or just add more deposit tokens.
    /// @dev To support token with tax and reward. Stores share of all token balances of this contract.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param depositToken Token to deposit. False for token0, true for token1.
    /// @param deposit Amount of ERC20 tokens to deposit. WETH deposit is not supported.
    /// @param borrow Amount of ERC20 to borrow from the short token pool.
    /// @param minBuyAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function marginTrade(
        uint16 marketId,
        bool longToken,
        bool depositToken,
        uint deposit,
        uint borrow,
        uint minBuyAmount,
        bytes memory dexData
    ) external payable override nonReentrant onlySupportDex(dexData) {
        Types.TradeVars memory tv;
        Types.MarketVars memory vars = toMarketVar(longToken, true, markets[marketId]);
        verifyTrade(vars, marketId, longToken, depositToken, deposit, borrow, dexData);
        (ControllerInterface(addressConfig.controller)).marginTradeAllowed(marketId);

        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(vars.buyToken), address(vars.sellToken), dexData);
        }

        tv.totalHeld = totalHelds[address(vars.buyToken)];
        tv.depositErc20 = depositToken == longToken ? vars.buyToken : vars.sellToken;

        deposit = transferIn(msg.sender, tv.depositErc20, deposit);

        // Borrow
        uint borrowed;
        if (borrow > 0) {
            {
                uint balance = vars.sellToken.balanceOf(address(this));
                vars.sellPool.borrowBehalf(msg.sender, borrow);
                borrowed = vars.sellToken.balanceOf(address(this)).sub(balance);
            }

            if (depositToken == longToken){
                (uint currentPrice, uint8 priceDecimals) = addressConfig.dexAggregator.getPrice(address(vars.sellToken), address(vars.buyToken), dexData);
                tv.borrowValue = borrow.mul(currentPrice).div(10 ** uint(priceDecimals));
            }else{
                tv.borrowValue = borrow;
            }
        }

        require(borrow == 0 || deposit.mul(10000).div(tv.borrowValue) > vars.marginLimit, "MAM");
        tv.fees = feesAndInsurance(msg.sender, deposit.add(tv.borrowValue), address(tv.depositErc20), marketId, tv.totalHeld, vars.reserveBuyToken);
        tv.depositAfterFees = deposit.sub(tv.fees);
        tv.dexDetail = dexData.toDexDetail();

        if (depositToken == longToken ){
            if (borrowed > 0){
                tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), borrowed, minBuyAmount, dexData);
                tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(borrowed) : borrowed.mul(1e18).div(tv.newHeld);
            }
            tv.newHeld = tv.newHeld.add(tv.depositAfterFees);
        }else{
            tv.tradeSize = tv.depositAfterFees.add(borrowed);
            tv.newHeld = flashSell(marketId, address(vars.buyToken), address(vars.sellToken), tv.tradeSize, minBuyAmount, dexData);
            tv.token0Price = longToken ? tv.newHeld.mul(1e18).div(tv.tradeSize) : tv.tradeSize.mul(1e18).div(tv.newHeld);
        }

        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        tv.newHeld = OpenLevV1Lib.amountToShare(tv.newHeld, tv.totalHeld, vars.reserveBuyToken);
        trade.held = trade.held.add(tv.newHeld);
        trade.depositToken = depositToken;
        trade.deposited = trade.deposited.add(tv.depositAfterFees);
        trade.lastBlockNum = uint128(block.number);

        totalHelds[address(vars.buyToken)] = totalHelds[address(vars.buyToken)].add(tv.newHeld);

        require(OpenLevV1Lib.isPositionHealthy(
                msg.sender,
                true,
                OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(vars.buyToken)], vars.buyToken.balanceOf(address(this))),
                vars,
                dexData
            ), "PNH");

        emit MarginTrade(msg.sender, marketId, longToken, depositToken, deposit, borrow, tv.newHeld, tv.fees, tv.token0Price, tv.dexDetail);
    }

    /// @notice Close trade by shares.
    /// @dev To support token with tax, function expect to fail if share of borrowed funds not repayed.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param closeHeld Amount of shares to close.
    /// @param minOrMaxAmount Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function closeTrade(uint16 marketId, bool longToken, uint closeHeld, uint minOrMaxAmount, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade storage trade = activeTrades[msg.sender][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);

        //verify
        verifyCloseBefore(trade, marketVars, closeHeld, dexData);

        uint closeAmount = OpenLevV1Lib.shareToAmount(closeHeld, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        Types.CloseTradeVars memory closeTradeVars;
        closeTradeVars.fees = feesAndInsurance(msg.sender, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        closeTradeVars.closeAmountAfterFees = closeAmount.sub(closeTradeVars.fees);
        closeTradeVars.closeRatio = closeHeld.mul(1e18).div(trade.held);
        closeTradeVars.isPartialClose = closeHeld != trade.held;
        closeTradeVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(msg.sender);
        closeTradeVars.repayAmount = Utils.toAmountBeforeTax(closeTradeVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        closeTradeVars.dexDetail = dexData.toDexDetail();

        //partial close
        if (closeTradeVars.isPartialClose) {
            closeTradeVars.repayAmount = closeTradeVars.repayAmount.mul(closeTradeVars.closeRatio).div(1e18);
            closeTradeVars.depositDecrease = trade.deposited.mul(closeTradeVars.closeRatio).div(1e18);
            trade.deposited = trade.deposited.sub(closeTradeVars.depositDecrease);
        } else {
            closeTradeVars.depositDecrease = trade.deposited;
        }

        if (trade.depositToken != longToken) {
            minOrMaxAmount = Utils.maxOf(closeTradeVars.repayAmount, minOrMaxAmount);
            closeTradeVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.closeAmountAfterFees, minOrMaxAmount, dexData);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            closeTradeVars.sellAmount = closeTradeVars.closeAmountAfterFees;
            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);

            closeTradeVars.depositReturn = closeTradeVars.receiveAmount.sub(closeTradeVars.repayAmount);
            doTransferOut(msg.sender, marketVars.buyToken, closeTradeVars.depositReturn);
        } else {
            uint balance = marketVars.buyToken.balanceOf(address(this));
            minOrMaxAmount = Utils.minOf(closeTradeVars.closeAmountAfterFees, minOrMaxAmount);
            closeTradeVars.sellAmount = flashBuy(marketId, address(marketVars.buyToken), address(marketVars.sellToken), closeTradeVars.repayAmount, minOrMaxAmount, dexData);
            closeTradeVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(balance);
            require(closeTradeVars.receiveAmount >= closeTradeVars.repayAmount, "ISR");

            marketVars.buyPool.repayBorrowBehalf(msg.sender, closeTradeVars.repayAmount);
            closeTradeVars.depositReturn = closeTradeVars.closeAmountAfterFees.sub(closeTradeVars.sellAmount);
            require(marketVars.sellToken.balanceOf(address(this)) >= closeTradeVars.depositReturn, "ISB");
            doTransferOut(msg.sender, marketVars.sellToken, closeTradeVars.depositReturn);
        }

        uint repayed = closeTradeVars.borrowed.sub(marketVars.buyPool.borrowBalanceCurrent(msg.sender));
        require(repayed >= closeTradeVars.borrowed.mul(closeTradeVars.closeRatio).div(1e18), "IRP");

        if (!closeTradeVars.isPartialClose) {
            delete activeTrades[msg.sender][marketId][longToken];
        }else{
            trade.held = trade.held.sub(closeHeld);
            trade.lastBlockNum = uint128(block.number);
        }

        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(closeHeld);

        closeTradeVars.token0Price = longToken ? closeTradeVars.sellAmount.mul(1e18).div(closeTradeVars.receiveAmount) : closeTradeVars.receiveAmount.mul(1e18).div(closeTradeVars.sellAmount);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        emit TradeClosed(msg.sender, marketId, longToken, trade.depositToken, closeAmount, closeTradeVars.depositDecrease, closeTradeVars.depositReturn, closeTradeVars.fees,
            closeTradeVars.token0Price, closeTradeVars.dexDetail);
    }

    /// @notice Liquidate if trade below margin limit.
    /// @dev For trades without sufficient funds to repay, use insurance.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param minBuy Slippage for Dex trading.
    /// @param maxSell Slippage for Dex trading.
    /// @param dexData Index and fee rate for the trading Dex.
    function liquidate(address owner, uint16 marketId, bool longToken, uint minBuy, uint maxSell, bytes memory dexData) external override nonReentrant onlySupportDex(dexData) {
        Types.Trade memory trade = activeTrades[owner][marketId][longToken];
        Types.MarketVars memory marketVars = toMarketVar(longToken, false, markets[marketId]);
        if (dexData.isUniV2Class()) {
            OpenLevV1Lib.updatePriceInternal(address(marketVars.buyToken), address(marketVars.sellToken), dexData);
        }

        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, marketVars.dexs, dexData.toDexDetail());
        uint closeAmount = OpenLevV1Lib.shareToAmount(trade.held, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);

        (ControllerInterface(addressConfig.controller)).liquidateAllowed(marketId, msg.sender, closeAmount, dexData);
        require(!OpenLevV1Lib.isPositionHealthy(owner, false, closeAmount, marketVars, dexData), "PIH");

        Types.LiquidateVars memory liquidateVars;
        liquidateVars.fees = feesAndInsurance(owner, closeAmount, address(marketVars.sellToken), marketId, totalHelds[address(marketVars.sellToken)], marketVars.reserveSellToken);
        liquidateVars.penalty = closeAmount.mul(calculateConfig.penaltyRatio).div(10000);
        if (liquidateVars.penalty > 0) {
            doTransferOut(msg.sender, marketVars.sellToken, liquidateVars.penalty);
        }
        liquidateVars.remainAmountAfterFees = closeAmount.sub(liquidateVars.fees).sub(liquidateVars.penalty);
        liquidateVars.dexDetail = dexData.toDexDetail();
        liquidateVars.borrowed = marketVars.buyPool.borrowBalanceCurrent(owner);
        liquidateVars.borrowed = Utils.toAmountBeforeTax(liquidateVars.borrowed, taxes[marketId][address(marketVars.buyToken)][0]);
        liquidateVars.marketId = marketId;
        liquidateVars.longToken = longToken;

        bool buySuccess;
        bytes memory sellAmountData;
        if (longToken == trade.depositToken) {
            maxSell = Utils.minOf(maxSell, liquidateVars.remainAmountAfterFees);
            marketVars.sellToken.safeApprove(address(addressConfig.dexAggregator), maxSell);
            (buySuccess, sellAmountData) = address(addressConfig.dexAggregator).call(
                abi.encodeWithSelector(addressConfig.dexAggregator.buy.selector, address(marketVars.buyToken), address(marketVars.sellToken), taxes[liquidateVars.marketId][address(marketVars.buyToken)][2],
                taxes[liquidateVars.marketId][address(marketVars.sellToken)][1], liquidateVars.borrowed, maxSell, dexData)
            );
        }

        if (buySuccess) {
            {
                uint temp;
                assembly {
                    temp := mload(add(sellAmountData, 0x20))
                }
                liquidateVars.sellAmount = temp;
            }

            liquidateVars.receiveAmount = marketVars.buyToken.balanceOf(address(this)).sub(marketVars.reserveBuyToken);
            marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
            liquidateVars.depositReturn = liquidateVars.remainAmountAfterFees.sub(liquidateVars.sellAmount);
            doTransferOut(owner, marketVars.sellToken, liquidateVars.depositReturn);
        } else {
            liquidateVars.sellAmount = liquidateVars.remainAmountAfterFees;
            liquidateVars.receiveAmount = flashSell(marketId, address(marketVars.buyToken), address(marketVars.sellToken), liquidateVars.sellAmount, minBuy, dexData);
            if (liquidateVars.receiveAmount >= liquidateVars.borrowed) {
                // fail if buy failed but sell succeeded
                require (longToken != trade.depositToken, "PH");
                marketVars.buyPool.repayBorrowBehalf(owner, liquidateVars.borrowed);
                liquidateVars.depositReturn = liquidateVars.receiveAmount.sub(liquidateVars.borrowed);
                doTransferOut(owner, marketVars.buyToken, liquidateVars.depositReturn);
            } else {
                liquidateVars.finalRepayAmount = reduceInsurance(liquidateVars.borrowed, liquidateVars.receiveAmount, liquidateVars.marketId, liquidateVars.longToken, address(marketVars.buyToken), marketVars.reserveBuyToken);
                liquidateVars.outstandingAmount = liquidateVars.borrowed.sub(liquidateVars.finalRepayAmount);
                marketVars.buyPool.repayBorrowEndByOpenLev(owner, liquidateVars.finalRepayAmount);
            }
        }

        liquidateVars.token0Price = longToken ? liquidateVars.sellAmount.mul(1e18).div(liquidateVars.receiveAmount) : liquidateVars.receiveAmount.mul(1e18).div(liquidateVars.sellAmount);
        totalHelds[address(marketVars.sellToken)] = totalHelds[address(marketVars.sellToken)].sub(trade.held);

        emit Liquidation(owner, marketId, longToken, trade.depositToken, trade.held, liquidateVars.outstandingAmount, msg.sender,
            trade.deposited, liquidateVars.depositReturn, liquidateVars.fees, liquidateVars.token0Price, liquidateVars.penalty, liquidateVars.dexDetail);

        delete activeTrades[owner][marketId][longToken];
    }

    function toMarketVar(bool longToken, bool open, Types.Market storage market) internal view returns (Types.MarketVars memory) {
        return open == longToken ?
        Types.MarketVars(
            market.pool1,
            market.pool0,
            IERC20(market.token1),
            IERC20(market.token0),
            IERC20(market.token1).balanceOf(address(this)),
            IERC20(market.token0).balanceOf(address(this)),
            market.pool1Insurance,
            market.pool0Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs) :
        Types.MarketVars(
            market.pool0,
            market.pool1,
            IERC20(market.token0),
            IERC20(market.token1),
            IERC20(market.token0).balanceOf(address(this)),
            IERC20(market.token1).balanceOf(address(this)),
            market.pool0Insurance,
            market.pool1Insurance,
            market.marginLimit,
            market.priceDiffientRatio,
            market.dexs);
    }

    /// @notice Get ratios of deposited token value to borrowed token value.
    /// @dev Caluclate ratio with current price and twap price.
    /// @param owner Owner of the trade to liquidate.
    /// @param longToken Token to long. False for token0, true for token1.
    /// @param dexData Index and fee rate for the trading Dex.
    /// @return current Margin ratio calculated using current price.
    /// @return cAvg Margin ratio calculated using twap price.
    /// @return hAvg Margin ratio calculated using last recorded twap price.
    /// @return limit The liquidation trigger ratio of deposited token value to borrowed token value.
    function marginRatio(address owner, uint16 marketId, bool longToken, bytes memory dexData) external override onlySupportDex(dexData) view returns (uint current, uint cAvg, uint hAvg, uint32 limit) {
        Types.MarketVars memory vars = toMarketVar(longToken, false, markets[marketId]);
        limit = vars.marginLimit;
        (current, cAvg, hAvg,,) =
        OpenLevV1Lib.marginRatio(
            owner,
            activeTrades[owner][marketId][longToken].held,
            address(vars.sellToken),
            address(vars.buyToken),
            vars.buyPool,
            false,
            dexData
        );
    }

    /// @notice Check if a price update is required on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function shouldUpdatePrice(uint16 marketId, bytes memory dexData) external override view returns (bool){
        Types.Market memory market = markets[marketId];
        return OpenLevV1Lib.shouldUpdatePriceInternal(addressConfig.dexAggregator, calculateConfig.twapDuration,  market.priceDiffientRatio, market.token0, market.token1, dexData);
    }

    /// @notice Update price on Dex.
    /// @param dexData Index and fee rate for the trading Dex.
    function updatePrice(uint16 marketId, bytes memory dexData) external override {
        OpenLevV1Lib.updatePrice(marketId, markets[marketId], addressConfig, calculateConfig, dexData);
    }

    /// @notice List of all supporting Dexes.
    function getMarketSupportDexs(uint16 marketId) external override view returns (uint32[] memory){
        return markets[marketId].dexs;
    }

    function reduceInsurance(uint totalRepayment, uint remaining, uint16 marketId, bool longToken, address token, uint reserve) internal returns (uint maxCanRepayAmount) {
        Types.Market storage market = markets[marketId];
        uint needed = totalRepayment.sub(remaining);
        needed = OpenLevV1Lib.amountToShare(needed, totalHelds[token], reserve);
        maxCanRepayAmount = totalRepayment;
        if (longToken) {
            if (market.pool0Insurance >= needed) {
                market.pool0Insurance = market.pool0Insurance - needed;
                totalHelds[token] = totalHelds[token].sub(needed);
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool0Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool0Insurance);
                market.pool0Insurance = 0;
            }
        } else {
            if (market.pool1Insurance >= needed) {
                market.pool1Insurance = market.pool1Insurance - needed;
            } else {
                maxCanRepayAmount = OpenLevV1Lib.shareToAmount(market.pool1Insurance, totalHelds[token], reserve);
                maxCanRepayAmount = maxCanRepayAmount.add(remaining);
                totalHelds[token] = totalHelds[token].sub(market.pool1Insurance);
                market.pool1Insurance = 0;
            }
        }
    }

    function feesAndInsurance(address trader, uint tradeSize, address token, uint16 marketId, uint totalHeld, uint reserve) internal returns (uint) {
        // (uint fee, uint newInsurance) = OpenLevV1Lib.feesAndInsurance(markets[marketId], calculateConfig, addressConfig.xOLE, trader, tradeSize, token);
        Types.Market storage market = markets[marketId];
        uint defaultFees = tradeSize.mul(market.feesRate).div(10000);
        uint newFees = defaultFees;
        // if trader holds more xOLE, then should enjoy trading discount.
        if (XOLEInterface(addressConfig.xOLE).balanceOf(trader) > calculateConfig.feesDiscountThreshold) {
            newFees = defaultFees.sub(defaultFees.mul(calculateConfig.feesDiscount).div(100));
        }
        // if trader update price, then should enjoy trading discount.
        if (market.priceUpdater == trader) {
            newFees = newFees.sub(defaultFees.mul(calculateConfig.updatePriceDiscount).div(100));
        }
        uint newInsurance = newFees.mul(calculateConfig.insuranceRatio).div(100);
        IERC20(token).safeTransfer(addressConfig.xOLE, newFees.sub(newInsurance));

        newInsurance = OpenLevV1Lib.amountToShare(newInsurance, totalHeld, reserve);
        if (token == market.token1) {
            market.pool1Insurance = market.pool1Insurance.add(newInsurance);
        } else {
            market.pool0Insurance = market.pool0Insurance.add(newInsurance);
        }

        totalHelds[token] = totalHelds[token].add(newInsurance);
        return newFees;
    }

    function flashSell(uint16 marketId, address buyToken, address sellToken, uint sellAmount, uint minBuyAmount, bytes memory data) internal returns (uint buyAmount){
        if (sellAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), sellAmount);
            buyAmount = dexAggregator.sell(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], sellAmount, minBuyAmount, data);
        }
    }

    function flashBuy(uint16 marketId, address buyToken, address sellToken, uint buyAmount, uint maxSellAmount, bytes memory data) internal returns (uint sellAmount){
        if (buyAmount > 0){
            DexAggregatorInterface dexAggregator = addressConfig.dexAggregator;
            IERC20(sellToken).safeApprove(address(dexAggregator), maxSellAmount);
            sellAmount = dexAggregator.buy(buyToken, sellToken, taxes[marketId][buyToken][2], taxes[marketId][sellToken][1], buyAmount, maxSellAmount, data);
        }
    }

    /// @dev All credited on this contract and share with all token holder if any rewards for the transfer.
    function transferIn(address from, IERC20 token, uint amount) internal returns (uint) {
        return OpenLevV1Lib.transferIn(from, token, addressConfig.wETH, amount);
    }

    /// @dev All credited on "to" if any taxes for the transfer.
    function doTransferOut(address to, IERC20 token, uint amount) internal {
        OpenLevV1Lib.doTransferOut(to, token, addressConfig.wETH, amount);
    }

    /*** Admin Functions ***/
    function setCalculateConfig(uint16 defaultFeesRate,
        uint8 insuranceRatio,
        uint16 defaultMarginLimit,
        uint16 priceDiffientRatio,
        uint16 updatePriceDiscount,
        uint16 feesDiscount,
        uint128 feesDiscountThreshold,
        uint16 penaltyRatio,
        uint8 maxLiquidationPriceDiffientRatio,
        uint16 twapDuration) external override onlyAdmin() {
        OpenLevV1Lib.setCalculateConfigInternal(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount,
            feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration, calculateConfig);
        emit NewCalculateConfig(defaultFeesRate, insuranceRatio, defaultMarginLimit, priceDiffientRatio, updatePriceDiscount, feesDiscount, feesDiscountThreshold, penaltyRatio, maxLiquidationPriceDiffientRatio, twapDuration);
    }

    function setAddressConfig(address controller, DexAggregatorInterface dexAggregator) external override onlyAdmin() {
        OpenLevV1Lib.setAddressConfigInternal(controller, dexAggregator, addressConfig);
        emit NewAddressConfig(controller, address(dexAggregator));
    }

    function setMarketConfig(uint16 marketId, uint16 feesRate, uint16 marginLimit, uint16 priceDiffientRatio, uint32[] memory dexs) external override onlyAdmin() {
        OpenLevV1Lib.setMarketConfigInternal(feesRate, marginLimit, priceDiffientRatio, dexs, markets[marketId]);
        emit NewMarketConfig(marketId, feesRate, marginLimit, priceDiffientRatio, dexs);
    }

    /// @notice List of all supporting Dexes.
    /// @param poolIndex index of insurance pool, 0 for token0, 1 for token1
    function moveInsurance(uint16 marketId, uint8 poolIndex, address to, uint amount) external override nonReentrant() onlyAdmin() {
        Types.Market storage market = markets[marketId];
        if (poolIndex == 0) {
            market.pool0Insurance = market.pool0Insurance.sub(amount);
            (IERC20(market.token0)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token0], IERC20(market.token0).balanceOf(address(this))));
            return;
        }
        market.pool1Insurance = market.pool1Insurance.sub(amount);
        (IERC20(market.token1)).safeTransfer(to, OpenLevV1Lib.shareToAmount(amount, totalHelds[market.token1], IERC20(market.token1).balanceOf(address(this))));
    }

    function setSupportDex(uint8 dex, bool support) public override onlyAdmin() {
        supportDexs[dex] = support;
    }

    function setTaxRate(uint16 marketId, address token, uint index, uint24 tax) external override onlyAdmin(){
        taxes[marketId][token][index] = tax;
    }

    function verifyTrade(Types.MarketVars memory vars, uint16 marketId, bool longToken, bool depositToken, uint deposit, uint borrow, bytes memory dexData) internal view {
        Types.Trade memory trade = activeTrades[msg.sender][marketId][longToken];
        OpenLevV1Lib.verifyTrade(vars, longToken, depositToken, deposit, borrow, dexData, addressConfig, trade);
    }

    function verifyCloseBefore(Types.Trade memory trade, Types.MarketVars memory vars, uint closeHeld, bytes memory dexData) internal view {
        verifyCloseOrLiquidateBefore(trade.held, trade.lastBlockNum, vars.dexs, dexData.toDexDetail());
        require(closeHeld <= trade.held, "CBH");
    }

    function verifyCloseOrLiquidateBefore(uint held, uint lastBlockNumber, uint32[] memory dexs, uint32 dex) internal view {
        require(held != 0 && lastBlockNumber != block.number && OpenLevV1Lib.isInSupportDex(dexs, dex), "HI0");
    }

    modifier onlySupportDex(bytes memory dexData) {
        require(OpenLevV1Lib.isSupportDex(supportDexs, dexData.toDex()), "UDX");
        _;
    }
}.]

###

[2024-24-08 18:28:32 INFO] **[Seminar Conclusion]**:

 ###

[2024-24-08 18:28:32 INFO] **[Post Info]**

Software Info: 

**cost**=$0.000000

**version_updates**=1.0

**num_code_files**=0

**num_png_files**=0

**num_doc_files**=5

**code_lines**=0

**env_lines**=-1

**manual_lines**=-1

**num_utterances**=18

**num_self_reflections**=1

**num_prompt_tokens**=110892

**num_completion_tokens**=5884

**num_total_tokens**=116776

**duration**=86.00s

ChatDev Starts (20240824182706)

ChatDev Ends (20240824182832)



