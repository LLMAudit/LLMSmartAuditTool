[2024-24-08 19:27:54 INFO] **[Preprocessing]**

**ChatDev Starts** (20240824192754)

**Timestamp**: 20240824192754

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;


import "./LPoolInterface.sol";
import "./LPoolDepositor.sol";
import "../lib/Exponential.sol";
import "../Adminable.sol";
import "../lib/CarefulMath.sol";
import "../lib/TransferHelper.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import "../DelegateInterface.sol";
import "../ControllerInterface.sol";
import "../IWETH.sol";

/// @title OpenLeverage's LToken Contract
/// @dev Abstract base for LTokens
/// @author OpenLeverage
contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {
    using TransferHelper for IERC20;
    using SafeMath for uint;

    constructor() {

    }
    
    /// @notice Initialize the money market
    /// @param controller_ The address of the Controller
    /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0
    /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate
    /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point
    /// @param kink_ The utilization point at which the jump multiplier is applied
    /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
    /// @param name_ EIP-20 name of this token
    /// @param symbol_ EIP-20 symbol of this token
    /// @param decimals_ EIP-20 decimal precision of this token
    function initialize(
        address underlying_,
        bool isWethPool_,
        address controller_,
        uint256 baseRatePerBlock_,
        uint256 multiplierPerBlock_,
        uint256 jumpMultiplierPerBlock_,
        uint256 kink_,
        uint initialExchangeRateMantissa_,
        string memory name_,
        string memory symbol_,
        uint8 decimals_) public {
        require(underlying_ != address(0), "underlying_ address cannot be 0");
        require(controller_ != address(0), "controller_ address cannot be 0");
        require(msg.sender == admin, "Only allow to be called by admin");
        require(accrualBlockNumber == 0 && borrowIndex == 0, "inited once");

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial Exchange Rate Mantissa should be greater zero");
        //set controller
        controller = controller_;
        isWethPool = isWethPool_;
        //set interestRateModel
        baseRatePerBlock = baseRatePerBlock_;
        multiplierPerBlock = multiplierPerBlock_;
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        kink = kink_;

        // Initialize block number and borrow index (block number mocks depend on controller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = 1e25;
        //80%
        borrowCapFactorMantissa = 0.8e18;
        //10%
        reserveFactorMantissa = 0.1e18;


        name = name_;
        symbol = symbol_;
        decimals = decimals_;

        _notEntered = true;

        // Set underlying and sanity check it
        underlying = underlying_;
        IERC20(underlying).totalSupply();
        emit Transfer(address(0), msg.sender, 0);
    }

    /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
    /// @dev Called by both `transfer` and `transferFrom` internally
    /// @param spender The address of the account performing the transfer
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param tokens The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {
        require(dst != address(0), "dst address cannot be 0");
        /* Do not allow self-transfers */
        require(src != dst, "src = dst");
        /* Fail if transfer not allowed */
        (ControllerInterface(controller)).transferAllowed(src, dst, tokens);

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(- 1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        require(mathErr == MathError.NO_ERROR, 'not allowed');

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        require(mathErr == MathError.NO_ERROR, 'not enough');

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        require(mathErr == MathError.NO_ERROR, 'too much');

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(- 1)) {
            transferAllowances[src][spender] = allowanceNew;
        }
        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);
        return true;
    }

    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount);
    }

    /// @notice Transfer `amount` tokens from `src` to `dst`
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount);
    }

    /// @notice Approve `spender` to transfer up to `amount` from `src`
    /// @dev This will overwrite the approval amount for `spender`
    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
    /// @param spender The address of the account which may transfer tokens
    /// @param amount The number of tokens that are approved (-1 means infinite)
    /// @return Whether or not the approval succeeded
    function approve(address spender, uint256 amount) external override returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /// @notice Get the current allowance from `owner` for `spender`
    /// @param owner The address of the account which owns the tokens to be spent
    /// @param spender The address of the account which may transfer tokens
    /// @return The number of tokens allowed to be spent (-1 means infinite)
    function allowance(address owner, address spender) external override view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /// @notice Get the token balance of the `owner`
    /// @param owner The address of the account to query
    /// @return The number of tokens owned by `owner`
    function balanceOf(address owner) external override view returns (uint256) {
        return accountTokens[owner];
    }

    /// @notice Get the underlying balance of the `owner`
    /// @dev This also accrues interest in a transaction
    /// @param owner The address of the account to query
    /// @return The amount of underlying owned by `owner`
    function balanceOfUnderlying(address owner) external override returns (uint) {
        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR, "calc failed");
        return balance;
    }

    /*** User Interface ***/

    /// @notice Sender supplies assets into the market and receives lTokens in exchange
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param mintAmount The amount of the underlying asset to supply
    function mint(uint mintAmount) external override nonReentrant {
        accrueInterest();
        mintFresh(msg.sender, mintAmount, false);
    }

    function mintTo(address to, uint amount) external payable override nonReentrant {
        accrueInterest();
        if (isWethPool) {
            mintFresh(to, msg.value, false);
        } else {
            mintFresh(to, amount, true);
        }
    }

    function mintEth() external payable override nonReentrant {
        require(isWethPool, "not eth pool");
        accrueInterest();
        mintFresh(msg.sender, msg.value, false);
    }

    /// @notice Sender redeems lTokens in exchange for the underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemTokens The number of lTokens to redeem into underlying
    function redeem(uint redeemTokens) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, redeemTokens, 0);
    }

    /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemAmount The amount of underlying to redeem
    function redeemUnderlying(uint redeemAmount) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, 0, redeemAmount);
    }

    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {
        accrueInterest();
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        borrowFresh(payable(borrower), msg.sender, borrowAmount);
    }

    /// @notice Sender repays a borrow belonging to borrower
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount The amount to repay
    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        repayBorrowFresh(msg.sender, borrower, repayAmount, false);
    }

    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        repayBorrowFresh(msg.sender, borrower, repayAmount, true);
    }


    /*** Safe Token ***/

    /// Gets balance of this contract in terms of the underlying
    /// @dev This excludes the value of the current message, if any
    /// @return The quantity of underlying tokens owned by this contract
    function getCashPrior() internal view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }


    /**
     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.
     *      This will revert due to insufficient balance or insufficient allowance.
     *      This function returns the actual amount received,
     *      which may be less than `amount` if there is a fee attached to the transfer.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {
        if (isWethPool && convertWeth) {
            actualAmount = msg.value;
            IWETH(underlying).deposit{value : actualAmount}();
        } else {
            actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);
        }
    }

    /**
     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory
     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to
     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified
     *      it is >= amount, this should not revert in normal conditions.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {
        if (isWethPool && convertWeth) {
            IWETH(underlying).withdraw(amount);
            to.transfer(amount);
        } else {
            IERC20(underlying).safeTransfer(to, amount);
        }
    }

    function availableForBorrow() external view override returns (uint){
        uint cash = getCashPrior();
        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);
        if (err0 != MathError.NO_ERROR) {
            return 0;
        }
        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);
        if (err1 != MathError.NO_ERROR) {
            return 0;
        }
        if (totalBorrows > maxAvailable) {
            return 0;
        }
        return maxAvailable - totalBorrows;
    }


    /// @notice Get a snapshot of the account's balances, and the cached exchange rate
    /// @dev This is used by controller to more efficiently perform liquidity checks.
    /// @param account Address of the account to snapshot
    /// @return ( token balance, borrow balance, exchange rate mantissa)
    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        return (cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /// @dev Function to simply retrieve block number
    ///  This exists mainly for inheriting test contracts to stub this result.
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /// @notice Returns the current per-block borrow interest rate for this cToken
    /// @return The borrow interest rate per block, scaled by 1e18
    function borrowRatePerBlock() external override view returns (uint) {
        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
    }

    
    /// @notice Returns the current per-block supply interest rate for this cToken
    /// @return The supply interest rate per block, scaled by 1e18
    function supplyRatePerBlock() external override view returns (uint) {
        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);
    }

    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {
        // Utilization rate is 0 when there are no borrows
        if (borrows == 0) {
            return 0;
        }
        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));
    }

    /// @notice Calculates the current borrow rate per block, with the error code expected by the market
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18)
    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {
        uint util = utilizationRate(cash, borrows, reserves);
        if (util <= kink) {
            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
        } else {
            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
            uint excessUtil = util.sub(kink);
            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);
        }
    }

    /// @notice Calculates the current supply rate per block
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The supply rate percentage per block as a mantissa (scaled by 1e18)
    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {
        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);
        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);
        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);
        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);
    }

    /// @notice Returns the current total borrows plus accrued interest
    /// @return The total borrows with interest
    function totalBorrowsCurrent() external override view returns (uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return totalBorrows;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        return totalBorrowsNew;
    }

    /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
    /// @param account The address whose balance should be calculated after updating borrowIndex
    /// @return The calculated balance
    function borrowBalanceCurrent(address account) external view override returns (uint) {
        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();
        require(err0 == MathError.NO_ERROR, "calc borrow index fail");
        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
        require(err1 == MathError.NO_ERROR, "calc fail");
        return result;
    }

    function borrowBalanceStored(address account) external override view returns (uint){
        return accountBorrows[account].principal;
    }


    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
    }

    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /// @notice Accrue interest then return the up-to-date exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateCurrent() public override nonReentrant returns (uint) {
        accrueInterest();
        return exchangeRateStored();
    }

    /// Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateStored() public override view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "calc fail");
        return result;
    }

    /// @notice Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return (error code, calculated exchange rate scaled by 1e18)
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        uint _totalSupply = totalSupply;
        if (_totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint _totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /// @notice Get cash balance of this cToken in the underlying asset
    /// @return The quantity of underlying asset owned by this contract
    function getCash() external override view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }

    function calCurrentBorrowIndex() internal view returns (MathError, uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;
        uint borrowIndexNew;
        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return (MathError.NO_ERROR, borrowIndex);
        }
        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);

        Exp memory simpleInterestFactor;
        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }
        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);
        return (mathErr, borrowIndexNew);
    }

    /// @notice Applies accrued interest to total borrows and reserves
    /// @dev This calculates interest accrued from the last checkpointed block
    ///   up to the current block and writes new checkpoint to storage.
    function accrueInterest() public override {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint borrowIndexPrior = borrowIndex;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");


        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;
        uint borrowIndexNew;
        uint totalReservesNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total reserves error');

        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);
        require(mathErr == MathError.NO_ERROR, 'calc borrows index error');


        /* We write the previously calculated values into storage */
        accrualBlockNumber = currentBlockNumber;
        borrowIndex = borrowIndexNew;
        totalBorrows = totalBorrowsNew;
        totalReserves = totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);

    }

    struct MintLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
        uint actualMintAmount;
    }

    /// @notice User supplies assets into the market and receives lTokens in exchange
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param minter The address of the account which is supplying the assets
    /// @param mintAmount The amount of the underlying asset to supply
    /// @return uint the actual mint amount.
    function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {
        MintLocalVars memory vars;
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /*
         *  We call `doTransferIn` for the minter and the mintAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if
         *  side-effects occurred. The function returns the amount actually transferred,
         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`
         *  of cash.
         */
        if (isDelegete) {
            uint balanceBefore = getCashPrior();
            LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);
            uint balanceAfter = getCashPrior();
            require(balanceAfter > balanceBefore, 'mint 0');
            vars.actualMintAmount = balanceAfter - balanceBefore;
        } else {
            vars.actualMintAmount = doTransferIn(minter, mintAmount, true);
        }
        /*
         * We get the current exchange rate and calculate the number of lTokens to be minted:
         *  mintTokens = actualMintAmount / exchangeRate
         */

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));
        require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");

        /* Fail if mint not allowed */
        (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);
        /*
         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */

        return vars.actualMintAmount;
    }


    struct RedeemLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /// @notice User redeems lTokens in exchange for the underlying asset
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param redeemer The address of the account which is redeeming the tokens
    /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');
            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');
        require(getCashPrior() >= vars.redeemAmount, 'cash < redeem');

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;
        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(redeemer, vars.redeemAmount, true);


        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
    }

    struct BorrowLocalVars {
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /// @notice Users borrow assets from the protocol to their own address
    /// @param borrowAmount The amount of the underlying asset to borrow
    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {
        /* Fail if borrow not allowed */
        (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);

        /* Fail gracefully if protocol has insufficient underlying cash */
        require(getCashPrior() >= borrowAmount, 'cash<borrow');

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(payee, borrowAmount, false);

        /* We emit a Borrow event */
        emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
    }

    struct RepayBorrowLocalVars {
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
        uint actualRepayAmount;
        uint badDebtsAmount;
    }

    /// @notice Borrows are repaid by another user (possibly the borrower).
    /// @param payer the account paying off the borrow
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount the amount of undelrying tokens being returned
    function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {
        /* Fail if repayBorrow not allowed */
        (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(- 1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }
        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);


        if (isEnd && vars.accountBorrows > vars.actualRepayAmount) {
            vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;
        }

        /*
        *  We calculate the new borrower and total borrow balances, failing on underflow:
        *  accountBorrowsNew = accountBorrows - repayAmount
        *  totalBorrowsNew = totalBorrows - repayAmount
        */
        if (vars.accountBorrows < vars.actualRepayAmount) {
            require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) <= 105e16, 'repay more than 5%');
            vars.accountBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.accountBorrowsNew = 0;
            } else {
                vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;
            }
        }
        //Avoid mantissa errors
        if (vars.actualRepayAmount > totalBorrows) {
            vars.totalBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);
            } else {
                vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;
            }
        }

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */

        return vars.actualRepayAmount;
    }

    /*** Admin Functions ***/

    /// @notice Sets a new CONTROLLER for the market
    /// @dev Admin function to set a new controller
    function setController(address newController) external override onlyAdmin {
        require(address(0) != newController, "0x");
        address oldController = controller;
        controller = newController;
        // Emit NewController(oldController, newController)
        emit NewController(oldController, newController);
    }

    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {
        require(newBorrowCapFactorMantissa <= 1e18, 'Factor too large');
        uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;
        borrowCapFactorMantissa = newBorrowCapFactorMantissa;
        emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa);
    }

    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {
        //accrueInterest except first
        if (baseRatePerBlock != 0) {
            accrueInterest();
        }
        // total rate perYear < 2000%
        require(baseRatePerBlock_ < 1e13, 'Base rate too large');
        baseRatePerBlock = baseRatePerBlock_;
        require(multiplierPerBlock_ < 1e13, 'Mul rate too large');
        multiplierPerBlock = multiplierPerBlock_;
        require(jumpMultiplierPerBlock_ < 1e13, 'Jump rate too large');
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        require(kink_ <= 1e18, 'Kline too large');
        kink = kink_;
        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);
    }

    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {
        require(newReserveFactorMantissa <= 1e18, 'Factor too large');
        accrueInterest();
        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;
        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);
    }

    function addReserves(uint addAmount) external override nonReentrant {
        accrueInterest();
        uint totalReservesNew;
        uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);
        totalReservesNew = totalReserves.add(actualAddAmount);
        totalReserves = totalReservesNew;
        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);
    }

    function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {
        accrueInterest();
        uint totalReservesNew;
        totalReservesNew = totalReserves.sub(reduceAmount);
        totalReserves = totalReservesNew;
        doTransferOut(to, reduceAmount, true);
        emit ReservesReduced(to, reduceAmount, totalReservesNew);
    }

    modifier sameBlock() {
        require(accrualBlockNumber == getBlockNumber(), 'not same block');
        _;
    }
}



**project_name**: RealWorld_BA_72_LPool

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_72_LPool_RealWord_20240824192754.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-24-08 19:27:54 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.7.6; import "./LPoolInterface.sol"; import "./LPoolDepositor.sol"; import "../lib/Exponential.sol"; import "../Adminable.sol"; import "../lib/CarefulMath.sol"; import "../lib/TransferHelper.sol"; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import "../DelegateInterface.sol"; import "../ControllerInterface.sol"; import "../IWETH.sol"; /// @title OpenLeverage's LToken Contract /// @dev Abstract base for LTokens /// @author OpenLeverage contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {     using TransferHelper for IERC20;     using SafeMath for uint; constructor() {  }  /// @notice Initialize the money market /// @param controller_ The address of the Controller /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0 /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point /// @param kink_ The utilization point at which the jump multiplier is applied /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18 /// @param name_ EIP-20 name of this token /// @param symbol_ EIP-20 symbol of this token /// @param decimals_ EIP-20 decimal precision of this token function initialize(     address underlying_,     bool isWethPool_,     address controller_,     uint256 baseRatePerBlock_,     uint256 multiplierPerBlock_,     uint256 jumpMultiplierPerBlock_,     uint256 kink_,     uint initialExchangeRateMantissa_,     string memory name_,     string memory symbol_,     uint8 decimals_) public {     require(underlying_ != address(0), "underlying_ address cannot be 0");     require(controller_ != address(0), "controller_ address cannot be 0");     require(msg.sender == admin, "Only allow to be called by admin");     require(accrualBlockNumber == 0 &amp;&amp; borrowIndex == 0, "inited once");      // Set initial exchange rate     initialExchangeRateMantissa = initialExchangeRateMantissa_;     require(initialExchangeRateMantissa &gt; 0, "Initial Exchange Rate Mantissa should be greater zero");     //set controller     controller = controller_;     isWethPool = isWethPool_;     //set interestRateModel     baseRatePerBlock = baseRatePerBlock_;     multiplierPerBlock = multiplierPerBlock_;     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     kink = kink_;      // Initialize block number and borrow index (block number mocks depend on controller being set)     accrualBlockNumber = getBlockNumber();     borrowIndex = 1e25;     //80%     borrowCapFactorMantissa = 0.8e18;     //10%     reserveFactorMantissa = 0.1e18;       name = name_;     symbol = symbol_;     decimals = decimals_;      _notEntered = true;      // Set underlying and sanity check it     underlying = underlying_;     IERC20(underlying).totalSupply();     emit Transfer(address(0), msg.sender, 0); }  /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender` /// @dev Called by both `transfer` and `transferFrom` internally /// @param spender The address of the account performing the transfer /// @param src The address of the source account /// @param dst The address of the destination account /// @param tokens The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {     require(dst != address(0), "dst address cannot be 0");     /* Do not allow self-transfers */     require(src != dst, "src = dst");     /* Fail if transfer not allowed */     (ControllerInterface(controller)).transferAllowed(src, dst, tokens);      /* Get the allowance, infinite for the account owner */     uint startingAllowance = 0;     if (spender == src) {         startingAllowance = uint(- 1);     } else {         startingAllowance = transferAllowances[src][spender];     }      /* Do the calculations, checking for {under,over}flow */     MathError mathErr;     uint allowanceNew;     uint srcTokensNew;     uint dstTokensNew;      (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);     require(mathErr == MathError.NO_ERROR, 'not allowed');      (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);     require(mathErr == MathError.NO_ERROR, 'not enough');      (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);     require(mathErr == MathError.NO_ERROR, 'too much');      accountTokens[src] = srcTokensNew;     accountTokens[dst] = dstTokensNew;      /* Eat some of the allowance (if necessary) */     if (startingAllowance != uint(- 1)) {         transferAllowances[src][spender] = allowanceNew;     }     /* We emit a Transfer event */     emit Transfer(src, dst, tokens);     return true; }  /// @notice Transfer `amount` tokens from `msg.sender` to `dst` /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, msg.sender, dst, amount); }  /// @notice Transfer `amount` tokens from `src` to `dst` /// @param src The address of the source account /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, src, dst, amount); }  /// @notice Approve `spender` to transfer up to `amount` from `src` /// @dev This will overwrite the approval amount for `spender` ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve) /// @param spender The address of the account which may transfer tokens /// @param amount The number of tokens that are approved (-1 means infinite) /// @return Whether or not the approval succeeded function approve(address spender, uint256 amount) external override returns (bool) {     address src = msg.sender;     transferAllowances[src][spender] = amount;     emit Approval(src, spender, amount);     return true; }  /// @notice Get the current allowance from `owner` for `spender` /// @param owner The address of the account which owns the tokens to be spent /// @param spender The address of the account which may transfer tokens /// @return The number of tokens allowed to be spent (-1 means infinite) function allowance(address owner, address spender) external override view returns (uint256) {     return transferAllowances[owner][spender]; }  /// @notice Get the token balance of the `owner` /// @param owner The address of the account to query /// @return The number of tokens owned by `owner` function balanceOf(address owner) external override view returns (uint256) {     return accountTokens[owner]; }  /// @notice Get the underlying balance of the `owner` /// @dev This also accrues interest in a transaction /// @param owner The address of the account to query /// @return The amount of underlying owned by `owner` function balanceOfUnderlying(address owner) external override returns (uint) {     Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});     (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);     require(mErr == MathError.NO_ERROR, "calc failed");     return balance; }  /*** User Interface ***/  /// @notice Sender supplies assets into the market and receives lTokens in exchange /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param mintAmount The amount of the underlying asset to supply function mint(uint mintAmount) external override nonReentrant {     accrueInterest();     mintFresh(msg.sender, mintAmount, false); }  function mintTo(address to, uint amount) external payable override nonReentrant {     accrueInterest();     if (isWethPool) {         mintFresh(to, msg.value, false);     } else {         mintFresh(to, amount, true);     } }  function mintEth() external payable override nonReentrant {     require(isWethPool, "not eth pool");     accrueInterest();     mintFresh(msg.sender, msg.value, false); }  /// @notice Sender redeems lTokens in exchange for the underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemTokens The number of lTokens to redeem into underlying function redeem(uint redeemTokens) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, redeemTokens, 0); }  /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemAmount The amount of underlying to redeem function redeemUnderlying(uint redeemAmount) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, 0, redeemAmount); }  function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {     accrueInterest();     // borrowFresh emits borrow-specific logs on errors, so we don't need to     borrowFresh(payable(borrower), msg.sender, borrowAmount); }  /// @notice Sender repays a borrow belonging to borrower /// @param borrower the account with the debt being payed off /// @param repayAmount The amount to repay function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     repayBorrowFresh(msg.sender, borrower, repayAmount, false); }  function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     repayBorrowFresh(msg.sender, borrower, repayAmount, true); }   /*** Safe Token ***/  /// Gets balance of this contract in terms of the underlying /// @dev This excludes the value of the current message, if any /// @return The quantity of underlying tokens owned by this contract function getCashPrior() internal view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }   /**  * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.  *      This will revert due to insufficient balance or insufficient allowance.  *      This function returns the actual amount received,  *      which may be less than `amount` if there is a fee attached to the transfer.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {     if (isWethPool &amp;&amp; convertWeth) {         actualAmount = msg.value;         IWETH(underlying).deposit{value : actualAmount}();     } else {         actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);     } }  /**  * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory  *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to  *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified  *      it is &gt;= amount, this should not revert in normal conditions.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferOut(address payable to, uint amount, bool convertWeth) internal {     if (isWethPool &amp;&amp; convertWeth) {         IWETH(underlying).withdraw(amount);         to.transfer(amount);     } else {         IERC20(underlying).safeTransfer(to, amount);     } }  function availableForBorrow() external view override returns (uint){     uint cash = getCashPrior();     (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);     if (err0 != MathError.NO_ERROR) {         return 0;     }     (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);     if (err1 != MathError.NO_ERROR) {         return 0;     }     if (totalBorrows &gt; maxAvailable) {         return 0;     }     return maxAvailable - totalBorrows; }   /// @notice Get a snapshot of the account's balances, and the cached exchange rate /// @dev This is used by controller to more efficiently perform liquidity checks. /// @param account Address of the account to snapshot /// @return ( token balance, borrow balance, exchange rate mantissa) function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {     uint cTokenBalance = accountTokens[account];     uint borrowBalance;     uint exchangeRateMantissa;      MathError mErr;      (mErr, borrowBalance) = borrowBalanceStoredInternal(account);     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      return (cTokenBalance, borrowBalance, exchangeRateMantissa); }  /// @dev Function to simply retrieve block number ///  This exists mainly for inheriting test contracts to stub this result. function getBlockNumber() internal view returns (uint) {     return block.number; }  /// @notice Returns the current per-block borrow interest rate for this cToken /// @return The borrow interest rate per block, scaled by 1e18 function borrowRatePerBlock() external override view returns (uint) {     return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves); }   /// @notice Returns the current per-block supply interest rate for this cToken /// @return The supply interest rate per block, scaled by 1e18 function supplyRatePerBlock() external override view returns (uint) {     return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa); }  function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {     // Utilization rate is 0 when there are no borrows     if (borrows == 0) {         return 0;     }     return borrows.mul(1e18).div(cash.add(borrows).sub(reserves)); }  /// @notice Calculates the current borrow rate per block, with the error code expected by the market /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18) function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {     uint util = utilizationRate(cash, borrows, reserves);     if (util &lt;= kink) {         return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);     } else {         uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);         uint excessUtil = util.sub(kink);         return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);     } }  /// @notice Calculates the current supply rate per block /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The supply rate percentage per block as a mantissa (scaled by 1e18) function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {     uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);     uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);     uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);     return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18); }  /// @notice Returns the current total borrows plus accrued interest /// @return The total borrows with interest function totalBorrowsCurrent() external override view returns (uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return totalBorrows;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, "calc block delta erro");      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      return totalBorrowsNew; }  /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex /// @param account The address whose balance should be calculated after updating borrowIndex /// @return The calculated balance function borrowBalanceCurrent(address account) external view override returns (uint) {     (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();     require(err0 == MathError.NO_ERROR, "calc borrow index fail");     (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);     require(err1 == MathError.NO_ERROR, "calc fail");     return result; }  function borrowBalanceStored(address account) external override view returns (uint){     return accountBorrows[account].principal; }   /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {     return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex); }  /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {     /* Note: we do not assert that the market is up to date */     MathError mathErr;     uint principalTimesIndex;     uint result;      /* Get borrowBalance and borrowIndex */     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];      /* If borrowBalance = 0 then borrowIndex is likely also 0.      * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.      */     if (borrowSnapshot.principal == 0) {         return (MathError.NO_ERROR, 0);     }      /* Calculate new borrow balance using the interest index:      *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex      */     (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      return (MathError.NO_ERROR, result); }  /// @notice Accrue interest then return the up-to-date exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateCurrent() public override nonReentrant returns (uint) {     accrueInterest();     return exchangeRateStored(); }  /// Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateStored() public override view returns (uint) {     (MathError err, uint result) = exchangeRateStoredInternal();     require(err == MathError.NO_ERROR, "calc fail");     return result; }  /// @notice Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return (error code, calculated exchange rate scaled by 1e18) function exchangeRateStoredInternal() internal view returns (MathError, uint) {     uint _totalSupply = totalSupply;     if (_totalSupply == 0) {         /*          * If there are no tokens minted:          *  exchangeRate = initialExchangeRate          */         return (MathError.NO_ERROR, initialExchangeRateMantissa);     } else {         /*          * Otherwise:          *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply          */         uint _totalCash = getCashPrior();         uint cashPlusBorrowsMinusReserves;         Exp memory exchangeRate;         MathError mathErr;          (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          return (MathError.NO_ERROR, exchangeRate.mantissa);     } }  /// @notice Get cash balance of this cToken in the underlying asset /// @return The quantity of underlying asset owned by this contract function getCash() external override view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }  function calCurrentBorrowIndex() internal view returns (MathError, uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;     uint borrowIndexNew;     /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return (MathError.NO_ERROR, borrowIndex);     }     uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);      Exp memory simpleInterestFactor;     (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }     (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);     return (mathErr, borrowIndexNew); }  /// @notice Applies accrued interest to total borrows and reserves /// @dev This calculates interest accrued from the last checkpointed block ///   up to the current block and writes new checkpoint to storage. function accrueInterest() public override {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint borrowIndexPrior = borrowIndex;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, "calc block delta erro");       /*      * Calculate the interest accumulated into borrows and reserves and the new index:      *  simpleInterestFactor = borrowRate * blockDelta      *  interestAccumulated = simpleInterestFactor * totalBorrows      *  totalBorrowsNew = interestAccumulated + totalBorrows      *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex      */      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;     uint borrowIndexNew;     uint totalReservesNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);     require(mathErr == MathError.NO_ERROR, 'calc total reserves error');      (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);     require(mathErr == MathError.NO_ERROR, 'calc borrows index error');       /* We write the previously calculated values into storage */     accrualBlockNumber = currentBlockNumber;     borrowIndex = borrowIndexNew;     totalBorrows = totalBorrowsNew;     totalReserves = totalReservesNew;      /* We emit an AccrueInterest event */     emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);  }  struct MintLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint mintTokens;     uint totalSupplyNew;     uint accountTokensNew;     uint actualMintAmount; }  /// @notice User supplies assets into the market and receives lTokens in exchange /// @dev Assumes interest has already been accrued up to the current block /// @param minter The address of the account which is supplying the assets /// @param mintAmount The amount of the underlying asset to supply /// @return uint the actual mint amount. function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {     MintLocalVars memory vars;     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /*      *  We call `doTransferIn` for the minter and the mintAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if      *  side-effects occurred. The function returns the amount actually transferred,      *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`      *  of cash.      */     if (isDelegete) {         uint balanceBefore = getCashPrior();         LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);         uint balanceAfter = getCashPrior();         require(balanceAfter &gt; balanceBefore, 'mint 0');         vars.actualMintAmount = balanceAfter - balanceBefore;     } else {         vars.actualMintAmount = doTransferIn(minter, mintAmount, true);     }     /*      * We get the current exchange rate and calculate the number of lTokens to be minted:      *  mintTokens = actualMintAmount / exchangeRate      */      (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));     require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");      /* Fail if mint not allowed */     (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);     /*      * We calculate the new total supply of lTokens and minter token balance, checking for overflow:      *  totalSupplyNew = totalSupply + mintTokens      *  accountTokensNew = accountTokens[minter] + mintTokens      */     (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");      (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[minter] = vars.accountTokensNew;      /* We emit a Mint event, and a Transfer event */     emit Mint(minter, vars.actualMintAmount, vars.mintTokens);     emit Transfer(address(this), minter, vars.mintTokens);      /* We call the defense hook */      return vars.actualMintAmount; }   struct RedeemLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint redeemTokens;     uint redeemAmount;     uint totalSupplyNew;     uint accountTokensNew; }  /// @notice User redeems lTokens in exchange for the underlying asset /// @dev Assumes interest has already been accrued up to the current block /// @param redeemer The address of the account which is redeeming the tokens /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero) /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero) function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {     require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");      RedeemLocalVars memory vars;      /* exchangeRate = invoke Exchange Rate Stored() */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /* If redeemTokensIn &gt; 0: */     if (redeemTokensIn &gt; 0) {         /*          * We calculate the exchange rate and the amount of underlying to be redeemed:          *  redeemTokens = redeemTokensIn          *  redeemAmount = redeemTokensIn x exchangeRateCurrent          */         vars.redeemTokens = redeemTokensIn;          (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');     } else {         /*          * We get the current exchange rate and calculate the amount to be redeemed:          *  redeemTokens = redeemAmountIn / exchangeRate          *  redeemAmount = redeemAmountIn          */          (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');         vars.redeemAmount = redeemAmountIn;     }      /* Fail if redeem not allowed */     (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);      /*      * We calculate the new total supply and redeemer balance, checking for underflow:      *  totalSupplyNew = totalSupply - redeemTokens      *  accountTokensNew = accountTokens[redeemer] - redeemTokens      */     (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');      (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');     require(getCashPrior() &gt;= vars.redeemAmount, 'cash &lt; redeem');      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[redeemer] = vars.accountTokensNew;     /*      * We invoke doTransferOut for the redeemer and the redeemAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken has redeemAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(redeemer, vars.redeemAmount, true);       /* We emit a Transfer event, and a Redeem event */     emit Transfer(redeemer, address(this), vars.redeemTokens);     emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);      /* We call the defense hook */ }  struct BorrowLocalVars {     MathError mathErr;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /// @notice Users borrow assets from the protocol to their own address /// @param borrowAmount The amount of the underlying asset to borrow function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {     /* Fail if borrow not allowed */     (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);      /* Fail gracefully if protocol has insufficient underlying cash */     require(getCashPrior() &gt;= borrowAmount, 'cash&lt;borrow');      BorrowLocalVars memory vars;      /*      * We calculate the new borrower and total borrow balances, failing on overflow:      *  accountBorrowsNew = accountBorrows + borrowAmount      *  totalBorrowsNew = totalBorrows + borrowAmount      */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /*      * We invoke doTransferOut for the borrower and the borrowAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken borrowAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(payee, borrowAmount, false);      /* We emit a Borrow event */     emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */ }  struct RepayBorrowLocalVars {     MathError mathErr;     uint repayAmount;     uint borrowerIndex;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew;     uint actualRepayAmount;     uint badDebtsAmount; }  /// @notice Borrows are repaid by another user (possibly the borrower). /// @param payer the account paying off the borrow /// @param borrower the account with the debt being payed off /// @param repayAmount the amount of undelrying tokens being returned function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {     /* Fail if repayBorrow not allowed */     (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);      RepayBorrowLocalVars memory vars;      /* We remember the original borrowerIndex for verification purposes */     vars.borrowerIndex = accountBorrows[borrower].interestIndex;      /* We fetch the amount the borrower owes, with accumulated interest */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');      /* If repayAmount == -1, repayAmount = accountBorrows */     if (repayAmount == uint(- 1)) {         vars.repayAmount = vars.accountBorrows;     } else {         vars.repayAmount = repayAmount;     }     vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);       if (isEnd &amp;&amp; vars.accountBorrows &gt; vars.actualRepayAmount) {         vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;     }      /*     *  We calculate the new borrower and total borrow balances, failing on underflow:     *  accountBorrowsNew = accountBorrows - repayAmount     *  totalBorrowsNew = totalBorrows - repayAmount     */     if (vars.accountBorrows &lt; vars.actualRepayAmount) {         require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) &lt;= 105e16, 'repay more than 5%');         vars.accountBorrowsNew = 0;     } else {         if (isEnd) {             vars.accountBorrowsNew = 0;         } else {             vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;         }     }     //Avoid mantissa errors     if (vars.actualRepayAmount &gt; totalBorrows) {         vars.totalBorrowsNew = 0;     } else {         if (isEnd) {             vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);         } else {             vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;         }     }      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a RepayBorrow event */     emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */      return vars.actualRepayAmount; }  /*** Admin Functions ***/  /// @notice Sets a new CONTROLLER for the market /// @dev Admin function to set a new controller function setController(address newController) external override onlyAdmin {     require(address(0) != newController, "0x");     address oldController = controller;     controller = newController;     // Emit NewController(oldController, newController)     emit NewController(oldController, newController); }  function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {     require(newBorrowCapFactorMantissa &lt;= 1e18, 'Factor too large');     uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;     borrowCapFactorMantissa = newBorrowCapFactorMantissa;     emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa); }  function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {     //accrueInterest except first     if (baseRatePerBlock != 0) {         accrueInterest();     }     // total rate perYear &lt; 2000%     require(baseRatePerBlock_ &lt; 1e13, 'Base rate too large');     baseRatePerBlock = baseRatePerBlock_;     require(multiplierPerBlock_ &lt; 1e13, 'Mul rate too large');     multiplierPerBlock = multiplierPerBlock_;     require(jumpMultiplierPerBlock_ &lt; 1e13, 'Jump rate too large');     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     require(kink_ &lt;= 1e18, 'Kline too large');     kink = kink_;     emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_); }  function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {     require(newReserveFactorMantissa &lt;= 1e18, 'Factor too large');     accrueInterest();     uint oldReserveFactorMantissa = reserveFactorMantissa;     reserveFactorMantissa = newReserveFactorMantissa;     emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa); }  function addReserves(uint addAmount) external override nonReentrant {     accrueInterest();     uint totalReservesNew;     uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);     totalReservesNew = totalReserves.add(actualAddAmount);     totalReserves = totalReservesNew;     emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew); }  function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {     accrueInterest();     uint totalReservesNew;     totalReservesNew = totalReserves.sub(reduceAmount);     totalReserves = totalReservesNew;     doTransferOut(to, reduceAmount, true);     emit ReservesReduced(to, reduceAmount, totalReservesNew); }  modifier sameBlock() {     require(accrualBlockNumber == getBlockNumber(), 'not same block');     _; }  } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.7.6;\n\n\nimport "./LPoolInterface.sol";\nimport "./LPoolDepositor.sol";\nimport "../lib/Exponential.sol";\nimport "../Adminable.sol";\nimport "../lib/CarefulMath.sol";\nimport "../lib/TransferHelper.sol";\nimport "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\n\nimport "../DelegateInterface.sol";\nimport "../ControllerInterface.sol";\nimport "../IWETH.sol";\n\n/// @title OpenLeverage\'s LToken Contract\n/// @dev Abstract base for LTokens\n/// @author OpenLeverage\ncontract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {\n    using TransferHelper for IERC20;\n    using SafeMath for uint;\n\n    constructor() {\n\n    }\n    \n    /// @notice Initialize the money market\n    /// @param controller_ The address of the Controller\n    /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0\n    /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate\n    /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point\n    /// @param kink_ The utilization point at which the jump multiplier is applied\n    /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n    /// @param name_ EIP-20 name of this token\n    /// @param symbol_ EIP-20 symbol of this token\n    /// @param decimals_ EIP-20 decimal precision of this token\n    function initialize(\n        address underlying_,\n        bool isWethPool_,\n        address controller_,\n        uint256 baseRatePerBlock_,\n        uint256 multiplierPerBlock_,\n        uint256 jumpMultiplierPerBlock_,\n        uint256 kink_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_) public {\n        require(underlying_ != address(0), "underlying_ address cannot be 0");\n        require(controller_ != address(0), "controller_ address cannot be 0");\n        require(msg.sender == admin, "Only allow to be called by admin");\n        require(accrualBlockNumber == 0 &amp;&amp; borrowIndex == 0, "inited once");\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa &gt; 0, "Initial Exchange Rate Mantissa should be greater zero");\n        //set controller\n        controller = controller_;\n        isWethPool = isWethPool_;\n        //set interestRateModel\n        baseRatePerBlock = baseRatePerBlock_;\n        multiplierPerBlock = multiplierPerBlock_;\n        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;\n        kink = kink_;\n\n        // Initialize block number and borrow index (block number mocks depend on controller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = 1e25;\n        //80%\n        borrowCapFactorMantissa = 0.8e18;\n        //10%\n        reserveFactorMantissa = 0.1e18;\n\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n\n        notEntered = true;\n\n        // Set underlying and sanity check it\n        underlying = underlying;\n        IERC20(underlying).totalSupply();\n        emit Transfer(address(0), msg.sender, 0);\n    }\n\n    /// @notice Transfer tokens tokens from src to dst by spender\n    /// @dev Called by both transfer and transferFrom internally\n    /// @param spender The address of the account performing the transfer\n    /// @param src The address of the source account\n    /// @param dst The address of the destination account\n    /// @param tokens The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {\n        require(dst != address(0), "dst address cannot be 0");\n        / Do not allow self-transfers /\n        require(src != dst, "src = dst");\n        / Fail if transfer not allowed /\n        (ControllerInterface(controller)).transferAllowed(src, dst, tokens);\n\n        / Get the allowance, infinite for the account owner /\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = uint(- 1);\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        / Do the calculations, checking for {under,over}flow /\n        MathError mathErr;\n        uint allowanceNew;\n        uint srcTokensNew;\n        uint dstTokensNew;\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n        require(mathErr == MathError.NO_ERROR, \'not allowed\');\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n        require(mathErr == MathError.NO_ERROR, \'not enough\');\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n        require(mathErr == MathError.NO_ERROR, \'too much\');\n\n        accountTokens[src] = srcTokensNew;\n        accountTokens[dst] = dstTokensNew;\n\n        / Eat some of the allowance (if necessary) /\n        if (startingAllowance != uint(- 1)) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n        / We emit a Transfer event /\n        emit Transfer(src, dst, tokens);\n        return true;\n    }\n\n    /// @notice Transfer amount tokens from msg.sender to dst\n    /// @param dst The address of the destination account\n    /// @param amount The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, msg.sender, dst, amount);\n    }\n\n    /// @notice Transfer amount tokens from src to dst\n    /// @param src The address of the source account\n    /// @param dst The address of the destination account\n    /// @param amount The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, src, dst, amount);\n    }\n\n    /// @notice Approve spender to transfer up to amount from src\n    /// @dev This will overwrite the approval amount for spender\n    ///  and is subject to issues noted here\n    /// @param spender The address of the account which may transfer tokens\n    /// @param amount The number of tokens that are approved (-1 means infinite)\n    /// @return Whether or not the approval succeeded\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /// @notice Get the current allowance from owner for spender\n    /// @param owner The address of the account which owns the tokens to be spent\n    /// @param spender The address of the account which may transfer tokens\n    /// @return The number of tokens allowed to be spent (-1 means infinite)\n    function allowance(address owner, address spender) external override view returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n\n    /// @notice Get the token balance of the owner\n    /// @param owner The address of the account to query\n    /// @return The number of tokens owned by owner\n    function balanceOf(address owner) external override view returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /// @notice Get the underlying balance of the owner\n    /// @dev This also accrues interest in a transaction\n    /// @param owner The address of the account to query\n    /// @return The amount of underlying owned by owner\n    function balanceOfUnderlying(address owner) external override returns (uint) {\n        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n        require(mErr == MathError.NO_ERROR, "calc failed");\n        return balance;\n    }\n\n    / User Interface /\n\n    /// @notice Sender supplies assets into the market and receives lTokens in exchange\n    /// @dev Accrues interest whether or not the operation succeeds, unless reverted\n    /// @param mintAmount The amount of the underlying asset to supply\n    function mint(uint mintAmount) external override nonReentrant {\n        accrueInterest();\n        mintFresh(msg.sender, mintAmount, false);\n    }\n\n    function mintTo(address to, uint amount) external payable override nonReentrant {\n        accrueInterest();\n        if (isWethPool) {\n            mintFresh(to, msg.value, false);\n        } else {\n            mintFresh(to, amount, true);\n        }\n    }\n\n    function mintEth() external payable override nonReentrant {\n        require(isWethPool, "not eth pool");\n        accrueInterest();\n        mintFresh(msg.sender, msg.value, false);\n    }\n\n    /// @notice Sender redeems lTokens in exchange for the underlying asset\n    /// @dev Accrues interest whether or not the operation succeeds, unless reverted\n    /// @param redeemTokens The number of lTokens to redeem into underlying\n    function redeem(uint redeemTokens) external override nonReentrant {\n        accrueInterest();\n        // redeemFresh emits redeem-specific logs on errors, so we don\'t need to\n        redeemFresh(msg.sender, redeemTokens, 0);\n    }\n\n    /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset\n    /// @dev Accrues interest whether or not the operation succeeds, unless reverted\n    /// @param redeemAmount The amount of underlying to redeem\n    function redeemUnderlying(uint redeemAmount) external override nonReentrant {\n        accrueInterest();\n        // redeemFresh emits redeem-specific logs on errors, so we don\'t need to\n        redeemFresh(msg.sender, 0, redeemAmount);\n    }\n\n    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {\n        accrueInterest();\n        // borrowFresh emits borrow-specific logs on errors, so we don\'t need to\n        borrowFresh(payable(borrower), msg.sender, borrowAmount);\n    }\n\n    /// @notice Sender repays a borrow belonging to borrower\n    /// @param borrower the account with the debt being payed off\n    /// @param repayAmount The amount to repay\n    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {\n        accrueInterest();\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don\'t need to\n        repayBorrowFresh(msg.sender, borrower, repayAmount, false);\n    }\n\n    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {\n        accrueInterest();\n        repayBorrowFresh(msg.sender, borrower, repayAmount, true);\n    }\n\n\n    / Safe Token /\n\n    /// Gets balance of this contract in terms of the underlying\n    /// @dev This excludes the value of the current message, if any\n    /// @return The quantity of underlying tokens owned by this contract\n    function getCashPrior() internal view returns (uint) {\n        return IERC20(underlying).balanceOf(address(this));\n    }\n\n\n    /\n     * @dev Similar to EIP20 transfer, except it handles a False result from transferFrom and reverts in that case.\n     *      This will revert due to insufficient balance or insufficient allowance.\n     *      This function returns the actual amount received,\n     *      which may be less than amount if there is a fee attached to the transfer.\n     \n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     /\n    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {\n        if (isWethPool &amp;&amp; convertWeth) {\n            actualAmount = msg.value;\n            IWETH(underlying).deposit{value : actualAmount}();\n        } else {\n            actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);\n        }\n    }\n\n    /\n     * @dev Similar to EIP20 transfer, except it handles a False success from transfer and returns an explanatory\n     *      error code rather than reverting. If caller has not called checked protocol\'s balance, this may revert due to\n     *      insufficient cash held in this contract. If caller has checked protocol\'s balance prior to this call, and verified\n     *      it is &gt;= amount, this should not revert in normal conditions.\n     \n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     /\n    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {\n        if (isWethPool &amp;&amp; convertWeth) {\n            IWETH(underlying).withdraw(amount);\n            to.transfer(amount);\n        } else {\n            IERC20(underlying).safeTransfer(to, amount);\n        }\n    }\n\n    function availableForBorrow() external view override returns (uint){\n        uint cash = getCashPrior();\n        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);\n        if (err0 != MathError.NO_ERROR) {\n            return 0;\n        }\n        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);\n        if (err1 != MathError.NO_ERROR) {\n            return 0;\n        }\n        if (totalBorrows &gt; maxAvailable) {\n            return 0;\n        }\n        return maxAvailable - totalBorrows;\n    }\n\n\n    /// @notice Get a snapshot of the account\'s balances, and the cached exchange rate\n    /// @dev This is used by controller to more efficiently perform liquidity checks.\n    /// @param account Address of the account to snapshot\n    /// @return ( token balance, borrow balance, exchange rate mantissa)\n    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {\n        uint cTokenBalance = accountTokens[account];\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n\n        MathError mErr;\n\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n        if (mErr != MathError.NO_ERROR) {\n            return (0, 0, 0);\n        }\n\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (mErr != MathError.NO_ERROR) {\n            return (0, 0, 0);\n        }\n\n        return (cTokenBalance, borrowBalance, exchangeRateMantissa);\n    }\n\n    /// @dev Function to simply retrieve block number\n    ///  This exists mainly for inheriting test contracts to stub this result.\n    function getBlockNumber() internal view returns (uint) {\n        return block.number;\n    }\n\n    /// @notice Returns the current per-block borrow interest rate for this cToken\n    /// @return The borrow interest rate per block, scaled by 1e18\n    function borrowRatePerBlock() external override view returns (uint) {\n        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);\n    }\n\n    \n    /// @notice Returns the current per-block supply interest rate for this cToken\n    /// @return The supply interest rate per block, scaled by 1e18\n    function supplyRatePerBlock() external override view returns (uint) {\n        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\n    }\n\n    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {\n        // Utilization rate is 0 when there are no borrows\n        if (borrows == 0) {\n            return 0;\n        }\n        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));\n    }\n\n    /// @notice Calculates the current borrow rate per block, with the error code expected by the market\n    /// @param cash The amount of cash in the market\n    /// @param borrows The amount of borrows in the market\n    /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\n    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {\n        uint util = utilizationRate(cash, borrows, reserves);\n        if (util &lt;= kink) {\n            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n        } else {\n            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n            uint excessUtil = util.sub(kink);\n            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);\n        }\n    }\n\n    /// @notice Calculates the current supply rate per block\n    /// @param cash The amount of cash in the market\n    /// @param borrows The amount of borrows in the market\n    /// @return The supply rate percentage per block as a mantissa (scaled by 1e18)\n    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {\n        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);\n        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);\n        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\n        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\n    }\n\n    /// @notice Returns the current total borrows plus accrued interest\n    /// @return The total borrows with interest\n    function totalBorrowsCurrent() external override view returns (uint) {\n        / Remember the initial block number /\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        / Short-circuit accumulating 0 interest /\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return totalBorrows;\n        }\n\n        / Read the previous values out of storage /\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint reservesPrior = totalReserves;\n\n        / Calculate the current borrow interest rate /\n        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");\n\n        / Calculate the number of blocks elapsed since the last accrual /\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        require(mathErr == MathError.NO_ERROR, "calc block delta erro");\n\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        require(mathErr == MathError.NO_ERROR, \'calc interest factor error\');\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc interest acc error\');\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc total borrows error\');\n\n        return totalBorrowsNew;\n    }\n\n    /// @notice Accrue interest to updated borrowIndex and then calculate account\'s borrow balance using the updated borrowIndex\n    /// @param account The address whose balance should be calculated after updating borrowIndex\n    /// @return The calculated balance\n    function borrowBalanceCurrent(address account) external view override returns (uint) {\n        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();\n        require(err0 == MathError.NO_ERROR, "calc borrow index fail");\n        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);\n        require(err1 == MathError.NO_ERROR, "calc fail");\n        return result;\n    }\n\n    function borrowBalanceStored(address account) external override view returns (uint){\n        return accountBorrows[account].principal;\n    }\n\n\n    /// @notice Return the borrow balance of account based on stored data\n    /// @param account The address whose balance should be calculated\n    /// @return (error code, the calculated balance or 0 if error code is non-zero)\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);\n    }\n\n    /// @notice Return the borrow balance of account based on stored data\n    /// @param account The address whose balance should be calculated\n    /// @return (error code, the calculated balance or 0 if error code is non-zero)\n    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {\n        / Note: we do not assert that the market is up to date /\n        MathError mathErr;\n        uint principalTimesIndex;\n        uint result;\n\n        / Get borrowBalance and borrowIndex /\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        / If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         /\n        if (borrowSnapshot.principal == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        / Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         /\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        return (MathError.NO_ERROR, result);\n    }\n\n    /// @notice Accrue interest then return the up-to-date exchange rate\n    /// @return Calculated exchange rate scaled by 1e18\n    function exchangeRateCurrent() public override nonReentrant returns (uint) {\n        accrueInterest();\n        return exchangeRateStored();\n    }\n\n    /// Calculates the exchange rate from the underlying to the LToken\n    /// @dev This function does not accrue interest before calculating the exchange rate\n    /// @return Calculated exchange rate scaled by 1e18\n    function exchangeRateStored() public override view returns (uint) {\n        (MathError err, uint result) = exchangeRateStoredInternal();\n        require(err == MathError.NO_ERROR, "calc fail");\n        return result;\n    }\n\n    /// @notice Calculates the exchange rate from the underlying to the LToken\n    /// @dev This function does not accrue interest before calculating the exchange rate\n    /// @return (error code, calculated exchange rate scaled by 1e18)\n    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n        uint _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            /\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             /\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\n        } else {\n            /\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             /\n            uint _totalCash = getCashPrior();\n            uint cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n            MathError mathErr;\n\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\n        }\n    }\n\n    /// @notice Get cash balance of this cToken in the underlying asset\n    /// @return The quantity of underlying asset owned by this contract\n    function getCash() external override view returns (uint) {\n        return IERC20(underlying).balanceOf(address(this));\n    }\n\n    function calCurrentBorrowIndex() internal view returns (MathError, uint) {\n        / Remember the initial block number /\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n        uint borrowIndexNew;\n        / Short-circuit accumulating 0 interest /\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return (MathError.NO_ERROR, borrowIndex);\n        }\n        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n\n        Exp memory simpleInterestFactor;\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);\n        return (mathErr, borrowIndexNew);\n    }\n\n    /// @notice Applies accrued interest to total borrows and reserves\n    /// @dev This calculates interest accrued from the last checkpointed block\n    ///   up to the current block and writes new checkpoint to storage.\n    function accrueInterest() public override {\n        / Remember the initial block number /\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        / Short-circuit accumulating 0 interest /\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return;\n        }\n\n        / Read the previous values out of storage /\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint borrowIndexPrior = borrowIndex;\n        uint reservesPrior = totalReserves;\n\n        / Calculate the current borrow interest rate /\n        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");\n\n        / Calculate the number of blocks elapsed since the last accrual /\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        require(mathErr == MathError.NO_ERROR, "calc block delta erro");\n\n\n        /\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         /\n\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n        uint borrowIndexNew;\n        uint totalReservesNew;\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        require(mathErr == MathError.NO_ERROR, \'calc interest factor error\');\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc interest acc error\');\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc total borrows error\');\n\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc total reserves error\');\n\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc borrows index error\');\n\n\n        / We write the previously calculated values into storage /\n        accrualBlockNumber = currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n        totalReserves = totalReservesNew;\n\n        / We emit an AccrueInterest event /\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n    }\n\n    struct MintLocalVars {\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint mintTokens;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n        uint actualMintAmount;\n    }\n\n    /// @notice User supplies assets into the market and receives lTokens in exchange\n    /// @dev Assumes interest has already been accrued up to the current block\n    /// @param minter The address of the account which is supplying the assets\n    /// @param mintAmount The amount of the underlying asset to supply\n    /// @return uint the actual mint amount.\n    function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {\n        MintLocalVars memory vars;\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, \'calc exchangerate error\');\n\n        /\n         *  We call doTransferIn for the minter and the mintAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  doTransferIn reverts if anything goes wrong, since we can\'t be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the cToken holds an additional actualMintAmount\n         *  of cash.\n         /\n        if (isDelegete) {\n            uint balanceBefore = getCashPrior();\n            LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);\n            uint balanceAfter = getCashPrior();\n            require(balanceAfter &gt; balanceBefore, \'mint 0\');\n            vars.actualMintAmount = balanceAfter - balanceBefore;\n        } else {\n            vars.actualMintAmount = doTransferIn(minter, mintAmount, true);\n        }\n        /\n         * We get the current exchange rate and calculate the number of lTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         /\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));\n        require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");\n\n        / Fail if mint not allowed /\n        (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);\n        /\n         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         /\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n        require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n        require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");\n\n        / We write previously calculated values into storage /\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[minter] = vars.accountTokensNew;\n\n        / We emit a Mint event, and a Transfer event /\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n        / We call the defense hook /\n\n        return vars.actualMintAmount;\n    }\n\n\n    struct RedeemLocalVars {\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint redeemTokens;\n        uint redeemAmount;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n    }\n\n    /// @notice User redeems lTokens in exchange for the underlying asset\n    /// @dev Assumes interest has already been accrued up to the current block\n    /// @param redeemer The address of the account which is redeeming the tokens\n    /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n    /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");\n\n        RedeemLocalVars memory vars;\n\n        / exchangeRate = invoke Exchange Rate Stored() /\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, \'calc exchangerate error\');\n\n        / If redeemTokensIn &gt; 0: /\n        if (redeemTokensIn &gt; 0) {\n            /\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             /\n            vars.redeemTokens = redeemTokensIn;\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);\n            require(vars.mathErr == MathError.NO_ERROR, \'calc redeem amount error\');\n        } else {\n            /\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             /\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));\n            require(vars.mathErr == MathError.NO_ERROR, \'calc redeem tokens error\');\n            vars.redeemAmount = redeemAmountIn;\n        }\n\n        / Fail if redeem not allowed /\n        (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);\n\n        /\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n         *  totalSupplyNew = totalSupply - redeemTokens\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n         /\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n        require(vars.mathErr == MathError.NO_ERROR, \'calc supply new error\');\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n        require(vars.mathErr == MathError.NO_ERROR, \'calc token new error\');\n        require(getCashPrior() &gt;= vars.redeemAmount, \'cash &lt; redeem\');\n\n        / We write previously calculated values into storage /\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[redeemer] = vars.accountTokensNew;\n        /\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken has redeemAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can\'t be sure if side effects occurred.\n         /\n        doTransferOut(redeemer, vars.redeemAmount, true);\n\n\n        / We emit a Transfer event, and a Redeem event /\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        / We call the defense hook /\n    }\n\n    struct BorrowLocalVars {\n        MathError mathErr;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n    }\n\n    /// @notice Users borrow assets from the protocol to their own address\n    /// @param borrowAmount The amount of the underlying asset to borrow\n    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {\n        / Fail if borrow not allowed /\n        (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);\n\n        / Fail gracefully if protocol has insufficient underlying cash /\n        require(getCashPrior() &gt;= borrowAmount, \'cash vars.actualRepayAmount) {\n            vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;\n        }\n\n        /\n        *  We calculate the new borrower and total borrow balances, failing on underflow:\n        *  accountBorrowsNew = accountBorrows - repayAmount\n        *  totalBorrowsNew = totalBorrows - repayAmount\n        /\n        if (vars.accountBorrows &lt; vars.actualRepayAmount) {\n            require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) &lt;= 105e16, \'repay more than 5%\');\n            vars.accountBorrowsNew = 0;\n        } else {\n            if (isEnd) {\n                vars.accountBorrowsNew = 0;\n            } else {\n                vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;\n            }\n        }\n        //Avoid mantissa errors\n        if (vars.actualRepayAmount &gt; totalBorrows) {\n            vars.totalBorrowsNew = 0;\n        } else {\n            if (isEnd) {\n                vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);\n            } else {\n                vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;\n            }\n        }\n\n        / We write the previously calculated values into storage /\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        / We emit a RepayBorrow event /\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        / We call the defense hook */\n\n        return vars.actualRepayAmount;\n    }\n\n    / Admin Functions ***/\n\n    /// @notice Sets a new CONTROLLER for the market\n    /// @dev Admin function to set a new controller\n    function setController(address newController) external override onlyAdmin {\n        require(address(0) != newController, "0x");\n        address oldController = controller;\n        controller = newController;\n        // Emit NewController(oldController, newController)\n        emit NewController(oldController, newController);\n    }\n\n    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {\n        require(newBorrowCapFactorMantissa &lt;= 1e18, \'Factor too large\');\n        uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;\n        borrowCapFactorMantissa = newBorrowCapFactorMantissa;\n        emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa);\n    }\n\n    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {\n        //accrueInterest except first\n        if (baseRatePerBlock != 0) {\n            accrueInterest();\n        }\n        // total rate perYear &lt; 2000%\n        require(baseRatePerBlock_ &lt; 1e13, \'Base rate too large\');\n        baseRatePerBlock = baseRatePerBlock_;\n        require(multiplierPerBlock_ &lt; 1e13, \'Mul rate too large\');\n        multiplierPerBlock = multiplierPerBlock_;\n        require(jumpMultiplierPerBlock_ &lt; 1e13, \'Jump rate too large\');\n        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;\n        require(kink_ &lt;= 1e18, \'Kline too large\');\n        kink = kink_;\n        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);\n    }\n\n    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {\n        require(newReserveFactorMantissa &lt;= 1e18, \'Factor too large\');\n        accrueInterest();\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n        reserveFactorMantissa = newReserveFactorMantissa;\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n    }\n\n    function addReserves(uint addAmount) external override nonReentrant {\n        accrueInterest();\n        uint totalReservesNew;\n        uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);\n        totalReservesNew = totalReserves.add(actualAddAmount);\n        totalReserves = totalReservesNew;\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n    }\n\n    function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {\n        accrueInterest();\n        uint totalReservesNew;\n        totalReservesNew = totalReserves.sub(reduceAmount);\n        totalReserves = totalReservesNew;\n        doTransferOut(to, reduceAmount, true);\n        emit ReservesReduced(to, reduceAmount, totalReservesNew);\n    }\n\n    modifier sameBlock() {\n        require(accrualBlockNumber == getBlockNumber(), \'not same block\');\n        _;\n    }\n}\n\n'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-24-08 19:27:54 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.7.6; import "./LPoolInterface.sol"; import "./LPoolDepositor.sol"; import "../lib/Exponential.sol"; import "../Adminable.sol"; import "../lib/CarefulMath.sol"; import "../lib/TransferHelper.sol"; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import "../DelegateInterface.sol"; import "../ControllerInterface.sol"; import "../IWETH.sol"; /// @title OpenLeverage's LToken Contract /// @dev Abstract base for LTokens /// @author OpenLeverage contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {     using TransferHelper for IERC20;     using SafeMath for uint; constructor() {  }  /// @notice Initialize the money market /// @param controller_ The address of the Controller /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0 /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point /// @param kink_ The utilization point at which the jump multiplier is applied /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18 /// @param name_ EIP-20 name of this token /// @param symbol_ EIP-20 symbol of this token /// @param decimals_ EIP-20 decimal precision of this token function initialize(     address underlying_,     bool isWethPool_,     address controller_,     uint256 baseRatePerBlock_,     uint256 multiplierPerBlock_,     uint256 jumpMultiplierPerBlock_,     uint256 kink_,     uint initialExchangeRateMantissa_,     string memory name_,     string memory symbol_,     uint8 decimals_) public {     require(underlying_ != address(0), "underlying_ address cannot be 0");     require(controller_ != address(0), "controller_ address cannot be 0");     require(msg.sender == admin, "Only allow to be called by admin");     require(accrualBlockNumber == 0 &amp;&amp; borrowIndex == 0, "inited once");      // Set initial exchange rate     initialExchangeRateMantissa = initialExchangeRateMantissa_;     require(initialExchangeRateMantissa &gt; 0, "Initial Exchange Rate Mantissa should be greater zero");     //set controller     controller = controller_;     isWethPool = isWethPool_;     //set interestRateModel     baseRatePerBlock = baseRatePerBlock_;     multiplierPerBlock = multiplierPerBlock_;     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     kink = kink_;      // Initialize block number and borrow index (block number mocks depend on controller being set)     accrualBlockNumber = getBlockNumber();     borrowIndex = 1e25;     //80%     borrowCapFactorMantissa = 0.8e18;     //10%     reserveFactorMantissa = 0.1e18;       name = name_;     symbol = symbol_;     decimals = decimals_;      _notEntered = true;      // Set underlying and sanity check it     underlying = underlying_;     IERC20(underlying).totalSupply();     emit Transfer(address(0), msg.sender, 0); }  /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender` /// @dev Called by both `transfer` and `transferFrom` internally /// @param spender The address of the account performing the transfer /// @param src The address of the source account /// @param dst The address of the destination account /// @param tokens The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {     require(dst != address(0), "dst address cannot be 0");     /* Do not allow self-transfers */     require(src != dst, "src = dst");     /* Fail if transfer not allowed */     (ControllerInterface(controller)).transferAllowed(src, dst, tokens);      /* Get the allowance, infinite for the account owner */     uint startingAllowance = 0;     if (spender == src) {         startingAllowance = uint(- 1);     } else {         startingAllowance = transferAllowances[src][spender];     }      /* Do the calculations, checking for {under,over}flow */     MathError mathErr;     uint allowanceNew;     uint srcTokensNew;     uint dstTokensNew;      (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);     require(mathErr == MathError.NO_ERROR, 'not allowed');      (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);     require(mathErr == MathError.NO_ERROR, 'not enough');      (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);     require(mathErr == MathError.NO_ERROR, 'too much');      accountTokens[src] = srcTokensNew;     accountTokens[dst] = dstTokensNew;      /* Eat some of the allowance (if necessary) */     if (startingAllowance != uint(- 1)) {         transferAllowances[src][spender] = allowanceNew;     }     /* We emit a Transfer event */     emit Transfer(src, dst, tokens);     return true; }  /// @notice Transfer `amount` tokens from `msg.sender` to `dst` /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, msg.sender, dst, amount); }  /// @notice Transfer `amount` tokens from `src` to `dst` /// @param src The address of the source account /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, src, dst, amount); }  /// @notice Approve `spender` to transfer up to `amount` from `src` /// @dev This will overwrite the approval amount for `spender` ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve) /// @param spender The address of the account which may transfer tokens /// @param amount The number of tokens that are approved (-1 means infinite) /// @return Whether or not the approval succeeded function approve(address spender, uint256 amount) external override returns (bool) {     address src = msg.sender;     transferAllowances[src][spender] = amount;     emit Approval(src, spender, amount);     return true; }  /// @notice Get the current allowance from `owner` for `spender` /// @param owner The address of the account which owns the tokens to be spent /// @param spender The address of the account which may transfer tokens /// @return The number of tokens allowed to be spent (-1 means infinite) function allowance(address owner, address spender) external override view returns (uint256) {     return transferAllowances[owner][spender]; }  /// @notice Get the token balance of the `owner` /// @param owner The address of the account to query /// @return The number of tokens owned by `owner` function balanceOf(address owner) external override view returns (uint256) {     return accountTokens[owner]; }  /// @notice Get the underlying balance of the `owner` /// @dev This also accrues interest in a transaction /// @param owner The address of the account to query /// @return The amount of underlying owned by `owner` function balanceOfUnderlying(address owner) external override returns (uint) {     Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});     (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);     require(mErr == MathError.NO_ERROR, "calc failed");     return balance; }  /*** User Interface ***/  /// @notice Sender supplies assets into the market and receives lTokens in exchange /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param mintAmount The amount of the underlying asset to supply function mint(uint mintAmount) external override nonReentrant {     accrueInterest();     mintFresh(msg.sender, mintAmount, false); }  function mintTo(address to, uint amount) external payable override nonReentrant {     accrueInterest();     if (isWethPool) {         mintFresh(to, msg.value, false);     } else {         mintFresh(to, amount, true);     } }  function mintEth() external payable override nonReentrant {     require(isWethPool, "not eth pool");     accrueInterest();     mintFresh(msg.sender, msg.value, false); }  /// @notice Sender redeems lTokens in exchange for the underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemTokens The number of lTokens to redeem into underlying function redeem(uint redeemTokens) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, redeemTokens, 0); }  /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemAmount The amount of underlying to redeem function redeemUnderlying(uint redeemAmount) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, 0, redeemAmount); }  function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {     accrueInterest();     // borrowFresh emits borrow-specific logs on errors, so we don't need to     borrowFresh(payable(borrower), msg.sender, borrowAmount); }  /// @notice Sender repays a borrow belonging to borrower /// @param borrower the account with the debt being payed off /// @param repayAmount The amount to repay function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     repayBorrowFresh(msg.sender, borrower, repayAmount, false); }  function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     repayBorrowFresh(msg.sender, borrower, repayAmount, true); }   /*** Safe Token ***/  /// Gets balance of this contract in terms of the underlying /// @dev This excludes the value of the current message, if any /// @return The quantity of underlying tokens owned by this contract function getCashPrior() internal view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }   /**  * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.  *      This will revert due to insufficient balance or insufficient allowance.  *      This function returns the actual amount received,  *      which may be less than `amount` if there is a fee attached to the transfer.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {     if (isWethPool &amp;&amp; convertWeth) {         actualAmount = msg.value;         IWETH(underlying).deposit{value : actualAmount}();     } else {         actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);     } }  /**  * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory  *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to  *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified  *      it is &gt;= amount, this should not revert in normal conditions.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferOut(address payable to, uint amount, bool convertWeth) internal {     if (isWethPool &amp;&amp; convertWeth) {         IWETH(underlying).withdraw(amount);         to.transfer(amount);     } else {         IERC20(underlying).safeTransfer(to, amount);     } }  function availableForBorrow() external view override returns (uint){     uint cash = getCashPrior();     (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);     if (err0 != MathError.NO_ERROR) {         return 0;     }     (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);     if (err1 != MathError.NO_ERROR) {         return 0;     }     if (totalBorrows &gt; maxAvailable) {         return 0;     }     return maxAvailable - totalBorrows; }   /// @notice Get a snapshot of the account's balances, and the cached exchange rate /// @dev This is used by controller to more efficiently perform liquidity checks. /// @param account Address of the account to snapshot /// @return ( token balance, borrow balance, exchange rate mantissa) function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {     uint cTokenBalance = accountTokens[account];     uint borrowBalance;     uint exchangeRateMantissa;      MathError mErr;      (mErr, borrowBalance) = borrowBalanceStoredInternal(account);     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      return (cTokenBalance, borrowBalance, exchangeRateMantissa); }  /// @dev Function to simply retrieve block number ///  This exists mainly for inheriting test contracts to stub this result. function getBlockNumber() internal view returns (uint) {     return block.number; }  /// @notice Returns the current per-block borrow interest rate for this cToken /// @return The borrow interest rate per block, scaled by 1e18 function borrowRatePerBlock() external override view returns (uint) {     return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves); }   /// @notice Returns the current per-block supply interest rate for this cToken /// @return The supply interest rate per block, scaled by 1e18 function supplyRatePerBlock() external override view returns (uint) {     return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa); }  function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {     // Utilization rate is 0 when there are no borrows     if (borrows == 0) {         return 0;     }     return borrows.mul(1e18).div(cash.add(borrows).sub(reserves)); }  /// @notice Calculates the current borrow rate per block, with the error code expected by the market /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18) function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {     uint util = utilizationRate(cash, borrows, reserves);     if (util &lt;= kink) {         return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);     } else {         uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);         uint excessUtil = util.sub(kink);         return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);     } }  /// @notice Calculates the current supply rate per block /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The supply rate percentage per block as a mantissa (scaled by 1e18) function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {     uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);     uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);     uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);     return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18); }  /// @notice Returns the current total borrows plus accrued interest /// @return The total borrows with interest function totalBorrowsCurrent() external override view returns (uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return totalBorrows;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, "calc block delta erro");      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      return totalBorrowsNew; }  /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex /// @param account The address whose balance should be calculated after updating borrowIndex /// @return The calculated balance function borrowBalanceCurrent(address account) external view override returns (uint) {     (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();     require(err0 == MathError.NO_ERROR, "calc borrow index fail");     (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);     require(err1 == MathError.NO_ERROR, "calc fail");     return result; }  function borrowBalanceStored(address account) external override view returns (uint){     return accountBorrows[account].principal; }   /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {     return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex); }  /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {     /* Note: we do not assert that the market is up to date */     MathError mathErr;     uint principalTimesIndex;     uint result;      /* Get borrowBalance and borrowIndex */     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];      /* If borrowBalance = 0 then borrowIndex is likely also 0.      * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.      */     if (borrowSnapshot.principal == 0) {         return (MathError.NO_ERROR, 0);     }      /* Calculate new borrow balance using the interest index:      *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex      */     (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      return (MathError.NO_ERROR, result); }  /// @notice Accrue interest then return the up-to-date exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateCurrent() public override nonReentrant returns (uint) {     accrueInterest();     return exchangeRateStored(); }  /// Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateStored() public override view returns (uint) {     (MathError err, uint result) = exchangeRateStoredInternal();     require(err == MathError.NO_ERROR, "calc fail");     return result; }  /// @notice Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return (error code, calculated exchange rate scaled by 1e18) function exchangeRateStoredInternal() internal view returns (MathError, uint) {     uint _totalSupply = totalSupply;     if (_totalSupply == 0) {         /*          * If there are no tokens minted:          *  exchangeRate = initialExchangeRate          */         return (MathError.NO_ERROR, initialExchangeRateMantissa);     } else {         /*          * Otherwise:          *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply          */         uint _totalCash = getCashPrior();         uint cashPlusBorrowsMinusReserves;         Exp memory exchangeRate;         MathError mathErr;          (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          return (MathError.NO_ERROR, exchangeRate.mantissa);     } }  /// @notice Get cash balance of this cToken in the underlying asset /// @return The quantity of underlying asset owned by this contract function getCash() external override view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }  function calCurrentBorrowIndex() internal view returns (MathError, uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;     uint borrowIndexNew;     /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return (MathError.NO_ERROR, borrowIndex);     }     uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);      Exp memory simpleInterestFactor;     (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }     (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);     return (mathErr, borrowIndexNew); }  /// @notice Applies accrued interest to total borrows and reserves /// @dev This calculates interest accrued from the last checkpointed block ///   up to the current block and writes new checkpoint to storage. function accrueInterest() public override {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint borrowIndexPrior = borrowIndex;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, "calc block delta erro");       /*      * Calculate the interest accumulated into borrows and reserves and the new index:      *  simpleInterestFactor = borrowRate * blockDelta      *  interestAccumulated = simpleInterestFactor * totalBorrows      *  totalBorrowsNew = interestAccumulated + totalBorrows      *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex      */      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;     uint borrowIndexNew;     uint totalReservesNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);     require(mathErr == MathError.NO_ERROR, 'calc total reserves error');      (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);     require(mathErr == MathError.NO_ERROR, 'calc borrows index error');       /* We write the previously calculated values into storage */     accrualBlockNumber = currentBlockNumber;     borrowIndex = borrowIndexNew;     totalBorrows = totalBorrowsNew;     totalReserves = totalReservesNew;      /* We emit an AccrueInterest event */     emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);  }  struct MintLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint mintTokens;     uint totalSupplyNew;     uint accountTokensNew;     uint actualMintAmount; }  /// @notice User supplies assets into the market and receives lTokens in exchange /// @dev Assumes interest has already been accrued up to the current block /// @param minter The address of the account which is supplying the assets /// @param mintAmount The amount of the underlying asset to supply /// @return uint the actual mint amount. function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {     MintLocalVars memory vars;     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /*      *  We call `doTransferIn` for the minter and the mintAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if      *  side-effects occurred. The function returns the amount actually transferred,      *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`      *  of cash.      */     if (isDelegete) {         uint balanceBefore = getCashPrior();         LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);         uint balanceAfter = getCashPrior();         require(balanceAfter &gt; balanceBefore, 'mint 0');         vars.actualMintAmount = balanceAfter - balanceBefore;     } else {         vars.actualMintAmount = doTransferIn(minter, mintAmount, true);     }     /*      * We get the current exchange rate and calculate the number of lTokens to be minted:      *  mintTokens = actualMintAmount / exchangeRate      */      (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));     require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");      /* Fail if mint not allowed */     (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);     /*      * We calculate the new total supply of lTokens and minter token balance, checking for overflow:      *  totalSupplyNew = totalSupply + mintTokens      *  accountTokensNew = accountTokens[minter] + mintTokens      */     (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");      (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[minter] = vars.accountTokensNew;      /* We emit a Mint event, and a Transfer event */     emit Mint(minter, vars.actualMintAmount, vars.mintTokens);     emit Transfer(address(this), minter, vars.mintTokens);      /* We call the defense hook */      return vars.actualMintAmount; }   struct RedeemLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint redeemTokens;     uint redeemAmount;     uint totalSupplyNew;     uint accountTokensNew; }  /// @notice User redeems lTokens in exchange for the underlying asset /// @dev Assumes interest has already been accrued up to the current block /// @param redeemer The address of the account which is redeeming the tokens /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero) /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero) function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {     require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");      RedeemLocalVars memory vars;      /* exchangeRate = invoke Exchange Rate Stored() */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /* If redeemTokensIn &gt; 0: */     if (redeemTokensIn &gt; 0) {         /*          * We calculate the exchange rate and the amount of underlying to be redeemed:          *  redeemTokens = redeemTokensIn          *  redeemAmount = redeemTokensIn x exchangeRateCurrent          */         vars.redeemTokens = redeemTokensIn;          (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');     } else {         /*          * We get the current exchange rate and calculate the amount to be redeemed:          *  redeemTokens = redeemAmountIn / exchangeRate          *  redeemAmount = redeemAmountIn          */          (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');         vars.redeemAmount = redeemAmountIn;     }      /* Fail if redeem not allowed */     (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);      /*      * We calculate the new total supply and redeemer balance, checking for underflow:      *  totalSupplyNew = totalSupply - redeemTokens      *  accountTokensNew = accountTokens[redeemer] - redeemTokens      */     (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');      (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');     require(getCashPrior() &gt;= vars.redeemAmount, 'cash &lt; redeem');      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[redeemer] = vars.accountTokensNew;     /*      * We invoke doTransferOut for the redeemer and the redeemAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken has redeemAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(redeemer, vars.redeemAmount, true);       /* We emit a Transfer event, and a Redeem event */     emit Transfer(redeemer, address(this), vars.redeemTokens);     emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);      /* We call the defense hook */ }  struct BorrowLocalVars {     MathError mathErr;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /// @notice Users borrow assets from the protocol to their own address /// @param borrowAmount The amount of the underlying asset to borrow function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {     /* Fail if borrow not allowed */     (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);      /* Fail gracefully if protocol has insufficient underlying cash */     require(getCashPrior() &gt;= borrowAmount, 'cash&lt;borrow');      BorrowLocalVars memory vars;      /*      * We calculate the new borrower and total borrow balances, failing on overflow:      *  accountBorrowsNew = accountBorrows + borrowAmount      *  totalBorrowsNew = totalBorrows + borrowAmount      */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /*      * We invoke doTransferOut for the borrower and the borrowAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken borrowAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(payee, borrowAmount, false);      /* We emit a Borrow event */     emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */ }  struct RepayBorrowLocalVars {     MathError mathErr;     uint repayAmount;     uint borrowerIndex;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew;     uint actualRepayAmount;     uint badDebtsAmount; }  /// @notice Borrows are repaid by another user (possibly the borrower). /// @param payer the account paying off the borrow /// @param borrower the account with the debt being payed off /// @param repayAmount the amount of undelrying tokens being returned function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {     /* Fail if repayBorrow not allowed */     (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);      RepayBorrowLocalVars memory vars;      /* We remember the original borrowerIndex for verification purposes */     vars.borrowerIndex = accountBorrows[borrower].interestIndex;      /* We fetch the amount the borrower owes, with accumulated interest */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');      /* If repayAmount == -1, repayAmount = accountBorrows */     if (repayAmount == uint(- 1)) {         vars.repayAmount = vars.accountBorrows;     } else {         vars.repayAmount = repayAmount;     }     vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);       if (isEnd &amp;&amp; vars.accountBorrows &gt; vars.actualRepayAmount) {         vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;     }      /*     *  We calculate the new borrower and total borrow balances, failing on underflow:     *  accountBorrowsNew = accountBorrows - repayAmount     *  totalBorrowsNew = totalBorrows - repayAmount     */     if (vars.accountBorrows &lt; vars.actualRepayAmount) {         require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) &lt;= 105e16, 'repay more than 5%');         vars.accountBorrowsNew = 0;     } else {         if (isEnd) {             vars.accountBorrowsNew = 0;         } else {             vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;         }     }     //Avoid mantissa errors     if (vars.actualRepayAmount &gt; totalBorrows) {         vars.totalBorrowsNew = 0;     } else {         if (isEnd) {             vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);         } else {             vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;         }     }      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a RepayBorrow event */     emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */      return vars.actualRepayAmount; }  /*** Admin Functions ***/  /// @notice Sets a new CONTROLLER for the market /// @dev Admin function to set a new controller function setController(address newController) external override onlyAdmin {     require(address(0) != newController, "0x");     address oldController = controller;     controller = newController;     // Emit NewController(oldController, newController)     emit NewController(oldController, newController); }  function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {     require(newBorrowCapFactorMantissa &lt;= 1e18, 'Factor too large');     uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;     borrowCapFactorMantissa = newBorrowCapFactorMantissa;     emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa); }  function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {     //accrueInterest except first     if (baseRatePerBlock != 0) {         accrueInterest();     }     // total rate perYear &lt; 2000%     require(baseRatePerBlock_ &lt; 1e13, 'Base rate too large');     baseRatePerBlock = baseRatePerBlock_;     require(multiplierPerBlock_ &lt; 1e13, 'Mul rate too large');     multiplierPerBlock = multiplierPerBlock_;     require(jumpMultiplierPerBlock_ &lt; 1e13, 'Jump rate too large');     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     require(kink_ &lt;= 1e18, 'Kline too large');     kink = kink_;     emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_); }  function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {     require(newReserveFactorMantissa &lt;= 1e18, 'Factor too large');     accrueInterest();     uint oldReserveFactorMantissa = reserveFactorMantissa;     reserveFactorMantissa = newReserveFactorMantissa;     emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa); }  function addReserves(uint addAmount) external override nonReentrant {     accrueInterest();     uint totalReservesNew;     uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);     totalReservesNew = totalReserves.add(actualAddAmount);     totalReserves = totalReservesNew;     emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew); }  function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {     accrueInterest();     uint totalReservesNew;     totalReservesNew = totalReserves.sub(reduceAmount);     totalReserves = totalReservesNew;     doTransferOut(to, reduceAmount, true);     emit ReservesReduced(to, reduceAmount, totalReservesNew); }  modifier sameBlock() {     require(accrualBlockNumber == getBlockNumber(), 'not same block');     _; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-24-08 19:27:54 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;


import "./LPoolInterface.sol";
import "./LPoolDepositor.sol";
import "../lib/Exponential.sol";
import "../Adminable.sol";
import "../lib/CarefulMath.sol";
import "../lib/TransferHelper.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import "../DelegateInterface.sol";
import "../ControllerInterface.sol";
import "../IWETH.sol";

/// @title OpenLeverage's LToken Contract
/// @dev Abstract base for LTokens
/// @author OpenLeverage
contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {
    using TransferHelper for IERC20;
    using SafeMath for uint;

    constructor() {

    }
    
    /// @notice Initialize the money market
    /// @param controller_ The address of the Controller
    /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0
    /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate
    /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point
    /// @param kink_ The utilization point at which the jump multiplier is applied
    /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
    /// @param name_ EIP-20 name of this token
    /// @param symbol_ EIP-20 symbol of this token
    /// @param decimals_ EIP-20 decimal precision of this token
    function initialize(
        address underlying_,
        bool isWethPool_,
        address controller_,
        uint256 baseRatePerBlock_,
        uint256 multiplierPerBlock_,
        uint256 jumpMultiplierPerBlock_,
        uint256 kink_,
        uint initialExchangeRateMantissa_,
        string memory name_,
        string memory symbol_,
        uint8 decimals_) public {
        require(underlying_ != address(0), "underlying_ address cannot be 0");
        require(controller_ != address(0), "controller_ address cannot be 0");
        require(msg.sender == admin, "Only allow to be called by admin");
        require(accrualBlockNumber == 0 && borrowIndex == 0, "inited once");

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial Exchange Rate Mantissa should be greater zero");
        //set controller
        controller = controller_;
        isWethPool = isWethPool_;
        //set interestRateModel
        baseRatePerBlock = baseRatePerBlock_;
        multiplierPerBlock = multiplierPerBlock_;
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        kink = kink_;

        // Initialize block number and borrow index (block number mocks depend on controller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = 1e25;
        //80%
        borrowCapFactorMantissa = 0.8e18;
        //10%
        reserveFactorMantissa = 0.1e18;


        name = name_;
        symbol = symbol_;
        decimals = decimals_;

        _notEntered = true;

        // Set underlying and sanity check it
        underlying = underlying_;
        IERC20(underlying).totalSupply();
        emit Transfer(address(0), msg.sender, 0);
    }

    /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
    /// @dev Called by both `transfer` and `transferFrom` internally
    /// @param spender The address of the account performing the transfer
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param tokens The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {
        require(dst != address(0), "dst address cannot be 0");
        /* Do not allow self-transfers */
        require(src != dst, "src = dst");
        /* Fail if transfer not allowed */
        (ControllerInterface(controller)).transferAllowed(src, dst, tokens);

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(- 1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        require(mathErr == MathError.NO_ERROR, 'not allowed');

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        require(mathErr == MathError.NO_ERROR, 'not enough');

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        require(mathErr == MathError.NO_ERROR, 'too much');

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(- 1)) {
            transferAllowances[src][spender] = allowanceNew;
        }
        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);
        return true;
    }

    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount);
    }

    /// @notice Transfer `amount` tokens from `src` to `dst`
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount);
    }

    /// @notice Approve `spender` to transfer up to `amount` from `src`
    /// @dev This will overwrite the approval amount for `spender`
    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
    /// @param spender The address of the account which may transfer tokens
    /// @param amount The number of tokens that are approved (-1 means infinite)
    /// @return Whether or not the approval succeeded
    function approve(address spender, uint256 amount) external override returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /// @notice Get the current allowance from `owner` for `spender`
    /// @param owner The address of the account which owns the tokens to be spent
    /// @param spender The address of the account which may transfer tokens
    /// @return The number of tokens allowed to be spent (-1 means infinite)
    function allowance(address owner, address spender) external override view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /// @notice Get the token balance of the `owner`
    /// @param owner The address of the account to query
    /// @return The number of tokens owned by `owner`
    function balanceOf(address owner) external override view returns (uint256) {
        return accountTokens[owner];
    }

    /// @notice Get the underlying balance of the `owner`
    /// @dev This also accrues interest in a transaction
    /// @param owner The address of the account to query
    /// @return The amount of underlying owned by `owner`
    function balanceOfUnderlying(address owner) external override returns (uint) {
        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR, "calc failed");
        return balance;
    }

    /*** User Interface ***/

    /// @notice Sender supplies assets into the market and receives lTokens in exchange
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param mintAmount The amount of the underlying asset to supply
    function mint(uint mintAmount) external override nonReentrant {
        accrueInterest();
        mintFresh(msg.sender, mintAmount, false);
    }

    function mintTo(address to, uint amount) external payable override nonReentrant {
        accrueInterest();
        if (isWethPool) {
            mintFresh(to, msg.value, false);
        } else {
            mintFresh(to, amount, true);
        }
    }

    function mintEth() external payable override nonReentrant {
        require(isWethPool, "not eth pool");
        accrueInterest();
        mintFresh(msg.sender, msg.value, false);
    }

    /// @notice Sender redeems lTokens in exchange for the underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemTokens The number of lTokens to redeem into underlying
    function redeem(uint redeemTokens) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, redeemTokens, 0);
    }

    /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemAmount The amount of underlying to redeem
    function redeemUnderlying(uint redeemAmount) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, 0, redeemAmount);
    }

    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {
        accrueInterest();
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        borrowFresh(payable(borrower), msg.sender, borrowAmount);
    }

    /// @notice Sender repays a borrow belonging to borrower
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount The amount to repay
    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        repayBorrowFresh(msg.sender, borrower, repayAmount, false);
    }

    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        repayBorrowFresh(msg.sender, borrower, repayAmount, true);
    }


    /*** Safe Token ***/

    /// Gets balance of this contract in terms of the underlying
    /// @dev This excludes the value of the current message, if any
    /// @return The quantity of underlying tokens owned by this contract
    function getCashPrior() internal view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }


    /**
     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.
     *      This will revert due to insufficient balance or insufficient allowance.
     *      This function returns the actual amount received,
     *      which may be less than `amount` if there is a fee attached to the transfer.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {
        if (isWethPool && convertWeth) {
            actualAmount = msg.value;
            IWETH(underlying).deposit{value : actualAmount}();
        } else {
            actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);
        }
    }

    /**
     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory
     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to
     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified
     *      it is >= amount, this should not revert in normal conditions.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {
        if (isWethPool && convertWeth) {
            IWETH(underlying).withdraw(amount);
            to.transfer(amount);
        } else {
            IERC20(underlying).safeTransfer(to, amount);
        }
    }

    function availableForBorrow() external view override returns (uint){
        uint cash = getCashPrior();
        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);
        if (err0 != MathError.NO_ERROR) {
            return 0;
        }
        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);
        if (err1 != MathError.NO_ERROR) {
            return 0;
        }
        if (totalBorrows > maxAvailable) {
            return 0;
        }
        return maxAvailable - totalBorrows;
    }


    /// @notice Get a snapshot of the account's balances, and the cached exchange rate
    /// @dev This is used by controller to more efficiently perform liquidity checks.
    /// @param account Address of the account to snapshot
    /// @return ( token balance, borrow balance, exchange rate mantissa)
    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        return (cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /// @dev Function to simply retrieve block number
    ///  This exists mainly for inheriting test contracts to stub this result.
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /// @notice Returns the current per-block borrow interest rate for this cToken
    /// @return The borrow interest rate per block, scaled by 1e18
    function borrowRatePerBlock() external override view returns (uint) {
        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
    }

    
    /// @notice Returns the current per-block supply interest rate for this cToken
    /// @return The supply interest rate per block, scaled by 1e18
    function supplyRatePerBlock() external override view returns (uint) {
        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);
    }

    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {
        // Utilization rate is 0 when there are no borrows
        if (borrows == 0) {
            return 0;
        }
        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));
    }

    /// @notice Calculates the current borrow rate per block, with the error code expected by the market
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18)
    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {
        uint util = utilizationRate(cash, borrows, reserves);
        if (util <= kink) {
            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
        } else {
            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
            uint excessUtil = util.sub(kink);
            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);
        }
    }

    /// @notice Calculates the current supply rate per block
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The supply rate percentage per block as a mantissa (scaled by 1e18)
    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {
        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);
        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);
        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);
        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);
    }

    /// @notice Returns the current total borrows plus accrued interest
    /// @return The total borrows with interest
    function totalBorrowsCurrent() external override view returns (uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return totalBorrows;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        return totalBorrowsNew;
    }

    /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
    /// @param account The address whose balance should be calculated after updating borrowIndex
    /// @return The calculated balance
    function borrowBalanceCurrent(address account) external view override returns (uint) {
        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();
        require(err0 == MathError.NO_ERROR, "calc borrow index fail");
        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
        require(err1 == MathError.NO_ERROR, "calc fail");
        return result;
    }

    function borrowBalanceStored(address account) external override view returns (uint){
        return accountBorrows[account].principal;
    }


    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
    }

    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /// @notice Accrue interest then return the up-to-date exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateCurrent() public override nonReentrant returns (uint) {
        accrueInterest();
        return exchangeRateStored();
    }

    /// Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateStored() public override view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "calc fail");
        return result;
    }

    /// @notice Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return (error code, calculated exchange rate scaled by 1e18)
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        uint _totalSupply = totalSupply;
        if (_totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint _totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /// @notice Get cash balance of this cToken in the underlying asset
    /// @return The quantity of underlying asset owned by this contract
    function getCash() external override view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }

    function calCurrentBorrowIndex() internal view returns (MathError, uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;
        uint borrowIndexNew;
        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return (MathError.NO_ERROR, borrowIndex);
        }
        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);

        Exp memory simpleInterestFactor;
        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }
        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);
        return (mathErr, borrowIndexNew);
    }

    /// @notice Applies accrued interest to total borrows and reserves
    /// @dev This calculates interest accrued from the last checkpointed block
    ///   up to the current block and writes new checkpoint to storage.
    function accrueInterest() public override {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint borrowIndexPrior = borrowIndex;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");


        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;
        uint borrowIndexNew;
        uint totalReservesNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total reserves error');

        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);
        require(mathErr == MathError.NO_ERROR, 'calc borrows index error');


        /* We write the previously calculated values into storage */
        accrualBlockNumber = currentBlockNumber;
        borrowIndex = borrowIndexNew;
        totalBorrows = totalBorrowsNew;
        totalReserves = totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);

    }

    struct MintLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
        uint actualMintAmount;
    }

    /// @notice User supplies assets into the market and receives lTokens in exchange
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param minter The address of the account which is supplying the assets
    /// @param mintAmount The amount of the underlying asset to supply
    /// @return uint the actual mint amount.
    function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {
        MintLocalVars memory vars;
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /*
         *  We call `doTransferIn` for the minter and the mintAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if
         *  side-effects occurred. The function returns the amount actually transferred,
         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`
         *  of cash.
         */
        if (isDelegete) {
            uint balanceBefore = getCashPrior();
            LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);
            uint balanceAfter = getCashPrior();
            require(balanceAfter > balanceBefore, 'mint 0');
            vars.actualMintAmount = balanceAfter - balanceBefore;
        } else {
            vars.actualMintAmount = doTransferIn(minter, mintAmount, true);
        }
        /*
         * We get the current exchange rate and calculate the number of lTokens to be minted:
         *  mintTokens = actualMintAmount / exchangeRate
         */

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));
        require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");

        /* Fail if mint not allowed */
        (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);
        /*
         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */

        return vars.actualMintAmount;
    }


    struct RedeemLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /// @notice User redeems lTokens in exchange for the underlying asset
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param redeemer The address of the account which is redeeming the tokens
    /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');
            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');
        require(getCashPrior() >= vars.redeemAmount, 'cash < redeem');

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;
        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(redeemer, vars.redeemAmount, true);


        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
    }

    struct BorrowLocalVars {
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /// @notice Users borrow assets from the protocol to their own address
    /// @param borrowAmount The amount of the underlying asset to borrow
    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {
        /* Fail if borrow not allowed */
        (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);

        /* Fail gracefully if protocol has insufficient underlying cash */
        require(getCashPrior() >= borrowAmount, 'cash<borrow');

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(payee, borrowAmount, false);

        /* We emit a Borrow event */
        emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
    }

    struct RepayBorrowLocalVars {
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
        uint actualRepayAmount;
        uint badDebtsAmount;
    }

    /// @notice Borrows are repaid by another user (possibly the borrower).
    /// @param payer the account paying off the borrow
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount the amount of undelrying tokens being returned
    function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {
        /* Fail if repayBorrow not allowed */
        (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(- 1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }
        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);


        if (isEnd && vars.accountBorrows > vars.actualRepayAmount) {
            vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;
        }

        /*
        *  We calculate the new borrower and total borrow balances, failing on underflow:
        *  accountBorrowsNew = accountBorrows - repayAmount
        *  totalBorrowsNew = totalBorrows - repayAmount
        */
        if (vars.accountBorrows < vars.actualRepayAmount) {
            require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) <= 105e16, 'repay more than 5%');
            vars.accountBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.accountBorrowsNew = 0;
            } else {
                vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;
            }
        }
        //Avoid mantissa errors
        if (vars.actualRepayAmount > totalBorrows) {
            vars.totalBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);
            } else {
                vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;
            }
        }

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */

        return vars.actualRepayAmount;
    }

    /*** Admin Functions ***/

    /// @notice Sets a new CONTROLLER for the market
    /// @dev Admin function to set a new controller
    function setController(address newController) external override onlyAdmin {
        require(address(0) != newController, "0x");
        address oldController = controller;
        controller = newController;
        // Emit NewController(oldController, newController)
        emit NewController(oldController, newController);
    }

    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {
        require(newBorrowCapFactorMantissa <= 1e18, 'Factor too large');
        uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;
        borrowCapFactorMantissa = newBorrowCapFactorMantissa;
        emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa);
    }

    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {
        //accrueInterest except first
        if (baseRatePerBlock != 0) {
            accrueInterest();
        }
        // total rate perYear < 2000%
        require(baseRatePerBlock_ < 1e13, 'Base rate too large');
        baseRatePerBlock = baseRatePerBlock_;
        require(multiplierPerBlock_ < 1e13, 'Mul rate too large');
        multiplierPerBlock = multiplierPerBlock_;
        require(jumpMultiplierPerBlock_ < 1e13, 'Jump rate too large');
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        require(kink_ <= 1e18, 'Kline too large');
        kink = kink_;
        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);
    }

    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {
        require(newReserveFactorMantissa <= 1e18, 'Factor too large');
        accrueInterest();
        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;
        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);
    }

    function addReserves(uint addAmount) external override nonReentrant {
        accrueInterest();
        uint totalReservesNew;
        uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);
        totalReservesNew = totalReserves.add(actualAddAmount);
        totalReserves = totalReservesNew;
        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);
    }

    function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {
        accrueInterest();
        uint totalReservesNew;
        totalReservesNew = totalReserves.sub(reduceAmount);
        totalReserves = totalReservesNew;
        doTransferOut(to, reduceAmount, true);
        emit ReservesReduced(to, reduceAmount, totalReservesNew);
    }

    modifier sameBlock() {
        require(accrualBlockNumber == getBlockNumber(), 'not same block');
        _;
    }
}

.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;


import "./LPoolInterface.sol";
import "./LPoolDepositor.sol";
import "../lib/Exponential.sol";
import "../Adminable.sol";
import "../lib/CarefulMath.sol";
import "../lib/TransferHelper.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import "../DelegateInterface.sol";
import "../ControllerInterface.sol";
import "../IWETH.sol";

/// @title OpenLeverage's LToken Contract
/// @dev Abstract base for LTokens
/// @author OpenLeverage
contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {
    using TransferHelper for IERC20;
    using SafeMath for uint;

    constructor() {

    }
    
    /// @notice Initialize the money market
    /// @param controller_ The address of the Controller
    /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0
    /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate
    /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point
    /// @param kink_ The utilization point at which the jump multiplier is applied
    /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
    /// @param name_ EIP-20 name of this token
    /// @param symbol_ EIP-20 symbol of this token
    /// @param decimals_ EIP-20 decimal precision of this token
    function initialize(
        address underlying_,
        bool isWethPool_,
        address controller_,
        uint256 baseRatePerBlock_,
        uint256 multiplierPerBlock_,
        uint256 jumpMultiplierPerBlock_,
        uint256 kink_,
        uint initialExchangeRateMantissa_,
        string memory name_,
        string memory symbol_,
        uint8 decimals_) public {
        require(underlying_ != address(0), "underlying_ address cannot be 0");
        require(controller_ != address(0), "controller_ address cannot be 0");
        require(msg.sender == admin, "Only allow to be called by admin");
        require(accrualBlockNumber == 0 && borrowIndex == 0, "inited once");

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial Exchange Rate Mantissa should be greater zero");
        //set controller
        controller = controller_;
        isWethPool = isWethPool_;
        //set interestRateModel
        baseRatePerBlock = baseRatePerBlock_;
        multiplierPerBlock = multiplierPerBlock_;
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        kink = kink_;

        // Initialize block number and borrow index (block number mocks depend on controller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = 1e25;
        //80%
        borrowCapFactorMantissa = 0.8e18;
        //10%
        reserveFactorMantissa = 0.1e18;


        name = name_;
        symbol = symbol_;
        decimals = decimals_;

        _notEntered = true;

        // Set underlying and sanity check it
        underlying = underlying_;
        IERC20(underlying).totalSupply();
        emit Transfer(address(0), msg.sender, 0);
    }

    /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
    /// @dev Called by both `transfer` and `transferFrom` internally
    /// @param spender The address of the account performing the transfer
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param tokens The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {
        require(dst != address(0), "dst address cannot be 0");
        /* Do not allow self-transfers */
        require(src != dst, "src = dst");
        /* Fail if transfer not allowed */
        (ControllerInterface(controller)).transferAllowed(src, dst, tokens);

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(- 1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        require(mathErr == MathError.NO_ERROR, 'not allowed');

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        require(mathErr == MathError.NO_ERROR, 'not enough');

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        require(mathErr == MathError.NO_ERROR, 'too much');

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(- 1)) {
            transferAllowances[src][spender] = allowanceNew;
        }
        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);
        return true;
    }

    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount);
    }

    /// @notice Transfer `amount` tokens from `src` to `dst`
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount);
    }

    /// @notice Approve `spender` to transfer up to `amount` from `src`
    /// @dev This will overwrite the approval amount for `spender`
    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
    /// @param spender The address of the account which may transfer tokens
    /// @param amount The number of tokens that are approved (-1 means infinite)
    /// @return Whether or not the approval succeeded
    function approve(address spender, uint256 amount) external override returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /// @notice Get the current allowance from `owner` for `spender`
    /// @param owner The address of the account which owns the tokens to be spent
    /// @param spender The address of the account which may transfer tokens
    /// @return The number of tokens allowed to be spent (-1 means infinite)
    function allowance(address owner, address spender) external override view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /// @notice Get the token balance of the `owner`
    /// @param owner The address of the account to query
    /// @return The number of tokens owned by `owner`
    function balanceOf(address owner) external override view returns (uint256) {
        return accountTokens[owner];
    }

    /// @notice Get the underlying balance of the `owner`
    /// @dev This also accrues interest in a transaction
    /// @param owner The address of the account to query
    /// @return The amount of underlying owned by `owner`
    function balanceOfUnderlying(address owner) external override returns (uint) {
        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR, "calc failed");
        return balance;
    }

    /*** User Interface ***/

    /// @notice Sender supplies assets into the market and receives lTokens in exchange
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param mintAmount The amount of the underlying asset to supply
    function mint(uint mintAmount) external override nonReentrant {
        accrueInterest();
        mintFresh(msg.sender, mintAmount, false);
    }

    function mintTo(address to, uint amount) external payable override nonReentrant {
        accrueInterest();
        if (isWethPool) {
            mintFresh(to, msg.value, false);
        } else {
            mintFresh(to, amount, true);
        }
    }

    function mintEth() external payable override nonReentrant {
        require(isWethPool, "not eth pool");
        accrueInterest();
        mintFresh(msg.sender, msg.value, false);
    }

    /// @notice Sender redeems lTokens in exchange for the underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemTokens The number of lTokens to redeem into underlying
    function redeem(uint redeemTokens) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, redeemTokens, 0);
    }

    /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemAmount The amount of underlying to redeem
    function redeemUnderlying(uint redeemAmount) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, 0, redeemAmount);
    }

    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {
        accrueInterest();
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        borrowFresh(payable(borrower), msg.sender, borrowAmount);
    }

    /// @notice Sender repays a borrow belonging to borrower
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount The amount to repay
    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        repayBorrowFresh(msg.sender, borrower, repayAmount, false);
    }

    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        repayBorrowFresh(msg.sender, borrower, repayAmount, true);
    }


    /*** Safe Token ***/

    /// Gets balance of this contract in terms of the underlying
    /// @dev This excludes the value of the current message, if any
    /// @return The quantity of underlying tokens owned by this contract
    function getCashPrior() internal view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }


    /**
     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.
     *      This will revert due to insufficient balance or insufficient allowance.
     *      This function returns the actual amount received,
     *      which may be less than `amount` if there is a fee attached to the transfer.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {
        if (isWethPool && convertWeth) {
            actualAmount = msg.value;
            IWETH(underlying).deposit{value : actualAmount}();
        } else {
            actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);
        }
    }

    /**
     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory
     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to
     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified
     *      it is >= amount, this should not revert in normal conditions.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {
        if (isWethPool && convertWeth) {
            IWETH(underlying).withdraw(amount);
            to.transfer(amount);
        } else {
            IERC20(underlying).safeTransfer(to, amount);
        }
    }

    function availableForBorrow() external view override returns (uint){
        uint cash = getCashPrior();
        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);
        if (err0 != MathError.NO_ERROR) {
            return 0;
        }
        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);
        if (err1 != MathError.NO_ERROR) {
            return 0;
        }
        if (totalBorrows > maxAvailable) {
            return 0;
        }
        return maxAvailable - totalBorrows;
    }


    /// @notice Get a snapshot of the account's balances, and the cached exchange rate
    /// @dev This is used by controller to more efficiently perform liquidity checks.
    /// @param account Address of the account to snapshot
    /// @return ( token balance, borrow balance, exchange rate mantissa)
    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        return (cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /// @dev Function to simply retrieve block number
    ///  This exists mainly for inheriting test contracts to stub this result.
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /// @notice Returns the current per-block borrow interest rate for this cToken
    /// @return The borrow interest rate per block, scaled by 1e18
    function borrowRatePerBlock() external override view returns (uint) {
        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
    }

    
    /// @notice Returns the current per-block supply interest rate for this cToken
    /// @return The supply interest rate per block, scaled by 1e18
    function supplyRatePerBlock() external override view returns (uint) {
        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);
    }

    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {
        // Utilization rate is 0 when there are no borrows
        if (borrows == 0) {
            return 0;
        }
        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));
    }

    /// @notice Calculates the current borrow rate per block, with the error code expected by the market
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18)
    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {
        uint util = utilizationRate(cash, borrows, reserves);
        if (util <= kink) {
            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
        } else {
            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
            uint excessUtil = util.sub(kink);
            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);
        }
    }

    /// @notice Calculates the current supply rate per block
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The supply rate percentage per block as a mantissa (scaled by 1e18)
    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {
        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);
        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);
        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);
        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);
    }

    /// @notice Returns the current total borrows plus accrued interest
    /// @return The total borrows with interest
    function totalBorrowsCurrent() external override view returns (uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return totalBorrows;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        return totalBorrowsNew;
    }

    /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
    /// @param account The address whose balance should be calculated after updating borrowIndex
    /// @return The calculated balance
    function borrowBalanceCurrent(address account) external view override returns (uint) {
        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();
        require(err0 == MathError.NO_ERROR, "calc borrow index fail");
        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
        require(err1 == MathError.NO_ERROR, "calc fail");
        return result;
    }

    function borrowBalanceStored(address account) external override view returns (uint){
        return accountBorrows[account].principal;
    }


    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
    }

    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /// @notice Accrue interest then return the up-to-date exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateCurrent() public override nonReentrant returns (uint) {
        accrueInterest();
        return exchangeRateStored();
    }

    /// Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateStored() public override view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "calc fail");
        return result;
    }

    /// @notice Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return (error code, calculated exchange rate scaled by 1e18)
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        uint _totalSupply = totalSupply;
        if (_totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint _totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /// @notice Get cash balance of this cToken in the underlying asset
    /// @return The quantity of underlying asset owned by this contract
    function getCash() external override view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }

    function calCurrentBorrowIndex() internal view returns (MathError, uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;
        uint borrowIndexNew;
        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return (MathError.NO_ERROR, borrowIndex);
        }
        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);

        Exp memory simpleInterestFactor;
        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }
        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);
        return (mathErr, borrowIndexNew);
    }

    /// @notice Applies accrued interest to total borrows and reserves
    /// @dev This calculates interest accrued from the last checkpointed block
    ///   up to the current block and writes new checkpoint to storage.
    function accrueInterest() public override {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint borrowIndexPrior = borrowIndex;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");


        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;
        uint borrowIndexNew;
        uint totalReservesNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total reserves error');

        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);
        require(mathErr == MathError.NO_ERROR, 'calc borrows index error');


        /* We write the previously calculated values into storage */
        accrualBlockNumber = currentBlockNumber;
        borrowIndex = borrowIndexNew;
        totalBorrows = totalBorrowsNew;
        totalReserves = totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);

    }

    struct MintLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
        uint actualMintAmount;
    }

    /// @notice User supplies assets into the market and receives lTokens in exchange
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param minter The address of the account which is supplying the assets
    /// @param mintAmount The amount of the underlying asset to supply
    /// @return uint the actual mint amount.
    function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {
        MintLocalVars memory vars;
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /*
         *  We call `doTransferIn` for the minter and the mintAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if
         *  side-effects occurred. The function returns the amount actually transferred,
         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`
         *  of cash.
         */
        if (isDelegete) {
            uint balanceBefore = getCashPrior();
            LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);
            uint balanceAfter = getCashPrior();
            require(balanceAfter > balanceBefore, 'mint 0');
            vars.actualMintAmount = balanceAfter - balanceBefore;
        } else {
            vars.actualMintAmount = doTransferIn(minter, mintAmount, true);
        }
        /*
         * We get the current exchange rate and calculate the number of lTokens to be minted:
         *  mintTokens = actualMintAmount / exchangeRate
         */

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));
        require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");

        /* Fail if mint not allowed */
        (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);
        /*
         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */

        return vars.actualMintAmount;
    }


    struct RedeemLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /// @notice User redeems lTokens in exchange for the underlying asset
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param redeemer The address of the account which is redeeming the tokens
    /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');
            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');
        require(getCashPrior() >= vars.redeemAmount, 'cash < redeem');

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;
        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(redeemer, vars.redeemAmount, true);


        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
    }

    struct BorrowLocalVars {
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /// @notice Users borrow assets from the protocol to their own address
    /// @param borrowAmount The amount of the underlying asset to borrow
    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {
        /* Fail if borrow not allowed */
        (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);

        /* Fail gracefully if protocol has insufficient underlying cash */
        require(getCashPrior() >= borrowAmount, 'cash<borrow');

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(payee, borrowAmount, false);

        /* We emit a Borrow event */
        emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
    }

    struct RepayBorrowLocalVars {
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
        uint actualRepayAmount;
        uint badDebtsAmount;
    }

    /// @notice Borrows are repaid by another user (possibly the borrower).
    /// @param payer the account paying off the borrow
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount the amount of undelrying tokens being returned
    function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {
        /* Fail if repayBorrow not allowed */
        (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(- 1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }
        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);


        if (isEnd && vars.accountBorrows > vars.actualRepayAmount) {
            vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;
        }

        /*
        *  We calculate the new borrower and total borrow balances, failing on underflow:
        *  accountBorrowsNew = accountBorrows - repayAmount
        *  totalBorrowsNew = totalBorrows - repayAmount
        */
        if (vars.accountBorrows < vars.actualRepayAmount) {
            require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) <= 105e16, 'repay more than 5%');
            vars.accountBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.accountBorrowsNew = 0;
            } else {
                vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;
            }
        }
        //Avoid mantissa errors
        if (vars.actualRepayAmount > totalBorrows) {
            vars.totalBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);
            } else {
                vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;
            }
        }

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */

        return vars.actualRepayAmount;
    }

    /*** Admin Functions ***/

    /// @notice Sets a new CONTROLLER for the market
    /// @dev Admin function to set a new controller
    function setController(address newController) external override onlyAdmin {
        require(address(0) != newController, "0x");
        address oldController = controller;
        controller = newController;
        // Emit NewController(oldController, newController)
        emit NewController(oldController, newController);
    }

    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {
        require(newBorrowCapFactorMantissa <= 1e18, 'Factor too large');
        uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;
        borrowCapFactorMantissa = newBorrowCapFactorMantissa;
        emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa);
    }

    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {
        //accrueInterest except first
        if (baseRatePerBlock != 0) {
            accrueInterest();
        }
        // total rate perYear < 2000%
        require(baseRatePerBlock_ < 1e13, 'Base rate too large');
        baseRatePerBlock = baseRatePerBlock_;
        require(multiplierPerBlock_ < 1e13, 'Mul rate too large');
        multiplierPerBlock = multiplierPerBlock_;
        require(jumpMultiplierPerBlock_ < 1e13, 'Jump rate too large');
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        require(kink_ <= 1e18, 'Kline too large');
        kink = kink_;
        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);
    }

    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {
        require(newReserveFactorMantissa <= 1e18, 'Factor too large');
        accrueInterest();
        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;
        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);
    }

    function addReserves(uint addAmount) external override nonReentrant {
        accrueInterest();
        uint totalReservesNew;
        uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);
        totalReservesNew = totalReserves.add(actualAddAmount);
        totalReserves = totalReservesNew;
        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);
    }

    function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {
        accrueInterest();
        uint totalReservesNew;
        totalReservesNew = totalReserves.sub(reduceAmount);
        totalReserves = totalReservesNew;
        doTransferOut(to, reduceAmount, true);
        emit ReservesReduced(to, reduceAmount, totalReservesNew);
    }

    modifier sameBlock() {
        require(accrualBlockNumber == getBlockNumber(), 'not same block');
        _;
    }
}

".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-24-08 19:27:57 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-24-08 19:27:57 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 19892
completion_tokens: 1
total_tokens: 19893
cost: $-1.000000


[2024-24-08 19:27:57 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;


import "./LPoolInterface.sol";
import "./LPoolDepositor.sol";
import "../lib/Exponential.sol";
import "../Adminable.sol";
import "../lib/CarefulMath.sol";
import "../lib/TransferHelper.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import "../DelegateInterface.sol";
import "../ControllerInterface.sol";
import "../IWETH.sol";

/// @title OpenLeverage's LToken Contract
/// @dev Abstract base for LTokens
/// @author OpenLeverage
contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {
    using TransferHelper for IERC20;
    using SafeMath for uint;

    constructor() {

    }
    
    /// @notice Initialize the money market
    /// @param controller_ The address of the Controller
    /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0
    /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate
    /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point
    /// @param kink_ The utilization point at which the jump multiplier is applied
    /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
    /// @param name_ EIP-20 name of this token
    /// @param symbol_ EIP-20 symbol of this token
    /// @param decimals_ EIP-20 decimal precision of this token
    function initialize(
        address underlying_,
        bool isWethPool_,
        address controller_,
        uint256 baseRatePerBlock_,
        uint256 multiplierPerBlock_,
        uint256 jumpMultiplierPerBlock_,
        uint256 kink_,
        uint initialExchangeRateMantissa_,
        string memory name_,
        string memory symbol_,
        uint8 decimals_) public {
        require(underlying_ != address(0), "underlying_ address cannot be 0");
        require(controller_ != address(0), "controller_ address cannot be 0");
        require(msg.sender == admin, "Only allow to be called by admin");
        require(accrualBlockNumber == 0 && borrowIndex == 0, "inited once");

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial Exchange Rate Mantissa should be greater zero");
        //set controller
        controller = controller_;
        isWethPool = isWethPool_;
        //set interestRateModel
        baseRatePerBlock = baseRatePerBlock_;
        multiplierPerBlock = multiplierPerBlock_;
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        kink = kink_;

        // Initialize block number and borrow index (block number mocks depend on controller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = 1e25;
        //80%
        borrowCapFactorMantissa = 0.8e18;
        //10%
        reserveFactorMantissa = 0.1e18;


        name = name_;
        symbol = symbol_;
        decimals = decimals_;

        _notEntered = true;

        // Set underlying and sanity check it
        underlying = underlying_;
        IERC20(underlying).totalSupply();
        emit Transfer(address(0), msg.sender, 0);
    }

    /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
    /// @dev Called by both `transfer` and `transferFrom` internally
    /// @param spender The address of the account performing the transfer
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param tokens The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {
        require(dst != address(0), "dst address cannot be 0");
        /* Do not allow self-transfers */
        require(src != dst, "src = dst");
        /* Fail if transfer not allowed */
        (ControllerInterface(controller)).transferAllowed(src, dst, tokens);

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(- 1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        require(mathErr == MathError.NO_ERROR, 'not allowed');

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        require(mathErr == MathError.NO_ERROR, 'not enough');

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        require(mathErr == MathError.NO_ERROR, 'too much');

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(- 1)) {
            transferAllowances[src][spender] = allowanceNew;
        }
        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);
        return true;
    }

    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount);
    }

    /// @notice Transfer `amount` tokens from `src` to `dst`
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount);
    }

    /// @notice Approve `spender` to transfer up to `amount` from `src`
    /// @dev This will overwrite the approval amount for `spender`
    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
    /// @param spender The address of the account which may transfer tokens
    /// @param amount The number of tokens that are approved (-1 means infinite)
    /// @return Whether or not the approval succeeded
    function approve(address spender, uint256 amount) external override returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /// @notice Get the current allowance from `owner` for `spender`
    /// @param owner The address of the account which owns the tokens to be spent
    /// @param spender The address of the account which may transfer tokens
    /// @return The number of tokens allowed to be spent (-1 means infinite)
    function allowance(address owner, address spender) external override view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /// @notice Get the token balance of the `owner`
    /// @param owner The address of the account to query
    /// @return The number of tokens owned by `owner`
    function balanceOf(address owner) external override view returns (uint256) {
        return accountTokens[owner];
    }

    /// @notice Get the underlying balance of the `owner`
    /// @dev This also accrues interest in a transaction
    /// @param owner The address of the account to query
    /// @return The amount of underlying owned by `owner`
    function balanceOfUnderlying(address owner) external override returns (uint) {
        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR, "calc failed");
        return balance;
    }

    /*** User Interface ***/

    /// @notice Sender supplies assets into the market and receives lTokens in exchange
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param mintAmount The amount of the underlying asset to supply
    function mint(uint mintAmount) external override nonReentrant {
        accrueInterest();
        mintFresh(msg.sender, mintAmount, false);
    }

    function mintTo(address to, uint amount) external payable override nonReentrant {
        accrueInterest();
        if (isWethPool) {
            mintFresh(to, msg.value, false);
        } else {
            mintFresh(to, amount, true);
        }
    }

    function mintEth() external payable override nonReentrant {
        require(isWethPool, "not eth pool");
        accrueInterest();
        mintFresh(msg.sender, msg.value, false);
    }

    /// @notice Sender redeems lTokens in exchange for the underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemTokens The number of lTokens to redeem into underlying
    function redeem(uint redeemTokens) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, redeemTokens, 0);
    }

    /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemAmount The amount of underlying to redeem
    function redeemUnderlying(uint redeemAmount) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, 0, redeemAmount);
    }

    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {
        accrueInterest();
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        borrowFresh(payable(borrower), msg.sender, borrowAmount);
    }

    /// @notice Sender repays a borrow belonging to borrower
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount The amount to repay
    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        repayBorrowFresh(msg.sender, borrower, repayAmount, false);
    }

    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        repayBorrowFresh(msg.sender, borrower, repayAmount, true);
    }


    /*** Safe Token ***/

    /// Gets balance of this contract in terms of the underlying
    /// @dev This excludes the value of the current message, if any
    /// @return The quantity of underlying tokens owned by this contract
    function getCashPrior() internal view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }


    /**
     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.
     *      This will revert due to insufficient balance or insufficient allowance.
     *      This function returns the actual amount received,
     *      which may be less than `amount` if there is a fee attached to the transfer.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {
        if (isWethPool && convertWeth) {
            actualAmount = msg.value;
            IWETH(underlying).deposit{value : actualAmount}();
        } else {
            actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);
        }
    }

    /**
     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory
     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to
     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified
     *      it is >= amount, this should not revert in normal conditions.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {
        if (isWethPool && convertWeth) {
            IWETH(underlying).withdraw(amount);
            to.transfer(amount);
        } else {
            IERC20(underlying).safeTransfer(to, amount);
        }
    }

    function availableForBorrow() external view override returns (uint){
        uint cash = getCashPrior();
        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);
        if (err0 != MathError.NO_ERROR) {
            return 0;
        }
        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);
        if (err1 != MathError.NO_ERROR) {
            return 0;
        }
        if (totalBorrows > maxAvailable) {
            return 0;
        }
        return maxAvailable - totalBorrows;
    }


    /// @notice Get a snapshot of the account's balances, and the cached exchange rate
    /// @dev This is used by controller to more efficiently perform liquidity checks.
    /// @param account Address of the account to snapshot
    /// @return ( token balance, borrow balance, exchange rate mantissa)
    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        return (cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /// @dev Function to simply retrieve block number
    ///  This exists mainly for inheriting test contracts to stub this result.
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /// @notice Returns the current per-block borrow interest rate for this cToken
    /// @return The borrow interest rate per block, scaled by 1e18
    function borrowRatePerBlock() external override view returns (uint) {
        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
    }

    
    /// @notice Returns the current per-block supply interest rate for this cToken
    /// @return The supply interest rate per block, scaled by 1e18
    function supplyRatePerBlock() external override view returns (uint) {
        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);
    }

    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {
        // Utilization rate is 0 when there are no borrows
        if (borrows == 0) {
            return 0;
        }
        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));
    }

    /// @notice Calculates the current borrow rate per block, with the error code expected by the market
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18)
    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {
        uint util = utilizationRate(cash, borrows, reserves);
        if (util <= kink) {
            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
        } else {
            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
            uint excessUtil = util.sub(kink);
            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);
        }
    }

    /// @notice Calculates the current supply rate per block
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The supply rate percentage per block as a mantissa (scaled by 1e18)
    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {
        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);
        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);
        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);
        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);
    }

    /// @notice Returns the current total borrows plus accrued interest
    /// @return The total borrows with interest
    function totalBorrowsCurrent() external override view returns (uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return totalBorrows;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        return totalBorrowsNew;
    }

    /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
    /// @param account The address whose balance should be calculated after updating borrowIndex
    /// @return The calculated balance
    function borrowBalanceCurrent(address account) external view override returns (uint) {
        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();
        require(err0 == MathError.NO_ERROR, "calc borrow index fail");
        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
        require(err1 == MathError.NO_ERROR, "calc fail");
        return result;
    }

    function borrowBalanceStored(address account) external override view returns (uint){
        return accountBorrows[account].principal;
    }


    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
    }

    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /// @notice Accrue interest then return the up-to-date exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateCurrent() public override nonReentrant returns (uint) {
        accrueInterest();
        return exchangeRateStored();
    }

    /// Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateStored() public override view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "calc fail");
        return result;
    }

    /// @notice Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return (error code, calculated exchange rate scaled by 1e18)
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        uint _totalSupply = totalSupply;
        if (_totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint _totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /// @notice Get cash balance of this cToken in the underlying asset
    /// @return The quantity of underlying asset owned by this contract
    function getCash() external override view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }

    function calCurrentBorrowIndex() internal view returns (MathError, uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;
        uint borrowIndexNew;
        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return (MathError.NO_ERROR, borrowIndex);
        }
        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);

        Exp memory simpleInterestFactor;
        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }
        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);
        return (mathErr, borrowIndexNew);
    }

    /// @notice Applies accrued interest to total borrows and reserves
    /// @dev This calculates interest accrued from the last checkpointed block
    ///   up to the current block and writes new checkpoint to storage.
    function accrueInterest() public override {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint borrowIndexPrior = borrowIndex;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");


        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;
        uint borrowIndexNew;
        uint totalReservesNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total reserves error');

        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);
        require(mathErr == MathError.NO_ERROR, 'calc borrows index error');


        /* We write the previously calculated values into storage */
        accrualBlockNumber = currentBlockNumber;
        borrowIndex = borrowIndexNew;
        totalBorrows = totalBorrowsNew;
        totalReserves = totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);

    }

    struct MintLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
        uint actualMintAmount;
    }

    /// @notice User supplies assets into the market and receives lTokens in exchange
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param minter The address of the account which is supplying the assets
    /// @param mintAmount The amount of the underlying asset to supply
    /// @return uint the actual mint amount.
    function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {
        MintLocalVars memory vars;
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /*
         *  We call `doTransferIn` for the minter and the mintAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if
         *  side-effects occurred. The function returns the amount actually transferred,
         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`
         *  of cash.
         */
        if (isDelegete) {
            uint balanceBefore = getCashPrior();
            LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);
            uint balanceAfter = getCashPrior();
            require(balanceAfter > balanceBefore, 'mint 0');
            vars.actualMintAmount = balanceAfter - balanceBefore;
        } else {
            vars.actualMintAmount = doTransferIn(minter, mintAmount, true);
        }
        /*
         * We get the current exchange rate and calculate the number of lTokens to be minted:
         *  mintTokens = actualMintAmount / exchangeRate
         */

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));
        require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");

        /* Fail if mint not allowed */
        (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);
        /*
         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */

        return vars.actualMintAmount;
    }


    struct RedeemLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /// @notice User redeems lTokens in exchange for the underlying asset
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param redeemer The address of the account which is redeeming the tokens
    /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');
            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');
        require(getCashPrior() >= vars.redeemAmount, 'cash < redeem');

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;
        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(redeemer, vars.redeemAmount, true);


        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
    }

    struct BorrowLocalVars {
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /// @notice Users borrow assets from the protocol to their own address
    /// @param borrowAmount The amount of the underlying asset to borrow
    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {
        /* Fail if borrow not allowed */
        (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);

        /* Fail gracefully if protocol has insufficient underlying cash */
        require(getCashPrior() >= borrowAmount, 'cash<borrow');

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(payee, borrowAmount, false);

        /* We emit a Borrow event */
        emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
    }

    struct RepayBorrowLocalVars {
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
        uint actualRepayAmount;
        uint badDebtsAmount;
    }

    /// @notice Borrows are repaid by another user (possibly the borrower).
    /// @param payer the account paying off the borrow
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount the amount of undelrying tokens being returned
    function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {
        /* Fail if repayBorrow not allowed */
        (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(- 1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }
        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);


        if (isEnd && vars.accountBorrows > vars.actualRepayAmount) {
            vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;
        }

        /*
        *  We calculate the new borrower and total borrow balances, failing on underflow:
        *  accountBorrowsNew = accountBorrows - repayAmount
        *  totalBorrowsNew = totalBorrows - repayAmount
        */
        if (vars.accountBorrows < vars.actualRepayAmount) {
            require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) <= 105e16, 'repay more than 5%');
            vars.accountBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.accountBorrowsNew = 0;
            } else {
                vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;
            }
        }
        //Avoid mantissa errors
        if (vars.actualRepayAmount > totalBorrows) {
            vars.totalBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);
            } else {
                vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;
            }
        }

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */

        return vars.actualRepayAmount;
    }

    /*** Admin Functions ***/

    /// @notice Sets a new CONTROLLER for the market
    /// @dev Admin function to set a new controller
    function setController(address newController) external override onlyAdmin {
        require(address(0) != newController, "0x");
        address oldController = controller;
        controller = newController;
        // Emit NewController(oldController, newController)
        emit NewController(oldController, newController);
    }

    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {
        require(newBorrowCapFactorMantissa <= 1e18, 'Factor too large');
        uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;
        borrowCapFactorMantissa = newBorrowCapFactorMantissa;
        emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa);
    }

    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {
        //accrueInterest except first
        if (baseRatePerBlock != 0) {
            accrueInterest();
        }
        // total rate perYear < 2000%
        require(baseRatePerBlock_ < 1e13, 'Base rate too large');
        baseRatePerBlock = baseRatePerBlock_;
        require(multiplierPerBlock_ < 1e13, 'Mul rate too large');
        multiplierPerBlock = multiplierPerBlock_;
        require(jumpMultiplierPerBlock_ < 1e13, 'Jump rate too large');
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        require(kink_ <= 1e18, 'Kline too large');
        kink = kink_;
        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);
    }

    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {
        require(newReserveFactorMantissa <= 1e18, 'Factor too large');
        accrueInterest();
        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;
        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);
    }

    function addReserves(uint addAmount) external override nonReentrant {
        accrueInterest();
        uint totalReservesNew;
        uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);
        totalReservesNew = totalReserves.add(actualAddAmount);
        totalReserves = totalReservesNew;
        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);
    }

    function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {
        accrueInterest();
        uint totalReservesNew;
        totalReservesNew = totalReserves.sub(reduceAmount);
        totalReserves = totalReservesNew;
        doTransferOut(to, reduceAmount, true);
        emit ReservesReduced(to, reduceAmount, totalReservesNew);
    }

    modifier sameBlock() {
        require(accrualBlockNumber == getBlockNumber(), 'not same block');
        _;
    }
}

.]

Let's

[2024-24-08 19:27:58 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.7.6; import "./LPoolInterface.sol"; import "./LPoolDepositor.sol"; import "../lib/Exponential.sol"; import "../Adminable.sol"; import "../lib/CarefulMath.sol"; import "../lib/TransferHelper.sol"; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import "../DelegateInterface.sol"; import "../ControllerInterface.sol"; import "../IWETH.sol"; /// @title OpenLeverage's LToken Contract /// @dev Abstract base for LTokens /// @author OpenLeverage contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {     using TransferHelper for IERC20;     using SafeMath for uint; constructor() {  }  /// @notice Initialize the money market /// @param controller_ The address of the Controller /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0 /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point /// @param kink_ The utilization point at which the jump multiplier is applied /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18 /// @param name_ EIP-20 name of this token /// @param symbol_ EIP-20 symbol of this token /// @param decimals_ EIP-20 decimal precision of this token function initialize(     address underlying_,     bool isWethPool_,     address controller_,     uint256 baseRatePerBlock_,     uint256 multiplierPerBlock_,     uint256 jumpMultiplierPerBlock_,     uint256 kink_,     uint initialExchangeRateMantissa_,     string memory name_,     string memory symbol_,     uint8 decimals_) public {     require(underlying_ != address(0), "underlying_ address cannot be 0");     require(controller_ != address(0), "controller_ address cannot be 0");     require(msg.sender == admin, "Only allow to be called by admin");     require(accrualBlockNumber == 0 &amp;&amp; borrowIndex == 0, "inited once");      // Set initial exchange rate     initialExchangeRateMantissa = initialExchangeRateMantissa_;     require(initialExchangeRateMantissa &gt; 0, "Initial Exchange Rate Mantissa should be greater zero");     //set controller     controller = controller_;     isWethPool = isWethPool_;     //set interestRateModel     baseRatePerBlock = baseRatePerBlock_;     multiplierPerBlock = multiplierPerBlock_;     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     kink = kink_;      // Initialize block number and borrow index (block number mocks depend on controller being set)     accrualBlockNumber = getBlockNumber();     borrowIndex = 1e25;     //80%     borrowCapFactorMantissa = 0.8e18;     //10%     reserveFactorMantissa = 0.1e18;       name = name_;     symbol = symbol_;     decimals = decimals_;      _notEntered = true;      // Set underlying and sanity check it     underlying = underlying_;     IERC20(underlying).totalSupply();     emit Transfer(address(0), msg.sender, 0); }  /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender` /// @dev Called by both `transfer` and `transferFrom` internally /// @param spender The address of the account performing the transfer /// @param src The address of the source account /// @param dst The address of the destination account /// @param tokens The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {     require(dst != address(0), "dst address cannot be 0");     /* Do not allow self-transfers */     require(src != dst, "src = dst");     /* Fail if transfer not allowed */     (ControllerInterface(controller)).transferAllowed(src, dst, tokens);      /* Get the allowance, infinite for the account owner */     uint startingAllowance = 0;     if (spender == src) {         startingAllowance = uint(- 1);     } else {         startingAllowance = transferAllowances[src][spender];     }      /* Do the calculations, checking for {under,over}flow */     MathError mathErr;     uint allowanceNew;     uint srcTokensNew;     uint dstTokensNew;      (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);     require(mathErr == MathError.NO_ERROR, 'not allowed');      (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);     require(mathErr == MathError.NO_ERROR, 'not enough');      (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);     require(mathErr == MathError.NO_ERROR, 'too much');      accountTokens[src] = srcTokensNew;     accountTokens[dst] = dstTokensNew;      /* Eat some of the allowance (if necessary) */     if (startingAllowance != uint(- 1)) {         transferAllowances[src][spender] = allowanceNew;     }     /* We emit a Transfer event */     emit Transfer(src, dst, tokens);     return true; }  /// @notice Transfer `amount` tokens from `msg.sender` to `dst` /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, msg.sender, dst, amount); }  /// @notice Transfer `amount` tokens from `src` to `dst` /// @param src The address of the source account /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, src, dst, amount); }  /// @notice Approve `spender` to transfer up to `amount` from `src` /// @dev This will overwrite the approval amount for `spender` ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve) /// @param spender The address of the account which may transfer tokens /// @param amount The number of tokens that are approved (-1 means infinite) /// @return Whether or not the approval succeeded function approve(address spender, uint256 amount) external override returns (bool) {     address src = msg.sender;     transferAllowances[src][spender] = amount;     emit Approval(src, spender, amount);     return true; }  /// @notice Get the current allowance from `owner` for `spender` /// @param owner The address of the account which owns the tokens to be spent /// @param spender The address of the account which may transfer tokens /// @return The number of tokens allowed to be spent (-1 means infinite) function allowance(address owner, address spender) external override view returns (uint256) {     return transferAllowances[owner][spender]; }  /// @notice Get the token balance of the `owner` /// @param owner The address of the account to query /// @return The number of tokens owned by `owner` function balanceOf(address owner) external override view returns (uint256) {     return accountTokens[owner]; }  /// @notice Get the underlying balance of the `owner` /// @dev This also accrues interest in a transaction /// @param owner The address of the account to query /// @return The amount of underlying owned by `owner` function balanceOfUnderlying(address owner) external override returns (uint) {     Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});     (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);     require(mErr == MathError.NO_ERROR, "calc failed");     return balance; }  /*** User Interface ***/  /// @notice Sender supplies assets into the market and receives lTokens in exchange /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param mintAmount The amount of the underlying asset to supply function mint(uint mintAmount) external override nonReentrant {     accrueInterest();     mintFresh(msg.sender, mintAmount, false); }  function mintTo(address to, uint amount) external payable override nonReentrant {     accrueInterest();     if (isWethPool) {         mintFresh(to, msg.value, false);     } else {         mintFresh(to, amount, true);     } }  function mintEth() external payable override nonReentrant {     require(isWethPool, "not eth pool");     accrueInterest();     mintFresh(msg.sender, msg.value, false); }  /// @notice Sender redeems lTokens in exchange for the underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemTokens The number of lTokens to redeem into underlying function redeem(uint redeemTokens) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, redeemTokens, 0); }  /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemAmount The amount of underlying to redeem function redeemUnderlying(uint redeemAmount) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, 0, redeemAmount); }  function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {     accrueInterest();     // borrowFresh emits borrow-specific logs on errors, so we don't need to     borrowFresh(payable(borrower), msg.sender, borrowAmount); }  /// @notice Sender repays a borrow belonging to borrower /// @param borrower the account with the debt being payed off /// @param repayAmount The amount to repay function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     repayBorrowFresh(msg.sender, borrower, repayAmount, false); }  function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     repayBorrowFresh(msg.sender, borrower, repayAmount, true); }   /*** Safe Token ***/  /// Gets balance of this contract in terms of the underlying /// @dev This excludes the value of the current message, if any /// @return The quantity of underlying tokens owned by this contract function getCashPrior() internal view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }   /**  * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.  *      This will revert due to insufficient balance or insufficient allowance.  *      This function returns the actual amount received,  *      which may be less than `amount` if there is a fee attached to the transfer.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {     if (isWethPool &amp;&amp; convertWeth) {         actualAmount = msg.value;         IWETH(underlying).deposit{value : actualAmount}();     } else {         actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);     } }  /**  * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory  *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to  *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified  *      it is &gt;= amount, this should not revert in normal conditions.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferOut(address payable to, uint amount, bool convertWeth) internal {     if (isWethPool &amp;&amp; convertWeth) {         IWETH(underlying).withdraw(amount);         to.transfer(amount);     } else {         IERC20(underlying).safeTransfer(to, amount);     } }  function availableForBorrow() external view override returns (uint){     uint cash = getCashPrior();     (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);     if (err0 != MathError.NO_ERROR) {         return 0;     }     (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);     if (err1 != MathError.NO_ERROR) {         return 0;     }     if (totalBorrows &gt; maxAvailable) {         return 0;     }     return maxAvailable - totalBorrows; }   /// @notice Get a snapshot of the account's balances, and the cached exchange rate /// @dev This is used by controller to more efficiently perform liquidity checks. /// @param account Address of the account to snapshot /// @return ( token balance, borrow balance, exchange rate mantissa) function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {     uint cTokenBalance = accountTokens[account];     uint borrowBalance;     uint exchangeRateMantissa;      MathError mErr;      (mErr, borrowBalance) = borrowBalanceStoredInternal(account);     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      return (cTokenBalance, borrowBalance, exchangeRateMantissa); }  /// @dev Function to simply retrieve block number ///  This exists mainly for inheriting test contracts to stub this result. function getBlockNumber() internal view returns (uint) {     return block.number; }  /// @notice Returns the current per-block borrow interest rate for this cToken /// @return The borrow interest rate per block, scaled by 1e18 function borrowRatePerBlock() external override view returns (uint) {     return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves); }   /// @notice Returns the current per-block supply interest rate for this cToken /// @return The supply interest rate per block, scaled by 1e18 function supplyRatePerBlock() external override view returns (uint) {     return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa); }  function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {     // Utilization rate is 0 when there are no borrows     if (borrows == 0) {         return 0;     }     return borrows.mul(1e18).div(cash.add(borrows).sub(reserves)); }  /// @notice Calculates the current borrow rate per block, with the error code expected by the market /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18) function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {     uint util = utilizationRate(cash, borrows, reserves);     if (util &lt;= kink) {         return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);     } else {         uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);         uint excessUtil = util.sub(kink);         return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);     } }  /// @notice Calculates the current supply rate per block /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The supply rate percentage per block as a mantissa (scaled by 1e18) function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {     uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);     uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);     uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);     return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18); }  /// @notice Returns the current total borrows plus accrued interest /// @return The total borrows with interest function totalBorrowsCurrent() external override view returns (uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return totalBorrows;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, "calc block delta erro");      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      return totalBorrowsNew; }  /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex /// @param account The address whose balance should be calculated after updating borrowIndex /// @return The calculated balance function borrowBalanceCurrent(address account) external view override returns (uint) {     (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();     require(err0 == MathError.NO_ERROR, "calc borrow index fail");     (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);     require(err1 == MathError.NO_ERROR, "calc fail");     return result; }  function borrowBalanceStored(address account) external override view returns (uint){     return accountBorrows[account].principal; }   /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {     return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex); }  /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {     /* Note: we do not assert that the market is up to date */     MathError mathErr;     uint principalTimesIndex;     uint result;      /* Get borrowBalance and borrowIndex */     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];      /* If borrowBalance = 0 then borrowIndex is likely also 0.      * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.      */     if (borrowSnapshot.principal == 0) {         return (MathError.NO_ERROR, 0);     }      /* Calculate new borrow balance using the interest index:      *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex      */     (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      return (MathError.NO_ERROR, result); }  /// @notice Accrue interest then return the up-to-date exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateCurrent() public override nonReentrant returns (uint) {     accrueInterest();     return exchangeRateStored(); }  /// Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateStored() public override view returns (uint) {     (MathError err, uint result) = exchangeRateStoredInternal();     require(err == MathError.NO_ERROR, "calc fail");     return result; }  /// @notice Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return (error code, calculated exchange rate scaled by 1e18) function exchangeRateStoredInternal() internal view returns (MathError, uint) {     uint _totalSupply = totalSupply;     if (_totalSupply == 0) {         /*          * If there are no tokens minted:          *  exchangeRate = initialExchangeRate          */         return (MathError.NO_ERROR, initialExchangeRateMantissa);     } else {         /*          * Otherwise:          *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply          */         uint _totalCash = getCashPrior();         uint cashPlusBorrowsMinusReserves;         Exp memory exchangeRate;         MathError mathErr;          (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          return (MathError.NO_ERROR, exchangeRate.mantissa);     } }  /// @notice Get cash balance of this cToken in the underlying asset /// @return The quantity of underlying asset owned by this contract function getCash() external override view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }  function calCurrentBorrowIndex() internal view returns (MathError, uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;     uint borrowIndexNew;     /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return (MathError.NO_ERROR, borrowIndex);     }     uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);      Exp memory simpleInterestFactor;     (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }     (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);     return (mathErr, borrowIndexNew); }  /// @notice Applies accrued interest to total borrows and reserves /// @dev This calculates interest accrued from the last checkpointed block ///   up to the current block and writes new checkpoint to storage. function accrueInterest() public override {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint borrowIndexPrior = borrowIndex;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, "calc block delta erro");       /*      * Calculate the interest accumulated into borrows and reserves and the new index:      *  simpleInterestFactor = borrowRate * blockDelta      *  interestAccumulated = simpleInterestFactor * totalBorrows      *  totalBorrowsNew = interestAccumulated + totalBorrows      *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex      */      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;     uint borrowIndexNew;     uint totalReservesNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);     require(mathErr == MathError.NO_ERROR, 'calc total reserves error');      (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);     require(mathErr == MathError.NO_ERROR, 'calc borrows index error');       /* We write the previously calculated values into storage */     accrualBlockNumber = currentBlockNumber;     borrowIndex = borrowIndexNew;     totalBorrows = totalBorrowsNew;     totalReserves = totalReservesNew;      /* We emit an AccrueInterest event */     emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);  }  struct MintLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint mintTokens;     uint totalSupplyNew;     uint accountTokensNew;     uint actualMintAmount; }  /// @notice User supplies assets into the market and receives lTokens in exchange /// @dev Assumes interest has already been accrued up to the current block /// @param minter The address of the account which is supplying the assets /// @param mintAmount The amount of the underlying asset to supply /// @return uint the actual mint amount. function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {     MintLocalVars memory vars;     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /*      *  We call `doTransferIn` for the minter and the mintAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if      *  side-effects occurred. The function returns the amount actually transferred,      *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`      *  of cash.      */     if (isDelegete) {         uint balanceBefore = getCashPrior();         LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);         uint balanceAfter = getCashPrior();         require(balanceAfter &gt; balanceBefore, 'mint 0');         vars.actualMintAmount = balanceAfter - balanceBefore;     } else {         vars.actualMintAmount = doTransferIn(minter, mintAmount, true);     }     /*      * We get the current exchange rate and calculate the number of lTokens to be minted:      *  mintTokens = actualMintAmount / exchangeRate      */      (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));     require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");      /* Fail if mint not allowed */     (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);     /*      * We calculate the new total supply of lTokens and minter token balance, checking for overflow:      *  totalSupplyNew = totalSupply + mintTokens      *  accountTokensNew = accountTokens[minter] + mintTokens      */     (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");      (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[minter] = vars.accountTokensNew;      /* We emit a Mint event, and a Transfer event */     emit Mint(minter, vars.actualMintAmount, vars.mintTokens);     emit Transfer(address(this), minter, vars.mintTokens);      /* We call the defense hook */      return vars.actualMintAmount; }   struct RedeemLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint redeemTokens;     uint redeemAmount;     uint totalSupplyNew;     uint accountTokensNew; }  /// @notice User redeems lTokens in exchange for the underlying asset /// @dev Assumes interest has already been accrued up to the current block /// @param redeemer The address of the account which is redeeming the tokens /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero) /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero) function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {     require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");      RedeemLocalVars memory vars;      /* exchangeRate = invoke Exchange Rate Stored() */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /* If redeemTokensIn &gt; 0: */     if (redeemTokensIn &gt; 0) {         /*          * We calculate the exchange rate and the amount of underlying to be redeemed:          *  redeemTokens = redeemTokensIn          *  redeemAmount = redeemTokensIn x exchangeRateCurrent          */         vars.redeemTokens = redeemTokensIn;          (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');     } else {         /*          * We get the current exchange rate and calculate the amount to be redeemed:          *  redeemTokens = redeemAmountIn / exchangeRate          *  redeemAmount = redeemAmountIn          */          (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');         vars.redeemAmount = redeemAmountIn;     }      /* Fail if redeem not allowed */     (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);      /*      * We calculate the new total supply and redeemer balance, checking for underflow:      *  totalSupplyNew = totalSupply - redeemTokens      *  accountTokensNew = accountTokens[redeemer] - redeemTokens      */     (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');      (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');     require(getCashPrior() &gt;= vars.redeemAmount, 'cash &lt; redeem');      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[redeemer] = vars.accountTokensNew;     /*      * We invoke doTransferOut for the redeemer and the redeemAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken has redeemAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(redeemer, vars.redeemAmount, true);       /* We emit a Transfer event, and a Redeem event */     emit Transfer(redeemer, address(this), vars.redeemTokens);     emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);      /* We call the defense hook */ }  struct BorrowLocalVars {     MathError mathErr;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /// @notice Users borrow assets from the protocol to their own address /// @param borrowAmount The amount of the underlying asset to borrow function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {     /* Fail if borrow not allowed */     (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);      /* Fail gracefully if protocol has insufficient underlying cash */     require(getCashPrior() &gt;= borrowAmount, 'cash&lt;borrow');      BorrowLocalVars memory vars;      /*      * We calculate the new borrower and total borrow balances, failing on overflow:      *  accountBorrowsNew = accountBorrows + borrowAmount      *  totalBorrowsNew = totalBorrows + borrowAmount      */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /*      * We invoke doTransferOut for the borrower and the borrowAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken borrowAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(payee, borrowAmount, false);      /* We emit a Borrow event */     emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */ }  struct RepayBorrowLocalVars {     MathError mathErr;     uint repayAmount;     uint borrowerIndex;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew;     uint actualRepayAmount;     uint badDebtsAmount; }  /// @notice Borrows are repaid by another user (possibly the borrower). /// @param payer the account paying off the borrow /// @param borrower the account with the debt being payed off /// @param repayAmount the amount of undelrying tokens being returned function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {     /* Fail if repayBorrow not allowed */     (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);      RepayBorrowLocalVars memory vars;      /* We remember the original borrowerIndex for verification purposes */     vars.borrowerIndex = accountBorrows[borrower].interestIndex;      /* We fetch the amount the borrower owes, with accumulated interest */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');      /* If repayAmount == -1, repayAmount = accountBorrows */     if (repayAmount == uint(- 1)) {         vars.repayAmount = vars.accountBorrows;     } else {         vars.repayAmount = repayAmount;     }     vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);       if (isEnd &amp;&amp; vars.accountBorrows &gt; vars.actualRepayAmount) {         vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;     }      /*     *  We calculate the new borrower and total borrow balances, failing on underflow:     *  accountBorrowsNew = accountBorrows - repayAmount     *  totalBorrowsNew = totalBorrows - repayAmount     */     if (vars.accountBorrows &lt; vars.actualRepayAmount) {         require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) &lt;= 105e16, 'repay more than 5%');         vars.accountBorrowsNew = 0;     } else {         if (isEnd) {             vars.accountBorrowsNew = 0;         } else {             vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;         }     }     //Avoid mantissa errors     if (vars.actualRepayAmount &gt; totalBorrows) {         vars.totalBorrowsNew = 0;     } else {         if (isEnd) {             vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);         } else {             vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;         }     }      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a RepayBorrow event */     emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */      return vars.actualRepayAmount; }  /*** Admin Functions ***/  /// @notice Sets a new CONTROLLER for the market /// @dev Admin function to set a new controller function setController(address newController) external override onlyAdmin {     require(address(0) != newController, "0x");     address oldController = controller;     controller = newController;     // Emit NewController(oldController, newController)     emit NewController(oldController, newController); }  function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {     require(newBorrowCapFactorMantissa &lt;= 1e18, 'Factor too large');     uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;     borrowCapFactorMantissa = newBorrowCapFactorMantissa;     emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa); }  function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {     //accrueInterest except first     if (baseRatePerBlock != 0) {         accrueInterest();     }     // total rate perYear &lt; 2000%     require(baseRatePerBlock_ &lt; 1e13, 'Base rate too large');     baseRatePerBlock = baseRatePerBlock_;     require(multiplierPerBlock_ &lt; 1e13, 'Mul rate too large');     multiplierPerBlock = multiplierPerBlock_;     require(jumpMultiplierPerBlock_ &lt; 1e13, 'Jump rate too large');     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     require(kink_ &lt;= 1e18, 'Kline too large');     kink = kink_;     emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_); }  function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {     require(newReserveFactorMantissa &lt;= 1e18, 'Factor too large');     accrueInterest();     uint oldReserveFactorMantissa = reserveFactorMantissa;     reserveFactorMantissa = newReserveFactorMantissa;     emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa); }  function addReserves(uint addAmount) external override nonReentrant {     accrueInterest();     uint totalReservesNew;     uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);     totalReservesNew = totalReserves.add(actualAddAmount);     totalReserves = totalReservesNew;     emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew); }  function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {     accrueInterest();     uint totalReservesNew;     totalReservesNew = totalReserves.sub(reduceAmount);     totalReserves = totalReservesNew;     doTransferOut(to, reduceAmount, true);     emit ReservesReduced(to, reduceAmount, totalReservesNew); }  modifier sameBlock() {     require(accrualBlockNumber == getBlockNumber(), 'not same block');     _; }  } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: // SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.7.6;\n\nimport "./LPoolInterface.sol";\nimport "./LPoolDepositor.sol";\nimport "../lib/Exponential.sol";\nimport "../Adminable.sol";\nimport "../lib/CarefulMath.sol";\nimport "../lib/TransferHelper.sol";\nimport "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\nimport "../DelegateInterface.sol";\nimport "../ControllerInterface.sol";\nimport "../IWETH.sol";\n/// @title OpenLeverage\'s LToken Contract\n/// @dev Abstract base for LTokens\n/// @author OpenLeverage\ncontract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {\n    using TransferHelper for IERC20;\n    using SafeMath for uint;\n    constructor() {\n    }\n    \n    /// @notice Initialize the money market\n    /// @param controller_ The address of the Controller\n    /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0\n    /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate\n    /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point\n    /// @param kink_ The utilization point at which the jump multiplier is applied\n    /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n    /// @param name_ EIP-20 name of this token\n    /// @param symbol_ EIP-20 symbol of this token\n    /// @param decimals_ EIP-20 decimal precision of this token\n    function initialize(\n        address underlying_,\n        bool isWethPool_,\n        address controller_,\n        uint256 baseRatePerBlock_,\n        uint256 multiplierPerBlock_,\n        uint256 jumpMultiplierPerBlock_,\n        uint256 kink_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_) public {\n        require(underlying_ != address(0), "underlying_ address cannot be 0");\n        require(controller_ != address(0), "controller_ address cannot be 0");\n        require(msg.sender == admin, "Only allow to be called by admin");\n        require(accrualBlockNumber == 0 &amp;&amp; borrowIndex == 0, "inited once");\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa &gt; 0, "Initial Exchange Rate Mantissa should be greater zero");\n        //set controller\n        controller = controller_;\n        isWethPool = isWethPool_;\n        //set interestRateModel\n        baseRatePerBlock = baseRatePerBlock_;\n        multiplierPerBlock = multiplierPerBlock_;\n        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;\n        kink = kink_;\n        // Initialize block number and borrow index (block number mocks depend on controller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = 1e25;\n        //80%\n        borrowCapFactorMantissa = 0.8e18;\n        //10%\n        reserveFactorMantissa = 0.1e18;\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n        notEntered = true;\n        // Set underlying and sanity check it\n        underlying = underlying;\n        IERC20(underlying).totalSupply();\n        emit Transfer(address(0), msg.sender, 0);\n    }\n    /// @notice Transfer tokens tokens from src to dst by spender\n    /// @dev Called by both transfer and transferFrom internally\n    /// @param spender The address of the account performing the transfer\n    /// @param src The address of the source account\n    /// @param dst The address of the destination account\n    /// @param tokens The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {\n        require(dst != address(0), "dst address cannot be 0");\n        / Do not allow self-transfers /\n        require(src != dst, "src = dst");\n        / Fail if transfer not allowed /\n        (ControllerInterface(controller)).transferAllowed(src, dst, tokens);\n        / Get the allowance, infinite for the account owner /\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = uint(- 1);\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n        / Do the calculations, checking for {under,over}flow /\n        MathError mathErr;\n        uint allowanceNew;\n        uint srcTokensNew;\n        uint dstTokensNew;\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n        require(mathErr == MathError.NO_ERROR, \'not allowed\');\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n        require(mathErr == MathError.NO_ERROR, \'not enough\');\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n        require(mathErr == MathError.NO_ERROR, \'too much\');\n        accountTokens[src] = srcTokensNew;\n        accountTokens[dst] = dstTokensNew;\n        / Eat some of the allowance (if necessary) /\n        if (startingAllowance != uint(- 1)) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n        / We emit a Transfer event /\n        emit Transfer(src, dst, tokens);\n        return true;\n    }\n    /// @notice Transfer amount tokens from msg.sender to dst\n    /// @param dst The address of the destination account\n    /// @param amount The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, msg.sender, dst, amount);\n    }\n    /// @notice Transfer amount tokens from src to dst\n    /// @param src The address of the source account\n    /// @param dst The address of the destination account\n    /// @param amount The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, src, dst, amount);\n    }\n    /// @notice Approve spender to transfer up to amount from src\n    /// @dev This will overwrite the approval amount for spender\n    ///  and is subject to issues noted here\n    /// @param spender The address of the account which may transfer tokens\n    /// @param amount The number of tokens that are approved (-1 means infinite)\n    /// @return Whether or not the approval succeeded\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n    /// @notice Get the current allowance from owner for spender\n    /// @param owner The address of the account which owns the tokens to be spent\n    /// @param spender The address of the account which may transfer tokens\n    /// @return The number of tokens allowed to be spent (-1 means infinite)\n    function allowance(address owner, address spender) external override view returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n    /// @notice Get the token balance of the owner\n    /// @param owner The address of the account to query\n    /// @return The number of tokens owned by owner\n    function balanceOf(address owner) external override view returns (uint256) {\n        return accountTokens[owner];\n    }\n    /// @notice Get the underlying balance of the owner\n    /// @dev This also accrues interest in a transaction\n    /// @param owner The address of the account to query\n    /// @return The amount of underlying owned by owner\n    function balanceOfUnderlying(address owner) external override returns (uint) {\n        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n        require(mErr == MathError.NO_ERROR, "calc failed");\n        return balance;\n    }\n    / User Interface /\n    /// @notice Sender supplies assets into the market and receives lTokens in exchange\n    /// @dev Accrues interest whether or not the operation succeeds, unless reverted\n    /// @param mintAmount The amount of the underlying asset to supply\n    function mint(uint mintAmount) external override nonReentrant {\n        accrueInterest();\n        mintFresh(msg.sender, mintAmount, false);\n    }\n    function mintTo(address to, uint amount) external payable override nonReentrant {\n        accrueInterest();\n        if (isWethPool) {\n            mintFresh(to, msg.value, false);\n        } else {\n            mintFresh(to, amount, true);\n        }\n    }\n    function mintEth() external payable override nonReentrant {\n        require(isWethPool, "not eth pool");\n        accrueInterest();\n        mintFresh(msg.sender, msg.value, false);\n    }\n    /// @notice Sender redeems lTokens in exchange for the underlying asset\n    /// @dev Accrues interest whether or not the operation succeeds, unless reverted\n    /// @param redeemTokens The number of lTokens to redeem into underlying\n    function redeem(uint redeemTokens) external override nonReentrant {\n        accrueInterest();\n        // redeemFresh emits redeem-specific logs on errors, so we don\'t need to\n        redeemFresh(msg.sender, redeemTokens, 0);\n    }\n    /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset\n    /// @dev Accrues interest whether or not the operation succeeds, unless reverted\n    /// @param redeemAmount The amount of underlying to redeem\n    function redeemUnderlying(uint redeemAmount) external override nonReentrant {\n        accrueInterest();\n        // redeemFresh emits redeem-specific logs on errors, so we don\'t need to\n        redeemFresh(msg.sender, 0, redeemAmount);\n    }\n    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {\n        accrueInterest();\n        // borrowFresh emits borrow-specific logs on errors, so we don\'t need to\n        borrowFresh(payable(borrower), msg.sender, borrowAmount);\n    }\n    /// @notice Sender repays a borrow belonging to borrower\n    /// @param borrower the account with the debt being payed off\n    /// @param repayAmount The amount to repay\n    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {\n        accrueInterest();\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don\'t need to\n        repayBorrowFresh(msg.sender, borrower, repayAmount, false);\n    }\n    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {\n        accrueInterest();\n        repayBorrowFresh(msg.sender, borrower, repayAmount, true);\n    }\n\n    / Safe Token /\n    /// Gets balance of this contract in terms of the underlying\n    /// @dev This excludes the value of the current message, if any\n    /// @return The quantity of underlying tokens owned by this contract\n    function getCashPrior() internal view returns (uint) {\n        return IERC20(underlying).balanceOf(address(this));\n    }\n\n    /\n     * @dev Similar to EIP20 transfer, except it handles a False result from transferFrom and reverts in that case.\n     *      This will revert due to insufficient balance or insufficient allowance.\n     *      This function returns the actual amount received,\n     *      which may be less than amount if there is a fee attached to the transfer.\n     \n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     /\n    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {\n        if (isWethPool &amp;&amp; convertWeth) {\n            actualAmount = msg.value;\n            IWETH(underlying).deposit{value : actualAmount}();\n        } else {\n            actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);\n        }\n    }\n    /\n     * @dev Similar to EIP20 transfer, except it handles a False success from transfer and returns an explanatory\n     *      error code rather than reverting. If caller has not called checked protocol\'s balance, this may revert due to\n     *      insufficient cash held in this contract. If caller has checked protocol\'s balance prior to this call, and verified\n     *      it is &gt;= amount, this should not revert in normal conditions.\n     \n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     /\n    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {\n        if (isWethPool &amp;&amp; convertWeth) {\n            IWETH(underlying).withdraw(amount);\n            to.transfer(amount);\n        } else {\n            IERC20(underlying).safeTransfer(to, amount);\n        }\n    }\n    function availableForBorrow() external view override returns (uint){\n        uint cash = getCashPrior();\n        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);\n        if (err0 != MathError.NO_ERROR) {\n            return 0;\n        }\n        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);\n        if (err1 != MathError.NO_ERROR) {\n            return 0;\n        }\n        if (totalBorrows &gt; maxAvailable) {\n            return 0;\n        }\n        return maxAvailable - totalBorrows;\n    }\n\n    /// @notice Get a snapshot of the account\'s balances, and the cached exchange rate\n    /// @dev This is used by controller to more efficiently perform liquidity checks.\n    /// @param account Address of the account to snapshot\n    /// @return ( token balance, borrow balance, exchange rate mantissa)\n    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {\n        uint cTokenBalance = accountTokens[account];\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n        MathError mErr;\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n        if (mErr != MathError.NO_ERROR) {\n            return (0, 0, 0);\n        }\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (mErr != MathError.NO_ERROR) {\n            return (0, 0, 0);\n        }\n        return (cTokenBalance, borrowBalance, exchangeRateMantissa);\n    }\n    /// @dev Function to simply retrieve block number\n    ///  This exists mainly for inheriting test contracts to stub this result.\n    function getBlockNumber() internal view returns (uint) {\n        return block.number;\n    }\n    /// @notice Returns the current per-block borrow interest rate for this cToken\n    /// @return The borrow interest rate per block, scaled by 1e18\n    function borrowRatePerBlock() external override view returns (uint) {\n        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);\n    }\n    \n    /// @notice Returns the current per-block supply interest rate for this cToken\n    /// @return The supply interest rate per block, scaled by 1e18\n    function supplyRatePerBlock() external override view returns (uint) {\n        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\n    }\n    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {\n        // Utilization rate is 0 when there are no borrows\n        if (borrows == 0) {\n            return 0;\n        }\n        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));\n    }\n    /// @notice Calculates the current borrow rate per block, with the error code expected by the market\n    /// @param cash The amount of cash in the market\n    /// @param borrows The amount of borrows in the market\n    /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\n    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {\n        uint util = utilizationRate(cash, borrows, reserves);\n        if (util &lt;= kink) {\n            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n        } else {\n            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n            uint excessUtil = util.sub(kink);\n            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);\n        }\n    }\n    /// @notice Calculates the current supply rate per block\n    /// @param cash The amount of cash in the market\n    /// @param borrows The amount of borrows in the market\n    /// @return The supply rate percentage per block as a mantissa (scaled by 1e18)\n    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {\n        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);\n        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);\n        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\n        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\n    }\n    /// @notice Returns the current total borrows plus accrued interest\n    /// @return The total borrows with interest\n    function totalBorrowsCurrent() external override view returns (uint) {\n        / Remember the initial block number /\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n        / Short-circuit accumulating 0 interest /\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return totalBorrows;\n        }\n        / Read the previous values out of storage /\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint reservesPrior = totalReserves;\n        / Calculate the current borrow interest rate /\n        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");\n        / Calculate the number of blocks elapsed since the last accrual /\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        require(mathErr == MathError.NO_ERROR, "calc block delta erro");\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        require(mathErr == MathError.NO_ERROR, \'calc interest factor error\');\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc interest acc error\');\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc total borrows error\');\n        return totalBorrowsNew;\n    }\n    /// @notice Accrue interest to updated borrowIndex and then calculate account\'s borrow balance using the updated borrowIndex\n    /// @param account The address whose balance should be calculated after updating borrowIndex\n    /// @return The calculated balance\n    function borrowBalanceCurrent(address account) external view override returns (uint) {\n        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();\n        require(err0 == MathError.NO_ERROR, "calc borrow index fail");\n        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);\n        require(err1 == MathError.NO_ERROR, "calc fail");\n        return result;\n    }\n    function borrowBalanceStored(address account) external override view returns (uint){\n        return accountBorrows[account].principal;\n    }\n\n    /// @notice Return the borrow balance of account based on stored data\n    /// @param account The address whose balance should be calculated\n    /// @return (error code, the calculated balance or 0 if error code is non-zero)\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);\n    }\n    /// @notice Return the borrow balance of account based on stored data\n    /// @param account The address whose balance should be calculated\n    /// @return (error code, the calculated balance or 0 if error code is non-zero)\n    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {\n        / Note: we do not assert that the market is up to date /\n        MathError mathErr;\n        uint principalTimesIndex;\n        uint result;\n        / Get borrowBalance and borrowIndex /\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n        / If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         /\n        if (borrowSnapshot.principal == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n        / Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         /\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n        return (MathError.NO_ERROR, result);\n    }\n    /// @notice Accrue interest then return the up-to-date exchange rate\n    /// @return Calculated exchange rate scaled by 1e18\n    function exchangeRateCurrent() public override nonReentrant returns (uint) {\n        accrueInterest();\n        return exchangeRateStored();\n    }\n    /// Calculates the exchange rate from the underlying to the LToken\n    /// @dev This function does not accrue interest before calculating the exchange rate\n    /// @return Calculated exchange rate scaled by 1e18\n    function exchangeRateStored() public override view returns (uint) {\n        (MathError err, uint result) = exchangeRateStoredInternal();\n        require(err == MathError.NO_ERROR, "calc fail");\n        return result;\n    }\n    /// @notice Calculates the exchange rate from the underlying to the LToken\n    /// @dev This function does not accrue interest before calculating the exchange rate\n    /// @return (error code, calculated exchange rate scaled by 1e18)\n    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n        uint _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            /\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             /\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\n        } else {\n            /\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             /\n            uint _totalCash = getCashPrior();\n            uint cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n            MathError mathErr;\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\n        }\n    }\n    /// @notice Get cash balance of this cToken in the underlying asset\n    /// @return The quantity of underlying asset owned by this contract\n    function getCash() external override view returns (uint) {\n        return IERC20(underlying).balanceOf(address(this));\n    }\n    function calCurrentBorrowIndex() internal view returns (MathError, uint) {\n        / Remember the initial block number /\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n        uint borrowIndexNew;\n        / Short-circuit accumulating 0 interest /\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return (MathError.NO_ERROR, borrowIndex);\n        }\n        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        Exp memory simpleInterestFactor;\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);\n        return (mathErr, borrowIndexNew);\n    }\n    /// @notice Applies accrued interest to total borrows and reserves\n    /// @dev This calculates interest accrued from the last checkpointed block\n    ///   up to the current block and writes new checkpoint to storage.\n    function accrueInterest() public override {\n        / Remember the initial block number /\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n        / Short-circuit accumulating 0 interest /\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return;\n        }\n        / Read the previous values out of storage /\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint borrowIndexPrior = borrowIndex;\n        uint reservesPrior = totalReserves;\n        / Calculate the current borrow interest rate /\n        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");\n        / Calculate the number of blocks elapsed since the last accrual /\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        require(mathErr == MathError.NO_ERROR, "calc block delta erro");\n\n        /\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         /\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n        uint borrowIndexNew;\n        uint totalReservesNew;\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        require(mathErr == MathError.NO_ERROR, \'calc interest factor error\');\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc interest acc error\');\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc total borrows error\');\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc total reserves error\');\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc borrows index error\');\n\n        / We write the previously calculated values into storage /\n        accrualBlockNumber = currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n        totalReserves = totalReservesNew;\n        / We emit an AccrueInterest event /\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n    }\n    struct MintLocalVars {\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint mintTokens;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n        uint actualMintAmount;\n    }\n    /// @notice User supplies assets into the market and receives lTokens in exchange\n    /// @dev Assumes interest has already been accrued up to the current block\n    /// @param minter The address of the account which is supplying the assets\n    /// @param mintAmount The amount of the underlying asset to supply\n    /// @return uint the actual mint amount.\n    function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {\n        MintLocalVars memory vars;\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, \'calc exchangerate error\');\n        /\n         *  We call doTransferIn for the minter and the mintAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  doTransferIn reverts if anything goes wrong, since we can\'t be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the cToken holds an additional actualMintAmount\n         *  of cash.\n         /\n        if (isDelegete) {\n            uint balanceBefore = getCashPrior();\n            LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);\n            uint balanceAfter = getCashPrior();\n            require(balanceAfter &gt; balanceBefore, \'mint 0\');\n            vars.actualMintAmount = balanceAfter - balanceBefore;\n        } else {\n            vars.actualMintAmount = doTransferIn(minter, mintAmount, true);\n        }\n        /\n         * We get the current exchange rate and calculate the number of lTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         /\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));\n        require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");\n        / Fail if mint not allowed /\n        (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);\n        /\n         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         /\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n        require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n        require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");\n        / We write previously calculated values into storage /\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[minter] = vars.accountTokensNew;\n        / We emit a Mint event, and a Transfer event /\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n        emit Transfer(address(this), minter, vars.mintTokens);\n        / We call the defense hook /\n        return vars.actualMintAmount;\n    }\n\n    struct RedeemLocalVars {\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint redeemTokens;\n        uint redeemAmount;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n    }\n    /// @notice User redeems lTokens in exchange for the underlying asset\n    /// @dev Assumes interest has already been accrued up to the current block\n    /// @param redeemer The address of the account which is redeeming the tokens\n    /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n    /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");\n        RedeemLocalVars memory vars;\n        / exchangeRate = invoke Exchange Rate Stored() /\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, \'calc exchangerate error\');\n        / If redeemTokensIn &gt; 0: /\n        if (redeemTokensIn &gt; 0) {\n            /\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             /\n            vars.redeemTokens = redeemTokensIn;\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);\n            require(vars.mathErr == MathError.NO_ERROR, \'calc redeem amount error\');\n        } else {\n            /\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             /\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));\n            require(vars.mathErr == MathError.NO_ERROR, \'calc redeem tokens error\');\n            vars.redeemAmount = redeemAmountIn;\n        }\n        / Fail if redeem not allowed /\n        (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);\n        /\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n         *  totalSupplyNew = totalSupply - redeemTokens\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n         /\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n        require(vars.mathErr == MathError.NO_ERROR, \'calc supply new error\');\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n        require(vars.mathErr == MathError.NO_ERROR, \'calc token new error\');\n        require(getCashPrior() &gt;= vars.redeemAmount, \'cash &lt; redeem\');\n        / We write previously calculated values into storage /\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[redeemer] = vars.accountTokensNew;\n        /\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken has redeemAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can\'t be sure if side effects occurred.\n         /\n        doTransferOut(redeemer, vars.redeemAmount, true);\n\n        / We emit a Transfer event, and a Redeem event /\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n        / We call the defense hook /\n    }\n    struct BorrowLocalVars {\n        MathError mathErr;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n    }\n    /// @notice Users borrow assets from the protocol to their own address\n    /// @param borrowAmount The amount of the underlying asset to borrow\n    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {\n        / Fail if borrow not allowed /\n        (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);\n        / Fail gracefully if protocol has insufficient underlying cash /\n        require(getCashPrior() &gt;= borrowAmount, \'cash vars.actualRepayAmount) {\n            vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;\n        }\n        /\n        *  We calculate the new borrower and total borrow balances, failing on underflow:\n        *  accountBorrowsNew = accountBorrows - repayAmount\n        *  totalBorrowsNew = totalBorrows - repayAmount\n        /\n        if (vars.accountBorrows &lt; vars.actualRepayAmount) {\n            require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) &lt;= 105e16, \'repay more than 5%\');\n            vars.accountBorrowsNew = 0;\n        } else {\n            if (isEnd) {\n                vars.accountBorrowsNew = 0;\n            } else {\n                vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;\n            }\n        }\n        //Avoid mantissa errors\n        if (vars.actualRepayAmount &gt; totalBorrows) {\n            vars.totalBorrowsNew = 0;\n        } else {\n            if (isEnd) {\n                vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);\n            } else {\n                vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;\n            }\n        }\n        / We write the previously calculated values into storage /\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n        / We emit a RepayBorrow event /\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n        / We call the defense hook */\n        return vars.actualRepayAmount;\n    }\n    / Admin Functions /\n    /// @notice Sets a new CONTROLLER for the market\n    /// @dev Admin function to set a new controller\n    function setController(address newController) external override onlyAdmin {\n        require(address(0) != newController, "0x");\n        address oldController = controller;\n        controller = newController;\n        // Emit NewController(oldController, newController)\n        emit NewController(oldController, newController);\n    }\n    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {\n        require(newBorrowCapFactorMantissa &lt;= 1e18, \'Factor too large\');\n        uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;\n        borrowCapFactorMantissa = newBorrowCapFactorMantissa;\n        emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa);\n    }\n    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {\n        //accrueInterest except first\n        if (baseRatePerBlock != 0) {\n            accrueInterest();\n        }\n        // total rate perYear &lt; 2000%\n        require(baseRatePerBlock_ &lt; 1e13, \'Base rate too large\');\n        baseRatePerBlock = baseRatePerBlock_;\n        require(multiplierPerBlock_ &lt; 1e13, \'Mul rate too large\');\n        multiplierPerBlock = multiplierPerBlock_;\n        require(jumpMultiplierPerBlock_ &lt; 1e13, \'Jump rate too large\');\n        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;\n        require(kink_ &lt;= 1e18, \'Kline too large\');\n        kink = kink_;\n        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);\n    }\n    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {\n        require(newReserveFactorMantissa &lt;= 1e18, \'Factor too large\');\n        accrueInterest();\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n        reserveFactorMantissa = newReserveFactorMantissa;\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n    }\n    function addReserves(uint addAmount) external override nonReentrant {\n        accrueInterest();\n        uint totalReservesNew;\n        uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);\n        totalReservesNew = totalReserves.add(actualAddAmount);\n        totalReserves = totalReservesNew;\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n    }\n    function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {\n        accrueInterest();\n        uint totalReservesNew;\n        totalReservesNew = totalReserves.sub(reduceAmount);\n        totalReserves = totalReservesNew;\n        doTransferOut(to, reduceAmount, true);\n        emit ReservesReduced(to, reduceAmount, totalReservesNew);\n    }\n    modifier sameBlock() {\n        require(accrualBlockNumber == getBlockNumber(), \'not same block\');\n        ;\n    }\n}\n.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.7.6;\n\nimport "./LPoolInterface.sol";\nimport "./LPoolDepositor.sol";\nimport "../lib/Exponential.sol";\nimport "../Adminable.sol";\nimport "../lib/CarefulMath.sol";\nimport "../lib/TransferHelper.sol";\nimport "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\nimport "../DelegateInterface.sol";\nimport "../ControllerInterface.sol";\nimport "../IWETH.sol";\n/// @title OpenLeverage\'s LToken Contract\n/// @dev Abstract base for LTokens\n/// @author OpenLeverage\ncontract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {\n    using TransferHelper for IERC20;\n    using SafeMath for uint;\n    constructor() {\n    }\n    \n    /// @notice Initialize the money market\n    /// @param controller The address of the Controller\n    /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0\n    /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate\n    /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point\n    /// @param kink_ The utilization point at which the jump multiplier is applied\n    /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n    /// @param name_ EIP-20 name of this token\n    /// @param symbol_ EIP-20 symbol of this token\n    /// @param decimals_ EIP-20 decimal precision of this token\n    function initialize(\n        address underlying_,\n        bool isWethPool_,\n        address controller_,\n        uint256 baseRatePerBlock_,\n        uint256 multiplierPerBlock_,\n        uint256 jumpMultiplierPerBlock_,\n        uint256 kink_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_) public {\n        require(underlying_ != address(0), "underlying_ address cannot be 0");\n        require(controller_ != address(0), "controller_ address cannot be 0");\n        require(msg.sender == admin, "Only allow to be called by admin");\n        require(accrualBlockNumber == 0 &amp;&amp; borrowIndex == 0, "inited once");\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa &gt; 0, "Initial Exchange Rate Mantissa should be greater zero");\n        //set controller\n        controller = controller_;\n        isWethPool = isWethPool_;\n        //set interestRateModel\n        baseRatePerBlock = baseRatePerBlock_;\n        multiplierPerBlock = multiplierPerBlock_;\n        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;\n        kink = kink_;\n        // Initialize block number and borrow index (block number mocks depend on controller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = 1e25;\n        //80%\n        borrowCapFactorMantissa = 0.8e18;\n        //10%\n        reserveFactorMantissa = 0.1e18;\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n        notEntered = true;\n        // Set underlying and sanity check it\n        underlying = underlying;\n        IERC20(underlying).totalSupply();\n        emit Transfer(address(0), msg.sender, 0);\n    }\n    /// @notice Transfer tokens tokens from src to dst by spender\n    /// @dev Called by both transfer and transferFrom internally\n    /// @param spender The address of the account performing the transfer\n    /// @param src The address of the source account\n    /// @param dst The address of the destination account\n    /// @param tokens The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {\n        require(dst != address(0), "dst address cannot be 0");\n        / Do not allow self-transfers /\n        require(src != dst, "src = dst");\n        / Fail if transfer not allowed /\n        (ControllerInterface(controller)).transferAllowed(src, dst, tokens);\n        / Get the allowance, infinite for the account owner /\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = uint(- 1);\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n        / Do the calculations, checking for {under,over}flow /\n        MathError mathErr;\n        uint allowanceNew;\n        uint srcTokensNew;\n        uint dstTokensNew;\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n        require(mathErr == MathError.NO_ERROR, \'not allowed\');\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n        require(mathErr == MathError.NO_ERROR, \'not enough\');\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n        require(mathErr == MathError.NO_ERROR, \'too much\');\n        accountTokens[src] = srcTokensNew;\n        accountTokens[dst] = dstTokensNew;\n        / Eat some of the allowance (if necessary) /\n        if (startingAllowance != uint(- 1)) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n        / We emit a Transfer event */\n        emit Transfer(src, dst, tokens);\n        return true;\n    }\n    /// @notice Transfer amount tokens from msg.sender to dst\n    /// @param dst The address of the destination account\n    /// @param amount The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, msg.sender, dst, amount);\n    }\n    /// @notice Transfer amount tokens from src to dst\n    /// @param src The address of the source account\n    /// @param dst The address of the destination account\n    /// @param amount The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, src, dst, amount);\n    }\n    /// @notice Approve spender to transfer up to amount from src\n    /// @dev This will overwrite the approval amount for spender\n    ///  and is subject to issues noted here\n    /// @param spender The address of the account which may transfer tokens\n    /// @param amount The number of tokens that are approved (-1 means infinite)\n    /// @return Whether or not the approval succeeded\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n    /// @notice Get the current allowance from owner for spender\n    /// @param owner The address of the account which owns the tokens to be spent\n    /// @param spender The address of the account which may transfer tokens\n    /// @return The number of tokens allowed to be spent (-1 means infinite)\n    function allowance(address owner, address spender) external override view returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n    /// @notice Get the token balance of the owner\n    /// @param owner The address of the account to query\n    /// @return The number of tokens owned by owner\n    function balanceOf(address owner) external override view returns (uint256) {\n        return accountTokens[owner];\n    }\n    /// @notice Get the underlying balance of the owner\n    /// @dev This also accrues interest in a transaction\n    /// @param owner The address of the account to query\n    /// @return The amount of underlying owned by owner\n    function balanceOfUnderlying(address owner) external override returns (uint) {\n        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n        require(mErr == MathError.NO_ERROR, "calc failed");\n        return balance;\n    }\n    / User Interface /\n    /// @notice Sender supplies assets into the market and receives lTokens in exchange\n    /// @dev Accrues interest whether or not the operation succeeds, unless reverted\n    /// @param mintAmount The amount of the underlying asset to supply\n    function mint(uint mintAmount) external override nonReentrant {\n        accrueInterest();\n        mintFresh(msg.sender, mintAmount, false);\n    }\n    function mintTo(address to, uint amount) external payable override nonReentrant {\n        accrueInterest();\n        if (isWethPool) {\n            mintFresh(to, msg.value, false);\n        } else {\n            mintFresh(to, amount, true);\n        }\n    }\n    function mintEth() external payable override nonReentrant {\n        require(isWethPool, "not eth pool");\n        accrueInterest();\n        mintFresh(msg.sender, msg.value, false);\n    }\n    /// @notice Sender redeems lTokens in exchange for the underlying asset\n    /// @dev Accrues interest whether or not the operation succeeds, unless reverted\n    /// @param redeemTokens The number of lTokens to redeem into underlying\n    function redeem(uint redeemTokens) external override nonReentrant {\n        accrueInterest();\n        // redeemFresh emits redeem-specific logs on errors, so we don\'t need to\n        redeemFresh(msg.sender, redeemTokens, 0);\n    }\n    /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset\n    /// @dev Accrues interest whether or not the operation succeeds, unless reverted\n    /// @param redeemAmount The amount of underlying to redeem\n    function redeemUnderlying(uint redeemAmount) external override nonReentrant {\n        accrueInterest();\n        // redeemFresh emits redeem-specific logs on errors, so we don\'t need to\n        redeemFresh(msg.sender, 0, redeemAmount);\n    }\n    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {\n        accrueInterest();\n        // borrowFresh emits borrow-specific logs on errors, so we don\'t need to\n        borrowFresh(payable(borrower), msg.sender, borrowAmount);\n    }\n    /// @notice Sender repays a borrow belonging to borrower\n    /// @param borrower the account with the debt being payed off\n    /// @param repayAmount The amount to repay\n    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {\n        accrueInterest();\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don\'t need to\n        repayBorrowFresh(msg.sender, borrower, repayAmount, false);\n    }\n    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {\n        accrueInterest();\n        repayBorrowFresh(msg.sender, borrower, repayAmount, true);\n    }\n\n    / Safe Token /\n    /// Gets balance of this contract in terms of the underlying\n    /// @dev This excludes the value of the current message, if any\n    /// @return The quantity of underlying tokens owned by this contract\n    function getCashPrior() internal view returns (uint) {\n        return IERC20(underlying).balanceOf(address(this));\n    }\n\n    /\n     * @dev Similar to EIP20 transfer, except it handles a False result from transferFrom and reverts in that case.\n     *      This will revert due to insufficient balance or insufficient allowance.\n     *      This function returns the actual amount received,\n     *      which may be less than amount if there is a fee attached to the transfer.\n     \n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     /\n    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {\n        if (isWethPool &amp;&amp; convertWeth) {\n            actualAmount = msg.value;\n            IWETH(underlying).deposit{value : actualAmount}();\n        } else {\n            actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);\n        }\n    }\n    /\n     * @dev Similar to EIP20 transfer, except it handles a False success from transfer and returns an explanatory\n     *      error code rather than reverting. If caller has not called checked protocol\'s balance, this may revert due to\n     *      insufficient cash held in this contract. If caller has checked protocol\'s balance prior to this call, and verified\n     *      it is &gt;= amount, this should not revert in normal conditions.\n     \n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     /\n    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {\n        if (isWethPool &amp;&amp; convertWeth) {\n            IWETH(underlying).withdraw(amount);\n            to.transfer(amount);\n        } else {\n            IERC20(underlying).safeTransfer(to, amount);\n        }\n    }\n    function availableForBorrow() external view override returns (uint){\n        uint cash = getCashPrior();\n        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);\n        if (err0 != MathError.NO_ERROR) {\n            return 0;\n        }\n        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);\n        if (err1 != MathError.NO_ERROR) {\n            return 0;\n        }\n        if (totalBorrows &gt; maxAvailable) {\n            return 0;\n        }\n        return maxAvailable - totalBorrows;\n    }\n\n    /// @notice Get a snapshot of the account\'s balances, and the cached exchange rate\n    /// @dev This is used by controller to more efficiently perform liquidity checks.\n    /// @param account Address of the account to snapshot\n    /// @return ( token balance, borrow balance, exchange rate mantissa)\n    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {\n        uint cTokenBalance = accountTokens[account];\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n        MathError mErr;\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n        if (mErr != MathError.NO_ERROR) {\n            return (0, 0, 0);\n        }\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (mErr != MathError.NO_ERROR) {\n            return (0, 0, 0);\n        }\n        return (cTokenBalance, borrowBalance, exchangeRateMantissa);\n    }\n    /// @dev Function to simply retrieve block number\n    ///  This exists mainly for inheriting test contracts to stub this result.\n    function getBlockNumber() internal view returns (uint) {\n        return block.number;\n    }\n    /// @notice Returns the current per-block borrow interest rate for this cToken\n    /// @return The borrow interest rate per block, scaled by 1e18\n    function borrowRatePerBlock() external override view returns (uint) {\n        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);\n    }\n    \n    /// @notice Returns the current per-block supply interest rate for this cToken\n    /// @return The supply interest rate per block, scaled by 1e18\n    function supplyRatePerBlock() external override view returns (uint) {\n        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\n    }\n    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {\n        // Utilization rate is 0 when there are no borrows\n        if (borrows == 0) {\n            return 0;\n        }\n        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));\n    }\n    /// @notice Calculates the current borrow rate per block, with the error code expected by the market\n    /// @param cash The amount of cash in the market\n    /// @param borrows The amount of borrows in the market\n    /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\n    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {\n        uint util = utilizationRate(cash, borrows, reserves);\n        if (util &lt;= kink) {\n            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n        } else {\n            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n            uint excessUtil = util.sub(kink);\n            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);\n        }\n    }\n    /// @notice Calculates the current supply rate per block\n    /// @param cash The amount of cash in the market\n    /// @param borrows The amount of borrows in the market\n    /// @return The supply rate percentage per block as a mantissa (scaled by 1e18)\n    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {\n        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);\n        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);\n        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\n        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\n    }\n    /// @notice Returns the current total borrows plus accrued interest\n    /// @return The total borrows with interest\n    function totalBorrowsCurrent() external override view returns (uint) {\n        / Remember the initial block number /\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n        / Short-circuit accumulating 0 interest /\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return totalBorrows;\n        }\n        / Read the previous values out of storage /\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint reservesPrior = totalReserves;\n        / Calculate the current borrow interest rate /\n        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");\n        / Calculate the number of blocks elapsed since the last accrual /\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        require(mathErr == MathError.NO_ERROR, "calc block delta erro");\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        require(mathErr == MathError.NO_ERROR, \'calc interest factor error\');\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc interest acc error\');\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc total borrows error\');\n        return totalBorrowsNew;\n    }\n    /// @notice Accrue interest to updated borrowIndex and then calculate account\'s borrow balance using the updated borrowIndex\n    /// @param account The address whose balance should be calculated after updating borrowIndex\n    /// @return The calculated balance\n    function borrowBalanceCurrent(address account) external view override returns (uint) {\n        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();\n        require(err0 == MathError.NO_ERROR, "calc borrow index fail");\n        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);\n        require(err1 == MathError.NO_ERROR, "calc fail");\n        return result;\n    }\n    function borrowBalanceStored(address account) external override view returns (uint){\n        return accountBorrows[account].principal;\n    }\n\n    /// @notice Return the borrow balance of account based on stored data\n    /// @param account The address whose balance should be calculated\n    /// @return (error code, the calculated balance or 0 if error code is non-zero)\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);\n    }\n    /// @notice Return the borrow balance of account based on stored data\n    /// @param account The address whose balance should be calculated\n    /// @return (error code, the calculated balance or 0 if error code is non-zero)\n    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {\n        / Note: we do not assert that the market is up to date /\n        MathError mathErr;\n        uint principalTimesIndex;\n        uint result;\n        / Get borrowBalance and borrowIndex /\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n        / If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         /\n        if (borrowSnapshot.principal == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n        / Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         /\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n        return (MathError.NO_ERROR, result);\n    }\n    /// @notice Accrue interest then return the up-to-date exchange rate\n    /// @return Calculated exchange rate scaled by 1e18\n    function exchangeRateCurrent() public override nonReentrant returns (uint) {\n        accrueInterest();\n        return exchangeRateStored();\n    }\n    /// Calculates the exchange rate from the underlying to the LToken\n    /// @dev This function does not accrue interest before calculating the exchange rate\n    /// @return Calculated exchange rate scaled by 1e18\n    function exchangeRateStored() public override view returns (uint) {\n        (MathError err, uint result) = exchangeRateStoredInternal();\n        require(err == MathError.NO_ERROR, "calc fail");\n        return result;\n    }\n    /// @notice Calculates the exchange rate from the underlying to the LToken\n    /// @dev This function does not accrue interest before calculating the exchange rate\n    /// @return (error code, calculated exchange rate scaled by 1e18)\n    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n        uint _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            /\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             /\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\n        } else {\n            /\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             /\n            uint _totalCash = getCashPrior();\n            uint cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n            MathError mathErr;\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\n        }\n    }\n    /// @notice Get cash balance of this cToken in the underlying asset\n    /// @return The quantity of underlying asset owned by this contract\n    function getCash() external override view returns (uint) {\n        return IERC20(underlying).balanceOf(address(this));\n    }\n    function calCurrentBorrowIndex() internal view returns (MathError, uint) {\n        / Remember the initial block number /\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n        uint borrowIndexNew;\n        / Short-circuit accumulating 0 interest /\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return (MathError.NO_ERROR, borrowIndex);\n        }\n        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        Exp memory simpleInterestFactor;\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);\n        return (mathErr, borrowIndexNew);\n    }\n    /// @notice Applies accrued interest to total borrows and reserves\n    /// @dev This calculates interest accrued from the last checkpointed block\n    ///   up to the current block and writes new checkpoint to storage.\n    function accrueInterest() public override {\n        / Remember the initial block number /\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n        / Short-circuit accumulating 0 interest /\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return;\n        }\n        / Read the previous values out of storage /\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint borrowIndexPrior = borrowIndex;\n        uint reservesPrior = totalReserves;\n        / Calculate the current borrow interest rate /\n        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");\n        / Calculate the number of blocks elapsed since the last accrual /\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        require(mathErr == MathError.NO_ERROR, "calc block delta erro");\n\n        /\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         /\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n        uint borrowIndexNew;\n        uint totalReservesNew;\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        require(mathErr == MathError.NO_ERROR, \'calc interest factor error\');\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc interest acc error\');\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc total borrows error\');\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc total reserves error\');\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc borrows index error\');\n\n        / We write the previously calculated values into storage /\n        accrualBlockNumber = currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n        totalReserves = totalReservesNew;\n        / We emit an AccrueInterest event /\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n    }\n    struct MintLocalVars {\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint mintTokens;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n        uint actualMintAmount;\n    }\n    /// @notice User supplies assets into the market and receives lTokens in exchange\n    /// @dev Assumes interest has already been accrued up to the current block\n    /// @param minter The address of the account which is supplying the assets\n    /// @param mintAmount The amount of the underlying asset to supply\n    /// @return uint the actual mint amount.\n    function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {\n        MintLocalVars memory vars;\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, \'calc exchangerate error\');\n        /\n         *  We call doTransferIn for the minter and the mintAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  doTransferIn reverts if anything goes wrong, since we can\'t be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the cToken holds an additional actualMintAmount\n         *  of cash.\n         /\n        if (isDelegete) {\n            uint balanceBefore = getCashPrior();\n            LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);\n            uint balanceAfter = getCashPrior();\n            require(balanceAfter &gt; balanceBefore, \'mint 0\');\n            vars.actualMintAmount = balanceAfter - balanceBefore;\n        } else {\n            vars.actualMintAmount = doTransferIn(minter, mintAmount, true);\n        }\n        /\n         * We get the current exchange rate and calculate the number of lTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         /\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));\n        require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");\n        / Fail if mint not allowed /\n        (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);\n        /\n         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         /\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n        require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n        require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");\n        / We write previously calculated values into storage /\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[minter] = vars.accountTokensNew;\n        / We emit a Mint event, and a Transfer event /\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n        emit Transfer(address(this), minter, vars.mintTokens);\n        / We call the defense hook /\n        return vars.actualMintAmount;\n    }\n\n    struct RedeemLocalVars {\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint redeemTokens;\n        uint redeemAmount;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n    }\n    /// @notice User redeems lTokens in exchange for the underlying asset\n    /// @dev Assumes interest has already been accrued up to the current block\n    /// @param redeemer The address of the account which is redeeming the tokens\n    /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n    /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");\n        RedeemLocalVars memory vars;\n        / exchangeRate = invoke Exchange Rate Stored() /\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, \'calc exchangerate error\');\n        / If redeemTokensIn &gt; 0: /\n        if (redeemTokensIn &gt; 0) {\n            /\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             /\n            vars.redeemTokens = redeemTokensIn;\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);\n            require(vars.mathErr == MathError.NO_ERROR, \'calc redeem amount error\');\n        } else {\n            /\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             /\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));\n            require(vars.mathErr == MathError.NO_ERROR, \'calc redeem tokens error\');\n            vars.redeemAmount = redeemAmountIn;\n        }\n        / Fail if redeem not allowed /\n        (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);\n        /\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n         *  totalSupplyNew = totalSupply - redeemTokens\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n         /\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n        require(vars.mathErr == MathError.NO_ERROR, \'calc supply new error\');\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n        require(vars.mathErr == MathError.NO_ERROR, \'calc token new error\');\n        require(getCashPrior() &gt;= vars.redeemAmount, \'cash &lt; redeem\');\n        / We write previously calculated values into storage /\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[redeemer] = vars.accountTokensNew;\n        /\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken has redeemAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can\'t be sure if side effects occurred.\n         /\n        doTransferOut(redeemer, vars.redeemAmount, true);\n\n        / We emit a Transfer event, and a Redeem event /\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n        / We call the defense hook /\n    }\n    struct BorrowLocalVars {\n        MathError mathErr;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n    }\n    /// @notice Users borrow assets from the protocol to their own address\n    /// @param borrowAmount The amount of the underlying asset to borrow\n    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {\n        / Fail if borrow not allowed /\n        (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);\n        / Fail gracefully if protocol has insufficient underlying cash /\n        require(getCashPrior() &gt;= borrowAmount, \'cash vars.actualRepayAmount) {\n            vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;\n        }\n        /\n        *  We calculate the new borrower and total borrow balances, failing on underflow:\n        *  accountBorrowsNew = accountBorrows - repayAmount\n        *  totalBorrowsNew = totalBorrows - repayAmount\n        /\n        if (vars.accountBorrows &lt; vars.actualRepayAmount) {\n            require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) &lt;= 105e16, \'repay more than 5%\');\n            vars.accountBorrowsNew = 0;\n        } else {\n            if (isEnd) {\n                vars.accountBorrowsNew = 0;\n            } else {\n                vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;\n            }\n        }\n        //Avoid mantissa errors\n        if (vars.actualRepayAmount &gt; totalBorrows) {\n            vars.totalBorrowsNew = 0;\n        } else {\n            if (isEnd) {\n                vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);\n            } else {\n                vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;\n            }\n        }\n        / We write the previously calculated values into storage /\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n        / We emit a RepayBorrow event /\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n        / We call the defense hook */\n        return vars.actualRepayAmount;\n    }\n    / Admin Functions ***/\n    /// @notice Sets a new CONTROLLER for the market\n    /// @dev Admin function to set a new controller\n    function setController(address newController) external override onlyAdmin {\n        require(address(0) != newController, "0x");\n        address oldController = controller;\n        controller = newController;\n        // Emit NewController(oldController, newController)\n        emit NewController(oldController, newController);\n    }\n    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {\n        require(newBorrowCapFactorMantissa &lt;= 1e18, \'Factor too large\');\n        uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;\n        borrowCapFactorMantissa = newBorrowCapFactorMantissa;\n        emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa);\n    }\n    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {\n        //accrueInterest except first\n        if (baseRatePerBlock != 0) {\n            accrueInterest();\n        }\n        // total rate perYear &lt; 2000%\n        require(baseRatePerBlock_ &lt; 1e13, \'Base rate too large\');\n        baseRatePerBlock = baseRatePerBlock_;\n        require(multiplierPerBlock_ &lt; 1e13, \'Mul rate too large\');\n        multiplierPerBlock = multiplierPerBlock_;\n        require(jumpMultiplierPerBlock_ &lt; 1e13, \'Jump rate too large\');\n        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;\n        require(kink_ &lt;= 1e18, \'Kline too large\');\n        kink = kink_;\n        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);\n    }\n    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {\n        require(newReserveFactorMantissa &lt;= 1e18, \'Factor too large\');\n        accrueInterest();\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n        reserveFactorMantissa = newReserveFactorMantissa;\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n    }\n    function addReserves(uint addAmount) external override nonReentrant {\n        accrueInterest();\n        uint totalReservesNew;\n        uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);\n        totalReservesNew = totalReserves.add(actualAddAmount);\n        totalReserves = totalReservesNew;\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n    }\n    function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {\n        accrueInterest();\n        uint totalReservesNew;\n        totalReservesNew = totalReserves.sub(reduceAmount);\n        totalReserves = totalReservesNew;\n        doTransferOut(to, reduceAmount, true);\n        emit ReservesReduced(to, reduceAmount, totalReservesNew);\n    }\n    modifier sameBlock() {\n        require(accrualBlockNumber == getBlockNumber(), \'not same block\');\n        _;\n    }\n}\n".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Let\'s', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-24-08 19:27:58 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.7.6; import "./LPoolInterface.sol"; import "./LPoolDepositor.sol"; import "../lib/Exponential.sol"; import "../Adminable.sol"; import "../lib/CarefulMath.sol"; import "../lib/TransferHelper.sol"; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import "../DelegateInterface.sol"; import "../ControllerInterface.sol"; import "../IWETH.sol"; /// @title OpenLeverage's LToken Contract /// @dev Abstract base for LTokens /// @author OpenLeverage contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {     using TransferHelper for IERC20;     using SafeMath for uint; constructor() {  }  /// @notice Initialize the money market /// @param controller_ The address of the Controller /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0 /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point /// @param kink_ The utilization point at which the jump multiplier is applied /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18 /// @param name_ EIP-20 name of this token /// @param symbol_ EIP-20 symbol of this token /// @param decimals_ EIP-20 decimal precision of this token function initialize(     address underlying_,     bool isWethPool_,     address controller_,     uint256 baseRatePerBlock_,     uint256 multiplierPerBlock_,     uint256 jumpMultiplierPerBlock_,     uint256 kink_,     uint initialExchangeRateMantissa_,     string memory name_,     string memory symbol_,     uint8 decimals_) public {     require(underlying_ != address(0), "underlying_ address cannot be 0");     require(controller_ != address(0), "controller_ address cannot be 0");     require(msg.sender == admin, "Only allow to be called by admin");     require(accrualBlockNumber == 0 &amp;&amp; borrowIndex == 0, "inited once");      // Set initial exchange rate     initialExchangeRateMantissa = initialExchangeRateMantissa_;     require(initialExchangeRateMantissa &gt; 0, "Initial Exchange Rate Mantissa should be greater zero");     //set controller     controller = controller_;     isWethPool = isWethPool_;     //set interestRateModel     baseRatePerBlock = baseRatePerBlock_;     multiplierPerBlock = multiplierPerBlock_;     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     kink = kink_;      // Initialize block number and borrow index (block number mocks depend on controller being set)     accrualBlockNumber = getBlockNumber();     borrowIndex = 1e25;     //80%     borrowCapFactorMantissa = 0.8e18;     //10%     reserveFactorMantissa = 0.1e18;       name = name_;     symbol = symbol_;     decimals = decimals_;      _notEntered = true;      // Set underlying and sanity check it     underlying = underlying_;     IERC20(underlying).totalSupply();     emit Transfer(address(0), msg.sender, 0); }  /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender` /// @dev Called by both `transfer` and `transferFrom` internally /// @param spender The address of the account performing the transfer /// @param src The address of the source account /// @param dst The address of the destination account /// @param tokens The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {     require(dst != address(0), "dst address cannot be 0");     /* Do not allow self-transfers */     require(src != dst, "src = dst");     /* Fail if transfer not allowed */     (ControllerInterface(controller)).transferAllowed(src, dst, tokens);      /* Get the allowance, infinite for the account owner */     uint startingAllowance = 0;     if (spender == src) {         startingAllowance = uint(- 1);     } else {         startingAllowance = transferAllowances[src][spender];     }      /* Do the calculations, checking for {under,over}flow */     MathError mathErr;     uint allowanceNew;     uint srcTokensNew;     uint dstTokensNew;      (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);     require(mathErr == MathError.NO_ERROR, 'not allowed');      (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);     require(mathErr == MathError.NO_ERROR, 'not enough');      (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);     require(mathErr == MathError.NO_ERROR, 'too much');      accountTokens[src] = srcTokensNew;     accountTokens[dst] = dstTokensNew;      /* Eat some of the allowance (if necessary) */     if (startingAllowance != uint(- 1)) {         transferAllowances[src][spender] = allowanceNew;     }     /* We emit a Transfer event */     emit Transfer(src, dst, tokens);     return true; }  /// @notice Transfer `amount` tokens from `msg.sender` to `dst` /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, msg.sender, dst, amount); }  /// @notice Transfer `amount` tokens from `src` to `dst` /// @param src The address of the source account /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, src, dst, amount); }  /// @notice Approve `spender` to transfer up to `amount` from `src` /// @dev This will overwrite the approval amount for `spender` ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve) /// @param spender The address of the account which may transfer tokens /// @param amount The number of tokens that are approved (-1 means infinite) /// @return Whether or not the approval succeeded function approve(address spender, uint256 amount) external override returns (bool) {     address src = msg.sender;     transferAllowances[src][spender] = amount;     emit Approval(src, spender, amount);     return true; }  /// @notice Get the current allowance from `owner` for `spender` /// @param owner The address of the account which owns the tokens to be spent /// @param spender The address of the account which may transfer tokens /// @return The number of tokens allowed to be spent (-1 means infinite) function allowance(address owner, address spender) external override view returns (uint256) {     return transferAllowances[owner][spender]; }  /// @notice Get the token balance of the `owner` /// @param owner The address of the account to query /// @return The number of tokens owned by `owner` function balanceOf(address owner) external override view returns (uint256) {     return accountTokens[owner]; }  /// @notice Get the underlying balance of the `owner` /// @dev This also accrues interest in a transaction /// @param owner The address of the account to query /// @return The amount of underlying owned by `owner` function balanceOfUnderlying(address owner) external override returns (uint) {     Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});     (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);     require(mErr == MathError.NO_ERROR, "calc failed");     return balance; }  /*** User Interface ***/  /// @notice Sender supplies assets into the market and receives lTokens in exchange /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param mintAmount The amount of the underlying asset to supply function mint(uint mintAmount) external override nonReentrant {     accrueInterest();     mintFresh(msg.sender, mintAmount, false); }  function mintTo(address to, uint amount) external payable override nonReentrant {     accrueInterest();     if (isWethPool) {         mintFresh(to, msg.value, false);     } else {         mintFresh(to, amount, true);     } }  function mintEth() external payable override nonReentrant {     require(isWethPool, "not eth pool");     accrueInterest();     mintFresh(msg.sender, msg.value, false); }  /// @notice Sender redeems lTokens in exchange for the underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemTokens The number of lTokens to redeem into underlying function redeem(uint redeemTokens) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, redeemTokens, 0); }  /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemAmount The amount of underlying to redeem function redeemUnderlying(uint redeemAmount) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, 0, redeemAmount); }  function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {     accrueInterest();     // borrowFresh emits borrow-specific logs on errors, so we don't need to     borrowFresh(payable(borrower), msg.sender, borrowAmount); }  /// @notice Sender repays a borrow belonging to borrower /// @param borrower the account with the debt being payed off /// @param repayAmount The amount to repay function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     repayBorrowFresh(msg.sender, borrower, repayAmount, false); }  function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     repayBorrowFresh(msg.sender, borrower, repayAmount, true); }   /*** Safe Token ***/  /// Gets balance of this contract in terms of the underlying /// @dev This excludes the value of the current message, if any /// @return The quantity of underlying tokens owned by this contract function getCashPrior() internal view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }   /**  * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.  *      This will revert due to insufficient balance or insufficient allowance.  *      This function returns the actual amount received,  *      which may be less than `amount` if there is a fee attached to the transfer.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {     if (isWethPool &amp;&amp; convertWeth) {         actualAmount = msg.value;         IWETH(underlying).deposit{value : actualAmount}();     } else {         actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);     } }  /**  * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory  *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to  *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified  *      it is &gt;= amount, this should not revert in normal conditions.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferOut(address payable to, uint amount, bool convertWeth) internal {     if (isWethPool &amp;&amp; convertWeth) {         IWETH(underlying).withdraw(amount);         to.transfer(amount);     } else {         IERC20(underlying).safeTransfer(to, amount);     } }  function availableForBorrow() external view override returns (uint){     uint cash = getCashPrior();     (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);     if (err0 != MathError.NO_ERROR) {         return 0;     }     (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);     if (err1 != MathError.NO_ERROR) {         return 0;     }     if (totalBorrows &gt; maxAvailable) {         return 0;     }     return maxAvailable - totalBorrows; }   /// @notice Get a snapshot of the account's balances, and the cached exchange rate /// @dev This is used by controller to more efficiently perform liquidity checks. /// @param account Address of the account to snapshot /// @return ( token balance, borrow balance, exchange rate mantissa) function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {     uint cTokenBalance = accountTokens[account];     uint borrowBalance;     uint exchangeRateMantissa;      MathError mErr;      (mErr, borrowBalance) = borrowBalanceStoredInternal(account);     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      return (cTokenBalance, borrowBalance, exchangeRateMantissa); }  /// @dev Function to simply retrieve block number ///  This exists mainly for inheriting test contracts to stub this result. function getBlockNumber() internal view returns (uint) {     return block.number; }  /// @notice Returns the current per-block borrow interest rate for this cToken /// @return The borrow interest rate per block, scaled by 1e18 function borrowRatePerBlock() external override view returns (uint) {     return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves); }   /// @notice Returns the current per-block supply interest rate for this cToken /// @return The supply interest rate per block, scaled by 1e18 function supplyRatePerBlock() external override view returns (uint) {     return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa); }  function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {     // Utilization rate is 0 when there are no borrows     if (borrows == 0) {         return 0;     }     return borrows.mul(1e18).div(cash.add(borrows).sub(reserves)); }  /// @notice Calculates the current borrow rate per block, with the error code expected by the market /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18) function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {     uint util = utilizationRate(cash, borrows, reserves);     if (util &lt;= kink) {         return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);     } else {         uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);         uint excessUtil = util.sub(kink);         return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);     } }  /// @notice Calculates the current supply rate per block /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The supply rate percentage per block as a mantissa (scaled by 1e18) function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {     uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);     uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);     uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);     return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18); }  /// @notice Returns the current total borrows plus accrued interest /// @return The total borrows with interest function totalBorrowsCurrent() external override view returns (uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return totalBorrows;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, "calc block delta erro");      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      return totalBorrowsNew; }  /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex /// @param account The address whose balance should be calculated after updating borrowIndex /// @return The calculated balance function borrowBalanceCurrent(address account) external view override returns (uint) {     (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();     require(err0 == MathError.NO_ERROR, "calc borrow index fail");     (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);     require(err1 == MathError.NO_ERROR, "calc fail");     return result; }  function borrowBalanceStored(address account) external override view returns (uint){     return accountBorrows[account].principal; }   /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {     return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex); }  /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {     /* Note: we do not assert that the market is up to date */     MathError mathErr;     uint principalTimesIndex;     uint result;      /* Get borrowBalance and borrowIndex */     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];      /* If borrowBalance = 0 then borrowIndex is likely also 0.      * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.      */     if (borrowSnapshot.principal == 0) {         return (MathError.NO_ERROR, 0);     }      /* Calculate new borrow balance using the interest index:      *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex      */     (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      return (MathError.NO_ERROR, result); }  /// @notice Accrue interest then return the up-to-date exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateCurrent() public override nonReentrant returns (uint) {     accrueInterest();     return exchangeRateStored(); }  /// Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateStored() public override view returns (uint) {     (MathError err, uint result) = exchangeRateStoredInternal();     require(err == MathError.NO_ERROR, "calc fail");     return result; }  /// @notice Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return (error code, calculated exchange rate scaled by 1e18) function exchangeRateStoredInternal() internal view returns (MathError, uint) {     uint _totalSupply = totalSupply;     if (_totalSupply == 0) {         /*          * If there are no tokens minted:          *  exchangeRate = initialExchangeRate          */         return (MathError.NO_ERROR, initialExchangeRateMantissa);     } else {         /*          * Otherwise:          *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply          */         uint _totalCash = getCashPrior();         uint cashPlusBorrowsMinusReserves;         Exp memory exchangeRate;         MathError mathErr;          (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          return (MathError.NO_ERROR, exchangeRate.mantissa);     } }  /// @notice Get cash balance of this cToken in the underlying asset /// @return The quantity of underlying asset owned by this contract function getCash() external override view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }  function calCurrentBorrowIndex() internal view returns (MathError, uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;     uint borrowIndexNew;     /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return (MathError.NO_ERROR, borrowIndex);     }     uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);      Exp memory simpleInterestFactor;     (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }     (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);     return (mathErr, borrowIndexNew); }  /// @notice Applies accrued interest to total borrows and reserves /// @dev This calculates interest accrued from the last checkpointed block ///   up to the current block and writes new checkpoint to storage. function accrueInterest() public override {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint borrowIndexPrior = borrowIndex;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, "calc block delta erro");       /*      * Calculate the interest accumulated into borrows and reserves and the new index:      *  simpleInterestFactor = borrowRate * blockDelta      *  interestAccumulated = simpleInterestFactor * totalBorrows      *  totalBorrowsNew = interestAccumulated + totalBorrows      *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex      */      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;     uint borrowIndexNew;     uint totalReservesNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);     require(mathErr == MathError.NO_ERROR, 'calc total reserves error');      (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);     require(mathErr == MathError.NO_ERROR, 'calc borrows index error');       /* We write the previously calculated values into storage */     accrualBlockNumber = currentBlockNumber;     borrowIndex = borrowIndexNew;     totalBorrows = totalBorrowsNew;     totalReserves = totalReservesNew;      /* We emit an AccrueInterest event */     emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);  }  struct MintLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint mintTokens;     uint totalSupplyNew;     uint accountTokensNew;     uint actualMintAmount; }  /// @notice User supplies assets into the market and receives lTokens in exchange /// @dev Assumes interest has already been accrued up to the current block /// @param minter The address of the account which is supplying the assets /// @param mintAmount The amount of the underlying asset to supply /// @return uint the actual mint amount. function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {     MintLocalVars memory vars;     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /*      *  We call `doTransferIn` for the minter and the mintAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if      *  side-effects occurred. The function returns the amount actually transferred,      *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`      *  of cash.      */     if (isDelegete) {         uint balanceBefore = getCashPrior();         LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);         uint balanceAfter = getCashPrior();         require(balanceAfter &gt; balanceBefore, 'mint 0');         vars.actualMintAmount = balanceAfter - balanceBefore;     } else {         vars.actualMintAmount = doTransferIn(minter, mintAmount, true);     }     /*      * We get the current exchange rate and calculate the number of lTokens to be minted:      *  mintTokens = actualMintAmount / exchangeRate      */      (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));     require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");      /* Fail if mint not allowed */     (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);     /*      * We calculate the new total supply of lTokens and minter token balance, checking for overflow:      *  totalSupplyNew = totalSupply + mintTokens      *  accountTokensNew = accountTokens[minter] + mintTokens      */     (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");      (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[minter] = vars.accountTokensNew;      /* We emit a Mint event, and a Transfer event */     emit Mint(minter, vars.actualMintAmount, vars.mintTokens);     emit Transfer(address(this), minter, vars.mintTokens);      /* We call the defense hook */      return vars.actualMintAmount; }   struct RedeemLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint redeemTokens;     uint redeemAmount;     uint totalSupplyNew;     uint accountTokensNew; }  /// @notice User redeems lTokens in exchange for the underlying asset /// @dev Assumes interest has already been accrued up to the current block /// @param redeemer The address of the account which is redeeming the tokens /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero) /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero) function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {     require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");      RedeemLocalVars memory vars;      /* exchangeRate = invoke Exchange Rate Stored() */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /* If redeemTokensIn &gt; 0: */     if (redeemTokensIn &gt; 0) {         /*          * We calculate the exchange rate and the amount of underlying to be redeemed:          *  redeemTokens = redeemTokensIn          *  redeemAmount = redeemTokensIn x exchangeRateCurrent          */         vars.redeemTokens = redeemTokensIn;          (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');     } else {         /*          * We get the current exchange rate and calculate the amount to be redeemed:          *  redeemTokens = redeemAmountIn / exchangeRate          *  redeemAmount = redeemAmountIn          */          (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');         vars.redeemAmount = redeemAmountIn;     }      /* Fail if redeem not allowed */     (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);      /*      * We calculate the new total supply and redeemer balance, checking for underflow:      *  totalSupplyNew = totalSupply - redeemTokens      *  accountTokensNew = accountTokens[redeemer] - redeemTokens      */     (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');      (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');     require(getCashPrior() &gt;= vars.redeemAmount, 'cash &lt; redeem');      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[redeemer] = vars.accountTokensNew;     /*      * We invoke doTransferOut for the redeemer and the redeemAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken has redeemAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(redeemer, vars.redeemAmount, true);       /* We emit a Transfer event, and a Redeem event */     emit Transfer(redeemer, address(this), vars.redeemTokens);     emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);      /* We call the defense hook */ }  struct BorrowLocalVars {     MathError mathErr;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /// @notice Users borrow assets from the protocol to their own address /// @param borrowAmount The amount of the underlying asset to borrow function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {     /* Fail if borrow not allowed */     (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);      /* Fail gracefully if protocol has insufficient underlying cash */     require(getCashPrior() &gt;= borrowAmount, 'cash&lt;borrow');      BorrowLocalVars memory vars;      /*      * We calculate the new borrower and total borrow balances, failing on overflow:      *  accountBorrowsNew = accountBorrows + borrowAmount      *  totalBorrowsNew = totalBorrows + borrowAmount      */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /*      * We invoke doTransferOut for the borrower and the borrowAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken borrowAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(payee, borrowAmount, false);      /* We emit a Borrow event */     emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */ }  struct RepayBorrowLocalVars {     MathError mathErr;     uint repayAmount;     uint borrowerIndex;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew;     uint actualRepayAmount;     uint badDebtsAmount; }  /// @notice Borrows are repaid by another user (possibly the borrower). /// @param payer the account paying off the borrow /// @param borrower the account with the debt being payed off /// @param repayAmount the amount of undelrying tokens being returned function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {     /* Fail if repayBorrow not allowed */     (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);      RepayBorrowLocalVars memory vars;      /* We remember the original borrowerIndex for verification purposes */     vars.borrowerIndex = accountBorrows[borrower].interestIndex;      /* We fetch the amount the borrower owes, with accumulated interest */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');      /* If repayAmount == -1, repayAmount = accountBorrows */     if (repayAmount == uint(- 1)) {         vars.repayAmount = vars.accountBorrows;     } else {         vars.repayAmount = repayAmount;     }     vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);       if (isEnd &amp;&amp; vars.accountBorrows &gt; vars.actualRepayAmount) {         vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;     }      /*     *  We calculate the new borrower and total borrow balances, failing on underflow:     *  accountBorrowsNew = accountBorrows - repayAmount     *  totalBorrowsNew = totalBorrows - repayAmount     */     if (vars.accountBorrows &lt; vars.actualRepayAmount) {         require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) &lt;= 105e16, 'repay more than 5%');         vars.accountBorrowsNew = 0;     } else {         if (isEnd) {             vars.accountBorrowsNew = 0;         } else {             vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;         }     }     //Avoid mantissa errors     if (vars.actualRepayAmount &gt; totalBorrows) {         vars.totalBorrowsNew = 0;     } else {         if (isEnd) {             vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);         } else {             vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;         }     }      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a RepayBorrow event */     emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */      return vars.actualRepayAmount; }  /*** Admin Functions ***/  /// @notice Sets a new CONTROLLER for the market /// @dev Admin function to set a new controller function setController(address newController) external override onlyAdmin {     require(address(0) != newController, "0x");     address oldController = controller;     controller = newController;     // Emit NewController(oldController, newController)     emit NewController(oldController, newController); }  function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {     require(newBorrowCapFactorMantissa &lt;= 1e18, 'Factor too large');     uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;     borrowCapFactorMantissa = newBorrowCapFactorMantissa;     emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa); }  function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {     //accrueInterest except first     if (baseRatePerBlock != 0) {         accrueInterest();     }     // total rate perYear &lt; 2000%     require(baseRatePerBlock_ &lt; 1e13, 'Base rate too large');     baseRatePerBlock = baseRatePerBlock_;     require(multiplierPerBlock_ &lt; 1e13, 'Mul rate too large');     multiplierPerBlock = multiplierPerBlock_;     require(jumpMultiplierPerBlock_ &lt; 1e13, 'Jump rate too large');     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     require(kink_ &lt;= 1e18, 'Kline too large');     kink = kink_;     emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_); }  function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {     require(newReserveFactorMantissa &lt;= 1e18, 'Factor too large');     accrueInterest();     uint oldReserveFactorMantissa = reserveFactorMantissa;     reserveFactorMantissa = newReserveFactorMantissa;     emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa); }  function addReserves(uint addAmount) external override nonReentrant {     accrueInterest();     uint totalReservesNew;     uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);     totalReservesNew = totalReserves.add(actualAddAmount);     totalReserves = totalReservesNew;     emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew); }  function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {     accrueInterest();     uint totalReservesNew;     totalReservesNew = totalReserves.sub(reduceAmount);     totalReserves = totalReservesNew;     doTransferOut(to, reduceAmount, true);     emit ReservesReduced(to, reduceAmount, totalReservesNew); }  modifier sameBlock() {     require(accrualBlockNumber == getBlockNumber(), 'not same block');     _; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-24-08 19:27:58 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;


import "./LPoolInterface.sol";
import "./LPoolDepositor.sol";
import "../lib/Exponential.sol";
import "../Adminable.sol";
import "../lib/CarefulMath.sol";
import "../lib/TransferHelper.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import "../DelegateInterface.sol";
import "../ControllerInterface.sol";
import "../IWETH.sol";

/// @title OpenLeverage's LToken Contract
/// @dev Abstract base for LTokens
/// @author OpenLeverage
contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {
    using TransferHelper for IERC20;
    using SafeMath for uint;

    constructor() {

    }
    
    /// @notice Initialize the money market
    /// @param controller_ The address of the Controller
    /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0
    /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate
    /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point
    /// @param kink_ The utilization point at which the jump multiplier is applied
    /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
    /// @param name_ EIP-20 name of this token
    /// @param symbol_ EIP-20 symbol of this token
    /// @param decimals_ EIP-20 decimal precision of this token
    function initialize(
        address underlying_,
        bool isWethPool_,
        address controller_,
        uint256 baseRatePerBlock_,
        uint256 multiplierPerBlock_,
        uint256 jumpMultiplierPerBlock_,
        uint256 kink_,
        uint initialExchangeRateMantissa_,
        string memory name_,
        string memory symbol_,
        uint8 decimals_) public {
        require(underlying_ != address(0), "underlying_ address cannot be 0");
        require(controller_ != address(0), "controller_ address cannot be 0");
        require(msg.sender == admin, "Only allow to be called by admin");
        require(accrualBlockNumber == 0 && borrowIndex == 0, "inited once");

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial Exchange Rate Mantissa should be greater zero");
        //set controller
        controller = controller_;
        isWethPool = isWethPool_;
        //set interestRateModel
        baseRatePerBlock = baseRatePerBlock_;
        multiplierPerBlock = multiplierPerBlock_;
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        kink = kink_;

        // Initialize block number and borrow index (block number mocks depend on controller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = 1e25;
        //80%
        borrowCapFactorMantissa = 0.8e18;
        //10%
        reserveFactorMantissa = 0.1e18;


        name = name_;
        symbol = symbol_;
        decimals = decimals_;

        _notEntered = true;

        // Set underlying and sanity check it
        underlying = underlying_;
        IERC20(underlying).totalSupply();
        emit Transfer(address(0), msg.sender, 0);
    }

    /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
    /// @dev Called by both `transfer` and `transferFrom` internally
    /// @param spender The address of the account performing the transfer
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param tokens The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {
        require(dst != address(0), "dst address cannot be 0");
        /* Do not allow self-transfers */
        require(src != dst, "src = dst");
        /* Fail if transfer not allowed */
        (ControllerInterface(controller)).transferAllowed(src, dst, tokens);

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(- 1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        require(mathErr == MathError.NO_ERROR, 'not allowed');

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        require(mathErr == MathError.NO_ERROR, 'not enough');

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        require(mathErr == MathError.NO_ERROR, 'too much');

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(- 1)) {
            transferAllowances[src][spender] = allowanceNew;
        }
        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);
        return true;
    }

    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount);
    }

    /// @notice Transfer `amount` tokens from `src` to `dst`
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount);
    }

    /// @notice Approve `spender` to transfer up to `amount` from `src`
    /// @dev This will overwrite the approval amount for `spender`
    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
    /// @param spender The address of the account which may transfer tokens
    /// @param amount The number of tokens that are approved (-1 means infinite)
    /// @return Whether or not the approval succeeded
    function approve(address spender, uint256 amount) external override returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /// @notice Get the current allowance from `owner` for `spender`
    /// @param owner The address of the account which owns the tokens to be spent
    /// @param spender The address of the account which may transfer tokens
    /// @return The number of tokens allowed to be spent (-1 means infinite)
    function allowance(address owner, address spender) external override view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /// @notice Get the token balance of the `owner`
    /// @param owner The address of the account to query
    /// @return The number of tokens owned by `owner`
    function balanceOf(address owner) external override view returns (uint256) {
        return accountTokens[owner];
    }

    /// @notice Get the underlying balance of the `owner`
    /// @dev This also accrues interest in a transaction
    /// @param owner The address of the account to query
    /// @return The amount of underlying owned by `owner`
    function balanceOfUnderlying(address owner) external override returns (uint) {
        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR, "calc failed");
        return balance;
    }

    /*** User Interface ***/

    /// @notice Sender supplies assets into the market and receives lTokens in exchange
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param mintAmount The amount of the underlying asset to supply
    function mint(uint mintAmount) external override nonReentrant {
        accrueInterest();
        mintFresh(msg.sender, mintAmount, false);
    }

    function mintTo(address to, uint amount) external payable override nonReentrant {
        accrueInterest();
        if (isWethPool) {
            mintFresh(to, msg.value, false);
        } else {
            mintFresh(to, amount, true);
        }
    }

    function mintEth() external payable override nonReentrant {
        require(isWethPool, "not eth pool");
        accrueInterest();
        mintFresh(msg.sender, msg.value, false);
    }

    /// @notice Sender redeems lTokens in exchange for the underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemTokens The number of lTokens to redeem into underlying
    function redeem(uint redeemTokens) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, redeemTokens, 0);
    }

    /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemAmount The amount of underlying to redeem
    function redeemUnderlying(uint redeemAmount) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, 0, redeemAmount);
    }

    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {
        accrueInterest();
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        borrowFresh(payable(borrower), msg.sender, borrowAmount);
    }

    /// @notice Sender repays a borrow belonging to borrower
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount The amount to repay
    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        repayBorrowFresh(msg.sender, borrower, repayAmount, false);
    }

    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        repayBorrowFresh(msg.sender, borrower, repayAmount, true);
    }


    /*** Safe Token ***/

    /// Gets balance of this contract in terms of the underlying
    /// @dev This excludes the value of the current message, if any
    /// @return The quantity of underlying tokens owned by this contract
    function getCashPrior() internal view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }


    /**
     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.
     *      This will revert due to insufficient balance or insufficient allowance.
     *      This function returns the actual amount received,
     *      which may be less than `amount` if there is a fee attached to the transfer.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {
        if (isWethPool && convertWeth) {
            actualAmount = msg.value;
            IWETH(underlying).deposit{value : actualAmount}();
        } else {
            actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);
        }
    }

    /**
     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory
     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to
     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified
     *      it is >= amount, this should not revert in normal conditions.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {
        if (isWethPool && convertWeth) {
            IWETH(underlying).withdraw(amount);
            to.transfer(amount);
        } else {
            IERC20(underlying).safeTransfer(to, amount);
        }
    }

    function availableForBorrow() external view override returns (uint){
        uint cash = getCashPrior();
        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);
        if (err0 != MathError.NO_ERROR) {
            return 0;
        }
        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);
        if (err1 != MathError.NO_ERROR) {
            return 0;
        }
        if (totalBorrows > maxAvailable) {
            return 0;
        }
        return maxAvailable - totalBorrows;
    }


    /// @notice Get a snapshot of the account's balances, and the cached exchange rate
    /// @dev This is used by controller to more efficiently perform liquidity checks.
    /// @param account Address of the account to snapshot
    /// @return ( token balance, borrow balance, exchange rate mantissa)
    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        return (cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /// @dev Function to simply retrieve block number
    ///  This exists mainly for inheriting test contracts to stub this result.
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /// @notice Returns the current per-block borrow interest rate for this cToken
    /// @return The borrow interest rate per block, scaled by 1e18
    function borrowRatePerBlock() external override view returns (uint) {
        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
    }

    
    /// @notice Returns the current per-block supply interest rate for this cToken
    /// @return The supply interest rate per block, scaled by 1e18
    function supplyRatePerBlock() external override view returns (uint) {
        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);
    }

    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {
        // Utilization rate is 0 when there are no borrows
        if (borrows == 0) {
            return 0;
        }
        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));
    }

    /// @notice Calculates the current borrow rate per block, with the error code expected by the market
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18)
    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {
        uint util = utilizationRate(cash, borrows, reserves);
        if (util <= kink) {
            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
        } else {
            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
            uint excessUtil = util.sub(kink);
            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);
        }
    }

    /// @notice Calculates the current supply rate per block
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The supply rate percentage per block as a mantissa (scaled by 1e18)
    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {
        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);
        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);
        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);
        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);
    }

    /// @notice Returns the current total borrows plus accrued interest
    /// @return The total borrows with interest
    function totalBorrowsCurrent() external override view returns (uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return totalBorrows;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        return totalBorrowsNew;
    }

    /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
    /// @param account The address whose balance should be calculated after updating borrowIndex
    /// @return The calculated balance
    function borrowBalanceCurrent(address account) external view override returns (uint) {
        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();
        require(err0 == MathError.NO_ERROR, "calc borrow index fail");
        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
        require(err1 == MathError.NO_ERROR, "calc fail");
        return result;
    }

    function borrowBalanceStored(address account) external override view returns (uint){
        return accountBorrows[account].principal;
    }


    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
    }

    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /// @notice Accrue interest then return the up-to-date exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateCurrent() public override nonReentrant returns (uint) {
        accrueInterest();
        return exchangeRateStored();
    }

    /// Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateStored() public override view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "calc fail");
        return result;
    }

    /// @notice Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return (error code, calculated exchange rate scaled by 1e18)
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        uint _totalSupply = totalSupply;
        if (_totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint _totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /// @notice Get cash balance of this cToken in the underlying asset
    /// @return The quantity of underlying asset owned by this contract
    function getCash() external override view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }

    function calCurrentBorrowIndex() internal view returns (MathError, uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;
        uint borrowIndexNew;
        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return (MathError.NO_ERROR, borrowIndex);
        }
        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);

        Exp memory simpleInterestFactor;
        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }
        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);
        return (mathErr, borrowIndexNew);
    }

    /// @notice Applies accrued interest to total borrows and reserves
    /// @dev This calculates interest accrued from the last checkpointed block
    ///   up to the current block and writes new checkpoint to storage.
    function accrueInterest() public override {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint borrowIndexPrior = borrowIndex;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");


        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;
        uint borrowIndexNew;
        uint totalReservesNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total reserves error');

        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);
        require(mathErr == MathError.NO_ERROR, 'calc borrows index error');


        /* We write the previously calculated values into storage */
        accrualBlockNumber = currentBlockNumber;
        borrowIndex = borrowIndexNew;
        totalBorrows = totalBorrowsNew;
        totalReserves = totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);

    }

    struct MintLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
        uint actualMintAmount;
    }

    /// @notice User supplies assets into the market and receives lTokens in exchange
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param minter The address of the account which is supplying the assets
    /// @param mintAmount The amount of the underlying asset to supply
    /// @return uint the actual mint amount.
    function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {
        MintLocalVars memory vars;
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /*
         *  We call `doTransferIn` for the minter and the mintAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if
         *  side-effects occurred. The function returns the amount actually transferred,
         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`
         *  of cash.
         */
        if (isDelegete) {
            uint balanceBefore = getCashPrior();
            LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);
            uint balanceAfter = getCashPrior();
            require(balanceAfter > balanceBefore, 'mint 0');
            vars.actualMintAmount = balanceAfter - balanceBefore;
        } else {
            vars.actualMintAmount = doTransferIn(minter, mintAmount, true);
        }
        /*
         * We get the current exchange rate and calculate the number of lTokens to be minted:
         *  mintTokens = actualMintAmount / exchangeRate
         */

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));
        require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");

        /* Fail if mint not allowed */
        (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);
        /*
         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */

        return vars.actualMintAmount;
    }


    struct RedeemLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /// @notice User redeems lTokens in exchange for the underlying asset
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param redeemer The address of the account which is redeeming the tokens
    /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');
            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');
        require(getCashPrior() >= vars.redeemAmount, 'cash < redeem');

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;
        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(redeemer, vars.redeemAmount, true);


        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
    }

    struct BorrowLocalVars {
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /// @notice Users borrow assets from the protocol to their own address
    /// @param borrowAmount The amount of the underlying asset to borrow
    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {
        /* Fail if borrow not allowed */
        (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);

        /* Fail gracefully if protocol has insufficient underlying cash */
        require(getCashPrior() >= borrowAmount, 'cash<borrow');

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(payee, borrowAmount, false);

        /* We emit a Borrow event */
        emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
    }

    struct RepayBorrowLocalVars {
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
        uint actualRepayAmount;
        uint badDebtsAmount;
    }

    /// @notice Borrows are repaid by another user (possibly the borrower).
    /// @param payer the account paying off the borrow
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount the amount of undelrying tokens being returned
    function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {
        /* Fail if repayBorrow not allowed */
        (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(- 1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }
        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);


        if (isEnd && vars.accountBorrows > vars.actualRepayAmount) {
            vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;
        }

        /*
        *  We calculate the new borrower and total borrow balances, failing on underflow:
        *  accountBorrowsNew = accountBorrows - repayAmount
        *  totalBorrowsNew = totalBorrows - repayAmount
        */
        if (vars.accountBorrows < vars.actualRepayAmount) {
            require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) <= 105e16, 'repay more than 5%');
            vars.accountBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.accountBorrowsNew = 0;
            } else {
                vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;
            }
        }
        //Avoid mantissa errors
        if (vars.actualRepayAmount > totalBorrows) {
            vars.totalBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);
            } else {
                vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;
            }
        }

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */

        return vars.actualRepayAmount;
    }

    /*** Admin Functions ***/

    /// @notice Sets a new CONTROLLER for the market
    /// @dev Admin function to set a new controller
    function setController(address newController) external override onlyAdmin {
        require(address(0) != newController, "0x");
        address oldController = controller;
        controller = newController;
        // Emit NewController(oldController, newController)
        emit NewController(oldController, newController);
    }

    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {
        require(newBorrowCapFactorMantissa <= 1e18, 'Factor too large');
        uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;
        borrowCapFactorMantissa = newBorrowCapFactorMantissa;
        emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa);
    }

    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {
        //accrueInterest except first
        if (baseRatePerBlock != 0) {
            accrueInterest();
        }
        // total rate perYear < 2000%
        require(baseRatePerBlock_ < 1e13, 'Base rate too large');
        baseRatePerBlock = baseRatePerBlock_;
        require(multiplierPerBlock_ < 1e13, 'Mul rate too large');
        multiplierPerBlock = multiplierPerBlock_;
        require(jumpMultiplierPerBlock_ < 1e13, 'Jump rate too large');
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        require(kink_ <= 1e18, 'Kline too large');
        kink = kink_;
        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);
    }

    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {
        require(newReserveFactorMantissa <= 1e18, 'Factor too large');
        accrueInterest();
        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;
        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);
    }

    function addReserves(uint addAmount) external override nonReentrant {
        accrueInterest();
        uint totalReservesNew;
        uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);
        totalReservesNew = totalReserves.add(actualAddAmount);
        totalReserves = totalReservesNew;
        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);
    }

    function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {
        accrueInterest();
        uint totalReservesNew;
        totalReservesNew = totalReserves.sub(reduceAmount);
        totalReserves = totalReservesNew;
        doTransferOut(to, reduceAmount, true);
        emit ReservesReduced(to, reduceAmount, totalReservesNew);
    }

    modifier sameBlock() {
        require(accrualBlockNumber == getBlockNumber(), 'not same block');
        _;
    }
}

.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;

import "./LPoolInterface.sol";
import "./LPoolDepositor.sol";
import "../lib/Exponential.sol";
import "../Adminable.sol";
import "../lib/CarefulMath.sol";
import "../lib/TransferHelper.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "../DelegateInterface.sol";
import "../ControllerInterface.sol";
import "../IWETH.sol";
/// @title OpenLeverage's LToken Contract
/// @dev Abstract base for LTokens
/// @author OpenLeverage
contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {
    using TransferHelper for IERC20;
    using SafeMath for uint;
    constructor() {
    }
    
    /// @notice Initialize the money market
    /// @param controller_ The address of the Controller
    /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0
    /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate
    /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point
    /// @param kink_ The utilization point at which the jump multiplier is applied
    /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
    /// @param name_ EIP-20 name of this token
    /// @param symbol_ EIP-20 symbol of this token
    /// @param decimals_ EIP-20 decimal precision of this token
    function initialize(
        address underlying_,
        bool isWethPool_,
        address controller_,
        uint256 baseRatePerBlock_,
        uint256 multiplierPerBlock_,
        uint256 jumpMultiplierPerBlock_,
        uint256 kink_,
        uint initialExchangeRateMantissa_,
        string memory name_,
        string memory symbol_,
        uint8 decimals_) public {
        require(underlying_ != address(0), "underlying_ address cannot be 0");
        require(controller_ != address(0), "controller_ address cannot be 0");
        require(msg.sender == admin, "Only allow to be called by admin");
        require(accrualBlockNumber == 0 && borrowIndex == 0, "inited once");
        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial Exchange Rate Mantissa should be greater zero");
        //set controller
        controller = controller_;
        isWethPool = isWethPool_;
        //set interestRateModel
        baseRatePerBlock = baseRatePerBlock_;
        multiplierPerBlock = multiplierPerBlock_;
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        kink = kink_;
        // Initialize block number and borrow index (block number mocks depend on controller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = 1e25;
        //80%
        borrowCapFactorMantissa = 0.8e18;
        //10%
        reserveFactorMantissa = 0.1e18;

        name = name_;
        symbol = symbol_;
        decimals = decimals_;
        _notEntered = true;
        // Set underlying and sanity check it
        underlying = underlying_;
        IERC20(underlying).totalSupply();
        emit Transfer(address(0), msg.sender, 0);
    }
    /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
    /// @dev Called by both `transfer` and `transferFrom` internally
    /// @param spender The address of the account performing the transfer
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param tokens The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {
        require(dst != address(0), "dst address cannot be 0");
        /* Do not allow self-transfers */
        require(src != dst, "src = dst");
        /* Fail if transfer not allowed */
        (ControllerInterface(controller)).transferAllowed(src, dst, tokens);
        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(- 1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }
        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;
        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        require(mathErr == MathError.NO_ERROR, 'not allowed');
        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        require(mathErr == MathError.NO_ERROR, 'not enough');
        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        require(mathErr == MathError.NO_ERROR, 'too much');
        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;
        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(- 1)) {
            transferAllowances[src][spender] = allowanceNew;
        }
        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);
        return true;
    }
    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount);
    }
    /// @notice Transfer `amount` tokens from `src` to `dst`
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount);
    }
    /// @notice Approve `spender` to transfer up to `amount` from `src`
    /// @dev This will overwrite the approval amount for `spender`
    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
    /// @param spender The address of the account which may transfer tokens
    /// @param amount The number of tokens that are approved (-1 means infinite)
    /// @return Whether or not the approval succeeded
    function approve(address spender, uint256 amount) external override returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }
    /// @notice Get the current allowance from `owner` for `spender`
    /// @param owner The address of the account which owns the tokens to be spent
    /// @param spender The address of the account which may transfer tokens
    /// @return The number of tokens allowed to be spent (-1 means infinite)
    function allowance(address owner, address spender) external override view returns (uint256) {
        return transferAllowances[owner][spender];
    }
    /// @notice Get the token balance of the `owner`
    /// @param owner The address of the account to query
    /// @return The number of tokens owned by `owner`
    function balanceOf(address owner) external override view returns (uint256) {
        return accountTokens[owner];
    }
    /// @notice Get the underlying balance of the `owner`
    /// @dev This also accrues interest in a transaction
    /// @param owner The address of the account to query
    /// @return The amount of underlying owned by `owner`
    function balanceOfUnderlying(address owner) external override returns (uint) {
        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR, "calc failed");
        return balance;
    }
    /*** User Interface ***/
    /// @notice Sender supplies assets into the market and receives lTokens in exchange
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param mintAmount The amount of the underlying asset to supply
    function mint(uint mintAmount) external override nonReentrant {
        accrueInterest();
        mintFresh(msg.sender, mintAmount, false);
    }
    function mintTo(address to, uint amount) external payable override nonReentrant {
        accrueInterest();
        if (isWethPool) {
            mintFresh(to, msg.value, false);
        } else {
            mintFresh(to, amount, true);
        }
    }
    function mintEth() external payable override nonReentrant {
        require(isWethPool, "not eth pool");
        accrueInterest();
        mintFresh(msg.sender, msg.value, false);
    }
    /// @notice Sender redeems lTokens in exchange for the underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemTokens The number of lTokens to redeem into underlying
    function redeem(uint redeemTokens) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, redeemTokens, 0);
    }
    /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemAmount The amount of underlying to redeem
    function redeemUnderlying(uint redeemAmount) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, 0, redeemAmount);
    }
    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {
        accrueInterest();
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        borrowFresh(payable(borrower), msg.sender, borrowAmount);
    }
    /// @notice Sender repays a borrow belonging to borrower
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount The amount to repay
    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        repayBorrowFresh(msg.sender, borrower, repayAmount, false);
    }
    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        repayBorrowFresh(msg.sender, borrower, repayAmount, true);
    }

    /*** Safe Token ***/
    /// Gets balance of this contract in terms of the underlying
    /// @dev This excludes the value of the current message, if any
    /// @return The quantity of underlying tokens owned by this contract
    function getCashPrior() internal view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }

    /**
     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.
     *      This will revert due to insufficient balance or insufficient allowance.
     *      This function returns the actual amount received,
     *      which may be less than `amount` if there is a fee attached to the transfer.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {
        if (isWethPool && convertWeth) {
            actualAmount = msg.value;
            IWETH(underlying).deposit{value : actualAmount}();
        } else {
            actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);
        }
    }
    /**
     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory
     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to
     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified
     *      it is >= amount, this should not revert in normal conditions.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {
        if (isWethPool && convertWeth) {
            IWETH(underlying).withdraw(amount);
            to.transfer(amount);
        } else {
            IERC20(underlying).safeTransfer(to, amount);
        }
    }
    function availableForBorrow() external view override returns (uint){
        uint cash = getCashPrior();
        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);
        if (err0 != MathError.NO_ERROR) {
            return 0;
        }
        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);
        if (err1 != MathError.NO_ERROR) {
            return 0;
        }
        if (totalBorrows > maxAvailable) {
            return 0;
        }
        return maxAvailable - totalBorrows;
    }

    /// @notice Get a snapshot of the account's balances, and the cached exchange rate
    /// @dev This is used by controller to more efficiently perform liquidity checks.
    /// @param account Address of the account to snapshot
    /// @return ( token balance, borrow balance, exchange rate mantissa)
    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;
        MathError mErr;
        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }
        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }
        return (cTokenBalance, borrowBalance, exchangeRateMantissa);
    }
    /// @dev Function to simply retrieve block number
    ///  This exists mainly for inheriting test contracts to stub this result.
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }
    /// @notice Returns the current per-block borrow interest rate for this cToken
    /// @return The borrow interest rate per block, scaled by 1e18
    function borrowRatePerBlock() external override view returns (uint) {
        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
    }
    
    /// @notice Returns the current per-block supply interest rate for this cToken
    /// @return The supply interest rate per block, scaled by 1e18
    function supplyRatePerBlock() external override view returns (uint) {
        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);
    }
    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {
        // Utilization rate is 0 when there are no borrows
        if (borrows == 0) {
            return 0;
        }
        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));
    }
    /// @notice Calculates the current borrow rate per block, with the error code expected by the market
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18)
    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {
        uint util = utilizationRate(cash, borrows, reserves);
        if (util <= kink) {
            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
        } else {
            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
            uint excessUtil = util.sub(kink);
            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);
        }
    }
    /// @notice Calculates the current supply rate per block
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The supply rate percentage per block as a mantissa (scaled by 1e18)
    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {
        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);
        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);
        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);
        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);
    }
    /// @notice Returns the current total borrows plus accrued interest
    /// @return The total borrows with interest
    function totalBorrowsCurrent() external override view returns (uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;
        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return totalBorrows;
        }
        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint reservesPrior = totalReserves;
        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");
        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");
        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;
        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');
        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');
        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');
        return totalBorrowsNew;
    }
    /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
    /// @param account The address whose balance should be calculated after updating borrowIndex
    /// @return The calculated balance
    function borrowBalanceCurrent(address account) external view override returns (uint) {
        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();
        require(err0 == MathError.NO_ERROR, "calc borrow index fail");
        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
        require(err1 == MathError.NO_ERROR, "calc fail");
        return result;
    }
    function borrowBalanceStored(address account) external override view returns (uint){
        return accountBorrows[account].principal;
    }

    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
    }
    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;
        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];
        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }
        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }
        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }
        return (MathError.NO_ERROR, result);
    }
    /// @notice Accrue interest then return the up-to-date exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateCurrent() public override nonReentrant returns (uint) {
        accrueInterest();
        return exchangeRateStored();
    }
    /// Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateStored() public override view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "calc fail");
        return result;
    }
    /// @notice Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return (error code, calculated exchange rate scaled by 1e18)
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        uint _totalSupply = totalSupply;
        if (_totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint _totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;
            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }
            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }
            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }
    /// @notice Get cash balance of this cToken in the underlying asset
    /// @return The quantity of underlying asset owned by this contract
    function getCash() external override view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }
    function calCurrentBorrowIndex() internal view returns (MathError, uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;
        uint borrowIndexNew;
        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return (MathError.NO_ERROR, borrowIndex);
        }
        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        Exp memory simpleInterestFactor;
        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }
        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);
        return (mathErr, borrowIndexNew);
    }
    /// @notice Applies accrued interest to total borrows and reserves
    /// @dev This calculates interest accrued from the last checkpointed block
    ///   up to the current block and writes new checkpoint to storage.
    function accrueInterest() public override {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;
        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return;
        }
        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint borrowIndexPrior = borrowIndex;
        uint reservesPrior = totalReserves;
        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");
        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");

        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */
        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;
        uint borrowIndexNew;
        uint totalReservesNew;
        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');
        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');
        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');
        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total reserves error');
        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);
        require(mathErr == MathError.NO_ERROR, 'calc borrows index error');

        /* We write the previously calculated values into storage */
        accrualBlockNumber = currentBlockNumber;
        borrowIndex = borrowIndexNew;
        totalBorrows = totalBorrowsNew;
        totalReserves = totalReservesNew;
        /* We emit an AccrueInterest event */
        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);
    }
    struct MintLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
        uint actualMintAmount;
    }
    /// @notice User supplies assets into the market and receives lTokens in exchange
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param minter The address of the account which is supplying the assets
    /// @param mintAmount The amount of the underlying asset to supply
    /// @return uint the actual mint amount.
    function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {
        MintLocalVars memory vars;
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');
        /*
         *  We call `doTransferIn` for the minter and the mintAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if
         *  side-effects occurred. The function returns the amount actually transferred,
         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`
         *  of cash.
         */
        if (isDelegete) {
            uint balanceBefore = getCashPrior();
            LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);
            uint balanceAfter = getCashPrior();
            require(balanceAfter > balanceBefore, 'mint 0');
            vars.actualMintAmount = balanceAfter - balanceBefore;
        } else {
            vars.actualMintAmount = doTransferIn(minter, mintAmount, true);
        }
        /*
         * We get the current exchange rate and calculate the number of lTokens to be minted:
         *  mintTokens = actualMintAmount / exchangeRate
         */
        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));
        require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");
        /* Fail if mint not allowed */
        (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);
        /*
         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");
        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");
        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;
        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);
        /* We call the defense hook */
        return vars.actualMintAmount;
    }

    struct RedeemLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }
    /// @notice User redeems lTokens in exchange for the underlying asset
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param redeemer The address of the account which is redeeming the tokens
    /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");
        RedeemLocalVars memory vars;
        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');
        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;
            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */
            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');
            vars.redeemAmount = redeemAmountIn;
        }
        /* Fail if redeem not allowed */
        (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);
        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');
        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');
        require(getCashPrior() >= vars.redeemAmount, 'cash < redeem');
        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;
        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(redeemer, vars.redeemAmount, true);

        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);
        /* We call the defense hook */
    }
    struct BorrowLocalVars {
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }
    /// @notice Users borrow assets from the protocol to their own address
    /// @param borrowAmount The amount of the underlying asset to borrow
    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {
        /* Fail if borrow not allowed */
        (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);
        /* Fail gracefully if protocol has insufficient underlying cash */
        require(getCashPrior() >= borrowAmount, 'cash<borrow');
        BorrowLocalVars memory vars;
        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');
        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');
        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');
        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;
        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(payee, borrowAmount, false);
        /* We emit a Borrow event */
        emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);
        /* We call the defense hook */
    }
    struct RepayBorrowLocalVars {
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
        uint actualRepayAmount;
        uint badDebtsAmount;
    }
    /// @notice Borrows are repaid by another user (possibly the borrower).
    /// @param payer the account paying off the borrow
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount the amount of undelrying tokens being returned
    function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {
        /* Fail if repayBorrow not allowed */
        (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);
        RepayBorrowLocalVars memory vars;
        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;
        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');
        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(- 1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }
        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);

        if (isEnd && vars.accountBorrows > vars.actualRepayAmount) {
            vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;
        }
        /*
        *  We calculate the new borrower and total borrow balances, failing on underflow:
        *  accountBorrowsNew = accountBorrows - repayAmount
        *  totalBorrowsNew = totalBorrows - repayAmount
        */
        if (vars.accountBorrows < vars.actualRepayAmount) {
            require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) <= 105e16, 'repay more than 5%');
            vars.accountBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.accountBorrowsNew = 0;
            } else {
                vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;
            }
        }
        //Avoid mantissa errors
        if (vars.actualRepayAmount > totalBorrows) {
            vars.totalBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);
            } else {
                vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;
            }
        }
        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;
        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);
        /* We call the defense hook */
        return vars.actualRepayAmount;
    }
    /*** Admin Functions ***/
    /// @notice Sets a new CONTROLLER for the market
    /// @dev Admin function to set a new controller
    function setController(address newController) external override onlyAdmin {
        require(address(0) != newController, "0x");
        address oldController = controller;
        controller = newController;
        // Emit NewController(oldController, newController)
        emit NewController(oldController, newController);
    }
    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {
        require(newBorrowCapFactorMantissa <= 1e18, 'Factor too large');
        uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;
        borrowCapFactorMantissa = newBorrowCapFactorMantissa;
        emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa);
    }
    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {
        //accrueInterest except first
        if (baseRatePerBlock != 0) {
            accrueInterest();
        }
        // total rate perYear < 2000%
        require(baseRatePerBlock_ < 1e13, 'Base rate too large');
        baseRatePerBlock = baseRatePerBlock_;
        require(multiplierPerBlock_ < 1e13, 'Mul rate too large');
        multiplierPerBlock = multiplierPerBlock_;
        require(jumpMultiplierPerBlock_ < 1e13, 'Jump rate too large');
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        require(kink_ <= 1e18, 'Kline too large');
        kink = kink_;
        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);
    }
    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {
        require(newReserveFactorMantissa <= 1e18, 'Factor too large');
        accrueInterest();
        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;
        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);
    }
    function addReserves(uint addAmount) external override nonReentrant {
        accrueInterest();
        uint totalReservesNew;
        uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);
        totalReservesNew = totalReserves.add(actualAddAmount);
        totalReserves = totalReservesNew;
        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);
    }
    function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {
        accrueInterest();
        uint totalReservesNew;
        totalReservesNew = totalReserves.sub(reduceAmount);
        totalReserves = totalReservesNew;
        doTransferOut(to, reduceAmount, true);
        emit ReservesReduced(to, reduceAmount, totalReservesNew);
    }
    modifier sameBlock() {
        require(accrualBlockNumber == getBlockNumber(), 'not same block');
        _;
    }
}
.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;

import "./LPoolInterface.sol";
import "./LPoolDepositor.sol";
import "../lib/Exponential.sol";
import "../Adminable.sol";
import "../lib/CarefulMath.sol";
import "../lib/TransferHelper.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "../DelegateInterface.sol";
import "../ControllerInterface.sol";
import "../IWETH.sol";
/// @title OpenLeverage's LToken Contract
/// @dev Abstract base for LTokens
/// @author OpenLeverage
contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {
    using TransferHelper for IERC20;
    using SafeMath for uint;
    constructor() {
    }
    
    /// @notice Initialize the money market
    /// @param controller_ The address of the Controller
    /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0
    /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate
    /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point
    /// @param kink_ The utilization point at which the jump multiplier is applied
    /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
    /// @param name_ EIP-20 name of this token
    /// @param symbol_ EIP-20 symbol of this token
    /// @param decimals_ EIP-20 decimal precision of this token
    function initialize(
        address underlying_,
        bool isWethPool_,
        address controller_,
        uint256 baseRatePerBlock_,
        uint256 multiplierPerBlock_,
        uint256 jumpMultiplierPerBlock_,
        uint256 kink_,
        uint initialExchangeRateMantissa_,
        string memory name_,
        string memory symbol_,
        uint8 decimals_) public {
        require(underlying_ != address(0), "underlying_ address cannot be 0");
        require(controller_ != address(0), "controller_ address cannot be 0");
        require(msg.sender == admin, "Only allow to be called by admin");
        require(accrualBlockNumber == 0 && borrowIndex == 0, "inited once");
        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial Exchange Rate Mantissa should be greater zero");
        //set controller
        controller = controller_;
        isWethPool = isWethPool_;
        //set interestRateModel
        baseRatePerBlock = baseRatePerBlock_;
        multiplierPerBlock = multiplierPerBlock_;
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        kink = kink_;
        // Initialize block number and borrow index (block number mocks depend on controller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = 1e25;
        //80%
        borrowCapFactorMantissa = 0.8e18;
        //10%
        reserveFactorMantissa = 0.1e18;

        name = name_;
        symbol = symbol_;
        decimals = decimals_;
        _notEntered = true;
        // Set underlying and sanity check it
        underlying = underlying_;
        IERC20(underlying).totalSupply();
        emit Transfer(address(0), msg.sender, 0);
    }
    /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
    /// @dev Called by both `transfer` and `transferFrom` internally
    /// @param spender The address of the account performing the transfer
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param tokens The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {
        require(dst != address(0), "dst address cannot be 0");
        /* Do not allow self-transfers */
        require(src != dst, "src = dst");
        /* Fail if transfer not allowed */
        (ControllerInterface(controller)).transferAllowed(src, dst, tokens);
        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(- 1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }
        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;
        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        require(mathErr == MathError.NO_ERROR, 'not allowed');
        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        require(mathErr == MathError.NO_ERROR, 'not enough');
        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        require(mathErr == MathError.NO_ERROR, 'too much');
        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;
        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(- 1)) {
            transferAllowances[src][spender] = allowanceNew;
        }
        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);
        return true;
    }
    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount);
    }
    /// @notice Transfer `amount` tokens from `src` to `dst`
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount);
    }
    /// @notice Approve `spender` to transfer up to `amount` from `src`
    /// @dev This will overwrite the approval amount for `spender`
    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
    /// @param spender The address of the account which may transfer tokens
    /// @param amount The number of tokens that are approved (-1 means infinite)
    /// @return Whether or not the approval succeeded
    function approve(address spender, uint256 amount) external override returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }
    /// @notice Get the current allowance from `owner` for `spender`
    /// @param owner The address of the account which owns the tokens to be spent
    /// @param spender The address of the account which may transfer tokens
    /// @return The number of tokens allowed to be spent (-1 means infinite)
    function allowance(address owner, address spender) external override view returns (uint256) {
        return transferAllowances[owner][spender];
    }
    /// @notice Get the token balance of the `owner`
    /// @param owner The address of the account to query
    /// @return The number of tokens owned by `owner`
    function balanceOf(address owner) external override view returns (uint256) {
        return accountTokens[owner];
    }
    /// @notice Get the underlying balance of the `owner`
    /// @dev This also accrues interest in a transaction
    /// @param owner The address of the account to query
    /// @return The amount of underlying owned by `owner`
    function balanceOfUnderlying(address owner) external override returns (uint) {
        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR, "calc failed");
        return balance;
    }
    /*** User Interface ***/
    /// @notice Sender supplies assets into the market and receives lTokens in exchange
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param mintAmount The amount of the underlying asset to supply
    function mint(uint mintAmount) external override nonReentrant {
        accrueInterest();
        mintFresh(msg.sender, mintAmount, false);
    }
    function mintTo(address to, uint amount) external payable override nonReentrant {
        accrueInterest();
        if (isWethPool) {
            mintFresh(to, msg.value, false);
        } else {
            mintFresh(to, amount, true);
        }
    }
    function mintEth() external payable override nonReentrant {
        require(isWethPool, "not eth pool");
        accrueInterest();
        mintFresh(msg.sender, msg.value, false);
    }
    /// @notice Sender redeems lTokens in exchange for the underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemTokens The number of lTokens to redeem into underlying
    function redeem(uint redeemTokens) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, redeemTokens, 0);
    }
    /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemAmount The amount of underlying to redeem
    function redeemUnderlying(uint redeemAmount) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, 0, redeemAmount);
    }
    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {
        accrueInterest();
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        borrowFresh(payable(borrower), msg.sender, borrowAmount);
    }
    /// @notice Sender repays a borrow belonging to borrower
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount The amount to repay
    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        repayBorrowFresh(msg.sender, borrower, repayAmount, false);
    }
    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        repayBorrowFresh(msg.sender, borrower, repayAmount, true);
    }

    /*** Safe Token ***/
    /// Gets balance of this contract in terms of the underlying
    /// @dev This excludes the value of the current message, if any
    /// @return The quantity of underlying tokens owned by this contract
    function getCashPrior() internal view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }

    /**
     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.
     *      This will revert due to insufficient balance or insufficient allowance.
     *      This function returns the actual amount received,
     *      which may be less than `amount` if there is a fee attached to the transfer.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {
        if (isWethPool && convertWeth) {
            actualAmount = msg.value;
            IWETH(underlying).deposit{value : actualAmount}();
        } else {
            actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);
        }
    }
    /**
     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory
     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to
     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified
     *      it is >= amount, this should not revert in normal conditions.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {
        if (isWethPool && convertWeth) {
            IWETH(underlying).withdraw(amount);
            to.transfer(amount);
        } else {
            IERC20(underlying).safeTransfer(to, amount);
        }
    }
    function availableForBorrow() external view override returns (uint){
        uint cash = getCashPrior();
        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);
        if (err0 != MathError.NO_ERROR) {
            return 0;
        }
        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);
        if (err1 != MathError.NO_ERROR) {
            return 0;
        }
        if (totalBorrows > maxAvailable) {
            return 0;
        }
        return maxAvailable - totalBorrows;
    }

    /// @notice Get a snapshot of the account's balances, and the cached exchange rate
    /// @dev This is used by controller to more efficiently perform liquidity checks.
    /// @param account Address of the account to snapshot
    /// @return ( token balance, borrow balance, exchange rate mantissa)
    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;
        MathError mErr;
        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }
        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }
        return (cTokenBalance, borrowBalance, exchangeRateMantissa);
    }
    /// @dev Function to simply retrieve block number
    ///  This exists mainly for inheriting test contracts to stub this result.
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }
    /// @notice Returns the current per-block borrow interest rate for this cToken
    /// @return The borrow interest rate per block, scaled by 1e18
    function borrowRatePerBlock() external override view returns (uint) {
        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
    }
    
    /// @notice Returns the current per-block supply interest rate for this cToken
    /// @return The supply interest rate per block, scaled by 1e18
    function supplyRatePerBlock() external override view returns (uint) {
        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);
    }
    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {
        // Utilization rate is 0 when there are no borrows
        if (borrows == 0) {
            return 0;
        }
        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));
    }
    /// @notice Calculates the current borrow rate per block, with the error code expected by the market
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18)
    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {
        uint util = utilizationRate(cash, borrows, reserves);
        if (util <= kink) {
            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
        } else {
            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
            uint excessUtil = util.sub(kink);
            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);
        }
    }
    /// @notice Calculates the current supply rate per block
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The supply rate percentage per block as a mantissa (scaled by 1e18)
    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {
        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);
        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);
        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);
        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);
    }
    /// @notice Returns the current total borrows plus accrued interest
    /// @return The total borrows with interest
    function totalBorrowsCurrent() external override view returns (uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;
        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return totalBorrows;
        }
        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint reservesPrior = totalReserves;
        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");
        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");
        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;
        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');
        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');
        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');
        return totalBorrowsNew;
    }
    /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
    /// @param account The address whose balance should be calculated after updating borrowIndex
    /// @return The calculated balance
    function borrowBalanceCurrent(address account) external view override returns (uint) {
        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();
        require(err0 == MathError.NO_ERROR, "calc borrow index fail");
        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
        require(err1 == MathError.NO_ERROR, "calc fail");
        return result;
    }
    function borrowBalanceStored(address account) external override view returns (uint){
        return accountBorrows[account].principal;
    }

    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
    }
    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;
        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];
        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }
        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }
        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }
        return (MathError.NO_ERROR, result);
    }
    /// @notice Accrue interest then return the up-to-date exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateCurrent() public override nonReentrant returns (uint) {
        accrueInterest();
        return exchangeRateStored();
    }
    /// Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateStored() public override view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "calc fail");
        return result;
    }
    /// @notice Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return (error code, calculated exchange rate scaled by 1e18)
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        uint _totalSupply = totalSupply;
        if (_totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint _totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;
            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }
            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }
            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }
    /// @notice Get cash balance of this cToken in the underlying asset
    /// @return The quantity of underlying asset owned by this contract
    function getCash() external override view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }
    function calCurrentBorrowIndex() internal view returns (MathError, uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;
        uint borrowIndexNew;
        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return (MathError.NO_ERROR, borrowIndex);
        }
        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        Exp memory simpleInterestFactor;
        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }
        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);
        return (mathErr, borrowIndexNew);
    }
    /// @notice Applies accrued interest to total borrows and reserves
    /// @dev This calculates interest accrued from the last checkpointed block
    ///   up to the current block and writes new checkpoint to storage.
    function accrueInterest() public override {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;
        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return;
        }
        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint borrowIndexPrior = borrowIndex;
        uint reservesPrior = totalReserves;
        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");
        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");

        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */
        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;
        uint borrowIndexNew;
        uint totalReservesNew;
        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');
        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');
        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');
        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total reserves error');
        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);
        require(mathErr == MathError.NO_ERROR, 'calc borrows index error');

        /* We write the previously calculated values into storage */
        accrualBlockNumber = currentBlockNumber;
        borrowIndex = borrowIndexNew;
        totalBorrows = totalBorrowsNew;
        totalReserves = totalReservesNew;
        /* We emit an AccrueInterest event */
        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);
    }
    struct MintLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
        uint actualMintAmount;
    }
    /// @notice User supplies assets into the market and receives lTokens in exchange
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param minter The address of the account which is supplying the assets
    /// @param mintAmount The amount of the underlying asset to supply
    /// @return uint the actual mint amount.
    function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {
        MintLocalVars memory vars;
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');
        /*
         *  We call `doTransferIn` for the minter and the mintAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if
         *  side-effects occurred. The function returns the amount actually transferred,
         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`
         *  of cash.
         */
        if (isDelegete) {
            uint balanceBefore = getCashPrior();
            LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);
            uint balanceAfter = getCashPrior();
            require(balanceAfter > balanceBefore, 'mint 0');
            vars.actualMintAmount = balanceAfter - balanceBefore;
        } else {
            vars.actualMintAmount = doTransferIn(minter, mintAmount, true);
        }
        /*
         * We get the current exchange rate and calculate the number of lTokens to be minted:
         *  mintTokens = actualMintAmount / exchangeRate
         */
        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));
        require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");
        /* Fail if mint not allowed */
        (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);
        /*
         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");
        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");
        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;
        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);
        /* We call the defense hook */
        return vars.actualMintAmount;
    }

    struct RedeemLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }
    /// @notice User redeems lTokens in exchange for the underlying asset
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param redeemer The address of the account which is redeeming the tokens
    /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");
        RedeemLocalVars memory vars;
        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');
        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;
            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */
            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');
            vars.redeemAmount = redeemAmountIn;
        }
        /* Fail if redeem not allowed */
        (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);
        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');
        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');
        require(getCashPrior() >= vars.redeemAmount, 'cash < redeem');
        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;
        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(redeemer, vars.redeemAmount, true);

        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);
        /* We call the defense hook */
    }
    struct BorrowLocalVars {
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }
    /// @notice Users borrow assets from the protocol to their own address
    /// @param borrowAmount The amount of the underlying asset to borrow
    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {
        /* Fail if borrow not allowed */
        (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);
        /* Fail gracefully if protocol has insufficient underlying cash */
        require(getCashPrior() >= borrowAmount, 'cash<borrow');
        BorrowLocalVars memory vars;
        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');
        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');
        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');
        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;
        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(payee, borrowAmount, false);
        /* We emit a Borrow event */
        emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);
        /* We call the defense hook */
    }
    struct RepayBorrowLocalVars {
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
        uint actualRepayAmount;
        uint badDebtsAmount;
    }
    /// @notice Borrows are repaid by another user (possibly the borrower).
    /// @param payer the account paying off the borrow
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount the amount of undelrying tokens being returned
    function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {
        /* Fail if repayBorrow not allowed */
        (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);
        RepayBorrowLocalVars memory vars;
        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;
        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');
        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(- 1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }
        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);

        if (isEnd && vars.accountBorrows > vars.actualRepayAmount) {
            vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;
        }
        /*
        *  We calculate the new borrower and total borrow balances, failing on underflow:
        *  accountBorrowsNew = accountBorrows - repayAmount
        *  totalBorrowsNew = totalBorrows - repayAmount
        */
        if (vars.accountBorrows < vars.actualRepayAmount) {
            require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) <= 105e16, 'repay more than 5%');
            vars.accountBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.accountBorrowsNew = 0;
            } else {
                vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;
            }
        }
        //Avoid mantissa errors
        if (vars.actualRepayAmount > totalBorrows) {
            vars.totalBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);
            } else {
                vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;
            }
        }
        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;
        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);
        /* We call the defense hook */
        return vars.actualRepayAmount;
    }
    /*** Admin Functions ***/
    /// @notice Sets a new CONTROLLER for the market
    /// @dev Admin function to set a new controller
    function setController(address newController) external override onlyAdmin {
        require(address(0) != newController, "0x");
        address oldController = controller;
        controller = newController;
        // Emit NewController(oldController, newController)
        emit NewController(oldController, newController);
    }
    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {
        require(newBorrowCapFactorMantissa <= 1e18, 'Factor too large');
        uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;
        borrowCapFactorMantissa = newBorrowCapFactorMantissa;
        emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa);
    }
    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {
        //accrueInterest except first
        if (baseRatePerBlock != 0) {
            accrueInterest();
        }
        // total rate perYear < 2000%
        require(baseRatePerBlock_ < 1e13, 'Base rate too large');
        baseRatePerBlock = baseRatePerBlock_;
        require(multiplierPerBlock_ < 1e13, 'Mul rate too large');
        multiplierPerBlock = multiplierPerBlock_;
        require(jumpMultiplierPerBlock_ < 1e13, 'Jump rate too large');
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        require(kink_ <= 1e18, 'Kline too large');
        kink = kink_;
        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);
    }
    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {
        require(newReserveFactorMantissa <= 1e18, 'Factor too large');
        accrueInterest();
        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;
        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);
    }
    function addReserves(uint addAmount) external override nonReentrant {
        accrueInterest();
        uint totalReservesNew;
        uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);
        totalReservesNew = totalReserves.add(actualAddAmount);
        totalReserves = totalReservesNew;
        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);
    }
    function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {
        accrueInterest();
        uint totalReservesNew;
        totalReservesNew = totalReserves.sub(reduceAmount);
        totalReserves = totalReservesNew;
        doTransferOut(to, reduceAmount, true);
        emit ReservesReduced(to, reduceAmount, totalReservesNew);
    }
    modifier sameBlock() {
        require(accrualBlockNumber == getBlockNumber(), 'not same block');
        _;
    }
}
".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Let's Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-24-08 19:28:01 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-24-08 19:28:01 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 29893
completion_tokens: 1
total_tokens: 29894
cost: $-1.000000


[2024-24-08 19:28:01 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;


import "./LPoolInterface.sol";
import "./LPoolDepositor.sol";
import "../lib/Exponential.sol";
import "../Adminable.sol";
import "../lib/CarefulMath.sol";
import "../lib/TransferHelper.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import "../DelegateInterface.sol";
import "../ControllerInterface.sol";
import "../IWETH.sol";

/// @title OpenLeverage's LToken Contract
/// @dev Abstract base for LTokens
/// @author OpenLeverage
contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {
    using TransferHelper for IERC20;
    using SafeMath for uint;

    constructor() {

    }
    
    /// @notice Initialize the money market
    /// @param controller_ The address of the Controller
    /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0
    /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate
    /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point
    /// @param kink_ The utilization point at which the jump multiplier is applied
    /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
    /// @param name_ EIP-20 name of this token
    /// @param symbol_ EIP-20 symbol of this token
    /// @param decimals_ EIP-20 decimal precision of this token
    function initialize(
        address underlying_,
        bool isWethPool_,
        address controller_,
        uint256 baseRatePerBlock_,
        uint256 multiplierPerBlock_,
        uint256 jumpMultiplierPerBlock_,
        uint256 kink_,
        uint initialExchangeRateMantissa_,
        string memory name_,
        string memory symbol_,
        uint8 decimals_) public {
        require(underlying_ != address(0), "underlying_ address cannot be 0");
        require(controller_ != address(0), "controller_ address cannot be 0");
        require(msg.sender == admin, "Only allow to be called by admin");
        require(accrualBlockNumber == 0 && borrowIndex == 0, "inited once");

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial Exchange Rate Mantissa should be greater zero");
        //set controller
        controller = controller_;
        isWethPool = isWethPool_;
        //set interestRateModel
        baseRatePerBlock = baseRatePerBlock_;
        multiplierPerBlock = multiplierPerBlock_;
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        kink = kink_;

        // Initialize block number and borrow index (block number mocks depend on controller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = 1e25;
        //80%
        borrowCapFactorMantissa = 0.8e18;
        //10%
        reserveFactorMantissa = 0.1e18;


        name = name_;
        symbol = symbol_;
        decimals = decimals_;

        _notEntered = true;

        // Set underlying and sanity check it
        underlying = underlying_;
        IERC20(underlying).totalSupply();
        emit Transfer(address(0), msg.sender, 0);
    }

    /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
    /// @dev Called by both `transfer` and `transferFrom` internally
    /// @param spender The address of the account performing the transfer
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param tokens The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {
        require(dst != address(0), "dst address cannot be 0");
        /* Do not allow self-transfers */
        require(src != dst, "src = dst");
        /* Fail if transfer not allowed */
        (ControllerInterface(controller)).transferAllowed(src, dst, tokens);

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(- 1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        require(mathErr == MathError.NO_ERROR, 'not allowed');

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        require(mathErr == MathError.NO_ERROR, 'not enough');

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        require(mathErr == MathError.NO_ERROR, 'too much');

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(- 1)) {
            transferAllowances[src][spender] = allowanceNew;
        }
        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);
        return true;
    }

    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount);
    }

    /// @notice Transfer `amount` tokens from `src` to `dst`
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount);
    }

    /// @notice Approve `spender` to transfer up to `amount` from `src`
    /// @dev This will overwrite the approval amount for `spender`
    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
    /// @param spender The address of the account which may transfer tokens
    /// @param amount The number of tokens that are approved (-1 means infinite)
    /// @return Whether or not the approval succeeded
    function approve(address spender, uint256 amount) external override returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /// @notice Get the current allowance from `owner` for `spender`
    /// @param owner The address of the account which owns the tokens to be spent
    /// @param spender The address of the account which may transfer tokens
    /// @return The number of tokens allowed to be spent (-1 means infinite)
    function allowance(address owner, address spender) external override view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /// @notice Get the token balance of the `owner`
    /// @param owner The address of the account to query
    /// @return The number of tokens owned by `owner`
    function balanceOf(address owner) external override view returns (uint256) {
        return accountTokens[owner];
    }

    /// @notice Get the underlying balance of the `owner`
    /// @dev This also accrues interest in a transaction
    /// @param owner The address of the account to query
    /// @return The amount of underlying owned by `owner`
    function balanceOfUnderlying(address owner) external override returns (uint) {
        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR, "calc failed");
        return balance;
    }

    /*** User Interface ***/

    /// @notice Sender supplies assets into the market and receives lTokens in exchange
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param mintAmount The amount of the underlying asset to supply
    function mint(uint mintAmount) external override nonReentrant {
        accrueInterest();
        mintFresh(msg.sender, mintAmount, false);
    }

    function mintTo(address to, uint amount) external payable override nonReentrant {
        accrueInterest();
        if (isWethPool) {
            mintFresh(to, msg.value, false);
        } else {
            mintFresh(to, amount, true);
        }
    }

    function mintEth() external payable override nonReentrant {
        require(isWethPool, "not eth pool");
        accrueInterest();
        mintFresh(msg.sender, msg.value, false);
    }

    /// @notice Sender redeems lTokens in exchange for the underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemTokens The number of lTokens to redeem into underlying
    function redeem(uint redeemTokens) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, redeemTokens, 0);
    }

    /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemAmount The amount of underlying to redeem
    function redeemUnderlying(uint redeemAmount) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, 0, redeemAmount);
    }

    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {
        accrueInterest();
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        borrowFresh(payable(borrower), msg.sender, borrowAmount);
    }

    /// @notice Sender repays a borrow belonging to borrower
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount The amount to repay
    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        repayBorrowFresh(msg.sender, borrower, repayAmount, false);
    }

    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        repayBorrowFresh(msg.sender, borrower, repayAmount, true);
    }


    /*** Safe Token ***/

    /// Gets balance of this contract in terms of the underlying
    /// @dev This excludes the value of the current message, if any
    /// @return The quantity of underlying tokens owned by this contract
    function getCashPrior() internal view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }


    /**
     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.
     *      This will revert due to insufficient balance or insufficient allowance.
     *      This function returns the actual amount received,
     *      which may be less than `amount` if there is a fee attached to the transfer.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {
        if (isWethPool && convertWeth) {
            actualAmount = msg.value;
            IWETH(underlying).deposit{value : actualAmount}();
        } else {
            actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);
        }
    }

    /**
     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory
     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to
     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified
     *      it is >= amount, this should not revert in normal conditions.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {
        if (isWethPool && convertWeth) {
            IWETH(underlying).withdraw(amount);
            to.transfer(amount);
        } else {
            IERC20(underlying).safeTransfer(to, amount);
        }
    }

    function availableForBorrow() external view override returns (uint){
        uint cash = getCashPrior();
        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);
        if (err0 != MathError.NO_ERROR) {
            return 0;
        }
        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);
        if (err1 != MathError.NO_ERROR) {
            return 0;
        }
        if (totalBorrows > maxAvailable) {
            return 0;
        }
        return maxAvailable - totalBorrows;
    }


    /// @notice Get a snapshot of the account's balances, and the cached exchange rate
    /// @dev This is used by controller to more efficiently perform liquidity checks.
    /// @param account Address of the account to snapshot
    /// @return ( token balance, borrow balance, exchange rate mantissa)
    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        return (cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /// @dev Function to simply retrieve block number
    ///  This exists mainly for inheriting test contracts to stub this result.
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /// @notice Returns the current per-block borrow interest rate for this cToken
    /// @return The borrow interest rate per block, scaled by 1e18
    function borrowRatePerBlock() external override view returns (uint) {
        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
    }

    
    /// @notice Returns the current per-block supply interest rate for this cToken
    /// @return The supply interest rate per block, scaled by 1e18
    function supplyRatePerBlock() external override view returns (uint) {
        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);
    }

    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {
        // Utilization rate is 0 when there are no borrows
        if (borrows == 0) {
            return 0;
        }
        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));
    }

    /// @notice Calculates the current borrow rate per block, with the error code expected by the market
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18)
    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {
        uint util = utilizationRate(cash, borrows, reserves);
        if (util <= kink) {
            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
        } else {
            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
            uint excessUtil = util.sub(kink);
            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);
        }
    }

    /// @notice Calculates the current supply rate per block
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The supply rate percentage per block as a mantissa (scaled by 1e18)
    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {
        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);
        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);
        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);
        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);
    }

    /// @notice Returns the current total borrows plus accrued interest
    /// @return The total borrows with interest
    function totalBorrowsCurrent() external override view returns (uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return totalBorrows;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        return totalBorrowsNew;
    }

    /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
    /// @param account The address whose balance should be calculated after updating borrowIndex
    /// @return The calculated balance
    function borrowBalanceCurrent(address account) external view override returns (uint) {
        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();
        require(err0 == MathError.NO_ERROR, "calc borrow index fail");
        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
        require(err1 == MathError.NO_ERROR, "calc fail");
        return result;
    }

    function borrowBalanceStored(address account) external override view returns (uint){
        return accountBorrows[account].principal;
    }


    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
    }

    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /// @notice Accrue interest then return the up-to-date exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateCurrent() public override nonReentrant returns (uint) {
        accrueInterest();
        return exchangeRateStored();
    }

    /// Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateStored() public override view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "calc fail");
        return result;
    }

    /// @notice Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return (error code, calculated exchange rate scaled by 1e18)
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        uint _totalSupply = totalSupply;
        if (_totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint _totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /// @notice Get cash balance of this cToken in the underlying asset
    /// @return The quantity of underlying asset owned by this contract
    function getCash() external override view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }

    function calCurrentBorrowIndex() internal view returns (MathError, uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;
        uint borrowIndexNew;
        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return (MathError.NO_ERROR, borrowIndex);
        }
        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);

        Exp memory simpleInterestFactor;
        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }
        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);
        return (mathErr, borrowIndexNew);
    }

    /// @notice Applies accrued interest to total borrows and reserves
    /// @dev This calculates interest accrued from the last checkpointed block
    ///   up to the current block and writes new checkpoint to storage.
    function accrueInterest() public override {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint borrowIndexPrior = borrowIndex;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");


        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;
        uint borrowIndexNew;
        uint totalReservesNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total reserves error');

        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);
        require(mathErr == MathError.NO_ERROR, 'calc borrows index error');


        /* We write the previously calculated values into storage */
        accrualBlockNumber = currentBlockNumber;
        borrowIndex = borrowIndexNew;
        totalBorrows = totalBorrowsNew;
        totalReserves = totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);

    }

    struct MintLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
        uint actualMintAmount;
    }

    /// @notice User supplies assets into the market and receives lTokens in exchange
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param minter The address of the account which is supplying the assets
    /// @param mintAmount The amount of the underlying asset to supply
    /// @return uint the actual mint amount.
    function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {
        MintLocalVars memory vars;
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /*
         *  We call `doTransferIn` for the minter and the mintAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if
         *  side-effects occurred. The function returns the amount actually transferred,
         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`
         *  of cash.
         */
        if (isDelegete) {
            uint balanceBefore = getCashPrior();
            LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);
            uint balanceAfter = getCashPrior();
            require(balanceAfter > balanceBefore, 'mint 0');
            vars.actualMintAmount = balanceAfter - balanceBefore;
        } else {
            vars.actualMintAmount = doTransferIn(minter, mintAmount, true);
        }
        /*
         * We get the current exchange rate and calculate the number of lTokens to be minted:
         *  mintTokens = actualMintAmount / exchangeRate
         */

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));
        require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");

        /* Fail if mint not allowed */
        (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);
        /*
         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */

        return vars.actualMintAmount;
    }


    struct RedeemLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /// @notice User redeems lTokens in exchange for the underlying asset
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param redeemer The address of the account which is redeeming the tokens
    /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');
            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');
        require(getCashPrior() >= vars.redeemAmount, 'cash < redeem');

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;
        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(redeemer, vars.redeemAmount, true);


        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
    }

    struct BorrowLocalVars {
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /// @notice Users borrow assets from the protocol to their own address
    /// @param borrowAmount The amount of the underlying asset to borrow
    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {
        /* Fail if borrow not allowed */
        (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);

        /* Fail gracefully if protocol has insufficient underlying cash */
        require(getCashPrior() >= borrowAmount, 'cash<borrow');

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(payee, borrowAmount, false);

        /* We emit a Borrow event */
        emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
    }

    struct RepayBorrowLocalVars {
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
        uint actualRepayAmount;
        uint badDebtsAmount;
    }

    /// @notice Borrows are repaid by another user (possibly the borrower).
    /// @param payer the account paying off the borrow
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount the amount of undelrying tokens being returned
    function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {
        /* Fail if repayBorrow not allowed */
        (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(- 1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }
        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);


        if (isEnd && vars.accountBorrows > vars.actualRepayAmount) {
            vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;
        }

        /*
        *  We calculate the new borrower and total borrow balances, failing on underflow:
        *  accountBorrowsNew = accountBorrows - repayAmount
        *  totalBorrowsNew = totalBorrows - repayAmount
        */
        if (vars.accountBorrows < vars.actualRepayAmount) {
            require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) <= 105e16, 'repay more than 5%');
            vars.accountBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.accountBorrowsNew = 0;
            } else {
                vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;
            }
        }
        //Avoid mantissa errors
        if (vars.actualRepayAmount > totalBorrows) {
            vars.totalBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);
            } else {
                vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;
            }
        }

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */

        return vars.actualRepayAmount;
    }

    /*** Admin Functions ***/

    /// @notice Sets a new CONTROLLER for the market
    /// @dev Admin function to set a new controller
    function setController(address newController) external override onlyAdmin {
        require(address(0) != newController, "0x");
        address oldController = controller;
        controller = newController;
        // Emit NewController(oldController, newController)
        emit NewController(oldController, newController);
    }

    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {
        require(newBorrowCapFactorMantissa <= 1e18, 'Factor too large');
        uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;
        borrowCapFactorMantissa = newBorrowCapFactorMantissa;
        emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa);
    }

    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {
        //accrueInterest except first
        if (baseRatePerBlock != 0) {
            accrueInterest();
        }
        // total rate perYear < 2000%
        require(baseRatePerBlock_ < 1e13, 'Base rate too large');
        baseRatePerBlock = baseRatePerBlock_;
        require(multiplierPerBlock_ < 1e13, 'Mul rate too large');
        multiplierPerBlock = multiplierPerBlock_;
        require(jumpMultiplierPerBlock_ < 1e13, 'Jump rate too large');
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        require(kink_ <= 1e18, 'Kline too large');
        kink = kink_;
        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);
    }

    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {
        require(newReserveFactorMantissa <= 1e18, 'Factor too large');
        accrueInterest();
        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;
        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);
    }

    function addReserves(uint addAmount) external override nonReentrant {
        accrueInterest();
        uint totalReservesNew;
        uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);
        totalReservesNew = totalReserves.add(actualAddAmount);
        totalReserves = totalReservesNew;
        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);
    }

    function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {
        accrueInterest();
        uint totalReservesNew;
        totalReservesNew = totalReserves.sub(reduceAmount);
        totalReserves = totalReservesNew;
        doTransferOut(to, reduceAmount, true);
        emit ReservesReduced(to, reduceAmount, totalReservesNew);
    }

    modifier sameBlock() {
        require(accrualBlockNumber == getBlockNumber(), 'not same block');
        _;
    }
}

.]

Security

[2024-24-08 19:28:01 INFO] **[Seminar Conclusion]**:

 Security

[2024-24-08 19:28:01 INFO] **[Seminar Conclusion]**:

 <INFO> Security

[2024-24-08 19:28:01 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-24-08 19:28:02 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.7.6; import "./LPoolInterface.sol"; import "./LPoolDepositor.sol"; import "../lib/Exponential.sol"; import "../Adminable.sol"; import "../lib/CarefulMath.sol"; import "../lib/TransferHelper.sol"; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import "../DelegateInterface.sol"; import "../ControllerInterface.sol"; import "../IWETH.sol"; /// @title OpenLeverage's LToken Contract /// @dev Abstract base for LTokens /// @author OpenLeverage contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {     using TransferHelper for IERC20;     using SafeMath for uint; constructor() {  }  /// @notice Initialize the money market /// @param controller_ The address of the Controller /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0 /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point /// @param kink_ The utilization point at which the jump multiplier is applied /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18 /// @param name_ EIP-20 name of this token /// @param symbol_ EIP-20 symbol of this token /// @param decimals_ EIP-20 decimal precision of this token function initialize(     address underlying_,     bool isWethPool_,     address controller_,     uint256 baseRatePerBlock_,     uint256 multiplierPerBlock_,     uint256 jumpMultiplierPerBlock_,     uint256 kink_,     uint initialExchangeRateMantissa_,     string memory name_,     string memory symbol_,     uint8 decimals_) public {     require(underlying_ != address(0), "underlying_ address cannot be 0");     require(controller_ != address(0), "controller_ address cannot be 0");     require(msg.sender == admin, "Only allow to be called by admin");     require(accrualBlockNumber == 0 &amp;&amp; borrowIndex == 0, "inited once");      // Set initial exchange rate     initialExchangeRateMantissa = initialExchangeRateMantissa_;     require(initialExchangeRateMantissa &gt; 0, "Initial Exchange Rate Mantissa should be greater zero");     //set controller     controller = controller_;     isWethPool = isWethPool_;     //set interestRateModel     baseRatePerBlock = baseRatePerBlock_;     multiplierPerBlock = multiplierPerBlock_;     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     kink = kink_;      // Initialize block number and borrow index (block number mocks depend on controller being set)     accrualBlockNumber = getBlockNumber();     borrowIndex = 1e25;     //80%     borrowCapFactorMantissa = 0.8e18;     //10%     reserveFactorMantissa = 0.1e18;       name = name_;     symbol = symbol_;     decimals = decimals_;      _notEntered = true;      // Set underlying and sanity check it     underlying = underlying_;     IERC20(underlying).totalSupply();     emit Transfer(address(0), msg.sender, 0); }  /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender` /// @dev Called by both `transfer` and `transferFrom` internally /// @param spender The address of the account performing the transfer /// @param src The address of the source account /// @param dst The address of the destination account /// @param tokens The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {     require(dst != address(0), "dst address cannot be 0");     /* Do not allow self-transfers */     require(src != dst, "src = dst");     /* Fail if transfer not allowed */     (ControllerInterface(controller)).transferAllowed(src, dst, tokens);      /* Get the allowance, infinite for the account owner */     uint startingAllowance = 0;     if (spender == src) {         startingAllowance = uint(- 1);     } else {         startingAllowance = transferAllowances[src][spender];     }      /* Do the calculations, checking for {under,over}flow */     MathError mathErr;     uint allowanceNew;     uint srcTokensNew;     uint dstTokensNew;      (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);     require(mathErr == MathError.NO_ERROR, 'not allowed');      (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);     require(mathErr == MathError.NO_ERROR, 'not enough');      (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);     require(mathErr == MathError.NO_ERROR, 'too much');      accountTokens[src] = srcTokensNew;     accountTokens[dst] = dstTokensNew;      /* Eat some of the allowance (if necessary) */     if (startingAllowance != uint(- 1)) {         transferAllowances[src][spender] = allowanceNew;     }     /* We emit a Transfer event */     emit Transfer(src, dst, tokens);     return true; }  /// @notice Transfer `amount` tokens from `msg.sender` to `dst` /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, msg.sender, dst, amount); }  /// @notice Transfer `amount` tokens from `src` to `dst` /// @param src The address of the source account /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, src, dst, amount); }  /// @notice Approve `spender` to transfer up to `amount` from `src` /// @dev This will overwrite the approval amount for `spender` ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve) /// @param spender The address of the account which may transfer tokens /// @param amount The number of tokens that are approved (-1 means infinite) /// @return Whether or not the approval succeeded function approve(address spender, uint256 amount) external override returns (bool) {     address src = msg.sender;     transferAllowances[src][spender] = amount;     emit Approval(src, spender, amount);     return true; }  /// @notice Get the current allowance from `owner` for `spender` /// @param owner The address of the account which owns the tokens to be spent /// @param spender The address of the account which may transfer tokens /// @return The number of tokens allowed to be spent (-1 means infinite) function allowance(address owner, address spender) external override view returns (uint256) {     return transferAllowances[owner][spender]; }  /// @notice Get the token balance of the `owner` /// @param owner The address of the account to query /// @return The number of tokens owned by `owner` function balanceOf(address owner) external override view returns (uint256) {     return accountTokens[owner]; }  /// @notice Get the underlying balance of the `owner` /// @dev This also accrues interest in a transaction /// @param owner The address of the account to query /// @return The amount of underlying owned by `owner` function balanceOfUnderlying(address owner) external override returns (uint) {     Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});     (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);     require(mErr == MathError.NO_ERROR, "calc failed");     return balance; }  /*** User Interface ***/  /// @notice Sender supplies assets into the market and receives lTokens in exchange /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param mintAmount The amount of the underlying asset to supply function mint(uint mintAmount) external override nonReentrant {     accrueInterest();     mintFresh(msg.sender, mintAmount, false); }  function mintTo(address to, uint amount) external payable override nonReentrant {     accrueInterest();     if (isWethPool) {         mintFresh(to, msg.value, false);     } else {         mintFresh(to, amount, true);     } }  function mintEth() external payable override nonReentrant {     require(isWethPool, "not eth pool");     accrueInterest();     mintFresh(msg.sender, msg.value, false); }  /// @notice Sender redeems lTokens in exchange for the underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemTokens The number of lTokens to redeem into underlying function redeem(uint redeemTokens) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, redeemTokens, 0); }  /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemAmount The amount of underlying to redeem function redeemUnderlying(uint redeemAmount) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, 0, redeemAmount); }  function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {     accrueInterest();     // borrowFresh emits borrow-specific logs on errors, so we don't need to     borrowFresh(payable(borrower), msg.sender, borrowAmount); }  /// @notice Sender repays a borrow belonging to borrower /// @param borrower the account with the debt being payed off /// @param repayAmount The amount to repay function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     repayBorrowFresh(msg.sender, borrower, repayAmount, false); }  function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     repayBorrowFresh(msg.sender, borrower, repayAmount, true); }   /*** Safe Token ***/  /// Gets balance of this contract in terms of the underlying /// @dev This excludes the value of the current message, if any /// @return The quantity of underlying tokens owned by this contract function getCashPrior() internal view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }   /**  * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.  *      This will revert due to insufficient balance or insufficient allowance.  *      This function returns the actual amount received,  *      which may be less than `amount` if there is a fee attached to the transfer.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {     if (isWethPool &amp;&amp; convertWeth) {         actualAmount = msg.value;         IWETH(underlying).deposit{value : actualAmount}();     } else {         actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);     } }  /**  * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory  *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to  *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified  *      it is &gt;= amount, this should not revert in normal conditions.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferOut(address payable to, uint amount, bool convertWeth) internal {     if (isWethPool &amp;&amp; convertWeth) {         IWETH(underlying).withdraw(amount);         to.transfer(amount);     } else {         IERC20(underlying).safeTransfer(to, amount);     } }  function availableForBorrow() external view override returns (uint){     uint cash = getCashPrior();     (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);     if (err0 != MathError.NO_ERROR) {         return 0;     }     (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);     if (err1 != MathError.NO_ERROR) {         return 0;     }     if (totalBorrows &gt; maxAvailable) {         return 0;     }     return maxAvailable - totalBorrows; }   /// @notice Get a snapshot of the account's balances, and the cached exchange rate /// @dev This is used by controller to more efficiently perform liquidity checks. /// @param account Address of the account to snapshot /// @return ( token balance, borrow balance, exchange rate mantissa) function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {     uint cTokenBalance = accountTokens[account];     uint borrowBalance;     uint exchangeRateMantissa;      MathError mErr;      (mErr, borrowBalance) = borrowBalanceStoredInternal(account);     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      return (cTokenBalance, borrowBalance, exchangeRateMantissa); }  /// @dev Function to simply retrieve block number ///  This exists mainly for inheriting test contracts to stub this result. function getBlockNumber() internal view returns (uint) {     return block.number; }  /// @notice Returns the current per-block borrow interest rate for this cToken /// @return The borrow interest rate per block, scaled by 1e18 function borrowRatePerBlock() external override view returns (uint) {     return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves); }   /// @notice Returns the current per-block supply interest rate for this cToken /// @return The supply interest rate per block, scaled by 1e18 function supplyRatePerBlock() external override view returns (uint) {     return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa); }  function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {     // Utilization rate is 0 when there are no borrows     if (borrows == 0) {         return 0;     }     return borrows.mul(1e18).div(cash.add(borrows).sub(reserves)); }  /// @notice Calculates the current borrow rate per block, with the error code expected by the market /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18) function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {     uint util = utilizationRate(cash, borrows, reserves);     if (util &lt;= kink) {         return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);     } else {         uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);         uint excessUtil = util.sub(kink);         return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);     } }  /// @notice Calculates the current supply rate per block /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The supply rate percentage per block as a mantissa (scaled by 1e18) function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {     uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);     uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);     uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);     return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18); }  /// @notice Returns the current total borrows plus accrued interest /// @return The total borrows with interest function totalBorrowsCurrent() external override view returns (uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return totalBorrows;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, "calc block delta erro");      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      return totalBorrowsNew; }  /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex /// @param account The address whose balance should be calculated after updating borrowIndex /// @return The calculated balance function borrowBalanceCurrent(address account) external view override returns (uint) {     (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();     require(err0 == MathError.NO_ERROR, "calc borrow index fail");     (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);     require(err1 == MathError.NO_ERROR, "calc fail");     return result; }  function borrowBalanceStored(address account) external override view returns (uint){     return accountBorrows[account].principal; }   /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {     return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex); }  /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {     /* Note: we do not assert that the market is up to date */     MathError mathErr;     uint principalTimesIndex;     uint result;      /* Get borrowBalance and borrowIndex */     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];      /* If borrowBalance = 0 then borrowIndex is likely also 0.      * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.      */     if (borrowSnapshot.principal == 0) {         return (MathError.NO_ERROR, 0);     }      /* Calculate new borrow balance using the interest index:      *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex      */     (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      return (MathError.NO_ERROR, result); }  /// @notice Accrue interest then return the up-to-date exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateCurrent() public override nonReentrant returns (uint) {     accrueInterest();     return exchangeRateStored(); }  /// Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateStored() public override view returns (uint) {     (MathError err, uint result) = exchangeRateStoredInternal();     require(err == MathError.NO_ERROR, "calc fail");     return result; }  /// @notice Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return (error code, calculated exchange rate scaled by 1e18) function exchangeRateStoredInternal() internal view returns (MathError, uint) {     uint _totalSupply = totalSupply;     if (_totalSupply == 0) {         /*          * If there are no tokens minted:          *  exchangeRate = initialExchangeRate          */         return (MathError.NO_ERROR, initialExchangeRateMantissa);     } else {         /*          * Otherwise:          *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply          */         uint _totalCash = getCashPrior();         uint cashPlusBorrowsMinusReserves;         Exp memory exchangeRate;         MathError mathErr;          (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          return (MathError.NO_ERROR, exchangeRate.mantissa);     } }  /// @notice Get cash balance of this cToken in the underlying asset /// @return The quantity of underlying asset owned by this contract function getCash() external override view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }  function calCurrentBorrowIndex() internal view returns (MathError, uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;     uint borrowIndexNew;     /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return (MathError.NO_ERROR, borrowIndex);     }     uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);      Exp memory simpleInterestFactor;     (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }     (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);     return (mathErr, borrowIndexNew); }  /// @notice Applies accrued interest to total borrows and reserves /// @dev This calculates interest accrued from the last checkpointed block ///   up to the current block and writes new checkpoint to storage. function accrueInterest() public override {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint borrowIndexPrior = borrowIndex;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, "calc block delta erro");       /*      * Calculate the interest accumulated into borrows and reserves and the new index:      *  simpleInterestFactor = borrowRate * blockDelta      *  interestAccumulated = simpleInterestFactor * totalBorrows      *  totalBorrowsNew = interestAccumulated + totalBorrows      *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex      */      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;     uint borrowIndexNew;     uint totalReservesNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);     require(mathErr == MathError.NO_ERROR, 'calc total reserves error');      (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);     require(mathErr == MathError.NO_ERROR, 'calc borrows index error');       /* We write the previously calculated values into storage */     accrualBlockNumber = currentBlockNumber;     borrowIndex = borrowIndexNew;     totalBorrows = totalBorrowsNew;     totalReserves = totalReservesNew;      /* We emit an AccrueInterest event */     emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);  }  struct MintLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint mintTokens;     uint totalSupplyNew;     uint accountTokensNew;     uint actualMintAmount; }  /// @notice User supplies assets into the market and receives lTokens in exchange /// @dev Assumes interest has already been accrued up to the current block /// @param minter The address of the account which is supplying the assets /// @param mintAmount The amount of the underlying asset to supply /// @return uint the actual mint amount. function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {     MintLocalVars memory vars;     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /*      *  We call `doTransferIn` for the minter and the mintAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if      *  side-effects occurred. The function returns the amount actually transferred,      *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`      *  of cash.      */     if (isDelegete) {         uint balanceBefore = getCashPrior();         LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);         uint balanceAfter = getCashPrior();         require(balanceAfter &gt; balanceBefore, 'mint 0');         vars.actualMintAmount = balanceAfter - balanceBefore;     } else {         vars.actualMintAmount = doTransferIn(minter, mintAmount, true);     }     /*      * We get the current exchange rate and calculate the number of lTokens to be minted:      *  mintTokens = actualMintAmount / exchangeRate      */      (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));     require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");      /* Fail if mint not allowed */     (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);     /*      * We calculate the new total supply of lTokens and minter token balance, checking for overflow:      *  totalSupplyNew = totalSupply + mintTokens      *  accountTokensNew = accountTokens[minter] + mintTokens      */     (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");      (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[minter] = vars.accountTokensNew;      /* We emit a Mint event, and a Transfer event */     emit Mint(minter, vars.actualMintAmount, vars.mintTokens);     emit Transfer(address(this), minter, vars.mintTokens);      /* We call the defense hook */      return vars.actualMintAmount; }   struct RedeemLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint redeemTokens;     uint redeemAmount;     uint totalSupplyNew;     uint accountTokensNew; }  /// @notice User redeems lTokens in exchange for the underlying asset /// @dev Assumes interest has already been accrued up to the current block /// @param redeemer The address of the account which is redeeming the tokens /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero) /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero) function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {     require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");      RedeemLocalVars memory vars;      /* exchangeRate = invoke Exchange Rate Stored() */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /* If redeemTokensIn &gt; 0: */     if (redeemTokensIn &gt; 0) {         /*          * We calculate the exchange rate and the amount of underlying to be redeemed:          *  redeemTokens = redeemTokensIn          *  redeemAmount = redeemTokensIn x exchangeRateCurrent          */         vars.redeemTokens = redeemTokensIn;          (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');     } else {         /*          * We get the current exchange rate and calculate the amount to be redeemed:          *  redeemTokens = redeemAmountIn / exchangeRate          *  redeemAmount = redeemAmountIn          */          (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');         vars.redeemAmount = redeemAmountIn;     }      /* Fail if redeem not allowed */     (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);      /*      * We calculate the new total supply and redeemer balance, checking for underflow:      *  totalSupplyNew = totalSupply - redeemTokens      *  accountTokensNew = accountTokens[redeemer] - redeemTokens      */     (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');      (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');     require(getCashPrior() &gt;= vars.redeemAmount, 'cash &lt; redeem');      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[redeemer] = vars.accountTokensNew;     /*      * We invoke doTransferOut for the redeemer and the redeemAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken has redeemAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(redeemer, vars.redeemAmount, true);       /* We emit a Transfer event, and a Redeem event */     emit Transfer(redeemer, address(this), vars.redeemTokens);     emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);      /* We call the defense hook */ }  struct BorrowLocalVars {     MathError mathErr;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /// @notice Users borrow assets from the protocol to their own address /// @param borrowAmount The amount of the underlying asset to borrow function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {     /* Fail if borrow not allowed */     (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);      /* Fail gracefully if protocol has insufficient underlying cash */     require(getCashPrior() &gt;= borrowAmount, 'cash&lt;borrow');      BorrowLocalVars memory vars;      /*      * We calculate the new borrower and total borrow balances, failing on overflow:      *  accountBorrowsNew = accountBorrows + borrowAmount      *  totalBorrowsNew = totalBorrows + borrowAmount      */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /*      * We invoke doTransferOut for the borrower and the borrowAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken borrowAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(payee, borrowAmount, false);      /* We emit a Borrow event */     emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */ }  struct RepayBorrowLocalVars {     MathError mathErr;     uint repayAmount;     uint borrowerIndex;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew;     uint actualRepayAmount;     uint badDebtsAmount; }  /// @notice Borrows are repaid by another user (possibly the borrower). /// @param payer the account paying off the borrow /// @param borrower the account with the debt being payed off /// @param repayAmount the amount of undelrying tokens being returned function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {     /* Fail if repayBorrow not allowed */     (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);      RepayBorrowLocalVars memory vars;      /* We remember the original borrowerIndex for verification purposes */     vars.borrowerIndex = accountBorrows[borrower].interestIndex;      /* We fetch the amount the borrower owes, with accumulated interest */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');      /* If repayAmount == -1, repayAmount = accountBorrows */     if (repayAmount == uint(- 1)) {         vars.repayAmount = vars.accountBorrows;     } else {         vars.repayAmount = repayAmount;     }     vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);       if (isEnd &amp;&amp; vars.accountBorrows &gt; vars.actualRepayAmount) {         vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;     }      /*     *  We calculate the new borrower and total borrow balances, failing on underflow:     *  accountBorrowsNew = accountBorrows - repayAmount     *  totalBorrowsNew = totalBorrows - repayAmount     */     if (vars.accountBorrows &lt; vars.actualRepayAmount) {         require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) &lt;= 105e16, 'repay more than 5%');         vars.accountBorrowsNew = 0;     } else {         if (isEnd) {             vars.accountBorrowsNew = 0;         } else {             vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;         }     }     //Avoid mantissa errors     if (vars.actualRepayAmount &gt; totalBorrows) {         vars.totalBorrowsNew = 0;     } else {         if (isEnd) {             vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);         } else {             vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;         }     }      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a RepayBorrow event */     emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */      return vars.actualRepayAmount; }  /*** Admin Functions ***/  /// @notice Sets a new CONTROLLER for the market /// @dev Admin function to set a new controller function setController(address newController) external override onlyAdmin {     require(address(0) != newController, "0x");     address oldController = controller;     controller = newController;     // Emit NewController(oldController, newController)     emit NewController(oldController, newController); }  function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {     require(newBorrowCapFactorMantissa &lt;= 1e18, 'Factor too large');     uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;     borrowCapFactorMantissa = newBorrowCapFactorMantissa;     emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa); }  function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {     //accrueInterest except first     if (baseRatePerBlock != 0) {         accrueInterest();     }     // total rate perYear &lt; 2000%     require(baseRatePerBlock_ &lt; 1e13, 'Base rate too large');     baseRatePerBlock = baseRatePerBlock_;     require(multiplierPerBlock_ &lt; 1e13, 'Mul rate too large');     multiplierPerBlock = multiplierPerBlock_;     require(jumpMultiplierPerBlock_ &lt; 1e13, 'Jump rate too large');     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     require(kink_ &lt;= 1e18, 'Kline too large');     kink = kink_;     emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_); }  function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {     require(newReserveFactorMantissa &lt;= 1e18, 'Factor too large');     accrueInterest();     uint oldReserveFactorMantissa = reserveFactorMantissa;     reserveFactorMantissa = newReserveFactorMantissa;     emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa); }  function addReserves(uint addAmount) external override nonReentrant {     accrueInterest();     uint totalReservesNew;     uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);     totalReservesNew = totalReserves.add(actualAddAmount);     totalReserves = totalReservesNew;     emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew); }  function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {     accrueInterest();     uint totalReservesNew;     totalReservesNew = totalReserves.sub(reduceAmount);     totalReserves = totalReservesNew;     doTransferOut(to, reduceAmount, true);     emit ReservesReduced(to, reduceAmount, totalReservesNew); }  modifier sameBlock() {     require(accrualBlockNumber == getBlockNumber(), 'not same block');     _; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.7.6;\n\n\nimport "./LPoolInterface.sol";\nimport "./LPoolDepositor.sol";\nimport "../lib/Exponential.sol";\nimport "../Adminable.sol";\nimport "../lib/CarefulMath.sol";\nimport "../lib/TransferHelper.sol";\nimport "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\n\nimport "../DelegateInterface.sol";\nimport "../ControllerInterface.sol";\nimport "../IWETH.sol";\n\n/// @title OpenLeverage\'s LToken Contract\n/// @dev Abstract base for LTokens\n/// @author OpenLeverage\ncontract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {\n    using TransferHelper for IERC20;\n    using SafeMath for uint;\n\n    constructor() {\n\n    }\n    \n    /// @notice Initialize the money market\n    /// @param controller_ The address of the Controller\n    /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0\n    /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate\n    /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point\n    /// @param kink_ The utilization point at which the jump multiplier is applied\n    /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n    /// @param name_ EIP-20 name of this token\n    /// @param symbol_ EIP-20 symbol of this token\n    /// @param decimals_ EIP-20 decimal precision of this token\n    function initialize(\n        address underlying_,\n        bool isWethPool_,\n        address controller_,\n        uint256 baseRatePerBlock_,\n        uint256 multiplierPerBlock_,\n        uint256 jumpMultiplierPerBlock_,\n        uint256 kink_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_) public {\n        require(underlying_ != address(0), "underlying_ address cannot be 0");\n        require(controller_ != address(0), "controller_ address cannot be 0");\n        require(msg.sender == admin, "Only allow to be called by admin");\n        require(accrualBlockNumber == 0 &amp;&amp; borrowIndex == 0, "inited once");\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa &gt; 0, "Initial Exchange Rate Mantissa should be greater zero");\n        //set controller\n        controller = controller_;\n        isWethPool = isWethPool_;\n        //set interestRateModel\n        baseRatePerBlock = baseRatePerBlock_;\n        multiplierPerBlock = multiplierPerBlock_;\n        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;\n        kink = kink_;\n\n        // Initialize block number and borrow index (block number mocks depend on controller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = 1e25;\n        //80%\n        borrowCapFactorMantissa = 0.8e18;\n        //10%\n        reserveFactorMantissa = 0.1e18;\n\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n\n        notEntered = true;\n\n        // Set underlying and sanity check it\n        underlying = underlying;\n        IERC20(underlying).totalSupply();\n        emit Transfer(address(0), msg.sender, 0);\n    }\n\n    /// @notice Transfer tokens tokens from src to dst by spender\n    /// @dev Called by both transfer and transferFrom internally\n    /// @param spender The address of the account performing the transfer\n    /// @param src The address of the source account\n    /// @param dst The address of the destination account\n    /// @param tokens The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {\n        require(dst != address(0), "dst address cannot be 0");\n        / Do not allow self-transfers /\n        require(src != dst, "src = dst");\n        / Fail if transfer not allowed /\n        (ControllerInterface(controller)).transferAllowed(src, dst, tokens);\n\n        / Get the allowance, infinite for the account owner /\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = uint(- 1);\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        / Do the calculations, checking for {under,over}flow /\n        MathError mathErr;\n        uint allowanceNew;\n        uint srcTokensNew;\n        uint dstTokensNew;\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n        require(mathErr == MathError.NO_ERROR, \'not allowed\');\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n        require(mathErr == MathError.NO_ERROR, \'not enough\');\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n        require(mathErr == MathError.NO_ERROR, \'too much\');\n\n        accountTokens[src] = srcTokensNew;\n        accountTokens[dst] = dstTokensNew;\n\n        / Eat some of the allowance (if necessary) /\n        if (startingAllowance != uint(- 1)) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n        / We emit a Transfer event /\n        emit Transfer(src, dst, tokens);\n        return true;\n    }\n\n    /// @notice Transfer amount tokens from msg.sender to dst\n    /// @param dst The address of the destination account\n    /// @param amount The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, msg.sender, dst, amount);\n    }\n\n    /// @notice Transfer amount tokens from src to dst\n    /// @param src The address of the source account\n    /// @param dst The address of the destination account\n    /// @param amount The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, src, dst, amount);\n    }\n\n    /// @notice Approve spender to transfer up to amount from src\n    /// @dev This will overwrite the approval amount for spender\n    ///  and is subject to issues noted here\n    /// @param spender The address of the account which may transfer tokens\n    /// @param amount The number of tokens that are approved (-1 means infinite)\n    /// @return Whether or not the approval succeeded\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /// @notice Get the current allowance from owner for spender\n    /// @param owner The address of the account which owns the tokens to be spent\n    /// @param spender The address of the account which may transfer tokens\n    /// @return The number of tokens allowed to be spent (-1 means infinite)\n    function allowance(address owner, address spender) external override view returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n\n    /// @notice Get the token balance of the owner\n    /// @param owner The address of the account to query\n    /// @return The number of tokens owned by owner\n    function balanceOf(address owner) external override view returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /// @notice Get the underlying balance of the owner\n    /// @dev This also accrues interest in a transaction\n    /// @param owner The address of the account to query\n    /// @return The amount of underlying owned by owner\n    function balanceOfUnderlying(address owner) external override returns (uint) {\n        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n        require(mErr == MathError.NO_ERROR, "calc failed");\n        return balance;\n    }\n\n    / User Interface /\n\n    /// @notice Sender supplies assets into the market and receives lTokens in exchange\n    /// @dev Accrues interest whether or not the operation succeeds, unless reverted\n    /// @param mintAmount The amount of the underlying asset to supply\n    function mint(uint mintAmount) external override nonReentrant {\n        accrueInterest();\n        mintFresh(msg.sender, mintAmount, false);\n    }\n\n    function mintTo(address to, uint amount) external payable override nonReentrant {\n        accrueInterest();\n        if (isWethPool) {\n            mintFresh(to, msg.value, false);\n        } else {\n            mintFresh(to, amount, true);\n        }\n    }\n\n    function mintEth() external payable override nonReentrant {\n        require(isWethPool, "not eth pool");\n        accrueInterest();\n        mintFresh(msg.sender, msg.value, false);\n    }\n\n    /// @notice Sender redeems lTokens in exchange for the underlying asset\n    /// @dev Accrues interest whether or not the operation succeeds, unless reverted\n    /// @param redeemTokens The number of lTokens to redeem into underlying\n    function redeem(uint redeemTokens) external override nonReentrant {\n        accrueInterest();\n        // redeemFresh emits redeem-specific logs on errors, so we don\'t need to\n        redeemFresh(msg.sender, redeemTokens, 0);\n    }\n\n    /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset\n    /// @dev Accrues interest whether or not the operation succeeds, unless reverted\n    /// @param redeemAmount The amount of underlying to redeem\n    function redeemUnderlying(uint redeemAmount) external override nonReentrant {\n        accrueInterest();\n        // redeemFresh emits redeem-specific logs on errors, so we don\'t need to\n        redeemFresh(msg.sender, 0, redeemAmount);\n    }\n\n    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {\n        accrueInterest();\n        // borrowFresh emits borrow-specific logs on errors, so we don\'t need to\n        borrowFresh(payable(borrower), msg.sender, borrowAmount);\n    }\n\n    /// @notice Sender repays a borrow belonging to borrower\n    /// @param borrower the account with the debt being payed off\n    /// @param repayAmount The amount to repay\n    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {\n        accrueInterest();\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don\'t need to\n        repayBorrowFresh(msg.sender, borrower, repayAmount, false);\n    }\n\n    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {\n        accrueInterest();\n        repayBorrowFresh(msg.sender, borrower, repayAmount, true);\n    }\n\n\n    / Safe Token /\n\n    /// Gets balance of this contract in terms of the underlying\n    /// @dev This excludes the value of the current message, if any\n    /// @return The quantity of underlying tokens owned by this contract\n    function getCashPrior() internal view returns (uint) {\n        return IERC20(underlying).balanceOf(address(this));\n    }\n\n\n    /\n     * @dev Similar to EIP20 transfer, except it handles a False result from transferFrom and reverts in that case.\n     *      This will revert due to insufficient balance or insufficient allowance.\n     *      This function returns the actual amount received,\n     *      which may be less than amount if there is a fee attached to the transfer.\n     \n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     /\n    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {\n        if (isWethPool &amp;&amp; convertWeth) {\n            actualAmount = msg.value;\n            IWETH(underlying).deposit{value : actualAmount}();\n        } else {\n            actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);\n        }\n    }\n\n    /\n     * @dev Similar to EIP20 transfer, except it handles a False success from transfer and returns an explanatory\n     *      error code rather than reverting. If caller has not called checked protocol\'s balance, this may revert due to\n     *      insufficient cash held in this contract. If caller has checked protocol\'s balance prior to this call, and verified\n     *      it is &gt;= amount, this should not revert in normal conditions.\n     \n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     /\n    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {\n        if (isWethPool &amp;&amp; convertWeth) {\n            IWETH(underlying).withdraw(amount);\n            to.transfer(amount);\n        } else {\n            IERC20(underlying).safeTransfer(to, amount);\n        }\n    }\n\n    function availableForBorrow() external view override returns (uint){\n        uint cash = getCashPrior();\n        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);\n        if (err0 != MathError.NO_ERROR) {\n            return 0;\n        }\n        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);\n        if (err1 != MathError.NO_ERROR) {\n            return 0;\n        }\n        if (totalBorrows &gt; maxAvailable) {\n            return 0;\n        }\n        return maxAvailable - totalBorrows;\n    }\n\n\n    /// @notice Get a snapshot of the account\'s balances, and the cached exchange rate\n    /// @dev This is used by controller to more efficiently perform liquidity checks.\n    /// @param account Address of the account to snapshot\n    /// @return ( token balance, borrow balance, exchange rate mantissa)\n    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {\n        uint cTokenBalance = accountTokens[account];\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n\n        MathError mErr;\n\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n        if (mErr != MathError.NO_ERROR) {\n            return (0, 0, 0);\n        }\n\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (mErr != MathError.NO_ERROR) {\n            return (0, 0, 0);\n        }\n\n        return (cTokenBalance, borrowBalance, exchangeRateMantissa);\n    }\n\n    /// @dev Function to simply retrieve block number\n    ///  This exists mainly for inheriting test contracts to stub this result.\n    function getBlockNumber() internal view returns (uint) {\n        return block.number;\n    }\n\n    /// @notice Returns the current per-block borrow interest rate for this cToken\n    /// @return The borrow interest rate per block, scaled by 1e18\n    function borrowRatePerBlock() external override view returns (uint) {\n        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);\n    }\n\n    \n    /// @notice Returns the current per-block supply interest rate for this cToken\n    /// @return The supply interest rate per block, scaled by 1e18\n    function supplyRatePerBlock() external override view returns (uint) {\n        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\n    }\n\n    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {\n        // Utilization rate is 0 when there are no borrows\n        if (borrows == 0) {\n            return 0;\n        }\n        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));\n    }\n\n    /// @notice Calculates the current borrow rate per block, with the error code expected by the market\n    /// @param cash The amount of cash in the market\n    /// @param borrows The amount of borrows in the market\n    /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\n    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {\n        uint util = utilizationRate(cash, borrows, reserves);\n        if (util &lt;= kink) {\n            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n        } else {\n            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n            uint excessUtil = util.sub(kink);\n            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);\n        }\n    }\n\n    /// @notice Calculates the current supply rate per block\n    /// @param cash The amount of cash in the market\n    /// @param borrows The amount of borrows in the market\n    /// @return The supply rate percentage per block as a mantissa (scaled by 1e18)\n    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {\n        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);\n        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);\n        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\n        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\n    }\n\n    /// @notice Returns the current total borrows plus accrued interest\n    /// @return The total borrows with interest\n    function totalBorrowsCurrent() external override view returns (uint) {\n        / Remember the initial block number /\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        / Short-circuit accumulating 0 interest /\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return totalBorrows;\n        }\n\n        / Read the previous values out of storage /\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint reservesPrior = totalReserves;\n\n        / Calculate the current borrow interest rate /\n        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");\n\n        / Calculate the number of blocks elapsed since the last accrual /\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        require(mathErr == MathError.NO_ERROR, "calc block delta erro");\n\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        require(mathErr == MathError.NO_ERROR, \'calc interest factor error\');\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc interest acc error\');\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc total borrows error\');\n\n        return totalBorrowsNew;\n    }\n\n    /// @notice Accrue interest to updated borrowIndex and then calculate account\'s borrow balance using the updated borrowIndex\n    /// @param account The address whose balance should be calculated after updating borrowIndex\n    /// @return The calculated balance\n    function borrowBalanceCurrent(address account) external view override returns (uint) {\n        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();\n        require(err0 == MathError.NO_ERROR, "calc borrow index fail");\n        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);\n        require(err1 == MathError.NO_ERROR, "calc fail");\n        return result;\n    }\n\n    function borrowBalanceStored(address account) external override view returns (uint){\n        return accountBorrows[account].principal;\n    }\n\n\n    /// @notice Return the borrow balance of account based on stored data\n    /// @param account The address whose balance should be calculated\n    /// @return (error code, the calculated balance or 0 if error code is non-zero)\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);\n    }\n\n    /// @notice Return the borrow balance of account based on stored data\n    /// @param account The address whose balance should be calculated\n    /// @return (error code, the calculated balance or 0 if error code is non-zero)\n    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {\n        / Note: we do not assert that the market is up to date /\n        MathError mathErr;\n        uint principalTimesIndex;\n        uint result;\n\n        / Get borrowBalance and borrowIndex /\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        / If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         /\n        if (borrowSnapshot.principal == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        / Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         /\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        return (MathError.NO_ERROR, result);\n    }\n\n    /// @notice Accrue interest then return the up-to-date exchange rate\n    /// @return Calculated exchange rate scaled by 1e18\n    function exchangeRateCurrent() public override nonReentrant returns (uint) {\n        accrueInterest();\n        return exchangeRateStored();\n    }\n\n    /// Calculates the exchange rate from the underlying to the LToken\n    /// @dev This function does not accrue interest before calculating the exchange rate\n    /// @return Calculated exchange rate scaled by 1e18\n    function exchangeRateStored() public override view returns (uint) {\n        (MathError err, uint result) = exchangeRateStoredInternal();\n        require(err == MathError.NO_ERROR, "calc fail");\n        return result;\n    }\n\n    /// @notice Calculates the exchange rate from the underlying to the LToken\n    /// @dev This function does not accrue interest before calculating the exchange rate\n    /// @return (error code, calculated exchange rate scaled by 1e18)\n    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n        uint _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            /\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             /\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\n        } else {\n            /\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             /\n            uint _totalCash = getCashPrior();\n            uint cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n            MathError mathErr;\n\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\n        }\n    }\n\n    /// @notice Get cash balance of this cToken in the underlying asset\n    /// @return The quantity of underlying asset owned by this contract\n    function getCash() external override view returns (uint) {\n        return IERC20(underlying).balanceOf(address(this));\n    }\n\n    function calCurrentBorrowIndex() internal view returns (MathError, uint) {\n        / Remember the initial block number /\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n        uint borrowIndexNew;\n        / Short-circuit accumulating 0 interest /\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return (MathError.NO_ERROR, borrowIndex);\n        }\n        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n\n        Exp memory simpleInterestFactor;\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);\n        return (mathErr, borrowIndexNew);\n    }\n\n    /// @notice Applies accrued interest to total borrows and reserves\n    /// @dev This calculates interest accrued from the last checkpointed block\n    ///   up to the current block and writes new checkpoint to storage.\n    function accrueInterest() public override {\n        / Remember the initial block number /\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        / Short-circuit accumulating 0 interest /\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return;\n        }\n\n        / Read the previous values out of storage /\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint borrowIndexPrior = borrowIndex;\n        uint reservesPrior = totalReserves;\n\n        / Calculate the current borrow interest rate /\n        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");\n\n        / Calculate the number of blocks elapsed since the last accrual /\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        require(mathErr == MathError.NO_ERROR, "calc block delta erro");\n\n\n        /\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         /\n\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n        uint borrowIndexNew;\n        uint totalReservesNew;\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        require(mathErr == MathError.NO_ERROR, \'calc interest factor error\');\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc interest acc error\');\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc total borrows error\');\n\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc total reserves error\');\n\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc borrows index error\');\n\n\n        / We write the previously calculated values into storage /\n        accrualBlockNumber = currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n        totalReserves = totalReservesNew;\n\n        / We emit an AccrueInterest event /\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n    }\n\n    struct MintLocalVars {\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint mintTokens;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n        uint actualMintAmount;\n    }\n\n    /// @notice User supplies assets into the market and receives lTokens in exchange\n    /// @dev Assumes interest has already been accrued up to the current block\n    /// @param minter The address of the account which is supplying the assets\n    /// @param mintAmount The amount of the underlying asset to supply\n    /// @return uint the actual mint amount.\n    function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {\n        MintLocalVars memory vars;\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, \'calc exchangerate error\');\n\n        /\n         *  We call doTransferIn for the minter and the mintAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  doTransferIn reverts if anything goes wrong, since we can\'t be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the cToken holds an additional actualMintAmount\n         *  of cash.\n         /\n        if (isDelegete) {\n            uint balanceBefore = getCashPrior();\n            LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);\n            uint balanceAfter = getCashPrior();\n            require(balanceAfter &gt; balanceBefore, \'mint 0\');\n            vars.actualMintAmount = balanceAfter - balanceBefore;\n        } else {\n            vars.actualMintAmount = doTransferIn(minter, mintAmount, true);\n        }\n        /\n         * We get the current exchange rate and calculate the number of lTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         /\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));\n        require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");\n\n        / Fail if mint not allowed /\n        (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);\n        /\n         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         /\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n        require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n        require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");\n\n        / We write previously calculated values into storage /\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[minter] = vars.accountTokensNew;\n\n        / We emit a Mint event, and a Transfer event /\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n        / We call the defense hook /\n\n        return vars.actualMintAmount;\n    }\n\n\n    struct RedeemLocalVars {\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint redeemTokens;\n        uint redeemAmount;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n    }\n\n    /// @notice User redeems lTokens in exchange for the underlying asset\n    /// @dev Assumes interest has already been accrued up to the current block\n    /// @param redeemer The address of the account which is redeeming the tokens\n    /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n    /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");\n\n        RedeemLocalVars memory vars;\n\n        / exchangeRate = invoke Exchange Rate Stored() /\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, \'calc exchangerate error\');\n\n        / If redeemTokensIn &gt; 0: /\n        if (redeemTokensIn &gt; 0) {\n            /\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             /\n            vars.redeemTokens = redeemTokensIn;\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);\n            require(vars.mathErr == MathError.NO_ERROR, \'calc redeem amount error\');\n        } else {\n            /\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             /\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));\n            require(vars.mathErr == MathError.NO_ERROR, \'calc redeem tokens error\');\n            vars.redeemAmount = redeemAmountIn;\n        }\n\n        / Fail if redeem not allowed /\n        (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);\n\n        /\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n         *  totalSupplyNew = totalSupply - redeemTokens\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n         /\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n        require(vars.mathErr == MathError.NO_ERROR, \'calc supply new error\');\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n        require(vars.mathErr == MathError.NO_ERROR, \'calc token new error\');\n        require(getCashPrior() &gt;= vars.redeemAmount, \'cash &lt; redeem\');\n\n        / We write previously calculated values into storage /\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[redeemer] = vars.accountTokensNew;\n        /\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken has redeemAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can\'t be sure if side effects occurred.\n         /\n        doTransferOut(redeemer, vars.redeemAmount, true);\n\n\n        / We emit a Transfer event, and a Redeem event /\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        / We call the defense hook /\n    }\n\n    struct BorrowLocalVars {\n        MathError mathErr;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n    }\n\n    /// @notice Users borrow assets from the protocol to their own address\n    /// @param borrowAmount The amount of the underlying asset to borrow\n    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {\n        / Fail if borrow not allowed /\n        (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);\n\n        / Fail gracefully if protocol has insufficient underlying cash /\n        require(getCashPrior() &gt;= borrowAmount, \'cash vars.actualRepayAmount) {\n            vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;\n        }\n\n        /\n        *  We calculate the new borrower and total borrow balances, failing on underflow:\n        *  accountBorrowsNew = accountBorrows - repayAmount\n        *  totalBorrowsNew = totalBorrows - repayAmount\n        /\n        if (vars.accountBorrows &lt; vars.actualRepayAmount) {\n            require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) &lt;= 105e16, \'repay more than 5%\');\n            vars.accountBorrowsNew = 0;\n        } else {\n            if (isEnd) {\n                vars.accountBorrowsNew = 0;\n            } else {\n                vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;\n            }\n        }\n        //Avoid mantissa errors\n        if (vars.actualRepayAmount &gt; totalBorrows) {\n            vars.totalBorrowsNew = 0;\n        } else {\n            if (isEnd) {\n                vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);\n            } else {\n                vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;\n            }\n        }\n\n        / We write the previously calculated values into storage /\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        / We emit a RepayBorrow event /\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        / We call the defense hook */\n\n        return vars.actualRepayAmount;\n    }\n\n    / Admin Functions ***/\n\n    /// @notice Sets a new CONTROLLER for the market\n    /// @dev Admin function to set a new controller\n    function setController(address newController) external override onlyAdmin {\n        require(address(0) != newController, "0x");\n        address oldController = controller;\n        controller = newController;\n        // Emit NewController(oldController, newController)\n        emit NewController(oldController, newController);\n    }\n\n    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {\n        require(newBorrowCapFactorMantissa &lt;= 1e18, \'Factor too large\');\n        uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;\n        borrowCapFactorMantissa = newBorrowCapFactorMantissa;\n        emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa);\n    }\n\n    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {\n        //accrueInterest except first\n        if (baseRatePerBlock != 0) {\n            accrueInterest();\n        }\n        // total rate perYear &lt; 2000%\n        require(baseRatePerBlock_ &lt; 1e13, \'Base rate too large\');\n        baseRatePerBlock = baseRatePerBlock_;\n        require(multiplierPerBlock_ &lt; 1e13, \'Mul rate too large\');\n        multiplierPerBlock = multiplierPerBlock_;\n        require(jumpMultiplierPerBlock_ &lt; 1e13, \'Jump rate too large\');\n        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;\n        require(kink_ &lt;= 1e18, \'Kline too large\');\n        kink = kink_;\n        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);\n    }\n\n    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {\n        require(newReserveFactorMantissa &lt;= 1e18, \'Factor too large\');\n        accrueInterest();\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n        reserveFactorMantissa = newReserveFactorMantissa;\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n    }\n\n    function addReserves(uint addAmount) external override nonReentrant {\n        accrueInterest();\n        uint totalReservesNew;\n        uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);\n        totalReservesNew = totalReserves.add(actualAddAmount);\n        totalReserves = totalReservesNew;\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n    }\n\n    function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {\n        accrueInterest();\n        uint totalReservesNew;\n        totalReservesNew = totalReserves.sub(reduceAmount);\n        totalReserves = totalReservesNew;\n        doTransferOut(to, reduceAmount, true);\n        emit ReservesReduced(to, reduceAmount, totalReservesNew);\n    }\n\n    modifier sameBlock() {\n        require(accrualBlockNumber == getBlockNumber(), \'not same block\');\n        _;\n    }\n}\n\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-24-08 19:28:02 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.7.6; import "./LPoolInterface.sol"; import "./LPoolDepositor.sol"; import "../lib/Exponential.sol"; import "../Adminable.sol"; import "../lib/CarefulMath.sol"; import "../lib/TransferHelper.sol"; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import "../DelegateInterface.sol"; import "../ControllerInterface.sol"; import "../IWETH.sol"; /// @title OpenLeverage's LToken Contract /// @dev Abstract base for LTokens /// @author OpenLeverage contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {     using TransferHelper for IERC20;     using SafeMath for uint; constructor() {  }  /// @notice Initialize the money market /// @param controller_ The address of the Controller /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0 /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point /// @param kink_ The utilization point at which the jump multiplier is applied /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18 /// @param name_ EIP-20 name of this token /// @param symbol_ EIP-20 symbol of this token /// @param decimals_ EIP-20 decimal precision of this token function initialize(     address underlying_,     bool isWethPool_,     address controller_,     uint256 baseRatePerBlock_,     uint256 multiplierPerBlock_,     uint256 jumpMultiplierPerBlock_,     uint256 kink_,     uint initialExchangeRateMantissa_,     string memory name_,     string memory symbol_,     uint8 decimals_) public {     require(underlying_ != address(0), "underlying_ address cannot be 0");     require(controller_ != address(0), "controller_ address cannot be 0");     require(msg.sender == admin, "Only allow to be called by admin");     require(accrualBlockNumber == 0 &amp;&amp; borrowIndex == 0, "inited once");      // Set initial exchange rate     initialExchangeRateMantissa = initialExchangeRateMantissa_;     require(initialExchangeRateMantissa &gt; 0, "Initial Exchange Rate Mantissa should be greater zero");     //set controller     controller = controller_;     isWethPool = isWethPool_;     //set interestRateModel     baseRatePerBlock = baseRatePerBlock_;     multiplierPerBlock = multiplierPerBlock_;     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     kink = kink_;      // Initialize block number and borrow index (block number mocks depend on controller being set)     accrualBlockNumber = getBlockNumber();     borrowIndex = 1e25;     //80%     borrowCapFactorMantissa = 0.8e18;     //10%     reserveFactorMantissa = 0.1e18;       name = name_;     symbol = symbol_;     decimals = decimals_;      _notEntered = true;      // Set underlying and sanity check it     underlying = underlying_;     IERC20(underlying).totalSupply();     emit Transfer(address(0), msg.sender, 0); }  /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender` /// @dev Called by both `transfer` and `transferFrom` internally /// @param spender The address of the account performing the transfer /// @param src The address of the source account /// @param dst The address of the destination account /// @param tokens The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {     require(dst != address(0), "dst address cannot be 0");     /* Do not allow self-transfers */     require(src != dst, "src = dst");     /* Fail if transfer not allowed */     (ControllerInterface(controller)).transferAllowed(src, dst, tokens);      /* Get the allowance, infinite for the account owner */     uint startingAllowance = 0;     if (spender == src) {         startingAllowance = uint(- 1);     } else {         startingAllowance = transferAllowances[src][spender];     }      /* Do the calculations, checking for {under,over}flow */     MathError mathErr;     uint allowanceNew;     uint srcTokensNew;     uint dstTokensNew;      (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);     require(mathErr == MathError.NO_ERROR, 'not allowed');      (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);     require(mathErr == MathError.NO_ERROR, 'not enough');      (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);     require(mathErr == MathError.NO_ERROR, 'too much');      accountTokens[src] = srcTokensNew;     accountTokens[dst] = dstTokensNew;      /* Eat some of the allowance (if necessary) */     if (startingAllowance != uint(- 1)) {         transferAllowances[src][spender] = allowanceNew;     }     /* We emit a Transfer event */     emit Transfer(src, dst, tokens);     return true; }  /// @notice Transfer `amount` tokens from `msg.sender` to `dst` /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, msg.sender, dst, amount); }  /// @notice Transfer `amount` tokens from `src` to `dst` /// @param src The address of the source account /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, src, dst, amount); }  /// @notice Approve `spender` to transfer up to `amount` from `src` /// @dev This will overwrite the approval amount for `spender` ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve) /// @param spender The address of the account which may transfer tokens /// @param amount The number of tokens that are approved (-1 means infinite) /// @return Whether or not the approval succeeded function approve(address spender, uint256 amount) external override returns (bool) {     address src = msg.sender;     transferAllowances[src][spender] = amount;     emit Approval(src, spender, amount);     return true; }  /// @notice Get the current allowance from `owner` for `spender` /// @param owner The address of the account which owns the tokens to be spent /// @param spender The address of the account which may transfer tokens /// @return The number of tokens allowed to be spent (-1 means infinite) function allowance(address owner, address spender) external override view returns (uint256) {     return transferAllowances[owner][spender]; }  /// @notice Get the token balance of the `owner` /// @param owner The address of the account to query /// @return The number of tokens owned by `owner` function balanceOf(address owner) external override view returns (uint256) {     return accountTokens[owner]; }  /// @notice Get the underlying balance of the `owner` /// @dev This also accrues interest in a transaction /// @param owner The address of the account to query /// @return The amount of underlying owned by `owner` function balanceOfUnderlying(address owner) external override returns (uint) {     Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});     (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);     require(mErr == MathError.NO_ERROR, "calc failed");     return balance; }  /*** User Interface ***/  /// @notice Sender supplies assets into the market and receives lTokens in exchange /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param mintAmount The amount of the underlying asset to supply function mint(uint mintAmount) external override nonReentrant {     accrueInterest();     mintFresh(msg.sender, mintAmount, false); }  function mintTo(address to, uint amount) external payable override nonReentrant {     accrueInterest();     if (isWethPool) {         mintFresh(to, msg.value, false);     } else {         mintFresh(to, amount, true);     } }  function mintEth() external payable override nonReentrant {     require(isWethPool, "not eth pool");     accrueInterest();     mintFresh(msg.sender, msg.value, false); }  /// @notice Sender redeems lTokens in exchange for the underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemTokens The number of lTokens to redeem into underlying function redeem(uint redeemTokens) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, redeemTokens, 0); }  /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemAmount The amount of underlying to redeem function redeemUnderlying(uint redeemAmount) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, 0, redeemAmount); }  function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {     accrueInterest();     // borrowFresh emits borrow-specific logs on errors, so we don't need to     borrowFresh(payable(borrower), msg.sender, borrowAmount); }  /// @notice Sender repays a borrow belonging to borrower /// @param borrower the account with the debt being payed off /// @param repayAmount The amount to repay function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     repayBorrowFresh(msg.sender, borrower, repayAmount, false); }  function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     repayBorrowFresh(msg.sender, borrower, repayAmount, true); }   /*** Safe Token ***/  /// Gets balance of this contract in terms of the underlying /// @dev This excludes the value of the current message, if any /// @return The quantity of underlying tokens owned by this contract function getCashPrior() internal view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }   /**  * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.  *      This will revert due to insufficient balance or insufficient allowance.  *      This function returns the actual amount received,  *      which may be less than `amount` if there is a fee attached to the transfer.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {     if (isWethPool &amp;&amp; convertWeth) {         actualAmount = msg.value;         IWETH(underlying).deposit{value : actualAmount}();     } else {         actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);     } }  /**  * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory  *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to  *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified  *      it is &gt;= amount, this should not revert in normal conditions.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferOut(address payable to, uint amount, bool convertWeth) internal {     if (isWethPool &amp;&amp; convertWeth) {         IWETH(underlying).withdraw(amount);         to.transfer(amount);     } else {         IERC20(underlying).safeTransfer(to, amount);     } }  function availableForBorrow() external view override returns (uint){     uint cash = getCashPrior();     (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);     if (err0 != MathError.NO_ERROR) {         return 0;     }     (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);     if (err1 != MathError.NO_ERROR) {         return 0;     }     if (totalBorrows &gt; maxAvailable) {         return 0;     }     return maxAvailable - totalBorrows; }   /// @notice Get a snapshot of the account's balances, and the cached exchange rate /// @dev This is used by controller to more efficiently perform liquidity checks. /// @param account Address of the account to snapshot /// @return ( token balance, borrow balance, exchange rate mantissa) function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {     uint cTokenBalance = accountTokens[account];     uint borrowBalance;     uint exchangeRateMantissa;      MathError mErr;      (mErr, borrowBalance) = borrowBalanceStoredInternal(account);     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      return (cTokenBalance, borrowBalance, exchangeRateMantissa); }  /// @dev Function to simply retrieve block number ///  This exists mainly for inheriting test contracts to stub this result. function getBlockNumber() internal view returns (uint) {     return block.number; }  /// @notice Returns the current per-block borrow interest rate for this cToken /// @return The borrow interest rate per block, scaled by 1e18 function borrowRatePerBlock() external override view returns (uint) {     return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves); }   /// @notice Returns the current per-block supply interest rate for this cToken /// @return The supply interest rate per block, scaled by 1e18 function supplyRatePerBlock() external override view returns (uint) {     return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa); }  function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {     // Utilization rate is 0 when there are no borrows     if (borrows == 0) {         return 0;     }     return borrows.mul(1e18).div(cash.add(borrows).sub(reserves)); }  /// @notice Calculates the current borrow rate per block, with the error code expected by the market /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18) function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {     uint util = utilizationRate(cash, borrows, reserves);     if (util &lt;= kink) {         return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);     } else {         uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);         uint excessUtil = util.sub(kink);         return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);     } }  /// @notice Calculates the current supply rate per block /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The supply rate percentage per block as a mantissa (scaled by 1e18) function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {     uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);     uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);     uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);     return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18); }  /// @notice Returns the current total borrows plus accrued interest /// @return The total borrows with interest function totalBorrowsCurrent() external override view returns (uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return totalBorrows;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, "calc block delta erro");      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      return totalBorrowsNew; }  /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex /// @param account The address whose balance should be calculated after updating borrowIndex /// @return The calculated balance function borrowBalanceCurrent(address account) external view override returns (uint) {     (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();     require(err0 == MathError.NO_ERROR, "calc borrow index fail");     (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);     require(err1 == MathError.NO_ERROR, "calc fail");     return result; }  function borrowBalanceStored(address account) external override view returns (uint){     return accountBorrows[account].principal; }   /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {     return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex); }  /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {     /* Note: we do not assert that the market is up to date */     MathError mathErr;     uint principalTimesIndex;     uint result;      /* Get borrowBalance and borrowIndex */     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];      /* If borrowBalance = 0 then borrowIndex is likely also 0.      * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.      */     if (borrowSnapshot.principal == 0) {         return (MathError.NO_ERROR, 0);     }      /* Calculate new borrow balance using the interest index:      *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex      */     (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      return (MathError.NO_ERROR, result); }  /// @notice Accrue interest then return the up-to-date exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateCurrent() public override nonReentrant returns (uint) {     accrueInterest();     return exchangeRateStored(); }  /// Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateStored() public override view returns (uint) {     (MathError err, uint result) = exchangeRateStoredInternal();     require(err == MathError.NO_ERROR, "calc fail");     return result; }  /// @notice Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return (error code, calculated exchange rate scaled by 1e18) function exchangeRateStoredInternal() internal view returns (MathError, uint) {     uint _totalSupply = totalSupply;     if (_totalSupply == 0) {         /*          * If there are no tokens minted:          *  exchangeRate = initialExchangeRate          */         return (MathError.NO_ERROR, initialExchangeRateMantissa);     } else {         /*          * Otherwise:          *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply          */         uint _totalCash = getCashPrior();         uint cashPlusBorrowsMinusReserves;         Exp memory exchangeRate;         MathError mathErr;          (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          return (MathError.NO_ERROR, exchangeRate.mantissa);     } }  /// @notice Get cash balance of this cToken in the underlying asset /// @return The quantity of underlying asset owned by this contract function getCash() external override view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }  function calCurrentBorrowIndex() internal view returns (MathError, uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;     uint borrowIndexNew;     /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return (MathError.NO_ERROR, borrowIndex);     }     uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);      Exp memory simpleInterestFactor;     (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }     (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);     return (mathErr, borrowIndexNew); }  /// @notice Applies accrued interest to total borrows and reserves /// @dev This calculates interest accrued from the last checkpointed block ///   up to the current block and writes new checkpoint to storage. function accrueInterest() public override {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint borrowIndexPrior = borrowIndex;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, "calc block delta erro");       /*      * Calculate the interest accumulated into borrows and reserves and the new index:      *  simpleInterestFactor = borrowRate * blockDelta      *  interestAccumulated = simpleInterestFactor * totalBorrows      *  totalBorrowsNew = interestAccumulated + totalBorrows      *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex      */      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;     uint borrowIndexNew;     uint totalReservesNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);     require(mathErr == MathError.NO_ERROR, 'calc total reserves error');      (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);     require(mathErr == MathError.NO_ERROR, 'calc borrows index error');       /* We write the previously calculated values into storage */     accrualBlockNumber = currentBlockNumber;     borrowIndex = borrowIndexNew;     totalBorrows = totalBorrowsNew;     totalReserves = totalReservesNew;      /* We emit an AccrueInterest event */     emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);  }  struct MintLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint mintTokens;     uint totalSupplyNew;     uint accountTokensNew;     uint actualMintAmount; }  /// @notice User supplies assets into the market and receives lTokens in exchange /// @dev Assumes interest has already been accrued up to the current block /// @param minter The address of the account which is supplying the assets /// @param mintAmount The amount of the underlying asset to supply /// @return uint the actual mint amount. function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {     MintLocalVars memory vars;     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /*      *  We call `doTransferIn` for the minter and the mintAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if      *  side-effects occurred. The function returns the amount actually transferred,      *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`      *  of cash.      */     if (isDelegete) {         uint balanceBefore = getCashPrior();         LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);         uint balanceAfter = getCashPrior();         require(balanceAfter &gt; balanceBefore, 'mint 0');         vars.actualMintAmount = balanceAfter - balanceBefore;     } else {         vars.actualMintAmount = doTransferIn(minter, mintAmount, true);     }     /*      * We get the current exchange rate and calculate the number of lTokens to be minted:      *  mintTokens = actualMintAmount / exchangeRate      */      (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));     require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");      /* Fail if mint not allowed */     (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);     /*      * We calculate the new total supply of lTokens and minter token balance, checking for overflow:      *  totalSupplyNew = totalSupply + mintTokens      *  accountTokensNew = accountTokens[minter] + mintTokens      */     (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");      (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[minter] = vars.accountTokensNew;      /* We emit a Mint event, and a Transfer event */     emit Mint(minter, vars.actualMintAmount, vars.mintTokens);     emit Transfer(address(this), minter, vars.mintTokens);      /* We call the defense hook */      return vars.actualMintAmount; }   struct RedeemLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint redeemTokens;     uint redeemAmount;     uint totalSupplyNew;     uint accountTokensNew; }  /// @notice User redeems lTokens in exchange for the underlying asset /// @dev Assumes interest has already been accrued up to the current block /// @param redeemer The address of the account which is redeeming the tokens /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero) /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero) function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {     require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");      RedeemLocalVars memory vars;      /* exchangeRate = invoke Exchange Rate Stored() */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /* If redeemTokensIn &gt; 0: */     if (redeemTokensIn &gt; 0) {         /*          * We calculate the exchange rate and the amount of underlying to be redeemed:          *  redeemTokens = redeemTokensIn          *  redeemAmount = redeemTokensIn x exchangeRateCurrent          */         vars.redeemTokens = redeemTokensIn;          (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');     } else {         /*          * We get the current exchange rate and calculate the amount to be redeemed:          *  redeemTokens = redeemAmountIn / exchangeRate          *  redeemAmount = redeemAmountIn          */          (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');         vars.redeemAmount = redeemAmountIn;     }      /* Fail if redeem not allowed */     (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);      /*      * We calculate the new total supply and redeemer balance, checking for underflow:      *  totalSupplyNew = totalSupply - redeemTokens      *  accountTokensNew = accountTokens[redeemer] - redeemTokens      */     (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');      (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');     require(getCashPrior() &gt;= vars.redeemAmount, 'cash &lt; redeem');      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[redeemer] = vars.accountTokensNew;     /*      * We invoke doTransferOut for the redeemer and the redeemAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken has redeemAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(redeemer, vars.redeemAmount, true);       /* We emit a Transfer event, and a Redeem event */     emit Transfer(redeemer, address(this), vars.redeemTokens);     emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);      /* We call the defense hook */ }  struct BorrowLocalVars {     MathError mathErr;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /// @notice Users borrow assets from the protocol to their own address /// @param borrowAmount The amount of the underlying asset to borrow function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {     /* Fail if borrow not allowed */     (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);      /* Fail gracefully if protocol has insufficient underlying cash */     require(getCashPrior() &gt;= borrowAmount, 'cash&lt;borrow');      BorrowLocalVars memory vars;      /*      * We calculate the new borrower and total borrow balances, failing on overflow:      *  accountBorrowsNew = accountBorrows + borrowAmount      *  totalBorrowsNew = totalBorrows + borrowAmount      */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /*      * We invoke doTransferOut for the borrower and the borrowAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken borrowAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(payee, borrowAmount, false);      /* We emit a Borrow event */     emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */ }  struct RepayBorrowLocalVars {     MathError mathErr;     uint repayAmount;     uint borrowerIndex;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew;     uint actualRepayAmount;     uint badDebtsAmount; }  /// @notice Borrows are repaid by another user (possibly the borrower). /// @param payer the account paying off the borrow /// @param borrower the account with the debt being payed off /// @param repayAmount the amount of undelrying tokens being returned function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {     /* Fail if repayBorrow not allowed */     (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);      RepayBorrowLocalVars memory vars;      /* We remember the original borrowerIndex for verification purposes */     vars.borrowerIndex = accountBorrows[borrower].interestIndex;      /* We fetch the amount the borrower owes, with accumulated interest */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');      /* If repayAmount == -1, repayAmount = accountBorrows */     if (repayAmount == uint(- 1)) {         vars.repayAmount = vars.accountBorrows;     } else {         vars.repayAmount = repayAmount;     }     vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);       if (isEnd &amp;&amp; vars.accountBorrows &gt; vars.actualRepayAmount) {         vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;     }      /*     *  We calculate the new borrower and total borrow balances, failing on underflow:     *  accountBorrowsNew = accountBorrows - repayAmount     *  totalBorrowsNew = totalBorrows - repayAmount     */     if (vars.accountBorrows &lt; vars.actualRepayAmount) {         require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) &lt;= 105e16, 'repay more than 5%');         vars.accountBorrowsNew = 0;     } else {         if (isEnd) {             vars.accountBorrowsNew = 0;         } else {             vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;         }     }     //Avoid mantissa errors     if (vars.actualRepayAmount &gt; totalBorrows) {         vars.totalBorrowsNew = 0;     } else {         if (isEnd) {             vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);         } else {             vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;         }     }      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a RepayBorrow event */     emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */      return vars.actualRepayAmount; }  /*** Admin Functions ***/  /// @notice Sets a new CONTROLLER for the market /// @dev Admin function to set a new controller function setController(address newController) external override onlyAdmin {     require(address(0) != newController, "0x");     address oldController = controller;     controller = newController;     // Emit NewController(oldController, newController)     emit NewController(oldController, newController); }  function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {     require(newBorrowCapFactorMantissa &lt;= 1e18, 'Factor too large');     uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;     borrowCapFactorMantissa = newBorrowCapFactorMantissa;     emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa); }  function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {     //accrueInterest except first     if (baseRatePerBlock != 0) {         accrueInterest();     }     // total rate perYear &lt; 2000%     require(baseRatePerBlock_ &lt; 1e13, 'Base rate too large');     baseRatePerBlock = baseRatePerBlock_;     require(multiplierPerBlock_ &lt; 1e13, 'Mul rate too large');     multiplierPerBlock = multiplierPerBlock_;     require(jumpMultiplierPerBlock_ &lt; 1e13, 'Jump rate too large');     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     require(kink_ &lt;= 1e18, 'Kline too large');     kink = kink_;     emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_); }  function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {     require(newReserveFactorMantissa &lt;= 1e18, 'Factor too large');     accrueInterest();     uint oldReserveFactorMantissa = reserveFactorMantissa;     reserveFactorMantissa = newReserveFactorMantissa;     emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa); }  function addReserves(uint addAmount) external override nonReentrant {     accrueInterest();     uint totalReservesNew;     uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);     totalReservesNew = totalReserves.add(actualAddAmount);     totalReserves = totalReservesNew;     emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew); }  function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {     accrueInterest();     uint totalReservesNew;     totalReservesNew = totalReserves.sub(reduceAmount);     totalReserves = totalReservesNew;     doTransferOut(to, reduceAmount, true);     emit ReservesReduced(to, reduceAmount, totalReservesNew); }  modifier sameBlock() {     require(accrualBlockNumber == getBlockNumber(), 'not same block');     _; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-24-08 19:28:02 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;


import "./LPoolInterface.sol";
import "./LPoolDepositor.sol";
import "../lib/Exponential.sol";
import "../Adminable.sol";
import "../lib/CarefulMath.sol";
import "../lib/TransferHelper.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import "../DelegateInterface.sol";
import "../ControllerInterface.sol";
import "../IWETH.sol";

/// @title OpenLeverage's LToken Contract
/// @dev Abstract base for LTokens
/// @author OpenLeverage
contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {
    using TransferHelper for IERC20;
    using SafeMath for uint;

    constructor() {

    }
    
    /// @notice Initialize the money market
    /// @param controller_ The address of the Controller
    /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0
    /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate
    /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point
    /// @param kink_ The utilization point at which the jump multiplier is applied
    /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
    /// @param name_ EIP-20 name of this token
    /// @param symbol_ EIP-20 symbol of this token
    /// @param decimals_ EIP-20 decimal precision of this token
    function initialize(
        address underlying_,
        bool isWethPool_,
        address controller_,
        uint256 baseRatePerBlock_,
        uint256 multiplierPerBlock_,
        uint256 jumpMultiplierPerBlock_,
        uint256 kink_,
        uint initialExchangeRateMantissa_,
        string memory name_,
        string memory symbol_,
        uint8 decimals_) public {
        require(underlying_ != address(0), "underlying_ address cannot be 0");
        require(controller_ != address(0), "controller_ address cannot be 0");
        require(msg.sender == admin, "Only allow to be called by admin");
        require(accrualBlockNumber == 0 && borrowIndex == 0, "inited once");

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial Exchange Rate Mantissa should be greater zero");
        //set controller
        controller = controller_;
        isWethPool = isWethPool_;
        //set interestRateModel
        baseRatePerBlock = baseRatePerBlock_;
        multiplierPerBlock = multiplierPerBlock_;
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        kink = kink_;

        // Initialize block number and borrow index (block number mocks depend on controller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = 1e25;
        //80%
        borrowCapFactorMantissa = 0.8e18;
        //10%
        reserveFactorMantissa = 0.1e18;


        name = name_;
        symbol = symbol_;
        decimals = decimals_;

        _notEntered = true;

        // Set underlying and sanity check it
        underlying = underlying_;
        IERC20(underlying).totalSupply();
        emit Transfer(address(0), msg.sender, 0);
    }

    /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
    /// @dev Called by both `transfer` and `transferFrom` internally
    /// @param spender The address of the account performing the transfer
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param tokens The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {
        require(dst != address(0), "dst address cannot be 0");
        /* Do not allow self-transfers */
        require(src != dst, "src = dst");
        /* Fail if transfer not allowed */
        (ControllerInterface(controller)).transferAllowed(src, dst, tokens);

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(- 1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        require(mathErr == MathError.NO_ERROR, 'not allowed');

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        require(mathErr == MathError.NO_ERROR, 'not enough');

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        require(mathErr == MathError.NO_ERROR, 'too much');

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(- 1)) {
            transferAllowances[src][spender] = allowanceNew;
        }
        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);
        return true;
    }

    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount);
    }

    /// @notice Transfer `amount` tokens from `src` to `dst`
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount);
    }

    /// @notice Approve `spender` to transfer up to `amount` from `src`
    /// @dev This will overwrite the approval amount for `spender`
    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
    /// @param spender The address of the account which may transfer tokens
    /// @param amount The number of tokens that are approved (-1 means infinite)
    /// @return Whether or not the approval succeeded
    function approve(address spender, uint256 amount) external override returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /// @notice Get the current allowance from `owner` for `spender`
    /// @param owner The address of the account which owns the tokens to be spent
    /// @param spender The address of the account which may transfer tokens
    /// @return The number of tokens allowed to be spent (-1 means infinite)
    function allowance(address owner, address spender) external override view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /// @notice Get the token balance of the `owner`
    /// @param owner The address of the account to query
    /// @return The number of tokens owned by `owner`
    function balanceOf(address owner) external override view returns (uint256) {
        return accountTokens[owner];
    }

    /// @notice Get the underlying balance of the `owner`
    /// @dev This also accrues interest in a transaction
    /// @param owner The address of the account to query
    /// @return The amount of underlying owned by `owner`
    function balanceOfUnderlying(address owner) external override returns (uint) {
        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR, "calc failed");
        return balance;
    }

    /*** User Interface ***/

    /// @notice Sender supplies assets into the market and receives lTokens in exchange
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param mintAmount The amount of the underlying asset to supply
    function mint(uint mintAmount) external override nonReentrant {
        accrueInterest();
        mintFresh(msg.sender, mintAmount, false);
    }

    function mintTo(address to, uint amount) external payable override nonReentrant {
        accrueInterest();
        if (isWethPool) {
            mintFresh(to, msg.value, false);
        } else {
            mintFresh(to, amount, true);
        }
    }

    function mintEth() external payable override nonReentrant {
        require(isWethPool, "not eth pool");
        accrueInterest();
        mintFresh(msg.sender, msg.value, false);
    }

    /// @notice Sender redeems lTokens in exchange for the underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemTokens The number of lTokens to redeem into underlying
    function redeem(uint redeemTokens) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, redeemTokens, 0);
    }

    /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemAmount The amount of underlying to redeem
    function redeemUnderlying(uint redeemAmount) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, 0, redeemAmount);
    }

    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {
        accrueInterest();
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        borrowFresh(payable(borrower), msg.sender, borrowAmount);
    }

    /// @notice Sender repays a borrow belonging to borrower
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount The amount to repay
    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        repayBorrowFresh(msg.sender, borrower, repayAmount, false);
    }

    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        repayBorrowFresh(msg.sender, borrower, repayAmount, true);
    }


    /*** Safe Token ***/

    /// Gets balance of this contract in terms of the underlying
    /// @dev This excludes the value of the current message, if any
    /// @return The quantity of underlying tokens owned by this contract
    function getCashPrior() internal view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }


    /**
     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.
     *      This will revert due to insufficient balance or insufficient allowance.
     *      This function returns the actual amount received,
     *      which may be less than `amount` if there is a fee attached to the transfer.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {
        if (isWethPool && convertWeth) {
            actualAmount = msg.value;
            IWETH(underlying).deposit{value : actualAmount}();
        } else {
            actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);
        }
    }

    /**
     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory
     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to
     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified
     *      it is >= amount, this should not revert in normal conditions.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {
        if (isWethPool && convertWeth) {
            IWETH(underlying).withdraw(amount);
            to.transfer(amount);
        } else {
            IERC20(underlying).safeTransfer(to, amount);
        }
    }

    function availableForBorrow() external view override returns (uint){
        uint cash = getCashPrior();
        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);
        if (err0 != MathError.NO_ERROR) {
            return 0;
        }
        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);
        if (err1 != MathError.NO_ERROR) {
            return 0;
        }
        if (totalBorrows > maxAvailable) {
            return 0;
        }
        return maxAvailable - totalBorrows;
    }


    /// @notice Get a snapshot of the account's balances, and the cached exchange rate
    /// @dev This is used by controller to more efficiently perform liquidity checks.
    /// @param account Address of the account to snapshot
    /// @return ( token balance, borrow balance, exchange rate mantissa)
    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        return (cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /// @dev Function to simply retrieve block number
    ///  This exists mainly for inheriting test contracts to stub this result.
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /// @notice Returns the current per-block borrow interest rate for this cToken
    /// @return The borrow interest rate per block, scaled by 1e18
    function borrowRatePerBlock() external override view returns (uint) {
        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
    }

    
    /// @notice Returns the current per-block supply interest rate for this cToken
    /// @return The supply interest rate per block, scaled by 1e18
    function supplyRatePerBlock() external override view returns (uint) {
        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);
    }

    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {
        // Utilization rate is 0 when there are no borrows
        if (borrows == 0) {
            return 0;
        }
        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));
    }

    /// @notice Calculates the current borrow rate per block, with the error code expected by the market
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18)
    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {
        uint util = utilizationRate(cash, borrows, reserves);
        if (util <= kink) {
            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
        } else {
            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
            uint excessUtil = util.sub(kink);
            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);
        }
    }

    /// @notice Calculates the current supply rate per block
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The supply rate percentage per block as a mantissa (scaled by 1e18)
    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {
        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);
        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);
        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);
        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);
    }

    /// @notice Returns the current total borrows plus accrued interest
    /// @return The total borrows with interest
    function totalBorrowsCurrent() external override view returns (uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return totalBorrows;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        return totalBorrowsNew;
    }

    /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
    /// @param account The address whose balance should be calculated after updating borrowIndex
    /// @return The calculated balance
    function borrowBalanceCurrent(address account) external view override returns (uint) {
        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();
        require(err0 == MathError.NO_ERROR, "calc borrow index fail");
        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
        require(err1 == MathError.NO_ERROR, "calc fail");
        return result;
    }

    function borrowBalanceStored(address account) external override view returns (uint){
        return accountBorrows[account].principal;
    }


    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
    }

    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /// @notice Accrue interest then return the up-to-date exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateCurrent() public override nonReentrant returns (uint) {
        accrueInterest();
        return exchangeRateStored();
    }

    /// Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateStored() public override view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "calc fail");
        return result;
    }

    /// @notice Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return (error code, calculated exchange rate scaled by 1e18)
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        uint _totalSupply = totalSupply;
        if (_totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint _totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /// @notice Get cash balance of this cToken in the underlying asset
    /// @return The quantity of underlying asset owned by this contract
    function getCash() external override view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }

    function calCurrentBorrowIndex() internal view returns (MathError, uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;
        uint borrowIndexNew;
        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return (MathError.NO_ERROR, borrowIndex);
        }
        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);

        Exp memory simpleInterestFactor;
        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }
        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);
        return (mathErr, borrowIndexNew);
    }

    /// @notice Applies accrued interest to total borrows and reserves
    /// @dev This calculates interest accrued from the last checkpointed block
    ///   up to the current block and writes new checkpoint to storage.
    function accrueInterest() public override {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint borrowIndexPrior = borrowIndex;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");


        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;
        uint borrowIndexNew;
        uint totalReservesNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total reserves error');

        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);
        require(mathErr == MathError.NO_ERROR, 'calc borrows index error');


        /* We write the previously calculated values into storage */
        accrualBlockNumber = currentBlockNumber;
        borrowIndex = borrowIndexNew;
        totalBorrows = totalBorrowsNew;
        totalReserves = totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);

    }

    struct MintLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
        uint actualMintAmount;
    }

    /// @notice User supplies assets into the market and receives lTokens in exchange
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param minter The address of the account which is supplying the assets
    /// @param mintAmount The amount of the underlying asset to supply
    /// @return uint the actual mint amount.
    function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {
        MintLocalVars memory vars;
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /*
         *  We call `doTransferIn` for the minter and the mintAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if
         *  side-effects occurred. The function returns the amount actually transferred,
         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`
         *  of cash.
         */
        if (isDelegete) {
            uint balanceBefore = getCashPrior();
            LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);
            uint balanceAfter = getCashPrior();
            require(balanceAfter > balanceBefore, 'mint 0');
            vars.actualMintAmount = balanceAfter - balanceBefore;
        } else {
            vars.actualMintAmount = doTransferIn(minter, mintAmount, true);
        }
        /*
         * We get the current exchange rate and calculate the number of lTokens to be minted:
         *  mintTokens = actualMintAmount / exchangeRate
         */

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));
        require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");

        /* Fail if mint not allowed */
        (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);
        /*
         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */

        return vars.actualMintAmount;
    }


    struct RedeemLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /// @notice User redeems lTokens in exchange for the underlying asset
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param redeemer The address of the account which is redeeming the tokens
    /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');
            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');
        require(getCashPrior() >= vars.redeemAmount, 'cash < redeem');

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;
        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(redeemer, vars.redeemAmount, true);


        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
    }

    struct BorrowLocalVars {
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /// @notice Users borrow assets from the protocol to their own address
    /// @param borrowAmount The amount of the underlying asset to borrow
    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {
        /* Fail if borrow not allowed */
        (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);

        /* Fail gracefully if protocol has insufficient underlying cash */
        require(getCashPrior() >= borrowAmount, 'cash<borrow');

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(payee, borrowAmount, false);

        /* We emit a Borrow event */
        emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
    }

    struct RepayBorrowLocalVars {
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
        uint actualRepayAmount;
        uint badDebtsAmount;
    }

    /// @notice Borrows are repaid by another user (possibly the borrower).
    /// @param payer the account paying off the borrow
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount the amount of undelrying tokens being returned
    function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {
        /* Fail if repayBorrow not allowed */
        (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(- 1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }
        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);


        if (isEnd && vars.accountBorrows > vars.actualRepayAmount) {
            vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;
        }

        /*
        *  We calculate the new borrower and total borrow balances, failing on underflow:
        *  accountBorrowsNew = accountBorrows - repayAmount
        *  totalBorrowsNew = totalBorrows - repayAmount
        */
        if (vars.accountBorrows < vars.actualRepayAmount) {
            require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) <= 105e16, 'repay more than 5%');
            vars.accountBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.accountBorrowsNew = 0;
            } else {
                vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;
            }
        }
        //Avoid mantissa errors
        if (vars.actualRepayAmount > totalBorrows) {
            vars.totalBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);
            } else {
                vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;
            }
        }

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */

        return vars.actualRepayAmount;
    }

    /*** Admin Functions ***/

    /// @notice Sets a new CONTROLLER for the market
    /// @dev Admin function to set a new controller
    function setController(address newController) external override onlyAdmin {
        require(address(0) != newController, "0x");
        address oldController = controller;
        controller = newController;
        // Emit NewController(oldController, newController)
        emit NewController(oldController, newController);
    }

    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {
        require(newBorrowCapFactorMantissa <= 1e18, 'Factor too large');
        uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;
        borrowCapFactorMantissa = newBorrowCapFactorMantissa;
        emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa);
    }

    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {
        //accrueInterest except first
        if (baseRatePerBlock != 0) {
            accrueInterest();
        }
        // total rate perYear < 2000%
        require(baseRatePerBlock_ < 1e13, 'Base rate too large');
        baseRatePerBlock = baseRatePerBlock_;
        require(multiplierPerBlock_ < 1e13, 'Mul rate too large');
        multiplierPerBlock = multiplierPerBlock_;
        require(jumpMultiplierPerBlock_ < 1e13, 'Jump rate too large');
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        require(kink_ <= 1e18, 'Kline too large');
        kink = kink_;
        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);
    }

    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {
        require(newReserveFactorMantissa <= 1e18, 'Factor too large');
        accrueInterest();
        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;
        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);
    }

    function addReserves(uint addAmount) external override nonReentrant {
        accrueInterest();
        uint totalReservesNew;
        uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);
        totalReservesNew = totalReserves.add(actualAddAmount);
        totalReserves = totalReservesNew;
        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);
    }

    function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {
        accrueInterest();
        uint totalReservesNew;
        totalReservesNew = totalReserves.sub(reduceAmount);
        totalReserves = totalReservesNew;
        doTransferOut(to, reduceAmount, true);
        emit ReservesReduced(to, reduceAmount, totalReservesNew);
    }

    modifier sameBlock() {
        require(accrualBlockNumber == getBlockNumber(), 'not same block');
        _;
    }
}

.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;


import "./LPoolInterface.sol";
import "./LPoolDepositor.sol";
import "../lib/Exponential.sol";
import "../Adminable.sol";
import "../lib/CarefulMath.sol";
import "../lib/TransferHelper.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import "../DelegateInterface.sol";
import "../ControllerInterface.sol";
import "../IWETH.sol";

/// @title OpenLeverage's LToken Contract
/// @dev Abstract base for LTokens
/// @author OpenLeverage
contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {
    using TransferHelper for IERC20;
    using SafeMath for uint;

    constructor() {

    }
    
    /// @notice Initialize the money market
    /// @param controller_ The address of the Controller
    /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0
    /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate
    /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point
    /// @param kink_ The utilization point at which the jump multiplier is applied
    /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
    /// @param name_ EIP-20 name of this token
    /// @param symbol_ EIP-20 symbol of this token
    /// @param decimals_ EIP-20 decimal precision of this token
    function initialize(
        address underlying_,
        bool isWethPool_,
        address controller_,
        uint256 baseRatePerBlock_,
        uint256 multiplierPerBlock_,
        uint256 jumpMultiplierPerBlock_,
        uint256 kink_,
        uint initialExchangeRateMantissa_,
        string memory name_,
        string memory symbol_,
        uint8 decimals_) public {
        require(underlying_ != address(0), "underlying_ address cannot be 0");
        require(controller_ != address(0), "controller_ address cannot be 0");
        require(msg.sender == admin, "Only allow to be called by admin");
        require(accrualBlockNumber == 0 && borrowIndex == 0, "inited once");

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial Exchange Rate Mantissa should be greater zero");
        //set controller
        controller = controller_;
        isWethPool = isWethPool_;
        //set interestRateModel
        baseRatePerBlock = baseRatePerBlock_;
        multiplierPerBlock = multiplierPerBlock_;
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        kink = kink_;

        // Initialize block number and borrow index (block number mocks depend on controller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = 1e25;
        //80%
        borrowCapFactorMantissa = 0.8e18;
        //10%
        reserveFactorMantissa = 0.1e18;


        name = name_;
        symbol = symbol_;
        decimals = decimals_;

        _notEntered = true;

        // Set underlying and sanity check it
        underlying = underlying_;
        IERC20(underlying).totalSupply();
        emit Transfer(address(0), msg.sender, 0);
    }

    /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
    /// @dev Called by both `transfer` and `transferFrom` internally
    /// @param spender The address of the account performing the transfer
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param tokens The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {
        require(dst != address(0), "dst address cannot be 0");
        /* Do not allow self-transfers */
        require(src != dst, "src = dst");
        /* Fail if transfer not allowed */
        (ControllerInterface(controller)).transferAllowed(src, dst, tokens);

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(- 1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        require(mathErr == MathError.NO_ERROR, 'not allowed');

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        require(mathErr == MathError.NO_ERROR, 'not enough');

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        require(mathErr == MathError.NO_ERROR, 'too much');

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(- 1)) {
            transferAllowances[src][spender] = allowanceNew;
        }
        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);
        return true;
    }

    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount);
    }

    /// @notice Transfer `amount` tokens from `src` to `dst`
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount);
    }

    /// @notice Approve `spender` to transfer up to `amount` from `src`
    /// @dev This will overwrite the approval amount for `spender`
    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
    /// @param spender The address of the account which may transfer tokens
    /// @param amount The number of tokens that are approved (-1 means infinite)
    /// @return Whether or not the approval succeeded
    function approve(address spender, uint256 amount) external override returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /// @notice Get the current allowance from `owner` for `spender`
    /// @param owner The address of the account which owns the tokens to be spent
    /// @param spender The address of the account which may transfer tokens
    /// @return The number of tokens allowed to be spent (-1 means infinite)
    function allowance(address owner, address spender) external override view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /// @notice Get the token balance of the `owner`
    /// @param owner The address of the account to query
    /// @return The number of tokens owned by `owner`
    function balanceOf(address owner) external override view returns (uint256) {
        return accountTokens[owner];
    }

    /// @notice Get the underlying balance of the `owner`
    /// @dev This also accrues interest in a transaction
    /// @param owner The address of the account to query
    /// @return The amount of underlying owned by `owner`
    function balanceOfUnderlying(address owner) external override returns (uint) {
        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR, "calc failed");
        return balance;
    }

    /*** User Interface ***/

    /// @notice Sender supplies assets into the market and receives lTokens in exchange
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param mintAmount The amount of the underlying asset to supply
    function mint(uint mintAmount) external override nonReentrant {
        accrueInterest();
        mintFresh(msg.sender, mintAmount, false);
    }

    function mintTo(address to, uint amount) external payable override nonReentrant {
        accrueInterest();
        if (isWethPool) {
            mintFresh(to, msg.value, false);
        } else {
            mintFresh(to, amount, true);
        }
    }

    function mintEth() external payable override nonReentrant {
        require(isWethPool, "not eth pool");
        accrueInterest();
        mintFresh(msg.sender, msg.value, false);
    }

    /// @notice Sender redeems lTokens in exchange for the underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemTokens The number of lTokens to redeem into underlying
    function redeem(uint redeemTokens) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, redeemTokens, 0);
    }

    /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemAmount The amount of underlying to redeem
    function redeemUnderlying(uint redeemAmount) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, 0, redeemAmount);
    }

    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {
        accrueInterest();
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        borrowFresh(payable(borrower), msg.sender, borrowAmount);
    }

    /// @notice Sender repays a borrow belonging to borrower
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount The amount to repay
    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        repayBorrowFresh(msg.sender, borrower, repayAmount, false);
    }

    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        repayBorrowFresh(msg.sender, borrower, repayAmount, true);
    }


    /*** Safe Token ***/

    /// Gets balance of this contract in terms of the underlying
    /// @dev This excludes the value of the current message, if any
    /// @return The quantity of underlying tokens owned by this contract
    function getCashPrior() internal view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }


    /**
     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.
     *      This will revert due to insufficient balance or insufficient allowance.
     *      This function returns the actual amount received,
     *      which may be less than `amount` if there is a fee attached to the transfer.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {
        if (isWethPool && convertWeth) {
            actualAmount = msg.value;
            IWETH(underlying).deposit{value : actualAmount}();
        } else {
            actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);
        }
    }

    /**
     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory
     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to
     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified
     *      it is >= amount, this should not revert in normal conditions.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {
        if (isWethPool && convertWeth) {
            IWETH(underlying).withdraw(amount);
            to.transfer(amount);
        } else {
            IERC20(underlying).safeTransfer(to, amount);
        }
    }

    function availableForBorrow() external view override returns (uint){
        uint cash = getCashPrior();
        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);
        if (err0 != MathError.NO_ERROR) {
            return 0;
        }
        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);
        if (err1 != MathError.NO_ERROR) {
            return 0;
        }
        if (totalBorrows > maxAvailable) {
            return 0;
        }
        return maxAvailable - totalBorrows;
    }


    /// @notice Get a snapshot of the account's balances, and the cached exchange rate
    /// @dev This is used by controller to more efficiently perform liquidity checks.
    /// @param account Address of the account to snapshot
    /// @return ( token balance, borrow balance, exchange rate mantissa)
    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        return (cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /// @dev Function to simply retrieve block number
    ///  This exists mainly for inheriting test contracts to stub this result.
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /// @notice Returns the current per-block borrow interest rate for this cToken
    /// @return The borrow interest rate per block, scaled by 1e18
    function borrowRatePerBlock() external override view returns (uint) {
        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
    }

    
    /// @notice Returns the current per-block supply interest rate for this cToken
    /// @return The supply interest rate per block, scaled by 1e18
    function supplyRatePerBlock() external override view returns (uint) {
        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);
    }

    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {
        // Utilization rate is 0 when there are no borrows
        if (borrows == 0) {
            return 0;
        }
        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));
    }

    /// @notice Calculates the current borrow rate per block, with the error code expected by the market
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18)
    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {
        uint util = utilizationRate(cash, borrows, reserves);
        if (util <= kink) {
            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
        } else {
            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
            uint excessUtil = util.sub(kink);
            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);
        }
    }

    /// @notice Calculates the current supply rate per block
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The supply rate percentage per block as a mantissa (scaled by 1e18)
    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {
        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);
        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);
        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);
        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);
    }

    /// @notice Returns the current total borrows plus accrued interest
    /// @return The total borrows with interest
    function totalBorrowsCurrent() external override view returns (uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return totalBorrows;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        return totalBorrowsNew;
    }

    /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
    /// @param account The address whose balance should be calculated after updating borrowIndex
    /// @return The calculated balance
    function borrowBalanceCurrent(address account) external view override returns (uint) {
        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();
        require(err0 == MathError.NO_ERROR, "calc borrow index fail");
        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
        require(err1 == MathError.NO_ERROR, "calc fail");
        return result;
    }

    function borrowBalanceStored(address account) external override view returns (uint){
        return accountBorrows[account].principal;
    }


    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
    }

    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /// @notice Accrue interest then return the up-to-date exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateCurrent() public override nonReentrant returns (uint) {
        accrueInterest();
        return exchangeRateStored();
    }

    /// Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateStored() public override view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "calc fail");
        return result;
    }

    /// @notice Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return (error code, calculated exchange rate scaled by 1e18)
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        uint _totalSupply = totalSupply;
        if (_totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint _totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /// @notice Get cash balance of this cToken in the underlying asset
    /// @return The quantity of underlying asset owned by this contract
    function getCash() external override view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }

    function calCurrentBorrowIndex() internal view returns (MathError, uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;
        uint borrowIndexNew;
        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return (MathError.NO_ERROR, borrowIndex);
        }
        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);

        Exp memory simpleInterestFactor;
        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }
        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);
        return (mathErr, borrowIndexNew);
    }

    /// @notice Applies accrued interest to total borrows and reserves
    /// @dev This calculates interest accrued from the last checkpointed block
    ///   up to the current block and writes new checkpoint to storage.
    function accrueInterest() public override {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint borrowIndexPrior = borrowIndex;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");


        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;
        uint borrowIndexNew;
        uint totalReservesNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total reserves error');

        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);
        require(mathErr == MathError.NO_ERROR, 'calc borrows index error');


        /* We write the previously calculated values into storage */
        accrualBlockNumber = currentBlockNumber;
        borrowIndex = borrowIndexNew;
        totalBorrows = totalBorrowsNew;
        totalReserves = totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);

    }

    struct MintLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
        uint actualMintAmount;
    }

    /// @notice User supplies assets into the market and receives lTokens in exchange
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param minter The address of the account which is supplying the assets
    /// @param mintAmount The amount of the underlying asset to supply
    /// @return uint the actual mint amount.
    function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {
        MintLocalVars memory vars;
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /*
         *  We call `doTransferIn` for the minter and the mintAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if
         *  side-effects occurred. The function returns the amount actually transferred,
         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`
         *  of cash.
         */
        if (isDelegete) {
            uint balanceBefore = getCashPrior();
            LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);
            uint balanceAfter = getCashPrior();
            require(balanceAfter > balanceBefore, 'mint 0');
            vars.actualMintAmount = balanceAfter - balanceBefore;
        } else {
            vars.actualMintAmount = doTransferIn(minter, mintAmount, true);
        }
        /*
         * We get the current exchange rate and calculate the number of lTokens to be minted:
         *  mintTokens = actualMintAmount / exchangeRate
         */

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));
        require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");

        /* Fail if mint not allowed */
        (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);
        /*
         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */

        return vars.actualMintAmount;
    }


    struct RedeemLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /// @notice User redeems lTokens in exchange for the underlying asset
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param redeemer The address of the account which is redeeming the tokens
    /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');
            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');
        require(getCashPrior() >= vars.redeemAmount, 'cash < redeem');

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;
        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(redeemer, vars.redeemAmount, true);


        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
    }

    struct BorrowLocalVars {
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /// @notice Users borrow assets from the protocol to their own address
    /// @param borrowAmount The amount of the underlying asset to borrow
    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {
        /* Fail if borrow not allowed */
        (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);

        /* Fail gracefully if protocol has insufficient underlying cash */
        require(getCashPrior() >= borrowAmount, 'cash<borrow');

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(payee, borrowAmount, false);

        /* We emit a Borrow event */
        emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
    }

    struct RepayBorrowLocalVars {
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
        uint actualRepayAmount;
        uint badDebtsAmount;
    }

    /// @notice Borrows are repaid by another user (possibly the borrower).
    /// @param payer the account paying off the borrow
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount the amount of undelrying tokens being returned
    function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {
        /* Fail if repayBorrow not allowed */
        (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(- 1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }
        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);


        if (isEnd && vars.accountBorrows > vars.actualRepayAmount) {
            vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;
        }

        /*
        *  We calculate the new borrower and total borrow balances, failing on underflow:
        *  accountBorrowsNew = accountBorrows - repayAmount
        *  totalBorrowsNew = totalBorrows - repayAmount
        */
        if (vars.accountBorrows < vars.actualRepayAmount) {
            require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) <= 105e16, 'repay more than 5%');
            vars.accountBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.accountBorrowsNew = 0;
            } else {
                vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;
            }
        }
        //Avoid mantissa errors
        if (vars.actualRepayAmount > totalBorrows) {
            vars.totalBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);
            } else {
                vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;
            }
        }

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */

        return vars.actualRepayAmount;
    }

    /*** Admin Functions ***/

    /// @notice Sets a new CONTROLLER for the market
    /// @dev Admin function to set a new controller
    function setController(address newController) external override onlyAdmin {
        require(address(0) != newController, "0x");
        address oldController = controller;
        controller = newController;
        // Emit NewController(oldController, newController)
        emit NewController(oldController, newController);
    }

    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {
        require(newBorrowCapFactorMantissa <= 1e18, 'Factor too large');
        uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;
        borrowCapFactorMantissa = newBorrowCapFactorMantissa;
        emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa);
    }

    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {
        //accrueInterest except first
        if (baseRatePerBlock != 0) {
            accrueInterest();
        }
        // total rate perYear < 2000%
        require(baseRatePerBlock_ < 1e13, 'Base rate too large');
        baseRatePerBlock = baseRatePerBlock_;
        require(multiplierPerBlock_ < 1e13, 'Mul rate too large');
        multiplierPerBlock = multiplierPerBlock_;
        require(jumpMultiplierPerBlock_ < 1e13, 'Jump rate too large');
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        require(kink_ <= 1e18, 'Kline too large');
        kink = kink_;
        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);
    }

    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {
        require(newReserveFactorMantissa <= 1e18, 'Factor too large');
        accrueInterest();
        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;
        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);
    }

    function addReserves(uint addAmount) external override nonReentrant {
        accrueInterest();
        uint totalReservesNew;
        uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);
        totalReservesNew = totalReserves.add(actualAddAmount);
        totalReserves = totalReservesNew;
        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);
    }

    function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {
        accrueInterest();
        uint totalReservesNew;
        totalReservesNew = totalReserves.sub(reduceAmount);
        totalReserves = totalReservesNew;
        doTransferOut(to, reduceAmount, true);
        emit ReservesReduced(to, reduceAmount, totalReservesNew);
    }

    modifier sameBlock() {
        require(accrualBlockNumber == getBlockNumber(), 'not same block');
        _;
    }
}

".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-24-08 19:28:04 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-24-08 19:28:04 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 19883
completion_tokens: 1
total_tokens: 19884
cost: $-1.000000


[2024-24-08 19:28:04 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;


import "./LPoolInterface.sol";
import "./LPoolDepositor.sol";
import "../lib/Exponential.sol";
import "../Adminable.sol";
import "../lib/CarefulMath.sol";
import "../lib/TransferHelper.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import "../DelegateInterface.sol";
import "../ControllerInterface.sol";
import "../IWETH.sol";

/// @title OpenLeverage's LToken Contract
/// @dev Abstract base for LTokens
/// @author OpenLeverage
contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {
    using TransferHelper for IERC20;
    using SafeMath for uint;

    constructor() {

    }
    
    /// @notice Initialize the money market
    /// @param controller_ The address of the Controller
    /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0
    /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate
    /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point
    /// @param kink_ The utilization point at which the jump multiplier is applied
    /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
    /// @param name_ EIP-20 name of this token
    /// @param symbol_ EIP-20 symbol of this token
    /// @param decimals_ EIP-20 decimal precision of this token
    function initialize(
        address underlying_,
        bool isWethPool_,
        address controller_,
        uint256 baseRatePerBlock_,
        uint256 multiplierPerBlock_,
        uint256 jumpMultiplierPerBlock_,
        uint256 kink_,
        uint initialExchangeRateMantissa_,
        string memory name_,
        string memory symbol_,
        uint8 decimals_) public {
        require(underlying_ != address(0), "underlying_ address cannot be 0");
        require(controller_ != address(0), "controller_ address cannot be 0");
        require(msg.sender == admin, "Only allow to be called by admin");
        require(accrualBlockNumber == 0 && borrowIndex == 0, "inited once");

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial Exchange Rate Mantissa should be greater zero");
        //set controller
        controller = controller_;
        isWethPool = isWethPool_;
        //set interestRateModel
        baseRatePerBlock = baseRatePerBlock_;
        multiplierPerBlock = multiplierPerBlock_;
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        kink = kink_;

        // Initialize block number and borrow index (block number mocks depend on controller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = 1e25;
        //80%
        borrowCapFactorMantissa = 0.8e18;
        //10%
        reserveFactorMantissa = 0.1e18;


        name = name_;
        symbol = symbol_;
        decimals = decimals_;

        _notEntered = true;

        // Set underlying and sanity check it
        underlying = underlying_;
        IERC20(underlying).totalSupply();
        emit Transfer(address(0), msg.sender, 0);
    }

    /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
    /// @dev Called by both `transfer` and `transferFrom` internally
    /// @param spender The address of the account performing the transfer
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param tokens The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {
        require(dst != address(0), "dst address cannot be 0");
        /* Do not allow self-transfers */
        require(src != dst, "src = dst");
        /* Fail if transfer not allowed */
        (ControllerInterface(controller)).transferAllowed(src, dst, tokens);

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(- 1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        require(mathErr == MathError.NO_ERROR, 'not allowed');

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        require(mathErr == MathError.NO_ERROR, 'not enough');

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        require(mathErr == MathError.NO_ERROR, 'too much');

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(- 1)) {
            transferAllowances[src][spender] = allowanceNew;
        }
        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);
        return true;
    }

    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount);
    }

    /// @notice Transfer `amount` tokens from `src` to `dst`
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount);
    }

    /// @notice Approve `spender` to transfer up to `amount` from `src`
    /// @dev This will overwrite the approval amount for `spender`
    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
    /// @param spender The address of the account which may transfer tokens
    /// @param amount The number of tokens that are approved (-1 means infinite)
    /// @return Whether or not the approval succeeded
    function approve(address spender, uint256 amount) external override returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /// @notice Get the current allowance from `owner` for `spender`
    /// @param owner The address of the account which owns the tokens to be spent
    /// @param spender The address of the account which may transfer tokens
    /// @return The number of tokens allowed to be spent (-1 means infinite)
    function allowance(address owner, address spender) external override view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /// @notice Get the token balance of the `owner`
    /// @param owner The address of the account to query
    /// @return The number of tokens owned by `owner`
    function balanceOf(address owner) external override view returns (uint256) {
        return accountTokens[owner];
    }

    /// @notice Get the underlying balance of the `owner`
    /// @dev This also accrues interest in a transaction
    /// @param owner The address of the account to query
    /// @return The amount of underlying owned by `owner`
    function balanceOfUnderlying(address owner) external override returns (uint) {
        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR, "calc failed");
        return balance;
    }

    /*** User Interface ***/

    /// @notice Sender supplies assets into the market and receives lTokens in exchange
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param mintAmount The amount of the underlying asset to supply
    function mint(uint mintAmount) external override nonReentrant {
        accrueInterest();
        mintFresh(msg.sender, mintAmount, false);
    }

    function mintTo(address to, uint amount) external payable override nonReentrant {
        accrueInterest();
        if (isWethPool) {
            mintFresh(to, msg.value, false);
        } else {
            mintFresh(to, amount, true);
        }
    }

    function mintEth() external payable override nonReentrant {
        require(isWethPool, "not eth pool");
        accrueInterest();
        mintFresh(msg.sender, msg.value, false);
    }

    /// @notice Sender redeems lTokens in exchange for the underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemTokens The number of lTokens to redeem into underlying
    function redeem(uint redeemTokens) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, redeemTokens, 0);
    }

    /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemAmount The amount of underlying to redeem
    function redeemUnderlying(uint redeemAmount) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, 0, redeemAmount);
    }

    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {
        accrueInterest();
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        borrowFresh(payable(borrower), msg.sender, borrowAmount);
    }

    /// @notice Sender repays a borrow belonging to borrower
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount The amount to repay
    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        repayBorrowFresh(msg.sender, borrower, repayAmount, false);
    }

    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        repayBorrowFresh(msg.sender, borrower, repayAmount, true);
    }


    /*** Safe Token ***/

    /// Gets balance of this contract in terms of the underlying
    /// @dev This excludes the value of the current message, if any
    /// @return The quantity of underlying tokens owned by this contract
    function getCashPrior() internal view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }


    /**
     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.
     *      This will revert due to insufficient balance or insufficient allowance.
     *      This function returns the actual amount received,
     *      which may be less than `amount` if there is a fee attached to the transfer.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {
        if (isWethPool && convertWeth) {
            actualAmount = msg.value;
            IWETH(underlying).deposit{value : actualAmount}();
        } else {
            actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);
        }
    }

    /**
     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory
     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to
     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified
     *      it is >= amount, this should not revert in normal conditions.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {
        if (isWethPool && convertWeth) {
            IWETH(underlying).withdraw(amount);
            to.transfer(amount);
        } else {
            IERC20(underlying).safeTransfer(to, amount);
        }
    }

    function availableForBorrow() external view override returns (uint){
        uint cash = getCashPrior();
        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);
        if (err0 != MathError.NO_ERROR) {
            return 0;
        }
        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);
        if (err1 != MathError.NO_ERROR) {
            return 0;
        }
        if (totalBorrows > maxAvailable) {
            return 0;
        }
        return maxAvailable - totalBorrows;
    }


    /// @notice Get a snapshot of the account's balances, and the cached exchange rate
    /// @dev This is used by controller to more efficiently perform liquidity checks.
    /// @param account Address of the account to snapshot
    /// @return ( token balance, borrow balance, exchange rate mantissa)
    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        return (cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /// @dev Function to simply retrieve block number
    ///  This exists mainly for inheriting test contracts to stub this result.
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /// @notice Returns the current per-block borrow interest rate for this cToken
    /// @return The borrow interest rate per block, scaled by 1e18
    function borrowRatePerBlock() external override view returns (uint) {
        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
    }

    
    /// @notice Returns the current per-block supply interest rate for this cToken
    /// @return The supply interest rate per block, scaled by 1e18
    function supplyRatePerBlock() external override view returns (uint) {
        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);
    }

    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {
        // Utilization rate is 0 when there are no borrows
        if (borrows == 0) {
            return 0;
        }
        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));
    }

    /// @notice Calculates the current borrow rate per block, with the error code expected by the market
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18)
    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {
        uint util = utilizationRate(cash, borrows, reserves);
        if (util <= kink) {
            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
        } else {
            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
            uint excessUtil = util.sub(kink);
            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);
        }
    }

    /// @notice Calculates the current supply rate per block
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The supply rate percentage per block as a mantissa (scaled by 1e18)
    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {
        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);
        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);
        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);
        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);
    }

    /// @notice Returns the current total borrows plus accrued interest
    /// @return The total borrows with interest
    function totalBorrowsCurrent() external override view returns (uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return totalBorrows;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        return totalBorrowsNew;
    }

    /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
    /// @param account The address whose balance should be calculated after updating borrowIndex
    /// @return The calculated balance
    function borrowBalanceCurrent(address account) external view override returns (uint) {
        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();
        require(err0 == MathError.NO_ERROR, "calc borrow index fail");
        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
        require(err1 == MathError.NO_ERROR, "calc fail");
        return result;
    }

    function borrowBalanceStored(address account) external override view returns (uint){
        return accountBorrows[account].principal;
    }


    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
    }

    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /// @notice Accrue interest then return the up-to-date exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateCurrent() public override nonReentrant returns (uint) {
        accrueInterest();
        return exchangeRateStored();
    }

    /// Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateStored() public override view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "calc fail");
        return result;
    }

    /// @notice Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return (error code, calculated exchange rate scaled by 1e18)
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        uint _totalSupply = totalSupply;
        if (_totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint _totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /// @notice Get cash balance of this cToken in the underlying asset
    /// @return The quantity of underlying asset owned by this contract
    function getCash() external override view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }

    function calCurrentBorrowIndex() internal view returns (MathError, uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;
        uint borrowIndexNew;
        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return (MathError.NO_ERROR, borrowIndex);
        }
        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);

        Exp memory simpleInterestFactor;
        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }
        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);
        return (mathErr, borrowIndexNew);
    }

    /// @notice Applies accrued interest to total borrows and reserves
    /// @dev This calculates interest accrued from the last checkpointed block
    ///   up to the current block and writes new checkpoint to storage.
    function accrueInterest() public override {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint borrowIndexPrior = borrowIndex;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");


        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;
        uint borrowIndexNew;
        uint totalReservesNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total reserves error');

        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);
        require(mathErr == MathError.NO_ERROR, 'calc borrows index error');


        /* We write the previously calculated values into storage */
        accrualBlockNumber = currentBlockNumber;
        borrowIndex = borrowIndexNew;
        totalBorrows = totalBorrowsNew;
        totalReserves = totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);

    }

    struct MintLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
        uint actualMintAmount;
    }

    /// @notice User supplies assets into the market and receives lTokens in exchange
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param minter The address of the account which is supplying the assets
    /// @param mintAmount The amount of the underlying asset to supply
    /// @return uint the actual mint amount.
    function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {
        MintLocalVars memory vars;
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /*
         *  We call `doTransferIn` for the minter and the mintAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if
         *  side-effects occurred. The function returns the amount actually transferred,
         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`
         *  of cash.
         */
        if (isDelegete) {
            uint balanceBefore = getCashPrior();
            LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);
            uint balanceAfter = getCashPrior();
            require(balanceAfter > balanceBefore, 'mint 0');
            vars.actualMintAmount = balanceAfter - balanceBefore;
        } else {
            vars.actualMintAmount = doTransferIn(minter, mintAmount, true);
        }
        /*
         * We get the current exchange rate and calculate the number of lTokens to be minted:
         *  mintTokens = actualMintAmount / exchangeRate
         */

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));
        require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");

        /* Fail if mint not allowed */
        (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);
        /*
         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */

        return vars.actualMintAmount;
    }


    struct RedeemLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /// @notice User redeems lTokens in exchange for the underlying asset
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param redeemer The address of the account which is redeeming the tokens
    /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');
            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');
        require(getCashPrior() >= vars.redeemAmount, 'cash < redeem');

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;
        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(redeemer, vars.redeemAmount, true);


        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
    }

    struct BorrowLocalVars {
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /// @notice Users borrow assets from the protocol to their own address
    /// @param borrowAmount The amount of the underlying asset to borrow
    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {
        /* Fail if borrow not allowed */
        (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);

        /* Fail gracefully if protocol has insufficient underlying cash */
        require(getCashPrior() >= borrowAmount, 'cash<borrow');

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(payee, borrowAmount, false);

        /* We emit a Borrow event */
        emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
    }

    struct RepayBorrowLocalVars {
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
        uint actualRepayAmount;
        uint badDebtsAmount;
    }

    /// @notice Borrows are repaid by another user (possibly the borrower).
    /// @param payer the account paying off the borrow
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount the amount of undelrying tokens being returned
    function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {
        /* Fail if repayBorrow not allowed */
        (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(- 1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }
        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);


        if (isEnd && vars.accountBorrows > vars.actualRepayAmount) {
            vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;
        }

        /*
        *  We calculate the new borrower and total borrow balances, failing on underflow:
        *  accountBorrowsNew = accountBorrows - repayAmount
        *  totalBorrowsNew = totalBorrows - repayAmount
        */
        if (vars.accountBorrows < vars.actualRepayAmount) {
            require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) <= 105e16, 'repay more than 5%');
            vars.accountBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.accountBorrowsNew = 0;
            } else {
                vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;
            }
        }
        //Avoid mantissa errors
        if (vars.actualRepayAmount > totalBorrows) {
            vars.totalBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);
            } else {
                vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;
            }
        }

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */

        return vars.actualRepayAmount;
    }

    /*** Admin Functions ***/

    /// @notice Sets a new CONTROLLER for the market
    /// @dev Admin function to set a new controller
    function setController(address newController) external override onlyAdmin {
        require(address(0) != newController, "0x");
        address oldController = controller;
        controller = newController;
        // Emit NewController(oldController, newController)
        emit NewController(oldController, newController);
    }

    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {
        require(newBorrowCapFactorMantissa <= 1e18, 'Factor too large');
        uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;
        borrowCapFactorMantissa = newBorrowCapFactorMantissa;
        emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa);
    }

    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {
        //accrueInterest except first
        if (baseRatePerBlock != 0) {
            accrueInterest();
        }
        // total rate perYear < 2000%
        require(baseRatePerBlock_ < 1e13, 'Base rate too large');
        baseRatePerBlock = baseRatePerBlock_;
        require(multiplierPerBlock_ < 1e13, 'Mul rate too large');
        multiplierPerBlock = multiplierPerBlock_;
        require(jumpMultiplierPerBlock_ < 1e13, 'Jump rate too large');
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        require(kink_ <= 1e18, 'Kline too large');
        kink = kink_;
        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);
    }

    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {
        require(newReserveFactorMantissa <= 1e18, 'Factor too large');
        accrueInterest();
        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;
        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);
    }

    function addReserves(uint addAmount) external override nonReentrant {
        accrueInterest();
        uint totalReservesNew;
        uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);
        totalReservesNew = totalReserves.add(actualAddAmount);
        totalReserves = totalReservesNew;
        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);
    }

    function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {
        accrueInterest();
        uint totalReservesNew;
        totalReservesNew = totalReserves.sub(reduceAmount);
        totalReserves = totalReservesNew;
        doTransferOut(to, reduceAmount, true);
        emit ReservesReduced(to, reduceAmount, totalReservesNew);
    }

    modifier sameBlock() {
        require(accrualBlockNumber == getBlockNumber(), 'not same block');
        _;
    }
}

.]

###

[2024-24-08 19:28:04 INFO] **[Seminar Conclusion]**:

 ###

[2024-24-08 19:28:04 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-24-08 19:28:04 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.7.6; import "./LPoolInterface.sol"; import "./LPoolDepositor.sol"; import "../lib/Exponential.sol"; import "../Adminable.sol"; import "../lib/CarefulMath.sol"; import "../lib/TransferHelper.sol"; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import "../DelegateInterface.sol"; import "../ControllerInterface.sol"; import "../IWETH.sol"; /// @title OpenLeverage's LToken Contract /// @dev Abstract base for LTokens /// @author OpenLeverage contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {     using TransferHelper for IERC20;     using SafeMath for uint; constructor() {  }  /// @notice Initialize the money market /// @param controller_ The address of the Controller /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0 /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point /// @param kink_ The utilization point at which the jump multiplier is applied /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18 /// @param name_ EIP-20 name of this token /// @param symbol_ EIP-20 symbol of this token /// @param decimals_ EIP-20 decimal precision of this token function initialize(     address underlying_,     bool isWethPool_,     address controller_,     uint256 baseRatePerBlock_,     uint256 multiplierPerBlock_,     uint256 jumpMultiplierPerBlock_,     uint256 kink_,     uint initialExchangeRateMantissa_,     string memory name_,     string memory symbol_,     uint8 decimals_) public {     require(underlying_ != address(0), "underlying_ address cannot be 0");     require(controller_ != address(0), "controller_ address cannot be 0");     require(msg.sender == admin, "Only allow to be called by admin");     require(accrualBlockNumber == 0 &amp;&amp; borrowIndex == 0, "inited once");      // Set initial exchange rate     initialExchangeRateMantissa = initialExchangeRateMantissa_;     require(initialExchangeRateMantissa &gt; 0, "Initial Exchange Rate Mantissa should be greater zero");     //set controller     controller = controller_;     isWethPool = isWethPool_;     //set interestRateModel     baseRatePerBlock = baseRatePerBlock_;     multiplierPerBlock = multiplierPerBlock_;     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     kink = kink_;      // Initialize block number and borrow index (block number mocks depend on controller being set)     accrualBlockNumber = getBlockNumber();     borrowIndex = 1e25;     //80%     borrowCapFactorMantissa = 0.8e18;     //10%     reserveFactorMantissa = 0.1e18;       name = name_;     symbol = symbol_;     decimals = decimals_;      _notEntered = true;      // Set underlying and sanity check it     underlying = underlying_;     IERC20(underlying).totalSupply();     emit Transfer(address(0), msg.sender, 0); }  /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender` /// @dev Called by both `transfer` and `transferFrom` internally /// @param spender The address of the account performing the transfer /// @param src The address of the source account /// @param dst The address of the destination account /// @param tokens The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {     require(dst != address(0), "dst address cannot be 0");     /* Do not allow self-transfers */     require(src != dst, "src = dst");     /* Fail if transfer not allowed */     (ControllerInterface(controller)).transferAllowed(src, dst, tokens);      /* Get the allowance, infinite for the account owner */     uint startingAllowance = 0;     if (spender == src) {         startingAllowance = uint(- 1);     } else {         startingAllowance = transferAllowances[src][spender];     }      /* Do the calculations, checking for {under,over}flow */     MathError mathErr;     uint allowanceNew;     uint srcTokensNew;     uint dstTokensNew;      (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);     require(mathErr == MathError.NO_ERROR, 'not allowed');      (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);     require(mathErr == MathError.NO_ERROR, 'not enough');      (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);     require(mathErr == MathError.NO_ERROR, 'too much');      accountTokens[src] = srcTokensNew;     accountTokens[dst] = dstTokensNew;      /* Eat some of the allowance (if necessary) */     if (startingAllowance != uint(- 1)) {         transferAllowances[src][spender] = allowanceNew;     }     /* We emit a Transfer event */     emit Transfer(src, dst, tokens);     return true; }  /// @notice Transfer `amount` tokens from `msg.sender` to `dst` /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, msg.sender, dst, amount); }  /// @notice Transfer `amount` tokens from `src` to `dst` /// @param src The address of the source account /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, src, dst, amount); }  /// @notice Approve `spender` to transfer up to `amount` from `src` /// @dev This will overwrite the approval amount for `spender` ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve) /// @param spender The address of the account which may transfer tokens /// @param amount The number of tokens that are approved (-1 means infinite) /// @return Whether or not the approval succeeded function approve(address spender, uint256 amount) external override returns (bool) {     address src = msg.sender;     transferAllowances[src][spender] = amount;     emit Approval(src, spender, amount);     return true; }  /// @notice Get the current allowance from `owner` for `spender` /// @param owner The address of the account which owns the tokens to be spent /// @param spender The address of the account which may transfer tokens /// @return The number of tokens allowed to be spent (-1 means infinite) function allowance(address owner, address spender) external override view returns (uint256) {     return transferAllowances[owner][spender]; }  /// @notice Get the token balance of the `owner` /// @param owner The address of the account to query /// @return The number of tokens owned by `owner` function balanceOf(address owner) external override view returns (uint256) {     return accountTokens[owner]; }  /// @notice Get the underlying balance of the `owner` /// @dev This also accrues interest in a transaction /// @param owner The address of the account to query /// @return The amount of underlying owned by `owner` function balanceOfUnderlying(address owner) external override returns (uint) {     Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});     (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);     require(mErr == MathError.NO_ERROR, "calc failed");     return balance; }  /*** User Interface ***/  /// @notice Sender supplies assets into the market and receives lTokens in exchange /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param mintAmount The amount of the underlying asset to supply function mint(uint mintAmount) external override nonReentrant {     accrueInterest();     mintFresh(msg.sender, mintAmount, false); }  function mintTo(address to, uint amount) external payable override nonReentrant {     accrueInterest();     if (isWethPool) {         mintFresh(to, msg.value, false);     } else {         mintFresh(to, amount, true);     } }  function mintEth() external payable override nonReentrant {     require(isWethPool, "not eth pool");     accrueInterest();     mintFresh(msg.sender, msg.value, false); }  /// @notice Sender redeems lTokens in exchange for the underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemTokens The number of lTokens to redeem into underlying function redeem(uint redeemTokens) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, redeemTokens, 0); }  /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemAmount The amount of underlying to redeem function redeemUnderlying(uint redeemAmount) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, 0, redeemAmount); }  function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {     accrueInterest();     // borrowFresh emits borrow-specific logs on errors, so we don't need to     borrowFresh(payable(borrower), msg.sender, borrowAmount); }  /// @notice Sender repays a borrow belonging to borrower /// @param borrower the account with the debt being payed off /// @param repayAmount The amount to repay function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     repayBorrowFresh(msg.sender, borrower, repayAmount, false); }  function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     repayBorrowFresh(msg.sender, borrower, repayAmount, true); }   /*** Safe Token ***/  /// Gets balance of this contract in terms of the underlying /// @dev This excludes the value of the current message, if any /// @return The quantity of underlying tokens owned by this contract function getCashPrior() internal view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }   /**  * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.  *      This will revert due to insufficient balance or insufficient allowance.  *      This function returns the actual amount received,  *      which may be less than `amount` if there is a fee attached to the transfer.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {     if (isWethPool &amp;&amp; convertWeth) {         actualAmount = msg.value;         IWETH(underlying).deposit{value : actualAmount}();     } else {         actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);     } }  /**  * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory  *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to  *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified  *      it is &gt;= amount, this should not revert in normal conditions.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferOut(address payable to, uint amount, bool convertWeth) internal {     if (isWethPool &amp;&amp; convertWeth) {         IWETH(underlying).withdraw(amount);         to.transfer(amount);     } else {         IERC20(underlying).safeTransfer(to, amount);     } }  function availableForBorrow() external view override returns (uint){     uint cash = getCashPrior();     (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);     if (err0 != MathError.NO_ERROR) {         return 0;     }     (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);     if (err1 != MathError.NO_ERROR) {         return 0;     }     if (totalBorrows &gt; maxAvailable) {         return 0;     }     return maxAvailable - totalBorrows; }   /// @notice Get a snapshot of the account's balances, and the cached exchange rate /// @dev This is used by controller to more efficiently perform liquidity checks. /// @param account Address of the account to snapshot /// @return ( token balance, borrow balance, exchange rate mantissa) function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {     uint cTokenBalance = accountTokens[account];     uint borrowBalance;     uint exchangeRateMantissa;      MathError mErr;      (mErr, borrowBalance) = borrowBalanceStoredInternal(account);     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      return (cTokenBalance, borrowBalance, exchangeRateMantissa); }  /// @dev Function to simply retrieve block number ///  This exists mainly for inheriting test contracts to stub this result. function getBlockNumber() internal view returns (uint) {     return block.number; }  /// @notice Returns the current per-block borrow interest rate for this cToken /// @return The borrow interest rate per block, scaled by 1e18 function borrowRatePerBlock() external override view returns (uint) {     return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves); }   /// @notice Returns the current per-block supply interest rate for this cToken /// @return The supply interest rate per block, scaled by 1e18 function supplyRatePerBlock() external override view returns (uint) {     return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa); }  function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {     // Utilization rate is 0 when there are no borrows     if (borrows == 0) {         return 0;     }     return borrows.mul(1e18).div(cash.add(borrows).sub(reserves)); }  /// @notice Calculates the current borrow rate per block, with the error code expected by the market /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18) function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {     uint util = utilizationRate(cash, borrows, reserves);     if (util &lt;= kink) {         return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);     } else {         uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);         uint excessUtil = util.sub(kink);         return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);     } }  /// @notice Calculates the current supply rate per block /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The supply rate percentage per block as a mantissa (scaled by 1e18) function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {     uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);     uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);     uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);     return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18); }  /// @notice Returns the current total borrows plus accrued interest /// @return The total borrows with interest function totalBorrowsCurrent() external override view returns (uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return totalBorrows;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, "calc block delta erro");      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      return totalBorrowsNew; }  /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex /// @param account The address whose balance should be calculated after updating borrowIndex /// @return The calculated balance function borrowBalanceCurrent(address account) external view override returns (uint) {     (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();     require(err0 == MathError.NO_ERROR, "calc borrow index fail");     (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);     require(err1 == MathError.NO_ERROR, "calc fail");     return result; }  function borrowBalanceStored(address account) external override view returns (uint){     return accountBorrows[account].principal; }   /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {     return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex); }  /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {     /* Note: we do not assert that the market is up to date */     MathError mathErr;     uint principalTimesIndex;     uint result;      /* Get borrowBalance and borrowIndex */     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];      /* If borrowBalance = 0 then borrowIndex is likely also 0.      * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.      */     if (borrowSnapshot.principal == 0) {         return (MathError.NO_ERROR, 0);     }      /* Calculate new borrow balance using the interest index:      *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex      */     (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      return (MathError.NO_ERROR, result); }  /// @notice Accrue interest then return the up-to-date exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateCurrent() public override nonReentrant returns (uint) {     accrueInterest();     return exchangeRateStored(); }  /// Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateStored() public override view returns (uint) {     (MathError err, uint result) = exchangeRateStoredInternal();     require(err == MathError.NO_ERROR, "calc fail");     return result; }  /// @notice Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return (error code, calculated exchange rate scaled by 1e18) function exchangeRateStoredInternal() internal view returns (MathError, uint) {     uint _totalSupply = totalSupply;     if (_totalSupply == 0) {         /*          * If there are no tokens minted:          *  exchangeRate = initialExchangeRate          */         return (MathError.NO_ERROR, initialExchangeRateMantissa);     } else {         /*          * Otherwise:          *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply          */         uint _totalCash = getCashPrior();         uint cashPlusBorrowsMinusReserves;         Exp memory exchangeRate;         MathError mathErr;          (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          return (MathError.NO_ERROR, exchangeRate.mantissa);     } }  /// @notice Get cash balance of this cToken in the underlying asset /// @return The quantity of underlying asset owned by this contract function getCash() external override view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }  function calCurrentBorrowIndex() internal view returns (MathError, uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;     uint borrowIndexNew;     /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return (MathError.NO_ERROR, borrowIndex);     }     uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);      Exp memory simpleInterestFactor;     (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }     (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);     return (mathErr, borrowIndexNew); }  /// @notice Applies accrued interest to total borrows and reserves /// @dev This calculates interest accrued from the last checkpointed block ///   up to the current block and writes new checkpoint to storage. function accrueInterest() public override {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint borrowIndexPrior = borrowIndex;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, "calc block delta erro");       /*      * Calculate the interest accumulated into borrows and reserves and the new index:      *  simpleInterestFactor = borrowRate * blockDelta      *  interestAccumulated = simpleInterestFactor * totalBorrows      *  totalBorrowsNew = interestAccumulated + totalBorrows      *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex      */      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;     uint borrowIndexNew;     uint totalReservesNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);     require(mathErr == MathError.NO_ERROR, 'calc total reserves error');      (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);     require(mathErr == MathError.NO_ERROR, 'calc borrows index error');       /* We write the previously calculated values into storage */     accrualBlockNumber = currentBlockNumber;     borrowIndex = borrowIndexNew;     totalBorrows = totalBorrowsNew;     totalReserves = totalReservesNew;      /* We emit an AccrueInterest event */     emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);  }  struct MintLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint mintTokens;     uint totalSupplyNew;     uint accountTokensNew;     uint actualMintAmount; }  /// @notice User supplies assets into the market and receives lTokens in exchange /// @dev Assumes interest has already been accrued up to the current block /// @param minter The address of the account which is supplying the assets /// @param mintAmount The amount of the underlying asset to supply /// @return uint the actual mint amount. function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {     MintLocalVars memory vars;     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /*      *  We call `doTransferIn` for the minter and the mintAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if      *  side-effects occurred. The function returns the amount actually transferred,      *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`      *  of cash.      */     if (isDelegete) {         uint balanceBefore = getCashPrior();         LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);         uint balanceAfter = getCashPrior();         require(balanceAfter &gt; balanceBefore, 'mint 0');         vars.actualMintAmount = balanceAfter - balanceBefore;     } else {         vars.actualMintAmount = doTransferIn(minter, mintAmount, true);     }     /*      * We get the current exchange rate and calculate the number of lTokens to be minted:      *  mintTokens = actualMintAmount / exchangeRate      */      (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));     require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");      /* Fail if mint not allowed */     (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);     /*      * We calculate the new total supply of lTokens and minter token balance, checking for overflow:      *  totalSupplyNew = totalSupply + mintTokens      *  accountTokensNew = accountTokens[minter] + mintTokens      */     (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");      (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[minter] = vars.accountTokensNew;      /* We emit a Mint event, and a Transfer event */     emit Mint(minter, vars.actualMintAmount, vars.mintTokens);     emit Transfer(address(this), minter, vars.mintTokens);      /* We call the defense hook */      return vars.actualMintAmount; }   struct RedeemLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint redeemTokens;     uint redeemAmount;     uint totalSupplyNew;     uint accountTokensNew; }  /// @notice User redeems lTokens in exchange for the underlying asset /// @dev Assumes interest has already been accrued up to the current block /// @param redeemer The address of the account which is redeeming the tokens /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero) /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero) function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {     require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");      RedeemLocalVars memory vars;      /* exchangeRate = invoke Exchange Rate Stored() */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /* If redeemTokensIn &gt; 0: */     if (redeemTokensIn &gt; 0) {         /*          * We calculate the exchange rate and the amount of underlying to be redeemed:          *  redeemTokens = redeemTokensIn          *  redeemAmount = redeemTokensIn x exchangeRateCurrent          */         vars.redeemTokens = redeemTokensIn;          (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');     } else {         /*          * We get the current exchange rate and calculate the amount to be redeemed:          *  redeemTokens = redeemAmountIn / exchangeRate          *  redeemAmount = redeemAmountIn          */          (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');         vars.redeemAmount = redeemAmountIn;     }      /* Fail if redeem not allowed */     (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);      /*      * We calculate the new total supply and redeemer balance, checking for underflow:      *  totalSupplyNew = totalSupply - redeemTokens      *  accountTokensNew = accountTokens[redeemer] - redeemTokens      */     (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');      (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');     require(getCashPrior() &gt;= vars.redeemAmount, 'cash &lt; redeem');      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[redeemer] = vars.accountTokensNew;     /*      * We invoke doTransferOut for the redeemer and the redeemAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken has redeemAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(redeemer, vars.redeemAmount, true);       /* We emit a Transfer event, and a Redeem event */     emit Transfer(redeemer, address(this), vars.redeemTokens);     emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);      /* We call the defense hook */ }  struct BorrowLocalVars {     MathError mathErr;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /// @notice Users borrow assets from the protocol to their own address /// @param borrowAmount The amount of the underlying asset to borrow function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {     /* Fail if borrow not allowed */     (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);      /* Fail gracefully if protocol has insufficient underlying cash */     require(getCashPrior() &gt;= borrowAmount, 'cash&lt;borrow');      BorrowLocalVars memory vars;      /*      * We calculate the new borrower and total borrow balances, failing on overflow:      *  accountBorrowsNew = accountBorrows + borrowAmount      *  totalBorrowsNew = totalBorrows + borrowAmount      */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /*      * We invoke doTransferOut for the borrower and the borrowAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken borrowAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(payee, borrowAmount, false);      /* We emit a Borrow event */     emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */ }  struct RepayBorrowLocalVars {     MathError mathErr;     uint repayAmount;     uint borrowerIndex;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew;     uint actualRepayAmount;     uint badDebtsAmount; }  /// @notice Borrows are repaid by another user (possibly the borrower). /// @param payer the account paying off the borrow /// @param borrower the account with the debt being payed off /// @param repayAmount the amount of undelrying tokens being returned function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {     /* Fail if repayBorrow not allowed */     (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);      RepayBorrowLocalVars memory vars;      /* We remember the original borrowerIndex for verification purposes */     vars.borrowerIndex = accountBorrows[borrower].interestIndex;      /* We fetch the amount the borrower owes, with accumulated interest */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');      /* If repayAmount == -1, repayAmount = accountBorrows */     if (repayAmount == uint(- 1)) {         vars.repayAmount = vars.accountBorrows;     } else {         vars.repayAmount = repayAmount;     }     vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);       if (isEnd &amp;&amp; vars.accountBorrows &gt; vars.actualRepayAmount) {         vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;     }      /*     *  We calculate the new borrower and total borrow balances, failing on underflow:     *  accountBorrowsNew = accountBorrows - repayAmount     *  totalBorrowsNew = totalBorrows - repayAmount     */     if (vars.accountBorrows &lt; vars.actualRepayAmount) {         require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) &lt;= 105e16, 'repay more than 5%');         vars.accountBorrowsNew = 0;     } else {         if (isEnd) {             vars.accountBorrowsNew = 0;         } else {             vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;         }     }     //Avoid mantissa errors     if (vars.actualRepayAmount &gt; totalBorrows) {         vars.totalBorrowsNew = 0;     } else {         if (isEnd) {             vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);         } else {             vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;         }     }      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a RepayBorrow event */     emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */      return vars.actualRepayAmount; }  /*** Admin Functions ***/  /// @notice Sets a new CONTROLLER for the market /// @dev Admin function to set a new controller function setController(address newController) external override onlyAdmin {     require(address(0) != newController, "0x");     address oldController = controller;     controller = newController;     // Emit NewController(oldController, newController)     emit NewController(oldController, newController); }  function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {     require(newBorrowCapFactorMantissa &lt;= 1e18, 'Factor too large');     uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;     borrowCapFactorMantissa = newBorrowCapFactorMantissa;     emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa); }  function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {     //accrueInterest except first     if (baseRatePerBlock != 0) {         accrueInterest();     }     // total rate perYear &lt; 2000%     require(baseRatePerBlock_ &lt; 1e13, 'Base rate too large');     baseRatePerBlock = baseRatePerBlock_;     require(multiplierPerBlock_ &lt; 1e13, 'Mul rate too large');     multiplierPerBlock = multiplierPerBlock_;     require(jumpMultiplierPerBlock_ &lt; 1e13, 'Jump rate too large');     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     require(kink_ &lt;= 1e18, 'Kline too large');     kink = kink_;     emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_); }  function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {     require(newReserveFactorMantissa &lt;= 1e18, 'Factor too large');     accrueInterest();     uint oldReserveFactorMantissa = reserveFactorMantissa;     reserveFactorMantissa = newReserveFactorMantissa;     emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa); }  function addReserves(uint addAmount) external override nonReentrant {     accrueInterest();     uint totalReservesNew;     uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);     totalReservesNew = totalReserves.add(actualAddAmount);     totalReserves = totalReservesNew;     emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew); }  function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {     accrueInterest();     uint totalReservesNew;     totalReservesNew = totalReserves.sub(reduceAmount);     totalReserves = totalReservesNew;     doTransferOut(to, reduceAmount, true);     emit ReservesReduced(to, reduceAmount, totalReservesNew); }  modifier sameBlock() {     require(accrualBlockNumber == getBlockNumber(), 'not same block');     _; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-24-08 19:28:04 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.7.6; import "./LPoolInterface.sol"; import "./LPoolDepositor.sol"; import "../lib/Exponential.sol"; import "../Adminable.sol"; import "../lib/CarefulMath.sol"; import "../lib/TransferHelper.sol"; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import "../DelegateInterface.sol"; import "../ControllerInterface.sol"; import "../IWETH.sol"; /// @title OpenLeverage's LToken Contract /// @dev Abstract base for LTokens /// @author OpenLeverage contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {     using TransferHelper for IERC20;     using SafeMath for uint; constructor() {  }  /// @notice Initialize the money market /// @param controller_ The address of the Controller /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0 /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point /// @param kink_ The utilization point at which the jump multiplier is applied /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18 /// @param name_ EIP-20 name of this token /// @param symbol_ EIP-20 symbol of this token /// @param decimals_ EIP-20 decimal precision of this token function initialize(     address underlying_,     bool isWethPool_,     address controller_,     uint256 baseRatePerBlock_,     uint256 multiplierPerBlock_,     uint256 jumpMultiplierPerBlock_,     uint256 kink_,     uint initialExchangeRateMantissa_,     string memory name_,     string memory symbol_,     uint8 decimals_) public {     require(underlying_ != address(0), "underlying_ address cannot be 0");     require(controller_ != address(0), "controller_ address cannot be 0");     require(msg.sender == admin, "Only allow to be called by admin");     require(accrualBlockNumber == 0 &amp;&amp; borrowIndex == 0, "inited once");      // Set initial exchange rate     initialExchangeRateMantissa = initialExchangeRateMantissa_;     require(initialExchangeRateMantissa &gt; 0, "Initial Exchange Rate Mantissa should be greater zero");     //set controller     controller = controller_;     isWethPool = isWethPool_;     //set interestRateModel     baseRatePerBlock = baseRatePerBlock_;     multiplierPerBlock = multiplierPerBlock_;     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     kink = kink_;      // Initialize block number and borrow index (block number mocks depend on controller being set)     accrualBlockNumber = getBlockNumber();     borrowIndex = 1e25;     //80%     borrowCapFactorMantissa = 0.8e18;     //10%     reserveFactorMantissa = 0.1e18;       name = name_;     symbol = symbol_;     decimals = decimals_;      _notEntered = true;      // Set underlying and sanity check it     underlying = underlying_;     IERC20(underlying).totalSupply();     emit Transfer(address(0), msg.sender, 0); }  /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender` /// @dev Called by both `transfer` and `transferFrom` internally /// @param spender The address of the account performing the transfer /// @param src The address of the source account /// @param dst The address of the destination account /// @param tokens The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {     require(dst != address(0), "dst address cannot be 0");     /* Do not allow self-transfers */     require(src != dst, "src = dst");     /* Fail if transfer not allowed */     (ControllerInterface(controller)).transferAllowed(src, dst, tokens);      /* Get the allowance, infinite for the account owner */     uint startingAllowance = 0;     if (spender == src) {         startingAllowance = uint(- 1);     } else {         startingAllowance = transferAllowances[src][spender];     }      /* Do the calculations, checking for {under,over}flow */     MathError mathErr;     uint allowanceNew;     uint srcTokensNew;     uint dstTokensNew;      (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);     require(mathErr == MathError.NO_ERROR, 'not allowed');      (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);     require(mathErr == MathError.NO_ERROR, 'not enough');      (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);     require(mathErr == MathError.NO_ERROR, 'too much');      accountTokens[src] = srcTokensNew;     accountTokens[dst] = dstTokensNew;      /* Eat some of the allowance (if necessary) */     if (startingAllowance != uint(- 1)) {         transferAllowances[src][spender] = allowanceNew;     }     /* We emit a Transfer event */     emit Transfer(src, dst, tokens);     return true; }  /// @notice Transfer `amount` tokens from `msg.sender` to `dst` /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, msg.sender, dst, amount); }  /// @notice Transfer `amount` tokens from `src` to `dst` /// @param src The address of the source account /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, src, dst, amount); }  /// @notice Approve `spender` to transfer up to `amount` from `src` /// @dev This will overwrite the approval amount for `spender` ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve) /// @param spender The address of the account which may transfer tokens /// @param amount The number of tokens that are approved (-1 means infinite) /// @return Whether or not the approval succeeded function approve(address spender, uint256 amount) external override returns (bool) {     address src = msg.sender;     transferAllowances[src][spender] = amount;     emit Approval(src, spender, amount);     return true; }  /// @notice Get the current allowance from `owner` for `spender` /// @param owner The address of the account which owns the tokens to be spent /// @param spender The address of the account which may transfer tokens /// @return The number of tokens allowed to be spent (-1 means infinite) function allowance(address owner, address spender) external override view returns (uint256) {     return transferAllowances[owner][spender]; }  /// @notice Get the token balance of the `owner` /// @param owner The address of the account to query /// @return The number of tokens owned by `owner` function balanceOf(address owner) external override view returns (uint256) {     return accountTokens[owner]; }  /// @notice Get the underlying balance of the `owner` /// @dev This also accrues interest in a transaction /// @param owner The address of the account to query /// @return The amount of underlying owned by `owner` function balanceOfUnderlying(address owner) external override returns (uint) {     Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});     (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);     require(mErr == MathError.NO_ERROR, "calc failed");     return balance; }  /*** User Interface ***/  /// @notice Sender supplies assets into the market and receives lTokens in exchange /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param mintAmount The amount of the underlying asset to supply function mint(uint mintAmount) external override nonReentrant {     accrueInterest();     mintFresh(msg.sender, mintAmount, false); }  function mintTo(address to, uint amount) external payable override nonReentrant {     accrueInterest();     if (isWethPool) {         mintFresh(to, msg.value, false);     } else {         mintFresh(to, amount, true);     } }  function mintEth() external payable override nonReentrant {     require(isWethPool, "not eth pool");     accrueInterest();     mintFresh(msg.sender, msg.value, false); }  /// @notice Sender redeems lTokens in exchange for the underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemTokens The number of lTokens to redeem into underlying function redeem(uint redeemTokens) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, redeemTokens, 0); }  /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemAmount The amount of underlying to redeem function redeemUnderlying(uint redeemAmount) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, 0, redeemAmount); }  function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {     accrueInterest();     // borrowFresh emits borrow-specific logs on errors, so we don't need to     borrowFresh(payable(borrower), msg.sender, borrowAmount); }  /// @notice Sender repays a borrow belonging to borrower /// @param borrower the account with the debt being payed off /// @param repayAmount The amount to repay function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     repayBorrowFresh(msg.sender, borrower, repayAmount, false); }  function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     repayBorrowFresh(msg.sender, borrower, repayAmount, true); }   /*** Safe Token ***/  /// Gets balance of this contract in terms of the underlying /// @dev This excludes the value of the current message, if any /// @return The quantity of underlying tokens owned by this contract function getCashPrior() internal view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }   /**  * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.  *      This will revert due to insufficient balance or insufficient allowance.  *      This function returns the actual amount received,  *      which may be less than `amount` if there is a fee attached to the transfer.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {     if (isWethPool &amp;&amp; convertWeth) {         actualAmount = msg.value;         IWETH(underlying).deposit{value : actualAmount}();     } else {         actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);     } }  /**  * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory  *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to  *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified  *      it is &gt;= amount, this should not revert in normal conditions.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferOut(address payable to, uint amount, bool convertWeth) internal {     if (isWethPool &amp;&amp; convertWeth) {         IWETH(underlying).withdraw(amount);         to.transfer(amount);     } else {         IERC20(underlying).safeTransfer(to, amount);     } }  function availableForBorrow() external view override returns (uint){     uint cash = getCashPrior();     (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);     if (err0 != MathError.NO_ERROR) {         return 0;     }     (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);     if (err1 != MathError.NO_ERROR) {         return 0;     }     if (totalBorrows &gt; maxAvailable) {         return 0;     }     return maxAvailable - totalBorrows; }   /// @notice Get a snapshot of the account's balances, and the cached exchange rate /// @dev This is used by controller to more efficiently perform liquidity checks. /// @param account Address of the account to snapshot /// @return ( token balance, borrow balance, exchange rate mantissa) function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {     uint cTokenBalance = accountTokens[account];     uint borrowBalance;     uint exchangeRateMantissa;      MathError mErr;      (mErr, borrowBalance) = borrowBalanceStoredInternal(account);     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      return (cTokenBalance, borrowBalance, exchangeRateMantissa); }  /// @dev Function to simply retrieve block number ///  This exists mainly for inheriting test contracts to stub this result. function getBlockNumber() internal view returns (uint) {     return block.number; }  /// @notice Returns the current per-block borrow interest rate for this cToken /// @return The borrow interest rate per block, scaled by 1e18 function borrowRatePerBlock() external override view returns (uint) {     return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves); }   /// @notice Returns the current per-block supply interest rate for this cToken /// @return The supply interest rate per block, scaled by 1e18 function supplyRatePerBlock() external override view returns (uint) {     return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa); }  function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {     // Utilization rate is 0 when there are no borrows     if (borrows == 0) {         return 0;     }     return borrows.mul(1e18).div(cash.add(borrows).sub(reserves)); }  /// @notice Calculates the current borrow rate per block, with the error code expected by the market /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18) function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {     uint util = utilizationRate(cash, borrows, reserves);     if (util &lt;= kink) {         return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);     } else {         uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);         uint excessUtil = util.sub(kink);         return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);     } }  /// @notice Calculates the current supply rate per block /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The supply rate percentage per block as a mantissa (scaled by 1e18) function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {     uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);     uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);     uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);     return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18); }  /// @notice Returns the current total borrows plus accrued interest /// @return The total borrows with interest function totalBorrowsCurrent() external override view returns (uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return totalBorrows;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, "calc block delta erro");      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      return totalBorrowsNew; }  /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex /// @param account The address whose balance should be calculated after updating borrowIndex /// @return The calculated balance function borrowBalanceCurrent(address account) external view override returns (uint) {     (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();     require(err0 == MathError.NO_ERROR, "calc borrow index fail");     (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);     require(err1 == MathError.NO_ERROR, "calc fail");     return result; }  function borrowBalanceStored(address account) external override view returns (uint){     return accountBorrows[account].principal; }   /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {     return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex); }  /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {     /* Note: we do not assert that the market is up to date */     MathError mathErr;     uint principalTimesIndex;     uint result;      /* Get borrowBalance and borrowIndex */     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];      /* If borrowBalance = 0 then borrowIndex is likely also 0.      * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.      */     if (borrowSnapshot.principal == 0) {         return (MathError.NO_ERROR, 0);     }      /* Calculate new borrow balance using the interest index:      *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex      */     (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      return (MathError.NO_ERROR, result); }  /// @notice Accrue interest then return the up-to-date exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateCurrent() public override nonReentrant returns (uint) {     accrueInterest();     return exchangeRateStored(); }  /// Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateStored() public override view returns (uint) {     (MathError err, uint result) = exchangeRateStoredInternal();     require(err == MathError.NO_ERROR, "calc fail");     return result; }  /// @notice Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return (error code, calculated exchange rate scaled by 1e18) function exchangeRateStoredInternal() internal view returns (MathError, uint) {     uint _totalSupply = totalSupply;     if (_totalSupply == 0) {         /*          * If there are no tokens minted:          *  exchangeRate = initialExchangeRate          */         return (MathError.NO_ERROR, initialExchangeRateMantissa);     } else {         /*          * Otherwise:          *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply          */         uint _totalCash = getCashPrior();         uint cashPlusBorrowsMinusReserves;         Exp memory exchangeRate;         MathError mathErr;          (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          return (MathError.NO_ERROR, exchangeRate.mantissa);     } }  /// @notice Get cash balance of this cToken in the underlying asset /// @return The quantity of underlying asset owned by this contract function getCash() external override view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }  function calCurrentBorrowIndex() internal view returns (MathError, uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;     uint borrowIndexNew;     /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return (MathError.NO_ERROR, borrowIndex);     }     uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);      Exp memory simpleInterestFactor;     (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }     (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);     return (mathErr, borrowIndexNew); }  /// @notice Applies accrued interest to total borrows and reserves /// @dev This calculates interest accrued from the last checkpointed block ///   up to the current block and writes new checkpoint to storage. function accrueInterest() public override {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint borrowIndexPrior = borrowIndex;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, "calc block delta erro");       /*      * Calculate the interest accumulated into borrows and reserves and the new index:      *  simpleInterestFactor = borrowRate * blockDelta      *  interestAccumulated = simpleInterestFactor * totalBorrows      *  totalBorrowsNew = interestAccumulated + totalBorrows      *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex      */      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;     uint borrowIndexNew;     uint totalReservesNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);     require(mathErr == MathError.NO_ERROR, 'calc total reserves error');      (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);     require(mathErr == MathError.NO_ERROR, 'calc borrows index error');       /* We write the previously calculated values into storage */     accrualBlockNumber = currentBlockNumber;     borrowIndex = borrowIndexNew;     totalBorrows = totalBorrowsNew;     totalReserves = totalReservesNew;      /* We emit an AccrueInterest event */     emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);  }  struct MintLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint mintTokens;     uint totalSupplyNew;     uint accountTokensNew;     uint actualMintAmount; }  /// @notice User supplies assets into the market and receives lTokens in exchange /// @dev Assumes interest has already been accrued up to the current block /// @param minter The address of the account which is supplying the assets /// @param mintAmount The amount of the underlying asset to supply /// @return uint the actual mint amount. function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {     MintLocalVars memory vars;     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /*      *  We call `doTransferIn` for the minter and the mintAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if      *  side-effects occurred. The function returns the amount actually transferred,      *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`      *  of cash.      */     if (isDelegete) {         uint balanceBefore = getCashPrior();         LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);         uint balanceAfter = getCashPrior();         require(balanceAfter &gt; balanceBefore, 'mint 0');         vars.actualMintAmount = balanceAfter - balanceBefore;     } else {         vars.actualMintAmount = doTransferIn(minter, mintAmount, true);     }     /*      * We get the current exchange rate and calculate the number of lTokens to be minted:      *  mintTokens = actualMintAmount / exchangeRate      */      (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));     require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");      /* Fail if mint not allowed */     (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);     /*      * We calculate the new total supply of lTokens and minter token balance, checking for overflow:      *  totalSupplyNew = totalSupply + mintTokens      *  accountTokensNew = accountTokens[minter] + mintTokens      */     (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");      (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[minter] = vars.accountTokensNew;      /* We emit a Mint event, and a Transfer event */     emit Mint(minter, vars.actualMintAmount, vars.mintTokens);     emit Transfer(address(this), minter, vars.mintTokens);      /* We call the defense hook */      return vars.actualMintAmount; }   struct RedeemLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint redeemTokens;     uint redeemAmount;     uint totalSupplyNew;     uint accountTokensNew; }  /// @notice User redeems lTokens in exchange for the underlying asset /// @dev Assumes interest has already been accrued up to the current block /// @param redeemer The address of the account which is redeeming the tokens /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero) /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero) function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {     require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");      RedeemLocalVars memory vars;      /* exchangeRate = invoke Exchange Rate Stored() */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /* If redeemTokensIn &gt; 0: */     if (redeemTokensIn &gt; 0) {         /*          * We calculate the exchange rate and the amount of underlying to be redeemed:          *  redeemTokens = redeemTokensIn          *  redeemAmount = redeemTokensIn x exchangeRateCurrent          */         vars.redeemTokens = redeemTokensIn;          (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');     } else {         /*          * We get the current exchange rate and calculate the amount to be redeemed:          *  redeemTokens = redeemAmountIn / exchangeRate          *  redeemAmount = redeemAmountIn          */          (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');         vars.redeemAmount = redeemAmountIn;     }      /* Fail if redeem not allowed */     (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);      /*      * We calculate the new total supply and redeemer balance, checking for underflow:      *  totalSupplyNew = totalSupply - redeemTokens      *  accountTokensNew = accountTokens[redeemer] - redeemTokens      */     (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');      (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');     require(getCashPrior() &gt;= vars.redeemAmount, 'cash &lt; redeem');      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[redeemer] = vars.accountTokensNew;     /*      * We invoke doTransferOut for the redeemer and the redeemAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken has redeemAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(redeemer, vars.redeemAmount, true);       /* We emit a Transfer event, and a Redeem event */     emit Transfer(redeemer, address(this), vars.redeemTokens);     emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);      /* We call the defense hook */ }  struct BorrowLocalVars {     MathError mathErr;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /// @notice Users borrow assets from the protocol to their own address /// @param borrowAmount The amount of the underlying asset to borrow function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {     /* Fail if borrow not allowed */     (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);      /* Fail gracefully if protocol has insufficient underlying cash */     require(getCashPrior() &gt;= borrowAmount, 'cash&lt;borrow');      BorrowLocalVars memory vars;      /*      * We calculate the new borrower and total borrow balances, failing on overflow:      *  accountBorrowsNew = accountBorrows + borrowAmount      *  totalBorrowsNew = totalBorrows + borrowAmount      */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /*      * We invoke doTransferOut for the borrower and the borrowAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken borrowAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(payee, borrowAmount, false);      /* We emit a Borrow event */     emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */ }  struct RepayBorrowLocalVars {     MathError mathErr;     uint repayAmount;     uint borrowerIndex;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew;     uint actualRepayAmount;     uint badDebtsAmount; }  /// @notice Borrows are repaid by another user (possibly the borrower). /// @param payer the account paying off the borrow /// @param borrower the account with the debt being payed off /// @param repayAmount the amount of undelrying tokens being returned function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {     /* Fail if repayBorrow not allowed */     (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);      RepayBorrowLocalVars memory vars;      /* We remember the original borrowerIndex for verification purposes */     vars.borrowerIndex = accountBorrows[borrower].interestIndex;      /* We fetch the amount the borrower owes, with accumulated interest */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');      /* If repayAmount == -1, repayAmount = accountBorrows */     if (repayAmount == uint(- 1)) {         vars.repayAmount = vars.accountBorrows;     } else {         vars.repayAmount = repayAmount;     }     vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);       if (isEnd &amp;&amp; vars.accountBorrows &gt; vars.actualRepayAmount) {         vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;     }      /*     *  We calculate the new borrower and total borrow balances, failing on underflow:     *  accountBorrowsNew = accountBorrows - repayAmount     *  totalBorrowsNew = totalBorrows - repayAmount     */     if (vars.accountBorrows &lt; vars.actualRepayAmount) {         require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) &lt;= 105e16, 'repay more than 5%');         vars.accountBorrowsNew = 0;     } else {         if (isEnd) {             vars.accountBorrowsNew = 0;         } else {             vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;         }     }     //Avoid mantissa errors     if (vars.actualRepayAmount &gt; totalBorrows) {         vars.totalBorrowsNew = 0;     } else {         if (isEnd) {             vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);         } else {             vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;         }     }      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a RepayBorrow event */     emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */      return vars.actualRepayAmount; }  /*** Admin Functions ***/  /// @notice Sets a new CONTROLLER for the market /// @dev Admin function to set a new controller function setController(address newController) external override onlyAdmin {     require(address(0) != newController, "0x");     address oldController = controller;     controller = newController;     // Emit NewController(oldController, newController)     emit NewController(oldController, newController); }  function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {     require(newBorrowCapFactorMantissa &lt;= 1e18, 'Factor too large');     uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;     borrowCapFactorMantissa = newBorrowCapFactorMantissa;     emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa); }  function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {     //accrueInterest except first     if (baseRatePerBlock != 0) {         accrueInterest();     }     // total rate perYear &lt; 2000%     require(baseRatePerBlock_ &lt; 1e13, 'Base rate too large');     baseRatePerBlock = baseRatePerBlock_;     require(multiplierPerBlock_ &lt; 1e13, 'Mul rate too large');     multiplierPerBlock = multiplierPerBlock_;     require(jumpMultiplierPerBlock_ &lt; 1e13, 'Jump rate too large');     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     require(kink_ &lt;= 1e18, 'Kline too large');     kink = kink_;     emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_); }  function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {     require(newReserveFactorMantissa &lt;= 1e18, 'Factor too large');     accrueInterest();     uint oldReserveFactorMantissa = reserveFactorMantissa;     reserveFactorMantissa = newReserveFactorMantissa;     emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa); }  function addReserves(uint addAmount) external override nonReentrant {     accrueInterest();     uint totalReservesNew;     uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);     totalReservesNew = totalReserves.add(actualAddAmount);     totalReserves = totalReservesNew;     emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew); }  function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {     accrueInterest();     uint totalReservesNew;     totalReservesNew = totalReserves.sub(reduceAmount);     totalReserves = totalReservesNew;     doTransferOut(to, reduceAmount, true);     emit ReservesReduced(to, reduceAmount, totalReservesNew); }  modifier sameBlock() {     require(accrualBlockNumber == getBlockNumber(), 'not same block');     _; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-24-08 19:28:04 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;


import "./LPoolInterface.sol";
import "./LPoolDepositor.sol";
import "../lib/Exponential.sol";
import "../Adminable.sol";
import "../lib/CarefulMath.sol";
import "../lib/TransferHelper.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import "../DelegateInterface.sol";
import "../ControllerInterface.sol";
import "../IWETH.sol";

/// @title OpenLeverage's LToken Contract
/// @dev Abstract base for LTokens
/// @author OpenLeverage
contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {
    using TransferHelper for IERC20;
    using SafeMath for uint;

    constructor() {

    }
    
    /// @notice Initialize the money market
    /// @param controller_ The address of the Controller
    /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0
    /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate
    /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point
    /// @param kink_ The utilization point at which the jump multiplier is applied
    /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
    /// @param name_ EIP-20 name of this token
    /// @param symbol_ EIP-20 symbol of this token
    /// @param decimals_ EIP-20 decimal precision of this token
    function initialize(
        address underlying_,
        bool isWethPool_,
        address controller_,
        uint256 baseRatePerBlock_,
        uint256 multiplierPerBlock_,
        uint256 jumpMultiplierPerBlock_,
        uint256 kink_,
        uint initialExchangeRateMantissa_,
        string memory name_,
        string memory symbol_,
        uint8 decimals_) public {
        require(underlying_ != address(0), "underlying_ address cannot be 0");
        require(controller_ != address(0), "controller_ address cannot be 0");
        require(msg.sender == admin, "Only allow to be called by admin");
        require(accrualBlockNumber == 0 && borrowIndex == 0, "inited once");

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial Exchange Rate Mantissa should be greater zero");
        //set controller
        controller = controller_;
        isWethPool = isWethPool_;
        //set interestRateModel
        baseRatePerBlock = baseRatePerBlock_;
        multiplierPerBlock = multiplierPerBlock_;
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        kink = kink_;

        // Initialize block number and borrow index (block number mocks depend on controller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = 1e25;
        //80%
        borrowCapFactorMantissa = 0.8e18;
        //10%
        reserveFactorMantissa = 0.1e18;


        name = name_;
        symbol = symbol_;
        decimals = decimals_;

        _notEntered = true;

        // Set underlying and sanity check it
        underlying = underlying_;
        IERC20(underlying).totalSupply();
        emit Transfer(address(0), msg.sender, 0);
    }

    /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
    /// @dev Called by both `transfer` and `transferFrom` internally
    /// @param spender The address of the account performing the transfer
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param tokens The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {
        require(dst != address(0), "dst address cannot be 0");
        /* Do not allow self-transfers */
        require(src != dst, "src = dst");
        /* Fail if transfer not allowed */
        (ControllerInterface(controller)).transferAllowed(src, dst, tokens);

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(- 1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        require(mathErr == MathError.NO_ERROR, 'not allowed');

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        require(mathErr == MathError.NO_ERROR, 'not enough');

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        require(mathErr == MathError.NO_ERROR, 'too much');

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(- 1)) {
            transferAllowances[src][spender] = allowanceNew;
        }
        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);
        return true;
    }

    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount);
    }

    /// @notice Transfer `amount` tokens from `src` to `dst`
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount);
    }

    /// @notice Approve `spender` to transfer up to `amount` from `src`
    /// @dev This will overwrite the approval amount for `spender`
    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
    /// @param spender The address of the account which may transfer tokens
    /// @param amount The number of tokens that are approved (-1 means infinite)
    /// @return Whether or not the approval succeeded
    function approve(address spender, uint256 amount) external override returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /// @notice Get the current allowance from `owner` for `spender`
    /// @param owner The address of the account which owns the tokens to be spent
    /// @param spender The address of the account which may transfer tokens
    /// @return The number of tokens allowed to be spent (-1 means infinite)
    function allowance(address owner, address spender) external override view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /// @notice Get the token balance of the `owner`
    /// @param owner The address of the account to query
    /// @return The number of tokens owned by `owner`
    function balanceOf(address owner) external override view returns (uint256) {
        return accountTokens[owner];
    }

    /// @notice Get the underlying balance of the `owner`
    /// @dev This also accrues interest in a transaction
    /// @param owner The address of the account to query
    /// @return The amount of underlying owned by `owner`
    function balanceOfUnderlying(address owner) external override returns (uint) {
        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR, "calc failed");
        return balance;
    }

    /*** User Interface ***/

    /// @notice Sender supplies assets into the market and receives lTokens in exchange
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param mintAmount The amount of the underlying asset to supply
    function mint(uint mintAmount) external override nonReentrant {
        accrueInterest();
        mintFresh(msg.sender, mintAmount, false);
    }

    function mintTo(address to, uint amount) external payable override nonReentrant {
        accrueInterest();
        if (isWethPool) {
            mintFresh(to, msg.value, false);
        } else {
            mintFresh(to, amount, true);
        }
    }

    function mintEth() external payable override nonReentrant {
        require(isWethPool, "not eth pool");
        accrueInterest();
        mintFresh(msg.sender, msg.value, false);
    }

    /// @notice Sender redeems lTokens in exchange for the underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemTokens The number of lTokens to redeem into underlying
    function redeem(uint redeemTokens) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, redeemTokens, 0);
    }

    /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemAmount The amount of underlying to redeem
    function redeemUnderlying(uint redeemAmount) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, 0, redeemAmount);
    }

    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {
        accrueInterest();
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        borrowFresh(payable(borrower), msg.sender, borrowAmount);
    }

    /// @notice Sender repays a borrow belonging to borrower
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount The amount to repay
    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        repayBorrowFresh(msg.sender, borrower, repayAmount, false);
    }

    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        repayBorrowFresh(msg.sender, borrower, repayAmount, true);
    }


    /*** Safe Token ***/

    /// Gets balance of this contract in terms of the underlying
    /// @dev This excludes the value of the current message, if any
    /// @return The quantity of underlying tokens owned by this contract
    function getCashPrior() internal view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }


    /**
     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.
     *      This will revert due to insufficient balance or insufficient allowance.
     *      This function returns the actual amount received,
     *      which may be less than `amount` if there is a fee attached to the transfer.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {
        if (isWethPool && convertWeth) {
            actualAmount = msg.value;
            IWETH(underlying).deposit{value : actualAmount}();
        } else {
            actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);
        }
    }

    /**
     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory
     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to
     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified
     *      it is >= amount, this should not revert in normal conditions.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {
        if (isWethPool && convertWeth) {
            IWETH(underlying).withdraw(amount);
            to.transfer(amount);
        } else {
            IERC20(underlying).safeTransfer(to, amount);
        }
    }

    function availableForBorrow() external view override returns (uint){
        uint cash = getCashPrior();
        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);
        if (err0 != MathError.NO_ERROR) {
            return 0;
        }
        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);
        if (err1 != MathError.NO_ERROR) {
            return 0;
        }
        if (totalBorrows > maxAvailable) {
            return 0;
        }
        return maxAvailable - totalBorrows;
    }


    /// @notice Get a snapshot of the account's balances, and the cached exchange rate
    /// @dev This is used by controller to more efficiently perform liquidity checks.
    /// @param account Address of the account to snapshot
    /// @return ( token balance, borrow balance, exchange rate mantissa)
    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        return (cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /// @dev Function to simply retrieve block number
    ///  This exists mainly for inheriting test contracts to stub this result.
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /// @notice Returns the current per-block borrow interest rate for this cToken
    /// @return The borrow interest rate per block, scaled by 1e18
    function borrowRatePerBlock() external override view returns (uint) {
        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
    }

    
    /// @notice Returns the current per-block supply interest rate for this cToken
    /// @return The supply interest rate per block, scaled by 1e18
    function supplyRatePerBlock() external override view returns (uint) {
        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);
    }

    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {
        // Utilization rate is 0 when there are no borrows
        if (borrows == 0) {
            return 0;
        }
        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));
    }

    /// @notice Calculates the current borrow rate per block, with the error code expected by the market
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18)
    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {
        uint util = utilizationRate(cash, borrows, reserves);
        if (util <= kink) {
            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
        } else {
            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
            uint excessUtil = util.sub(kink);
            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);
        }
    }

    /// @notice Calculates the current supply rate per block
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The supply rate percentage per block as a mantissa (scaled by 1e18)
    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {
        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);
        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);
        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);
        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);
    }

    /// @notice Returns the current total borrows plus accrued interest
    /// @return The total borrows with interest
    function totalBorrowsCurrent() external override view returns (uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return totalBorrows;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        return totalBorrowsNew;
    }

    /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
    /// @param account The address whose balance should be calculated after updating borrowIndex
    /// @return The calculated balance
    function borrowBalanceCurrent(address account) external view override returns (uint) {
        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();
        require(err0 == MathError.NO_ERROR, "calc borrow index fail");
        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
        require(err1 == MathError.NO_ERROR, "calc fail");
        return result;
    }

    function borrowBalanceStored(address account) external override view returns (uint){
        return accountBorrows[account].principal;
    }


    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
    }

    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /// @notice Accrue interest then return the up-to-date exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateCurrent() public override nonReentrant returns (uint) {
        accrueInterest();
        return exchangeRateStored();
    }

    /// Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateStored() public override view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "calc fail");
        return result;
    }

    /// @notice Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return (error code, calculated exchange rate scaled by 1e18)
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        uint _totalSupply = totalSupply;
        if (_totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint _totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /// @notice Get cash balance of this cToken in the underlying asset
    /// @return The quantity of underlying asset owned by this contract
    function getCash() external override view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }

    function calCurrentBorrowIndex() internal view returns (MathError, uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;
        uint borrowIndexNew;
        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return (MathError.NO_ERROR, borrowIndex);
        }
        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);

        Exp memory simpleInterestFactor;
        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }
        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);
        return (mathErr, borrowIndexNew);
    }

    /// @notice Applies accrued interest to total borrows and reserves
    /// @dev This calculates interest accrued from the last checkpointed block
    ///   up to the current block and writes new checkpoint to storage.
    function accrueInterest() public override {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint borrowIndexPrior = borrowIndex;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");


        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;
        uint borrowIndexNew;
        uint totalReservesNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total reserves error');

        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);
        require(mathErr == MathError.NO_ERROR, 'calc borrows index error');


        /* We write the previously calculated values into storage */
        accrualBlockNumber = currentBlockNumber;
        borrowIndex = borrowIndexNew;
        totalBorrows = totalBorrowsNew;
        totalReserves = totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);

    }

    struct MintLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
        uint actualMintAmount;
    }

    /// @notice User supplies assets into the market and receives lTokens in exchange
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param minter The address of the account which is supplying the assets
    /// @param mintAmount The amount of the underlying asset to supply
    /// @return uint the actual mint amount.
    function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {
        MintLocalVars memory vars;
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /*
         *  We call `doTransferIn` for the minter and the mintAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if
         *  side-effects occurred. The function returns the amount actually transferred,
         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`
         *  of cash.
         */
        if (isDelegete) {
            uint balanceBefore = getCashPrior();
            LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);
            uint balanceAfter = getCashPrior();
            require(balanceAfter > balanceBefore, 'mint 0');
            vars.actualMintAmount = balanceAfter - balanceBefore;
        } else {
            vars.actualMintAmount = doTransferIn(minter, mintAmount, true);
        }
        /*
         * We get the current exchange rate and calculate the number of lTokens to be minted:
         *  mintTokens = actualMintAmount / exchangeRate
         */

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));
        require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");

        /* Fail if mint not allowed */
        (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);
        /*
         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */

        return vars.actualMintAmount;
    }


    struct RedeemLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /// @notice User redeems lTokens in exchange for the underlying asset
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param redeemer The address of the account which is redeeming the tokens
    /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');
            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');
        require(getCashPrior() >= vars.redeemAmount, 'cash < redeem');

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;
        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(redeemer, vars.redeemAmount, true);


        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
    }

    struct BorrowLocalVars {
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /// @notice Users borrow assets from the protocol to their own address
    /// @param borrowAmount The amount of the underlying asset to borrow
    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {
        /* Fail if borrow not allowed */
        (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);

        /* Fail gracefully if protocol has insufficient underlying cash */
        require(getCashPrior() >= borrowAmount, 'cash<borrow');

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(payee, borrowAmount, false);

        /* We emit a Borrow event */
        emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
    }

    struct RepayBorrowLocalVars {
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
        uint actualRepayAmount;
        uint badDebtsAmount;
    }

    /// @notice Borrows are repaid by another user (possibly the borrower).
    /// @param payer the account paying off the borrow
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount the amount of undelrying tokens being returned
    function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {
        /* Fail if repayBorrow not allowed */
        (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(- 1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }
        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);


        if (isEnd && vars.accountBorrows > vars.actualRepayAmount) {
            vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;
        }

        /*
        *  We calculate the new borrower and total borrow balances, failing on underflow:
        *  accountBorrowsNew = accountBorrows - repayAmount
        *  totalBorrowsNew = totalBorrows - repayAmount
        */
        if (vars.accountBorrows < vars.actualRepayAmount) {
            require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) <= 105e16, 'repay more than 5%');
            vars.accountBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.accountBorrowsNew = 0;
            } else {
                vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;
            }
        }
        //Avoid mantissa errors
        if (vars.actualRepayAmount > totalBorrows) {
            vars.totalBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);
            } else {
                vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;
            }
        }

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */

        return vars.actualRepayAmount;
    }

    /*** Admin Functions ***/

    /// @notice Sets a new CONTROLLER for the market
    /// @dev Admin function to set a new controller
    function setController(address newController) external override onlyAdmin {
        require(address(0) != newController, "0x");
        address oldController = controller;
        controller = newController;
        // Emit NewController(oldController, newController)
        emit NewController(oldController, newController);
    }

    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {
        require(newBorrowCapFactorMantissa <= 1e18, 'Factor too large');
        uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;
        borrowCapFactorMantissa = newBorrowCapFactorMantissa;
        emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa);
    }

    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {
        //accrueInterest except first
        if (baseRatePerBlock != 0) {
            accrueInterest();
        }
        // total rate perYear < 2000%
        require(baseRatePerBlock_ < 1e13, 'Base rate too large');
        baseRatePerBlock = baseRatePerBlock_;
        require(multiplierPerBlock_ < 1e13, 'Mul rate too large');
        multiplierPerBlock = multiplierPerBlock_;
        require(jumpMultiplierPerBlock_ < 1e13, 'Jump rate too large');
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        require(kink_ <= 1e18, 'Kline too large');
        kink = kink_;
        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);
    }

    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {
        require(newReserveFactorMantissa <= 1e18, 'Factor too large');
        accrueInterest();
        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;
        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);
    }

    function addReserves(uint addAmount) external override nonReentrant {
        accrueInterest();
        uint totalReservesNew;
        uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);
        totalReservesNew = totalReserves.add(actualAddAmount);
        totalReserves = totalReservesNew;
        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);
    }

    function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {
        accrueInterest();
        uint totalReservesNew;
        totalReservesNew = totalReserves.sub(reduceAmount);
        totalReserves = totalReservesNew;
        doTransferOut(to, reduceAmount, true);
        emit ReservesReduced(to, reduceAmount, totalReservesNew);
    }

    modifier sameBlock() {
        require(accrualBlockNumber == getBlockNumber(), 'not same block');
        _;
    }
}

.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-24-08 19:28:15 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-24-08 19:28:15 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 10001
completion_tokens: 766
total_tokens: 10767
cost: $-1.000000


[2024-24-08 19:28:15 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;


import "./LPoolInterface.sol";
import "./LPoolDepositor.sol";
import "../lib/Exponential.sol";
import "../Adminable.sol";
import "../lib/CarefulMath.sol";
import "../lib/TransferHelper.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import "../DelegateInterface.sol";
import "../ControllerInterface.sol";
import "../IWETH.sol";

/// @title OpenLeverage's LToken Contract
/// @dev Abstract base for LTokens
/// @author OpenLeverage
contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {
    using TransferHelper for IERC20;
    using SafeMath for uint;

    constructor() {

    }
    
    /// @notice Initialize the money market
    /// @param controller_ The address of the Controller
    /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0
    /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate
    /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point
    /// @param kink_ The utilization point at which the jump multiplier is applied
    /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
    /// @param name_ EIP-20 name of this token
    /// @param symbol_ EIP-20 symbol of this token
    /// @param decimals_ EIP-20 decimal precision of this token
    function initialize(
        address underlying_,
        bool isWethPool_,
        address controller_,
        uint256 baseRatePerBlock_,
        uint256 multiplierPerBlock_,
        uint256 jumpMultiplierPerBlock_,
        uint256 kink_,
        uint initialExchangeRateMantissa_,
        string memory name_,
        string memory symbol_,
        uint8 decimals_) public {
        require(underlying_ != address(0), "underlying_ address cannot be 0");
        require(controller_ != address(0), "controller_ address cannot be 0");
        require(msg.sender == admin, "Only allow to be called by admin");
        require(accrualBlockNumber == 0 && borrowIndex == 0, "inited once");

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial Exchange Rate Mantissa should be greater zero");
        //set controller
        controller = controller_;
        isWethPool = isWethPool_;
        //set interestRateModel
        baseRatePerBlock = baseRatePerBlock_;
        multiplierPerBlock = multiplierPerBlock_;
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        kink = kink_;

        // Initialize block number and borrow index (block number mocks depend on controller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = 1e25;
        //80%
        borrowCapFactorMantissa = 0.8e18;
        //10%
        reserveFactorMantissa = 0.1e18;


        name = name_;
        symbol = symbol_;
        decimals = decimals_;

        _notEntered = true;

        // Set underlying and sanity check it
        underlying = underlying_;
        IERC20(underlying).totalSupply();
        emit Transfer(address(0), msg.sender, 0);
    }

    /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
    /// @dev Called by both `transfer` and `transferFrom` internally
    /// @param spender The address of the account performing the transfer
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param tokens The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {
        require(dst != address(0), "dst address cannot be 0");
        /* Do not allow self-transfers */
        require(src != dst, "src = dst");
        /* Fail if transfer not allowed */
        (ControllerInterface(controller)).transferAllowed(src, dst, tokens);

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(- 1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        require(mathErr == MathError.NO_ERROR, 'not allowed');

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        require(mathErr == MathError.NO_ERROR, 'not enough');

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        require(mathErr == MathError.NO_ERROR, 'too much');

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(- 1)) {
            transferAllowances[src][spender] = allowanceNew;
        }
        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);
        return true;
    }

    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount);
    }

    /// @notice Transfer `amount` tokens from `src` to `dst`
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount);
    }

    /// @notice Approve `spender` to transfer up to `amount` from `src`
    /// @dev This will overwrite the approval amount for `spender`
    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
    /// @param spender The address of the account which may transfer tokens
    /// @param amount The number of tokens that are approved (-1 means infinite)
    /// @return Whether or not the approval succeeded
    function approve(address spender, uint256 amount) external override returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /// @notice Get the current allowance from `owner` for `spender`
    /// @param owner The address of the account which owns the tokens to be spent
    /// @param spender The address of the account which may transfer tokens
    /// @return The number of tokens allowed to be spent (-1 means infinite)
    function allowance(address owner, address spender) external override view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /// @notice Get the token balance of the `owner`
    /// @param owner The address of the account to query
    /// @return The number of tokens owned by `owner`
    function balanceOf(address owner) external override view returns (uint256) {
        return accountTokens[owner];
    }

    /// @notice Get the underlying balance of the `owner`
    /// @dev This also accrues interest in a transaction
    /// @param owner The address of the account to query
    /// @return The amount of underlying owned by `owner`
    function balanceOfUnderlying(address owner) external override returns (uint) {
        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR, "calc failed");
        return balance;
    }

    /*** User Interface ***/

    /// @notice Sender supplies assets into the market and receives lTokens in exchange
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param mintAmount The amount of the underlying asset to supply
    function mint(uint mintAmount) external override nonReentrant {
        accrueInterest();
        mintFresh(msg.sender, mintAmount, false);
    }

    function mintTo(address to, uint amount) external payable override nonReentrant {
        accrueInterest();
        if (isWethPool) {
            mintFresh(to, msg.value, false);
        } else {
            mintFresh(to, amount, true);
        }
    }

    function mintEth() external payable override nonReentrant {
        require(isWethPool, "not eth pool");
        accrueInterest();
        mintFresh(msg.sender, msg.value, false);
    }

    /// @notice Sender redeems lTokens in exchange for the underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemTokens The number of lTokens to redeem into underlying
    function redeem(uint redeemTokens) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, redeemTokens, 0);
    }

    /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemAmount The amount of underlying to redeem
    function redeemUnderlying(uint redeemAmount) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, 0, redeemAmount);
    }

    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {
        accrueInterest();
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        borrowFresh(payable(borrower), msg.sender, borrowAmount);
    }

    /// @notice Sender repays a borrow belonging to borrower
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount The amount to repay
    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        repayBorrowFresh(msg.sender, borrower, repayAmount, false);
    }

    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        repayBorrowFresh(msg.sender, borrower, repayAmount, true);
    }


    /*** Safe Token ***/

    /// Gets balance of this contract in terms of the underlying
    /// @dev This excludes the value of the current message, if any
    /// @return The quantity of underlying tokens owned by this contract
    function getCashPrior() internal view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }


    /**
     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.
     *      This will revert due to insufficient balance or insufficient allowance.
     *      This function returns the actual amount received,
     *      which may be less than `amount` if there is a fee attached to the transfer.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {
        if (isWethPool && convertWeth) {
            actualAmount = msg.value;
            IWETH(underlying).deposit{value : actualAmount}();
        } else {
            actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);
        }
    }

    /**
     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory
     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to
     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified
     *      it is >= amount, this should not revert in normal conditions.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {
        if (isWethPool && convertWeth) {
            IWETH(underlying).withdraw(amount);
            to.transfer(amount);
        } else {
            IERC20(underlying).safeTransfer(to, amount);
        }
    }

    function availableForBorrow() external view override returns (uint){
        uint cash = getCashPrior();
        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);
        if (err0 != MathError.NO_ERROR) {
            return 0;
        }
        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);
        if (err1 != MathError.NO_ERROR) {
            return 0;
        }
        if (totalBorrows > maxAvailable) {
            return 0;
        }
        return maxAvailable - totalBorrows;
    }


    /// @notice Get a snapshot of the account's balances, and the cached exchange rate
    /// @dev This is used by controller to more efficiently perform liquidity checks.
    /// @param account Address of the account to snapshot
    /// @return ( token balance, borrow balance, exchange rate mantissa)
    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        return (cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /// @dev Function to simply retrieve block number
    ///  This exists mainly for inheriting test contracts to stub this result.
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /// @notice Returns the current per-block borrow interest rate for this cToken
    /// @return The borrow interest rate per block, scaled by 1e18
    function borrowRatePerBlock() external override view returns (uint) {
        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
    }

    
    /// @notice Returns the current per-block supply interest rate for this cToken
    /// @return The supply interest rate per block, scaled by 1e18
    function supplyRatePerBlock() external override view returns (uint) {
        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);
    }

    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {
        // Utilization rate is 0 when there are no borrows
        if (borrows == 0) {
            return 0;
        }
        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));
    }

    /// @notice Calculates the current borrow rate per block, with the error code expected by the market
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18)
    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {
        uint util = utilizationRate(cash, borrows, reserves);
        if (util <= kink) {
            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
        } else {
            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
            uint excessUtil = util.sub(kink);
            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);
        }
    }

    /// @notice Calculates the current supply rate per block
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The supply rate percentage per block as a mantissa (scaled by 1e18)
    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {
        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);
        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);
        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);
        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);
    }

    /// @notice Returns the current total borrows plus accrued interest
    /// @return The total borrows with interest
    function totalBorrowsCurrent() external override view returns (uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return totalBorrows;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        return totalBorrowsNew;
    }

    /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
    /// @param account The address whose balance should be calculated after updating borrowIndex
    /// @return The calculated balance
    function borrowBalanceCurrent(address account) external view override returns (uint) {
        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();
        require(err0 == MathError.NO_ERROR, "calc borrow index fail");
        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
        require(err1 == MathError.NO_ERROR, "calc fail");
        return result;
    }

    function borrowBalanceStored(address account) external override view returns (uint){
        return accountBorrows[account].principal;
    }


    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
    }

    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /// @notice Accrue interest then return the up-to-date exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateCurrent() public override nonReentrant returns (uint) {
        accrueInterest();
        return exchangeRateStored();
    }

    /// Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateStored() public override view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "calc fail");
        return result;
    }

    /// @notice Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return (error code, calculated exchange rate scaled by 1e18)
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        uint _totalSupply = totalSupply;
        if (_totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint _totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /// @notice Get cash balance of this cToken in the underlying asset
    /// @return The quantity of underlying asset owned by this contract
    function getCash() external override view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }

    function calCurrentBorrowIndex() internal view returns (MathError, uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;
        uint borrowIndexNew;
        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return (MathError.NO_ERROR, borrowIndex);
        }
        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);

        Exp memory simpleInterestFactor;
        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }
        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);
        return (mathErr, borrowIndexNew);
    }

    /// @notice Applies accrued interest to total borrows and reserves
    /// @dev This calculates interest accrued from the last checkpointed block
    ///   up to the current block and writes new checkpoint to storage.
    function accrueInterest() public override {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint borrowIndexPrior = borrowIndex;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");


        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;
        uint borrowIndexNew;
        uint totalReservesNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total reserves error');

        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);
        require(mathErr == MathError.NO_ERROR, 'calc borrows index error');


        /* We write the previously calculated values into storage */
        accrualBlockNumber = currentBlockNumber;
        borrowIndex = borrowIndexNew;
        totalBorrows = totalBorrowsNew;
        totalReserves = totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);

    }

    struct MintLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
        uint actualMintAmount;
    }

    /// @notice User supplies assets into the market and receives lTokens in exchange
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param minter The address of the account which is supplying the assets
    /// @param mintAmount The amount of the underlying asset to supply
    /// @return uint the actual mint amount.
    function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {
        MintLocalVars memory vars;
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /*
         *  We call `doTransferIn` for the minter and the mintAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if
         *  side-effects occurred. The function returns the amount actually transferred,
         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`
         *  of cash.
         */
        if (isDelegete) {
            uint balanceBefore = getCashPrior();
            LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);
            uint balanceAfter = getCashPrior();
            require(balanceAfter > balanceBefore, 'mint 0');
            vars.actualMintAmount = balanceAfter - balanceBefore;
        } else {
            vars.actualMintAmount = doTransferIn(minter, mintAmount, true);
        }
        /*
         * We get the current exchange rate and calculate the number of lTokens to be minted:
         *  mintTokens = actualMintAmount / exchangeRate
         */

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));
        require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");

        /* Fail if mint not allowed */
        (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);
        /*
         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */

        return vars.actualMintAmount;
    }


    struct RedeemLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /// @notice User redeems lTokens in exchange for the underlying asset
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param redeemer The address of the account which is redeeming the tokens
    /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');
            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');
        require(getCashPrior() >= vars.redeemAmount, 'cash < redeem');

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;
        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(redeemer, vars.redeemAmount, true);


        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
    }

    struct BorrowLocalVars {
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /// @notice Users borrow assets from the protocol to their own address
    /// @param borrowAmount The amount of the underlying asset to borrow
    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {
        /* Fail if borrow not allowed */
        (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);

        /* Fail gracefully if protocol has insufficient underlying cash */
        require(getCashPrior() >= borrowAmount, 'cash<borrow');

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(payee, borrowAmount, false);

        /* We emit a Borrow event */
        emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
    }

    struct RepayBorrowLocalVars {
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
        uint actualRepayAmount;
        uint badDebtsAmount;
    }

    /// @notice Borrows are repaid by another user (possibly the borrower).
    /// @param payer the account paying off the borrow
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount the amount of undelrying tokens being returned
    function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {
        /* Fail if repayBorrow not allowed */
        (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(- 1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }
        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);


        if (isEnd && vars.accountBorrows > vars.actualRepayAmount) {
            vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;
        }

        /*
        *  We calculate the new borrower and total borrow balances, failing on underflow:
        *  accountBorrowsNew = accountBorrows - repayAmount
        *  totalBorrowsNew = totalBorrows - repayAmount
        */
        if (vars.accountBorrows < vars.actualRepayAmount) {
            require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) <= 105e16, 'repay more than 5%');
            vars.accountBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.accountBorrowsNew = 0;
            } else {
                vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;
            }
        }
        //Avoid mantissa errors
        if (vars.actualRepayAmount > totalBorrows) {
            vars.totalBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);
            } else {
                vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;
            }
        }

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */

        return vars.actualRepayAmount;
    }

    /*** Admin Functions ***/

    /// @notice Sets a new CONTROLLER for the market
    /// @dev Admin function to set a new controller
    function setController(address newController) external override onlyAdmin {
        require(address(0) != newController, "0x");
        address oldController = controller;
        controller = newController;
        // Emit NewController(oldController, newController)
        emit NewController(oldController, newController);
    }

    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {
        require(newBorrowCapFactorMantissa <= 1e18, 'Factor too large');
        uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;
        borrowCapFactorMantissa = newBorrowCapFactorMantissa;
        emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa);
    }

    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {
        //accrueInterest except first
        if (baseRatePerBlock != 0) {
            accrueInterest();
        }
        // total rate perYear < 2000%
        require(baseRatePerBlock_ < 1e13, 'Base rate too large');
        baseRatePerBlock = baseRatePerBlock_;
        require(multiplierPerBlock_ < 1e13, 'Mul rate too large');
        multiplierPerBlock = multiplierPerBlock_;
        require(jumpMultiplierPerBlock_ < 1e13, 'Jump rate too large');
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        require(kink_ <= 1e18, 'Kline too large');
        kink = kink_;
        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);
    }

    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {
        require(newReserveFactorMantissa <= 1e18, 'Factor too large');
        accrueInterest();
        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;
        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);
    }

    function addReserves(uint addAmount) external override nonReentrant {
        accrueInterest();
        uint totalReservesNew;
        uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);
        totalReservesNew = totalReserves.add(actualAddAmount);
        totalReserves = totalReservesNew;
        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);
    }

    function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {
        accrueInterest();
        uint totalReservesNew;
        totalReservesNew = totalReserves.sub(reduceAmount);
        totalReserves = totalReservesNew;
        doTransferOut(to, reduceAmount, true);
        emit ReservesReduced(to, reduceAmount, totalReservesNew);
    }

    modifier sameBlock() {
        require(accrualBlockNumber == getBlockNumber(), 'not same block');
        _;
    }
}

.]

Based on the provided smart contract code for the `LPool` contract, here is a summary of the potential security vulnerabilities identified:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**:
   - Although the contract uses the `ReentrancyGuard` modifier, there are still functions that could potentially be exploited if not properly managed, especially in functions like `doTransferOut` and `doTransferIn` where external calls are made.

2. **Access Control Issues**:
   - The `initialize` function has a check for `msg.sender == admin`, but there is no mechanism to ensure that the `admin` variable is properly set and secured against unauthorized changes.
   - Functions that modify critical parameters (like `setController`, `setInterestParams`, etc.) are only restricted to the admin, which could be a single point of failure if the admin account is compromised.

3. **Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath`, there are still areas where calculations could potentially lead to overflow or underflow if not handled correctly, especially in arithmetic operations involving user inputs.

4. **Gas Limit and Loops**:
   - Functions that involve multiple state changes or iterations over arrays (if any were present) could run into gas limit issues, potentially leading to failed transactions.

5. **Improper Error Handling**:
   - The contract relies heavily on `require` statements for error handling, which may not provide sufficient context for debugging or user feedback in case of failures.

6. **Lack of Event Emission**:
   - Some state-changing functions do not emit events, which is crucial for tracking changes on-chain and for user interfaces to react to state changes.

7. **Potential for Front-Running**:
   - The contract does not implement any mechanisms to prevent front-running attacks, especially in functions that involve financial transactions like `mint`, `redeem`, and `borrow`.

8. **Unbounded External Calls**:
   - Functions that call external contracts (like `doTransferIn` and `doTransferOut`) could be susceptible to unexpected behavior if the external contracts are malicious or poorly designed.

### Comprehensive Analysis Report

The `LPool` contract is a complex financial instrument that facilitates lending and borrowing of assets. While it employs several best practices, such as using `SafeMath` and `ReentrancyGuard`, there are notable vulnerabilities that need to be addressed to ensure the security and reliability of the contract.

1. **Reentrancy Protection**: The use of the `ReentrancyGuard` is a positive step, but developers should ensure that all external calls are carefully managed to prevent reentrancy attacks.

2. **Access Control**: The reliance on a single admin account poses a risk. It is advisable to implement a multi-signature wallet or a decentralized governance mechanism to manage critical functions.

3. **Error Handling**: The contract should enhance its error handling mechanisms to provide more informative feedback during failures, which can aid in debugging and improve user experience.

4. **Event Emission**: All state-changing functions should emit relevant events to ensure transparency and allow for easier tracking of contract activity.

5. **Front-Running Mitigation**: Implementing measures to prevent front-running, such as commit-reveal schemes or time-locks, could enhance the security of financial transactions.

6. **Testing and Auditing**: Comprehensive testing, including unit tests and integration tests, should be conducted, along with a third-party audit to identify any additional vulnerabilities.

In conclusion, while the `LPool` contract has a solid foundation, addressing the identified vulnerabilities is crucial for ensuring the security and trustworthiness of the platform. Continuous monitoring and updates will be necessary to adapt to evolving security threats in the blockchain ecosystem.

[2024-24-08 19:28:15 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for the `LPool` contract, here is a summary of the potential security vulnerabilities identified:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**:
   - Although the contract uses the `ReentrancyGuard` modifier, there are still functions that could potentially be exploited if not properly managed, especially in functions like `doTransferOut` and `doTransferIn` where external calls are made.

2. **Access Control Issues**:
   - The `initialize` function has a check for `msg.sender == admin`, but there is no mechanism to ensure that the `admin` variable is properly set and secured against unauthorized changes.
   - Functions that modify critical parameters (like `setController`, `setInterestParams`, etc.) are only restricted to the admin, which could be a single point of failure if the admin account is compromised.

3. **Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath`, there are still areas where calculations could potentially lead to overflow or underflow if not handled correctly, especially in arithmetic operations involving user inputs.

4. **Gas Limit and Loops**:
   - Functions that involve multiple state changes or iterations over arrays (if any were present) could run into gas limit issues, potentially leading to failed transactions.

5. **Improper Error Handling**:
   - The contract relies heavily on `require` statements for error handling, which may not provide sufficient context for debugging or user feedback in case of failures.

6. **Lack of Event Emission**:
   - Some state-changing functions do not emit events, which is crucial for tracking changes on-chain and for user interfaces to react to state changes.

7. **Potential for Front-Running**:
   - The contract does not implement any mechanisms to prevent front-running attacks, especially in functions that involve financial transactions like `mint`, `redeem`, and `borrow`.

8. **Unbounded External Calls**:
   - Functions that call external contracts (like `doTransferIn` and `doTransferOut`) could be susceptible to unexpected behavior if the external contracts are malicious or poorly designed.

### Comprehensive Analysis Report

The `LPool` contract is a complex financial instrument that facilitates lending and borrowing of assets. While it employs several best practices, such as using `SafeMath` and `ReentrancyGuard`, there are notable vulnerabilities that need to be addressed to ensure the security and reliability of the contract.

1. **Reentrancy Protection**: The use of the `ReentrancyGuard` is a positive step, but developers should ensure that all external calls are carefully managed to prevent reentrancy attacks.

2. **Access Control**: The reliance on a single admin account poses a risk. It is advisable to implement a multi-signature wallet or a decentralized governance mechanism to manage critical functions.

3. **Error Handling**: The contract should enhance its error handling mechanisms to provide more informative feedback during failures, which can aid in debugging and improve user experience.

4. **Event Emission**: All state-changing functions should emit relevant events to ensure transparency and allow for easier tracking of contract activity.

5. **Front-Running Mitigation**: Implementing measures to prevent front-running, such as commit-reveal schemes or time-locks, could enhance the security of financial transactions.

6. **Testing and Auditing**: Comprehensive testing, including unit tests and integration tests, should be conducted, along with a third-party audit to identify any additional vulnerabilities.

In conclusion, while the `LPool` contract has a solid foundation, addressing the identified vulnerabilities is crucial for ensuring the security and trustworthiness of the platform. Continuous monitoring and updates will be necessary to adapt to evolving security threats in the blockchain ecosystem.

[2024-24-08 19:28:15 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-24-08 19:28:15 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.7.6; import "./LPoolInterface.sol"; import "./LPoolDepositor.sol"; import "../lib/Exponential.sol"; import "../Adminable.sol"; import "../lib/CarefulMath.sol"; import "../lib/TransferHelper.sol"; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import "../DelegateInterface.sol"; import "../ControllerInterface.sol"; import "../IWETH.sol"; /// @title OpenLeverage's LToken Contract /// @dev Abstract base for LTokens /// @author OpenLeverage contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {     using TransferHelper for IERC20;     using SafeMath for uint; constructor() {  }  /// @notice Initialize the money market /// @param controller_ The address of the Controller /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0 /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point /// @param kink_ The utilization point at which the jump multiplier is applied /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18 /// @param name_ EIP-20 name of this token /// @param symbol_ EIP-20 symbol of this token /// @param decimals_ EIP-20 decimal precision of this token function initialize(     address underlying_,     bool isWethPool_,     address controller_,     uint256 baseRatePerBlock_,     uint256 multiplierPerBlock_,     uint256 jumpMultiplierPerBlock_,     uint256 kink_,     uint initialExchangeRateMantissa_,     string memory name_,     string memory symbol_,     uint8 decimals_) public {     require(underlying_ != address(0), "underlying_ address cannot be 0");     require(controller_ != address(0), "controller_ address cannot be 0");     require(msg.sender == admin, "Only allow to be called by admin");     require(accrualBlockNumber == 0 &amp;&amp; borrowIndex == 0, "inited once");      // Set initial exchange rate     initialExchangeRateMantissa = initialExchangeRateMantissa_;     require(initialExchangeRateMantissa &gt; 0, "Initial Exchange Rate Mantissa should be greater zero");     //set controller     controller = controller_;     isWethPool = isWethPool_;     //set interestRateModel     baseRatePerBlock = baseRatePerBlock_;     multiplierPerBlock = multiplierPerBlock_;     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     kink = kink_;      // Initialize block number and borrow index (block number mocks depend on controller being set)     accrualBlockNumber = getBlockNumber();     borrowIndex = 1e25;     //80%     borrowCapFactorMantissa = 0.8e18;     //10%     reserveFactorMantissa = 0.1e18;       name = name_;     symbol = symbol_;     decimals = decimals_;      _notEntered = true;      // Set underlying and sanity check it     underlying = underlying_;     IERC20(underlying).totalSupply();     emit Transfer(address(0), msg.sender, 0); }  /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender` /// @dev Called by both `transfer` and `transferFrom` internally /// @param spender The address of the account performing the transfer /// @param src The address of the source account /// @param dst The address of the destination account /// @param tokens The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {     require(dst != address(0), "dst address cannot be 0");     /* Do not allow self-transfers */     require(src != dst, "src = dst");     /* Fail if transfer not allowed */     (ControllerInterface(controller)).transferAllowed(src, dst, tokens);      /* Get the allowance, infinite for the account owner */     uint startingAllowance = 0;     if (spender == src) {         startingAllowance = uint(- 1);     } else {         startingAllowance = transferAllowances[src][spender];     }      /* Do the calculations, checking for {under,over}flow */     MathError mathErr;     uint allowanceNew;     uint srcTokensNew;     uint dstTokensNew;      (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);     require(mathErr == MathError.NO_ERROR, 'not allowed');      (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);     require(mathErr == MathError.NO_ERROR, 'not enough');      (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);     require(mathErr == MathError.NO_ERROR, 'too much');      accountTokens[src] = srcTokensNew;     accountTokens[dst] = dstTokensNew;      /* Eat some of the allowance (if necessary) */     if (startingAllowance != uint(- 1)) {         transferAllowances[src][spender] = allowanceNew;     }     /* We emit a Transfer event */     emit Transfer(src, dst, tokens);     return true; }  /// @notice Transfer `amount` tokens from `msg.sender` to `dst` /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, msg.sender, dst, amount); }  /// @notice Transfer `amount` tokens from `src` to `dst` /// @param src The address of the source account /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, src, dst, amount); }  /// @notice Approve `spender` to transfer up to `amount` from `src` /// @dev This will overwrite the approval amount for `spender` ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve) /// @param spender The address of the account which may transfer tokens /// @param amount The number of tokens that are approved (-1 means infinite) /// @return Whether or not the approval succeeded function approve(address spender, uint256 amount) external override returns (bool) {     address src = msg.sender;     transferAllowances[src][spender] = amount;     emit Approval(src, spender, amount);     return true; }  /// @notice Get the current allowance from `owner` for `spender` /// @param owner The address of the account which owns the tokens to be spent /// @param spender The address of the account which may transfer tokens /// @return The number of tokens allowed to be spent (-1 means infinite) function allowance(address owner, address spender) external override view returns (uint256) {     return transferAllowances[owner][spender]; }  /// @notice Get the token balance of the `owner` /// @param owner The address of the account to query /// @return The number of tokens owned by `owner` function balanceOf(address owner) external override view returns (uint256) {     return accountTokens[owner]; }  /// @notice Get the underlying balance of the `owner` /// @dev This also accrues interest in a transaction /// @param owner The address of the account to query /// @return The amount of underlying owned by `owner` function balanceOfUnderlying(address owner) external override returns (uint) {     Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});     (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);     require(mErr == MathError.NO_ERROR, "calc failed");     return balance; }  /*** User Interface ***/  /// @notice Sender supplies assets into the market and receives lTokens in exchange /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param mintAmount The amount of the underlying asset to supply function mint(uint mintAmount) external override nonReentrant {     accrueInterest();     mintFresh(msg.sender, mintAmount, false); }  function mintTo(address to, uint amount) external payable override nonReentrant {     accrueInterest();     if (isWethPool) {         mintFresh(to, msg.value, false);     } else {         mintFresh(to, amount, true);     } }  function mintEth() external payable override nonReentrant {     require(isWethPool, "not eth pool");     accrueInterest();     mintFresh(msg.sender, msg.value, false); }  /// @notice Sender redeems lTokens in exchange for the underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemTokens The number of lTokens to redeem into underlying function redeem(uint redeemTokens) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, redeemTokens, 0); }  /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemAmount The amount of underlying to redeem function redeemUnderlying(uint redeemAmount) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, 0, redeemAmount); }  function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {     accrueInterest();     // borrowFresh emits borrow-specific logs on errors, so we don't need to     borrowFresh(payable(borrower), msg.sender, borrowAmount); }  /// @notice Sender repays a borrow belonging to borrower /// @param borrower the account with the debt being payed off /// @param repayAmount The amount to repay function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     repayBorrowFresh(msg.sender, borrower, repayAmount, false); }  function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     repayBorrowFresh(msg.sender, borrower, repayAmount, true); }   /*** Safe Token ***/  /// Gets balance of this contract in terms of the underlying /// @dev This excludes the value of the current message, if any /// @return The quantity of underlying tokens owned by this contract function getCashPrior() internal view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }   /**  * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.  *      This will revert due to insufficient balance or insufficient allowance.  *      This function returns the actual amount received,  *      which may be less than `amount` if there is a fee attached to the transfer.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {     if (isWethPool &amp;&amp; convertWeth) {         actualAmount = msg.value;         IWETH(underlying).deposit{value : actualAmount}();     } else {         actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);     } }  /**  * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory  *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to  *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified  *      it is &gt;= amount, this should not revert in normal conditions.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferOut(address payable to, uint amount, bool convertWeth) internal {     if (isWethPool &amp;&amp; convertWeth) {         IWETH(underlying).withdraw(amount);         to.transfer(amount);     } else {         IERC20(underlying).safeTransfer(to, amount);     } }  function availableForBorrow() external view override returns (uint){     uint cash = getCashPrior();     (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);     if (err0 != MathError.NO_ERROR) {         return 0;     }     (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);     if (err1 != MathError.NO_ERROR) {         return 0;     }     if (totalBorrows &gt; maxAvailable) {         return 0;     }     return maxAvailable - totalBorrows; }   /// @notice Get a snapshot of the account's balances, and the cached exchange rate /// @dev This is used by controller to more efficiently perform liquidity checks. /// @param account Address of the account to snapshot /// @return ( token balance, borrow balance, exchange rate mantissa) function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {     uint cTokenBalance = accountTokens[account];     uint borrowBalance;     uint exchangeRateMantissa;      MathError mErr;      (mErr, borrowBalance) = borrowBalanceStoredInternal(account);     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      return (cTokenBalance, borrowBalance, exchangeRateMantissa); }  /// @dev Function to simply retrieve block number ///  This exists mainly for inheriting test contracts to stub this result. function getBlockNumber() internal view returns (uint) {     return block.number; }  /// @notice Returns the current per-block borrow interest rate for this cToken /// @return The borrow interest rate per block, scaled by 1e18 function borrowRatePerBlock() external override view returns (uint) {     return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves); }   /// @notice Returns the current per-block supply interest rate for this cToken /// @return The supply interest rate per block, scaled by 1e18 function supplyRatePerBlock() external override view returns (uint) {     return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa); }  function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {     // Utilization rate is 0 when there are no borrows     if (borrows == 0) {         return 0;     }     return borrows.mul(1e18).div(cash.add(borrows).sub(reserves)); }  /// @notice Calculates the current borrow rate per block, with the error code expected by the market /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18) function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {     uint util = utilizationRate(cash, borrows, reserves);     if (util &lt;= kink) {         return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);     } else {         uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);         uint excessUtil = util.sub(kink);         return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);     } }  /// @notice Calculates the current supply rate per block /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The supply rate percentage per block as a mantissa (scaled by 1e18) function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {     uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);     uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);     uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);     return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18); }  /// @notice Returns the current total borrows plus accrued interest /// @return The total borrows with interest function totalBorrowsCurrent() external override view returns (uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return totalBorrows;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, "calc block delta erro");      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      return totalBorrowsNew; }  /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex /// @param account The address whose balance should be calculated after updating borrowIndex /// @return The calculated balance function borrowBalanceCurrent(address account) external view override returns (uint) {     (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();     require(err0 == MathError.NO_ERROR, "calc borrow index fail");     (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);     require(err1 == MathError.NO_ERROR, "calc fail");     return result; }  function borrowBalanceStored(address account) external override view returns (uint){     return accountBorrows[account].principal; }   /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {     return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex); }  /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {     /* Note: we do not assert that the market is up to date */     MathError mathErr;     uint principalTimesIndex;     uint result;      /* Get borrowBalance and borrowIndex */     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];      /* If borrowBalance = 0 then borrowIndex is likely also 0.      * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.      */     if (borrowSnapshot.principal == 0) {         return (MathError.NO_ERROR, 0);     }      /* Calculate new borrow balance using the interest index:      *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex      */     (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      return (MathError.NO_ERROR, result); }  /// @notice Accrue interest then return the up-to-date exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateCurrent() public override nonReentrant returns (uint) {     accrueInterest();     return exchangeRateStored(); }  /// Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateStored() public override view returns (uint) {     (MathError err, uint result) = exchangeRateStoredInternal();     require(err == MathError.NO_ERROR, "calc fail");     return result; }  /// @notice Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return (error code, calculated exchange rate scaled by 1e18) function exchangeRateStoredInternal() internal view returns (MathError, uint) {     uint _totalSupply = totalSupply;     if (_totalSupply == 0) {         /*          * If there are no tokens minted:          *  exchangeRate = initialExchangeRate          */         return (MathError.NO_ERROR, initialExchangeRateMantissa);     } else {         /*          * Otherwise:          *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply          */         uint _totalCash = getCashPrior();         uint cashPlusBorrowsMinusReserves;         Exp memory exchangeRate;         MathError mathErr;          (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          return (MathError.NO_ERROR, exchangeRate.mantissa);     } }  /// @notice Get cash balance of this cToken in the underlying asset /// @return The quantity of underlying asset owned by this contract function getCash() external override view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }  function calCurrentBorrowIndex() internal view returns (MathError, uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;     uint borrowIndexNew;     /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return (MathError.NO_ERROR, borrowIndex);     }     uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);      Exp memory simpleInterestFactor;     (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }     (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);     return (mathErr, borrowIndexNew); }  /// @notice Applies accrued interest to total borrows and reserves /// @dev This calculates interest accrued from the last checkpointed block ///   up to the current block and writes new checkpoint to storage. function accrueInterest() public override {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint borrowIndexPrior = borrowIndex;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, "calc block delta erro");       /*      * Calculate the interest accumulated into borrows and reserves and the new index:      *  simpleInterestFactor = borrowRate * blockDelta      *  interestAccumulated = simpleInterestFactor * totalBorrows      *  totalBorrowsNew = interestAccumulated + totalBorrows      *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex      */      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;     uint borrowIndexNew;     uint totalReservesNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);     require(mathErr == MathError.NO_ERROR, 'calc total reserves error');      (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);     require(mathErr == MathError.NO_ERROR, 'calc borrows index error');       /* We write the previously calculated values into storage */     accrualBlockNumber = currentBlockNumber;     borrowIndex = borrowIndexNew;     totalBorrows = totalBorrowsNew;     totalReserves = totalReservesNew;      /* We emit an AccrueInterest event */     emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);  }  struct MintLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint mintTokens;     uint totalSupplyNew;     uint accountTokensNew;     uint actualMintAmount; }  /// @notice User supplies assets into the market and receives lTokens in exchange /// @dev Assumes interest has already been accrued up to the current block /// @param minter The address of the account which is supplying the assets /// @param mintAmount The amount of the underlying asset to supply /// @return uint the actual mint amount. function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {     MintLocalVars memory vars;     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /*      *  We call `doTransferIn` for the minter and the mintAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if      *  side-effects occurred. The function returns the amount actually transferred,      *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`      *  of cash.      */     if (isDelegete) {         uint balanceBefore = getCashPrior();         LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);         uint balanceAfter = getCashPrior();         require(balanceAfter &gt; balanceBefore, 'mint 0');         vars.actualMintAmount = balanceAfter - balanceBefore;     } else {         vars.actualMintAmount = doTransferIn(minter, mintAmount, true);     }     /*      * We get the current exchange rate and calculate the number of lTokens to be minted:      *  mintTokens = actualMintAmount / exchangeRate      */      (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));     require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");      /* Fail if mint not allowed */     (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);     /*      * We calculate the new total supply of lTokens and minter token balance, checking for overflow:      *  totalSupplyNew = totalSupply + mintTokens      *  accountTokensNew = accountTokens[minter] + mintTokens      */     (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");      (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[minter] = vars.accountTokensNew;      /* We emit a Mint event, and a Transfer event */     emit Mint(minter, vars.actualMintAmount, vars.mintTokens);     emit Transfer(address(this), minter, vars.mintTokens);      /* We call the defense hook */      return vars.actualMintAmount; }   struct RedeemLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint redeemTokens;     uint redeemAmount;     uint totalSupplyNew;     uint accountTokensNew; }  /// @notice User redeems lTokens in exchange for the underlying asset /// @dev Assumes interest has already been accrued up to the current block /// @param redeemer The address of the account which is redeeming the tokens /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero) /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero) function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {     require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");      RedeemLocalVars memory vars;      /* exchangeRate = invoke Exchange Rate Stored() */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /* If redeemTokensIn &gt; 0: */     if (redeemTokensIn &gt; 0) {         /*          * We calculate the exchange rate and the amount of underlying to be redeemed:          *  redeemTokens = redeemTokensIn          *  redeemAmount = redeemTokensIn x exchangeRateCurrent          */         vars.redeemTokens = redeemTokensIn;          (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');     } else {         /*          * We get the current exchange rate and calculate the amount to be redeemed:          *  redeemTokens = redeemAmountIn / exchangeRate          *  redeemAmount = redeemAmountIn          */          (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');         vars.redeemAmount = redeemAmountIn;     }      /* Fail if redeem not allowed */     (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);      /*      * We calculate the new total supply and redeemer balance, checking for underflow:      *  totalSupplyNew = totalSupply - redeemTokens      *  accountTokensNew = accountTokens[redeemer] - redeemTokens      */     (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');      (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');     require(getCashPrior() &gt;= vars.redeemAmount, 'cash &lt; redeem');      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[redeemer] = vars.accountTokensNew;     /*      * We invoke doTransferOut for the redeemer and the redeemAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken has redeemAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(redeemer, vars.redeemAmount, true);       /* We emit a Transfer event, and a Redeem event */     emit Transfer(redeemer, address(this), vars.redeemTokens);     emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);      /* We call the defense hook */ }  struct BorrowLocalVars {     MathError mathErr;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /// @notice Users borrow assets from the protocol to their own address /// @param borrowAmount The amount of the underlying asset to borrow function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {     /* Fail if borrow not allowed */     (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);      /* Fail gracefully if protocol has insufficient underlying cash */     require(getCashPrior() &gt;= borrowAmount, 'cash&lt;borrow');      BorrowLocalVars memory vars;      /*      * We calculate the new borrower and total borrow balances, failing on overflow:      *  accountBorrowsNew = accountBorrows + borrowAmount      *  totalBorrowsNew = totalBorrows + borrowAmount      */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /*      * We invoke doTransferOut for the borrower and the borrowAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken borrowAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(payee, borrowAmount, false);      /* We emit a Borrow event */     emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */ }  struct RepayBorrowLocalVars {     MathError mathErr;     uint repayAmount;     uint borrowerIndex;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew;     uint actualRepayAmount;     uint badDebtsAmount; }  /// @notice Borrows are repaid by another user (possibly the borrower). /// @param payer the account paying off the borrow /// @param borrower the account with the debt being payed off /// @param repayAmount the amount of undelrying tokens being returned function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {     /* Fail if repayBorrow not allowed */     (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);      RepayBorrowLocalVars memory vars;      /* We remember the original borrowerIndex for verification purposes */     vars.borrowerIndex = accountBorrows[borrower].interestIndex;      /* We fetch the amount the borrower owes, with accumulated interest */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');      /* If repayAmount == -1, repayAmount = accountBorrows */     if (repayAmount == uint(- 1)) {         vars.repayAmount = vars.accountBorrows;     } else {         vars.repayAmount = repayAmount;     }     vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);       if (isEnd &amp;&amp; vars.accountBorrows &gt; vars.actualRepayAmount) {         vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;     }      /*     *  We calculate the new borrower and total borrow balances, failing on underflow:     *  accountBorrowsNew = accountBorrows - repayAmount     *  totalBorrowsNew = totalBorrows - repayAmount     */     if (vars.accountBorrows &lt; vars.actualRepayAmount) {         require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) &lt;= 105e16, 'repay more than 5%');         vars.accountBorrowsNew = 0;     } else {         if (isEnd) {             vars.accountBorrowsNew = 0;         } else {             vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;         }     }     //Avoid mantissa errors     if (vars.actualRepayAmount &gt; totalBorrows) {         vars.totalBorrowsNew = 0;     } else {         if (isEnd) {             vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);         } else {             vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;         }     }      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a RepayBorrow event */     emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */      return vars.actualRepayAmount; }  /*** Admin Functions ***/  /// @notice Sets a new CONTROLLER for the market /// @dev Admin function to set a new controller function setController(address newController) external override onlyAdmin {     require(address(0) != newController, "0x");     address oldController = controller;     controller = newController;     // Emit NewController(oldController, newController)     emit NewController(oldController, newController); }  function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {     require(newBorrowCapFactorMantissa &lt;= 1e18, 'Factor too large');     uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;     borrowCapFactorMantissa = newBorrowCapFactorMantissa;     emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa); }  function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {     //accrueInterest except first     if (baseRatePerBlock != 0) {         accrueInterest();     }     // total rate perYear &lt; 2000%     require(baseRatePerBlock_ &lt; 1e13, 'Base rate too large');     baseRatePerBlock = baseRatePerBlock_;     require(multiplierPerBlock_ &lt; 1e13, 'Mul rate too large');     multiplierPerBlock = multiplierPerBlock_;     require(jumpMultiplierPerBlock_ &lt; 1e13, 'Jump rate too large');     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     require(kink_ &lt;= 1e18, 'Kline too large');     kink = kink_;     emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_); }  function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {     require(newReserveFactorMantissa &lt;= 1e18, 'Factor too large');     accrueInterest();     uint oldReserveFactorMantissa = reserveFactorMantissa;     reserveFactorMantissa = newReserveFactorMantissa;     emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa); }  function addReserves(uint addAmount) external override nonReentrant {     accrueInterest();     uint totalReservesNew;     uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);     totalReservesNew = totalReserves.add(actualAddAmount);     totalReserves = totalReservesNew;     emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew); }  function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {     accrueInterest();     uint totalReservesNew;     totalReservesNew = totalReserves.sub(reduceAmount);     totalReserves = totalReservesNew;     doTransferOut(to, reduceAmount, true);     emit ReservesReduced(to, reduceAmount, totalReservesNew); }  modifier sameBlock() {     require(accrualBlockNumber == getBlockNumber(), 'not same block');     _; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.7.6;\n\n\nimport "./LPoolInterface.sol";\nimport "./LPoolDepositor.sol";\nimport "../lib/Exponential.sol";\nimport "../Adminable.sol";\nimport "../lib/CarefulMath.sol";\nimport "../lib/TransferHelper.sol";\nimport "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\n\nimport "../DelegateInterface.sol";\nimport "../ControllerInterface.sol";\nimport "../IWETH.sol";\n\n/// @title OpenLeverage\'s LToken Contract\n/// @dev Abstract base for LTokens\n/// @author OpenLeverage\ncontract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {\n    using TransferHelper for IERC20;\n    using SafeMath for uint;\n\n    constructor() {\n\n    }\n    \n    /// @notice Initialize the money market\n    /// @param controller_ The address of the Controller\n    /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0\n    /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate\n    /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point\n    /// @param kink_ The utilization point at which the jump multiplier is applied\n    /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n    /// @param name_ EIP-20 name of this token\n    /// @param symbol_ EIP-20 symbol of this token\n    /// @param decimals_ EIP-20 decimal precision of this token\n    function initialize(\n        address underlying_,\n        bool isWethPool_,\n        address controller_,\n        uint256 baseRatePerBlock_,\n        uint256 multiplierPerBlock_,\n        uint256 jumpMultiplierPerBlock_,\n        uint256 kink_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_) public {\n        require(underlying_ != address(0), "underlying_ address cannot be 0");\n        require(controller_ != address(0), "controller_ address cannot be 0");\n        require(msg.sender == admin, "Only allow to be called by admin");\n        require(accrualBlockNumber == 0 &amp;&amp; borrowIndex == 0, "inited once");\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa &gt; 0, "Initial Exchange Rate Mantissa should be greater zero");\n        //set controller\n        controller = controller_;\n        isWethPool = isWethPool_;\n        //set interestRateModel\n        baseRatePerBlock = baseRatePerBlock_;\n        multiplierPerBlock = multiplierPerBlock_;\n        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;\n        kink = kink_;\n\n        // Initialize block number and borrow index (block number mocks depend on controller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = 1e25;\n        //80%\n        borrowCapFactorMantissa = 0.8e18;\n        //10%\n        reserveFactorMantissa = 0.1e18;\n\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n\n        notEntered = true;\n\n        // Set underlying and sanity check it\n        underlying = underlying;\n        IERC20(underlying).totalSupply();\n        emit Transfer(address(0), msg.sender, 0);\n    }\n\n    /// @notice Transfer tokens tokens from src to dst by spender\n    /// @dev Called by both transfer and transferFrom internally\n    /// @param spender The address of the account performing the transfer\n    /// @param src The address of the source account\n    /// @param dst The address of the destination account\n    /// @param tokens The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {\n        require(dst != address(0), "dst address cannot be 0");\n        / Do not allow self-transfers /\n        require(src != dst, "src = dst");\n        / Fail if transfer not allowed /\n        (ControllerInterface(controller)).transferAllowed(src, dst, tokens);\n\n        / Get the allowance, infinite for the account owner /\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = uint(- 1);\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        / Do the calculations, checking for {under,over}flow /\n        MathError mathErr;\n        uint allowanceNew;\n        uint srcTokensNew;\n        uint dstTokensNew;\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n        require(mathErr == MathError.NO_ERROR, \'not allowed\');\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n        require(mathErr == MathError.NO_ERROR, \'not enough\');\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n        require(mathErr == MathError.NO_ERROR, \'too much\');\n\n        accountTokens[src] = srcTokensNew;\n        accountTokens[dst] = dstTokensNew;\n\n        / Eat some of the allowance (if necessary) /\n        if (startingAllowance != uint(- 1)) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n        / We emit a Transfer event /\n        emit Transfer(src, dst, tokens);\n        return true;\n    }\n\n    /// @notice Transfer amount tokens from msg.sender to dst\n    /// @param dst The address of the destination account\n    /// @param amount The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, msg.sender, dst, amount);\n    }\n\n    /// @notice Transfer amount tokens from src to dst\n    /// @param src The address of the source account\n    /// @param dst The address of the destination account\n    /// @param amount The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, src, dst, amount);\n    }\n\n    /// @notice Approve spender to transfer up to amount from src\n    /// @dev This will overwrite the approval amount for spender\n    ///  and is subject to issues noted here\n    /// @param spender The address of the account which may transfer tokens\n    /// @param amount The number of tokens that are approved (-1 means infinite)\n    /// @return Whether or not the approval succeeded\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /// @notice Get the current allowance from owner for spender\n    /// @param owner The address of the account which owns the tokens to be spent\n    /// @param spender The address of the account which may transfer tokens\n    /// @return The number of tokens allowed to be spent (-1 means infinite)\n    function allowance(address owner, address spender) external override view returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n\n    /// @notice Get the token balance of the owner\n    /// @param owner The address of the account to query\n    /// @return The number of tokens owned by owner\n    function balanceOf(address owner) external override view returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /// @notice Get the underlying balance of the owner\n    /// @dev This also accrues interest in a transaction\n    /// @param owner The address of the account to query\n    /// @return The amount of underlying owned by owner\n    function balanceOfUnderlying(address owner) external override returns (uint) {\n        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n        require(mErr == MathError.NO_ERROR, "calc failed");\n        return balance;\n    }\n\n    / User Interface /\n\n    /// @notice Sender supplies assets into the market and receives lTokens in exchange\n    /// @dev Accrues interest whether or not the operation succeeds, unless reverted\n    /// @param mintAmount The amount of the underlying asset to supply\n    function mint(uint mintAmount) external override nonReentrant {\n        accrueInterest();\n        mintFresh(msg.sender, mintAmount, false);\n    }\n\n    function mintTo(address to, uint amount) external payable override nonReentrant {\n        accrueInterest();\n        if (isWethPool) {\n            mintFresh(to, msg.value, false);\n        } else {\n            mintFresh(to, amount, true);\n        }\n    }\n\n    function mintEth() external payable override nonReentrant {\n        require(isWethPool, "not eth pool");\n        accrueInterest();\n        mintFresh(msg.sender, msg.value, false);\n    }\n\n    /// @notice Sender redeems lTokens in exchange for the underlying asset\n    /// @dev Accrues interest whether or not the operation succeeds, unless reverted\n    /// @param redeemTokens The number of lTokens to redeem into underlying\n    function redeem(uint redeemTokens) external override nonReentrant {\n        accrueInterest();\n        // redeemFresh emits redeem-specific logs on errors, so we don\'t need to\n        redeemFresh(msg.sender, redeemTokens, 0);\n    }\n\n    /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset\n    /// @dev Accrues interest whether or not the operation succeeds, unless reverted\n    /// @param redeemAmount The amount of underlying to redeem\n    function redeemUnderlying(uint redeemAmount) external override nonReentrant {\n        accrueInterest();\n        // redeemFresh emits redeem-specific logs on errors, so we don\'t need to\n        redeemFresh(msg.sender, 0, redeemAmount);\n    }\n\n    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {\n        accrueInterest();\n        // borrowFresh emits borrow-specific logs on errors, so we don\'t need to\n        borrowFresh(payable(borrower), msg.sender, borrowAmount);\n    }\n\n    /// @notice Sender repays a borrow belonging to borrower\n    /// @param borrower the account with the debt being payed off\n    /// @param repayAmount The amount to repay\n    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {\n        accrueInterest();\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don\'t need to\n        repayBorrowFresh(msg.sender, borrower, repayAmount, false);\n    }\n\n    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {\n        accrueInterest();\n        repayBorrowFresh(msg.sender, borrower, repayAmount, true);\n    }\n\n\n    / Safe Token /\n\n    /// Gets balance of this contract in terms of the underlying\n    /// @dev This excludes the value of the current message, if any\n    /// @return The quantity of underlying tokens owned by this contract\n    function getCashPrior() internal view returns (uint) {\n        return IERC20(underlying).balanceOf(address(this));\n    }\n\n\n    /\n     * @dev Similar to EIP20 transfer, except it handles a False result from transferFrom and reverts in that case.\n     *      This will revert due to insufficient balance or insufficient allowance.\n     *      This function returns the actual amount received,\n     *      which may be less than amount if there is a fee attached to the transfer.\n     \n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     /\n    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {\n        if (isWethPool &amp;&amp; convertWeth) {\n            actualAmount = msg.value;\n            IWETH(underlying).deposit{value : actualAmount}();\n        } else {\n            actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);\n        }\n    }\n\n    /\n     * @dev Similar to EIP20 transfer, except it handles a False success from transfer and returns an explanatory\n     *      error code rather than reverting. If caller has not called checked protocol\'s balance, this may revert due to\n     *      insufficient cash held in this contract. If caller has checked protocol\'s balance prior to this call, and verified\n     *      it is &gt;= amount, this should not revert in normal conditions.\n     \n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     /\n    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {\n        if (isWethPool &amp;&amp; convertWeth) {\n            IWETH(underlying).withdraw(amount);\n            to.transfer(amount);\n        } else {\n            IERC20(underlying).safeTransfer(to, amount);\n        }\n    }\n\n    function availableForBorrow() external view override returns (uint){\n        uint cash = getCashPrior();\n        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);\n        if (err0 != MathError.NO_ERROR) {\n            return 0;\n        }\n        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);\n        if (err1 != MathError.NO_ERROR) {\n            return 0;\n        }\n        if (totalBorrows &gt; maxAvailable) {\n            return 0;\n        }\n        return maxAvailable - totalBorrows;\n    }\n\n\n    /// @notice Get a snapshot of the account\'s balances, and the cached exchange rate\n    /// @dev This is used by controller to more efficiently perform liquidity checks.\n    /// @param account Address of the account to snapshot\n    /// @return ( token balance, borrow balance, exchange rate mantissa)\n    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {\n        uint cTokenBalance = accountTokens[account];\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n\n        MathError mErr;\n\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n        if (mErr != MathError.NO_ERROR) {\n            return (0, 0, 0);\n        }\n\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (mErr != MathError.NO_ERROR) {\n            return (0, 0, 0);\n        }\n\n        return (cTokenBalance, borrowBalance, exchangeRateMantissa);\n    }\n\n    /// @dev Function to simply retrieve block number\n    ///  This exists mainly for inheriting test contracts to stub this result.\n    function getBlockNumber() internal view returns (uint) {\n        return block.number;\n    }\n\n    /// @notice Returns the current per-block borrow interest rate for this cToken\n    /// @return The borrow interest rate per block, scaled by 1e18\n    function borrowRatePerBlock() external override view returns (uint) {\n        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);\n    }\n\n    \n    /// @notice Returns the current per-block supply interest rate for this cToken\n    /// @return The supply interest rate per block, scaled by 1e18\n    function supplyRatePerBlock() external override view returns (uint) {\n        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\n    }\n\n    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {\n        // Utilization rate is 0 when there are no borrows\n        if (borrows == 0) {\n            return 0;\n        }\n        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));\n    }\n\n    /// @notice Calculates the current borrow rate per block, with the error code expected by the market\n    /// @param cash The amount of cash in the market\n    /// @param borrows The amount of borrows in the market\n    /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\n    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {\n        uint util = utilizationRate(cash, borrows, reserves);\n        if (util &lt;= kink) {\n            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n        } else {\n            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n            uint excessUtil = util.sub(kink);\n            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);\n        }\n    }\n\n    /// @notice Calculates the current supply rate per block\n    /// @param cash The amount of cash in the market\n    /// @param borrows The amount of borrows in the market\n    /// @return The supply rate percentage per block as a mantissa (scaled by 1e18)\n    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {\n        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);\n        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);\n        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\n        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\n    }\n\n    /// @notice Returns the current total borrows plus accrued interest\n    /// @return The total borrows with interest\n    function totalBorrowsCurrent() external override view returns (uint) {\n        / Remember the initial block number /\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        / Short-circuit accumulating 0 interest /\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return totalBorrows;\n        }\n\n        / Read the previous values out of storage /\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint reservesPrior = totalReserves;\n\n        / Calculate the current borrow interest rate /\n        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");\n\n        / Calculate the number of blocks elapsed since the last accrual /\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        require(mathErr == MathError.NO_ERROR, "calc block delta erro");\n\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        require(mathErr == MathError.NO_ERROR, \'calc interest factor error\');\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc interest acc error\');\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc total borrows error\');\n\n        return totalBorrowsNew;\n    }\n\n    /// @notice Accrue interest to updated borrowIndex and then calculate account\'s borrow balance using the updated borrowIndex\n    /// @param account The address whose balance should be calculated after updating borrowIndex\n    /// @return The calculated balance\n    function borrowBalanceCurrent(address account) external view override returns (uint) {\n        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();\n        require(err0 == MathError.NO_ERROR, "calc borrow index fail");\n        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);\n        require(err1 == MathError.NO_ERROR, "calc fail");\n        return result;\n    }\n\n    function borrowBalanceStored(address account) external override view returns (uint){\n        return accountBorrows[account].principal;\n    }\n\n\n    /// @notice Return the borrow balance of account based on stored data\n    /// @param account The address whose balance should be calculated\n    /// @return (error code, the calculated balance or 0 if error code is non-zero)\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);\n    }\n\n    /// @notice Return the borrow balance of account based on stored data\n    /// @param account The address whose balance should be calculated\n    /// @return (error code, the calculated balance or 0 if error code is non-zero)\n    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {\n        / Note: we do not assert that the market is up to date /\n        MathError mathErr;\n        uint principalTimesIndex;\n        uint result;\n\n        / Get borrowBalance and borrowIndex /\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        / If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         /\n        if (borrowSnapshot.principal == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        / Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         /\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        return (MathError.NO_ERROR, result);\n    }\n\n    /// @notice Accrue interest then return the up-to-date exchange rate\n    /// @return Calculated exchange rate scaled by 1e18\n    function exchangeRateCurrent() public override nonReentrant returns (uint) {\n        accrueInterest();\n        return exchangeRateStored();\n    }\n\n    /// Calculates the exchange rate from the underlying to the LToken\n    /// @dev This function does not accrue interest before calculating the exchange rate\n    /// @return Calculated exchange rate scaled by 1e18\n    function exchangeRateStored() public override view returns (uint) {\n        (MathError err, uint result) = exchangeRateStoredInternal();\n        require(err == MathError.NO_ERROR, "calc fail");\n        return result;\n    }\n\n    /// @notice Calculates the exchange rate from the underlying to the LToken\n    /// @dev This function does not accrue interest before calculating the exchange rate\n    /// @return (error code, calculated exchange rate scaled by 1e18)\n    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n        uint _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            /\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             /\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\n        } else {\n            /\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             /\n            uint _totalCash = getCashPrior();\n            uint cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n            MathError mathErr;\n\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\n        }\n    }\n\n    /// @notice Get cash balance of this cToken in the underlying asset\n    /// @return The quantity of underlying asset owned by this contract\n    function getCash() external override view returns (uint) {\n        return IERC20(underlying).balanceOf(address(this));\n    }\n\n    function calCurrentBorrowIndex() internal view returns (MathError, uint) {\n        / Remember the initial block number /\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n        uint borrowIndexNew;\n        / Short-circuit accumulating 0 interest /\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return (MathError.NO_ERROR, borrowIndex);\n        }\n        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n\n        Exp memory simpleInterestFactor;\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);\n        return (mathErr, borrowIndexNew);\n    }\n\n    /// @notice Applies accrued interest to total borrows and reserves\n    /// @dev This calculates interest accrued from the last checkpointed block\n    ///   up to the current block and writes new checkpoint to storage.\n    function accrueInterest() public override {\n        / Remember the initial block number /\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        / Short-circuit accumulating 0 interest /\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return;\n        }\n\n        / Read the previous values out of storage /\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint borrowIndexPrior = borrowIndex;\n        uint reservesPrior = totalReserves;\n\n        / Calculate the current borrow interest rate /\n        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");\n\n        / Calculate the number of blocks elapsed since the last accrual /\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        require(mathErr == MathError.NO_ERROR, "calc block delta erro");\n\n\n        /\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         /\n\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n        uint borrowIndexNew;\n        uint totalReservesNew;\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        require(mathErr == MathError.NO_ERROR, \'calc interest factor error\');\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc interest acc error\');\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc total borrows error\');\n\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc total reserves error\');\n\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc borrows index error\');\n\n\n        / We write the previously calculated values into storage /\n        accrualBlockNumber = currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n        totalReserves = totalReservesNew;\n\n        / We emit an AccrueInterest event /\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n    }\n\n    struct MintLocalVars {\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint mintTokens;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n        uint actualMintAmount;\n    }\n\n    /// @notice User supplies assets into the market and receives lTokens in exchange\n    /// @dev Assumes interest has already been accrued up to the current block\n    /// @param minter The address of the account which is supplying the assets\n    /// @param mintAmount The amount of the underlying asset to supply\n    /// @return uint the actual mint amount.\n    function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {\n        MintLocalVars memory vars;\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, \'calc exchangerate error\');\n\n        /\n         *  We call doTransferIn for the minter and the mintAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  doTransferIn reverts if anything goes wrong, since we can\'t be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the cToken holds an additional actualMintAmount\n         *  of cash.\n         /\n        if (isDelegete) {\n            uint balanceBefore = getCashPrior();\n            LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);\n            uint balanceAfter = getCashPrior();\n            require(balanceAfter &gt; balanceBefore, \'mint 0\');\n            vars.actualMintAmount = balanceAfter - balanceBefore;\n        } else {\n            vars.actualMintAmount = doTransferIn(minter, mintAmount, true);\n        }\n        /\n         * We get the current exchange rate and calculate the number of lTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         /\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));\n        require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");\n\n        / Fail if mint not allowed /\n        (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);\n        /\n         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         /\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n        require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n        require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");\n\n        / We write previously calculated values into storage /\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[minter] = vars.accountTokensNew;\n\n        / We emit a Mint event, and a Transfer event /\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n        / We call the defense hook /\n\n        return vars.actualMintAmount;\n    }\n\n\n    struct RedeemLocalVars {\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint redeemTokens;\n        uint redeemAmount;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n    }\n\n    /// @notice User redeems lTokens in exchange for the underlying asset\n    /// @dev Assumes interest has already been accrued up to the current block\n    /// @param redeemer The address of the account which is redeeming the tokens\n    /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n    /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");\n\n        RedeemLocalVars memory vars;\n\n        / exchangeRate = invoke Exchange Rate Stored() /\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, \'calc exchangerate error\');\n\n        / If redeemTokensIn &gt; 0: /\n        if (redeemTokensIn &gt; 0) {\n            /\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             /\n            vars.redeemTokens = redeemTokensIn;\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);\n            require(vars.mathErr == MathError.NO_ERROR, \'calc redeem amount error\');\n        } else {\n            /\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             /\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));\n            require(vars.mathErr == MathError.NO_ERROR, \'calc redeem tokens error\');\n            vars.redeemAmount = redeemAmountIn;\n        }\n\n        / Fail if redeem not allowed /\n        (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);\n\n        /\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n         *  totalSupplyNew = totalSupply - redeemTokens\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n         /\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n        require(vars.mathErr == MathError.NO_ERROR, \'calc supply new error\');\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n        require(vars.mathErr == MathError.NO_ERROR, \'calc token new error\');\n        require(getCashPrior() &gt;= vars.redeemAmount, \'cash &lt; redeem\');\n\n        / We write previously calculated values into storage /\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[redeemer] = vars.accountTokensNew;\n        /\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken has redeemAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can\'t be sure if side effects occurred.\n         /\n        doTransferOut(redeemer, vars.redeemAmount, true);\n\n\n        / We emit a Transfer event, and a Redeem event /\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        / We call the defense hook /\n    }\n\n    struct BorrowLocalVars {\n        MathError mathErr;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n    }\n\n    /// @notice Users borrow assets from the protocol to their own address\n    /// @param borrowAmount The amount of the underlying asset to borrow\n    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {\n        / Fail if borrow not allowed /\n        (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);\n\n        / Fail gracefully if protocol has insufficient underlying cash /\n        require(getCashPrior() &gt;= borrowAmount, \'cash vars.actualRepayAmount) {\n            vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;\n        }\n\n        /\n        *  We calculate the new borrower and total borrow balances, failing on underflow:\n        *  accountBorrowsNew = accountBorrows - repayAmount\n        *  totalBorrowsNew = totalBorrows - repayAmount\n        /\n        if (vars.accountBorrows &lt; vars.actualRepayAmount) {\n            require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) &lt;= 105e16, \'repay more than 5%\');\n            vars.accountBorrowsNew = 0;\n        } else {\n            if (isEnd) {\n                vars.accountBorrowsNew = 0;\n            } else {\n                vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;\n            }\n        }\n        //Avoid mantissa errors\n        if (vars.actualRepayAmount &gt; totalBorrows) {\n            vars.totalBorrowsNew = 0;\n        } else {\n            if (isEnd) {\n                vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);\n            } else {\n                vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;\n            }\n        }\n\n        / We write the previously calculated values into storage /\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        / We emit a RepayBorrow event /\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        / We call the defense hook */\n\n        return vars.actualRepayAmount;\n    }\n\n    / Admin Functions ***/\n\n    /// @notice Sets a new CONTROLLER for the market\n    /// @dev Admin function to set a new controller\n    function setController(address newController) external override onlyAdmin {\n        require(address(0) != newController, "0x");\n        address oldController = controller;\n        controller = newController;\n        // Emit NewController(oldController, newController)\n        emit NewController(oldController, newController);\n    }\n\n    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {\n        require(newBorrowCapFactorMantissa &lt;= 1e18, \'Factor too large\');\n        uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;\n        borrowCapFactorMantissa = newBorrowCapFactorMantissa;\n        emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa);\n    }\n\n    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {\n        //accrueInterest except first\n        if (baseRatePerBlock != 0) {\n            accrueInterest();\n        }\n        // total rate perYear &lt; 2000%\n        require(baseRatePerBlock_ &lt; 1e13, \'Base rate too large\');\n        baseRatePerBlock = baseRatePerBlock_;\n        require(multiplierPerBlock_ &lt; 1e13, \'Mul rate too large\');\n        multiplierPerBlock = multiplierPerBlock_;\n        require(jumpMultiplierPerBlock_ &lt; 1e13, \'Jump rate too large\');\n        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;\n        require(kink_ &lt;= 1e18, \'Kline too large\');\n        kink = kink_;\n        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);\n    }\n\n    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {\n        require(newReserveFactorMantissa &lt;= 1e18, \'Factor too large\');\n        accrueInterest();\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n        reserveFactorMantissa = newReserveFactorMantissa;\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n    }\n\n    function addReserves(uint addAmount) external override nonReentrant {\n        accrueInterest();\n        uint totalReservesNew;\n        uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);\n        totalReservesNew = totalReserves.add(actualAddAmount);\n        totalReserves = totalReservesNew;\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n    }\n\n    function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {\n        accrueInterest();\n        uint totalReservesNew;\n        totalReservesNew = totalReserves.sub(reduceAmount);\n        totalReserves = totalReservesNew;\n        doTransferOut(to, reduceAmount, true);\n        emit ReservesReduced(to, reduceAmount, totalReservesNew);\n    }\n\n    modifier sameBlock() {\n        require(accrualBlockNumber == getBlockNumber(), \'not same block\');\n        _;\n    }\n}\n\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-24-08 19:28:15 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.7.6; import "./LPoolInterface.sol"; import "./LPoolDepositor.sol"; import "../lib/Exponential.sol"; import "../Adminable.sol"; import "../lib/CarefulMath.sol"; import "../lib/TransferHelper.sol"; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import "../DelegateInterface.sol"; import "../ControllerInterface.sol"; import "../IWETH.sol"; /// @title OpenLeverage's LToken Contract /// @dev Abstract base for LTokens /// @author OpenLeverage contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {     using TransferHelper for IERC20;     using SafeMath for uint; constructor() {  }  /// @notice Initialize the money market /// @param controller_ The address of the Controller /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0 /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point /// @param kink_ The utilization point at which the jump multiplier is applied /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18 /// @param name_ EIP-20 name of this token /// @param symbol_ EIP-20 symbol of this token /// @param decimals_ EIP-20 decimal precision of this token function initialize(     address underlying_,     bool isWethPool_,     address controller_,     uint256 baseRatePerBlock_,     uint256 multiplierPerBlock_,     uint256 jumpMultiplierPerBlock_,     uint256 kink_,     uint initialExchangeRateMantissa_,     string memory name_,     string memory symbol_,     uint8 decimals_) public {     require(underlying_ != address(0), "underlying_ address cannot be 0");     require(controller_ != address(0), "controller_ address cannot be 0");     require(msg.sender == admin, "Only allow to be called by admin");     require(accrualBlockNumber == 0 &amp;&amp; borrowIndex == 0, "inited once");      // Set initial exchange rate     initialExchangeRateMantissa = initialExchangeRateMantissa_;     require(initialExchangeRateMantissa &gt; 0, "Initial Exchange Rate Mantissa should be greater zero");     //set controller     controller = controller_;     isWethPool = isWethPool_;     //set interestRateModel     baseRatePerBlock = baseRatePerBlock_;     multiplierPerBlock = multiplierPerBlock_;     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     kink = kink_;      // Initialize block number and borrow index (block number mocks depend on controller being set)     accrualBlockNumber = getBlockNumber();     borrowIndex = 1e25;     //80%     borrowCapFactorMantissa = 0.8e18;     //10%     reserveFactorMantissa = 0.1e18;       name = name_;     symbol = symbol_;     decimals = decimals_;      _notEntered = true;      // Set underlying and sanity check it     underlying = underlying_;     IERC20(underlying).totalSupply();     emit Transfer(address(0), msg.sender, 0); }  /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender` /// @dev Called by both `transfer` and `transferFrom` internally /// @param spender The address of the account performing the transfer /// @param src The address of the source account /// @param dst The address of the destination account /// @param tokens The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {     require(dst != address(0), "dst address cannot be 0");     /* Do not allow self-transfers */     require(src != dst, "src = dst");     /* Fail if transfer not allowed */     (ControllerInterface(controller)).transferAllowed(src, dst, tokens);      /* Get the allowance, infinite for the account owner */     uint startingAllowance = 0;     if (spender == src) {         startingAllowance = uint(- 1);     } else {         startingAllowance = transferAllowances[src][spender];     }      /* Do the calculations, checking for {under,over}flow */     MathError mathErr;     uint allowanceNew;     uint srcTokensNew;     uint dstTokensNew;      (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);     require(mathErr == MathError.NO_ERROR, 'not allowed');      (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);     require(mathErr == MathError.NO_ERROR, 'not enough');      (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);     require(mathErr == MathError.NO_ERROR, 'too much');      accountTokens[src] = srcTokensNew;     accountTokens[dst] = dstTokensNew;      /* Eat some of the allowance (if necessary) */     if (startingAllowance != uint(- 1)) {         transferAllowances[src][spender] = allowanceNew;     }     /* We emit a Transfer event */     emit Transfer(src, dst, tokens);     return true; }  /// @notice Transfer `amount` tokens from `msg.sender` to `dst` /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, msg.sender, dst, amount); }  /// @notice Transfer `amount` tokens from `src` to `dst` /// @param src The address of the source account /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, src, dst, amount); }  /// @notice Approve `spender` to transfer up to `amount` from `src` /// @dev This will overwrite the approval amount for `spender` ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve) /// @param spender The address of the account which may transfer tokens /// @param amount The number of tokens that are approved (-1 means infinite) /// @return Whether or not the approval succeeded function approve(address spender, uint256 amount) external override returns (bool) {     address src = msg.sender;     transferAllowances[src][spender] = amount;     emit Approval(src, spender, amount);     return true; }  /// @notice Get the current allowance from `owner` for `spender` /// @param owner The address of the account which owns the tokens to be spent /// @param spender The address of the account which may transfer tokens /// @return The number of tokens allowed to be spent (-1 means infinite) function allowance(address owner, address spender) external override view returns (uint256) {     return transferAllowances[owner][spender]; }  /// @notice Get the token balance of the `owner` /// @param owner The address of the account to query /// @return The number of tokens owned by `owner` function balanceOf(address owner) external override view returns (uint256) {     return accountTokens[owner]; }  /// @notice Get the underlying balance of the `owner` /// @dev This also accrues interest in a transaction /// @param owner The address of the account to query /// @return The amount of underlying owned by `owner` function balanceOfUnderlying(address owner) external override returns (uint) {     Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});     (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);     require(mErr == MathError.NO_ERROR, "calc failed");     return balance; }  /*** User Interface ***/  /// @notice Sender supplies assets into the market and receives lTokens in exchange /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param mintAmount The amount of the underlying asset to supply function mint(uint mintAmount) external override nonReentrant {     accrueInterest();     mintFresh(msg.sender, mintAmount, false); }  function mintTo(address to, uint amount) external payable override nonReentrant {     accrueInterest();     if (isWethPool) {         mintFresh(to, msg.value, false);     } else {         mintFresh(to, amount, true);     } }  function mintEth() external payable override nonReentrant {     require(isWethPool, "not eth pool");     accrueInterest();     mintFresh(msg.sender, msg.value, false); }  /// @notice Sender redeems lTokens in exchange for the underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemTokens The number of lTokens to redeem into underlying function redeem(uint redeemTokens) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, redeemTokens, 0); }  /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemAmount The amount of underlying to redeem function redeemUnderlying(uint redeemAmount) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, 0, redeemAmount); }  function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {     accrueInterest();     // borrowFresh emits borrow-specific logs on errors, so we don't need to     borrowFresh(payable(borrower), msg.sender, borrowAmount); }  /// @notice Sender repays a borrow belonging to borrower /// @param borrower the account with the debt being payed off /// @param repayAmount The amount to repay function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     repayBorrowFresh(msg.sender, borrower, repayAmount, false); }  function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     repayBorrowFresh(msg.sender, borrower, repayAmount, true); }   /*** Safe Token ***/  /// Gets balance of this contract in terms of the underlying /// @dev This excludes the value of the current message, if any /// @return The quantity of underlying tokens owned by this contract function getCashPrior() internal view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }   /**  * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.  *      This will revert due to insufficient balance or insufficient allowance.  *      This function returns the actual amount received,  *      which may be less than `amount` if there is a fee attached to the transfer.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {     if (isWethPool &amp;&amp; convertWeth) {         actualAmount = msg.value;         IWETH(underlying).deposit{value : actualAmount}();     } else {         actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);     } }  /**  * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory  *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to  *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified  *      it is &gt;= amount, this should not revert in normal conditions.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferOut(address payable to, uint amount, bool convertWeth) internal {     if (isWethPool &amp;&amp; convertWeth) {         IWETH(underlying).withdraw(amount);         to.transfer(amount);     } else {         IERC20(underlying).safeTransfer(to, amount);     } }  function availableForBorrow() external view override returns (uint){     uint cash = getCashPrior();     (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);     if (err0 != MathError.NO_ERROR) {         return 0;     }     (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);     if (err1 != MathError.NO_ERROR) {         return 0;     }     if (totalBorrows &gt; maxAvailable) {         return 0;     }     return maxAvailable - totalBorrows; }   /// @notice Get a snapshot of the account's balances, and the cached exchange rate /// @dev This is used by controller to more efficiently perform liquidity checks. /// @param account Address of the account to snapshot /// @return ( token balance, borrow balance, exchange rate mantissa) function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {     uint cTokenBalance = accountTokens[account];     uint borrowBalance;     uint exchangeRateMantissa;      MathError mErr;      (mErr, borrowBalance) = borrowBalanceStoredInternal(account);     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      return (cTokenBalance, borrowBalance, exchangeRateMantissa); }  /// @dev Function to simply retrieve block number ///  This exists mainly for inheriting test contracts to stub this result. function getBlockNumber() internal view returns (uint) {     return block.number; }  /// @notice Returns the current per-block borrow interest rate for this cToken /// @return The borrow interest rate per block, scaled by 1e18 function borrowRatePerBlock() external override view returns (uint) {     return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves); }   /// @notice Returns the current per-block supply interest rate for this cToken /// @return The supply interest rate per block, scaled by 1e18 function supplyRatePerBlock() external override view returns (uint) {     return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa); }  function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {     // Utilization rate is 0 when there are no borrows     if (borrows == 0) {         return 0;     }     return borrows.mul(1e18).div(cash.add(borrows).sub(reserves)); }  /// @notice Calculates the current borrow rate per block, with the error code expected by the market /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18) function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {     uint util = utilizationRate(cash, borrows, reserves);     if (util &lt;= kink) {         return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);     } else {         uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);         uint excessUtil = util.sub(kink);         return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);     } }  /// @notice Calculates the current supply rate per block /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The supply rate percentage per block as a mantissa (scaled by 1e18) function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {     uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);     uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);     uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);     return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18); }  /// @notice Returns the current total borrows plus accrued interest /// @return The total borrows with interest function totalBorrowsCurrent() external override view returns (uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return totalBorrows;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, "calc block delta erro");      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      return totalBorrowsNew; }  /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex /// @param account The address whose balance should be calculated after updating borrowIndex /// @return The calculated balance function borrowBalanceCurrent(address account) external view override returns (uint) {     (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();     require(err0 == MathError.NO_ERROR, "calc borrow index fail");     (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);     require(err1 == MathError.NO_ERROR, "calc fail");     return result; }  function borrowBalanceStored(address account) external override view returns (uint){     return accountBorrows[account].principal; }   /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {     return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex); }  /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {     /* Note: we do not assert that the market is up to date */     MathError mathErr;     uint principalTimesIndex;     uint result;      /* Get borrowBalance and borrowIndex */     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];      /* If borrowBalance = 0 then borrowIndex is likely also 0.      * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.      */     if (borrowSnapshot.principal == 0) {         return (MathError.NO_ERROR, 0);     }      /* Calculate new borrow balance using the interest index:      *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex      */     (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      return (MathError.NO_ERROR, result); }  /// @notice Accrue interest then return the up-to-date exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateCurrent() public override nonReentrant returns (uint) {     accrueInterest();     return exchangeRateStored(); }  /// Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateStored() public override view returns (uint) {     (MathError err, uint result) = exchangeRateStoredInternal();     require(err == MathError.NO_ERROR, "calc fail");     return result; }  /// @notice Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return (error code, calculated exchange rate scaled by 1e18) function exchangeRateStoredInternal() internal view returns (MathError, uint) {     uint _totalSupply = totalSupply;     if (_totalSupply == 0) {         /*          * If there are no tokens minted:          *  exchangeRate = initialExchangeRate          */         return (MathError.NO_ERROR, initialExchangeRateMantissa);     } else {         /*          * Otherwise:          *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply          */         uint _totalCash = getCashPrior();         uint cashPlusBorrowsMinusReserves;         Exp memory exchangeRate;         MathError mathErr;          (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          return (MathError.NO_ERROR, exchangeRate.mantissa);     } }  /// @notice Get cash balance of this cToken in the underlying asset /// @return The quantity of underlying asset owned by this contract function getCash() external override view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }  function calCurrentBorrowIndex() internal view returns (MathError, uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;     uint borrowIndexNew;     /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return (MathError.NO_ERROR, borrowIndex);     }     uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);      Exp memory simpleInterestFactor;     (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }     (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);     return (mathErr, borrowIndexNew); }  /// @notice Applies accrued interest to total borrows and reserves /// @dev This calculates interest accrued from the last checkpointed block ///   up to the current block and writes new checkpoint to storage. function accrueInterest() public override {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint borrowIndexPrior = borrowIndex;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, "calc block delta erro");       /*      * Calculate the interest accumulated into borrows and reserves and the new index:      *  simpleInterestFactor = borrowRate * blockDelta      *  interestAccumulated = simpleInterestFactor * totalBorrows      *  totalBorrowsNew = interestAccumulated + totalBorrows      *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex      */      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;     uint borrowIndexNew;     uint totalReservesNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);     require(mathErr == MathError.NO_ERROR, 'calc total reserves error');      (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);     require(mathErr == MathError.NO_ERROR, 'calc borrows index error');       /* We write the previously calculated values into storage */     accrualBlockNumber = currentBlockNumber;     borrowIndex = borrowIndexNew;     totalBorrows = totalBorrowsNew;     totalReserves = totalReservesNew;      /* We emit an AccrueInterest event */     emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);  }  struct MintLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint mintTokens;     uint totalSupplyNew;     uint accountTokensNew;     uint actualMintAmount; }  /// @notice User supplies assets into the market and receives lTokens in exchange /// @dev Assumes interest has already been accrued up to the current block /// @param minter The address of the account which is supplying the assets /// @param mintAmount The amount of the underlying asset to supply /// @return uint the actual mint amount. function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {     MintLocalVars memory vars;     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /*      *  We call `doTransferIn` for the minter and the mintAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if      *  side-effects occurred. The function returns the amount actually transferred,      *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`      *  of cash.      */     if (isDelegete) {         uint balanceBefore = getCashPrior();         LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);         uint balanceAfter = getCashPrior();         require(balanceAfter &gt; balanceBefore, 'mint 0');         vars.actualMintAmount = balanceAfter - balanceBefore;     } else {         vars.actualMintAmount = doTransferIn(minter, mintAmount, true);     }     /*      * We get the current exchange rate and calculate the number of lTokens to be minted:      *  mintTokens = actualMintAmount / exchangeRate      */      (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));     require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");      /* Fail if mint not allowed */     (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);     /*      * We calculate the new total supply of lTokens and minter token balance, checking for overflow:      *  totalSupplyNew = totalSupply + mintTokens      *  accountTokensNew = accountTokens[minter] + mintTokens      */     (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");      (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[minter] = vars.accountTokensNew;      /* We emit a Mint event, and a Transfer event */     emit Mint(minter, vars.actualMintAmount, vars.mintTokens);     emit Transfer(address(this), minter, vars.mintTokens);      /* We call the defense hook */      return vars.actualMintAmount; }   struct RedeemLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint redeemTokens;     uint redeemAmount;     uint totalSupplyNew;     uint accountTokensNew; }  /// @notice User redeems lTokens in exchange for the underlying asset /// @dev Assumes interest has already been accrued up to the current block /// @param redeemer The address of the account which is redeeming the tokens /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero) /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero) function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {     require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");      RedeemLocalVars memory vars;      /* exchangeRate = invoke Exchange Rate Stored() */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /* If redeemTokensIn &gt; 0: */     if (redeemTokensIn &gt; 0) {         /*          * We calculate the exchange rate and the amount of underlying to be redeemed:          *  redeemTokens = redeemTokensIn          *  redeemAmount = redeemTokensIn x exchangeRateCurrent          */         vars.redeemTokens = redeemTokensIn;          (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');     } else {         /*          * We get the current exchange rate and calculate the amount to be redeemed:          *  redeemTokens = redeemAmountIn / exchangeRate          *  redeemAmount = redeemAmountIn          */          (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');         vars.redeemAmount = redeemAmountIn;     }      /* Fail if redeem not allowed */     (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);      /*      * We calculate the new total supply and redeemer balance, checking for underflow:      *  totalSupplyNew = totalSupply - redeemTokens      *  accountTokensNew = accountTokens[redeemer] - redeemTokens      */     (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');      (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');     require(getCashPrior() &gt;= vars.redeemAmount, 'cash &lt; redeem');      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[redeemer] = vars.accountTokensNew;     /*      * We invoke doTransferOut for the redeemer and the redeemAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken has redeemAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(redeemer, vars.redeemAmount, true);       /* We emit a Transfer event, and a Redeem event */     emit Transfer(redeemer, address(this), vars.redeemTokens);     emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);      /* We call the defense hook */ }  struct BorrowLocalVars {     MathError mathErr;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /// @notice Users borrow assets from the protocol to their own address /// @param borrowAmount The amount of the underlying asset to borrow function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {     /* Fail if borrow not allowed */     (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);      /* Fail gracefully if protocol has insufficient underlying cash */     require(getCashPrior() &gt;= borrowAmount, 'cash&lt;borrow');      BorrowLocalVars memory vars;      /*      * We calculate the new borrower and total borrow balances, failing on overflow:      *  accountBorrowsNew = accountBorrows + borrowAmount      *  totalBorrowsNew = totalBorrows + borrowAmount      */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /*      * We invoke doTransferOut for the borrower and the borrowAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken borrowAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(payee, borrowAmount, false);      /* We emit a Borrow event */     emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */ }  struct RepayBorrowLocalVars {     MathError mathErr;     uint repayAmount;     uint borrowerIndex;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew;     uint actualRepayAmount;     uint badDebtsAmount; }  /// @notice Borrows are repaid by another user (possibly the borrower). /// @param payer the account paying off the borrow /// @param borrower the account with the debt being payed off /// @param repayAmount the amount of undelrying tokens being returned function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {     /* Fail if repayBorrow not allowed */     (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);      RepayBorrowLocalVars memory vars;      /* We remember the original borrowerIndex for verification purposes */     vars.borrowerIndex = accountBorrows[borrower].interestIndex;      /* We fetch the amount the borrower owes, with accumulated interest */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');      /* If repayAmount == -1, repayAmount = accountBorrows */     if (repayAmount == uint(- 1)) {         vars.repayAmount = vars.accountBorrows;     } else {         vars.repayAmount = repayAmount;     }     vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);       if (isEnd &amp;&amp; vars.accountBorrows &gt; vars.actualRepayAmount) {         vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;     }      /*     *  We calculate the new borrower and total borrow balances, failing on underflow:     *  accountBorrowsNew = accountBorrows - repayAmount     *  totalBorrowsNew = totalBorrows - repayAmount     */     if (vars.accountBorrows &lt; vars.actualRepayAmount) {         require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) &lt;= 105e16, 'repay more than 5%');         vars.accountBorrowsNew = 0;     } else {         if (isEnd) {             vars.accountBorrowsNew = 0;         } else {             vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;         }     }     //Avoid mantissa errors     if (vars.actualRepayAmount &gt; totalBorrows) {         vars.totalBorrowsNew = 0;     } else {         if (isEnd) {             vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);         } else {             vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;         }     }      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a RepayBorrow event */     emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */      return vars.actualRepayAmount; }  /*** Admin Functions ***/  /// @notice Sets a new CONTROLLER for the market /// @dev Admin function to set a new controller function setController(address newController) external override onlyAdmin {     require(address(0) != newController, "0x");     address oldController = controller;     controller = newController;     // Emit NewController(oldController, newController)     emit NewController(oldController, newController); }  function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {     require(newBorrowCapFactorMantissa &lt;= 1e18, 'Factor too large');     uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;     borrowCapFactorMantissa = newBorrowCapFactorMantissa;     emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa); }  function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {     //accrueInterest except first     if (baseRatePerBlock != 0) {         accrueInterest();     }     // total rate perYear &lt; 2000%     require(baseRatePerBlock_ &lt; 1e13, 'Base rate too large');     baseRatePerBlock = baseRatePerBlock_;     require(multiplierPerBlock_ &lt; 1e13, 'Mul rate too large');     multiplierPerBlock = multiplierPerBlock_;     require(jumpMultiplierPerBlock_ &lt; 1e13, 'Jump rate too large');     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     require(kink_ &lt;= 1e18, 'Kline too large');     kink = kink_;     emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_); }  function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {     require(newReserveFactorMantissa &lt;= 1e18, 'Factor too large');     accrueInterest();     uint oldReserveFactorMantissa = reserveFactorMantissa;     reserveFactorMantissa = newReserveFactorMantissa;     emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa); }  function addReserves(uint addAmount) external override nonReentrant {     accrueInterest();     uint totalReservesNew;     uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);     totalReservesNew = totalReserves.add(actualAddAmount);     totalReserves = totalReservesNew;     emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew); }  function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {     accrueInterest();     uint totalReservesNew;     totalReservesNew = totalReserves.sub(reduceAmount);     totalReserves = totalReservesNew;     doTransferOut(to, reduceAmount, true);     emit ReservesReduced(to, reduceAmount, totalReservesNew); }  modifier sameBlock() {     require(accrualBlockNumber == getBlockNumber(), 'not same block');     _; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-24-08 19:28:15 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;


import "./LPoolInterface.sol";
import "./LPoolDepositor.sol";
import "../lib/Exponential.sol";
import "../Adminable.sol";
import "../lib/CarefulMath.sol";
import "../lib/TransferHelper.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import "../DelegateInterface.sol";
import "../ControllerInterface.sol";
import "../IWETH.sol";

/// @title OpenLeverage's LToken Contract
/// @dev Abstract base for LTokens
/// @author OpenLeverage
contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {
    using TransferHelper for IERC20;
    using SafeMath for uint;

    constructor() {

    }
    
    /// @notice Initialize the money market
    /// @param controller_ The address of the Controller
    /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0
    /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate
    /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point
    /// @param kink_ The utilization point at which the jump multiplier is applied
    /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
    /// @param name_ EIP-20 name of this token
    /// @param symbol_ EIP-20 symbol of this token
    /// @param decimals_ EIP-20 decimal precision of this token
    function initialize(
        address underlying_,
        bool isWethPool_,
        address controller_,
        uint256 baseRatePerBlock_,
        uint256 multiplierPerBlock_,
        uint256 jumpMultiplierPerBlock_,
        uint256 kink_,
        uint initialExchangeRateMantissa_,
        string memory name_,
        string memory symbol_,
        uint8 decimals_) public {
        require(underlying_ != address(0), "underlying_ address cannot be 0");
        require(controller_ != address(0), "controller_ address cannot be 0");
        require(msg.sender == admin, "Only allow to be called by admin");
        require(accrualBlockNumber == 0 && borrowIndex == 0, "inited once");

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial Exchange Rate Mantissa should be greater zero");
        //set controller
        controller = controller_;
        isWethPool = isWethPool_;
        //set interestRateModel
        baseRatePerBlock = baseRatePerBlock_;
        multiplierPerBlock = multiplierPerBlock_;
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        kink = kink_;

        // Initialize block number and borrow index (block number mocks depend on controller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = 1e25;
        //80%
        borrowCapFactorMantissa = 0.8e18;
        //10%
        reserveFactorMantissa = 0.1e18;


        name = name_;
        symbol = symbol_;
        decimals = decimals_;

        _notEntered = true;

        // Set underlying and sanity check it
        underlying = underlying_;
        IERC20(underlying).totalSupply();
        emit Transfer(address(0), msg.sender, 0);
    }

    /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
    /// @dev Called by both `transfer` and `transferFrom` internally
    /// @param spender The address of the account performing the transfer
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param tokens The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {
        require(dst != address(0), "dst address cannot be 0");
        /* Do not allow self-transfers */
        require(src != dst, "src = dst");
        /* Fail if transfer not allowed */
        (ControllerInterface(controller)).transferAllowed(src, dst, tokens);

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(- 1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        require(mathErr == MathError.NO_ERROR, 'not allowed');

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        require(mathErr == MathError.NO_ERROR, 'not enough');

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        require(mathErr == MathError.NO_ERROR, 'too much');

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(- 1)) {
            transferAllowances[src][spender] = allowanceNew;
        }
        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);
        return true;
    }

    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount);
    }

    /// @notice Transfer `amount` tokens from `src` to `dst`
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount);
    }

    /// @notice Approve `spender` to transfer up to `amount` from `src`
    /// @dev This will overwrite the approval amount for `spender`
    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
    /// @param spender The address of the account which may transfer tokens
    /// @param amount The number of tokens that are approved (-1 means infinite)
    /// @return Whether or not the approval succeeded
    function approve(address spender, uint256 amount) external override returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /// @notice Get the current allowance from `owner` for `spender`
    /// @param owner The address of the account which owns the tokens to be spent
    /// @param spender The address of the account which may transfer tokens
    /// @return The number of tokens allowed to be spent (-1 means infinite)
    function allowance(address owner, address spender) external override view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /// @notice Get the token balance of the `owner`
    /// @param owner The address of the account to query
    /// @return The number of tokens owned by `owner`
    function balanceOf(address owner) external override view returns (uint256) {
        return accountTokens[owner];
    }

    /// @notice Get the underlying balance of the `owner`
    /// @dev This also accrues interest in a transaction
    /// @param owner The address of the account to query
    /// @return The amount of underlying owned by `owner`
    function balanceOfUnderlying(address owner) external override returns (uint) {
        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR, "calc failed");
        return balance;
    }

    /*** User Interface ***/

    /// @notice Sender supplies assets into the market and receives lTokens in exchange
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param mintAmount The amount of the underlying asset to supply
    function mint(uint mintAmount) external override nonReentrant {
        accrueInterest();
        mintFresh(msg.sender, mintAmount, false);
    }

    function mintTo(address to, uint amount) external payable override nonReentrant {
        accrueInterest();
        if (isWethPool) {
            mintFresh(to, msg.value, false);
        } else {
            mintFresh(to, amount, true);
        }
    }

    function mintEth() external payable override nonReentrant {
        require(isWethPool, "not eth pool");
        accrueInterest();
        mintFresh(msg.sender, msg.value, false);
    }

    /// @notice Sender redeems lTokens in exchange for the underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemTokens The number of lTokens to redeem into underlying
    function redeem(uint redeemTokens) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, redeemTokens, 0);
    }

    /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemAmount The amount of underlying to redeem
    function redeemUnderlying(uint redeemAmount) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, 0, redeemAmount);
    }

    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {
        accrueInterest();
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        borrowFresh(payable(borrower), msg.sender, borrowAmount);
    }

    /// @notice Sender repays a borrow belonging to borrower
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount The amount to repay
    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        repayBorrowFresh(msg.sender, borrower, repayAmount, false);
    }

    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        repayBorrowFresh(msg.sender, borrower, repayAmount, true);
    }


    /*** Safe Token ***/

    /// Gets balance of this contract in terms of the underlying
    /// @dev This excludes the value of the current message, if any
    /// @return The quantity of underlying tokens owned by this contract
    function getCashPrior() internal view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }


    /**
     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.
     *      This will revert due to insufficient balance or insufficient allowance.
     *      This function returns the actual amount received,
     *      which may be less than `amount` if there is a fee attached to the transfer.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {
        if (isWethPool && convertWeth) {
            actualAmount = msg.value;
            IWETH(underlying).deposit{value : actualAmount}();
        } else {
            actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);
        }
    }

    /**
     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory
     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to
     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified
     *      it is >= amount, this should not revert in normal conditions.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {
        if (isWethPool && convertWeth) {
            IWETH(underlying).withdraw(amount);
            to.transfer(amount);
        } else {
            IERC20(underlying).safeTransfer(to, amount);
        }
    }

    function availableForBorrow() external view override returns (uint){
        uint cash = getCashPrior();
        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);
        if (err0 != MathError.NO_ERROR) {
            return 0;
        }
        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);
        if (err1 != MathError.NO_ERROR) {
            return 0;
        }
        if (totalBorrows > maxAvailable) {
            return 0;
        }
        return maxAvailable - totalBorrows;
    }


    /// @notice Get a snapshot of the account's balances, and the cached exchange rate
    /// @dev This is used by controller to more efficiently perform liquidity checks.
    /// @param account Address of the account to snapshot
    /// @return ( token balance, borrow balance, exchange rate mantissa)
    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        return (cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /// @dev Function to simply retrieve block number
    ///  This exists mainly for inheriting test contracts to stub this result.
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /// @notice Returns the current per-block borrow interest rate for this cToken
    /// @return The borrow interest rate per block, scaled by 1e18
    function borrowRatePerBlock() external override view returns (uint) {
        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
    }

    
    /// @notice Returns the current per-block supply interest rate for this cToken
    /// @return The supply interest rate per block, scaled by 1e18
    function supplyRatePerBlock() external override view returns (uint) {
        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);
    }

    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {
        // Utilization rate is 0 when there are no borrows
        if (borrows == 0) {
            return 0;
        }
        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));
    }

    /// @notice Calculates the current borrow rate per block, with the error code expected by the market
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18)
    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {
        uint util = utilizationRate(cash, borrows, reserves);
        if (util <= kink) {
            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
        } else {
            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
            uint excessUtil = util.sub(kink);
            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);
        }
    }

    /// @notice Calculates the current supply rate per block
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The supply rate percentage per block as a mantissa (scaled by 1e18)
    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {
        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);
        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);
        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);
        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);
    }

    /// @notice Returns the current total borrows plus accrued interest
    /// @return The total borrows with interest
    function totalBorrowsCurrent() external override view returns (uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return totalBorrows;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        return totalBorrowsNew;
    }

    /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
    /// @param account The address whose balance should be calculated after updating borrowIndex
    /// @return The calculated balance
    function borrowBalanceCurrent(address account) external view override returns (uint) {
        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();
        require(err0 == MathError.NO_ERROR, "calc borrow index fail");
        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
        require(err1 == MathError.NO_ERROR, "calc fail");
        return result;
    }

    function borrowBalanceStored(address account) external override view returns (uint){
        return accountBorrows[account].principal;
    }


    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
    }

    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /// @notice Accrue interest then return the up-to-date exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateCurrent() public override nonReentrant returns (uint) {
        accrueInterest();
        return exchangeRateStored();
    }

    /// Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateStored() public override view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "calc fail");
        return result;
    }

    /// @notice Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return (error code, calculated exchange rate scaled by 1e18)
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        uint _totalSupply = totalSupply;
        if (_totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint _totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /// @notice Get cash balance of this cToken in the underlying asset
    /// @return The quantity of underlying asset owned by this contract
    function getCash() external override view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }

    function calCurrentBorrowIndex() internal view returns (MathError, uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;
        uint borrowIndexNew;
        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return (MathError.NO_ERROR, borrowIndex);
        }
        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);

        Exp memory simpleInterestFactor;
        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }
        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);
        return (mathErr, borrowIndexNew);
    }

    /// @notice Applies accrued interest to total borrows and reserves
    /// @dev This calculates interest accrued from the last checkpointed block
    ///   up to the current block and writes new checkpoint to storage.
    function accrueInterest() public override {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint borrowIndexPrior = borrowIndex;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");


        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;
        uint borrowIndexNew;
        uint totalReservesNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total reserves error');

        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);
        require(mathErr == MathError.NO_ERROR, 'calc borrows index error');


        /* We write the previously calculated values into storage */
        accrualBlockNumber = currentBlockNumber;
        borrowIndex = borrowIndexNew;
        totalBorrows = totalBorrowsNew;
        totalReserves = totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);

    }

    struct MintLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
        uint actualMintAmount;
    }

    /// @notice User supplies assets into the market and receives lTokens in exchange
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param minter The address of the account which is supplying the assets
    /// @param mintAmount The amount of the underlying asset to supply
    /// @return uint the actual mint amount.
    function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {
        MintLocalVars memory vars;
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /*
         *  We call `doTransferIn` for the minter and the mintAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if
         *  side-effects occurred. The function returns the amount actually transferred,
         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`
         *  of cash.
         */
        if (isDelegete) {
            uint balanceBefore = getCashPrior();
            LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);
            uint balanceAfter = getCashPrior();
            require(balanceAfter > balanceBefore, 'mint 0');
            vars.actualMintAmount = balanceAfter - balanceBefore;
        } else {
            vars.actualMintAmount = doTransferIn(minter, mintAmount, true);
        }
        /*
         * We get the current exchange rate and calculate the number of lTokens to be minted:
         *  mintTokens = actualMintAmount / exchangeRate
         */

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));
        require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");

        /* Fail if mint not allowed */
        (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);
        /*
         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */

        return vars.actualMintAmount;
    }


    struct RedeemLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /// @notice User redeems lTokens in exchange for the underlying asset
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param redeemer The address of the account which is redeeming the tokens
    /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');
            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');
        require(getCashPrior() >= vars.redeemAmount, 'cash < redeem');

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;
        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(redeemer, vars.redeemAmount, true);


        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
    }

    struct BorrowLocalVars {
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /// @notice Users borrow assets from the protocol to their own address
    /// @param borrowAmount The amount of the underlying asset to borrow
    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {
        /* Fail if borrow not allowed */
        (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);

        /* Fail gracefully if protocol has insufficient underlying cash */
        require(getCashPrior() >= borrowAmount, 'cash<borrow');

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(payee, borrowAmount, false);

        /* We emit a Borrow event */
        emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
    }

    struct RepayBorrowLocalVars {
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
        uint actualRepayAmount;
        uint badDebtsAmount;
    }

    /// @notice Borrows are repaid by another user (possibly the borrower).
    /// @param payer the account paying off the borrow
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount the amount of undelrying tokens being returned
    function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {
        /* Fail if repayBorrow not allowed */
        (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(- 1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }
        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);


        if (isEnd && vars.accountBorrows > vars.actualRepayAmount) {
            vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;
        }

        /*
        *  We calculate the new borrower and total borrow balances, failing on underflow:
        *  accountBorrowsNew = accountBorrows - repayAmount
        *  totalBorrowsNew = totalBorrows - repayAmount
        */
        if (vars.accountBorrows < vars.actualRepayAmount) {
            require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) <= 105e16, 'repay more than 5%');
            vars.accountBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.accountBorrowsNew = 0;
            } else {
                vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;
            }
        }
        //Avoid mantissa errors
        if (vars.actualRepayAmount > totalBorrows) {
            vars.totalBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);
            } else {
                vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;
            }
        }

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */

        return vars.actualRepayAmount;
    }

    /*** Admin Functions ***/

    /// @notice Sets a new CONTROLLER for the market
    /// @dev Admin function to set a new controller
    function setController(address newController) external override onlyAdmin {
        require(address(0) != newController, "0x");
        address oldController = controller;
        controller = newController;
        // Emit NewController(oldController, newController)
        emit NewController(oldController, newController);
    }

    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {
        require(newBorrowCapFactorMantissa <= 1e18, 'Factor too large');
        uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;
        borrowCapFactorMantissa = newBorrowCapFactorMantissa;
        emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa);
    }

    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {
        //accrueInterest except first
        if (baseRatePerBlock != 0) {
            accrueInterest();
        }
        // total rate perYear < 2000%
        require(baseRatePerBlock_ < 1e13, 'Base rate too large');
        baseRatePerBlock = baseRatePerBlock_;
        require(multiplierPerBlock_ < 1e13, 'Mul rate too large');
        multiplierPerBlock = multiplierPerBlock_;
        require(jumpMultiplierPerBlock_ < 1e13, 'Jump rate too large');
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        require(kink_ <= 1e18, 'Kline too large');
        kink = kink_;
        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);
    }

    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {
        require(newReserveFactorMantissa <= 1e18, 'Factor too large');
        accrueInterest();
        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;
        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);
    }

    function addReserves(uint addAmount) external override nonReentrant {
        accrueInterest();
        uint totalReservesNew;
        uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);
        totalReservesNew = totalReserves.add(actualAddAmount);
        totalReserves = totalReservesNew;
        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);
    }

    function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {
        accrueInterest();
        uint totalReservesNew;
        totalReservesNew = totalReserves.sub(reduceAmount);
        totalReserves = totalReservesNew;
        doTransferOut(to, reduceAmount, true);
        emit ReservesReduced(to, reduceAmount, totalReservesNew);
    }

    modifier sameBlock() {
        require(accrualBlockNumber == getBlockNumber(), 'not same block');
        _;
    }
}

.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;


import "./LPoolInterface.sol";
import "./LPoolDepositor.sol";
import "../lib/Exponential.sol";
import "../Adminable.sol";
import "../lib/CarefulMath.sol";
import "../lib/TransferHelper.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import "../DelegateInterface.sol";
import "../ControllerInterface.sol";
import "../IWETH.sol";

/// @title OpenLeverage's LToken Contract
/// @dev Abstract base for LTokens
/// @author OpenLeverage
contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {
    using TransferHelper for IERC20;
    using SafeMath for uint;

    constructor() {

    }
    
    /// @notice Initialize the money market
    /// @param controller_ The address of the Controller
    /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0
    /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate
    /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point
    /// @param kink_ The utilization point at which the jump multiplier is applied
    /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
    /// @param name_ EIP-20 name of this token
    /// @param symbol_ EIP-20 symbol of this token
    /// @param decimals_ EIP-20 decimal precision of this token
    function initialize(
        address underlying_,
        bool isWethPool_,
        address controller_,
        uint256 baseRatePerBlock_,
        uint256 multiplierPerBlock_,
        uint256 jumpMultiplierPerBlock_,
        uint256 kink_,
        uint initialExchangeRateMantissa_,
        string memory name_,
        string memory symbol_,
        uint8 decimals_) public {
        require(underlying_ != address(0), "underlying_ address cannot be 0");
        require(controller_ != address(0), "controller_ address cannot be 0");
        require(msg.sender == admin, "Only allow to be called by admin");
        require(accrualBlockNumber == 0 && borrowIndex == 0, "inited once");

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial Exchange Rate Mantissa should be greater zero");
        //set controller
        controller = controller_;
        isWethPool = isWethPool_;
        //set interestRateModel
        baseRatePerBlock = baseRatePerBlock_;
        multiplierPerBlock = multiplierPerBlock_;
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        kink = kink_;

        // Initialize block number and borrow index (block number mocks depend on controller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = 1e25;
        //80%
        borrowCapFactorMantissa = 0.8e18;
        //10%
        reserveFactorMantissa = 0.1e18;


        name = name_;
        symbol = symbol_;
        decimals = decimals_;

        _notEntered = true;

        // Set underlying and sanity check it
        underlying = underlying_;
        IERC20(underlying).totalSupply();
        emit Transfer(address(0), msg.sender, 0);
    }

    /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
    /// @dev Called by both `transfer` and `transferFrom` internally
    /// @param spender The address of the account performing the transfer
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param tokens The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {
        require(dst != address(0), "dst address cannot be 0");
        /* Do not allow self-transfers */
        require(src != dst, "src = dst");
        /* Fail if transfer not allowed */
        (ControllerInterface(controller)).transferAllowed(src, dst, tokens);

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(- 1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        require(mathErr == MathError.NO_ERROR, 'not allowed');

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        require(mathErr == MathError.NO_ERROR, 'not enough');

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        require(mathErr == MathError.NO_ERROR, 'too much');

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(- 1)) {
            transferAllowances[src][spender] = allowanceNew;
        }
        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);
        return true;
    }

    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount);
    }

    /// @notice Transfer `amount` tokens from `src` to `dst`
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount);
    }

    /// @notice Approve `spender` to transfer up to `amount` from `src`
    /// @dev This will overwrite the approval amount for `spender`
    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
    /// @param spender The address of the account which may transfer tokens
    /// @param amount The number of tokens that are approved (-1 means infinite)
    /// @return Whether or not the approval succeeded
    function approve(address spender, uint256 amount) external override returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /// @notice Get the current allowance from `owner` for `spender`
    /// @param owner The address of the account which owns the tokens to be spent
    /// @param spender The address of the account which may transfer tokens
    /// @return The number of tokens allowed to be spent (-1 means infinite)
    function allowance(address owner, address spender) external override view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /// @notice Get the token balance of the `owner`
    /// @param owner The address of the account to query
    /// @return The number of tokens owned by `owner`
    function balanceOf(address owner) external override view returns (uint256) {
        return accountTokens[owner];
    }

    /// @notice Get the underlying balance of the `owner`
    /// @dev This also accrues interest in a transaction
    /// @param owner The address of the account to query
    /// @return The amount of underlying owned by `owner`
    function balanceOfUnderlying(address owner) external override returns (uint) {
        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR, "calc failed");
        return balance;
    }

    /*** User Interface ***/

    /// @notice Sender supplies assets into the market and receives lTokens in exchange
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param mintAmount The amount of the underlying asset to supply
    function mint(uint mintAmount) external override nonReentrant {
        accrueInterest();
        mintFresh(msg.sender, mintAmount, false);
    }

    function mintTo(address to, uint amount) external payable override nonReentrant {
        accrueInterest();
        if (isWethPool) {
            mintFresh(to, msg.value, false);
        } else {
            mintFresh(to, amount, true);
        }
    }

    function mintEth() external payable override nonReentrant {
        require(isWethPool, "not eth pool");
        accrueInterest();
        mintFresh(msg.sender, msg.value, false);
    }

    /// @notice Sender redeems lTokens in exchange for the underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemTokens The number of lTokens to redeem into underlying
    function redeem(uint redeemTokens) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, redeemTokens, 0);
    }

    /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemAmount The amount of underlying to redeem
    function redeemUnderlying(uint redeemAmount) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, 0, redeemAmount);
    }

    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {
        accrueInterest();
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        borrowFresh(payable(borrower), msg.sender, borrowAmount);
    }

    /// @notice Sender repays a borrow belonging to borrower
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount The amount to repay
    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        repayBorrowFresh(msg.sender, borrower, repayAmount, false);
    }

    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        repayBorrowFresh(msg.sender, borrower, repayAmount, true);
    }


    /*** Safe Token ***/

    /// Gets balance of this contract in terms of the underlying
    /// @dev This excludes the value of the current message, if any
    /// @return The quantity of underlying tokens owned by this contract
    function getCashPrior() internal view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }


    /**
     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.
     *      This will revert due to insufficient balance or insufficient allowance.
     *      This function returns the actual amount received,
     *      which may be less than `amount` if there is a fee attached to the transfer.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {
        if (isWethPool && convertWeth) {
            actualAmount = msg.value;
            IWETH(underlying).deposit{value : actualAmount}();
        } else {
            actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);
        }
    }

    /**
     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory
     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to
     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified
     *      it is >= amount, this should not revert in normal conditions.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {
        if (isWethPool && convertWeth) {
            IWETH(underlying).withdraw(amount);
            to.transfer(amount);
        } else {
            IERC20(underlying).safeTransfer(to, amount);
        }
    }

    function availableForBorrow() external view override returns (uint){
        uint cash = getCashPrior();
        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);
        if (err0 != MathError.NO_ERROR) {
            return 0;
        }
        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);
        if (err1 != MathError.NO_ERROR) {
            return 0;
        }
        if (totalBorrows > maxAvailable) {
            return 0;
        }
        return maxAvailable - totalBorrows;
    }


    /// @notice Get a snapshot of the account's balances, and the cached exchange rate
    /// @dev This is used by controller to more efficiently perform liquidity checks.
    /// @param account Address of the account to snapshot
    /// @return ( token balance, borrow balance, exchange rate mantissa)
    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        return (cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /// @dev Function to simply retrieve block number
    ///  This exists mainly for inheriting test contracts to stub this result.
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /// @notice Returns the current per-block borrow interest rate for this cToken
    /// @return The borrow interest rate per block, scaled by 1e18
    function borrowRatePerBlock() external override view returns (uint) {
        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
    }

    
    /// @notice Returns the current per-block supply interest rate for this cToken
    /// @return The supply interest rate per block, scaled by 1e18
    function supplyRatePerBlock() external override view returns (uint) {
        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);
    }

    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {
        // Utilization rate is 0 when there are no borrows
        if (borrows == 0) {
            return 0;
        }
        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));
    }

    /// @notice Calculates the current borrow rate per block, with the error code expected by the market
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18)
    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {
        uint util = utilizationRate(cash, borrows, reserves);
        if (util <= kink) {
            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
        } else {
            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
            uint excessUtil = util.sub(kink);
            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);
        }
    }

    /// @notice Calculates the current supply rate per block
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The supply rate percentage per block as a mantissa (scaled by 1e18)
    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {
        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);
        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);
        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);
        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);
    }

    /// @notice Returns the current total borrows plus accrued interest
    /// @return The total borrows with interest
    function totalBorrowsCurrent() external override view returns (uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return totalBorrows;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        return totalBorrowsNew;
    }

    /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
    /// @param account The address whose balance should be calculated after updating borrowIndex
    /// @return The calculated balance
    function borrowBalanceCurrent(address account) external view override returns (uint) {
        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();
        require(err0 == MathError.NO_ERROR, "calc borrow index fail");
        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
        require(err1 == MathError.NO_ERROR, "calc fail");
        return result;
    }

    function borrowBalanceStored(address account) external override view returns (uint){
        return accountBorrows[account].principal;
    }


    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
    }

    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /// @notice Accrue interest then return the up-to-date exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateCurrent() public override nonReentrant returns (uint) {
        accrueInterest();
        return exchangeRateStored();
    }

    /// Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateStored() public override view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "calc fail");
        return result;
    }

    /// @notice Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return (error code, calculated exchange rate scaled by 1e18)
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        uint _totalSupply = totalSupply;
        if (_totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint _totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /// @notice Get cash balance of this cToken in the underlying asset
    /// @return The quantity of underlying asset owned by this contract
    function getCash() external override view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }

    function calCurrentBorrowIndex() internal view returns (MathError, uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;
        uint borrowIndexNew;
        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return (MathError.NO_ERROR, borrowIndex);
        }
        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);

        Exp memory simpleInterestFactor;
        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }
        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);
        return (mathErr, borrowIndexNew);
    }

    /// @notice Applies accrued interest to total borrows and reserves
    /// @dev This calculates interest accrued from the last checkpointed block
    ///   up to the current block and writes new checkpoint to storage.
    function accrueInterest() public override {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint borrowIndexPrior = borrowIndex;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");


        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;
        uint borrowIndexNew;
        uint totalReservesNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total reserves error');

        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);
        require(mathErr == MathError.NO_ERROR, 'calc borrows index error');


        /* We write the previously calculated values into storage */
        accrualBlockNumber = currentBlockNumber;
        borrowIndex = borrowIndexNew;
        totalBorrows = totalBorrowsNew;
        totalReserves = totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);

    }

    struct MintLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
        uint actualMintAmount;
    }

    /// @notice User supplies assets into the market and receives lTokens in exchange
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param minter The address of the account which is supplying the assets
    /// @param mintAmount The amount of the underlying asset to supply
    /// @return uint the actual mint amount.
    function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {
        MintLocalVars memory vars;
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /*
         *  We call `doTransferIn` for the minter and the mintAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if
         *  side-effects occurred. The function returns the amount actually transferred,
         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`
         *  of cash.
         */
        if (isDelegete) {
            uint balanceBefore = getCashPrior();
            LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);
            uint balanceAfter = getCashPrior();
            require(balanceAfter > balanceBefore, 'mint 0');
            vars.actualMintAmount = balanceAfter - balanceBefore;
        } else {
            vars.actualMintAmount = doTransferIn(minter, mintAmount, true);
        }
        /*
         * We get the current exchange rate and calculate the number of lTokens to be minted:
         *  mintTokens = actualMintAmount / exchangeRate
         */

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));
        require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");

        /* Fail if mint not allowed */
        (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);
        /*
         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */

        return vars.actualMintAmount;
    }


    struct RedeemLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /// @notice User redeems lTokens in exchange for the underlying asset
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param redeemer The address of the account which is redeeming the tokens
    /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');
            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');
        require(getCashPrior() >= vars.redeemAmount, 'cash < redeem');

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;
        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(redeemer, vars.redeemAmount, true);


        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
    }

    struct BorrowLocalVars {
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /// @notice Users borrow assets from the protocol to their own address
    /// @param borrowAmount The amount of the underlying asset to borrow
    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {
        /* Fail if borrow not allowed */
        (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);

        /* Fail gracefully if protocol has insufficient underlying cash */
        require(getCashPrior() >= borrowAmount, 'cash<borrow');

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(payee, borrowAmount, false);

        /* We emit a Borrow event */
        emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
    }

    struct RepayBorrowLocalVars {
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
        uint actualRepayAmount;
        uint badDebtsAmount;
    }

    /// @notice Borrows are repaid by another user (possibly the borrower).
    /// @param payer the account paying off the borrow
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount the amount of undelrying tokens being returned
    function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {
        /* Fail if repayBorrow not allowed */
        (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(- 1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }
        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);


        if (isEnd && vars.accountBorrows > vars.actualRepayAmount) {
            vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;
        }

        /*
        *  We calculate the new borrower and total borrow balances, failing on underflow:
        *  accountBorrowsNew = accountBorrows - repayAmount
        *  totalBorrowsNew = totalBorrows - repayAmount
        */
        if (vars.accountBorrows < vars.actualRepayAmount) {
            require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) <= 105e16, 'repay more than 5%');
            vars.accountBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.accountBorrowsNew = 0;
            } else {
                vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;
            }
        }
        //Avoid mantissa errors
        if (vars.actualRepayAmount > totalBorrows) {
            vars.totalBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);
            } else {
                vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;
            }
        }

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */

        return vars.actualRepayAmount;
    }

    /*** Admin Functions ***/

    /// @notice Sets a new CONTROLLER for the market
    /// @dev Admin function to set a new controller
    function setController(address newController) external override onlyAdmin {
        require(address(0) != newController, "0x");
        address oldController = controller;
        controller = newController;
        // Emit NewController(oldController, newController)
        emit NewController(oldController, newController);
    }

    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {
        require(newBorrowCapFactorMantissa <= 1e18, 'Factor too large');
        uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;
        borrowCapFactorMantissa = newBorrowCapFactorMantissa;
        emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa);
    }

    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {
        //accrueInterest except first
        if (baseRatePerBlock != 0) {
            accrueInterest();
        }
        // total rate perYear < 2000%
        require(baseRatePerBlock_ < 1e13, 'Base rate too large');
        baseRatePerBlock = baseRatePerBlock_;
        require(multiplierPerBlock_ < 1e13, 'Mul rate too large');
        multiplierPerBlock = multiplierPerBlock_;
        require(jumpMultiplierPerBlock_ < 1e13, 'Jump rate too large');
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        require(kink_ <= 1e18, 'Kline too large');
        kink = kink_;
        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);
    }

    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {
        require(newReserveFactorMantissa <= 1e18, 'Factor too large');
        accrueInterest();
        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;
        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);
    }

    function addReserves(uint addAmount) external override nonReentrant {
        accrueInterest();
        uint totalReservesNew;
        uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);
        totalReservesNew = totalReserves.add(actualAddAmount);
        totalReserves = totalReservesNew;
        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);
    }

    function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {
        accrueInterest();
        uint totalReservesNew;
        totalReservesNew = totalReserves.sub(reduceAmount);
        totalReserves = totalReservesNew;
        doTransferOut(to, reduceAmount, true);
        emit ReservesReduced(to, reduceAmount, totalReservesNew);
    }

    modifier sameBlock() {
        require(accrualBlockNumber == getBlockNumber(), 'not same block');
        _;
    }
}

".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-24-08 19:28:18 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-24-08 19:28:18 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 19883
completion_tokens: 1
total_tokens: 19884
cost: $-1.000000


[2024-24-08 19:28:18 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;


import "./LPoolInterface.sol";
import "./LPoolDepositor.sol";
import "../lib/Exponential.sol";
import "../Adminable.sol";
import "../lib/CarefulMath.sol";
import "../lib/TransferHelper.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import "../DelegateInterface.sol";
import "../ControllerInterface.sol";
import "../IWETH.sol";

/// @title OpenLeverage's LToken Contract
/// @dev Abstract base for LTokens
/// @author OpenLeverage
contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {
    using TransferHelper for IERC20;
    using SafeMath for uint;

    constructor() {

    }
    
    /// @notice Initialize the money market
    /// @param controller_ The address of the Controller
    /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0
    /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate
    /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point
    /// @param kink_ The utilization point at which the jump multiplier is applied
    /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
    /// @param name_ EIP-20 name of this token
    /// @param symbol_ EIP-20 symbol of this token
    /// @param decimals_ EIP-20 decimal precision of this token
    function initialize(
        address underlying_,
        bool isWethPool_,
        address controller_,
        uint256 baseRatePerBlock_,
        uint256 multiplierPerBlock_,
        uint256 jumpMultiplierPerBlock_,
        uint256 kink_,
        uint initialExchangeRateMantissa_,
        string memory name_,
        string memory symbol_,
        uint8 decimals_) public {
        require(underlying_ != address(0), "underlying_ address cannot be 0");
        require(controller_ != address(0), "controller_ address cannot be 0");
        require(msg.sender == admin, "Only allow to be called by admin");
        require(accrualBlockNumber == 0 && borrowIndex == 0, "inited once");

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial Exchange Rate Mantissa should be greater zero");
        //set controller
        controller = controller_;
        isWethPool = isWethPool_;
        //set interestRateModel
        baseRatePerBlock = baseRatePerBlock_;
        multiplierPerBlock = multiplierPerBlock_;
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        kink = kink_;

        // Initialize block number and borrow index (block number mocks depend on controller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = 1e25;
        //80%
        borrowCapFactorMantissa = 0.8e18;
        //10%
        reserveFactorMantissa = 0.1e18;


        name = name_;
        symbol = symbol_;
        decimals = decimals_;

        _notEntered = true;

        // Set underlying and sanity check it
        underlying = underlying_;
        IERC20(underlying).totalSupply();
        emit Transfer(address(0), msg.sender, 0);
    }

    /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
    /// @dev Called by both `transfer` and `transferFrom` internally
    /// @param spender The address of the account performing the transfer
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param tokens The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {
        require(dst != address(0), "dst address cannot be 0");
        /* Do not allow self-transfers */
        require(src != dst, "src = dst");
        /* Fail if transfer not allowed */
        (ControllerInterface(controller)).transferAllowed(src, dst, tokens);

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(- 1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        require(mathErr == MathError.NO_ERROR, 'not allowed');

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        require(mathErr == MathError.NO_ERROR, 'not enough');

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        require(mathErr == MathError.NO_ERROR, 'too much');

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(- 1)) {
            transferAllowances[src][spender] = allowanceNew;
        }
        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);
        return true;
    }

    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount);
    }

    /// @notice Transfer `amount` tokens from `src` to `dst`
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount);
    }

    /// @notice Approve `spender` to transfer up to `amount` from `src`
    /// @dev This will overwrite the approval amount for `spender`
    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
    /// @param spender The address of the account which may transfer tokens
    /// @param amount The number of tokens that are approved (-1 means infinite)
    /// @return Whether or not the approval succeeded
    function approve(address spender, uint256 amount) external override returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /// @notice Get the current allowance from `owner` for `spender`
    /// @param owner The address of the account which owns the tokens to be spent
    /// @param spender The address of the account which may transfer tokens
    /// @return The number of tokens allowed to be spent (-1 means infinite)
    function allowance(address owner, address spender) external override view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /// @notice Get the token balance of the `owner`
    /// @param owner The address of the account to query
    /// @return The number of tokens owned by `owner`
    function balanceOf(address owner) external override view returns (uint256) {
        return accountTokens[owner];
    }

    /// @notice Get the underlying balance of the `owner`
    /// @dev This also accrues interest in a transaction
    /// @param owner The address of the account to query
    /// @return The amount of underlying owned by `owner`
    function balanceOfUnderlying(address owner) external override returns (uint) {
        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR, "calc failed");
        return balance;
    }

    /*** User Interface ***/

    /// @notice Sender supplies assets into the market and receives lTokens in exchange
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param mintAmount The amount of the underlying asset to supply
    function mint(uint mintAmount) external override nonReentrant {
        accrueInterest();
        mintFresh(msg.sender, mintAmount, false);
    }

    function mintTo(address to, uint amount) external payable override nonReentrant {
        accrueInterest();
        if (isWethPool) {
            mintFresh(to, msg.value, false);
        } else {
            mintFresh(to, amount, true);
        }
    }

    function mintEth() external payable override nonReentrant {
        require(isWethPool, "not eth pool");
        accrueInterest();
        mintFresh(msg.sender, msg.value, false);
    }

    /// @notice Sender redeems lTokens in exchange for the underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemTokens The number of lTokens to redeem into underlying
    function redeem(uint redeemTokens) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, redeemTokens, 0);
    }

    /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemAmount The amount of underlying to redeem
    function redeemUnderlying(uint redeemAmount) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, 0, redeemAmount);
    }

    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {
        accrueInterest();
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        borrowFresh(payable(borrower), msg.sender, borrowAmount);
    }

    /// @notice Sender repays a borrow belonging to borrower
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount The amount to repay
    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        repayBorrowFresh(msg.sender, borrower, repayAmount, false);
    }

    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        repayBorrowFresh(msg.sender, borrower, repayAmount, true);
    }


    /*** Safe Token ***/

    /// Gets balance of this contract in terms of the underlying
    /// @dev This excludes the value of the current message, if any
    /// @return The quantity of underlying tokens owned by this contract
    function getCashPrior() internal view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }


    /**
     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.
     *      This will revert due to insufficient balance or insufficient allowance.
     *      This function returns the actual amount received,
     *      which may be less than `amount` if there is a fee attached to the transfer.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {
        if (isWethPool && convertWeth) {
            actualAmount = msg.value;
            IWETH(underlying).deposit{value : actualAmount}();
        } else {
            actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);
        }
    }

    /**
     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory
     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to
     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified
     *      it is >= amount, this should not revert in normal conditions.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {
        if (isWethPool && convertWeth) {
            IWETH(underlying).withdraw(amount);
            to.transfer(amount);
        } else {
            IERC20(underlying).safeTransfer(to, amount);
        }
    }

    function availableForBorrow() external view override returns (uint){
        uint cash = getCashPrior();
        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);
        if (err0 != MathError.NO_ERROR) {
            return 0;
        }
        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);
        if (err1 != MathError.NO_ERROR) {
            return 0;
        }
        if (totalBorrows > maxAvailable) {
            return 0;
        }
        return maxAvailable - totalBorrows;
    }


    /// @notice Get a snapshot of the account's balances, and the cached exchange rate
    /// @dev This is used by controller to more efficiently perform liquidity checks.
    /// @param account Address of the account to snapshot
    /// @return ( token balance, borrow balance, exchange rate mantissa)
    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        return (cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /// @dev Function to simply retrieve block number
    ///  This exists mainly for inheriting test contracts to stub this result.
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /// @notice Returns the current per-block borrow interest rate for this cToken
    /// @return The borrow interest rate per block, scaled by 1e18
    function borrowRatePerBlock() external override view returns (uint) {
        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
    }

    
    /// @notice Returns the current per-block supply interest rate for this cToken
    /// @return The supply interest rate per block, scaled by 1e18
    function supplyRatePerBlock() external override view returns (uint) {
        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);
    }

    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {
        // Utilization rate is 0 when there are no borrows
        if (borrows == 0) {
            return 0;
        }
        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));
    }

    /// @notice Calculates the current borrow rate per block, with the error code expected by the market
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18)
    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {
        uint util = utilizationRate(cash, borrows, reserves);
        if (util <= kink) {
            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
        } else {
            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
            uint excessUtil = util.sub(kink);
            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);
        }
    }

    /// @notice Calculates the current supply rate per block
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The supply rate percentage per block as a mantissa (scaled by 1e18)
    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {
        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);
        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);
        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);
        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);
    }

    /// @notice Returns the current total borrows plus accrued interest
    /// @return The total borrows with interest
    function totalBorrowsCurrent() external override view returns (uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return totalBorrows;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        return totalBorrowsNew;
    }

    /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
    /// @param account The address whose balance should be calculated after updating borrowIndex
    /// @return The calculated balance
    function borrowBalanceCurrent(address account) external view override returns (uint) {
        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();
        require(err0 == MathError.NO_ERROR, "calc borrow index fail");
        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
        require(err1 == MathError.NO_ERROR, "calc fail");
        return result;
    }

    function borrowBalanceStored(address account) external override view returns (uint){
        return accountBorrows[account].principal;
    }


    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
    }

    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /// @notice Accrue interest then return the up-to-date exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateCurrent() public override nonReentrant returns (uint) {
        accrueInterest();
        return exchangeRateStored();
    }

    /// Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateStored() public override view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "calc fail");
        return result;
    }

    /// @notice Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return (error code, calculated exchange rate scaled by 1e18)
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        uint _totalSupply = totalSupply;
        if (_totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint _totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /// @notice Get cash balance of this cToken in the underlying asset
    /// @return The quantity of underlying asset owned by this contract
    function getCash() external override view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }

    function calCurrentBorrowIndex() internal view returns (MathError, uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;
        uint borrowIndexNew;
        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return (MathError.NO_ERROR, borrowIndex);
        }
        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);

        Exp memory simpleInterestFactor;
        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }
        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);
        return (mathErr, borrowIndexNew);
    }

    /// @notice Applies accrued interest to total borrows and reserves
    /// @dev This calculates interest accrued from the last checkpointed block
    ///   up to the current block and writes new checkpoint to storage.
    function accrueInterest() public override {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint borrowIndexPrior = borrowIndex;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");


        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;
        uint borrowIndexNew;
        uint totalReservesNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total reserves error');

        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);
        require(mathErr == MathError.NO_ERROR, 'calc borrows index error');


        /* We write the previously calculated values into storage */
        accrualBlockNumber = currentBlockNumber;
        borrowIndex = borrowIndexNew;
        totalBorrows = totalBorrowsNew;
        totalReserves = totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);

    }

    struct MintLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
        uint actualMintAmount;
    }

    /// @notice User supplies assets into the market and receives lTokens in exchange
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param minter The address of the account which is supplying the assets
    /// @param mintAmount The amount of the underlying asset to supply
    /// @return uint the actual mint amount.
    function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {
        MintLocalVars memory vars;
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /*
         *  We call `doTransferIn` for the minter and the mintAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if
         *  side-effects occurred. The function returns the amount actually transferred,
         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`
         *  of cash.
         */
        if (isDelegete) {
            uint balanceBefore = getCashPrior();
            LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);
            uint balanceAfter = getCashPrior();
            require(balanceAfter > balanceBefore, 'mint 0');
            vars.actualMintAmount = balanceAfter - balanceBefore;
        } else {
            vars.actualMintAmount = doTransferIn(minter, mintAmount, true);
        }
        /*
         * We get the current exchange rate and calculate the number of lTokens to be minted:
         *  mintTokens = actualMintAmount / exchangeRate
         */

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));
        require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");

        /* Fail if mint not allowed */
        (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);
        /*
         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */

        return vars.actualMintAmount;
    }


    struct RedeemLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /// @notice User redeems lTokens in exchange for the underlying asset
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param redeemer The address of the account which is redeeming the tokens
    /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');
            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');
        require(getCashPrior() >= vars.redeemAmount, 'cash < redeem');

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;
        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(redeemer, vars.redeemAmount, true);


        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
    }

    struct BorrowLocalVars {
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /// @notice Users borrow assets from the protocol to their own address
    /// @param borrowAmount The amount of the underlying asset to borrow
    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {
        /* Fail if borrow not allowed */
        (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);

        /* Fail gracefully if protocol has insufficient underlying cash */
        require(getCashPrior() >= borrowAmount, 'cash<borrow');

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(payee, borrowAmount, false);

        /* We emit a Borrow event */
        emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
    }

    struct RepayBorrowLocalVars {
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
        uint actualRepayAmount;
        uint badDebtsAmount;
    }

    /// @notice Borrows are repaid by another user (possibly the borrower).
    /// @param payer the account paying off the borrow
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount the amount of undelrying tokens being returned
    function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {
        /* Fail if repayBorrow not allowed */
        (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(- 1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }
        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);


        if (isEnd && vars.accountBorrows > vars.actualRepayAmount) {
            vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;
        }

        /*
        *  We calculate the new borrower and total borrow balances, failing on underflow:
        *  accountBorrowsNew = accountBorrows - repayAmount
        *  totalBorrowsNew = totalBorrows - repayAmount
        */
        if (vars.accountBorrows < vars.actualRepayAmount) {
            require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) <= 105e16, 'repay more than 5%');
            vars.accountBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.accountBorrowsNew = 0;
            } else {
                vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;
            }
        }
        //Avoid mantissa errors
        if (vars.actualRepayAmount > totalBorrows) {
            vars.totalBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);
            } else {
                vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;
            }
        }

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */

        return vars.actualRepayAmount;
    }

    /*** Admin Functions ***/

    /// @notice Sets a new CONTROLLER for the market
    /// @dev Admin function to set a new controller
    function setController(address newController) external override onlyAdmin {
        require(address(0) != newController, "0x");
        address oldController = controller;
        controller = newController;
        // Emit NewController(oldController, newController)
        emit NewController(oldController, newController);
    }

    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {
        require(newBorrowCapFactorMantissa <= 1e18, 'Factor too large');
        uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;
        borrowCapFactorMantissa = newBorrowCapFactorMantissa;
        emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa);
    }

    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {
        //accrueInterest except first
        if (baseRatePerBlock != 0) {
            accrueInterest();
        }
        // total rate perYear < 2000%
        require(baseRatePerBlock_ < 1e13, 'Base rate too large');
        baseRatePerBlock = baseRatePerBlock_;
        require(multiplierPerBlock_ < 1e13, 'Mul rate too large');
        multiplierPerBlock = multiplierPerBlock_;
        require(jumpMultiplierPerBlock_ < 1e13, 'Jump rate too large');
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        require(kink_ <= 1e18, 'Kline too large');
        kink = kink_;
        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);
    }

    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {
        require(newReserveFactorMantissa <= 1e18, 'Factor too large');
        accrueInterest();
        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;
        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);
    }

    function addReserves(uint addAmount) external override nonReentrant {
        accrueInterest();
        uint totalReservesNew;
        uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);
        totalReservesNew = totalReserves.add(actualAddAmount);
        totalReserves = totalReservesNew;
        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);
    }

    function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {
        accrueInterest();
        uint totalReservesNew;
        totalReservesNew = totalReserves.sub(reduceAmount);
        totalReserves = totalReservesNew;
        doTransferOut(to, reduceAmount, true);
        emit ReservesReduced(to, reduceAmount, totalReservesNew);
    }

    modifier sameBlock() {
        require(accrualBlockNumber == getBlockNumber(), 'not same block');
        _;
    }
}

.]

###

[2024-24-08 19:28:18 INFO] **[Seminar Conclusion]**:

 ###

[2024-24-08 19:28:18 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-24-08 19:28:18 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.7.6; import "./LPoolInterface.sol"; import "./LPoolDepositor.sol"; import "../lib/Exponential.sol"; import "../Adminable.sol"; import "../lib/CarefulMath.sol"; import "../lib/TransferHelper.sol"; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import "../DelegateInterface.sol"; import "../ControllerInterface.sol"; import "../IWETH.sol"; /// @title OpenLeverage's LToken Contract /// @dev Abstract base for LTokens /// @author OpenLeverage contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {     using TransferHelper for IERC20;     using SafeMath for uint; constructor() {  }  /// @notice Initialize the money market /// @param controller_ The address of the Controller /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0 /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point /// @param kink_ The utilization point at which the jump multiplier is applied /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18 /// @param name_ EIP-20 name of this token /// @param symbol_ EIP-20 symbol of this token /// @param decimals_ EIP-20 decimal precision of this token function initialize(     address underlying_,     bool isWethPool_,     address controller_,     uint256 baseRatePerBlock_,     uint256 multiplierPerBlock_,     uint256 jumpMultiplierPerBlock_,     uint256 kink_,     uint initialExchangeRateMantissa_,     string memory name_,     string memory symbol_,     uint8 decimals_) public {     require(underlying_ != address(0), "underlying_ address cannot be 0");     require(controller_ != address(0), "controller_ address cannot be 0");     require(msg.sender == admin, "Only allow to be called by admin");     require(accrualBlockNumber == 0 &amp;&amp; borrowIndex == 0, "inited once");      // Set initial exchange rate     initialExchangeRateMantissa = initialExchangeRateMantissa_;     require(initialExchangeRateMantissa &gt; 0, "Initial Exchange Rate Mantissa should be greater zero");     //set controller     controller = controller_;     isWethPool = isWethPool_;     //set interestRateModel     baseRatePerBlock = baseRatePerBlock_;     multiplierPerBlock = multiplierPerBlock_;     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     kink = kink_;      // Initialize block number and borrow index (block number mocks depend on controller being set)     accrualBlockNumber = getBlockNumber();     borrowIndex = 1e25;     //80%     borrowCapFactorMantissa = 0.8e18;     //10%     reserveFactorMantissa = 0.1e18;       name = name_;     symbol = symbol_;     decimals = decimals_;      _notEntered = true;      // Set underlying and sanity check it     underlying = underlying_;     IERC20(underlying).totalSupply();     emit Transfer(address(0), msg.sender, 0); }  /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender` /// @dev Called by both `transfer` and `transferFrom` internally /// @param spender The address of the account performing the transfer /// @param src The address of the source account /// @param dst The address of the destination account /// @param tokens The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {     require(dst != address(0), "dst address cannot be 0");     /* Do not allow self-transfers */     require(src != dst, "src = dst");     /* Fail if transfer not allowed */     (ControllerInterface(controller)).transferAllowed(src, dst, tokens);      /* Get the allowance, infinite for the account owner */     uint startingAllowance = 0;     if (spender == src) {         startingAllowance = uint(- 1);     } else {         startingAllowance = transferAllowances[src][spender];     }      /* Do the calculations, checking for {under,over}flow */     MathError mathErr;     uint allowanceNew;     uint srcTokensNew;     uint dstTokensNew;      (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);     require(mathErr == MathError.NO_ERROR, 'not allowed');      (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);     require(mathErr == MathError.NO_ERROR, 'not enough');      (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);     require(mathErr == MathError.NO_ERROR, 'too much');      accountTokens[src] = srcTokensNew;     accountTokens[dst] = dstTokensNew;      /* Eat some of the allowance (if necessary) */     if (startingAllowance != uint(- 1)) {         transferAllowances[src][spender] = allowanceNew;     }     /* We emit a Transfer event */     emit Transfer(src, dst, tokens);     return true; }  /// @notice Transfer `amount` tokens from `msg.sender` to `dst` /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, msg.sender, dst, amount); }  /// @notice Transfer `amount` tokens from `src` to `dst` /// @param src The address of the source account /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, src, dst, amount); }  /// @notice Approve `spender` to transfer up to `amount` from `src` /// @dev This will overwrite the approval amount for `spender` ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve) /// @param spender The address of the account which may transfer tokens /// @param amount The number of tokens that are approved (-1 means infinite) /// @return Whether or not the approval succeeded function approve(address spender, uint256 amount) external override returns (bool) {     address src = msg.sender;     transferAllowances[src][spender] = amount;     emit Approval(src, spender, amount);     return true; }  /// @notice Get the current allowance from `owner` for `spender` /// @param owner The address of the account which owns the tokens to be spent /// @param spender The address of the account which may transfer tokens /// @return The number of tokens allowed to be spent (-1 means infinite) function allowance(address owner, address spender) external override view returns (uint256) {     return transferAllowances[owner][spender]; }  /// @notice Get the token balance of the `owner` /// @param owner The address of the account to query /// @return The number of tokens owned by `owner` function balanceOf(address owner) external override view returns (uint256) {     return accountTokens[owner]; }  /// @notice Get the underlying balance of the `owner` /// @dev This also accrues interest in a transaction /// @param owner The address of the account to query /// @return The amount of underlying owned by `owner` function balanceOfUnderlying(address owner) external override returns (uint) {     Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});     (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);     require(mErr == MathError.NO_ERROR, "calc failed");     return balance; }  /*** User Interface ***/  /// @notice Sender supplies assets into the market and receives lTokens in exchange /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param mintAmount The amount of the underlying asset to supply function mint(uint mintAmount) external override nonReentrant {     accrueInterest();     mintFresh(msg.sender, mintAmount, false); }  function mintTo(address to, uint amount) external payable override nonReentrant {     accrueInterest();     if (isWethPool) {         mintFresh(to, msg.value, false);     } else {         mintFresh(to, amount, true);     } }  function mintEth() external payable override nonReentrant {     require(isWethPool, "not eth pool");     accrueInterest();     mintFresh(msg.sender, msg.value, false); }  /// @notice Sender redeems lTokens in exchange for the underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemTokens The number of lTokens to redeem into underlying function redeem(uint redeemTokens) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, redeemTokens, 0); }  /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemAmount The amount of underlying to redeem function redeemUnderlying(uint redeemAmount) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, 0, redeemAmount); }  function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {     accrueInterest();     // borrowFresh emits borrow-specific logs on errors, so we don't need to     borrowFresh(payable(borrower), msg.sender, borrowAmount); }  /// @notice Sender repays a borrow belonging to borrower /// @param borrower the account with the debt being payed off /// @param repayAmount The amount to repay function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     repayBorrowFresh(msg.sender, borrower, repayAmount, false); }  function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     repayBorrowFresh(msg.sender, borrower, repayAmount, true); }   /*** Safe Token ***/  /// Gets balance of this contract in terms of the underlying /// @dev This excludes the value of the current message, if any /// @return The quantity of underlying tokens owned by this contract function getCashPrior() internal view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }   /**  * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.  *      This will revert due to insufficient balance or insufficient allowance.  *      This function returns the actual amount received,  *      which may be less than `amount` if there is a fee attached to the transfer.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {     if (isWethPool &amp;&amp; convertWeth) {         actualAmount = msg.value;         IWETH(underlying).deposit{value : actualAmount}();     } else {         actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);     } }  /**  * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory  *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to  *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified  *      it is &gt;= amount, this should not revert in normal conditions.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferOut(address payable to, uint amount, bool convertWeth) internal {     if (isWethPool &amp;&amp; convertWeth) {         IWETH(underlying).withdraw(amount);         to.transfer(amount);     } else {         IERC20(underlying).safeTransfer(to, amount);     } }  function availableForBorrow() external view override returns (uint){     uint cash = getCashPrior();     (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);     if (err0 != MathError.NO_ERROR) {         return 0;     }     (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);     if (err1 != MathError.NO_ERROR) {         return 0;     }     if (totalBorrows &gt; maxAvailable) {         return 0;     }     return maxAvailable - totalBorrows; }   /// @notice Get a snapshot of the account's balances, and the cached exchange rate /// @dev This is used by controller to more efficiently perform liquidity checks. /// @param account Address of the account to snapshot /// @return ( token balance, borrow balance, exchange rate mantissa) function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {     uint cTokenBalance = accountTokens[account];     uint borrowBalance;     uint exchangeRateMantissa;      MathError mErr;      (mErr, borrowBalance) = borrowBalanceStoredInternal(account);     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      return (cTokenBalance, borrowBalance, exchangeRateMantissa); }  /// @dev Function to simply retrieve block number ///  This exists mainly for inheriting test contracts to stub this result. function getBlockNumber() internal view returns (uint) {     return block.number; }  /// @notice Returns the current per-block borrow interest rate for this cToken /// @return The borrow interest rate per block, scaled by 1e18 function borrowRatePerBlock() external override view returns (uint) {     return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves); }   /// @notice Returns the current per-block supply interest rate for this cToken /// @return The supply interest rate per block, scaled by 1e18 function supplyRatePerBlock() external override view returns (uint) {     return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa); }  function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {     // Utilization rate is 0 when there are no borrows     if (borrows == 0) {         return 0;     }     return borrows.mul(1e18).div(cash.add(borrows).sub(reserves)); }  /// @notice Calculates the current borrow rate per block, with the error code expected by the market /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18) function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {     uint util = utilizationRate(cash, borrows, reserves);     if (util &lt;= kink) {         return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);     } else {         uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);         uint excessUtil = util.sub(kink);         return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);     } }  /// @notice Calculates the current supply rate per block /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The supply rate percentage per block as a mantissa (scaled by 1e18) function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {     uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);     uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);     uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);     return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18); }  /// @notice Returns the current total borrows plus accrued interest /// @return The total borrows with interest function totalBorrowsCurrent() external override view returns (uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return totalBorrows;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, "calc block delta erro");      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      return totalBorrowsNew; }  /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex /// @param account The address whose balance should be calculated after updating borrowIndex /// @return The calculated balance function borrowBalanceCurrent(address account) external view override returns (uint) {     (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();     require(err0 == MathError.NO_ERROR, "calc borrow index fail");     (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);     require(err1 == MathError.NO_ERROR, "calc fail");     return result; }  function borrowBalanceStored(address account) external override view returns (uint){     return accountBorrows[account].principal; }   /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {     return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex); }  /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {     /* Note: we do not assert that the market is up to date */     MathError mathErr;     uint principalTimesIndex;     uint result;      /* Get borrowBalance and borrowIndex */     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];      /* If borrowBalance = 0 then borrowIndex is likely also 0.      * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.      */     if (borrowSnapshot.principal == 0) {         return (MathError.NO_ERROR, 0);     }      /* Calculate new borrow balance using the interest index:      *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex      */     (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      return (MathError.NO_ERROR, result); }  /// @notice Accrue interest then return the up-to-date exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateCurrent() public override nonReentrant returns (uint) {     accrueInterest();     return exchangeRateStored(); }  /// Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateStored() public override view returns (uint) {     (MathError err, uint result) = exchangeRateStoredInternal();     require(err == MathError.NO_ERROR, "calc fail");     return result; }  /// @notice Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return (error code, calculated exchange rate scaled by 1e18) function exchangeRateStoredInternal() internal view returns (MathError, uint) {     uint _totalSupply = totalSupply;     if (_totalSupply == 0) {         /*          * If there are no tokens minted:          *  exchangeRate = initialExchangeRate          */         return (MathError.NO_ERROR, initialExchangeRateMantissa);     } else {         /*          * Otherwise:          *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply          */         uint _totalCash = getCashPrior();         uint cashPlusBorrowsMinusReserves;         Exp memory exchangeRate;         MathError mathErr;          (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          return (MathError.NO_ERROR, exchangeRate.mantissa);     } }  /// @notice Get cash balance of this cToken in the underlying asset /// @return The quantity of underlying asset owned by this contract function getCash() external override view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }  function calCurrentBorrowIndex() internal view returns (MathError, uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;     uint borrowIndexNew;     /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return (MathError.NO_ERROR, borrowIndex);     }     uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);      Exp memory simpleInterestFactor;     (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }     (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);     return (mathErr, borrowIndexNew); }  /// @notice Applies accrued interest to total borrows and reserves /// @dev This calculates interest accrued from the last checkpointed block ///   up to the current block and writes new checkpoint to storage. function accrueInterest() public override {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint borrowIndexPrior = borrowIndex;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, "calc block delta erro");       /*      * Calculate the interest accumulated into borrows and reserves and the new index:      *  simpleInterestFactor = borrowRate * blockDelta      *  interestAccumulated = simpleInterestFactor * totalBorrows      *  totalBorrowsNew = interestAccumulated + totalBorrows      *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex      */      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;     uint borrowIndexNew;     uint totalReservesNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);     require(mathErr == MathError.NO_ERROR, 'calc total reserves error');      (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);     require(mathErr == MathError.NO_ERROR, 'calc borrows index error');       /* We write the previously calculated values into storage */     accrualBlockNumber = currentBlockNumber;     borrowIndex = borrowIndexNew;     totalBorrows = totalBorrowsNew;     totalReserves = totalReservesNew;      /* We emit an AccrueInterest event */     emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);  }  struct MintLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint mintTokens;     uint totalSupplyNew;     uint accountTokensNew;     uint actualMintAmount; }  /// @notice User supplies assets into the market and receives lTokens in exchange /// @dev Assumes interest has already been accrued up to the current block /// @param minter The address of the account which is supplying the assets /// @param mintAmount The amount of the underlying asset to supply /// @return uint the actual mint amount. function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {     MintLocalVars memory vars;     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /*      *  We call `doTransferIn` for the minter and the mintAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if      *  side-effects occurred. The function returns the amount actually transferred,      *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`      *  of cash.      */     if (isDelegete) {         uint balanceBefore = getCashPrior();         LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);         uint balanceAfter = getCashPrior();         require(balanceAfter &gt; balanceBefore, 'mint 0');         vars.actualMintAmount = balanceAfter - balanceBefore;     } else {         vars.actualMintAmount = doTransferIn(minter, mintAmount, true);     }     /*      * We get the current exchange rate and calculate the number of lTokens to be minted:      *  mintTokens = actualMintAmount / exchangeRate      */      (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));     require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");      /* Fail if mint not allowed */     (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);     /*      * We calculate the new total supply of lTokens and minter token balance, checking for overflow:      *  totalSupplyNew = totalSupply + mintTokens      *  accountTokensNew = accountTokens[minter] + mintTokens      */     (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");      (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[minter] = vars.accountTokensNew;      /* We emit a Mint event, and a Transfer event */     emit Mint(minter, vars.actualMintAmount, vars.mintTokens);     emit Transfer(address(this), minter, vars.mintTokens);      /* We call the defense hook */      return vars.actualMintAmount; }   struct RedeemLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint redeemTokens;     uint redeemAmount;     uint totalSupplyNew;     uint accountTokensNew; }  /// @notice User redeems lTokens in exchange for the underlying asset /// @dev Assumes interest has already been accrued up to the current block /// @param redeemer The address of the account which is redeeming the tokens /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero) /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero) function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {     require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");      RedeemLocalVars memory vars;      /* exchangeRate = invoke Exchange Rate Stored() */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /* If redeemTokensIn &gt; 0: */     if (redeemTokensIn &gt; 0) {         /*          * We calculate the exchange rate and the amount of underlying to be redeemed:          *  redeemTokens = redeemTokensIn          *  redeemAmount = redeemTokensIn x exchangeRateCurrent          */         vars.redeemTokens = redeemTokensIn;          (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');     } else {         /*          * We get the current exchange rate and calculate the amount to be redeemed:          *  redeemTokens = redeemAmountIn / exchangeRate          *  redeemAmount = redeemAmountIn          */          (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');         vars.redeemAmount = redeemAmountIn;     }      /* Fail if redeem not allowed */     (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);      /*      * We calculate the new total supply and redeemer balance, checking for underflow:      *  totalSupplyNew = totalSupply - redeemTokens      *  accountTokensNew = accountTokens[redeemer] - redeemTokens      */     (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');      (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');     require(getCashPrior() &gt;= vars.redeemAmount, 'cash &lt; redeem');      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[redeemer] = vars.accountTokensNew;     /*      * We invoke doTransferOut for the redeemer and the redeemAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken has redeemAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(redeemer, vars.redeemAmount, true);       /* We emit a Transfer event, and a Redeem event */     emit Transfer(redeemer, address(this), vars.redeemTokens);     emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);      /* We call the defense hook */ }  struct BorrowLocalVars {     MathError mathErr;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /// @notice Users borrow assets from the protocol to their own address /// @param borrowAmount The amount of the underlying asset to borrow function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {     /* Fail if borrow not allowed */     (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);      /* Fail gracefully if protocol has insufficient underlying cash */     require(getCashPrior() &gt;= borrowAmount, 'cash&lt;borrow');      BorrowLocalVars memory vars;      /*      * We calculate the new borrower and total borrow balances, failing on overflow:      *  accountBorrowsNew = accountBorrows + borrowAmount      *  totalBorrowsNew = totalBorrows + borrowAmount      */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /*      * We invoke doTransferOut for the borrower and the borrowAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken borrowAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(payee, borrowAmount, false);      /* We emit a Borrow event */     emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */ }  struct RepayBorrowLocalVars {     MathError mathErr;     uint repayAmount;     uint borrowerIndex;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew;     uint actualRepayAmount;     uint badDebtsAmount; }  /// @notice Borrows are repaid by another user (possibly the borrower). /// @param payer the account paying off the borrow /// @param borrower the account with the debt being payed off /// @param repayAmount the amount of undelrying tokens being returned function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {     /* Fail if repayBorrow not allowed */     (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);      RepayBorrowLocalVars memory vars;      /* We remember the original borrowerIndex for verification purposes */     vars.borrowerIndex = accountBorrows[borrower].interestIndex;      /* We fetch the amount the borrower owes, with accumulated interest */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');      /* If repayAmount == -1, repayAmount = accountBorrows */     if (repayAmount == uint(- 1)) {         vars.repayAmount = vars.accountBorrows;     } else {         vars.repayAmount = repayAmount;     }     vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);       if (isEnd &amp;&amp; vars.accountBorrows &gt; vars.actualRepayAmount) {         vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;     }      /*     *  We calculate the new borrower and total borrow balances, failing on underflow:     *  accountBorrowsNew = accountBorrows - repayAmount     *  totalBorrowsNew = totalBorrows - repayAmount     */     if (vars.accountBorrows &lt; vars.actualRepayAmount) {         require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) &lt;= 105e16, 'repay more than 5%');         vars.accountBorrowsNew = 0;     } else {         if (isEnd) {             vars.accountBorrowsNew = 0;         } else {             vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;         }     }     //Avoid mantissa errors     if (vars.actualRepayAmount &gt; totalBorrows) {         vars.totalBorrowsNew = 0;     } else {         if (isEnd) {             vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);         } else {             vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;         }     }      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a RepayBorrow event */     emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */      return vars.actualRepayAmount; }  /*** Admin Functions ***/  /// @notice Sets a new CONTROLLER for the market /// @dev Admin function to set a new controller function setController(address newController) external override onlyAdmin {     require(address(0) != newController, "0x");     address oldController = controller;     controller = newController;     // Emit NewController(oldController, newController)     emit NewController(oldController, newController); }  function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {     require(newBorrowCapFactorMantissa &lt;= 1e18, 'Factor too large');     uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;     borrowCapFactorMantissa = newBorrowCapFactorMantissa;     emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa); }  function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {     //accrueInterest except first     if (baseRatePerBlock != 0) {         accrueInterest();     }     // total rate perYear &lt; 2000%     require(baseRatePerBlock_ &lt; 1e13, 'Base rate too large');     baseRatePerBlock = baseRatePerBlock_;     require(multiplierPerBlock_ &lt; 1e13, 'Mul rate too large');     multiplierPerBlock = multiplierPerBlock_;     require(jumpMultiplierPerBlock_ &lt; 1e13, 'Jump rate too large');     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     require(kink_ &lt;= 1e18, 'Kline too large');     kink = kink_;     emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_); }  function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {     require(newReserveFactorMantissa &lt;= 1e18, 'Factor too large');     accrueInterest();     uint oldReserveFactorMantissa = reserveFactorMantissa;     reserveFactorMantissa = newReserveFactorMantissa;     emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa); }  function addReserves(uint addAmount) external override nonReentrant {     accrueInterest();     uint totalReservesNew;     uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);     totalReservesNew = totalReserves.add(actualAddAmount);     totalReserves = totalReservesNew;     emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew); }  function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {     accrueInterest();     uint totalReservesNew;     totalReservesNew = totalReserves.sub(reduceAmount);     totalReserves = totalReservesNew;     doTransferOut(to, reduceAmount, true);     emit ReservesReduced(to, reduceAmount, totalReservesNew); }  modifier sameBlock() {     require(accrualBlockNumber == getBlockNumber(), 'not same block');     _; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-24-08 19:28:18 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.7.6; import "./LPoolInterface.sol"; import "./LPoolDepositor.sol"; import "../lib/Exponential.sol"; import "../Adminable.sol"; import "../lib/CarefulMath.sol"; import "../lib/TransferHelper.sol"; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import "../DelegateInterface.sol"; import "../ControllerInterface.sol"; import "../IWETH.sol"; /// @title OpenLeverage's LToken Contract /// @dev Abstract base for LTokens /// @author OpenLeverage contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {     using TransferHelper for IERC20;     using SafeMath for uint; constructor() {  }  /// @notice Initialize the money market /// @param controller_ The address of the Controller /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0 /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point /// @param kink_ The utilization point at which the jump multiplier is applied /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18 /// @param name_ EIP-20 name of this token /// @param symbol_ EIP-20 symbol of this token /// @param decimals_ EIP-20 decimal precision of this token function initialize(     address underlying_,     bool isWethPool_,     address controller_,     uint256 baseRatePerBlock_,     uint256 multiplierPerBlock_,     uint256 jumpMultiplierPerBlock_,     uint256 kink_,     uint initialExchangeRateMantissa_,     string memory name_,     string memory symbol_,     uint8 decimals_) public {     require(underlying_ != address(0), "underlying_ address cannot be 0");     require(controller_ != address(0), "controller_ address cannot be 0");     require(msg.sender == admin, "Only allow to be called by admin");     require(accrualBlockNumber == 0 &amp;&amp; borrowIndex == 0, "inited once");      // Set initial exchange rate     initialExchangeRateMantissa = initialExchangeRateMantissa_;     require(initialExchangeRateMantissa &gt; 0, "Initial Exchange Rate Mantissa should be greater zero");     //set controller     controller = controller_;     isWethPool = isWethPool_;     //set interestRateModel     baseRatePerBlock = baseRatePerBlock_;     multiplierPerBlock = multiplierPerBlock_;     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     kink = kink_;      // Initialize block number and borrow index (block number mocks depend on controller being set)     accrualBlockNumber = getBlockNumber();     borrowIndex = 1e25;     //80%     borrowCapFactorMantissa = 0.8e18;     //10%     reserveFactorMantissa = 0.1e18;       name = name_;     symbol = symbol_;     decimals = decimals_;      _notEntered = true;      // Set underlying and sanity check it     underlying = underlying_;     IERC20(underlying).totalSupply();     emit Transfer(address(0), msg.sender, 0); }  /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender` /// @dev Called by both `transfer` and `transferFrom` internally /// @param spender The address of the account performing the transfer /// @param src The address of the source account /// @param dst The address of the destination account /// @param tokens The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {     require(dst != address(0), "dst address cannot be 0");     /* Do not allow self-transfers */     require(src != dst, "src = dst");     /* Fail if transfer not allowed */     (ControllerInterface(controller)).transferAllowed(src, dst, tokens);      /* Get the allowance, infinite for the account owner */     uint startingAllowance = 0;     if (spender == src) {         startingAllowance = uint(- 1);     } else {         startingAllowance = transferAllowances[src][spender];     }      /* Do the calculations, checking for {under,over}flow */     MathError mathErr;     uint allowanceNew;     uint srcTokensNew;     uint dstTokensNew;      (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);     require(mathErr == MathError.NO_ERROR, 'not allowed');      (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);     require(mathErr == MathError.NO_ERROR, 'not enough');      (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);     require(mathErr == MathError.NO_ERROR, 'too much');      accountTokens[src] = srcTokensNew;     accountTokens[dst] = dstTokensNew;      /* Eat some of the allowance (if necessary) */     if (startingAllowance != uint(- 1)) {         transferAllowances[src][spender] = allowanceNew;     }     /* We emit a Transfer event */     emit Transfer(src, dst, tokens);     return true; }  /// @notice Transfer `amount` tokens from `msg.sender` to `dst` /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, msg.sender, dst, amount); }  /// @notice Transfer `amount` tokens from `src` to `dst` /// @param src The address of the source account /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, src, dst, amount); }  /// @notice Approve `spender` to transfer up to `amount` from `src` /// @dev This will overwrite the approval amount for `spender` ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve) /// @param spender The address of the account which may transfer tokens /// @param amount The number of tokens that are approved (-1 means infinite) /// @return Whether or not the approval succeeded function approve(address spender, uint256 amount) external override returns (bool) {     address src = msg.sender;     transferAllowances[src][spender] = amount;     emit Approval(src, spender, amount);     return true; }  /// @notice Get the current allowance from `owner` for `spender` /// @param owner The address of the account which owns the tokens to be spent /// @param spender The address of the account which may transfer tokens /// @return The number of tokens allowed to be spent (-1 means infinite) function allowance(address owner, address spender) external override view returns (uint256) {     return transferAllowances[owner][spender]; }  /// @notice Get the token balance of the `owner` /// @param owner The address of the account to query /// @return The number of tokens owned by `owner` function balanceOf(address owner) external override view returns (uint256) {     return accountTokens[owner]; }  /// @notice Get the underlying balance of the `owner` /// @dev This also accrues interest in a transaction /// @param owner The address of the account to query /// @return The amount of underlying owned by `owner` function balanceOfUnderlying(address owner) external override returns (uint) {     Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});     (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);     require(mErr == MathError.NO_ERROR, "calc failed");     return balance; }  /*** User Interface ***/  /// @notice Sender supplies assets into the market and receives lTokens in exchange /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param mintAmount The amount of the underlying asset to supply function mint(uint mintAmount) external override nonReentrant {     accrueInterest();     mintFresh(msg.sender, mintAmount, false); }  function mintTo(address to, uint amount) external payable override nonReentrant {     accrueInterest();     if (isWethPool) {         mintFresh(to, msg.value, false);     } else {         mintFresh(to, amount, true);     } }  function mintEth() external payable override nonReentrant {     require(isWethPool, "not eth pool");     accrueInterest();     mintFresh(msg.sender, msg.value, false); }  /// @notice Sender redeems lTokens in exchange for the underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemTokens The number of lTokens to redeem into underlying function redeem(uint redeemTokens) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, redeemTokens, 0); }  /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemAmount The amount of underlying to redeem function redeemUnderlying(uint redeemAmount) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, 0, redeemAmount); }  function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {     accrueInterest();     // borrowFresh emits borrow-specific logs on errors, so we don't need to     borrowFresh(payable(borrower), msg.sender, borrowAmount); }  /// @notice Sender repays a borrow belonging to borrower /// @param borrower the account with the debt being payed off /// @param repayAmount The amount to repay function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     repayBorrowFresh(msg.sender, borrower, repayAmount, false); }  function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     repayBorrowFresh(msg.sender, borrower, repayAmount, true); }   /*** Safe Token ***/  /// Gets balance of this contract in terms of the underlying /// @dev This excludes the value of the current message, if any /// @return The quantity of underlying tokens owned by this contract function getCashPrior() internal view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }   /**  * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.  *      This will revert due to insufficient balance or insufficient allowance.  *      This function returns the actual amount received,  *      which may be less than `amount` if there is a fee attached to the transfer.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {     if (isWethPool &amp;&amp; convertWeth) {         actualAmount = msg.value;         IWETH(underlying).deposit{value : actualAmount}();     } else {         actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);     } }  /**  * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory  *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to  *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified  *      it is &gt;= amount, this should not revert in normal conditions.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferOut(address payable to, uint amount, bool convertWeth) internal {     if (isWethPool &amp;&amp; convertWeth) {         IWETH(underlying).withdraw(amount);         to.transfer(amount);     } else {         IERC20(underlying).safeTransfer(to, amount);     } }  function availableForBorrow() external view override returns (uint){     uint cash = getCashPrior();     (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);     if (err0 != MathError.NO_ERROR) {         return 0;     }     (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);     if (err1 != MathError.NO_ERROR) {         return 0;     }     if (totalBorrows &gt; maxAvailable) {         return 0;     }     return maxAvailable - totalBorrows; }   /// @notice Get a snapshot of the account's balances, and the cached exchange rate /// @dev This is used by controller to more efficiently perform liquidity checks. /// @param account Address of the account to snapshot /// @return ( token balance, borrow balance, exchange rate mantissa) function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {     uint cTokenBalance = accountTokens[account];     uint borrowBalance;     uint exchangeRateMantissa;      MathError mErr;      (mErr, borrowBalance) = borrowBalanceStoredInternal(account);     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      return (cTokenBalance, borrowBalance, exchangeRateMantissa); }  /// @dev Function to simply retrieve block number ///  This exists mainly for inheriting test contracts to stub this result. function getBlockNumber() internal view returns (uint) {     return block.number; }  /// @notice Returns the current per-block borrow interest rate for this cToken /// @return The borrow interest rate per block, scaled by 1e18 function borrowRatePerBlock() external override view returns (uint) {     return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves); }   /// @notice Returns the current per-block supply interest rate for this cToken /// @return The supply interest rate per block, scaled by 1e18 function supplyRatePerBlock() external override view returns (uint) {     return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa); }  function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {     // Utilization rate is 0 when there are no borrows     if (borrows == 0) {         return 0;     }     return borrows.mul(1e18).div(cash.add(borrows).sub(reserves)); }  /// @notice Calculates the current borrow rate per block, with the error code expected by the market /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18) function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {     uint util = utilizationRate(cash, borrows, reserves);     if (util &lt;= kink) {         return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);     } else {         uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);         uint excessUtil = util.sub(kink);         return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);     } }  /// @notice Calculates the current supply rate per block /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The supply rate percentage per block as a mantissa (scaled by 1e18) function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {     uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);     uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);     uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);     return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18); }  /// @notice Returns the current total borrows plus accrued interest /// @return The total borrows with interest function totalBorrowsCurrent() external override view returns (uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return totalBorrows;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, "calc block delta erro");      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      return totalBorrowsNew; }  /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex /// @param account The address whose balance should be calculated after updating borrowIndex /// @return The calculated balance function borrowBalanceCurrent(address account) external view override returns (uint) {     (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();     require(err0 == MathError.NO_ERROR, "calc borrow index fail");     (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);     require(err1 == MathError.NO_ERROR, "calc fail");     return result; }  function borrowBalanceStored(address account) external override view returns (uint){     return accountBorrows[account].principal; }   /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {     return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex); }  /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {     /* Note: we do not assert that the market is up to date */     MathError mathErr;     uint principalTimesIndex;     uint result;      /* Get borrowBalance and borrowIndex */     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];      /* If borrowBalance = 0 then borrowIndex is likely also 0.      * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.      */     if (borrowSnapshot.principal == 0) {         return (MathError.NO_ERROR, 0);     }      /* Calculate new borrow balance using the interest index:      *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex      */     (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      return (MathError.NO_ERROR, result); }  /// @notice Accrue interest then return the up-to-date exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateCurrent() public override nonReentrant returns (uint) {     accrueInterest();     return exchangeRateStored(); }  /// Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateStored() public override view returns (uint) {     (MathError err, uint result) = exchangeRateStoredInternal();     require(err == MathError.NO_ERROR, "calc fail");     return result; }  /// @notice Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return (error code, calculated exchange rate scaled by 1e18) function exchangeRateStoredInternal() internal view returns (MathError, uint) {     uint _totalSupply = totalSupply;     if (_totalSupply == 0) {         /*          * If there are no tokens minted:          *  exchangeRate = initialExchangeRate          */         return (MathError.NO_ERROR, initialExchangeRateMantissa);     } else {         /*          * Otherwise:          *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply          */         uint _totalCash = getCashPrior();         uint cashPlusBorrowsMinusReserves;         Exp memory exchangeRate;         MathError mathErr;          (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          return (MathError.NO_ERROR, exchangeRate.mantissa);     } }  /// @notice Get cash balance of this cToken in the underlying asset /// @return The quantity of underlying asset owned by this contract function getCash() external override view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }  function calCurrentBorrowIndex() internal view returns (MathError, uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;     uint borrowIndexNew;     /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return (MathError.NO_ERROR, borrowIndex);     }     uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);      Exp memory simpleInterestFactor;     (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }     (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);     return (mathErr, borrowIndexNew); }  /// @notice Applies accrued interest to total borrows and reserves /// @dev This calculates interest accrued from the last checkpointed block ///   up to the current block and writes new checkpoint to storage. function accrueInterest() public override {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint borrowIndexPrior = borrowIndex;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, "calc block delta erro");       /*      * Calculate the interest accumulated into borrows and reserves and the new index:      *  simpleInterestFactor = borrowRate * blockDelta      *  interestAccumulated = simpleInterestFactor * totalBorrows      *  totalBorrowsNew = interestAccumulated + totalBorrows      *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex      */      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;     uint borrowIndexNew;     uint totalReservesNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);     require(mathErr == MathError.NO_ERROR, 'calc total reserves error');      (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);     require(mathErr == MathError.NO_ERROR, 'calc borrows index error');       /* We write the previously calculated values into storage */     accrualBlockNumber = currentBlockNumber;     borrowIndex = borrowIndexNew;     totalBorrows = totalBorrowsNew;     totalReserves = totalReservesNew;      /* We emit an AccrueInterest event */     emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);  }  struct MintLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint mintTokens;     uint totalSupplyNew;     uint accountTokensNew;     uint actualMintAmount; }  /// @notice User supplies assets into the market and receives lTokens in exchange /// @dev Assumes interest has already been accrued up to the current block /// @param minter The address of the account which is supplying the assets /// @param mintAmount The amount of the underlying asset to supply /// @return uint the actual mint amount. function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {     MintLocalVars memory vars;     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /*      *  We call `doTransferIn` for the minter and the mintAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if      *  side-effects occurred. The function returns the amount actually transferred,      *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`      *  of cash.      */     if (isDelegete) {         uint balanceBefore = getCashPrior();         LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);         uint balanceAfter = getCashPrior();         require(balanceAfter &gt; balanceBefore, 'mint 0');         vars.actualMintAmount = balanceAfter - balanceBefore;     } else {         vars.actualMintAmount = doTransferIn(minter, mintAmount, true);     }     /*      * We get the current exchange rate and calculate the number of lTokens to be minted:      *  mintTokens = actualMintAmount / exchangeRate      */      (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));     require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");      /* Fail if mint not allowed */     (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);     /*      * We calculate the new total supply of lTokens and minter token balance, checking for overflow:      *  totalSupplyNew = totalSupply + mintTokens      *  accountTokensNew = accountTokens[minter] + mintTokens      */     (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");      (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[minter] = vars.accountTokensNew;      /* We emit a Mint event, and a Transfer event */     emit Mint(minter, vars.actualMintAmount, vars.mintTokens);     emit Transfer(address(this), minter, vars.mintTokens);      /* We call the defense hook */      return vars.actualMintAmount; }   struct RedeemLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint redeemTokens;     uint redeemAmount;     uint totalSupplyNew;     uint accountTokensNew; }  /// @notice User redeems lTokens in exchange for the underlying asset /// @dev Assumes interest has already been accrued up to the current block /// @param redeemer The address of the account which is redeeming the tokens /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero) /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero) function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {     require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");      RedeemLocalVars memory vars;      /* exchangeRate = invoke Exchange Rate Stored() */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /* If redeemTokensIn &gt; 0: */     if (redeemTokensIn &gt; 0) {         /*          * We calculate the exchange rate and the amount of underlying to be redeemed:          *  redeemTokens = redeemTokensIn          *  redeemAmount = redeemTokensIn x exchangeRateCurrent          */         vars.redeemTokens = redeemTokensIn;          (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');     } else {         /*          * We get the current exchange rate and calculate the amount to be redeemed:          *  redeemTokens = redeemAmountIn / exchangeRate          *  redeemAmount = redeemAmountIn          */          (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');         vars.redeemAmount = redeemAmountIn;     }      /* Fail if redeem not allowed */     (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);      /*      * We calculate the new total supply and redeemer balance, checking for underflow:      *  totalSupplyNew = totalSupply - redeemTokens      *  accountTokensNew = accountTokens[redeemer] - redeemTokens      */     (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');      (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');     require(getCashPrior() &gt;= vars.redeemAmount, 'cash &lt; redeem');      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[redeemer] = vars.accountTokensNew;     /*      * We invoke doTransferOut for the redeemer and the redeemAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken has redeemAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(redeemer, vars.redeemAmount, true);       /* We emit a Transfer event, and a Redeem event */     emit Transfer(redeemer, address(this), vars.redeemTokens);     emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);      /* We call the defense hook */ }  struct BorrowLocalVars {     MathError mathErr;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /// @notice Users borrow assets from the protocol to their own address /// @param borrowAmount The amount of the underlying asset to borrow function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {     /* Fail if borrow not allowed */     (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);      /* Fail gracefully if protocol has insufficient underlying cash */     require(getCashPrior() &gt;= borrowAmount, 'cash&lt;borrow');      BorrowLocalVars memory vars;      /*      * We calculate the new borrower and total borrow balances, failing on overflow:      *  accountBorrowsNew = accountBorrows + borrowAmount      *  totalBorrowsNew = totalBorrows + borrowAmount      */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /*      * We invoke doTransferOut for the borrower and the borrowAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken borrowAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(payee, borrowAmount, false);      /* We emit a Borrow event */     emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */ }  struct RepayBorrowLocalVars {     MathError mathErr;     uint repayAmount;     uint borrowerIndex;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew;     uint actualRepayAmount;     uint badDebtsAmount; }  /// @notice Borrows are repaid by another user (possibly the borrower). /// @param payer the account paying off the borrow /// @param borrower the account with the debt being payed off /// @param repayAmount the amount of undelrying tokens being returned function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {     /* Fail if repayBorrow not allowed */     (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);      RepayBorrowLocalVars memory vars;      /* We remember the original borrowerIndex for verification purposes */     vars.borrowerIndex = accountBorrows[borrower].interestIndex;      /* We fetch the amount the borrower owes, with accumulated interest */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');      /* If repayAmount == -1, repayAmount = accountBorrows */     if (repayAmount == uint(- 1)) {         vars.repayAmount = vars.accountBorrows;     } else {         vars.repayAmount = repayAmount;     }     vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);       if (isEnd &amp;&amp; vars.accountBorrows &gt; vars.actualRepayAmount) {         vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;     }      /*     *  We calculate the new borrower and total borrow balances, failing on underflow:     *  accountBorrowsNew = accountBorrows - repayAmount     *  totalBorrowsNew = totalBorrows - repayAmount     */     if (vars.accountBorrows &lt; vars.actualRepayAmount) {         require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) &lt;= 105e16, 'repay more than 5%');         vars.accountBorrowsNew = 0;     } else {         if (isEnd) {             vars.accountBorrowsNew = 0;         } else {             vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;         }     }     //Avoid mantissa errors     if (vars.actualRepayAmount &gt; totalBorrows) {         vars.totalBorrowsNew = 0;     } else {         if (isEnd) {             vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);         } else {             vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;         }     }      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a RepayBorrow event */     emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */      return vars.actualRepayAmount; }  /*** Admin Functions ***/  /// @notice Sets a new CONTROLLER for the market /// @dev Admin function to set a new controller function setController(address newController) external override onlyAdmin {     require(address(0) != newController, "0x");     address oldController = controller;     controller = newController;     // Emit NewController(oldController, newController)     emit NewController(oldController, newController); }  function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {     require(newBorrowCapFactorMantissa &lt;= 1e18, 'Factor too large');     uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;     borrowCapFactorMantissa = newBorrowCapFactorMantissa;     emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa); }  function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {     //accrueInterest except first     if (baseRatePerBlock != 0) {         accrueInterest();     }     // total rate perYear &lt; 2000%     require(baseRatePerBlock_ &lt; 1e13, 'Base rate too large');     baseRatePerBlock = baseRatePerBlock_;     require(multiplierPerBlock_ &lt; 1e13, 'Mul rate too large');     multiplierPerBlock = multiplierPerBlock_;     require(jumpMultiplierPerBlock_ &lt; 1e13, 'Jump rate too large');     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     require(kink_ &lt;= 1e18, 'Kline too large');     kink = kink_;     emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_); }  function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {     require(newReserveFactorMantissa &lt;= 1e18, 'Factor too large');     accrueInterest();     uint oldReserveFactorMantissa = reserveFactorMantissa;     reserveFactorMantissa = newReserveFactorMantissa;     emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa); }  function addReserves(uint addAmount) external override nonReentrant {     accrueInterest();     uint totalReservesNew;     uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);     totalReservesNew = totalReserves.add(actualAddAmount);     totalReserves = totalReservesNew;     emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew); }  function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {     accrueInterest();     uint totalReservesNew;     totalReservesNew = totalReserves.sub(reduceAmount);     totalReserves = totalReservesNew;     doTransferOut(to, reduceAmount, true);     emit ReservesReduced(to, reduceAmount, totalReservesNew); }  modifier sameBlock() {     require(accrualBlockNumber == getBlockNumber(), 'not same block');     _; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-24-08 19:28:18 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;


import "./LPoolInterface.sol";
import "./LPoolDepositor.sol";
import "../lib/Exponential.sol";
import "../Adminable.sol";
import "../lib/CarefulMath.sol";
import "../lib/TransferHelper.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import "../DelegateInterface.sol";
import "../ControllerInterface.sol";
import "../IWETH.sol";

/// @title OpenLeverage's LToken Contract
/// @dev Abstract base for LTokens
/// @author OpenLeverage
contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {
    using TransferHelper for IERC20;
    using SafeMath for uint;

    constructor() {

    }
    
    /// @notice Initialize the money market
    /// @param controller_ The address of the Controller
    /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0
    /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate
    /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point
    /// @param kink_ The utilization point at which the jump multiplier is applied
    /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
    /// @param name_ EIP-20 name of this token
    /// @param symbol_ EIP-20 symbol of this token
    /// @param decimals_ EIP-20 decimal precision of this token
    function initialize(
        address underlying_,
        bool isWethPool_,
        address controller_,
        uint256 baseRatePerBlock_,
        uint256 multiplierPerBlock_,
        uint256 jumpMultiplierPerBlock_,
        uint256 kink_,
        uint initialExchangeRateMantissa_,
        string memory name_,
        string memory symbol_,
        uint8 decimals_) public {
        require(underlying_ != address(0), "underlying_ address cannot be 0");
        require(controller_ != address(0), "controller_ address cannot be 0");
        require(msg.sender == admin, "Only allow to be called by admin");
        require(accrualBlockNumber == 0 && borrowIndex == 0, "inited once");

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial Exchange Rate Mantissa should be greater zero");
        //set controller
        controller = controller_;
        isWethPool = isWethPool_;
        //set interestRateModel
        baseRatePerBlock = baseRatePerBlock_;
        multiplierPerBlock = multiplierPerBlock_;
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        kink = kink_;

        // Initialize block number and borrow index (block number mocks depend on controller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = 1e25;
        //80%
        borrowCapFactorMantissa = 0.8e18;
        //10%
        reserveFactorMantissa = 0.1e18;


        name = name_;
        symbol = symbol_;
        decimals = decimals_;

        _notEntered = true;

        // Set underlying and sanity check it
        underlying = underlying_;
        IERC20(underlying).totalSupply();
        emit Transfer(address(0), msg.sender, 0);
    }

    /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
    /// @dev Called by both `transfer` and `transferFrom` internally
    /// @param spender The address of the account performing the transfer
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param tokens The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {
        require(dst != address(0), "dst address cannot be 0");
        /* Do not allow self-transfers */
        require(src != dst, "src = dst");
        /* Fail if transfer not allowed */
        (ControllerInterface(controller)).transferAllowed(src, dst, tokens);

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(- 1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        require(mathErr == MathError.NO_ERROR, 'not allowed');

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        require(mathErr == MathError.NO_ERROR, 'not enough');

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        require(mathErr == MathError.NO_ERROR, 'too much');

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(- 1)) {
            transferAllowances[src][spender] = allowanceNew;
        }
        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);
        return true;
    }

    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount);
    }

    /// @notice Transfer `amount` tokens from `src` to `dst`
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount);
    }

    /// @notice Approve `spender` to transfer up to `amount` from `src`
    /// @dev This will overwrite the approval amount for `spender`
    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
    /// @param spender The address of the account which may transfer tokens
    /// @param amount The number of tokens that are approved (-1 means infinite)
    /// @return Whether or not the approval succeeded
    function approve(address spender, uint256 amount) external override returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /// @notice Get the current allowance from `owner` for `spender`
    /// @param owner The address of the account which owns the tokens to be spent
    /// @param spender The address of the account which may transfer tokens
    /// @return The number of tokens allowed to be spent (-1 means infinite)
    function allowance(address owner, address spender) external override view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /// @notice Get the token balance of the `owner`
    /// @param owner The address of the account to query
    /// @return The number of tokens owned by `owner`
    function balanceOf(address owner) external override view returns (uint256) {
        return accountTokens[owner];
    }

    /// @notice Get the underlying balance of the `owner`
    /// @dev This also accrues interest in a transaction
    /// @param owner The address of the account to query
    /// @return The amount of underlying owned by `owner`
    function balanceOfUnderlying(address owner) external override returns (uint) {
        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR, "calc failed");
        return balance;
    }

    /*** User Interface ***/

    /// @notice Sender supplies assets into the market and receives lTokens in exchange
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param mintAmount The amount of the underlying asset to supply
    function mint(uint mintAmount) external override nonReentrant {
        accrueInterest();
        mintFresh(msg.sender, mintAmount, false);
    }

    function mintTo(address to, uint amount) external payable override nonReentrant {
        accrueInterest();
        if (isWethPool) {
            mintFresh(to, msg.value, false);
        } else {
            mintFresh(to, amount, true);
        }
    }

    function mintEth() external payable override nonReentrant {
        require(isWethPool, "not eth pool");
        accrueInterest();
        mintFresh(msg.sender, msg.value, false);
    }

    /// @notice Sender redeems lTokens in exchange for the underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemTokens The number of lTokens to redeem into underlying
    function redeem(uint redeemTokens) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, redeemTokens, 0);
    }

    /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemAmount The amount of underlying to redeem
    function redeemUnderlying(uint redeemAmount) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, 0, redeemAmount);
    }

    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {
        accrueInterest();
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        borrowFresh(payable(borrower), msg.sender, borrowAmount);
    }

    /// @notice Sender repays a borrow belonging to borrower
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount The amount to repay
    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        repayBorrowFresh(msg.sender, borrower, repayAmount, false);
    }

    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        repayBorrowFresh(msg.sender, borrower, repayAmount, true);
    }


    /*** Safe Token ***/

    /// Gets balance of this contract in terms of the underlying
    /// @dev This excludes the value of the current message, if any
    /// @return The quantity of underlying tokens owned by this contract
    function getCashPrior() internal view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }


    /**
     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.
     *      This will revert due to insufficient balance or insufficient allowance.
     *      This function returns the actual amount received,
     *      which may be less than `amount` if there is a fee attached to the transfer.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {
        if (isWethPool && convertWeth) {
            actualAmount = msg.value;
            IWETH(underlying).deposit{value : actualAmount}();
        } else {
            actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);
        }
    }

    /**
     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory
     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to
     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified
     *      it is >= amount, this should not revert in normal conditions.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {
        if (isWethPool && convertWeth) {
            IWETH(underlying).withdraw(amount);
            to.transfer(amount);
        } else {
            IERC20(underlying).safeTransfer(to, amount);
        }
    }

    function availableForBorrow() external view override returns (uint){
        uint cash = getCashPrior();
        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);
        if (err0 != MathError.NO_ERROR) {
            return 0;
        }
        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);
        if (err1 != MathError.NO_ERROR) {
            return 0;
        }
        if (totalBorrows > maxAvailable) {
            return 0;
        }
        return maxAvailable - totalBorrows;
    }


    /// @notice Get a snapshot of the account's balances, and the cached exchange rate
    /// @dev This is used by controller to more efficiently perform liquidity checks.
    /// @param account Address of the account to snapshot
    /// @return ( token balance, borrow balance, exchange rate mantissa)
    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        return (cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /// @dev Function to simply retrieve block number
    ///  This exists mainly for inheriting test contracts to stub this result.
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /// @notice Returns the current per-block borrow interest rate for this cToken
    /// @return The borrow interest rate per block, scaled by 1e18
    function borrowRatePerBlock() external override view returns (uint) {
        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
    }

    
    /// @notice Returns the current per-block supply interest rate for this cToken
    /// @return The supply interest rate per block, scaled by 1e18
    function supplyRatePerBlock() external override view returns (uint) {
        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);
    }

    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {
        // Utilization rate is 0 when there are no borrows
        if (borrows == 0) {
            return 0;
        }
        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));
    }

    /// @notice Calculates the current borrow rate per block, with the error code expected by the market
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18)
    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {
        uint util = utilizationRate(cash, borrows, reserves);
        if (util <= kink) {
            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
        } else {
            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
            uint excessUtil = util.sub(kink);
            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);
        }
    }

    /// @notice Calculates the current supply rate per block
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The supply rate percentage per block as a mantissa (scaled by 1e18)
    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {
        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);
        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);
        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);
        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);
    }

    /// @notice Returns the current total borrows plus accrued interest
    /// @return The total borrows with interest
    function totalBorrowsCurrent() external override view returns (uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return totalBorrows;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        return totalBorrowsNew;
    }

    /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
    /// @param account The address whose balance should be calculated after updating borrowIndex
    /// @return The calculated balance
    function borrowBalanceCurrent(address account) external view override returns (uint) {
        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();
        require(err0 == MathError.NO_ERROR, "calc borrow index fail");
        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
        require(err1 == MathError.NO_ERROR, "calc fail");
        return result;
    }

    function borrowBalanceStored(address account) external override view returns (uint){
        return accountBorrows[account].principal;
    }


    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
    }

    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /// @notice Accrue interest then return the up-to-date exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateCurrent() public override nonReentrant returns (uint) {
        accrueInterest();
        return exchangeRateStored();
    }

    /// Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateStored() public override view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "calc fail");
        return result;
    }

    /// @notice Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return (error code, calculated exchange rate scaled by 1e18)
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        uint _totalSupply = totalSupply;
        if (_totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint _totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /// @notice Get cash balance of this cToken in the underlying asset
    /// @return The quantity of underlying asset owned by this contract
    function getCash() external override view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }

    function calCurrentBorrowIndex() internal view returns (MathError, uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;
        uint borrowIndexNew;
        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return (MathError.NO_ERROR, borrowIndex);
        }
        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);

        Exp memory simpleInterestFactor;
        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }
        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);
        return (mathErr, borrowIndexNew);
    }

    /// @notice Applies accrued interest to total borrows and reserves
    /// @dev This calculates interest accrued from the last checkpointed block
    ///   up to the current block and writes new checkpoint to storage.
    function accrueInterest() public override {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint borrowIndexPrior = borrowIndex;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");


        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;
        uint borrowIndexNew;
        uint totalReservesNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total reserves error');

        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);
        require(mathErr == MathError.NO_ERROR, 'calc borrows index error');


        /* We write the previously calculated values into storage */
        accrualBlockNumber = currentBlockNumber;
        borrowIndex = borrowIndexNew;
        totalBorrows = totalBorrowsNew;
        totalReserves = totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);

    }

    struct MintLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
        uint actualMintAmount;
    }

    /// @notice User supplies assets into the market and receives lTokens in exchange
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param minter The address of the account which is supplying the assets
    /// @param mintAmount The amount of the underlying asset to supply
    /// @return uint the actual mint amount.
    function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {
        MintLocalVars memory vars;
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /*
         *  We call `doTransferIn` for the minter and the mintAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if
         *  side-effects occurred. The function returns the amount actually transferred,
         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`
         *  of cash.
         */
        if (isDelegete) {
            uint balanceBefore = getCashPrior();
            LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);
            uint balanceAfter = getCashPrior();
            require(balanceAfter > balanceBefore, 'mint 0');
            vars.actualMintAmount = balanceAfter - balanceBefore;
        } else {
            vars.actualMintAmount = doTransferIn(minter, mintAmount, true);
        }
        /*
         * We get the current exchange rate and calculate the number of lTokens to be minted:
         *  mintTokens = actualMintAmount / exchangeRate
         */

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));
        require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");

        /* Fail if mint not allowed */
        (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);
        /*
         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */

        return vars.actualMintAmount;
    }


    struct RedeemLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /// @notice User redeems lTokens in exchange for the underlying asset
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param redeemer The address of the account which is redeeming the tokens
    /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');
            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');
        require(getCashPrior() >= vars.redeemAmount, 'cash < redeem');

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;
        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(redeemer, vars.redeemAmount, true);


        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
    }

    struct BorrowLocalVars {
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /// @notice Users borrow assets from the protocol to their own address
    /// @param borrowAmount The amount of the underlying asset to borrow
    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {
        /* Fail if borrow not allowed */
        (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);

        /* Fail gracefully if protocol has insufficient underlying cash */
        require(getCashPrior() >= borrowAmount, 'cash<borrow');

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(payee, borrowAmount, false);

        /* We emit a Borrow event */
        emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
    }

    struct RepayBorrowLocalVars {
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
        uint actualRepayAmount;
        uint badDebtsAmount;
    }

    /// @notice Borrows are repaid by another user (possibly the borrower).
    /// @param payer the account paying off the borrow
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount the amount of undelrying tokens being returned
    function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {
        /* Fail if repayBorrow not allowed */
        (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(- 1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }
        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);


        if (isEnd && vars.accountBorrows > vars.actualRepayAmount) {
            vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;
        }

        /*
        *  We calculate the new borrower and total borrow balances, failing on underflow:
        *  accountBorrowsNew = accountBorrows - repayAmount
        *  totalBorrowsNew = totalBorrows - repayAmount
        */
        if (vars.accountBorrows < vars.actualRepayAmount) {
            require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) <= 105e16, 'repay more than 5%');
            vars.accountBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.accountBorrowsNew = 0;
            } else {
                vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;
            }
        }
        //Avoid mantissa errors
        if (vars.actualRepayAmount > totalBorrows) {
            vars.totalBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);
            } else {
                vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;
            }
        }

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */

        return vars.actualRepayAmount;
    }

    /*** Admin Functions ***/

    /// @notice Sets a new CONTROLLER for the market
    /// @dev Admin function to set a new controller
    function setController(address newController) external override onlyAdmin {
        require(address(0) != newController, "0x");
        address oldController = controller;
        controller = newController;
        // Emit NewController(oldController, newController)
        emit NewController(oldController, newController);
    }

    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {
        require(newBorrowCapFactorMantissa <= 1e18, 'Factor too large');
        uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;
        borrowCapFactorMantissa = newBorrowCapFactorMantissa;
        emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa);
    }

    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {
        //accrueInterest except first
        if (baseRatePerBlock != 0) {
            accrueInterest();
        }
        // total rate perYear < 2000%
        require(baseRatePerBlock_ < 1e13, 'Base rate too large');
        baseRatePerBlock = baseRatePerBlock_;
        require(multiplierPerBlock_ < 1e13, 'Mul rate too large');
        multiplierPerBlock = multiplierPerBlock_;
        require(jumpMultiplierPerBlock_ < 1e13, 'Jump rate too large');
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        require(kink_ <= 1e18, 'Kline too large');
        kink = kink_;
        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);
    }

    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {
        require(newReserveFactorMantissa <= 1e18, 'Factor too large');
        accrueInterest();
        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;
        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);
    }

    function addReserves(uint addAmount) external override nonReentrant {
        accrueInterest();
        uint totalReservesNew;
        uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);
        totalReservesNew = totalReserves.add(actualAddAmount);
        totalReserves = totalReservesNew;
        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);
    }

    function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {
        accrueInterest();
        uint totalReservesNew;
        totalReservesNew = totalReserves.sub(reduceAmount);
        totalReserves = totalReservesNew;
        doTransferOut(to, reduceAmount, true);
        emit ReservesReduced(to, reduceAmount, totalReservesNew);
    }

    modifier sameBlock() {
        require(accrualBlockNumber == getBlockNumber(), 'not same block');
        _;
    }
}

.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-24-08 19:28:38 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-24-08 19:28:38 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 10001
completion_tokens: 726
total_tokens: 10727
cost: $-1.000000


[2024-24-08 19:28:38 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;


import "./LPoolInterface.sol";
import "./LPoolDepositor.sol";
import "../lib/Exponential.sol";
import "../Adminable.sol";
import "../lib/CarefulMath.sol";
import "../lib/TransferHelper.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import "../DelegateInterface.sol";
import "../ControllerInterface.sol";
import "../IWETH.sol";

/// @title OpenLeverage's LToken Contract
/// @dev Abstract base for LTokens
/// @author OpenLeverage
contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {
    using TransferHelper for IERC20;
    using SafeMath for uint;

    constructor() {

    }
    
    /// @notice Initialize the money market
    /// @param controller_ The address of the Controller
    /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0
    /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate
    /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point
    /// @param kink_ The utilization point at which the jump multiplier is applied
    /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
    /// @param name_ EIP-20 name of this token
    /// @param symbol_ EIP-20 symbol of this token
    /// @param decimals_ EIP-20 decimal precision of this token
    function initialize(
        address underlying_,
        bool isWethPool_,
        address controller_,
        uint256 baseRatePerBlock_,
        uint256 multiplierPerBlock_,
        uint256 jumpMultiplierPerBlock_,
        uint256 kink_,
        uint initialExchangeRateMantissa_,
        string memory name_,
        string memory symbol_,
        uint8 decimals_) public {
        require(underlying_ != address(0), "underlying_ address cannot be 0");
        require(controller_ != address(0), "controller_ address cannot be 0");
        require(msg.sender == admin, "Only allow to be called by admin");
        require(accrualBlockNumber == 0 && borrowIndex == 0, "inited once");

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial Exchange Rate Mantissa should be greater zero");
        //set controller
        controller = controller_;
        isWethPool = isWethPool_;
        //set interestRateModel
        baseRatePerBlock = baseRatePerBlock_;
        multiplierPerBlock = multiplierPerBlock_;
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        kink = kink_;

        // Initialize block number and borrow index (block number mocks depend on controller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = 1e25;
        //80%
        borrowCapFactorMantissa = 0.8e18;
        //10%
        reserveFactorMantissa = 0.1e18;


        name = name_;
        symbol = symbol_;
        decimals = decimals_;

        _notEntered = true;

        // Set underlying and sanity check it
        underlying = underlying_;
        IERC20(underlying).totalSupply();
        emit Transfer(address(0), msg.sender, 0);
    }

    /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
    /// @dev Called by both `transfer` and `transferFrom` internally
    /// @param spender The address of the account performing the transfer
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param tokens The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {
        require(dst != address(0), "dst address cannot be 0");
        /* Do not allow self-transfers */
        require(src != dst, "src = dst");
        /* Fail if transfer not allowed */
        (ControllerInterface(controller)).transferAllowed(src, dst, tokens);

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(- 1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        require(mathErr == MathError.NO_ERROR, 'not allowed');

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        require(mathErr == MathError.NO_ERROR, 'not enough');

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        require(mathErr == MathError.NO_ERROR, 'too much');

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(- 1)) {
            transferAllowances[src][spender] = allowanceNew;
        }
        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);
        return true;
    }

    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount);
    }

    /// @notice Transfer `amount` tokens from `src` to `dst`
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount);
    }

    /// @notice Approve `spender` to transfer up to `amount` from `src`
    /// @dev This will overwrite the approval amount for `spender`
    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
    /// @param spender The address of the account which may transfer tokens
    /// @param amount The number of tokens that are approved (-1 means infinite)
    /// @return Whether or not the approval succeeded
    function approve(address spender, uint256 amount) external override returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /// @notice Get the current allowance from `owner` for `spender`
    /// @param owner The address of the account which owns the tokens to be spent
    /// @param spender The address of the account which may transfer tokens
    /// @return The number of tokens allowed to be spent (-1 means infinite)
    function allowance(address owner, address spender) external override view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /// @notice Get the token balance of the `owner`
    /// @param owner The address of the account to query
    /// @return The number of tokens owned by `owner`
    function balanceOf(address owner) external override view returns (uint256) {
        return accountTokens[owner];
    }

    /// @notice Get the underlying balance of the `owner`
    /// @dev This also accrues interest in a transaction
    /// @param owner The address of the account to query
    /// @return The amount of underlying owned by `owner`
    function balanceOfUnderlying(address owner) external override returns (uint) {
        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR, "calc failed");
        return balance;
    }

    /*** User Interface ***/

    /// @notice Sender supplies assets into the market and receives lTokens in exchange
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param mintAmount The amount of the underlying asset to supply
    function mint(uint mintAmount) external override nonReentrant {
        accrueInterest();
        mintFresh(msg.sender, mintAmount, false);
    }

    function mintTo(address to, uint amount) external payable override nonReentrant {
        accrueInterest();
        if (isWethPool) {
            mintFresh(to, msg.value, false);
        } else {
            mintFresh(to, amount, true);
        }
    }

    function mintEth() external payable override nonReentrant {
        require(isWethPool, "not eth pool");
        accrueInterest();
        mintFresh(msg.sender, msg.value, false);
    }

    /// @notice Sender redeems lTokens in exchange for the underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemTokens The number of lTokens to redeem into underlying
    function redeem(uint redeemTokens) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, redeemTokens, 0);
    }

    /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemAmount The amount of underlying to redeem
    function redeemUnderlying(uint redeemAmount) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, 0, redeemAmount);
    }

    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {
        accrueInterest();
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        borrowFresh(payable(borrower), msg.sender, borrowAmount);
    }

    /// @notice Sender repays a borrow belonging to borrower
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount The amount to repay
    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        repayBorrowFresh(msg.sender, borrower, repayAmount, false);
    }

    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        repayBorrowFresh(msg.sender, borrower, repayAmount, true);
    }


    /*** Safe Token ***/

    /// Gets balance of this contract in terms of the underlying
    /// @dev This excludes the value of the current message, if any
    /// @return The quantity of underlying tokens owned by this contract
    function getCashPrior() internal view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }


    /**
     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.
     *      This will revert due to insufficient balance or insufficient allowance.
     *      This function returns the actual amount received,
     *      which may be less than `amount` if there is a fee attached to the transfer.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {
        if (isWethPool && convertWeth) {
            actualAmount = msg.value;
            IWETH(underlying).deposit{value : actualAmount}();
        } else {
            actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);
        }
    }

    /**
     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory
     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to
     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified
     *      it is >= amount, this should not revert in normal conditions.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {
        if (isWethPool && convertWeth) {
            IWETH(underlying).withdraw(amount);
            to.transfer(amount);
        } else {
            IERC20(underlying).safeTransfer(to, amount);
        }
    }

    function availableForBorrow() external view override returns (uint){
        uint cash = getCashPrior();
        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);
        if (err0 != MathError.NO_ERROR) {
            return 0;
        }
        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);
        if (err1 != MathError.NO_ERROR) {
            return 0;
        }
        if (totalBorrows > maxAvailable) {
            return 0;
        }
        return maxAvailable - totalBorrows;
    }


    /// @notice Get a snapshot of the account's balances, and the cached exchange rate
    /// @dev This is used by controller to more efficiently perform liquidity checks.
    /// @param account Address of the account to snapshot
    /// @return ( token balance, borrow balance, exchange rate mantissa)
    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        return (cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /// @dev Function to simply retrieve block number
    ///  This exists mainly for inheriting test contracts to stub this result.
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /// @notice Returns the current per-block borrow interest rate for this cToken
    /// @return The borrow interest rate per block, scaled by 1e18
    function borrowRatePerBlock() external override view returns (uint) {
        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
    }

    
    /// @notice Returns the current per-block supply interest rate for this cToken
    /// @return The supply interest rate per block, scaled by 1e18
    function supplyRatePerBlock() external override view returns (uint) {
        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);
    }

    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {
        // Utilization rate is 0 when there are no borrows
        if (borrows == 0) {
            return 0;
        }
        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));
    }

    /// @notice Calculates the current borrow rate per block, with the error code expected by the market
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18)
    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {
        uint util = utilizationRate(cash, borrows, reserves);
        if (util <= kink) {
            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
        } else {
            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
            uint excessUtil = util.sub(kink);
            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);
        }
    }

    /// @notice Calculates the current supply rate per block
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The supply rate percentage per block as a mantissa (scaled by 1e18)
    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {
        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);
        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);
        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);
        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);
    }

    /// @notice Returns the current total borrows plus accrued interest
    /// @return The total borrows with interest
    function totalBorrowsCurrent() external override view returns (uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return totalBorrows;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        return totalBorrowsNew;
    }

    /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
    /// @param account The address whose balance should be calculated after updating borrowIndex
    /// @return The calculated balance
    function borrowBalanceCurrent(address account) external view override returns (uint) {
        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();
        require(err0 == MathError.NO_ERROR, "calc borrow index fail");
        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
        require(err1 == MathError.NO_ERROR, "calc fail");
        return result;
    }

    function borrowBalanceStored(address account) external override view returns (uint){
        return accountBorrows[account].principal;
    }


    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
    }

    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /// @notice Accrue interest then return the up-to-date exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateCurrent() public override nonReentrant returns (uint) {
        accrueInterest();
        return exchangeRateStored();
    }

    /// Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateStored() public override view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "calc fail");
        return result;
    }

    /// @notice Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return (error code, calculated exchange rate scaled by 1e18)
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        uint _totalSupply = totalSupply;
        if (_totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint _totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /// @notice Get cash balance of this cToken in the underlying asset
    /// @return The quantity of underlying asset owned by this contract
    function getCash() external override view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }

    function calCurrentBorrowIndex() internal view returns (MathError, uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;
        uint borrowIndexNew;
        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return (MathError.NO_ERROR, borrowIndex);
        }
        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);

        Exp memory simpleInterestFactor;
        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }
        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);
        return (mathErr, borrowIndexNew);
    }

    /// @notice Applies accrued interest to total borrows and reserves
    /// @dev This calculates interest accrued from the last checkpointed block
    ///   up to the current block and writes new checkpoint to storage.
    function accrueInterest() public override {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint borrowIndexPrior = borrowIndex;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");


        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;
        uint borrowIndexNew;
        uint totalReservesNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total reserves error');

        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);
        require(mathErr == MathError.NO_ERROR, 'calc borrows index error');


        /* We write the previously calculated values into storage */
        accrualBlockNumber = currentBlockNumber;
        borrowIndex = borrowIndexNew;
        totalBorrows = totalBorrowsNew;
        totalReserves = totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);

    }

    struct MintLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
        uint actualMintAmount;
    }

    /// @notice User supplies assets into the market and receives lTokens in exchange
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param minter The address of the account which is supplying the assets
    /// @param mintAmount The amount of the underlying asset to supply
    /// @return uint the actual mint amount.
    function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {
        MintLocalVars memory vars;
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /*
         *  We call `doTransferIn` for the minter and the mintAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if
         *  side-effects occurred. The function returns the amount actually transferred,
         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`
         *  of cash.
         */
        if (isDelegete) {
            uint balanceBefore = getCashPrior();
            LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);
            uint balanceAfter = getCashPrior();
            require(balanceAfter > balanceBefore, 'mint 0');
            vars.actualMintAmount = balanceAfter - balanceBefore;
        } else {
            vars.actualMintAmount = doTransferIn(minter, mintAmount, true);
        }
        /*
         * We get the current exchange rate and calculate the number of lTokens to be minted:
         *  mintTokens = actualMintAmount / exchangeRate
         */

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));
        require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");

        /* Fail if mint not allowed */
        (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);
        /*
         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */

        return vars.actualMintAmount;
    }


    struct RedeemLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /// @notice User redeems lTokens in exchange for the underlying asset
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param redeemer The address of the account which is redeeming the tokens
    /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');
            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');
        require(getCashPrior() >= vars.redeemAmount, 'cash < redeem');

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;
        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(redeemer, vars.redeemAmount, true);


        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
    }

    struct BorrowLocalVars {
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /// @notice Users borrow assets from the protocol to their own address
    /// @param borrowAmount The amount of the underlying asset to borrow
    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {
        /* Fail if borrow not allowed */
        (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);

        /* Fail gracefully if protocol has insufficient underlying cash */
        require(getCashPrior() >= borrowAmount, 'cash<borrow');

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(payee, borrowAmount, false);

        /* We emit a Borrow event */
        emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
    }

    struct RepayBorrowLocalVars {
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
        uint actualRepayAmount;
        uint badDebtsAmount;
    }

    /// @notice Borrows are repaid by another user (possibly the borrower).
    /// @param payer the account paying off the borrow
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount the amount of undelrying tokens being returned
    function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {
        /* Fail if repayBorrow not allowed */
        (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(- 1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }
        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);


        if (isEnd && vars.accountBorrows > vars.actualRepayAmount) {
            vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;
        }

        /*
        *  We calculate the new borrower and total borrow balances, failing on underflow:
        *  accountBorrowsNew = accountBorrows - repayAmount
        *  totalBorrowsNew = totalBorrows - repayAmount
        */
        if (vars.accountBorrows < vars.actualRepayAmount) {
            require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) <= 105e16, 'repay more than 5%');
            vars.accountBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.accountBorrowsNew = 0;
            } else {
                vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;
            }
        }
        //Avoid mantissa errors
        if (vars.actualRepayAmount > totalBorrows) {
            vars.totalBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);
            } else {
                vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;
            }
        }

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */

        return vars.actualRepayAmount;
    }

    /*** Admin Functions ***/

    /// @notice Sets a new CONTROLLER for the market
    /// @dev Admin function to set a new controller
    function setController(address newController) external override onlyAdmin {
        require(address(0) != newController, "0x");
        address oldController = controller;
        controller = newController;
        // Emit NewController(oldController, newController)
        emit NewController(oldController, newController);
    }

    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {
        require(newBorrowCapFactorMantissa <= 1e18, 'Factor too large');
        uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;
        borrowCapFactorMantissa = newBorrowCapFactorMantissa;
        emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa);
    }

    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {
        //accrueInterest except first
        if (baseRatePerBlock != 0) {
            accrueInterest();
        }
        // total rate perYear < 2000%
        require(baseRatePerBlock_ < 1e13, 'Base rate too large');
        baseRatePerBlock = baseRatePerBlock_;
        require(multiplierPerBlock_ < 1e13, 'Mul rate too large');
        multiplierPerBlock = multiplierPerBlock_;
        require(jumpMultiplierPerBlock_ < 1e13, 'Jump rate too large');
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        require(kink_ <= 1e18, 'Kline too large');
        kink = kink_;
        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);
    }

    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {
        require(newReserveFactorMantissa <= 1e18, 'Factor too large');
        accrueInterest();
        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;
        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);
    }

    function addReserves(uint addAmount) external override nonReentrant {
        accrueInterest();
        uint totalReservesNew;
        uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);
        totalReservesNew = totalReserves.add(actualAddAmount);
        totalReserves = totalReservesNew;
        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);
    }

    function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {
        accrueInterest();
        uint totalReservesNew;
        totalReservesNew = totalReserves.sub(reduceAmount);
        totalReserves = totalReservesNew;
        doTransferOut(to, reduceAmount, true);
        emit ReservesReduced(to, reduceAmount, totalReservesNew);
    }

    modifier sameBlock() {
        require(accrualBlockNumber == getBlockNumber(), 'not same block');
        _;
    }
}

.]

### Summary of Security Vulnerabilities in the LPool Smart Contract

1. **Reentrancy Vulnerability**: 
   - Although the contract uses `ReentrancyGuard`, there are several functions that could potentially be exploited if not properly guarded. Functions like `transferTokens`, `mint`, `redeem`, `borrowFresh`, and `repayBorrowFresh` should be carefully reviewed to ensure that they do not allow reentrant calls.

2. **Access Control Issues**:
   - The `initialize` function allows only the admin to set critical parameters. However, if the admin's private key is compromised, an attacker could gain control over the contract. There should be a mechanism to revoke or change admin privileges securely.

3. **Integer Overflow/Underflow**:
   - While the contract uses `SafeMath`, there are still areas where integer operations could lead to unexpected behavior if not handled correctly. For instance, the calculations in `availableForBorrow`, `accrueInterest`, and other financial calculations should be thoroughly audited to ensure they are safe from overflow/underflow.

4. **Improper Error Handling**:
   - The contract relies heavily on `require` statements for error handling. If any of these checks fail, it could lead to a loss of funds or unexpected behavior. It is essential to ensure that all error messages are clear and provide sufficient context for debugging.

5. **Gas Limit and Loops**:
   - Functions that involve loops or extensive calculations (e.g., `accrueInterest`, `mintFresh`, `redeemFresh`) could potentially run into gas limit issues, especially if the number of transactions or the size of data grows significantly. This could lead to denial of service.

6. **Lack of Event Emission**:
   - While the contract emits events for significant state changes, there are areas where events could be beneficial for tracking and auditing purposes. For example, events for successful transfers or approvals could enhance transparency.

7. **Potential for Flash Loan Attacks**:
   - The contract does not have mechanisms to prevent flash loan attacks, which could allow an attacker to manipulate the contract's state temporarily to their advantage. Implementing checks to mitigate this risk is crucial.

8. **Unrestricted Withdrawals**:
   - The `reduceReserves` function allows the admin to withdraw reserves without any checks on the current state of the contract. This could lead to a situation where the contract becomes underfunded, impacting its ability to fulfill user requests.

### Comprehensive Analysis Report

The LPool smart contract exhibits several security vulnerabilities that could be exploited if not addressed. The use of `ReentrancyGuard` is a positive step, but the potential for reentrancy still exists in various functions. Access control mechanisms need to be robust to prevent unauthorized access, especially concerning admin privileges.

While `SafeMath` is employed to mitigate overflow and underflow risks, careful scrutiny is necessary to ensure that all arithmetic operations are safe. The reliance on `require` statements for error handling could lead to significant issues if not managed properly, and the potential for gas limit issues in functions with loops must be considered.

The contract's event emission strategy could be improved to enhance transparency and facilitate auditing. Additionally, the absence of protections against flash loan attacks poses a risk that could be exploited by malicious actors.

In conclusion, while the LPool contract has a solid foundation, it requires a thorough security audit and the implementation of best practices to mitigate identified vulnerabilities. Addressing these issues will enhance the contract's security and reliability, ultimately protecting user funds and maintaining trust in the protocol.

[2024-24-08 19:28:38 INFO] **[Seminar Conclusion]**:

 ### Summary of Security Vulnerabilities in the LPool Smart Contract

1. **Reentrancy Vulnerability**: 
   - Although the contract uses `ReentrancyGuard`, there are several functions that could potentially be exploited if not properly guarded. Functions like `transferTokens`, `mint`, `redeem`, `borrowFresh`, and `repayBorrowFresh` should be carefully reviewed to ensure that they do not allow reentrant calls.

2. **Access Control Issues**:
   - The `initialize` function allows only the admin to set critical parameters. However, if the admin's private key is compromised, an attacker could gain control over the contract. There should be a mechanism to revoke or change admin privileges securely.

3. **Integer Overflow/Underflow**:
   - While the contract uses `SafeMath`, there are still areas where integer operations could lead to unexpected behavior if not handled correctly. For instance, the calculations in `availableForBorrow`, `accrueInterest`, and other financial calculations should be thoroughly audited to ensure they are safe from overflow/underflow.

4. **Improper Error Handling**:
   - The contract relies heavily on `require` statements for error handling. If any of these checks fail, it could lead to a loss of funds or unexpected behavior. It is essential to ensure that all error messages are clear and provide sufficient context for debugging.

5. **Gas Limit and Loops**:
   - Functions that involve loops or extensive calculations (e.g., `accrueInterest`, `mintFresh`, `redeemFresh`) could potentially run into gas limit issues, especially if the number of transactions or the size of data grows significantly. This could lead to denial of service.

6. **Lack of Event Emission**:
   - While the contract emits events for significant state changes, there are areas where events could be beneficial for tracking and auditing purposes. For example, events for successful transfers or approvals could enhance transparency.

7. **Potential for Flash Loan Attacks**:
   - The contract does not have mechanisms to prevent flash loan attacks, which could allow an attacker to manipulate the contract's state temporarily to their advantage. Implementing checks to mitigate this risk is crucial.

8. **Unrestricted Withdrawals**:
   - The `reduceReserves` function allows the admin to withdraw reserves without any checks on the current state of the contract. This could lead to a situation where the contract becomes underfunded, impacting its ability to fulfill user requests.

### Comprehensive Analysis Report

The LPool smart contract exhibits several security vulnerabilities that could be exploited if not addressed. The use of `ReentrancyGuard` is a positive step, but the potential for reentrancy still exists in various functions. Access control mechanisms need to be robust to prevent unauthorized access, especially concerning admin privileges.

While `SafeMath` is employed to mitigate overflow and underflow risks, careful scrutiny is necessary to ensure that all arithmetic operations are safe. The reliance on `require` statements for error handling could lead to significant issues if not managed properly, and the potential for gas limit issues in functions with loops must be considered.

The contract's event emission strategy could be improved to enhance transparency and facilitate auditing. Additionally, the absence of protections against flash loan attacks poses a risk that could be exploited by malicious actors.

In conclusion, while the LPool contract has a solid foundation, it requires a thorough security audit and the implementation of best practices to mitigate identified vulnerabilities. Addressing these issues will enhance the contract's security and reliability, ultimately protecting user funds and maintaining trust in the protocol.

[2024-24-08 19:28:38 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-24-08 19:28:38 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.7.6; import "./LPoolInterface.sol"; import "./LPoolDepositor.sol"; import "../lib/Exponential.sol"; import "../Adminable.sol"; import "../lib/CarefulMath.sol"; import "../lib/TransferHelper.sol"; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import "../DelegateInterface.sol"; import "../ControllerInterface.sol"; import "../IWETH.sol"; /// @title OpenLeverage's LToken Contract /// @dev Abstract base for LTokens /// @author OpenLeverage contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {     using TransferHelper for IERC20;     using SafeMath for uint; constructor() {  }  /// @notice Initialize the money market /// @param controller_ The address of the Controller /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0 /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point /// @param kink_ The utilization point at which the jump multiplier is applied /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18 /// @param name_ EIP-20 name of this token /// @param symbol_ EIP-20 symbol of this token /// @param decimals_ EIP-20 decimal precision of this token function initialize(     address underlying_,     bool isWethPool_,     address controller_,     uint256 baseRatePerBlock_,     uint256 multiplierPerBlock_,     uint256 jumpMultiplierPerBlock_,     uint256 kink_,     uint initialExchangeRateMantissa_,     string memory name_,     string memory symbol_,     uint8 decimals_) public {     require(underlying_ != address(0), "underlying_ address cannot be 0");     require(controller_ != address(0), "controller_ address cannot be 0");     require(msg.sender == admin, "Only allow to be called by admin");     require(accrualBlockNumber == 0 &amp;&amp; borrowIndex == 0, "inited once");      // Set initial exchange rate     initialExchangeRateMantissa = initialExchangeRateMantissa_;     require(initialExchangeRateMantissa &gt; 0, "Initial Exchange Rate Mantissa should be greater zero");     //set controller     controller = controller_;     isWethPool = isWethPool_;     //set interestRateModel     baseRatePerBlock = baseRatePerBlock_;     multiplierPerBlock = multiplierPerBlock_;     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     kink = kink_;      // Initialize block number and borrow index (block number mocks depend on controller being set)     accrualBlockNumber = getBlockNumber();     borrowIndex = 1e25;     //80%     borrowCapFactorMantissa = 0.8e18;     //10%     reserveFactorMantissa = 0.1e18;       name = name_;     symbol = symbol_;     decimals = decimals_;      _notEntered = true;      // Set underlying and sanity check it     underlying = underlying_;     IERC20(underlying).totalSupply();     emit Transfer(address(0), msg.sender, 0); }  /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender` /// @dev Called by both `transfer` and `transferFrom` internally /// @param spender The address of the account performing the transfer /// @param src The address of the source account /// @param dst The address of the destination account /// @param tokens The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {     require(dst != address(0), "dst address cannot be 0");     /* Do not allow self-transfers */     require(src != dst, "src = dst");     /* Fail if transfer not allowed */     (ControllerInterface(controller)).transferAllowed(src, dst, tokens);      /* Get the allowance, infinite for the account owner */     uint startingAllowance = 0;     if (spender == src) {         startingAllowance = uint(- 1);     } else {         startingAllowance = transferAllowances[src][spender];     }      /* Do the calculations, checking for {under,over}flow */     MathError mathErr;     uint allowanceNew;     uint srcTokensNew;     uint dstTokensNew;      (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);     require(mathErr == MathError.NO_ERROR, 'not allowed');      (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);     require(mathErr == MathError.NO_ERROR, 'not enough');      (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);     require(mathErr == MathError.NO_ERROR, 'too much');      accountTokens[src] = srcTokensNew;     accountTokens[dst] = dstTokensNew;      /* Eat some of the allowance (if necessary) */     if (startingAllowance != uint(- 1)) {         transferAllowances[src][spender] = allowanceNew;     }     /* We emit a Transfer event */     emit Transfer(src, dst, tokens);     return true; }  /// @notice Transfer `amount` tokens from `msg.sender` to `dst` /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, msg.sender, dst, amount); }  /// @notice Transfer `amount` tokens from `src` to `dst` /// @param src The address of the source account /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, src, dst, amount); }  /// @notice Approve `spender` to transfer up to `amount` from `src` /// @dev This will overwrite the approval amount for `spender` ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve) /// @param spender The address of the account which may transfer tokens /// @param amount The number of tokens that are approved (-1 means infinite) /// @return Whether or not the approval succeeded function approve(address spender, uint256 amount) external override returns (bool) {     address src = msg.sender;     transferAllowances[src][spender] = amount;     emit Approval(src, spender, amount);     return true; }  /// @notice Get the current allowance from `owner` for `spender` /// @param owner The address of the account which owns the tokens to be spent /// @param spender The address of the account which may transfer tokens /// @return The number of tokens allowed to be spent (-1 means infinite) function allowance(address owner, address spender) external override view returns (uint256) {     return transferAllowances[owner][spender]; }  /// @notice Get the token balance of the `owner` /// @param owner The address of the account to query /// @return The number of tokens owned by `owner` function balanceOf(address owner) external override view returns (uint256) {     return accountTokens[owner]; }  /// @notice Get the underlying balance of the `owner` /// @dev This also accrues interest in a transaction /// @param owner The address of the account to query /// @return The amount of underlying owned by `owner` function balanceOfUnderlying(address owner) external override returns (uint) {     Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});     (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);     require(mErr == MathError.NO_ERROR, "calc failed");     return balance; }  /*** User Interface ***/  /// @notice Sender supplies assets into the market and receives lTokens in exchange /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param mintAmount The amount of the underlying asset to supply function mint(uint mintAmount) external override nonReentrant {     accrueInterest();     mintFresh(msg.sender, mintAmount, false); }  function mintTo(address to, uint amount) external payable override nonReentrant {     accrueInterest();     if (isWethPool) {         mintFresh(to, msg.value, false);     } else {         mintFresh(to, amount, true);     } }  function mintEth() external payable override nonReentrant {     require(isWethPool, "not eth pool");     accrueInterest();     mintFresh(msg.sender, msg.value, false); }  /// @notice Sender redeems lTokens in exchange for the underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemTokens The number of lTokens to redeem into underlying function redeem(uint redeemTokens) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, redeemTokens, 0); }  /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemAmount The amount of underlying to redeem function redeemUnderlying(uint redeemAmount) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, 0, redeemAmount); }  function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {     accrueInterest();     // borrowFresh emits borrow-specific logs on errors, so we don't need to     borrowFresh(payable(borrower), msg.sender, borrowAmount); }  /// @notice Sender repays a borrow belonging to borrower /// @param borrower the account with the debt being payed off /// @param repayAmount The amount to repay function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     repayBorrowFresh(msg.sender, borrower, repayAmount, false); }  function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     repayBorrowFresh(msg.sender, borrower, repayAmount, true); }   /*** Safe Token ***/  /// Gets balance of this contract in terms of the underlying /// @dev This excludes the value of the current message, if any /// @return The quantity of underlying tokens owned by this contract function getCashPrior() internal view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }   /**  * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.  *      This will revert due to insufficient balance or insufficient allowance.  *      This function returns the actual amount received,  *      which may be less than `amount` if there is a fee attached to the transfer.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {     if (isWethPool &amp;&amp; convertWeth) {         actualAmount = msg.value;         IWETH(underlying).deposit{value : actualAmount}();     } else {         actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);     } }  /**  * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory  *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to  *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified  *      it is &gt;= amount, this should not revert in normal conditions.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferOut(address payable to, uint amount, bool convertWeth) internal {     if (isWethPool &amp;&amp; convertWeth) {         IWETH(underlying).withdraw(amount);         to.transfer(amount);     } else {         IERC20(underlying).safeTransfer(to, amount);     } }  function availableForBorrow() external view override returns (uint){     uint cash = getCashPrior();     (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);     if (err0 != MathError.NO_ERROR) {         return 0;     }     (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);     if (err1 != MathError.NO_ERROR) {         return 0;     }     if (totalBorrows &gt; maxAvailable) {         return 0;     }     return maxAvailable - totalBorrows; }   /// @notice Get a snapshot of the account's balances, and the cached exchange rate /// @dev This is used by controller to more efficiently perform liquidity checks. /// @param account Address of the account to snapshot /// @return ( token balance, borrow balance, exchange rate mantissa) function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {     uint cTokenBalance = accountTokens[account];     uint borrowBalance;     uint exchangeRateMantissa;      MathError mErr;      (mErr, borrowBalance) = borrowBalanceStoredInternal(account);     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      return (cTokenBalance, borrowBalance, exchangeRateMantissa); }  /// @dev Function to simply retrieve block number ///  This exists mainly for inheriting test contracts to stub this result. function getBlockNumber() internal view returns (uint) {     return block.number; }  /// @notice Returns the current per-block borrow interest rate for this cToken /// @return The borrow interest rate per block, scaled by 1e18 function borrowRatePerBlock() external override view returns (uint) {     return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves); }   /// @notice Returns the current per-block supply interest rate for this cToken /// @return The supply interest rate per block, scaled by 1e18 function supplyRatePerBlock() external override view returns (uint) {     return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa); }  function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {     // Utilization rate is 0 when there are no borrows     if (borrows == 0) {         return 0;     }     return borrows.mul(1e18).div(cash.add(borrows).sub(reserves)); }  /// @notice Calculates the current borrow rate per block, with the error code expected by the market /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18) function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {     uint util = utilizationRate(cash, borrows, reserves);     if (util &lt;= kink) {         return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);     } else {         uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);         uint excessUtil = util.sub(kink);         return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);     } }  /// @notice Calculates the current supply rate per block /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The supply rate percentage per block as a mantissa (scaled by 1e18) function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {     uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);     uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);     uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);     return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18); }  /// @notice Returns the current total borrows plus accrued interest /// @return The total borrows with interest function totalBorrowsCurrent() external override view returns (uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return totalBorrows;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, "calc block delta erro");      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      return totalBorrowsNew; }  /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex /// @param account The address whose balance should be calculated after updating borrowIndex /// @return The calculated balance function borrowBalanceCurrent(address account) external view override returns (uint) {     (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();     require(err0 == MathError.NO_ERROR, "calc borrow index fail");     (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);     require(err1 == MathError.NO_ERROR, "calc fail");     return result; }  function borrowBalanceStored(address account) external override view returns (uint){     return accountBorrows[account].principal; }   /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {     return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex); }  /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {     /* Note: we do not assert that the market is up to date */     MathError mathErr;     uint principalTimesIndex;     uint result;      /* Get borrowBalance and borrowIndex */     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];      /* If borrowBalance = 0 then borrowIndex is likely also 0.      * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.      */     if (borrowSnapshot.principal == 0) {         return (MathError.NO_ERROR, 0);     }      /* Calculate new borrow balance using the interest index:      *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex      */     (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      return (MathError.NO_ERROR, result); }  /// @notice Accrue interest then return the up-to-date exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateCurrent() public override nonReentrant returns (uint) {     accrueInterest();     return exchangeRateStored(); }  /// Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateStored() public override view returns (uint) {     (MathError err, uint result) = exchangeRateStoredInternal();     require(err == MathError.NO_ERROR, "calc fail");     return result; }  /// @notice Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return (error code, calculated exchange rate scaled by 1e18) function exchangeRateStoredInternal() internal view returns (MathError, uint) {     uint _totalSupply = totalSupply;     if (_totalSupply == 0) {         /*          * If there are no tokens minted:          *  exchangeRate = initialExchangeRate          */         return (MathError.NO_ERROR, initialExchangeRateMantissa);     } else {         /*          * Otherwise:          *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply          */         uint _totalCash = getCashPrior();         uint cashPlusBorrowsMinusReserves;         Exp memory exchangeRate;         MathError mathErr;          (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          return (MathError.NO_ERROR, exchangeRate.mantissa);     } }  /// @notice Get cash balance of this cToken in the underlying asset /// @return The quantity of underlying asset owned by this contract function getCash() external override view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }  function calCurrentBorrowIndex() internal view returns (MathError, uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;     uint borrowIndexNew;     /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return (MathError.NO_ERROR, borrowIndex);     }     uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);      Exp memory simpleInterestFactor;     (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }     (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);     return (mathErr, borrowIndexNew); }  /// @notice Applies accrued interest to total borrows and reserves /// @dev This calculates interest accrued from the last checkpointed block ///   up to the current block and writes new checkpoint to storage. function accrueInterest() public override {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint borrowIndexPrior = borrowIndex;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, "calc block delta erro");       /*      * Calculate the interest accumulated into borrows and reserves and the new index:      *  simpleInterestFactor = borrowRate * blockDelta      *  interestAccumulated = simpleInterestFactor * totalBorrows      *  totalBorrowsNew = interestAccumulated + totalBorrows      *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex      */      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;     uint borrowIndexNew;     uint totalReservesNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);     require(mathErr == MathError.NO_ERROR, 'calc total reserves error');      (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);     require(mathErr == MathError.NO_ERROR, 'calc borrows index error');       /* We write the previously calculated values into storage */     accrualBlockNumber = currentBlockNumber;     borrowIndex = borrowIndexNew;     totalBorrows = totalBorrowsNew;     totalReserves = totalReservesNew;      /* We emit an AccrueInterest event */     emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);  }  struct MintLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint mintTokens;     uint totalSupplyNew;     uint accountTokensNew;     uint actualMintAmount; }  /// @notice User supplies assets into the market and receives lTokens in exchange /// @dev Assumes interest has already been accrued up to the current block /// @param minter The address of the account which is supplying the assets /// @param mintAmount The amount of the underlying asset to supply /// @return uint the actual mint amount. function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {     MintLocalVars memory vars;     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /*      *  We call `doTransferIn` for the minter and the mintAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if      *  side-effects occurred. The function returns the amount actually transferred,      *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`      *  of cash.      */     if (isDelegete) {         uint balanceBefore = getCashPrior();         LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);         uint balanceAfter = getCashPrior();         require(balanceAfter &gt; balanceBefore, 'mint 0');         vars.actualMintAmount = balanceAfter - balanceBefore;     } else {         vars.actualMintAmount = doTransferIn(minter, mintAmount, true);     }     /*      * We get the current exchange rate and calculate the number of lTokens to be minted:      *  mintTokens = actualMintAmount / exchangeRate      */      (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));     require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");      /* Fail if mint not allowed */     (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);     /*      * We calculate the new total supply of lTokens and minter token balance, checking for overflow:      *  totalSupplyNew = totalSupply + mintTokens      *  accountTokensNew = accountTokens[minter] + mintTokens      */     (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");      (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[minter] = vars.accountTokensNew;      /* We emit a Mint event, and a Transfer event */     emit Mint(minter, vars.actualMintAmount, vars.mintTokens);     emit Transfer(address(this), minter, vars.mintTokens);      /* We call the defense hook */      return vars.actualMintAmount; }   struct RedeemLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint redeemTokens;     uint redeemAmount;     uint totalSupplyNew;     uint accountTokensNew; }  /// @notice User redeems lTokens in exchange for the underlying asset /// @dev Assumes interest has already been accrued up to the current block /// @param redeemer The address of the account which is redeeming the tokens /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero) /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero) function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {     require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");      RedeemLocalVars memory vars;      /* exchangeRate = invoke Exchange Rate Stored() */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /* If redeemTokensIn &gt; 0: */     if (redeemTokensIn &gt; 0) {         /*          * We calculate the exchange rate and the amount of underlying to be redeemed:          *  redeemTokens = redeemTokensIn          *  redeemAmount = redeemTokensIn x exchangeRateCurrent          */         vars.redeemTokens = redeemTokensIn;          (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');     } else {         /*          * We get the current exchange rate and calculate the amount to be redeemed:          *  redeemTokens = redeemAmountIn / exchangeRate          *  redeemAmount = redeemAmountIn          */          (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');         vars.redeemAmount = redeemAmountIn;     }      /* Fail if redeem not allowed */     (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);      /*      * We calculate the new total supply and redeemer balance, checking for underflow:      *  totalSupplyNew = totalSupply - redeemTokens      *  accountTokensNew = accountTokens[redeemer] - redeemTokens      */     (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');      (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');     require(getCashPrior() &gt;= vars.redeemAmount, 'cash &lt; redeem');      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[redeemer] = vars.accountTokensNew;     /*      * We invoke doTransferOut for the redeemer and the redeemAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken has redeemAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(redeemer, vars.redeemAmount, true);       /* We emit a Transfer event, and a Redeem event */     emit Transfer(redeemer, address(this), vars.redeemTokens);     emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);      /* We call the defense hook */ }  struct BorrowLocalVars {     MathError mathErr;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /// @notice Users borrow assets from the protocol to their own address /// @param borrowAmount The amount of the underlying asset to borrow function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {     /* Fail if borrow not allowed */     (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);      /* Fail gracefully if protocol has insufficient underlying cash */     require(getCashPrior() &gt;= borrowAmount, 'cash&lt;borrow');      BorrowLocalVars memory vars;      /*      * We calculate the new borrower and total borrow balances, failing on overflow:      *  accountBorrowsNew = accountBorrows + borrowAmount      *  totalBorrowsNew = totalBorrows + borrowAmount      */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /*      * We invoke doTransferOut for the borrower and the borrowAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken borrowAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(payee, borrowAmount, false);      /* We emit a Borrow event */     emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */ }  struct RepayBorrowLocalVars {     MathError mathErr;     uint repayAmount;     uint borrowerIndex;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew;     uint actualRepayAmount;     uint badDebtsAmount; }  /// @notice Borrows are repaid by another user (possibly the borrower). /// @param payer the account paying off the borrow /// @param borrower the account with the debt being payed off /// @param repayAmount the amount of undelrying tokens being returned function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {     /* Fail if repayBorrow not allowed */     (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);      RepayBorrowLocalVars memory vars;      /* We remember the original borrowerIndex for verification purposes */     vars.borrowerIndex = accountBorrows[borrower].interestIndex;      /* We fetch the amount the borrower owes, with accumulated interest */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');      /* If repayAmount == -1, repayAmount = accountBorrows */     if (repayAmount == uint(- 1)) {         vars.repayAmount = vars.accountBorrows;     } else {         vars.repayAmount = repayAmount;     }     vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);       if (isEnd &amp;&amp; vars.accountBorrows &gt; vars.actualRepayAmount) {         vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;     }      /*     *  We calculate the new borrower and total borrow balances, failing on underflow:     *  accountBorrowsNew = accountBorrows - repayAmount     *  totalBorrowsNew = totalBorrows - repayAmount     */     if (vars.accountBorrows &lt; vars.actualRepayAmount) {         require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) &lt;= 105e16, 'repay more than 5%');         vars.accountBorrowsNew = 0;     } else {         if (isEnd) {             vars.accountBorrowsNew = 0;         } else {             vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;         }     }     //Avoid mantissa errors     if (vars.actualRepayAmount &gt; totalBorrows) {         vars.totalBorrowsNew = 0;     } else {         if (isEnd) {             vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);         } else {             vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;         }     }      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a RepayBorrow event */     emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */      return vars.actualRepayAmount; }  /*** Admin Functions ***/  /// @notice Sets a new CONTROLLER for the market /// @dev Admin function to set a new controller function setController(address newController) external override onlyAdmin {     require(address(0) != newController, "0x");     address oldController = controller;     controller = newController;     // Emit NewController(oldController, newController)     emit NewController(oldController, newController); }  function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {     require(newBorrowCapFactorMantissa &lt;= 1e18, 'Factor too large');     uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;     borrowCapFactorMantissa = newBorrowCapFactorMantissa;     emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa); }  function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {     //accrueInterest except first     if (baseRatePerBlock != 0) {         accrueInterest();     }     // total rate perYear &lt; 2000%     require(baseRatePerBlock_ &lt; 1e13, 'Base rate too large');     baseRatePerBlock = baseRatePerBlock_;     require(multiplierPerBlock_ &lt; 1e13, 'Mul rate too large');     multiplierPerBlock = multiplierPerBlock_;     require(jumpMultiplierPerBlock_ &lt; 1e13, 'Jump rate too large');     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     require(kink_ &lt;= 1e18, 'Kline too large');     kink = kink_;     emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_); }  function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {     require(newReserveFactorMantissa &lt;= 1e18, 'Factor too large');     accrueInterest();     uint oldReserveFactorMantissa = reserveFactorMantissa;     reserveFactorMantissa = newReserveFactorMantissa;     emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa); }  function addReserves(uint addAmount) external override nonReentrant {     accrueInterest();     uint totalReservesNew;     uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);     totalReservesNew = totalReserves.add(actualAddAmount);     totalReserves = totalReservesNew;     emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew); }  function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {     accrueInterest();     uint totalReservesNew;     totalReservesNew = totalReserves.sub(reduceAmount);     totalReserves = totalReservesNew;     doTransferOut(to, reduceAmount, true);     emit ReservesReduced(to, reduceAmount, totalReservesNew); }  modifier sameBlock() {     require(accrualBlockNumber == getBlockNumber(), 'not same block');     _; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.7.6;\n\n\nimport "./LPoolInterface.sol";\nimport "./LPoolDepositor.sol";\nimport "../lib/Exponential.sol";\nimport "../Adminable.sol";\nimport "../lib/CarefulMath.sol";\nimport "../lib/TransferHelper.sol";\nimport "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\n\nimport "../DelegateInterface.sol";\nimport "../ControllerInterface.sol";\nimport "../IWETH.sol";\n\n/// @title OpenLeverage\'s LToken Contract\n/// @dev Abstract base for LTokens\n/// @author OpenLeverage\ncontract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {\n    using TransferHelper for IERC20;\n    using SafeMath for uint;\n\n    constructor() {\n\n    }\n    \n    /// @notice Initialize the money market\n    /// @param controller_ The address of the Controller\n    /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0\n    /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate\n    /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point\n    /// @param kink_ The utilization point at which the jump multiplier is applied\n    /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n    /// @param name_ EIP-20 name of this token\n    /// @param symbol_ EIP-20 symbol of this token\n    /// @param decimals_ EIP-20 decimal precision of this token\n    function initialize(\n        address underlying_,\n        bool isWethPool_,\n        address controller_,\n        uint256 baseRatePerBlock_,\n        uint256 multiplierPerBlock_,\n        uint256 jumpMultiplierPerBlock_,\n        uint256 kink_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_) public {\n        require(underlying_ != address(0), "underlying_ address cannot be 0");\n        require(controller_ != address(0), "controller_ address cannot be 0");\n        require(msg.sender == admin, "Only allow to be called by admin");\n        require(accrualBlockNumber == 0 &amp;&amp; borrowIndex == 0, "inited once");\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa &gt; 0, "Initial Exchange Rate Mantissa should be greater zero");\n        //set controller\n        controller = controller_;\n        isWethPool = isWethPool_;\n        //set interestRateModel\n        baseRatePerBlock = baseRatePerBlock_;\n        multiplierPerBlock = multiplierPerBlock_;\n        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;\n        kink = kink_;\n\n        // Initialize block number and borrow index (block number mocks depend on controller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = 1e25;\n        //80%\n        borrowCapFactorMantissa = 0.8e18;\n        //10%\n        reserveFactorMantissa = 0.1e18;\n\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n\n        notEntered = true;\n\n        // Set underlying and sanity check it\n        underlying = underlying;\n        IERC20(underlying).totalSupply();\n        emit Transfer(address(0), msg.sender, 0);\n    }\n\n    /// @notice Transfer tokens tokens from src to dst by spender\n    /// @dev Called by both transfer and transferFrom internally\n    /// @param spender The address of the account performing the transfer\n    /// @param src The address of the source account\n    /// @param dst The address of the destination account\n    /// @param tokens The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {\n        require(dst != address(0), "dst address cannot be 0");\n        / Do not allow self-transfers /\n        require(src != dst, "src = dst");\n        / Fail if transfer not allowed /\n        (ControllerInterface(controller)).transferAllowed(src, dst, tokens);\n\n        / Get the allowance, infinite for the account owner /\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = uint(- 1);\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        / Do the calculations, checking for {under,over}flow /\n        MathError mathErr;\n        uint allowanceNew;\n        uint srcTokensNew;\n        uint dstTokensNew;\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n        require(mathErr == MathError.NO_ERROR, \'not allowed\');\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n        require(mathErr == MathError.NO_ERROR, \'not enough\');\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n        require(mathErr == MathError.NO_ERROR, \'too much\');\n\n        accountTokens[src] = srcTokensNew;\n        accountTokens[dst] = dstTokensNew;\n\n        / Eat some of the allowance (if necessary) /\n        if (startingAllowance != uint(- 1)) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n        / We emit a Transfer event /\n        emit Transfer(src, dst, tokens);\n        return true;\n    }\n\n    /// @notice Transfer amount tokens from msg.sender to dst\n    /// @param dst The address of the destination account\n    /// @param amount The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, msg.sender, dst, amount);\n    }\n\n    /// @notice Transfer amount tokens from src to dst\n    /// @param src The address of the source account\n    /// @param dst The address of the destination account\n    /// @param amount The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, src, dst, amount);\n    }\n\n    /// @notice Approve spender to transfer up to amount from src\n    /// @dev This will overwrite the approval amount for spender\n    ///  and is subject to issues noted here\n    /// @param spender The address of the account which may transfer tokens\n    /// @param amount The number of tokens that are approved (-1 means infinite)\n    /// @return Whether or not the approval succeeded\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /// @notice Get the current allowance from owner for spender\n    /// @param owner The address of the account which owns the tokens to be spent\n    /// @param spender The address of the account which may transfer tokens\n    /// @return The number of tokens allowed to be spent (-1 means infinite)\n    function allowance(address owner, address spender) external override view returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n\n    /// @notice Get the token balance of the owner\n    /// @param owner The address of the account to query\n    /// @return The number of tokens owned by owner\n    function balanceOf(address owner) external override view returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /// @notice Get the underlying balance of the owner\n    /// @dev This also accrues interest in a transaction\n    /// @param owner The address of the account to query\n    /// @return The amount of underlying owned by owner\n    function balanceOfUnderlying(address owner) external override returns (uint) {\n        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n        require(mErr == MathError.NO_ERROR, "calc failed");\n        return balance;\n    }\n\n    / User Interface /\n\n    /// @notice Sender supplies assets into the market and receives lTokens in exchange\n    /// @dev Accrues interest whether or not the operation succeeds, unless reverted\n    /// @param mintAmount The amount of the underlying asset to supply\n    function mint(uint mintAmount) external override nonReentrant {\n        accrueInterest();\n        mintFresh(msg.sender, mintAmount, false);\n    }\n\n    function mintTo(address to, uint amount) external payable override nonReentrant {\n        accrueInterest();\n        if (isWethPool) {\n            mintFresh(to, msg.value, false);\n        } else {\n            mintFresh(to, amount, true);\n        }\n    }\n\n    function mintEth() external payable override nonReentrant {\n        require(isWethPool, "not eth pool");\n        accrueInterest();\n        mintFresh(msg.sender, msg.value, false);\n    }\n\n    /// @notice Sender redeems lTokens in exchange for the underlying asset\n    /// @dev Accrues interest whether or not the operation succeeds, unless reverted\n    /// @param redeemTokens The number of lTokens to redeem into underlying\n    function redeem(uint redeemTokens) external override nonReentrant {\n        accrueInterest();\n        // redeemFresh emits redeem-specific logs on errors, so we don\'t need to\n        redeemFresh(msg.sender, redeemTokens, 0);\n    }\n\n    /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset\n    /// @dev Accrues interest whether or not the operation succeeds, unless reverted\n    /// @param redeemAmount The amount of underlying to redeem\n    function redeemUnderlying(uint redeemAmount) external override nonReentrant {\n        accrueInterest();\n        // redeemFresh emits redeem-specific logs on errors, so we don\'t need to\n        redeemFresh(msg.sender, 0, redeemAmount);\n    }\n\n    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {\n        accrueInterest();\n        // borrowFresh emits borrow-specific logs on errors, so we don\'t need to\n        borrowFresh(payable(borrower), msg.sender, borrowAmount);\n    }\n\n    /// @notice Sender repays a borrow belonging to borrower\n    /// @param borrower the account with the debt being payed off\n    /// @param repayAmount The amount to repay\n    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {\n        accrueInterest();\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don\'t need to\n        repayBorrowFresh(msg.sender, borrower, repayAmount, false);\n    }\n\n    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {\n        accrueInterest();\n        repayBorrowFresh(msg.sender, borrower, repayAmount, true);\n    }\n\n\n    / Safe Token /\n\n    /// Gets balance of this contract in terms of the underlying\n    /// @dev This excludes the value of the current message, if any\n    /// @return The quantity of underlying tokens owned by this contract\n    function getCashPrior() internal view returns (uint) {\n        return IERC20(underlying).balanceOf(address(this));\n    }\n\n\n    /\n     * @dev Similar to EIP20 transfer, except it handles a False result from transferFrom and reverts in that case.\n     *      This will revert due to insufficient balance or insufficient allowance.\n     *      This function returns the actual amount received,\n     *      which may be less than amount if there is a fee attached to the transfer.\n     \n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     /\n    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {\n        if (isWethPool &amp;&amp; convertWeth) {\n            actualAmount = msg.value;\n            IWETH(underlying).deposit{value : actualAmount}();\n        } else {\n            actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);\n        }\n    }\n\n    /\n     * @dev Similar to EIP20 transfer, except it handles a False success from transfer and returns an explanatory\n     *      error code rather than reverting. If caller has not called checked protocol\'s balance, this may revert due to\n     *      insufficient cash held in this contract. If caller has checked protocol\'s balance prior to this call, and verified\n     *      it is &gt;= amount, this should not revert in normal conditions.\n     \n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     /\n    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {\n        if (isWethPool &amp;&amp; convertWeth) {\n            IWETH(underlying).withdraw(amount);\n            to.transfer(amount);\n        } else {\n            IERC20(underlying).safeTransfer(to, amount);\n        }\n    }\n\n    function availableForBorrow() external view override returns (uint){\n        uint cash = getCashPrior();\n        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);\n        if (err0 != MathError.NO_ERROR) {\n            return 0;\n        }\n        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);\n        if (err1 != MathError.NO_ERROR) {\n            return 0;\n        }\n        if (totalBorrows &gt; maxAvailable) {\n            return 0;\n        }\n        return maxAvailable - totalBorrows;\n    }\n\n\n    /// @notice Get a snapshot of the account\'s balances, and the cached exchange rate\n    /// @dev This is used by controller to more efficiently perform liquidity checks.\n    /// @param account Address of the account to snapshot\n    /// @return ( token balance, borrow balance, exchange rate mantissa)\n    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {\n        uint cTokenBalance = accountTokens[account];\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n\n        MathError mErr;\n\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n        if (mErr != MathError.NO_ERROR) {\n            return (0, 0, 0);\n        }\n\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (mErr != MathError.NO_ERROR) {\n            return (0, 0, 0);\n        }\n\n        return (cTokenBalance, borrowBalance, exchangeRateMantissa);\n    }\n\n    /// @dev Function to simply retrieve block number\n    ///  This exists mainly for inheriting test contracts to stub this result.\n    function getBlockNumber() internal view returns (uint) {\n        return block.number;\n    }\n\n    /// @notice Returns the current per-block borrow interest rate for this cToken\n    /// @return The borrow interest rate per block, scaled by 1e18\n    function borrowRatePerBlock() external override view returns (uint) {\n        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);\n    }\n\n    \n    /// @notice Returns the current per-block supply interest rate for this cToken\n    /// @return The supply interest rate per block, scaled by 1e18\n    function supplyRatePerBlock() external override view returns (uint) {\n        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\n    }\n\n    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {\n        // Utilization rate is 0 when there are no borrows\n        if (borrows == 0) {\n            return 0;\n        }\n        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));\n    }\n\n    /// @notice Calculates the current borrow rate per block, with the error code expected by the market\n    /// @param cash The amount of cash in the market\n    /// @param borrows The amount of borrows in the market\n    /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\n    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {\n        uint util = utilizationRate(cash, borrows, reserves);\n        if (util &lt;= kink) {\n            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n        } else {\n            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n            uint excessUtil = util.sub(kink);\n            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);\n        }\n    }\n\n    /// @notice Calculates the current supply rate per block\n    /// @param cash The amount of cash in the market\n    /// @param borrows The amount of borrows in the market\n    /// @return The supply rate percentage per block as a mantissa (scaled by 1e18)\n    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {\n        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);\n        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);\n        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\n        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\n    }\n\n    /// @notice Returns the current total borrows plus accrued interest\n    /// @return The total borrows with interest\n    function totalBorrowsCurrent() external override view returns (uint) {\n        / Remember the initial block number /\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        / Short-circuit accumulating 0 interest /\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return totalBorrows;\n        }\n\n        / Read the previous values out of storage /\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint reservesPrior = totalReserves;\n\n        / Calculate the current borrow interest rate /\n        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");\n\n        / Calculate the number of blocks elapsed since the last accrual /\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        require(mathErr == MathError.NO_ERROR, "calc block delta erro");\n\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        require(mathErr == MathError.NO_ERROR, \'calc interest factor error\');\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc interest acc error\');\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc total borrows error\');\n\n        return totalBorrowsNew;\n    }\n\n    /// @notice Accrue interest to updated borrowIndex and then calculate account\'s borrow balance using the updated borrowIndex\n    /// @param account The address whose balance should be calculated after updating borrowIndex\n    /// @return The calculated balance\n    function borrowBalanceCurrent(address account) external view override returns (uint) {\n        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();\n        require(err0 == MathError.NO_ERROR, "calc borrow index fail");\n        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);\n        require(err1 == MathError.NO_ERROR, "calc fail");\n        return result;\n    }\n\n    function borrowBalanceStored(address account) external override view returns (uint){\n        return accountBorrows[account].principal;\n    }\n\n\n    /// @notice Return the borrow balance of account based on stored data\n    /// @param account The address whose balance should be calculated\n    /// @return (error code, the calculated balance or 0 if error code is non-zero)\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);\n    }\n\n    /// @notice Return the borrow balance of account based on stored data\n    /// @param account The address whose balance should be calculated\n    /// @return (error code, the calculated balance or 0 if error code is non-zero)\n    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {\n        / Note: we do not assert that the market is up to date /\n        MathError mathErr;\n        uint principalTimesIndex;\n        uint result;\n\n        / Get borrowBalance and borrowIndex /\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        / If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         /\n        if (borrowSnapshot.principal == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        / Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         /\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        return (MathError.NO_ERROR, result);\n    }\n\n    /// @notice Accrue interest then return the up-to-date exchange rate\n    /// @return Calculated exchange rate scaled by 1e18\n    function exchangeRateCurrent() public override nonReentrant returns (uint) {\n        accrueInterest();\n        return exchangeRateStored();\n    }\n\n    /// Calculates the exchange rate from the underlying to the LToken\n    /// @dev This function does not accrue interest before calculating the exchange rate\n    /// @return Calculated exchange rate scaled by 1e18\n    function exchangeRateStored() public override view returns (uint) {\n        (MathError err, uint result) = exchangeRateStoredInternal();\n        require(err == MathError.NO_ERROR, "calc fail");\n        return result;\n    }\n\n    /// @notice Calculates the exchange rate from the underlying to the LToken\n    /// @dev This function does not accrue interest before calculating the exchange rate\n    /// @return (error code, calculated exchange rate scaled by 1e18)\n    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n        uint _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            /\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             /\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\n        } else {\n            /\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             /\n            uint _totalCash = getCashPrior();\n            uint cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n            MathError mathErr;\n\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\n        }\n    }\n\n    /// @notice Get cash balance of this cToken in the underlying asset\n    /// @return The quantity of underlying asset owned by this contract\n    function getCash() external override view returns (uint) {\n        return IERC20(underlying).balanceOf(address(this));\n    }\n\n    function calCurrentBorrowIndex() internal view returns (MathError, uint) {\n        / Remember the initial block number /\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n        uint borrowIndexNew;\n        / Short-circuit accumulating 0 interest /\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return (MathError.NO_ERROR, borrowIndex);\n        }\n        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n\n        Exp memory simpleInterestFactor;\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);\n        return (mathErr, borrowIndexNew);\n    }\n\n    /// @notice Applies accrued interest to total borrows and reserves\n    /// @dev This calculates interest accrued from the last checkpointed block\n    ///   up to the current block and writes new checkpoint to storage.\n    function accrueInterest() public override {\n        / Remember the initial block number /\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        / Short-circuit accumulating 0 interest /\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return;\n        }\n\n        / Read the previous values out of storage /\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint borrowIndexPrior = borrowIndex;\n        uint reservesPrior = totalReserves;\n\n        / Calculate the current borrow interest rate /\n        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");\n\n        / Calculate the number of blocks elapsed since the last accrual /\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        require(mathErr == MathError.NO_ERROR, "calc block delta erro");\n\n\n        /\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         /\n\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n        uint borrowIndexNew;\n        uint totalReservesNew;\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        require(mathErr == MathError.NO_ERROR, \'calc interest factor error\');\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc interest acc error\');\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc total borrows error\');\n\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc total reserves error\');\n\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc borrows index error\');\n\n\n        / We write the previously calculated values into storage /\n        accrualBlockNumber = currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n        totalReserves = totalReservesNew;\n\n        / We emit an AccrueInterest event /\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n    }\n\n    struct MintLocalVars {\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint mintTokens;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n        uint actualMintAmount;\n    }\n\n    /// @notice User supplies assets into the market and receives lTokens in exchange\n    /// @dev Assumes interest has already been accrued up to the current block\n    /// @param minter The address of the account which is supplying the assets\n    /// @param mintAmount The amount of the underlying asset to supply\n    /// @return uint the actual mint amount.\n    function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {\n        MintLocalVars memory vars;\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, \'calc exchangerate error\');\n\n        /\n         *  We call doTransferIn for the minter and the mintAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  doTransferIn reverts if anything goes wrong, since we can\'t be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the cToken holds an additional actualMintAmount\n         *  of cash.\n         /\n        if (isDelegete) {\n            uint balanceBefore = getCashPrior();\n            LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);\n            uint balanceAfter = getCashPrior();\n            require(balanceAfter &gt; balanceBefore, \'mint 0\');\n            vars.actualMintAmount = balanceAfter - balanceBefore;\n        } else {\n            vars.actualMintAmount = doTransferIn(minter, mintAmount, true);\n        }\n        /\n         * We get the current exchange rate and calculate the number of lTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         /\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));\n        require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");\n\n        / Fail if mint not allowed /\n        (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);\n        /\n         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         /\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n        require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n        require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");\n\n        / We write previously calculated values into storage /\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[minter] = vars.accountTokensNew;\n\n        / We emit a Mint event, and a Transfer event /\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n        / We call the defense hook /\n\n        return vars.actualMintAmount;\n    }\n\n\n    struct RedeemLocalVars {\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint redeemTokens;\n        uint redeemAmount;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n    }\n\n    /// @notice User redeems lTokens in exchange for the underlying asset\n    /// @dev Assumes interest has already been accrued up to the current block\n    /// @param redeemer The address of the account which is redeeming the tokens\n    /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n    /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");\n\n        RedeemLocalVars memory vars;\n\n        / exchangeRate = invoke Exchange Rate Stored() /\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, \'calc exchangerate error\');\n\n        / If redeemTokensIn &gt; 0: /\n        if (redeemTokensIn &gt; 0) {\n            /\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             /\n            vars.redeemTokens = redeemTokensIn;\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);\n            require(vars.mathErr == MathError.NO_ERROR, \'calc redeem amount error\');\n        } else {\n            /\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             /\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));\n            require(vars.mathErr == MathError.NO_ERROR, \'calc redeem tokens error\');\n            vars.redeemAmount = redeemAmountIn;\n        }\n\n        / Fail if redeem not allowed /\n        (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);\n\n        /\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n         *  totalSupplyNew = totalSupply - redeemTokens\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n         /\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n        require(vars.mathErr == MathError.NO_ERROR, \'calc supply new error\');\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n        require(vars.mathErr == MathError.NO_ERROR, \'calc token new error\');\n        require(getCashPrior() &gt;= vars.redeemAmount, \'cash &lt; redeem\');\n\n        / We write previously calculated values into storage /\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[redeemer] = vars.accountTokensNew;\n        /\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken has redeemAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can\'t be sure if side effects occurred.\n         /\n        doTransferOut(redeemer, vars.redeemAmount, true);\n\n\n        / We emit a Transfer event, and a Redeem event /\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        / We call the defense hook /\n    }\n\n    struct BorrowLocalVars {\n        MathError mathErr;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n    }\n\n    /// @notice Users borrow assets from the protocol to their own address\n    /// @param borrowAmount The amount of the underlying asset to borrow\n    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {\n        / Fail if borrow not allowed /\n        (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);\n\n        / Fail gracefully if protocol has insufficient underlying cash /\n        require(getCashPrior() &gt;= borrowAmount, \'cash vars.actualRepayAmount) {\n            vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;\n        }\n\n        /\n        *  We calculate the new borrower and total borrow balances, failing on underflow:\n        *  accountBorrowsNew = accountBorrows - repayAmount\n        *  totalBorrowsNew = totalBorrows - repayAmount\n        /\n        if (vars.accountBorrows &lt; vars.actualRepayAmount) {\n            require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) &lt;= 105e16, \'repay more than 5%\');\n            vars.accountBorrowsNew = 0;\n        } else {\n            if (isEnd) {\n                vars.accountBorrowsNew = 0;\n            } else {\n                vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;\n            }\n        }\n        //Avoid mantissa errors\n        if (vars.actualRepayAmount &gt; totalBorrows) {\n            vars.totalBorrowsNew = 0;\n        } else {\n            if (isEnd) {\n                vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);\n            } else {\n                vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;\n            }\n        }\n\n        / We write the previously calculated values into storage /\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        / We emit a RepayBorrow event /\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        / We call the defense hook */\n\n        return vars.actualRepayAmount;\n    }\n\n    / Admin Functions ***/\n\n    /// @notice Sets a new CONTROLLER for the market\n    /// @dev Admin function to set a new controller\n    function setController(address newController) external override onlyAdmin {\n        require(address(0) != newController, "0x");\n        address oldController = controller;\n        controller = newController;\n        // Emit NewController(oldController, newController)\n        emit NewController(oldController, newController);\n    }\n\n    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {\n        require(newBorrowCapFactorMantissa &lt;= 1e18, \'Factor too large\');\n        uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;\n        borrowCapFactorMantissa = newBorrowCapFactorMantissa;\n        emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa);\n    }\n\n    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {\n        //accrueInterest except first\n        if (baseRatePerBlock != 0) {\n            accrueInterest();\n        }\n        // total rate perYear &lt; 2000%\n        require(baseRatePerBlock_ &lt; 1e13, \'Base rate too large\');\n        baseRatePerBlock = baseRatePerBlock_;\n        require(multiplierPerBlock_ &lt; 1e13, \'Mul rate too large\');\n        multiplierPerBlock = multiplierPerBlock_;\n        require(jumpMultiplierPerBlock_ &lt; 1e13, \'Jump rate too large\');\n        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;\n        require(kink_ &lt;= 1e18, \'Kline too large\');\n        kink = kink_;\n        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);\n    }\n\n    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {\n        require(newReserveFactorMantissa &lt;= 1e18, \'Factor too large\');\n        accrueInterest();\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n        reserveFactorMantissa = newReserveFactorMantissa;\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n    }\n\n    function addReserves(uint addAmount) external override nonReentrant {\n        accrueInterest();\n        uint totalReservesNew;\n        uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);\n        totalReservesNew = totalReserves.add(actualAddAmount);\n        totalReserves = totalReservesNew;\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n    }\n\n    function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {\n        accrueInterest();\n        uint totalReservesNew;\n        totalReservesNew = totalReserves.sub(reduceAmount);\n        totalReserves = totalReservesNew;\n        doTransferOut(to, reduceAmount, true);\n        emit ReservesReduced(to, reduceAmount, totalReservesNew);\n    }\n\n    modifier sameBlock() {\n        require(accrualBlockNumber == getBlockNumber(), \'not same block\');\n        _;\n    }\n}\n\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-24-08 19:28:38 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.7.6; import "./LPoolInterface.sol"; import "./LPoolDepositor.sol"; import "../lib/Exponential.sol"; import "../Adminable.sol"; import "../lib/CarefulMath.sol"; import "../lib/TransferHelper.sol"; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import "../DelegateInterface.sol"; import "../ControllerInterface.sol"; import "../IWETH.sol"; /// @title OpenLeverage's LToken Contract /// @dev Abstract base for LTokens /// @author OpenLeverage contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {     using TransferHelper for IERC20;     using SafeMath for uint; constructor() {  }  /// @notice Initialize the money market /// @param controller_ The address of the Controller /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0 /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point /// @param kink_ The utilization point at which the jump multiplier is applied /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18 /// @param name_ EIP-20 name of this token /// @param symbol_ EIP-20 symbol of this token /// @param decimals_ EIP-20 decimal precision of this token function initialize(     address underlying_,     bool isWethPool_,     address controller_,     uint256 baseRatePerBlock_,     uint256 multiplierPerBlock_,     uint256 jumpMultiplierPerBlock_,     uint256 kink_,     uint initialExchangeRateMantissa_,     string memory name_,     string memory symbol_,     uint8 decimals_) public {     require(underlying_ != address(0), "underlying_ address cannot be 0");     require(controller_ != address(0), "controller_ address cannot be 0");     require(msg.sender == admin, "Only allow to be called by admin");     require(accrualBlockNumber == 0 &amp;&amp; borrowIndex == 0, "inited once");      // Set initial exchange rate     initialExchangeRateMantissa = initialExchangeRateMantissa_;     require(initialExchangeRateMantissa &gt; 0, "Initial Exchange Rate Mantissa should be greater zero");     //set controller     controller = controller_;     isWethPool = isWethPool_;     //set interestRateModel     baseRatePerBlock = baseRatePerBlock_;     multiplierPerBlock = multiplierPerBlock_;     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     kink = kink_;      // Initialize block number and borrow index (block number mocks depend on controller being set)     accrualBlockNumber = getBlockNumber();     borrowIndex = 1e25;     //80%     borrowCapFactorMantissa = 0.8e18;     //10%     reserveFactorMantissa = 0.1e18;       name = name_;     symbol = symbol_;     decimals = decimals_;      _notEntered = true;      // Set underlying and sanity check it     underlying = underlying_;     IERC20(underlying).totalSupply();     emit Transfer(address(0), msg.sender, 0); }  /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender` /// @dev Called by both `transfer` and `transferFrom` internally /// @param spender The address of the account performing the transfer /// @param src The address of the source account /// @param dst The address of the destination account /// @param tokens The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {     require(dst != address(0), "dst address cannot be 0");     /* Do not allow self-transfers */     require(src != dst, "src = dst");     /* Fail if transfer not allowed */     (ControllerInterface(controller)).transferAllowed(src, dst, tokens);      /* Get the allowance, infinite for the account owner */     uint startingAllowance = 0;     if (spender == src) {         startingAllowance = uint(- 1);     } else {         startingAllowance = transferAllowances[src][spender];     }      /* Do the calculations, checking for {under,over}flow */     MathError mathErr;     uint allowanceNew;     uint srcTokensNew;     uint dstTokensNew;      (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);     require(mathErr == MathError.NO_ERROR, 'not allowed');      (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);     require(mathErr == MathError.NO_ERROR, 'not enough');      (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);     require(mathErr == MathError.NO_ERROR, 'too much');      accountTokens[src] = srcTokensNew;     accountTokens[dst] = dstTokensNew;      /* Eat some of the allowance (if necessary) */     if (startingAllowance != uint(- 1)) {         transferAllowances[src][spender] = allowanceNew;     }     /* We emit a Transfer event */     emit Transfer(src, dst, tokens);     return true; }  /// @notice Transfer `amount` tokens from `msg.sender` to `dst` /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, msg.sender, dst, amount); }  /// @notice Transfer `amount` tokens from `src` to `dst` /// @param src The address of the source account /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, src, dst, amount); }  /// @notice Approve `spender` to transfer up to `amount` from `src` /// @dev This will overwrite the approval amount for `spender` ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve) /// @param spender The address of the account which may transfer tokens /// @param amount The number of tokens that are approved (-1 means infinite) /// @return Whether or not the approval succeeded function approve(address spender, uint256 amount) external override returns (bool) {     address src = msg.sender;     transferAllowances[src][spender] = amount;     emit Approval(src, spender, amount);     return true; }  /// @notice Get the current allowance from `owner` for `spender` /// @param owner The address of the account which owns the tokens to be spent /// @param spender The address of the account which may transfer tokens /// @return The number of tokens allowed to be spent (-1 means infinite) function allowance(address owner, address spender) external override view returns (uint256) {     return transferAllowances[owner][spender]; }  /// @notice Get the token balance of the `owner` /// @param owner The address of the account to query /// @return The number of tokens owned by `owner` function balanceOf(address owner) external override view returns (uint256) {     return accountTokens[owner]; }  /// @notice Get the underlying balance of the `owner` /// @dev This also accrues interest in a transaction /// @param owner The address of the account to query /// @return The amount of underlying owned by `owner` function balanceOfUnderlying(address owner) external override returns (uint) {     Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});     (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);     require(mErr == MathError.NO_ERROR, "calc failed");     return balance; }  /*** User Interface ***/  /// @notice Sender supplies assets into the market and receives lTokens in exchange /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param mintAmount The amount of the underlying asset to supply function mint(uint mintAmount) external override nonReentrant {     accrueInterest();     mintFresh(msg.sender, mintAmount, false); }  function mintTo(address to, uint amount) external payable override nonReentrant {     accrueInterest();     if (isWethPool) {         mintFresh(to, msg.value, false);     } else {         mintFresh(to, amount, true);     } }  function mintEth() external payable override nonReentrant {     require(isWethPool, "not eth pool");     accrueInterest();     mintFresh(msg.sender, msg.value, false); }  /// @notice Sender redeems lTokens in exchange for the underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemTokens The number of lTokens to redeem into underlying function redeem(uint redeemTokens) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, redeemTokens, 0); }  /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemAmount The amount of underlying to redeem function redeemUnderlying(uint redeemAmount) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, 0, redeemAmount); }  function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {     accrueInterest();     // borrowFresh emits borrow-specific logs on errors, so we don't need to     borrowFresh(payable(borrower), msg.sender, borrowAmount); }  /// @notice Sender repays a borrow belonging to borrower /// @param borrower the account with the debt being payed off /// @param repayAmount The amount to repay function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     repayBorrowFresh(msg.sender, borrower, repayAmount, false); }  function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     repayBorrowFresh(msg.sender, borrower, repayAmount, true); }   /*** Safe Token ***/  /// Gets balance of this contract in terms of the underlying /// @dev This excludes the value of the current message, if any /// @return The quantity of underlying tokens owned by this contract function getCashPrior() internal view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }   /**  * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.  *      This will revert due to insufficient balance or insufficient allowance.  *      This function returns the actual amount received,  *      which may be less than `amount` if there is a fee attached to the transfer.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {     if (isWethPool &amp;&amp; convertWeth) {         actualAmount = msg.value;         IWETH(underlying).deposit{value : actualAmount}();     } else {         actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);     } }  /**  * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory  *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to  *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified  *      it is &gt;= amount, this should not revert in normal conditions.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferOut(address payable to, uint amount, bool convertWeth) internal {     if (isWethPool &amp;&amp; convertWeth) {         IWETH(underlying).withdraw(amount);         to.transfer(amount);     } else {         IERC20(underlying).safeTransfer(to, amount);     } }  function availableForBorrow() external view override returns (uint){     uint cash = getCashPrior();     (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);     if (err0 != MathError.NO_ERROR) {         return 0;     }     (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);     if (err1 != MathError.NO_ERROR) {         return 0;     }     if (totalBorrows &gt; maxAvailable) {         return 0;     }     return maxAvailable - totalBorrows; }   /// @notice Get a snapshot of the account's balances, and the cached exchange rate /// @dev This is used by controller to more efficiently perform liquidity checks. /// @param account Address of the account to snapshot /// @return ( token balance, borrow balance, exchange rate mantissa) function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {     uint cTokenBalance = accountTokens[account];     uint borrowBalance;     uint exchangeRateMantissa;      MathError mErr;      (mErr, borrowBalance) = borrowBalanceStoredInternal(account);     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      return (cTokenBalance, borrowBalance, exchangeRateMantissa); }  /// @dev Function to simply retrieve block number ///  This exists mainly for inheriting test contracts to stub this result. function getBlockNumber() internal view returns (uint) {     return block.number; }  /// @notice Returns the current per-block borrow interest rate for this cToken /// @return The borrow interest rate per block, scaled by 1e18 function borrowRatePerBlock() external override view returns (uint) {     return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves); }   /// @notice Returns the current per-block supply interest rate for this cToken /// @return The supply interest rate per block, scaled by 1e18 function supplyRatePerBlock() external override view returns (uint) {     return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa); }  function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {     // Utilization rate is 0 when there are no borrows     if (borrows == 0) {         return 0;     }     return borrows.mul(1e18).div(cash.add(borrows).sub(reserves)); }  /// @notice Calculates the current borrow rate per block, with the error code expected by the market /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18) function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {     uint util = utilizationRate(cash, borrows, reserves);     if (util &lt;= kink) {         return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);     } else {         uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);         uint excessUtil = util.sub(kink);         return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);     } }  /// @notice Calculates the current supply rate per block /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The supply rate percentage per block as a mantissa (scaled by 1e18) function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {     uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);     uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);     uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);     return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18); }  /// @notice Returns the current total borrows plus accrued interest /// @return The total borrows with interest function totalBorrowsCurrent() external override view returns (uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return totalBorrows;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, "calc block delta erro");      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      return totalBorrowsNew; }  /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex /// @param account The address whose balance should be calculated after updating borrowIndex /// @return The calculated balance function borrowBalanceCurrent(address account) external view override returns (uint) {     (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();     require(err0 == MathError.NO_ERROR, "calc borrow index fail");     (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);     require(err1 == MathError.NO_ERROR, "calc fail");     return result; }  function borrowBalanceStored(address account) external override view returns (uint){     return accountBorrows[account].principal; }   /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {     return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex); }  /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {     /* Note: we do not assert that the market is up to date */     MathError mathErr;     uint principalTimesIndex;     uint result;      /* Get borrowBalance and borrowIndex */     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];      /* If borrowBalance = 0 then borrowIndex is likely also 0.      * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.      */     if (borrowSnapshot.principal == 0) {         return (MathError.NO_ERROR, 0);     }      /* Calculate new borrow balance using the interest index:      *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex      */     (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      return (MathError.NO_ERROR, result); }  /// @notice Accrue interest then return the up-to-date exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateCurrent() public override nonReentrant returns (uint) {     accrueInterest();     return exchangeRateStored(); }  /// Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateStored() public override view returns (uint) {     (MathError err, uint result) = exchangeRateStoredInternal();     require(err == MathError.NO_ERROR, "calc fail");     return result; }  /// @notice Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return (error code, calculated exchange rate scaled by 1e18) function exchangeRateStoredInternal() internal view returns (MathError, uint) {     uint _totalSupply = totalSupply;     if (_totalSupply == 0) {         /*          * If there are no tokens minted:          *  exchangeRate = initialExchangeRate          */         return (MathError.NO_ERROR, initialExchangeRateMantissa);     } else {         /*          * Otherwise:          *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply          */         uint _totalCash = getCashPrior();         uint cashPlusBorrowsMinusReserves;         Exp memory exchangeRate;         MathError mathErr;          (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          return (MathError.NO_ERROR, exchangeRate.mantissa);     } }  /// @notice Get cash balance of this cToken in the underlying asset /// @return The quantity of underlying asset owned by this contract function getCash() external override view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }  function calCurrentBorrowIndex() internal view returns (MathError, uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;     uint borrowIndexNew;     /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return (MathError.NO_ERROR, borrowIndex);     }     uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);      Exp memory simpleInterestFactor;     (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }     (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);     return (mathErr, borrowIndexNew); }  /// @notice Applies accrued interest to total borrows and reserves /// @dev This calculates interest accrued from the last checkpointed block ///   up to the current block and writes new checkpoint to storage. function accrueInterest() public override {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint borrowIndexPrior = borrowIndex;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, "calc block delta erro");       /*      * Calculate the interest accumulated into borrows and reserves and the new index:      *  simpleInterestFactor = borrowRate * blockDelta      *  interestAccumulated = simpleInterestFactor * totalBorrows      *  totalBorrowsNew = interestAccumulated + totalBorrows      *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex      */      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;     uint borrowIndexNew;     uint totalReservesNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);     require(mathErr == MathError.NO_ERROR, 'calc total reserves error');      (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);     require(mathErr == MathError.NO_ERROR, 'calc borrows index error');       /* We write the previously calculated values into storage */     accrualBlockNumber = currentBlockNumber;     borrowIndex = borrowIndexNew;     totalBorrows = totalBorrowsNew;     totalReserves = totalReservesNew;      /* We emit an AccrueInterest event */     emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);  }  struct MintLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint mintTokens;     uint totalSupplyNew;     uint accountTokensNew;     uint actualMintAmount; }  /// @notice User supplies assets into the market and receives lTokens in exchange /// @dev Assumes interest has already been accrued up to the current block /// @param minter The address of the account which is supplying the assets /// @param mintAmount The amount of the underlying asset to supply /// @return uint the actual mint amount. function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {     MintLocalVars memory vars;     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /*      *  We call `doTransferIn` for the minter and the mintAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if      *  side-effects occurred. The function returns the amount actually transferred,      *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`      *  of cash.      */     if (isDelegete) {         uint balanceBefore = getCashPrior();         LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);         uint balanceAfter = getCashPrior();         require(balanceAfter &gt; balanceBefore, 'mint 0');         vars.actualMintAmount = balanceAfter - balanceBefore;     } else {         vars.actualMintAmount = doTransferIn(minter, mintAmount, true);     }     /*      * We get the current exchange rate and calculate the number of lTokens to be minted:      *  mintTokens = actualMintAmount / exchangeRate      */      (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));     require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");      /* Fail if mint not allowed */     (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);     /*      * We calculate the new total supply of lTokens and minter token balance, checking for overflow:      *  totalSupplyNew = totalSupply + mintTokens      *  accountTokensNew = accountTokens[minter] + mintTokens      */     (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");      (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[minter] = vars.accountTokensNew;      /* We emit a Mint event, and a Transfer event */     emit Mint(minter, vars.actualMintAmount, vars.mintTokens);     emit Transfer(address(this), minter, vars.mintTokens);      /* We call the defense hook */      return vars.actualMintAmount; }   struct RedeemLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint redeemTokens;     uint redeemAmount;     uint totalSupplyNew;     uint accountTokensNew; }  /// @notice User redeems lTokens in exchange for the underlying asset /// @dev Assumes interest has already been accrued up to the current block /// @param redeemer The address of the account which is redeeming the tokens /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero) /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero) function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {     require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");      RedeemLocalVars memory vars;      /* exchangeRate = invoke Exchange Rate Stored() */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /* If redeemTokensIn &gt; 0: */     if (redeemTokensIn &gt; 0) {         /*          * We calculate the exchange rate and the amount of underlying to be redeemed:          *  redeemTokens = redeemTokensIn          *  redeemAmount = redeemTokensIn x exchangeRateCurrent          */         vars.redeemTokens = redeemTokensIn;          (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');     } else {         /*          * We get the current exchange rate and calculate the amount to be redeemed:          *  redeemTokens = redeemAmountIn / exchangeRate          *  redeemAmount = redeemAmountIn          */          (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');         vars.redeemAmount = redeemAmountIn;     }      /* Fail if redeem not allowed */     (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);      /*      * We calculate the new total supply and redeemer balance, checking for underflow:      *  totalSupplyNew = totalSupply - redeemTokens      *  accountTokensNew = accountTokens[redeemer] - redeemTokens      */     (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');      (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');     require(getCashPrior() &gt;= vars.redeemAmount, 'cash &lt; redeem');      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[redeemer] = vars.accountTokensNew;     /*      * We invoke doTransferOut for the redeemer and the redeemAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken has redeemAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(redeemer, vars.redeemAmount, true);       /* We emit a Transfer event, and a Redeem event */     emit Transfer(redeemer, address(this), vars.redeemTokens);     emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);      /* We call the defense hook */ }  struct BorrowLocalVars {     MathError mathErr;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /// @notice Users borrow assets from the protocol to their own address /// @param borrowAmount The amount of the underlying asset to borrow function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {     /* Fail if borrow not allowed */     (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);      /* Fail gracefully if protocol has insufficient underlying cash */     require(getCashPrior() &gt;= borrowAmount, 'cash&lt;borrow');      BorrowLocalVars memory vars;      /*      * We calculate the new borrower and total borrow balances, failing on overflow:      *  accountBorrowsNew = accountBorrows + borrowAmount      *  totalBorrowsNew = totalBorrows + borrowAmount      */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /*      * We invoke doTransferOut for the borrower and the borrowAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken borrowAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(payee, borrowAmount, false);      /* We emit a Borrow event */     emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */ }  struct RepayBorrowLocalVars {     MathError mathErr;     uint repayAmount;     uint borrowerIndex;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew;     uint actualRepayAmount;     uint badDebtsAmount; }  /// @notice Borrows are repaid by another user (possibly the borrower). /// @param payer the account paying off the borrow /// @param borrower the account with the debt being payed off /// @param repayAmount the amount of undelrying tokens being returned function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {     /* Fail if repayBorrow not allowed */     (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);      RepayBorrowLocalVars memory vars;      /* We remember the original borrowerIndex for verification purposes */     vars.borrowerIndex = accountBorrows[borrower].interestIndex;      /* We fetch the amount the borrower owes, with accumulated interest */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');      /* If repayAmount == -1, repayAmount = accountBorrows */     if (repayAmount == uint(- 1)) {         vars.repayAmount = vars.accountBorrows;     } else {         vars.repayAmount = repayAmount;     }     vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);       if (isEnd &amp;&amp; vars.accountBorrows &gt; vars.actualRepayAmount) {         vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;     }      /*     *  We calculate the new borrower and total borrow balances, failing on underflow:     *  accountBorrowsNew = accountBorrows - repayAmount     *  totalBorrowsNew = totalBorrows - repayAmount     */     if (vars.accountBorrows &lt; vars.actualRepayAmount) {         require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) &lt;= 105e16, 'repay more than 5%');         vars.accountBorrowsNew = 0;     } else {         if (isEnd) {             vars.accountBorrowsNew = 0;         } else {             vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;         }     }     //Avoid mantissa errors     if (vars.actualRepayAmount &gt; totalBorrows) {         vars.totalBorrowsNew = 0;     } else {         if (isEnd) {             vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);         } else {             vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;         }     }      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a RepayBorrow event */     emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */      return vars.actualRepayAmount; }  /*** Admin Functions ***/  /// @notice Sets a new CONTROLLER for the market /// @dev Admin function to set a new controller function setController(address newController) external override onlyAdmin {     require(address(0) != newController, "0x");     address oldController = controller;     controller = newController;     // Emit NewController(oldController, newController)     emit NewController(oldController, newController); }  function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {     require(newBorrowCapFactorMantissa &lt;= 1e18, 'Factor too large');     uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;     borrowCapFactorMantissa = newBorrowCapFactorMantissa;     emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa); }  function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {     //accrueInterest except first     if (baseRatePerBlock != 0) {         accrueInterest();     }     // total rate perYear &lt; 2000%     require(baseRatePerBlock_ &lt; 1e13, 'Base rate too large');     baseRatePerBlock = baseRatePerBlock_;     require(multiplierPerBlock_ &lt; 1e13, 'Mul rate too large');     multiplierPerBlock = multiplierPerBlock_;     require(jumpMultiplierPerBlock_ &lt; 1e13, 'Jump rate too large');     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     require(kink_ &lt;= 1e18, 'Kline too large');     kink = kink_;     emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_); }  function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {     require(newReserveFactorMantissa &lt;= 1e18, 'Factor too large');     accrueInterest();     uint oldReserveFactorMantissa = reserveFactorMantissa;     reserveFactorMantissa = newReserveFactorMantissa;     emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa); }  function addReserves(uint addAmount) external override nonReentrant {     accrueInterest();     uint totalReservesNew;     uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);     totalReservesNew = totalReserves.add(actualAddAmount);     totalReserves = totalReservesNew;     emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew); }  function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {     accrueInterest();     uint totalReservesNew;     totalReservesNew = totalReserves.sub(reduceAmount);     totalReserves = totalReservesNew;     doTransferOut(to, reduceAmount, true);     emit ReservesReduced(to, reduceAmount, totalReservesNew); }  modifier sameBlock() {     require(accrualBlockNumber == getBlockNumber(), 'not same block');     _; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-24-08 19:28:38 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;


import "./LPoolInterface.sol";
import "./LPoolDepositor.sol";
import "../lib/Exponential.sol";
import "../Adminable.sol";
import "../lib/CarefulMath.sol";
import "../lib/TransferHelper.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import "../DelegateInterface.sol";
import "../ControllerInterface.sol";
import "../IWETH.sol";

/// @title OpenLeverage's LToken Contract
/// @dev Abstract base for LTokens
/// @author OpenLeverage
contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {
    using TransferHelper for IERC20;
    using SafeMath for uint;

    constructor() {

    }
    
    /// @notice Initialize the money market
    /// @param controller_ The address of the Controller
    /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0
    /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate
    /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point
    /// @param kink_ The utilization point at which the jump multiplier is applied
    /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
    /// @param name_ EIP-20 name of this token
    /// @param symbol_ EIP-20 symbol of this token
    /// @param decimals_ EIP-20 decimal precision of this token
    function initialize(
        address underlying_,
        bool isWethPool_,
        address controller_,
        uint256 baseRatePerBlock_,
        uint256 multiplierPerBlock_,
        uint256 jumpMultiplierPerBlock_,
        uint256 kink_,
        uint initialExchangeRateMantissa_,
        string memory name_,
        string memory symbol_,
        uint8 decimals_) public {
        require(underlying_ != address(0), "underlying_ address cannot be 0");
        require(controller_ != address(0), "controller_ address cannot be 0");
        require(msg.sender == admin, "Only allow to be called by admin");
        require(accrualBlockNumber == 0 && borrowIndex == 0, "inited once");

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial Exchange Rate Mantissa should be greater zero");
        //set controller
        controller = controller_;
        isWethPool = isWethPool_;
        //set interestRateModel
        baseRatePerBlock = baseRatePerBlock_;
        multiplierPerBlock = multiplierPerBlock_;
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        kink = kink_;

        // Initialize block number and borrow index (block number mocks depend on controller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = 1e25;
        //80%
        borrowCapFactorMantissa = 0.8e18;
        //10%
        reserveFactorMantissa = 0.1e18;


        name = name_;
        symbol = symbol_;
        decimals = decimals_;

        _notEntered = true;

        // Set underlying and sanity check it
        underlying = underlying_;
        IERC20(underlying).totalSupply();
        emit Transfer(address(0), msg.sender, 0);
    }

    /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
    /// @dev Called by both `transfer` and `transferFrom` internally
    /// @param spender The address of the account performing the transfer
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param tokens The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {
        require(dst != address(0), "dst address cannot be 0");
        /* Do not allow self-transfers */
        require(src != dst, "src = dst");
        /* Fail if transfer not allowed */
        (ControllerInterface(controller)).transferAllowed(src, dst, tokens);

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(- 1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        require(mathErr == MathError.NO_ERROR, 'not allowed');

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        require(mathErr == MathError.NO_ERROR, 'not enough');

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        require(mathErr == MathError.NO_ERROR, 'too much');

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(- 1)) {
            transferAllowances[src][spender] = allowanceNew;
        }
        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);
        return true;
    }

    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount);
    }

    /// @notice Transfer `amount` tokens from `src` to `dst`
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount);
    }

    /// @notice Approve `spender` to transfer up to `amount` from `src`
    /// @dev This will overwrite the approval amount for `spender`
    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
    /// @param spender The address of the account which may transfer tokens
    /// @param amount The number of tokens that are approved (-1 means infinite)
    /// @return Whether or not the approval succeeded
    function approve(address spender, uint256 amount) external override returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /// @notice Get the current allowance from `owner` for `spender`
    /// @param owner The address of the account which owns the tokens to be spent
    /// @param spender The address of the account which may transfer tokens
    /// @return The number of tokens allowed to be spent (-1 means infinite)
    function allowance(address owner, address spender) external override view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /// @notice Get the token balance of the `owner`
    /// @param owner The address of the account to query
    /// @return The number of tokens owned by `owner`
    function balanceOf(address owner) external override view returns (uint256) {
        return accountTokens[owner];
    }

    /// @notice Get the underlying balance of the `owner`
    /// @dev This also accrues interest in a transaction
    /// @param owner The address of the account to query
    /// @return The amount of underlying owned by `owner`
    function balanceOfUnderlying(address owner) external override returns (uint) {
        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR, "calc failed");
        return balance;
    }

    /*** User Interface ***/

    /// @notice Sender supplies assets into the market and receives lTokens in exchange
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param mintAmount The amount of the underlying asset to supply
    function mint(uint mintAmount) external override nonReentrant {
        accrueInterest();
        mintFresh(msg.sender, mintAmount, false);
    }

    function mintTo(address to, uint amount) external payable override nonReentrant {
        accrueInterest();
        if (isWethPool) {
            mintFresh(to, msg.value, false);
        } else {
            mintFresh(to, amount, true);
        }
    }

    function mintEth() external payable override nonReentrant {
        require(isWethPool, "not eth pool");
        accrueInterest();
        mintFresh(msg.sender, msg.value, false);
    }

    /// @notice Sender redeems lTokens in exchange for the underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemTokens The number of lTokens to redeem into underlying
    function redeem(uint redeemTokens) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, redeemTokens, 0);
    }

    /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemAmount The amount of underlying to redeem
    function redeemUnderlying(uint redeemAmount) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, 0, redeemAmount);
    }

    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {
        accrueInterest();
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        borrowFresh(payable(borrower), msg.sender, borrowAmount);
    }

    /// @notice Sender repays a borrow belonging to borrower
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount The amount to repay
    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        repayBorrowFresh(msg.sender, borrower, repayAmount, false);
    }

    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        repayBorrowFresh(msg.sender, borrower, repayAmount, true);
    }


    /*** Safe Token ***/

    /// Gets balance of this contract in terms of the underlying
    /// @dev This excludes the value of the current message, if any
    /// @return The quantity of underlying tokens owned by this contract
    function getCashPrior() internal view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }


    /**
     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.
     *      This will revert due to insufficient balance or insufficient allowance.
     *      This function returns the actual amount received,
     *      which may be less than `amount` if there is a fee attached to the transfer.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {
        if (isWethPool && convertWeth) {
            actualAmount = msg.value;
            IWETH(underlying).deposit{value : actualAmount}();
        } else {
            actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);
        }
    }

    /**
     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory
     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to
     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified
     *      it is >= amount, this should not revert in normal conditions.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {
        if (isWethPool && convertWeth) {
            IWETH(underlying).withdraw(amount);
            to.transfer(amount);
        } else {
            IERC20(underlying).safeTransfer(to, amount);
        }
    }

    function availableForBorrow() external view override returns (uint){
        uint cash = getCashPrior();
        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);
        if (err0 != MathError.NO_ERROR) {
            return 0;
        }
        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);
        if (err1 != MathError.NO_ERROR) {
            return 0;
        }
        if (totalBorrows > maxAvailable) {
            return 0;
        }
        return maxAvailable - totalBorrows;
    }


    /// @notice Get a snapshot of the account's balances, and the cached exchange rate
    /// @dev This is used by controller to more efficiently perform liquidity checks.
    /// @param account Address of the account to snapshot
    /// @return ( token balance, borrow balance, exchange rate mantissa)
    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        return (cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /// @dev Function to simply retrieve block number
    ///  This exists mainly for inheriting test contracts to stub this result.
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /// @notice Returns the current per-block borrow interest rate for this cToken
    /// @return The borrow interest rate per block, scaled by 1e18
    function borrowRatePerBlock() external override view returns (uint) {
        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
    }

    
    /// @notice Returns the current per-block supply interest rate for this cToken
    /// @return The supply interest rate per block, scaled by 1e18
    function supplyRatePerBlock() external override view returns (uint) {
        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);
    }

    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {
        // Utilization rate is 0 when there are no borrows
        if (borrows == 0) {
            return 0;
        }
        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));
    }

    /// @notice Calculates the current borrow rate per block, with the error code expected by the market
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18)
    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {
        uint util = utilizationRate(cash, borrows, reserves);
        if (util <= kink) {
            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
        } else {
            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
            uint excessUtil = util.sub(kink);
            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);
        }
    }

    /// @notice Calculates the current supply rate per block
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The supply rate percentage per block as a mantissa (scaled by 1e18)
    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {
        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);
        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);
        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);
        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);
    }

    /// @notice Returns the current total borrows plus accrued interest
    /// @return The total borrows with interest
    function totalBorrowsCurrent() external override view returns (uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return totalBorrows;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        return totalBorrowsNew;
    }

    /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
    /// @param account The address whose balance should be calculated after updating borrowIndex
    /// @return The calculated balance
    function borrowBalanceCurrent(address account) external view override returns (uint) {
        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();
        require(err0 == MathError.NO_ERROR, "calc borrow index fail");
        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
        require(err1 == MathError.NO_ERROR, "calc fail");
        return result;
    }

    function borrowBalanceStored(address account) external override view returns (uint){
        return accountBorrows[account].principal;
    }


    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
    }

    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /// @notice Accrue interest then return the up-to-date exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateCurrent() public override nonReentrant returns (uint) {
        accrueInterest();
        return exchangeRateStored();
    }

    /// Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateStored() public override view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "calc fail");
        return result;
    }

    /// @notice Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return (error code, calculated exchange rate scaled by 1e18)
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        uint _totalSupply = totalSupply;
        if (_totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint _totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /// @notice Get cash balance of this cToken in the underlying asset
    /// @return The quantity of underlying asset owned by this contract
    function getCash() external override view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }

    function calCurrentBorrowIndex() internal view returns (MathError, uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;
        uint borrowIndexNew;
        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return (MathError.NO_ERROR, borrowIndex);
        }
        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);

        Exp memory simpleInterestFactor;
        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }
        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);
        return (mathErr, borrowIndexNew);
    }

    /// @notice Applies accrued interest to total borrows and reserves
    /// @dev This calculates interest accrued from the last checkpointed block
    ///   up to the current block and writes new checkpoint to storage.
    function accrueInterest() public override {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint borrowIndexPrior = borrowIndex;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");


        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;
        uint borrowIndexNew;
        uint totalReservesNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total reserves error');

        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);
        require(mathErr == MathError.NO_ERROR, 'calc borrows index error');


        /* We write the previously calculated values into storage */
        accrualBlockNumber = currentBlockNumber;
        borrowIndex = borrowIndexNew;
        totalBorrows = totalBorrowsNew;
        totalReserves = totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);

    }

    struct MintLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
        uint actualMintAmount;
    }

    /// @notice User supplies assets into the market and receives lTokens in exchange
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param minter The address of the account which is supplying the assets
    /// @param mintAmount The amount of the underlying asset to supply
    /// @return uint the actual mint amount.
    function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {
        MintLocalVars memory vars;
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /*
         *  We call `doTransferIn` for the minter and the mintAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if
         *  side-effects occurred. The function returns the amount actually transferred,
         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`
         *  of cash.
         */
        if (isDelegete) {
            uint balanceBefore = getCashPrior();
            LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);
            uint balanceAfter = getCashPrior();
            require(balanceAfter > balanceBefore, 'mint 0');
            vars.actualMintAmount = balanceAfter - balanceBefore;
        } else {
            vars.actualMintAmount = doTransferIn(minter, mintAmount, true);
        }
        /*
         * We get the current exchange rate and calculate the number of lTokens to be minted:
         *  mintTokens = actualMintAmount / exchangeRate
         */

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));
        require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");

        /* Fail if mint not allowed */
        (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);
        /*
         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */

        return vars.actualMintAmount;
    }


    struct RedeemLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /// @notice User redeems lTokens in exchange for the underlying asset
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param redeemer The address of the account which is redeeming the tokens
    /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');
            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');
        require(getCashPrior() >= vars.redeemAmount, 'cash < redeem');

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;
        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(redeemer, vars.redeemAmount, true);


        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
    }

    struct BorrowLocalVars {
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /// @notice Users borrow assets from the protocol to their own address
    /// @param borrowAmount The amount of the underlying asset to borrow
    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {
        /* Fail if borrow not allowed */
        (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);

        /* Fail gracefully if protocol has insufficient underlying cash */
        require(getCashPrior() >= borrowAmount, 'cash<borrow');

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(payee, borrowAmount, false);

        /* We emit a Borrow event */
        emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
    }

    struct RepayBorrowLocalVars {
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
        uint actualRepayAmount;
        uint badDebtsAmount;
    }

    /// @notice Borrows are repaid by another user (possibly the borrower).
    /// @param payer the account paying off the borrow
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount the amount of undelrying tokens being returned
    function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {
        /* Fail if repayBorrow not allowed */
        (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(- 1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }
        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);


        if (isEnd && vars.accountBorrows > vars.actualRepayAmount) {
            vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;
        }

        /*
        *  We calculate the new borrower and total borrow balances, failing on underflow:
        *  accountBorrowsNew = accountBorrows - repayAmount
        *  totalBorrowsNew = totalBorrows - repayAmount
        */
        if (vars.accountBorrows < vars.actualRepayAmount) {
            require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) <= 105e16, 'repay more than 5%');
            vars.accountBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.accountBorrowsNew = 0;
            } else {
                vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;
            }
        }
        //Avoid mantissa errors
        if (vars.actualRepayAmount > totalBorrows) {
            vars.totalBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);
            } else {
                vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;
            }
        }

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */

        return vars.actualRepayAmount;
    }

    /*** Admin Functions ***/

    /// @notice Sets a new CONTROLLER for the market
    /// @dev Admin function to set a new controller
    function setController(address newController) external override onlyAdmin {
        require(address(0) != newController, "0x");
        address oldController = controller;
        controller = newController;
        // Emit NewController(oldController, newController)
        emit NewController(oldController, newController);
    }

    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {
        require(newBorrowCapFactorMantissa <= 1e18, 'Factor too large');
        uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;
        borrowCapFactorMantissa = newBorrowCapFactorMantissa;
        emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa);
    }

    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {
        //accrueInterest except first
        if (baseRatePerBlock != 0) {
            accrueInterest();
        }
        // total rate perYear < 2000%
        require(baseRatePerBlock_ < 1e13, 'Base rate too large');
        baseRatePerBlock = baseRatePerBlock_;
        require(multiplierPerBlock_ < 1e13, 'Mul rate too large');
        multiplierPerBlock = multiplierPerBlock_;
        require(jumpMultiplierPerBlock_ < 1e13, 'Jump rate too large');
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        require(kink_ <= 1e18, 'Kline too large');
        kink = kink_;
        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);
    }

    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {
        require(newReserveFactorMantissa <= 1e18, 'Factor too large');
        accrueInterest();
        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;
        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);
    }

    function addReserves(uint addAmount) external override nonReentrant {
        accrueInterest();
        uint totalReservesNew;
        uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);
        totalReservesNew = totalReserves.add(actualAddAmount);
        totalReserves = totalReservesNew;
        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);
    }

    function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {
        accrueInterest();
        uint totalReservesNew;
        totalReservesNew = totalReserves.sub(reduceAmount);
        totalReserves = totalReservesNew;
        doTransferOut(to, reduceAmount, true);
        emit ReservesReduced(to, reduceAmount, totalReservesNew);
    }

    modifier sameBlock() {
        require(accrualBlockNumber == getBlockNumber(), 'not same block');
        _;
    }
}

.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;


import "./LPoolInterface.sol";
import "./LPoolDepositor.sol";
import "../lib/Exponential.sol";
import "../Adminable.sol";
import "../lib/CarefulMath.sol";
import "../lib/TransferHelper.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import "../DelegateInterface.sol";
import "../ControllerInterface.sol";
import "../IWETH.sol";

/// @title OpenLeverage's LToken Contract
/// @dev Abstract base for LTokens
/// @author OpenLeverage
contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {
    using TransferHelper for IERC20;
    using SafeMath for uint;

    constructor() {

    }
    
    /// @notice Initialize the money market
    /// @param controller_ The address of the Controller
    /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0
    /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate
    /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point
    /// @param kink_ The utilization point at which the jump multiplier is applied
    /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
    /// @param name_ EIP-20 name of this token
    /// @param symbol_ EIP-20 symbol of this token
    /// @param decimals_ EIP-20 decimal precision of this token
    function initialize(
        address underlying_,
        bool isWethPool_,
        address controller_,
        uint256 baseRatePerBlock_,
        uint256 multiplierPerBlock_,
        uint256 jumpMultiplierPerBlock_,
        uint256 kink_,
        uint initialExchangeRateMantissa_,
        string memory name_,
        string memory symbol_,
        uint8 decimals_) public {
        require(underlying_ != address(0), "underlying_ address cannot be 0");
        require(controller_ != address(0), "controller_ address cannot be 0");
        require(msg.sender == admin, "Only allow to be called by admin");
        require(accrualBlockNumber == 0 && borrowIndex == 0, "inited once");

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial Exchange Rate Mantissa should be greater zero");
        //set controller
        controller = controller_;
        isWethPool = isWethPool_;
        //set interestRateModel
        baseRatePerBlock = baseRatePerBlock_;
        multiplierPerBlock = multiplierPerBlock_;
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        kink = kink_;

        // Initialize block number and borrow index (block number mocks depend on controller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = 1e25;
        //80%
        borrowCapFactorMantissa = 0.8e18;
        //10%
        reserveFactorMantissa = 0.1e18;


        name = name_;
        symbol = symbol_;
        decimals = decimals_;

        _notEntered = true;

        // Set underlying and sanity check it
        underlying = underlying_;
        IERC20(underlying).totalSupply();
        emit Transfer(address(0), msg.sender, 0);
    }

    /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
    /// @dev Called by both `transfer` and `transferFrom` internally
    /// @param spender The address of the account performing the transfer
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param tokens The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {
        require(dst != address(0), "dst address cannot be 0");
        /* Do not allow self-transfers */
        require(src != dst, "src = dst");
        /* Fail if transfer not allowed */
        (ControllerInterface(controller)).transferAllowed(src, dst, tokens);

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(- 1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        require(mathErr == MathError.NO_ERROR, 'not allowed');

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        require(mathErr == MathError.NO_ERROR, 'not enough');

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        require(mathErr == MathError.NO_ERROR, 'too much');

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(- 1)) {
            transferAllowances[src][spender] = allowanceNew;
        }
        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);
        return true;
    }

    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount);
    }

    /// @notice Transfer `amount` tokens from `src` to `dst`
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount);
    }

    /// @notice Approve `spender` to transfer up to `amount` from `src`
    /// @dev This will overwrite the approval amount for `spender`
    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
    /// @param spender The address of the account which may transfer tokens
    /// @param amount The number of tokens that are approved (-1 means infinite)
    /// @return Whether or not the approval succeeded
    function approve(address spender, uint256 amount) external override returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /// @notice Get the current allowance from `owner` for `spender`
    /// @param owner The address of the account which owns the tokens to be spent
    /// @param spender The address of the account which may transfer tokens
    /// @return The number of tokens allowed to be spent (-1 means infinite)
    function allowance(address owner, address spender) external override view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /// @notice Get the token balance of the `owner`
    /// @param owner The address of the account to query
    /// @return The number of tokens owned by `owner`
    function balanceOf(address owner) external override view returns (uint256) {
        return accountTokens[owner];
    }

    /// @notice Get the underlying balance of the `owner`
    /// @dev This also accrues interest in a transaction
    /// @param owner The address of the account to query
    /// @return The amount of underlying owned by `owner`
    function balanceOfUnderlying(address owner) external override returns (uint) {
        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR, "calc failed");
        return balance;
    }

    /*** User Interface ***/

    /// @notice Sender supplies assets into the market and receives lTokens in exchange
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param mintAmount The amount of the underlying asset to supply
    function mint(uint mintAmount) external override nonReentrant {
        accrueInterest();
        mintFresh(msg.sender, mintAmount, false);
    }

    function mintTo(address to, uint amount) external payable override nonReentrant {
        accrueInterest();
        if (isWethPool) {
            mintFresh(to, msg.value, false);
        } else {
            mintFresh(to, amount, true);
        }
    }

    function mintEth() external payable override nonReentrant {
        require(isWethPool, "not eth pool");
        accrueInterest();
        mintFresh(msg.sender, msg.value, false);
    }

    /// @notice Sender redeems lTokens in exchange for the underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemTokens The number of lTokens to redeem into underlying
    function redeem(uint redeemTokens) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, redeemTokens, 0);
    }

    /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemAmount The amount of underlying to redeem
    function redeemUnderlying(uint redeemAmount) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, 0, redeemAmount);
    }

    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {
        accrueInterest();
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        borrowFresh(payable(borrower), msg.sender, borrowAmount);
    }

    /// @notice Sender repays a borrow belonging to borrower
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount The amount to repay
    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        repayBorrowFresh(msg.sender, borrower, repayAmount, false);
    }

    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        repayBorrowFresh(msg.sender, borrower, repayAmount, true);
    }


    /*** Safe Token ***/

    /// Gets balance of this contract in terms of the underlying
    /// @dev This excludes the value of the current message, if any
    /// @return The quantity of underlying tokens owned by this contract
    function getCashPrior() internal view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }


    /**
     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.
     *      This will revert due to insufficient balance or insufficient allowance.
     *      This function returns the actual amount received,
     *      which may be less than `amount` if there is a fee attached to the transfer.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {
        if (isWethPool && convertWeth) {
            actualAmount = msg.value;
            IWETH(underlying).deposit{value : actualAmount}();
        } else {
            actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);
        }
    }

    /**
     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory
     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to
     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified
     *      it is >= amount, this should not revert in normal conditions.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {
        if (isWethPool && convertWeth) {
            IWETH(underlying).withdraw(amount);
            to.transfer(amount);
        } else {
            IERC20(underlying).safeTransfer(to, amount);
        }
    }

    function availableForBorrow() external view override returns (uint){
        uint cash = getCashPrior();
        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);
        if (err0 != MathError.NO_ERROR) {
            return 0;
        }
        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);
        if (err1 != MathError.NO_ERROR) {
            return 0;
        }
        if (totalBorrows > maxAvailable) {
            return 0;
        }
        return maxAvailable - totalBorrows;
    }


    /// @notice Get a snapshot of the account's balances, and the cached exchange rate
    /// @dev This is used by controller to more efficiently perform liquidity checks.
    /// @param account Address of the account to snapshot
    /// @return ( token balance, borrow balance, exchange rate mantissa)
    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        return (cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /// @dev Function to simply retrieve block number
    ///  This exists mainly for inheriting test contracts to stub this result.
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /// @notice Returns the current per-block borrow interest rate for this cToken
    /// @return The borrow interest rate per block, scaled by 1e18
    function borrowRatePerBlock() external override view returns (uint) {
        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
    }

    
    /// @notice Returns the current per-block supply interest rate for this cToken
    /// @return The supply interest rate per block, scaled by 1e18
    function supplyRatePerBlock() external override view returns (uint) {
        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);
    }

    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {
        // Utilization rate is 0 when there are no borrows
        if (borrows == 0) {
            return 0;
        }
        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));
    }

    /// @notice Calculates the current borrow rate per block, with the error code expected by the market
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18)
    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {
        uint util = utilizationRate(cash, borrows, reserves);
        if (util <= kink) {
            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
        } else {
            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
            uint excessUtil = util.sub(kink);
            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);
        }
    }

    /// @notice Calculates the current supply rate per block
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The supply rate percentage per block as a mantissa (scaled by 1e18)
    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {
        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);
        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);
        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);
        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);
    }

    /// @notice Returns the current total borrows plus accrued interest
    /// @return The total borrows with interest
    function totalBorrowsCurrent() external override view returns (uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return totalBorrows;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        return totalBorrowsNew;
    }

    /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
    /// @param account The address whose balance should be calculated after updating borrowIndex
    /// @return The calculated balance
    function borrowBalanceCurrent(address account) external view override returns (uint) {
        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();
        require(err0 == MathError.NO_ERROR, "calc borrow index fail");
        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
        require(err1 == MathError.NO_ERROR, "calc fail");
        return result;
    }

    function borrowBalanceStored(address account) external override view returns (uint){
        return accountBorrows[account].principal;
    }


    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
    }

    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /// @notice Accrue interest then return the up-to-date exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateCurrent() public override nonReentrant returns (uint) {
        accrueInterest();
        return exchangeRateStored();
    }

    /// Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateStored() public override view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "calc fail");
        return result;
    }

    /// @notice Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return (error code, calculated exchange rate scaled by 1e18)
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        uint _totalSupply = totalSupply;
        if (_totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint _totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /// @notice Get cash balance of this cToken in the underlying asset
    /// @return The quantity of underlying asset owned by this contract
    function getCash() external override view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }

    function calCurrentBorrowIndex() internal view returns (MathError, uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;
        uint borrowIndexNew;
        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return (MathError.NO_ERROR, borrowIndex);
        }
        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);

        Exp memory simpleInterestFactor;
        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }
        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);
        return (mathErr, borrowIndexNew);
    }

    /// @notice Applies accrued interest to total borrows and reserves
    /// @dev This calculates interest accrued from the last checkpointed block
    ///   up to the current block and writes new checkpoint to storage.
    function accrueInterest() public override {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint borrowIndexPrior = borrowIndex;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");


        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;
        uint borrowIndexNew;
        uint totalReservesNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total reserves error');

        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);
        require(mathErr == MathError.NO_ERROR, 'calc borrows index error');


        /* We write the previously calculated values into storage */
        accrualBlockNumber = currentBlockNumber;
        borrowIndex = borrowIndexNew;
        totalBorrows = totalBorrowsNew;
        totalReserves = totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);

    }

    struct MintLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
        uint actualMintAmount;
    }

    /// @notice User supplies assets into the market and receives lTokens in exchange
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param minter The address of the account which is supplying the assets
    /// @param mintAmount The amount of the underlying asset to supply
    /// @return uint the actual mint amount.
    function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {
        MintLocalVars memory vars;
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /*
         *  We call `doTransferIn` for the minter and the mintAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if
         *  side-effects occurred. The function returns the amount actually transferred,
         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`
         *  of cash.
         */
        if (isDelegete) {
            uint balanceBefore = getCashPrior();
            LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);
            uint balanceAfter = getCashPrior();
            require(balanceAfter > balanceBefore, 'mint 0');
            vars.actualMintAmount = balanceAfter - balanceBefore;
        } else {
            vars.actualMintAmount = doTransferIn(minter, mintAmount, true);
        }
        /*
         * We get the current exchange rate and calculate the number of lTokens to be minted:
         *  mintTokens = actualMintAmount / exchangeRate
         */

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));
        require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");

        /* Fail if mint not allowed */
        (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);
        /*
         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */

        return vars.actualMintAmount;
    }


    struct RedeemLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /// @notice User redeems lTokens in exchange for the underlying asset
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param redeemer The address of the account which is redeeming the tokens
    /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');
            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');
        require(getCashPrior() >= vars.redeemAmount, 'cash < redeem');

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;
        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(redeemer, vars.redeemAmount, true);


        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
    }

    struct BorrowLocalVars {
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /// @notice Users borrow assets from the protocol to their own address
    /// @param borrowAmount The amount of the underlying asset to borrow
    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {
        /* Fail if borrow not allowed */
        (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);

        /* Fail gracefully if protocol has insufficient underlying cash */
        require(getCashPrior() >= borrowAmount, 'cash<borrow');

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(payee, borrowAmount, false);

        /* We emit a Borrow event */
        emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
    }

    struct RepayBorrowLocalVars {
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
        uint actualRepayAmount;
        uint badDebtsAmount;
    }

    /// @notice Borrows are repaid by another user (possibly the borrower).
    /// @param payer the account paying off the borrow
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount the amount of undelrying tokens being returned
    function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {
        /* Fail if repayBorrow not allowed */
        (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(- 1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }
        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);


        if (isEnd && vars.accountBorrows > vars.actualRepayAmount) {
            vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;
        }

        /*
        *  We calculate the new borrower and total borrow balances, failing on underflow:
        *  accountBorrowsNew = accountBorrows - repayAmount
        *  totalBorrowsNew = totalBorrows - repayAmount
        */
        if (vars.accountBorrows < vars.actualRepayAmount) {
            require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) <= 105e16, 'repay more than 5%');
            vars.accountBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.accountBorrowsNew = 0;
            } else {
                vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;
            }
        }
        //Avoid mantissa errors
        if (vars.actualRepayAmount > totalBorrows) {
            vars.totalBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);
            } else {
                vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;
            }
        }

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */

        return vars.actualRepayAmount;
    }

    /*** Admin Functions ***/

    /// @notice Sets a new CONTROLLER for the market
    /// @dev Admin function to set a new controller
    function setController(address newController) external override onlyAdmin {
        require(address(0) != newController, "0x");
        address oldController = controller;
        controller = newController;
        // Emit NewController(oldController, newController)
        emit NewController(oldController, newController);
    }

    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {
        require(newBorrowCapFactorMantissa <= 1e18, 'Factor too large');
        uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;
        borrowCapFactorMantissa = newBorrowCapFactorMantissa;
        emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa);
    }

    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {
        //accrueInterest except first
        if (baseRatePerBlock != 0) {
            accrueInterest();
        }
        // total rate perYear < 2000%
        require(baseRatePerBlock_ < 1e13, 'Base rate too large');
        baseRatePerBlock = baseRatePerBlock_;
        require(multiplierPerBlock_ < 1e13, 'Mul rate too large');
        multiplierPerBlock = multiplierPerBlock_;
        require(jumpMultiplierPerBlock_ < 1e13, 'Jump rate too large');
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        require(kink_ <= 1e18, 'Kline too large');
        kink = kink_;
        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);
    }

    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {
        require(newReserveFactorMantissa <= 1e18, 'Factor too large');
        accrueInterest();
        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;
        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);
    }

    function addReserves(uint addAmount) external override nonReentrant {
        accrueInterest();
        uint totalReservesNew;
        uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);
        totalReservesNew = totalReserves.add(actualAddAmount);
        totalReserves = totalReservesNew;
        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);
    }

    function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {
        accrueInterest();
        uint totalReservesNew;
        totalReservesNew = totalReserves.sub(reduceAmount);
        totalReserves = totalReservesNew;
        doTransferOut(to, reduceAmount, true);
        emit ReservesReduced(to, reduceAmount, totalReservesNew);
    }

    modifier sameBlock() {
        require(accrualBlockNumber == getBlockNumber(), 'not same block');
        _;
    }
}

".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-24-08 19:28:41 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-24-08 19:28:41 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 19883
completion_tokens: 1
total_tokens: 19884
cost: $-1.000000


[2024-24-08 19:28:41 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;


import "./LPoolInterface.sol";
import "./LPoolDepositor.sol";
import "../lib/Exponential.sol";
import "../Adminable.sol";
import "../lib/CarefulMath.sol";
import "../lib/TransferHelper.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import "../DelegateInterface.sol";
import "../ControllerInterface.sol";
import "../IWETH.sol";

/// @title OpenLeverage's LToken Contract
/// @dev Abstract base for LTokens
/// @author OpenLeverage
contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {
    using TransferHelper for IERC20;
    using SafeMath for uint;

    constructor() {

    }
    
    /// @notice Initialize the money market
    /// @param controller_ The address of the Controller
    /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0
    /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate
    /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point
    /// @param kink_ The utilization point at which the jump multiplier is applied
    /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
    /// @param name_ EIP-20 name of this token
    /// @param symbol_ EIP-20 symbol of this token
    /// @param decimals_ EIP-20 decimal precision of this token
    function initialize(
        address underlying_,
        bool isWethPool_,
        address controller_,
        uint256 baseRatePerBlock_,
        uint256 multiplierPerBlock_,
        uint256 jumpMultiplierPerBlock_,
        uint256 kink_,
        uint initialExchangeRateMantissa_,
        string memory name_,
        string memory symbol_,
        uint8 decimals_) public {
        require(underlying_ != address(0), "underlying_ address cannot be 0");
        require(controller_ != address(0), "controller_ address cannot be 0");
        require(msg.sender == admin, "Only allow to be called by admin");
        require(accrualBlockNumber == 0 && borrowIndex == 0, "inited once");

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial Exchange Rate Mantissa should be greater zero");
        //set controller
        controller = controller_;
        isWethPool = isWethPool_;
        //set interestRateModel
        baseRatePerBlock = baseRatePerBlock_;
        multiplierPerBlock = multiplierPerBlock_;
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        kink = kink_;

        // Initialize block number and borrow index (block number mocks depend on controller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = 1e25;
        //80%
        borrowCapFactorMantissa = 0.8e18;
        //10%
        reserveFactorMantissa = 0.1e18;


        name = name_;
        symbol = symbol_;
        decimals = decimals_;

        _notEntered = true;

        // Set underlying and sanity check it
        underlying = underlying_;
        IERC20(underlying).totalSupply();
        emit Transfer(address(0), msg.sender, 0);
    }

    /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
    /// @dev Called by both `transfer` and `transferFrom` internally
    /// @param spender The address of the account performing the transfer
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param tokens The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {
        require(dst != address(0), "dst address cannot be 0");
        /* Do not allow self-transfers */
        require(src != dst, "src = dst");
        /* Fail if transfer not allowed */
        (ControllerInterface(controller)).transferAllowed(src, dst, tokens);

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(- 1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        require(mathErr == MathError.NO_ERROR, 'not allowed');

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        require(mathErr == MathError.NO_ERROR, 'not enough');

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        require(mathErr == MathError.NO_ERROR, 'too much');

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(- 1)) {
            transferAllowances[src][spender] = allowanceNew;
        }
        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);
        return true;
    }

    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount);
    }

    /// @notice Transfer `amount` tokens from `src` to `dst`
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount);
    }

    /// @notice Approve `spender` to transfer up to `amount` from `src`
    /// @dev This will overwrite the approval amount for `spender`
    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
    /// @param spender The address of the account which may transfer tokens
    /// @param amount The number of tokens that are approved (-1 means infinite)
    /// @return Whether or not the approval succeeded
    function approve(address spender, uint256 amount) external override returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /// @notice Get the current allowance from `owner` for `spender`
    /// @param owner The address of the account which owns the tokens to be spent
    /// @param spender The address of the account which may transfer tokens
    /// @return The number of tokens allowed to be spent (-1 means infinite)
    function allowance(address owner, address spender) external override view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /// @notice Get the token balance of the `owner`
    /// @param owner The address of the account to query
    /// @return The number of tokens owned by `owner`
    function balanceOf(address owner) external override view returns (uint256) {
        return accountTokens[owner];
    }

    /// @notice Get the underlying balance of the `owner`
    /// @dev This also accrues interest in a transaction
    /// @param owner The address of the account to query
    /// @return The amount of underlying owned by `owner`
    function balanceOfUnderlying(address owner) external override returns (uint) {
        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR, "calc failed");
        return balance;
    }

    /*** User Interface ***/

    /// @notice Sender supplies assets into the market and receives lTokens in exchange
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param mintAmount The amount of the underlying asset to supply
    function mint(uint mintAmount) external override nonReentrant {
        accrueInterest();
        mintFresh(msg.sender, mintAmount, false);
    }

    function mintTo(address to, uint amount) external payable override nonReentrant {
        accrueInterest();
        if (isWethPool) {
            mintFresh(to, msg.value, false);
        } else {
            mintFresh(to, amount, true);
        }
    }

    function mintEth() external payable override nonReentrant {
        require(isWethPool, "not eth pool");
        accrueInterest();
        mintFresh(msg.sender, msg.value, false);
    }

    /// @notice Sender redeems lTokens in exchange for the underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemTokens The number of lTokens to redeem into underlying
    function redeem(uint redeemTokens) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, redeemTokens, 0);
    }

    /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemAmount The amount of underlying to redeem
    function redeemUnderlying(uint redeemAmount) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, 0, redeemAmount);
    }

    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {
        accrueInterest();
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        borrowFresh(payable(borrower), msg.sender, borrowAmount);
    }

    /// @notice Sender repays a borrow belonging to borrower
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount The amount to repay
    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        repayBorrowFresh(msg.sender, borrower, repayAmount, false);
    }

    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        repayBorrowFresh(msg.sender, borrower, repayAmount, true);
    }


    /*** Safe Token ***/

    /// Gets balance of this contract in terms of the underlying
    /// @dev This excludes the value of the current message, if any
    /// @return The quantity of underlying tokens owned by this contract
    function getCashPrior() internal view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }


    /**
     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.
     *      This will revert due to insufficient balance or insufficient allowance.
     *      This function returns the actual amount received,
     *      which may be less than `amount` if there is a fee attached to the transfer.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {
        if (isWethPool && convertWeth) {
            actualAmount = msg.value;
            IWETH(underlying).deposit{value : actualAmount}();
        } else {
            actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);
        }
    }

    /**
     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory
     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to
     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified
     *      it is >= amount, this should not revert in normal conditions.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {
        if (isWethPool && convertWeth) {
            IWETH(underlying).withdraw(amount);
            to.transfer(amount);
        } else {
            IERC20(underlying).safeTransfer(to, amount);
        }
    }

    function availableForBorrow() external view override returns (uint){
        uint cash = getCashPrior();
        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);
        if (err0 != MathError.NO_ERROR) {
            return 0;
        }
        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);
        if (err1 != MathError.NO_ERROR) {
            return 0;
        }
        if (totalBorrows > maxAvailable) {
            return 0;
        }
        return maxAvailable - totalBorrows;
    }


    /// @notice Get a snapshot of the account's balances, and the cached exchange rate
    /// @dev This is used by controller to more efficiently perform liquidity checks.
    /// @param account Address of the account to snapshot
    /// @return ( token balance, borrow balance, exchange rate mantissa)
    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        return (cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /// @dev Function to simply retrieve block number
    ///  This exists mainly for inheriting test contracts to stub this result.
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /// @notice Returns the current per-block borrow interest rate for this cToken
    /// @return The borrow interest rate per block, scaled by 1e18
    function borrowRatePerBlock() external override view returns (uint) {
        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
    }

    
    /// @notice Returns the current per-block supply interest rate for this cToken
    /// @return The supply interest rate per block, scaled by 1e18
    function supplyRatePerBlock() external override view returns (uint) {
        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);
    }

    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {
        // Utilization rate is 0 when there are no borrows
        if (borrows == 0) {
            return 0;
        }
        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));
    }

    /// @notice Calculates the current borrow rate per block, with the error code expected by the market
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18)
    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {
        uint util = utilizationRate(cash, borrows, reserves);
        if (util <= kink) {
            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
        } else {
            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
            uint excessUtil = util.sub(kink);
            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);
        }
    }

    /// @notice Calculates the current supply rate per block
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The supply rate percentage per block as a mantissa (scaled by 1e18)
    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {
        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);
        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);
        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);
        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);
    }

    /// @notice Returns the current total borrows plus accrued interest
    /// @return The total borrows with interest
    function totalBorrowsCurrent() external override view returns (uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return totalBorrows;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        return totalBorrowsNew;
    }

    /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
    /// @param account The address whose balance should be calculated after updating borrowIndex
    /// @return The calculated balance
    function borrowBalanceCurrent(address account) external view override returns (uint) {
        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();
        require(err0 == MathError.NO_ERROR, "calc borrow index fail");
        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
        require(err1 == MathError.NO_ERROR, "calc fail");
        return result;
    }

    function borrowBalanceStored(address account) external override view returns (uint){
        return accountBorrows[account].principal;
    }


    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
    }

    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /// @notice Accrue interest then return the up-to-date exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateCurrent() public override nonReentrant returns (uint) {
        accrueInterest();
        return exchangeRateStored();
    }

    /// Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateStored() public override view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "calc fail");
        return result;
    }

    /// @notice Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return (error code, calculated exchange rate scaled by 1e18)
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        uint _totalSupply = totalSupply;
        if (_totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint _totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /// @notice Get cash balance of this cToken in the underlying asset
    /// @return The quantity of underlying asset owned by this contract
    function getCash() external override view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }

    function calCurrentBorrowIndex() internal view returns (MathError, uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;
        uint borrowIndexNew;
        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return (MathError.NO_ERROR, borrowIndex);
        }
        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);

        Exp memory simpleInterestFactor;
        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }
        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);
        return (mathErr, borrowIndexNew);
    }

    /// @notice Applies accrued interest to total borrows and reserves
    /// @dev This calculates interest accrued from the last checkpointed block
    ///   up to the current block and writes new checkpoint to storage.
    function accrueInterest() public override {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint borrowIndexPrior = borrowIndex;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");


        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;
        uint borrowIndexNew;
        uint totalReservesNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total reserves error');

        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);
        require(mathErr == MathError.NO_ERROR, 'calc borrows index error');


        /* We write the previously calculated values into storage */
        accrualBlockNumber = currentBlockNumber;
        borrowIndex = borrowIndexNew;
        totalBorrows = totalBorrowsNew;
        totalReserves = totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);

    }

    struct MintLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
        uint actualMintAmount;
    }

    /// @notice User supplies assets into the market and receives lTokens in exchange
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param minter The address of the account which is supplying the assets
    /// @param mintAmount The amount of the underlying asset to supply
    /// @return uint the actual mint amount.
    function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {
        MintLocalVars memory vars;
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /*
         *  We call `doTransferIn` for the minter and the mintAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if
         *  side-effects occurred. The function returns the amount actually transferred,
         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`
         *  of cash.
         */
        if (isDelegete) {
            uint balanceBefore = getCashPrior();
            LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);
            uint balanceAfter = getCashPrior();
            require(balanceAfter > balanceBefore, 'mint 0');
            vars.actualMintAmount = balanceAfter - balanceBefore;
        } else {
            vars.actualMintAmount = doTransferIn(minter, mintAmount, true);
        }
        /*
         * We get the current exchange rate and calculate the number of lTokens to be minted:
         *  mintTokens = actualMintAmount / exchangeRate
         */

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));
        require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");

        /* Fail if mint not allowed */
        (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);
        /*
         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */

        return vars.actualMintAmount;
    }


    struct RedeemLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /// @notice User redeems lTokens in exchange for the underlying asset
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param redeemer The address of the account which is redeeming the tokens
    /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');
            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');
        require(getCashPrior() >= vars.redeemAmount, 'cash < redeem');

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;
        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(redeemer, vars.redeemAmount, true);


        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
    }

    struct BorrowLocalVars {
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /// @notice Users borrow assets from the protocol to their own address
    /// @param borrowAmount The amount of the underlying asset to borrow
    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {
        /* Fail if borrow not allowed */
        (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);

        /* Fail gracefully if protocol has insufficient underlying cash */
        require(getCashPrior() >= borrowAmount, 'cash<borrow');

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(payee, borrowAmount, false);

        /* We emit a Borrow event */
        emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
    }

    struct RepayBorrowLocalVars {
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
        uint actualRepayAmount;
        uint badDebtsAmount;
    }

    /// @notice Borrows are repaid by another user (possibly the borrower).
    /// @param payer the account paying off the borrow
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount the amount of undelrying tokens being returned
    function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {
        /* Fail if repayBorrow not allowed */
        (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(- 1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }
        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);


        if (isEnd && vars.accountBorrows > vars.actualRepayAmount) {
            vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;
        }

        /*
        *  We calculate the new borrower and total borrow balances, failing on underflow:
        *  accountBorrowsNew = accountBorrows - repayAmount
        *  totalBorrowsNew = totalBorrows - repayAmount
        */
        if (vars.accountBorrows < vars.actualRepayAmount) {
            require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) <= 105e16, 'repay more than 5%');
            vars.accountBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.accountBorrowsNew = 0;
            } else {
                vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;
            }
        }
        //Avoid mantissa errors
        if (vars.actualRepayAmount > totalBorrows) {
            vars.totalBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);
            } else {
                vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;
            }
        }

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */

        return vars.actualRepayAmount;
    }

    /*** Admin Functions ***/

    /// @notice Sets a new CONTROLLER for the market
    /// @dev Admin function to set a new controller
    function setController(address newController) external override onlyAdmin {
        require(address(0) != newController, "0x");
        address oldController = controller;
        controller = newController;
        // Emit NewController(oldController, newController)
        emit NewController(oldController, newController);
    }

    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {
        require(newBorrowCapFactorMantissa <= 1e18, 'Factor too large');
        uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;
        borrowCapFactorMantissa = newBorrowCapFactorMantissa;
        emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa);
    }

    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {
        //accrueInterest except first
        if (baseRatePerBlock != 0) {
            accrueInterest();
        }
        // total rate perYear < 2000%
        require(baseRatePerBlock_ < 1e13, 'Base rate too large');
        baseRatePerBlock = baseRatePerBlock_;
        require(multiplierPerBlock_ < 1e13, 'Mul rate too large');
        multiplierPerBlock = multiplierPerBlock_;
        require(jumpMultiplierPerBlock_ < 1e13, 'Jump rate too large');
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        require(kink_ <= 1e18, 'Kline too large');
        kink = kink_;
        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);
    }

    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {
        require(newReserveFactorMantissa <= 1e18, 'Factor too large');
        accrueInterest();
        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;
        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);
    }

    function addReserves(uint addAmount) external override nonReentrant {
        accrueInterest();
        uint totalReservesNew;
        uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);
        totalReservesNew = totalReserves.add(actualAddAmount);
        totalReserves = totalReservesNew;
        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);
    }

    function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {
        accrueInterest();
        uint totalReservesNew;
        totalReservesNew = totalReserves.sub(reduceAmount);
        totalReserves = totalReservesNew;
        doTransferOut(to, reduceAmount, true);
        emit ReservesReduced(to, reduceAmount, totalReservesNew);
    }

    modifier sameBlock() {
        require(accrualBlockNumber == getBlockNumber(), 'not same block');
        _;
    }
}

.]

###

[2024-24-08 19:28:41 INFO] **[Seminar Conclusion]**:

 ###

[2024-24-08 19:28:41 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-24-08 19:28:41 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.7.6; import "./LPoolInterface.sol"; import "./LPoolDepositor.sol"; import "../lib/Exponential.sol"; import "../Adminable.sol"; import "../lib/CarefulMath.sol"; import "../lib/TransferHelper.sol"; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import "../DelegateInterface.sol"; import "../ControllerInterface.sol"; import "../IWETH.sol"; /// @title OpenLeverage's LToken Contract /// @dev Abstract base for LTokens /// @author OpenLeverage contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {     using TransferHelper for IERC20;     using SafeMath for uint; constructor() {  }  /// @notice Initialize the money market /// @param controller_ The address of the Controller /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0 /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point /// @param kink_ The utilization point at which the jump multiplier is applied /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18 /// @param name_ EIP-20 name of this token /// @param symbol_ EIP-20 symbol of this token /// @param decimals_ EIP-20 decimal precision of this token function initialize(     address underlying_,     bool isWethPool_,     address controller_,     uint256 baseRatePerBlock_,     uint256 multiplierPerBlock_,     uint256 jumpMultiplierPerBlock_,     uint256 kink_,     uint initialExchangeRateMantissa_,     string memory name_,     string memory symbol_,     uint8 decimals_) public {     require(underlying_ != address(0), "underlying_ address cannot be 0");     require(controller_ != address(0), "controller_ address cannot be 0");     require(msg.sender == admin, "Only allow to be called by admin");     require(accrualBlockNumber == 0 &amp;&amp; borrowIndex == 0, "inited once");      // Set initial exchange rate     initialExchangeRateMantissa = initialExchangeRateMantissa_;     require(initialExchangeRateMantissa &gt; 0, "Initial Exchange Rate Mantissa should be greater zero");     //set controller     controller = controller_;     isWethPool = isWethPool_;     //set interestRateModel     baseRatePerBlock = baseRatePerBlock_;     multiplierPerBlock = multiplierPerBlock_;     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     kink = kink_;      // Initialize block number and borrow index (block number mocks depend on controller being set)     accrualBlockNumber = getBlockNumber();     borrowIndex = 1e25;     //80%     borrowCapFactorMantissa = 0.8e18;     //10%     reserveFactorMantissa = 0.1e18;       name = name_;     symbol = symbol_;     decimals = decimals_;      _notEntered = true;      // Set underlying and sanity check it     underlying = underlying_;     IERC20(underlying).totalSupply();     emit Transfer(address(0), msg.sender, 0); }  /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender` /// @dev Called by both `transfer` and `transferFrom` internally /// @param spender The address of the account performing the transfer /// @param src The address of the source account /// @param dst The address of the destination account /// @param tokens The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {     require(dst != address(0), "dst address cannot be 0");     /* Do not allow self-transfers */     require(src != dst, "src = dst");     /* Fail if transfer not allowed */     (ControllerInterface(controller)).transferAllowed(src, dst, tokens);      /* Get the allowance, infinite for the account owner */     uint startingAllowance = 0;     if (spender == src) {         startingAllowance = uint(- 1);     } else {         startingAllowance = transferAllowances[src][spender];     }      /* Do the calculations, checking for {under,over}flow */     MathError mathErr;     uint allowanceNew;     uint srcTokensNew;     uint dstTokensNew;      (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);     require(mathErr == MathError.NO_ERROR, 'not allowed');      (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);     require(mathErr == MathError.NO_ERROR, 'not enough');      (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);     require(mathErr == MathError.NO_ERROR, 'too much');      accountTokens[src] = srcTokensNew;     accountTokens[dst] = dstTokensNew;      /* Eat some of the allowance (if necessary) */     if (startingAllowance != uint(- 1)) {         transferAllowances[src][spender] = allowanceNew;     }     /* We emit a Transfer event */     emit Transfer(src, dst, tokens);     return true; }  /// @notice Transfer `amount` tokens from `msg.sender` to `dst` /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, msg.sender, dst, amount); }  /// @notice Transfer `amount` tokens from `src` to `dst` /// @param src The address of the source account /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, src, dst, amount); }  /// @notice Approve `spender` to transfer up to `amount` from `src` /// @dev This will overwrite the approval amount for `spender` ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve) /// @param spender The address of the account which may transfer tokens /// @param amount The number of tokens that are approved (-1 means infinite) /// @return Whether or not the approval succeeded function approve(address spender, uint256 amount) external override returns (bool) {     address src = msg.sender;     transferAllowances[src][spender] = amount;     emit Approval(src, spender, amount);     return true; }  /// @notice Get the current allowance from `owner` for `spender` /// @param owner The address of the account which owns the tokens to be spent /// @param spender The address of the account which may transfer tokens /// @return The number of tokens allowed to be spent (-1 means infinite) function allowance(address owner, address spender) external override view returns (uint256) {     return transferAllowances[owner][spender]; }  /// @notice Get the token balance of the `owner` /// @param owner The address of the account to query /// @return The number of tokens owned by `owner` function balanceOf(address owner) external override view returns (uint256) {     return accountTokens[owner]; }  /// @notice Get the underlying balance of the `owner` /// @dev This also accrues interest in a transaction /// @param owner The address of the account to query /// @return The amount of underlying owned by `owner` function balanceOfUnderlying(address owner) external override returns (uint) {     Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});     (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);     require(mErr == MathError.NO_ERROR, "calc failed");     return balance; }  /*** User Interface ***/  /// @notice Sender supplies assets into the market and receives lTokens in exchange /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param mintAmount The amount of the underlying asset to supply function mint(uint mintAmount) external override nonReentrant {     accrueInterest();     mintFresh(msg.sender, mintAmount, false); }  function mintTo(address to, uint amount) external payable override nonReentrant {     accrueInterest();     if (isWethPool) {         mintFresh(to, msg.value, false);     } else {         mintFresh(to, amount, true);     } }  function mintEth() external payable override nonReentrant {     require(isWethPool, "not eth pool");     accrueInterest();     mintFresh(msg.sender, msg.value, false); }  /// @notice Sender redeems lTokens in exchange for the underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemTokens The number of lTokens to redeem into underlying function redeem(uint redeemTokens) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, redeemTokens, 0); }  /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemAmount The amount of underlying to redeem function redeemUnderlying(uint redeemAmount) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, 0, redeemAmount); }  function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {     accrueInterest();     // borrowFresh emits borrow-specific logs on errors, so we don't need to     borrowFresh(payable(borrower), msg.sender, borrowAmount); }  /// @notice Sender repays a borrow belonging to borrower /// @param borrower the account with the debt being payed off /// @param repayAmount The amount to repay function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     repayBorrowFresh(msg.sender, borrower, repayAmount, false); }  function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     repayBorrowFresh(msg.sender, borrower, repayAmount, true); }   /*** Safe Token ***/  /// Gets balance of this contract in terms of the underlying /// @dev This excludes the value of the current message, if any /// @return The quantity of underlying tokens owned by this contract function getCashPrior() internal view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }   /**  * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.  *      This will revert due to insufficient balance or insufficient allowance.  *      This function returns the actual amount received,  *      which may be less than `amount` if there is a fee attached to the transfer.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {     if (isWethPool &amp;&amp; convertWeth) {         actualAmount = msg.value;         IWETH(underlying).deposit{value : actualAmount}();     } else {         actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);     } }  /**  * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory  *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to  *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified  *      it is &gt;= amount, this should not revert in normal conditions.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferOut(address payable to, uint amount, bool convertWeth) internal {     if (isWethPool &amp;&amp; convertWeth) {         IWETH(underlying).withdraw(amount);         to.transfer(amount);     } else {         IERC20(underlying).safeTransfer(to, amount);     } }  function availableForBorrow() external view override returns (uint){     uint cash = getCashPrior();     (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);     if (err0 != MathError.NO_ERROR) {         return 0;     }     (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);     if (err1 != MathError.NO_ERROR) {         return 0;     }     if (totalBorrows &gt; maxAvailable) {         return 0;     }     return maxAvailable - totalBorrows; }   /// @notice Get a snapshot of the account's balances, and the cached exchange rate /// @dev This is used by controller to more efficiently perform liquidity checks. /// @param account Address of the account to snapshot /// @return ( token balance, borrow balance, exchange rate mantissa) function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {     uint cTokenBalance = accountTokens[account];     uint borrowBalance;     uint exchangeRateMantissa;      MathError mErr;      (mErr, borrowBalance) = borrowBalanceStoredInternal(account);     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      return (cTokenBalance, borrowBalance, exchangeRateMantissa); }  /// @dev Function to simply retrieve block number ///  This exists mainly for inheriting test contracts to stub this result. function getBlockNumber() internal view returns (uint) {     return block.number; }  /// @notice Returns the current per-block borrow interest rate for this cToken /// @return The borrow interest rate per block, scaled by 1e18 function borrowRatePerBlock() external override view returns (uint) {     return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves); }   /// @notice Returns the current per-block supply interest rate for this cToken /// @return The supply interest rate per block, scaled by 1e18 function supplyRatePerBlock() external override view returns (uint) {     return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa); }  function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {     // Utilization rate is 0 when there are no borrows     if (borrows == 0) {         return 0;     }     return borrows.mul(1e18).div(cash.add(borrows).sub(reserves)); }  /// @notice Calculates the current borrow rate per block, with the error code expected by the market /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18) function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {     uint util = utilizationRate(cash, borrows, reserves);     if (util &lt;= kink) {         return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);     } else {         uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);         uint excessUtil = util.sub(kink);         return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);     } }  /// @notice Calculates the current supply rate per block /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The supply rate percentage per block as a mantissa (scaled by 1e18) function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {     uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);     uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);     uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);     return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18); }  /// @notice Returns the current total borrows plus accrued interest /// @return The total borrows with interest function totalBorrowsCurrent() external override view returns (uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return totalBorrows;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, "calc block delta erro");      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      return totalBorrowsNew; }  /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex /// @param account The address whose balance should be calculated after updating borrowIndex /// @return The calculated balance function borrowBalanceCurrent(address account) external view override returns (uint) {     (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();     require(err0 == MathError.NO_ERROR, "calc borrow index fail");     (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);     require(err1 == MathError.NO_ERROR, "calc fail");     return result; }  function borrowBalanceStored(address account) external override view returns (uint){     return accountBorrows[account].principal; }   /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {     return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex); }  /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {     /* Note: we do not assert that the market is up to date */     MathError mathErr;     uint principalTimesIndex;     uint result;      /* Get borrowBalance and borrowIndex */     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];      /* If borrowBalance = 0 then borrowIndex is likely also 0.      * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.      */     if (borrowSnapshot.principal == 0) {         return (MathError.NO_ERROR, 0);     }      /* Calculate new borrow balance using the interest index:      *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex      */     (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      return (MathError.NO_ERROR, result); }  /// @notice Accrue interest then return the up-to-date exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateCurrent() public override nonReentrant returns (uint) {     accrueInterest();     return exchangeRateStored(); }  /// Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateStored() public override view returns (uint) {     (MathError err, uint result) = exchangeRateStoredInternal();     require(err == MathError.NO_ERROR, "calc fail");     return result; }  /// @notice Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return (error code, calculated exchange rate scaled by 1e18) function exchangeRateStoredInternal() internal view returns (MathError, uint) {     uint _totalSupply = totalSupply;     if (_totalSupply == 0) {         /*          * If there are no tokens minted:          *  exchangeRate = initialExchangeRate          */         return (MathError.NO_ERROR, initialExchangeRateMantissa);     } else {         /*          * Otherwise:          *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply          */         uint _totalCash = getCashPrior();         uint cashPlusBorrowsMinusReserves;         Exp memory exchangeRate;         MathError mathErr;          (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          return (MathError.NO_ERROR, exchangeRate.mantissa);     } }  /// @notice Get cash balance of this cToken in the underlying asset /// @return The quantity of underlying asset owned by this contract function getCash() external override view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }  function calCurrentBorrowIndex() internal view returns (MathError, uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;     uint borrowIndexNew;     /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return (MathError.NO_ERROR, borrowIndex);     }     uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);      Exp memory simpleInterestFactor;     (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }     (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);     return (mathErr, borrowIndexNew); }  /// @notice Applies accrued interest to total borrows and reserves /// @dev This calculates interest accrued from the last checkpointed block ///   up to the current block and writes new checkpoint to storage. function accrueInterest() public override {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint borrowIndexPrior = borrowIndex;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, "calc block delta erro");       /*      * Calculate the interest accumulated into borrows and reserves and the new index:      *  simpleInterestFactor = borrowRate * blockDelta      *  interestAccumulated = simpleInterestFactor * totalBorrows      *  totalBorrowsNew = interestAccumulated + totalBorrows      *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex      */      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;     uint borrowIndexNew;     uint totalReservesNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);     require(mathErr == MathError.NO_ERROR, 'calc total reserves error');      (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);     require(mathErr == MathError.NO_ERROR, 'calc borrows index error');       /* We write the previously calculated values into storage */     accrualBlockNumber = currentBlockNumber;     borrowIndex = borrowIndexNew;     totalBorrows = totalBorrowsNew;     totalReserves = totalReservesNew;      /* We emit an AccrueInterest event */     emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);  }  struct MintLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint mintTokens;     uint totalSupplyNew;     uint accountTokensNew;     uint actualMintAmount; }  /// @notice User supplies assets into the market and receives lTokens in exchange /// @dev Assumes interest has already been accrued up to the current block /// @param minter The address of the account which is supplying the assets /// @param mintAmount The amount of the underlying asset to supply /// @return uint the actual mint amount. function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {     MintLocalVars memory vars;     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /*      *  We call `doTransferIn` for the minter and the mintAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if      *  side-effects occurred. The function returns the amount actually transferred,      *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`      *  of cash.      */     if (isDelegete) {         uint balanceBefore = getCashPrior();         LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);         uint balanceAfter = getCashPrior();         require(balanceAfter &gt; balanceBefore, 'mint 0');         vars.actualMintAmount = balanceAfter - balanceBefore;     } else {         vars.actualMintAmount = doTransferIn(minter, mintAmount, true);     }     /*      * We get the current exchange rate and calculate the number of lTokens to be minted:      *  mintTokens = actualMintAmount / exchangeRate      */      (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));     require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");      /* Fail if mint not allowed */     (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);     /*      * We calculate the new total supply of lTokens and minter token balance, checking for overflow:      *  totalSupplyNew = totalSupply + mintTokens      *  accountTokensNew = accountTokens[minter] + mintTokens      */     (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");      (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[minter] = vars.accountTokensNew;      /* We emit a Mint event, and a Transfer event */     emit Mint(minter, vars.actualMintAmount, vars.mintTokens);     emit Transfer(address(this), minter, vars.mintTokens);      /* We call the defense hook */      return vars.actualMintAmount; }   struct RedeemLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint redeemTokens;     uint redeemAmount;     uint totalSupplyNew;     uint accountTokensNew; }  /// @notice User redeems lTokens in exchange for the underlying asset /// @dev Assumes interest has already been accrued up to the current block /// @param redeemer The address of the account which is redeeming the tokens /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero) /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero) function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {     require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");      RedeemLocalVars memory vars;      /* exchangeRate = invoke Exchange Rate Stored() */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /* If redeemTokensIn &gt; 0: */     if (redeemTokensIn &gt; 0) {         /*          * We calculate the exchange rate and the amount of underlying to be redeemed:          *  redeemTokens = redeemTokensIn          *  redeemAmount = redeemTokensIn x exchangeRateCurrent          */         vars.redeemTokens = redeemTokensIn;          (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');     } else {         /*          * We get the current exchange rate and calculate the amount to be redeemed:          *  redeemTokens = redeemAmountIn / exchangeRate          *  redeemAmount = redeemAmountIn          */          (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');         vars.redeemAmount = redeemAmountIn;     }      /* Fail if redeem not allowed */     (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);      /*      * We calculate the new total supply and redeemer balance, checking for underflow:      *  totalSupplyNew = totalSupply - redeemTokens      *  accountTokensNew = accountTokens[redeemer] - redeemTokens      */     (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');      (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');     require(getCashPrior() &gt;= vars.redeemAmount, 'cash &lt; redeem');      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[redeemer] = vars.accountTokensNew;     /*      * We invoke doTransferOut for the redeemer and the redeemAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken has redeemAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(redeemer, vars.redeemAmount, true);       /* We emit a Transfer event, and a Redeem event */     emit Transfer(redeemer, address(this), vars.redeemTokens);     emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);      /* We call the defense hook */ }  struct BorrowLocalVars {     MathError mathErr;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /// @notice Users borrow assets from the protocol to their own address /// @param borrowAmount The amount of the underlying asset to borrow function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {     /* Fail if borrow not allowed */     (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);      /* Fail gracefully if protocol has insufficient underlying cash */     require(getCashPrior() &gt;= borrowAmount, 'cash&lt;borrow');      BorrowLocalVars memory vars;      /*      * We calculate the new borrower and total borrow balances, failing on overflow:      *  accountBorrowsNew = accountBorrows + borrowAmount      *  totalBorrowsNew = totalBorrows + borrowAmount      */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /*      * We invoke doTransferOut for the borrower and the borrowAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken borrowAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(payee, borrowAmount, false);      /* We emit a Borrow event */     emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */ }  struct RepayBorrowLocalVars {     MathError mathErr;     uint repayAmount;     uint borrowerIndex;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew;     uint actualRepayAmount;     uint badDebtsAmount; }  /// @notice Borrows are repaid by another user (possibly the borrower). /// @param payer the account paying off the borrow /// @param borrower the account with the debt being payed off /// @param repayAmount the amount of undelrying tokens being returned function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {     /* Fail if repayBorrow not allowed */     (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);      RepayBorrowLocalVars memory vars;      /* We remember the original borrowerIndex for verification purposes */     vars.borrowerIndex = accountBorrows[borrower].interestIndex;      /* We fetch the amount the borrower owes, with accumulated interest */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');      /* If repayAmount == -1, repayAmount = accountBorrows */     if (repayAmount == uint(- 1)) {         vars.repayAmount = vars.accountBorrows;     } else {         vars.repayAmount = repayAmount;     }     vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);       if (isEnd &amp;&amp; vars.accountBorrows &gt; vars.actualRepayAmount) {         vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;     }      /*     *  We calculate the new borrower and total borrow balances, failing on underflow:     *  accountBorrowsNew = accountBorrows - repayAmount     *  totalBorrowsNew = totalBorrows - repayAmount     */     if (vars.accountBorrows &lt; vars.actualRepayAmount) {         require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) &lt;= 105e16, 'repay more than 5%');         vars.accountBorrowsNew = 0;     } else {         if (isEnd) {             vars.accountBorrowsNew = 0;         } else {             vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;         }     }     //Avoid mantissa errors     if (vars.actualRepayAmount &gt; totalBorrows) {         vars.totalBorrowsNew = 0;     } else {         if (isEnd) {             vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);         } else {             vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;         }     }      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a RepayBorrow event */     emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */      return vars.actualRepayAmount; }  /*** Admin Functions ***/  /// @notice Sets a new CONTROLLER for the market /// @dev Admin function to set a new controller function setController(address newController) external override onlyAdmin {     require(address(0) != newController, "0x");     address oldController = controller;     controller = newController;     // Emit NewController(oldController, newController)     emit NewController(oldController, newController); }  function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {     require(newBorrowCapFactorMantissa &lt;= 1e18, 'Factor too large');     uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;     borrowCapFactorMantissa = newBorrowCapFactorMantissa;     emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa); }  function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {     //accrueInterest except first     if (baseRatePerBlock != 0) {         accrueInterest();     }     // total rate perYear &lt; 2000%     require(baseRatePerBlock_ &lt; 1e13, 'Base rate too large');     baseRatePerBlock = baseRatePerBlock_;     require(multiplierPerBlock_ &lt; 1e13, 'Mul rate too large');     multiplierPerBlock = multiplierPerBlock_;     require(jumpMultiplierPerBlock_ &lt; 1e13, 'Jump rate too large');     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     require(kink_ &lt;= 1e18, 'Kline too large');     kink = kink_;     emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_); }  function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {     require(newReserveFactorMantissa &lt;= 1e18, 'Factor too large');     accrueInterest();     uint oldReserveFactorMantissa = reserveFactorMantissa;     reserveFactorMantissa = newReserveFactorMantissa;     emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa); }  function addReserves(uint addAmount) external override nonReentrant {     accrueInterest();     uint totalReservesNew;     uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);     totalReservesNew = totalReserves.add(actualAddAmount);     totalReserves = totalReservesNew;     emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew); }  function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {     accrueInterest();     uint totalReservesNew;     totalReservesNew = totalReserves.sub(reduceAmount);     totalReserves = totalReservesNew;     doTransferOut(to, reduceAmount, true);     emit ReservesReduced(to, reduceAmount, totalReservesNew); }  modifier sameBlock() {     require(accrualBlockNumber == getBlockNumber(), 'not same block');     _; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-24-08 19:28:41 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.7.6; import "./LPoolInterface.sol"; import "./LPoolDepositor.sol"; import "../lib/Exponential.sol"; import "../Adminable.sol"; import "../lib/CarefulMath.sol"; import "../lib/TransferHelper.sol"; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import "../DelegateInterface.sol"; import "../ControllerInterface.sol"; import "../IWETH.sol"; /// @title OpenLeverage's LToken Contract /// @dev Abstract base for LTokens /// @author OpenLeverage contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {     using TransferHelper for IERC20;     using SafeMath for uint; constructor() {  }  /// @notice Initialize the money market /// @param controller_ The address of the Controller /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0 /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point /// @param kink_ The utilization point at which the jump multiplier is applied /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18 /// @param name_ EIP-20 name of this token /// @param symbol_ EIP-20 symbol of this token /// @param decimals_ EIP-20 decimal precision of this token function initialize(     address underlying_,     bool isWethPool_,     address controller_,     uint256 baseRatePerBlock_,     uint256 multiplierPerBlock_,     uint256 jumpMultiplierPerBlock_,     uint256 kink_,     uint initialExchangeRateMantissa_,     string memory name_,     string memory symbol_,     uint8 decimals_) public {     require(underlying_ != address(0), "underlying_ address cannot be 0");     require(controller_ != address(0), "controller_ address cannot be 0");     require(msg.sender == admin, "Only allow to be called by admin");     require(accrualBlockNumber == 0 &amp;&amp; borrowIndex == 0, "inited once");      // Set initial exchange rate     initialExchangeRateMantissa = initialExchangeRateMantissa_;     require(initialExchangeRateMantissa &gt; 0, "Initial Exchange Rate Mantissa should be greater zero");     //set controller     controller = controller_;     isWethPool = isWethPool_;     //set interestRateModel     baseRatePerBlock = baseRatePerBlock_;     multiplierPerBlock = multiplierPerBlock_;     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     kink = kink_;      // Initialize block number and borrow index (block number mocks depend on controller being set)     accrualBlockNumber = getBlockNumber();     borrowIndex = 1e25;     //80%     borrowCapFactorMantissa = 0.8e18;     //10%     reserveFactorMantissa = 0.1e18;       name = name_;     symbol = symbol_;     decimals = decimals_;      _notEntered = true;      // Set underlying and sanity check it     underlying = underlying_;     IERC20(underlying).totalSupply();     emit Transfer(address(0), msg.sender, 0); }  /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender` /// @dev Called by both `transfer` and `transferFrom` internally /// @param spender The address of the account performing the transfer /// @param src The address of the source account /// @param dst The address of the destination account /// @param tokens The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {     require(dst != address(0), "dst address cannot be 0");     /* Do not allow self-transfers */     require(src != dst, "src = dst");     /* Fail if transfer not allowed */     (ControllerInterface(controller)).transferAllowed(src, dst, tokens);      /* Get the allowance, infinite for the account owner */     uint startingAllowance = 0;     if (spender == src) {         startingAllowance = uint(- 1);     } else {         startingAllowance = transferAllowances[src][spender];     }      /* Do the calculations, checking for {under,over}flow */     MathError mathErr;     uint allowanceNew;     uint srcTokensNew;     uint dstTokensNew;      (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);     require(mathErr == MathError.NO_ERROR, 'not allowed');      (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);     require(mathErr == MathError.NO_ERROR, 'not enough');      (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);     require(mathErr == MathError.NO_ERROR, 'too much');      accountTokens[src] = srcTokensNew;     accountTokens[dst] = dstTokensNew;      /* Eat some of the allowance (if necessary) */     if (startingAllowance != uint(- 1)) {         transferAllowances[src][spender] = allowanceNew;     }     /* We emit a Transfer event */     emit Transfer(src, dst, tokens);     return true; }  /// @notice Transfer `amount` tokens from `msg.sender` to `dst` /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, msg.sender, dst, amount); }  /// @notice Transfer `amount` tokens from `src` to `dst` /// @param src The address of the source account /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, src, dst, amount); }  /// @notice Approve `spender` to transfer up to `amount` from `src` /// @dev This will overwrite the approval amount for `spender` ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve) /// @param spender The address of the account which may transfer tokens /// @param amount The number of tokens that are approved (-1 means infinite) /// @return Whether or not the approval succeeded function approve(address spender, uint256 amount) external override returns (bool) {     address src = msg.sender;     transferAllowances[src][spender] = amount;     emit Approval(src, spender, amount);     return true; }  /// @notice Get the current allowance from `owner` for `spender` /// @param owner The address of the account which owns the tokens to be spent /// @param spender The address of the account which may transfer tokens /// @return The number of tokens allowed to be spent (-1 means infinite) function allowance(address owner, address spender) external override view returns (uint256) {     return transferAllowances[owner][spender]; }  /// @notice Get the token balance of the `owner` /// @param owner The address of the account to query /// @return The number of tokens owned by `owner` function balanceOf(address owner) external override view returns (uint256) {     return accountTokens[owner]; }  /// @notice Get the underlying balance of the `owner` /// @dev This also accrues interest in a transaction /// @param owner The address of the account to query /// @return The amount of underlying owned by `owner` function balanceOfUnderlying(address owner) external override returns (uint) {     Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});     (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);     require(mErr == MathError.NO_ERROR, "calc failed");     return balance; }  /*** User Interface ***/  /// @notice Sender supplies assets into the market and receives lTokens in exchange /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param mintAmount The amount of the underlying asset to supply function mint(uint mintAmount) external override nonReentrant {     accrueInterest();     mintFresh(msg.sender, mintAmount, false); }  function mintTo(address to, uint amount) external payable override nonReentrant {     accrueInterest();     if (isWethPool) {         mintFresh(to, msg.value, false);     } else {         mintFresh(to, amount, true);     } }  function mintEth() external payable override nonReentrant {     require(isWethPool, "not eth pool");     accrueInterest();     mintFresh(msg.sender, msg.value, false); }  /// @notice Sender redeems lTokens in exchange for the underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemTokens The number of lTokens to redeem into underlying function redeem(uint redeemTokens) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, redeemTokens, 0); }  /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemAmount The amount of underlying to redeem function redeemUnderlying(uint redeemAmount) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, 0, redeemAmount); }  function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {     accrueInterest();     // borrowFresh emits borrow-specific logs on errors, so we don't need to     borrowFresh(payable(borrower), msg.sender, borrowAmount); }  /// @notice Sender repays a borrow belonging to borrower /// @param borrower the account with the debt being payed off /// @param repayAmount The amount to repay function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     repayBorrowFresh(msg.sender, borrower, repayAmount, false); }  function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     repayBorrowFresh(msg.sender, borrower, repayAmount, true); }   /*** Safe Token ***/  /// Gets balance of this contract in terms of the underlying /// @dev This excludes the value of the current message, if any /// @return The quantity of underlying tokens owned by this contract function getCashPrior() internal view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }   /**  * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.  *      This will revert due to insufficient balance or insufficient allowance.  *      This function returns the actual amount received,  *      which may be less than `amount` if there is a fee attached to the transfer.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {     if (isWethPool &amp;&amp; convertWeth) {         actualAmount = msg.value;         IWETH(underlying).deposit{value : actualAmount}();     } else {         actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);     } }  /**  * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory  *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to  *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified  *      it is &gt;= amount, this should not revert in normal conditions.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferOut(address payable to, uint amount, bool convertWeth) internal {     if (isWethPool &amp;&amp; convertWeth) {         IWETH(underlying).withdraw(amount);         to.transfer(amount);     } else {         IERC20(underlying).safeTransfer(to, amount);     } }  function availableForBorrow() external view override returns (uint){     uint cash = getCashPrior();     (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);     if (err0 != MathError.NO_ERROR) {         return 0;     }     (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);     if (err1 != MathError.NO_ERROR) {         return 0;     }     if (totalBorrows &gt; maxAvailable) {         return 0;     }     return maxAvailable - totalBorrows; }   /// @notice Get a snapshot of the account's balances, and the cached exchange rate /// @dev This is used by controller to more efficiently perform liquidity checks. /// @param account Address of the account to snapshot /// @return ( token balance, borrow balance, exchange rate mantissa) function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {     uint cTokenBalance = accountTokens[account];     uint borrowBalance;     uint exchangeRateMantissa;      MathError mErr;      (mErr, borrowBalance) = borrowBalanceStoredInternal(account);     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      return (cTokenBalance, borrowBalance, exchangeRateMantissa); }  /// @dev Function to simply retrieve block number ///  This exists mainly for inheriting test contracts to stub this result. function getBlockNumber() internal view returns (uint) {     return block.number; }  /// @notice Returns the current per-block borrow interest rate for this cToken /// @return The borrow interest rate per block, scaled by 1e18 function borrowRatePerBlock() external override view returns (uint) {     return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves); }   /// @notice Returns the current per-block supply interest rate for this cToken /// @return The supply interest rate per block, scaled by 1e18 function supplyRatePerBlock() external override view returns (uint) {     return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa); }  function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {     // Utilization rate is 0 when there are no borrows     if (borrows == 0) {         return 0;     }     return borrows.mul(1e18).div(cash.add(borrows).sub(reserves)); }  /// @notice Calculates the current borrow rate per block, with the error code expected by the market /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18) function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {     uint util = utilizationRate(cash, borrows, reserves);     if (util &lt;= kink) {         return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);     } else {         uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);         uint excessUtil = util.sub(kink);         return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);     } }  /// @notice Calculates the current supply rate per block /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The supply rate percentage per block as a mantissa (scaled by 1e18) function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {     uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);     uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);     uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);     return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18); }  /// @notice Returns the current total borrows plus accrued interest /// @return The total borrows with interest function totalBorrowsCurrent() external override view returns (uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return totalBorrows;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, "calc block delta erro");      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      return totalBorrowsNew; }  /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex /// @param account The address whose balance should be calculated after updating borrowIndex /// @return The calculated balance function borrowBalanceCurrent(address account) external view override returns (uint) {     (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();     require(err0 == MathError.NO_ERROR, "calc borrow index fail");     (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);     require(err1 == MathError.NO_ERROR, "calc fail");     return result; }  function borrowBalanceStored(address account) external override view returns (uint){     return accountBorrows[account].principal; }   /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {     return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex); }  /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {     /* Note: we do not assert that the market is up to date */     MathError mathErr;     uint principalTimesIndex;     uint result;      /* Get borrowBalance and borrowIndex */     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];      /* If borrowBalance = 0 then borrowIndex is likely also 0.      * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.      */     if (borrowSnapshot.principal == 0) {         return (MathError.NO_ERROR, 0);     }      /* Calculate new borrow balance using the interest index:      *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex      */     (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      return (MathError.NO_ERROR, result); }  /// @notice Accrue interest then return the up-to-date exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateCurrent() public override nonReentrant returns (uint) {     accrueInterest();     return exchangeRateStored(); }  /// Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateStored() public override view returns (uint) {     (MathError err, uint result) = exchangeRateStoredInternal();     require(err == MathError.NO_ERROR, "calc fail");     return result; }  /// @notice Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return (error code, calculated exchange rate scaled by 1e18) function exchangeRateStoredInternal() internal view returns (MathError, uint) {     uint _totalSupply = totalSupply;     if (_totalSupply == 0) {         /*          * If there are no tokens minted:          *  exchangeRate = initialExchangeRate          */         return (MathError.NO_ERROR, initialExchangeRateMantissa);     } else {         /*          * Otherwise:          *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply          */         uint _totalCash = getCashPrior();         uint cashPlusBorrowsMinusReserves;         Exp memory exchangeRate;         MathError mathErr;          (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          return (MathError.NO_ERROR, exchangeRate.mantissa);     } }  /// @notice Get cash balance of this cToken in the underlying asset /// @return The quantity of underlying asset owned by this contract function getCash() external override view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }  function calCurrentBorrowIndex() internal view returns (MathError, uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;     uint borrowIndexNew;     /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return (MathError.NO_ERROR, borrowIndex);     }     uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);      Exp memory simpleInterestFactor;     (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }     (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);     return (mathErr, borrowIndexNew); }  /// @notice Applies accrued interest to total borrows and reserves /// @dev This calculates interest accrued from the last checkpointed block ///   up to the current block and writes new checkpoint to storage. function accrueInterest() public override {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint borrowIndexPrior = borrowIndex;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, "calc block delta erro");       /*      * Calculate the interest accumulated into borrows and reserves and the new index:      *  simpleInterestFactor = borrowRate * blockDelta      *  interestAccumulated = simpleInterestFactor * totalBorrows      *  totalBorrowsNew = interestAccumulated + totalBorrows      *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex      */      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;     uint borrowIndexNew;     uint totalReservesNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);     require(mathErr == MathError.NO_ERROR, 'calc total reserves error');      (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);     require(mathErr == MathError.NO_ERROR, 'calc borrows index error');       /* We write the previously calculated values into storage */     accrualBlockNumber = currentBlockNumber;     borrowIndex = borrowIndexNew;     totalBorrows = totalBorrowsNew;     totalReserves = totalReservesNew;      /* We emit an AccrueInterest event */     emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);  }  struct MintLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint mintTokens;     uint totalSupplyNew;     uint accountTokensNew;     uint actualMintAmount; }  /// @notice User supplies assets into the market and receives lTokens in exchange /// @dev Assumes interest has already been accrued up to the current block /// @param minter The address of the account which is supplying the assets /// @param mintAmount The amount of the underlying asset to supply /// @return uint the actual mint amount. function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {     MintLocalVars memory vars;     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /*      *  We call `doTransferIn` for the minter and the mintAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if      *  side-effects occurred. The function returns the amount actually transferred,      *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`      *  of cash.      */     if (isDelegete) {         uint balanceBefore = getCashPrior();         LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);         uint balanceAfter = getCashPrior();         require(balanceAfter &gt; balanceBefore, 'mint 0');         vars.actualMintAmount = balanceAfter - balanceBefore;     } else {         vars.actualMintAmount = doTransferIn(minter, mintAmount, true);     }     /*      * We get the current exchange rate and calculate the number of lTokens to be minted:      *  mintTokens = actualMintAmount / exchangeRate      */      (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));     require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");      /* Fail if mint not allowed */     (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);     /*      * We calculate the new total supply of lTokens and minter token balance, checking for overflow:      *  totalSupplyNew = totalSupply + mintTokens      *  accountTokensNew = accountTokens[minter] + mintTokens      */     (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");      (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[minter] = vars.accountTokensNew;      /* We emit a Mint event, and a Transfer event */     emit Mint(minter, vars.actualMintAmount, vars.mintTokens);     emit Transfer(address(this), minter, vars.mintTokens);      /* We call the defense hook */      return vars.actualMintAmount; }   struct RedeemLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint redeemTokens;     uint redeemAmount;     uint totalSupplyNew;     uint accountTokensNew; }  /// @notice User redeems lTokens in exchange for the underlying asset /// @dev Assumes interest has already been accrued up to the current block /// @param redeemer The address of the account which is redeeming the tokens /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero) /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero) function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {     require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");      RedeemLocalVars memory vars;      /* exchangeRate = invoke Exchange Rate Stored() */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /* If redeemTokensIn &gt; 0: */     if (redeemTokensIn &gt; 0) {         /*          * We calculate the exchange rate and the amount of underlying to be redeemed:          *  redeemTokens = redeemTokensIn          *  redeemAmount = redeemTokensIn x exchangeRateCurrent          */         vars.redeemTokens = redeemTokensIn;          (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');     } else {         /*          * We get the current exchange rate and calculate the amount to be redeemed:          *  redeemTokens = redeemAmountIn / exchangeRate          *  redeemAmount = redeemAmountIn          */          (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');         vars.redeemAmount = redeemAmountIn;     }      /* Fail if redeem not allowed */     (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);      /*      * We calculate the new total supply and redeemer balance, checking for underflow:      *  totalSupplyNew = totalSupply - redeemTokens      *  accountTokensNew = accountTokens[redeemer] - redeemTokens      */     (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');      (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');     require(getCashPrior() &gt;= vars.redeemAmount, 'cash &lt; redeem');      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[redeemer] = vars.accountTokensNew;     /*      * We invoke doTransferOut for the redeemer and the redeemAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken has redeemAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(redeemer, vars.redeemAmount, true);       /* We emit a Transfer event, and a Redeem event */     emit Transfer(redeemer, address(this), vars.redeemTokens);     emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);      /* We call the defense hook */ }  struct BorrowLocalVars {     MathError mathErr;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /// @notice Users borrow assets from the protocol to their own address /// @param borrowAmount The amount of the underlying asset to borrow function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {     /* Fail if borrow not allowed */     (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);      /* Fail gracefully if protocol has insufficient underlying cash */     require(getCashPrior() &gt;= borrowAmount, 'cash&lt;borrow');      BorrowLocalVars memory vars;      /*      * We calculate the new borrower and total borrow balances, failing on overflow:      *  accountBorrowsNew = accountBorrows + borrowAmount      *  totalBorrowsNew = totalBorrows + borrowAmount      */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /*      * We invoke doTransferOut for the borrower and the borrowAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken borrowAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(payee, borrowAmount, false);      /* We emit a Borrow event */     emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */ }  struct RepayBorrowLocalVars {     MathError mathErr;     uint repayAmount;     uint borrowerIndex;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew;     uint actualRepayAmount;     uint badDebtsAmount; }  /// @notice Borrows are repaid by another user (possibly the borrower). /// @param payer the account paying off the borrow /// @param borrower the account with the debt being payed off /// @param repayAmount the amount of undelrying tokens being returned function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {     /* Fail if repayBorrow not allowed */     (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);      RepayBorrowLocalVars memory vars;      /* We remember the original borrowerIndex for verification purposes */     vars.borrowerIndex = accountBorrows[borrower].interestIndex;      /* We fetch the amount the borrower owes, with accumulated interest */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');      /* If repayAmount == -1, repayAmount = accountBorrows */     if (repayAmount == uint(- 1)) {         vars.repayAmount = vars.accountBorrows;     } else {         vars.repayAmount = repayAmount;     }     vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);       if (isEnd &amp;&amp; vars.accountBorrows &gt; vars.actualRepayAmount) {         vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;     }      /*     *  We calculate the new borrower and total borrow balances, failing on underflow:     *  accountBorrowsNew = accountBorrows - repayAmount     *  totalBorrowsNew = totalBorrows - repayAmount     */     if (vars.accountBorrows &lt; vars.actualRepayAmount) {         require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) &lt;= 105e16, 'repay more than 5%');         vars.accountBorrowsNew = 0;     } else {         if (isEnd) {             vars.accountBorrowsNew = 0;         } else {             vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;         }     }     //Avoid mantissa errors     if (vars.actualRepayAmount &gt; totalBorrows) {         vars.totalBorrowsNew = 0;     } else {         if (isEnd) {             vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);         } else {             vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;         }     }      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a RepayBorrow event */     emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */      return vars.actualRepayAmount; }  /*** Admin Functions ***/  /// @notice Sets a new CONTROLLER for the market /// @dev Admin function to set a new controller function setController(address newController) external override onlyAdmin {     require(address(0) != newController, "0x");     address oldController = controller;     controller = newController;     // Emit NewController(oldController, newController)     emit NewController(oldController, newController); }  function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {     require(newBorrowCapFactorMantissa &lt;= 1e18, 'Factor too large');     uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;     borrowCapFactorMantissa = newBorrowCapFactorMantissa;     emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa); }  function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {     //accrueInterest except first     if (baseRatePerBlock != 0) {         accrueInterest();     }     // total rate perYear &lt; 2000%     require(baseRatePerBlock_ &lt; 1e13, 'Base rate too large');     baseRatePerBlock = baseRatePerBlock_;     require(multiplierPerBlock_ &lt; 1e13, 'Mul rate too large');     multiplierPerBlock = multiplierPerBlock_;     require(jumpMultiplierPerBlock_ &lt; 1e13, 'Jump rate too large');     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     require(kink_ &lt;= 1e18, 'Kline too large');     kink = kink_;     emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_); }  function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {     require(newReserveFactorMantissa &lt;= 1e18, 'Factor too large');     accrueInterest();     uint oldReserveFactorMantissa = reserveFactorMantissa;     reserveFactorMantissa = newReserveFactorMantissa;     emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa); }  function addReserves(uint addAmount) external override nonReentrant {     accrueInterest();     uint totalReservesNew;     uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);     totalReservesNew = totalReserves.add(actualAddAmount);     totalReserves = totalReservesNew;     emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew); }  function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {     accrueInterest();     uint totalReservesNew;     totalReservesNew = totalReserves.sub(reduceAmount);     totalReserves = totalReservesNew;     doTransferOut(to, reduceAmount, true);     emit ReservesReduced(to, reduceAmount, totalReservesNew); }  modifier sameBlock() {     require(accrualBlockNumber == getBlockNumber(), 'not same block');     _; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-24-08 19:28:41 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;


import "./LPoolInterface.sol";
import "./LPoolDepositor.sol";
import "../lib/Exponential.sol";
import "../Adminable.sol";
import "../lib/CarefulMath.sol";
import "../lib/TransferHelper.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import "../DelegateInterface.sol";
import "../ControllerInterface.sol";
import "../IWETH.sol";

/// @title OpenLeverage's LToken Contract
/// @dev Abstract base for LTokens
/// @author OpenLeverage
contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {
    using TransferHelper for IERC20;
    using SafeMath for uint;

    constructor() {

    }
    
    /// @notice Initialize the money market
    /// @param controller_ The address of the Controller
    /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0
    /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate
    /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point
    /// @param kink_ The utilization point at which the jump multiplier is applied
    /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
    /// @param name_ EIP-20 name of this token
    /// @param symbol_ EIP-20 symbol of this token
    /// @param decimals_ EIP-20 decimal precision of this token
    function initialize(
        address underlying_,
        bool isWethPool_,
        address controller_,
        uint256 baseRatePerBlock_,
        uint256 multiplierPerBlock_,
        uint256 jumpMultiplierPerBlock_,
        uint256 kink_,
        uint initialExchangeRateMantissa_,
        string memory name_,
        string memory symbol_,
        uint8 decimals_) public {
        require(underlying_ != address(0), "underlying_ address cannot be 0");
        require(controller_ != address(0), "controller_ address cannot be 0");
        require(msg.sender == admin, "Only allow to be called by admin");
        require(accrualBlockNumber == 0 && borrowIndex == 0, "inited once");

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial Exchange Rate Mantissa should be greater zero");
        //set controller
        controller = controller_;
        isWethPool = isWethPool_;
        //set interestRateModel
        baseRatePerBlock = baseRatePerBlock_;
        multiplierPerBlock = multiplierPerBlock_;
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        kink = kink_;

        // Initialize block number and borrow index (block number mocks depend on controller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = 1e25;
        //80%
        borrowCapFactorMantissa = 0.8e18;
        //10%
        reserveFactorMantissa = 0.1e18;


        name = name_;
        symbol = symbol_;
        decimals = decimals_;

        _notEntered = true;

        // Set underlying and sanity check it
        underlying = underlying_;
        IERC20(underlying).totalSupply();
        emit Transfer(address(0), msg.sender, 0);
    }

    /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
    /// @dev Called by both `transfer` and `transferFrom` internally
    /// @param spender The address of the account performing the transfer
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param tokens The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {
        require(dst != address(0), "dst address cannot be 0");
        /* Do not allow self-transfers */
        require(src != dst, "src = dst");
        /* Fail if transfer not allowed */
        (ControllerInterface(controller)).transferAllowed(src, dst, tokens);

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(- 1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        require(mathErr == MathError.NO_ERROR, 'not allowed');

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        require(mathErr == MathError.NO_ERROR, 'not enough');

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        require(mathErr == MathError.NO_ERROR, 'too much');

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(- 1)) {
            transferAllowances[src][spender] = allowanceNew;
        }
        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);
        return true;
    }

    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount);
    }

    /// @notice Transfer `amount` tokens from `src` to `dst`
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount);
    }

    /// @notice Approve `spender` to transfer up to `amount` from `src`
    /// @dev This will overwrite the approval amount for `spender`
    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
    /// @param spender The address of the account which may transfer tokens
    /// @param amount The number of tokens that are approved (-1 means infinite)
    /// @return Whether or not the approval succeeded
    function approve(address spender, uint256 amount) external override returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /// @notice Get the current allowance from `owner` for `spender`
    /// @param owner The address of the account which owns the tokens to be spent
    /// @param spender The address of the account which may transfer tokens
    /// @return The number of tokens allowed to be spent (-1 means infinite)
    function allowance(address owner, address spender) external override view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /// @notice Get the token balance of the `owner`
    /// @param owner The address of the account to query
    /// @return The number of tokens owned by `owner`
    function balanceOf(address owner) external override view returns (uint256) {
        return accountTokens[owner];
    }

    /// @notice Get the underlying balance of the `owner`
    /// @dev This also accrues interest in a transaction
    /// @param owner The address of the account to query
    /// @return The amount of underlying owned by `owner`
    function balanceOfUnderlying(address owner) external override returns (uint) {
        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR, "calc failed");
        return balance;
    }

    /*** User Interface ***/

    /// @notice Sender supplies assets into the market and receives lTokens in exchange
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param mintAmount The amount of the underlying asset to supply
    function mint(uint mintAmount) external override nonReentrant {
        accrueInterest();
        mintFresh(msg.sender, mintAmount, false);
    }

    function mintTo(address to, uint amount) external payable override nonReentrant {
        accrueInterest();
        if (isWethPool) {
            mintFresh(to, msg.value, false);
        } else {
            mintFresh(to, amount, true);
        }
    }

    function mintEth() external payable override nonReentrant {
        require(isWethPool, "not eth pool");
        accrueInterest();
        mintFresh(msg.sender, msg.value, false);
    }

    /// @notice Sender redeems lTokens in exchange for the underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemTokens The number of lTokens to redeem into underlying
    function redeem(uint redeemTokens) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, redeemTokens, 0);
    }

    /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemAmount The amount of underlying to redeem
    function redeemUnderlying(uint redeemAmount) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, 0, redeemAmount);
    }

    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {
        accrueInterest();
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        borrowFresh(payable(borrower), msg.sender, borrowAmount);
    }

    /// @notice Sender repays a borrow belonging to borrower
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount The amount to repay
    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        repayBorrowFresh(msg.sender, borrower, repayAmount, false);
    }

    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        repayBorrowFresh(msg.sender, borrower, repayAmount, true);
    }


    /*** Safe Token ***/

    /// Gets balance of this contract in terms of the underlying
    /// @dev This excludes the value of the current message, if any
    /// @return The quantity of underlying tokens owned by this contract
    function getCashPrior() internal view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }


    /**
     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.
     *      This will revert due to insufficient balance or insufficient allowance.
     *      This function returns the actual amount received,
     *      which may be less than `amount` if there is a fee attached to the transfer.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {
        if (isWethPool && convertWeth) {
            actualAmount = msg.value;
            IWETH(underlying).deposit{value : actualAmount}();
        } else {
            actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);
        }
    }

    /**
     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory
     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to
     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified
     *      it is >= amount, this should not revert in normal conditions.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {
        if (isWethPool && convertWeth) {
            IWETH(underlying).withdraw(amount);
            to.transfer(amount);
        } else {
            IERC20(underlying).safeTransfer(to, amount);
        }
    }

    function availableForBorrow() external view override returns (uint){
        uint cash = getCashPrior();
        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);
        if (err0 != MathError.NO_ERROR) {
            return 0;
        }
        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);
        if (err1 != MathError.NO_ERROR) {
            return 0;
        }
        if (totalBorrows > maxAvailable) {
            return 0;
        }
        return maxAvailable - totalBorrows;
    }


    /// @notice Get a snapshot of the account's balances, and the cached exchange rate
    /// @dev This is used by controller to more efficiently perform liquidity checks.
    /// @param account Address of the account to snapshot
    /// @return ( token balance, borrow balance, exchange rate mantissa)
    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        return (cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /// @dev Function to simply retrieve block number
    ///  This exists mainly for inheriting test contracts to stub this result.
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /// @notice Returns the current per-block borrow interest rate for this cToken
    /// @return The borrow interest rate per block, scaled by 1e18
    function borrowRatePerBlock() external override view returns (uint) {
        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
    }

    
    /// @notice Returns the current per-block supply interest rate for this cToken
    /// @return The supply interest rate per block, scaled by 1e18
    function supplyRatePerBlock() external override view returns (uint) {
        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);
    }

    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {
        // Utilization rate is 0 when there are no borrows
        if (borrows == 0) {
            return 0;
        }
        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));
    }

    /// @notice Calculates the current borrow rate per block, with the error code expected by the market
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18)
    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {
        uint util = utilizationRate(cash, borrows, reserves);
        if (util <= kink) {
            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
        } else {
            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
            uint excessUtil = util.sub(kink);
            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);
        }
    }

    /// @notice Calculates the current supply rate per block
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The supply rate percentage per block as a mantissa (scaled by 1e18)
    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {
        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);
        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);
        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);
        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);
    }

    /// @notice Returns the current total borrows plus accrued interest
    /// @return The total borrows with interest
    function totalBorrowsCurrent() external override view returns (uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return totalBorrows;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        return totalBorrowsNew;
    }

    /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
    /// @param account The address whose balance should be calculated after updating borrowIndex
    /// @return The calculated balance
    function borrowBalanceCurrent(address account) external view override returns (uint) {
        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();
        require(err0 == MathError.NO_ERROR, "calc borrow index fail");
        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
        require(err1 == MathError.NO_ERROR, "calc fail");
        return result;
    }

    function borrowBalanceStored(address account) external override view returns (uint){
        return accountBorrows[account].principal;
    }


    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
    }

    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /// @notice Accrue interest then return the up-to-date exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateCurrent() public override nonReentrant returns (uint) {
        accrueInterest();
        return exchangeRateStored();
    }

    /// Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateStored() public override view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "calc fail");
        return result;
    }

    /// @notice Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return (error code, calculated exchange rate scaled by 1e18)
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        uint _totalSupply = totalSupply;
        if (_totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint _totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /// @notice Get cash balance of this cToken in the underlying asset
    /// @return The quantity of underlying asset owned by this contract
    function getCash() external override view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }

    function calCurrentBorrowIndex() internal view returns (MathError, uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;
        uint borrowIndexNew;
        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return (MathError.NO_ERROR, borrowIndex);
        }
        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);

        Exp memory simpleInterestFactor;
        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }
        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);
        return (mathErr, borrowIndexNew);
    }

    /// @notice Applies accrued interest to total borrows and reserves
    /// @dev This calculates interest accrued from the last checkpointed block
    ///   up to the current block and writes new checkpoint to storage.
    function accrueInterest() public override {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint borrowIndexPrior = borrowIndex;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");


        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;
        uint borrowIndexNew;
        uint totalReservesNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total reserves error');

        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);
        require(mathErr == MathError.NO_ERROR, 'calc borrows index error');


        /* We write the previously calculated values into storage */
        accrualBlockNumber = currentBlockNumber;
        borrowIndex = borrowIndexNew;
        totalBorrows = totalBorrowsNew;
        totalReserves = totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);

    }

    struct MintLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
        uint actualMintAmount;
    }

    /// @notice User supplies assets into the market and receives lTokens in exchange
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param minter The address of the account which is supplying the assets
    /// @param mintAmount The amount of the underlying asset to supply
    /// @return uint the actual mint amount.
    function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {
        MintLocalVars memory vars;
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /*
         *  We call `doTransferIn` for the minter and the mintAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if
         *  side-effects occurred. The function returns the amount actually transferred,
         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`
         *  of cash.
         */
        if (isDelegete) {
            uint balanceBefore = getCashPrior();
            LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);
            uint balanceAfter = getCashPrior();
            require(balanceAfter > balanceBefore, 'mint 0');
            vars.actualMintAmount = balanceAfter - balanceBefore;
        } else {
            vars.actualMintAmount = doTransferIn(minter, mintAmount, true);
        }
        /*
         * We get the current exchange rate and calculate the number of lTokens to be minted:
         *  mintTokens = actualMintAmount / exchangeRate
         */

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));
        require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");

        /* Fail if mint not allowed */
        (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);
        /*
         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */

        return vars.actualMintAmount;
    }


    struct RedeemLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /// @notice User redeems lTokens in exchange for the underlying asset
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param redeemer The address of the account which is redeeming the tokens
    /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');
            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');
        require(getCashPrior() >= vars.redeemAmount, 'cash < redeem');

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;
        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(redeemer, vars.redeemAmount, true);


        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
    }

    struct BorrowLocalVars {
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /// @notice Users borrow assets from the protocol to their own address
    /// @param borrowAmount The amount of the underlying asset to borrow
    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {
        /* Fail if borrow not allowed */
        (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);

        /* Fail gracefully if protocol has insufficient underlying cash */
        require(getCashPrior() >= borrowAmount, 'cash<borrow');

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(payee, borrowAmount, false);

        /* We emit a Borrow event */
        emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
    }

    struct RepayBorrowLocalVars {
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
        uint actualRepayAmount;
        uint badDebtsAmount;
    }

    /// @notice Borrows are repaid by another user (possibly the borrower).
    /// @param payer the account paying off the borrow
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount the amount of undelrying tokens being returned
    function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {
        /* Fail if repayBorrow not allowed */
        (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(- 1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }
        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);


        if (isEnd && vars.accountBorrows > vars.actualRepayAmount) {
            vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;
        }

        /*
        *  We calculate the new borrower and total borrow balances, failing on underflow:
        *  accountBorrowsNew = accountBorrows - repayAmount
        *  totalBorrowsNew = totalBorrows - repayAmount
        */
        if (vars.accountBorrows < vars.actualRepayAmount) {
            require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) <= 105e16, 'repay more than 5%');
            vars.accountBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.accountBorrowsNew = 0;
            } else {
                vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;
            }
        }
        //Avoid mantissa errors
        if (vars.actualRepayAmount > totalBorrows) {
            vars.totalBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);
            } else {
                vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;
            }
        }

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */

        return vars.actualRepayAmount;
    }

    /*** Admin Functions ***/

    /// @notice Sets a new CONTROLLER for the market
    /// @dev Admin function to set a new controller
    function setController(address newController) external override onlyAdmin {
        require(address(0) != newController, "0x");
        address oldController = controller;
        controller = newController;
        // Emit NewController(oldController, newController)
        emit NewController(oldController, newController);
    }

    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {
        require(newBorrowCapFactorMantissa <= 1e18, 'Factor too large');
        uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;
        borrowCapFactorMantissa = newBorrowCapFactorMantissa;
        emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa);
    }

    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {
        //accrueInterest except first
        if (baseRatePerBlock != 0) {
            accrueInterest();
        }
        // total rate perYear < 2000%
        require(baseRatePerBlock_ < 1e13, 'Base rate too large');
        baseRatePerBlock = baseRatePerBlock_;
        require(multiplierPerBlock_ < 1e13, 'Mul rate too large');
        multiplierPerBlock = multiplierPerBlock_;
        require(jumpMultiplierPerBlock_ < 1e13, 'Jump rate too large');
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        require(kink_ <= 1e18, 'Kline too large');
        kink = kink_;
        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);
    }

    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {
        require(newReserveFactorMantissa <= 1e18, 'Factor too large');
        accrueInterest();
        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;
        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);
    }

    function addReserves(uint addAmount) external override nonReentrant {
        accrueInterest();
        uint totalReservesNew;
        uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);
        totalReservesNew = totalReserves.add(actualAddAmount);
        totalReserves = totalReservesNew;
        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);
    }

    function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {
        accrueInterest();
        uint totalReservesNew;
        totalReservesNew = totalReserves.sub(reduceAmount);
        totalReserves = totalReservesNew;
        doTransferOut(to, reduceAmount, true);
        emit ReservesReduced(to, reduceAmount, totalReservesNew);
    }

    modifier sameBlock() {
        require(accrualBlockNumber == getBlockNumber(), 'not same block');
        _;
    }
}

.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-24-08 19:28:52 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-24-08 19:28:52 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 10001
completion_tokens: 859
total_tokens: 10860
cost: $-1.000000


[2024-24-08 19:28:52 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;


import "./LPoolInterface.sol";
import "./LPoolDepositor.sol";
import "../lib/Exponential.sol";
import "../Adminable.sol";
import "../lib/CarefulMath.sol";
import "../lib/TransferHelper.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import "../DelegateInterface.sol";
import "../ControllerInterface.sol";
import "../IWETH.sol";

/// @title OpenLeverage's LToken Contract
/// @dev Abstract base for LTokens
/// @author OpenLeverage
contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {
    using TransferHelper for IERC20;
    using SafeMath for uint;

    constructor() {

    }
    
    /// @notice Initialize the money market
    /// @param controller_ The address of the Controller
    /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0
    /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate
    /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point
    /// @param kink_ The utilization point at which the jump multiplier is applied
    /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
    /// @param name_ EIP-20 name of this token
    /// @param symbol_ EIP-20 symbol of this token
    /// @param decimals_ EIP-20 decimal precision of this token
    function initialize(
        address underlying_,
        bool isWethPool_,
        address controller_,
        uint256 baseRatePerBlock_,
        uint256 multiplierPerBlock_,
        uint256 jumpMultiplierPerBlock_,
        uint256 kink_,
        uint initialExchangeRateMantissa_,
        string memory name_,
        string memory symbol_,
        uint8 decimals_) public {
        require(underlying_ != address(0), "underlying_ address cannot be 0");
        require(controller_ != address(0), "controller_ address cannot be 0");
        require(msg.sender == admin, "Only allow to be called by admin");
        require(accrualBlockNumber == 0 && borrowIndex == 0, "inited once");

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial Exchange Rate Mantissa should be greater zero");
        //set controller
        controller = controller_;
        isWethPool = isWethPool_;
        //set interestRateModel
        baseRatePerBlock = baseRatePerBlock_;
        multiplierPerBlock = multiplierPerBlock_;
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        kink = kink_;

        // Initialize block number and borrow index (block number mocks depend on controller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = 1e25;
        //80%
        borrowCapFactorMantissa = 0.8e18;
        //10%
        reserveFactorMantissa = 0.1e18;


        name = name_;
        symbol = symbol_;
        decimals = decimals_;

        _notEntered = true;

        // Set underlying and sanity check it
        underlying = underlying_;
        IERC20(underlying).totalSupply();
        emit Transfer(address(0), msg.sender, 0);
    }

    /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
    /// @dev Called by both `transfer` and `transferFrom` internally
    /// @param spender The address of the account performing the transfer
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param tokens The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {
        require(dst != address(0), "dst address cannot be 0");
        /* Do not allow self-transfers */
        require(src != dst, "src = dst");
        /* Fail if transfer not allowed */
        (ControllerInterface(controller)).transferAllowed(src, dst, tokens);

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(- 1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        require(mathErr == MathError.NO_ERROR, 'not allowed');

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        require(mathErr == MathError.NO_ERROR, 'not enough');

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        require(mathErr == MathError.NO_ERROR, 'too much');

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(- 1)) {
            transferAllowances[src][spender] = allowanceNew;
        }
        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);
        return true;
    }

    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount);
    }

    /// @notice Transfer `amount` tokens from `src` to `dst`
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount);
    }

    /// @notice Approve `spender` to transfer up to `amount` from `src`
    /// @dev This will overwrite the approval amount for `spender`
    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
    /// @param spender The address of the account which may transfer tokens
    /// @param amount The number of tokens that are approved (-1 means infinite)
    /// @return Whether or not the approval succeeded
    function approve(address spender, uint256 amount) external override returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /// @notice Get the current allowance from `owner` for `spender`
    /// @param owner The address of the account which owns the tokens to be spent
    /// @param spender The address of the account which may transfer tokens
    /// @return The number of tokens allowed to be spent (-1 means infinite)
    function allowance(address owner, address spender) external override view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /// @notice Get the token balance of the `owner`
    /// @param owner The address of the account to query
    /// @return The number of tokens owned by `owner`
    function balanceOf(address owner) external override view returns (uint256) {
        return accountTokens[owner];
    }

    /// @notice Get the underlying balance of the `owner`
    /// @dev This also accrues interest in a transaction
    /// @param owner The address of the account to query
    /// @return The amount of underlying owned by `owner`
    function balanceOfUnderlying(address owner) external override returns (uint) {
        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR, "calc failed");
        return balance;
    }

    /*** User Interface ***/

    /// @notice Sender supplies assets into the market and receives lTokens in exchange
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param mintAmount The amount of the underlying asset to supply
    function mint(uint mintAmount) external override nonReentrant {
        accrueInterest();
        mintFresh(msg.sender, mintAmount, false);
    }

    function mintTo(address to, uint amount) external payable override nonReentrant {
        accrueInterest();
        if (isWethPool) {
            mintFresh(to, msg.value, false);
        } else {
            mintFresh(to, amount, true);
        }
    }

    function mintEth() external payable override nonReentrant {
        require(isWethPool, "not eth pool");
        accrueInterest();
        mintFresh(msg.sender, msg.value, false);
    }

    /// @notice Sender redeems lTokens in exchange for the underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemTokens The number of lTokens to redeem into underlying
    function redeem(uint redeemTokens) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, redeemTokens, 0);
    }

    /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemAmount The amount of underlying to redeem
    function redeemUnderlying(uint redeemAmount) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, 0, redeemAmount);
    }

    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {
        accrueInterest();
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        borrowFresh(payable(borrower), msg.sender, borrowAmount);
    }

    /// @notice Sender repays a borrow belonging to borrower
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount The amount to repay
    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        repayBorrowFresh(msg.sender, borrower, repayAmount, false);
    }

    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        repayBorrowFresh(msg.sender, borrower, repayAmount, true);
    }


    /*** Safe Token ***/

    /// Gets balance of this contract in terms of the underlying
    /// @dev This excludes the value of the current message, if any
    /// @return The quantity of underlying tokens owned by this contract
    function getCashPrior() internal view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }


    /**
     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.
     *      This will revert due to insufficient balance or insufficient allowance.
     *      This function returns the actual amount received,
     *      which may be less than `amount` if there is a fee attached to the transfer.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {
        if (isWethPool && convertWeth) {
            actualAmount = msg.value;
            IWETH(underlying).deposit{value : actualAmount}();
        } else {
            actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);
        }
    }

    /**
     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory
     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to
     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified
     *      it is >= amount, this should not revert in normal conditions.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {
        if (isWethPool && convertWeth) {
            IWETH(underlying).withdraw(amount);
            to.transfer(amount);
        } else {
            IERC20(underlying).safeTransfer(to, amount);
        }
    }

    function availableForBorrow() external view override returns (uint){
        uint cash = getCashPrior();
        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);
        if (err0 != MathError.NO_ERROR) {
            return 0;
        }
        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);
        if (err1 != MathError.NO_ERROR) {
            return 0;
        }
        if (totalBorrows > maxAvailable) {
            return 0;
        }
        return maxAvailable - totalBorrows;
    }


    /// @notice Get a snapshot of the account's balances, and the cached exchange rate
    /// @dev This is used by controller to more efficiently perform liquidity checks.
    /// @param account Address of the account to snapshot
    /// @return ( token balance, borrow balance, exchange rate mantissa)
    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        return (cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /// @dev Function to simply retrieve block number
    ///  This exists mainly for inheriting test contracts to stub this result.
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /// @notice Returns the current per-block borrow interest rate for this cToken
    /// @return The borrow interest rate per block, scaled by 1e18
    function borrowRatePerBlock() external override view returns (uint) {
        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
    }

    
    /// @notice Returns the current per-block supply interest rate for this cToken
    /// @return The supply interest rate per block, scaled by 1e18
    function supplyRatePerBlock() external override view returns (uint) {
        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);
    }

    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {
        // Utilization rate is 0 when there are no borrows
        if (borrows == 0) {
            return 0;
        }
        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));
    }

    /// @notice Calculates the current borrow rate per block, with the error code expected by the market
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18)
    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {
        uint util = utilizationRate(cash, borrows, reserves);
        if (util <= kink) {
            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
        } else {
            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
            uint excessUtil = util.sub(kink);
            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);
        }
    }

    /// @notice Calculates the current supply rate per block
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The supply rate percentage per block as a mantissa (scaled by 1e18)
    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {
        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);
        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);
        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);
        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);
    }

    /// @notice Returns the current total borrows plus accrued interest
    /// @return The total borrows with interest
    function totalBorrowsCurrent() external override view returns (uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return totalBorrows;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        return totalBorrowsNew;
    }

    /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
    /// @param account The address whose balance should be calculated after updating borrowIndex
    /// @return The calculated balance
    function borrowBalanceCurrent(address account) external view override returns (uint) {
        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();
        require(err0 == MathError.NO_ERROR, "calc borrow index fail");
        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
        require(err1 == MathError.NO_ERROR, "calc fail");
        return result;
    }

    function borrowBalanceStored(address account) external override view returns (uint){
        return accountBorrows[account].principal;
    }


    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
    }

    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /// @notice Accrue interest then return the up-to-date exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateCurrent() public override nonReentrant returns (uint) {
        accrueInterest();
        return exchangeRateStored();
    }

    /// Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateStored() public override view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "calc fail");
        return result;
    }

    /// @notice Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return (error code, calculated exchange rate scaled by 1e18)
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        uint _totalSupply = totalSupply;
        if (_totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint _totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /// @notice Get cash balance of this cToken in the underlying asset
    /// @return The quantity of underlying asset owned by this contract
    function getCash() external override view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }

    function calCurrentBorrowIndex() internal view returns (MathError, uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;
        uint borrowIndexNew;
        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return (MathError.NO_ERROR, borrowIndex);
        }
        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);

        Exp memory simpleInterestFactor;
        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }
        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);
        return (mathErr, borrowIndexNew);
    }

    /// @notice Applies accrued interest to total borrows and reserves
    /// @dev This calculates interest accrued from the last checkpointed block
    ///   up to the current block and writes new checkpoint to storage.
    function accrueInterest() public override {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint borrowIndexPrior = borrowIndex;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");


        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;
        uint borrowIndexNew;
        uint totalReservesNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total reserves error');

        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);
        require(mathErr == MathError.NO_ERROR, 'calc borrows index error');


        /* We write the previously calculated values into storage */
        accrualBlockNumber = currentBlockNumber;
        borrowIndex = borrowIndexNew;
        totalBorrows = totalBorrowsNew;
        totalReserves = totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);

    }

    struct MintLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
        uint actualMintAmount;
    }

    /// @notice User supplies assets into the market and receives lTokens in exchange
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param minter The address of the account which is supplying the assets
    /// @param mintAmount The amount of the underlying asset to supply
    /// @return uint the actual mint amount.
    function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {
        MintLocalVars memory vars;
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /*
         *  We call `doTransferIn` for the minter and the mintAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if
         *  side-effects occurred. The function returns the amount actually transferred,
         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`
         *  of cash.
         */
        if (isDelegete) {
            uint balanceBefore = getCashPrior();
            LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);
            uint balanceAfter = getCashPrior();
            require(balanceAfter > balanceBefore, 'mint 0');
            vars.actualMintAmount = balanceAfter - balanceBefore;
        } else {
            vars.actualMintAmount = doTransferIn(minter, mintAmount, true);
        }
        /*
         * We get the current exchange rate and calculate the number of lTokens to be minted:
         *  mintTokens = actualMintAmount / exchangeRate
         */

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));
        require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");

        /* Fail if mint not allowed */
        (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);
        /*
         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */

        return vars.actualMintAmount;
    }


    struct RedeemLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /// @notice User redeems lTokens in exchange for the underlying asset
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param redeemer The address of the account which is redeeming the tokens
    /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');
            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');
        require(getCashPrior() >= vars.redeemAmount, 'cash < redeem');

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;
        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(redeemer, vars.redeemAmount, true);


        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
    }

    struct BorrowLocalVars {
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /// @notice Users borrow assets from the protocol to their own address
    /// @param borrowAmount The amount of the underlying asset to borrow
    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {
        /* Fail if borrow not allowed */
        (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);

        /* Fail gracefully if protocol has insufficient underlying cash */
        require(getCashPrior() >= borrowAmount, 'cash<borrow');

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(payee, borrowAmount, false);

        /* We emit a Borrow event */
        emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
    }

    struct RepayBorrowLocalVars {
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
        uint actualRepayAmount;
        uint badDebtsAmount;
    }

    /// @notice Borrows are repaid by another user (possibly the borrower).
    /// @param payer the account paying off the borrow
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount the amount of undelrying tokens being returned
    function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {
        /* Fail if repayBorrow not allowed */
        (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(- 1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }
        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);


        if (isEnd && vars.accountBorrows > vars.actualRepayAmount) {
            vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;
        }

        /*
        *  We calculate the new borrower and total borrow balances, failing on underflow:
        *  accountBorrowsNew = accountBorrows - repayAmount
        *  totalBorrowsNew = totalBorrows - repayAmount
        */
        if (vars.accountBorrows < vars.actualRepayAmount) {
            require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) <= 105e16, 'repay more than 5%');
            vars.accountBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.accountBorrowsNew = 0;
            } else {
                vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;
            }
        }
        //Avoid mantissa errors
        if (vars.actualRepayAmount > totalBorrows) {
            vars.totalBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);
            } else {
                vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;
            }
        }

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */

        return vars.actualRepayAmount;
    }

    /*** Admin Functions ***/

    /// @notice Sets a new CONTROLLER for the market
    /// @dev Admin function to set a new controller
    function setController(address newController) external override onlyAdmin {
        require(address(0) != newController, "0x");
        address oldController = controller;
        controller = newController;
        // Emit NewController(oldController, newController)
        emit NewController(oldController, newController);
    }

    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {
        require(newBorrowCapFactorMantissa <= 1e18, 'Factor too large');
        uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;
        borrowCapFactorMantissa = newBorrowCapFactorMantissa;
        emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa);
    }

    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {
        //accrueInterest except first
        if (baseRatePerBlock != 0) {
            accrueInterest();
        }
        // total rate perYear < 2000%
        require(baseRatePerBlock_ < 1e13, 'Base rate too large');
        baseRatePerBlock = baseRatePerBlock_;
        require(multiplierPerBlock_ < 1e13, 'Mul rate too large');
        multiplierPerBlock = multiplierPerBlock_;
        require(jumpMultiplierPerBlock_ < 1e13, 'Jump rate too large');
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        require(kink_ <= 1e18, 'Kline too large');
        kink = kink_;
        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);
    }

    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {
        require(newReserveFactorMantissa <= 1e18, 'Factor too large');
        accrueInterest();
        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;
        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);
    }

    function addReserves(uint addAmount) external override nonReentrant {
        accrueInterest();
        uint totalReservesNew;
        uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);
        totalReservesNew = totalReserves.add(actualAddAmount);
        totalReserves = totalReservesNew;
        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);
    }

    function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {
        accrueInterest();
        uint totalReservesNew;
        totalReservesNew = totalReserves.sub(reduceAmount);
        totalReserves = totalReservesNew;
        doTransferOut(to, reduceAmount, true);
        emit ReservesReduced(to, reduceAmount, totalReservesNew);
    }

    modifier sameBlock() {
        require(accrualBlockNumber == getBlockNumber(), 'not same block');
        _;
    }
}

.]

Based on the provided Solidity smart contract code for the `LPool` contract, here is a summary of the identified security vulnerabilities and issues:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - While the contract uses `ReentrancyGuard`, there are multiple functions that could potentially be vulnerable to reentrancy attacks if the guard is not properly implemented or if the guard is bypassed in future modifications.

2. **Access Control Issues**:
   - The `initialize` function has a check for `msg.sender == admin`, but there is no mechanism to ensure that the `admin` variable is set securely. If the admin address is compromised, it could lead to unauthorized access.
   - Functions that modify critical parameters (like `setController`, `setInterestParams`, etc.) are only protected by the `onlyAdmin` modifier, which could be problematic if the admin is compromised.

3. **Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath`, there are instances where arithmetic operations could still lead to unexpected results if not properly handled. For example, the checks for underflow/overflow are not consistently applied across all arithmetic operations.

4. **Gas Limit and Loops**:
   - The contract does not appear to have any explicit loops that could lead to gas limit issues, but functions that involve multiple state changes (like `accrueInterest`) could potentially run into gas limit problems if the state grows too large.

5. **Lack of Input Validation**:
   - Functions like `setInterestParams` and `setReserveFactor` do not validate the input parameters thoroughly. For example, the maximum limits for interest rates and reserve factors should be checked against realistic values to prevent extreme configurations.

6. **Potential for Front-Running**:
   - The contract does not implement any mechanisms to prevent front-running, especially in functions that involve financial transactions like `mint`, `redeem`, and `borrow`. This could allow malicious actors to exploit the timing of transactions.

7. **Event Emission**:
   - While events are emitted for significant state changes, there are some functions where events are not emitted for all critical actions, which could hinder tracking and auditing of contract activity.

8. **Fallback Function**:
   - The contract does not implement a fallback function to handle unexpected Ether transfers, which could lead to loss of funds if someone sends Ether directly to the contract address.

### Comprehensive Analysis Report:

The `LPool` contract is a complex financial instrument that facilitates lending and borrowing of assets. While it incorporates several best practices, such as using `SafeMath` and `ReentrancyGuard`, there are notable vulnerabilities that could be exploited if not addressed.

1. **Reentrancy**: The use of `ReentrancyGuard` is a positive step, but developers must ensure that all functions that interact with external contracts are adequately protected. Continuous testing and audits are essential to maintain security.

2. **Access Control**: The reliance on a single admin address for critical functions poses a significant risk. Implementing a multi-signature wallet or a decentralized governance model could mitigate this risk.

3. **Arithmetic Safety**: Although `SafeMath` is used, developers should ensure that all arithmetic operations are consistently checked for overflow/underflow to prevent unexpected behavior.

4. **Input Validation**: Comprehensive validation of input parameters is crucial to prevent misconfigurations that could lead to financial losses or contract failures.

5. **Front-Running**: Implementing measures to mitigate front-running, such as commit-reveal schemes or time-locks, could enhance the contract's resilience against such attacks.

6. **Event Logging**: Ensuring that all critical actions are logged through events will improve transparency and facilitate easier audits.

7. **Ether Handling**: The absence of a fallback function could lead to loss of funds. Implementing a fallback function to handle unexpected Ether transfers is advisable.

In conclusion, while the `LPool` contract has a solid foundation, addressing the identified vulnerabilities is essential for ensuring the security and reliability of the contract in a production environment. Regular audits, thorough testing, and adherence to best practices in smart contract development will be critical in maintaining the integrity of the contract.

[2024-24-08 19:28:52 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code for the `LPool` contract, here is a summary of the identified security vulnerabilities and issues:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - While the contract uses `ReentrancyGuard`, there are multiple functions that could potentially be vulnerable to reentrancy attacks if the guard is not properly implemented or if the guard is bypassed in future modifications.

2. **Access Control Issues**:
   - The `initialize` function has a check for `msg.sender == admin`, but there is no mechanism to ensure that the `admin` variable is set securely. If the admin address is compromised, it could lead to unauthorized access.
   - Functions that modify critical parameters (like `setController`, `setInterestParams`, etc.) are only protected by the `onlyAdmin` modifier, which could be problematic if the admin is compromised.

3. **Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath`, there are instances where arithmetic operations could still lead to unexpected results if not properly handled. For example, the checks for underflow/overflow are not consistently applied across all arithmetic operations.

4. **Gas Limit and Loops**:
   - The contract does not appear to have any explicit loops that could lead to gas limit issues, but functions that involve multiple state changes (like `accrueInterest`) could potentially run into gas limit problems if the state grows too large.

5. **Lack of Input Validation**:
   - Functions like `setInterestParams` and `setReserveFactor` do not validate the input parameters thoroughly. For example, the maximum limits for interest rates and reserve factors should be checked against realistic values to prevent extreme configurations.

6. **Potential for Front-Running**:
   - The contract does not implement any mechanisms to prevent front-running, especially in functions that involve financial transactions like `mint`, `redeem`, and `borrow`. This could allow malicious actors to exploit the timing of transactions.

7. **Event Emission**:
   - While events are emitted for significant state changes, there are some functions where events are not emitted for all critical actions, which could hinder tracking and auditing of contract activity.

8. **Fallback Function**:
   - The contract does not implement a fallback function to handle unexpected Ether transfers, which could lead to loss of funds if someone sends Ether directly to the contract address.

### Comprehensive Analysis Report:

The `LPool` contract is a complex financial instrument that facilitates lending and borrowing of assets. While it incorporates several best practices, such as using `SafeMath` and `ReentrancyGuard`, there are notable vulnerabilities that could be exploited if not addressed.

1. **Reentrancy**: The use of `ReentrancyGuard` is a positive step, but developers must ensure that all functions that interact with external contracts are adequately protected. Continuous testing and audits are essential to maintain security.

2. **Access Control**: The reliance on a single admin address for critical functions poses a significant risk. Implementing a multi-signature wallet or a decentralized governance model could mitigate this risk.

3. **Arithmetic Safety**: Although `SafeMath` is used, developers should ensure that all arithmetic operations are consistently checked for overflow/underflow to prevent unexpected behavior.

4. **Input Validation**: Comprehensive validation of input parameters is crucial to prevent misconfigurations that could lead to financial losses or contract failures.

5. **Front-Running**: Implementing measures to mitigate front-running, such as commit-reveal schemes or time-locks, could enhance the contract's resilience against such attacks.

6. **Event Logging**: Ensuring that all critical actions are logged through events will improve transparency and facilitate easier audits.

7. **Ether Handling**: The absence of a fallback function could lead to loss of funds. Implementing a fallback function to handle unexpected Ether transfers is advisable.

In conclusion, while the `LPool` contract has a solid foundation, addressing the identified vulnerabilities is essential for ensuring the security and reliability of the contract in a production environment. Regular audits, thorough testing, and adherence to best practices in smart contract development will be critical in maintaining the integrity of the contract.

[2024-24-08 19:28:56 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.7.6; import "./LPoolInterface.sol"; import "./LPoolDepositor.sol"; import "../lib/Exponential.sol"; import "../Adminable.sol"; import "../lib/CarefulMath.sol"; import "../lib/TransferHelper.sol"; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import "../DelegateInterface.sol"; import "../ControllerInterface.sol"; import "../IWETH.sol"; /// @title OpenLeverage's LToken Contract /// @dev Abstract base for LTokens /// @author OpenLeverage contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {     using TransferHelper for IERC20;     using SafeMath for uint; constructor() {  }  /// @notice Initialize the money market /// @param controller_ The address of the Controller /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0 /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point /// @param kink_ The utilization point at which the jump multiplier is applied /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18 /// @param name_ EIP-20 name of this token /// @param symbol_ EIP-20 symbol of this token /// @param decimals_ EIP-20 decimal precision of this token function initialize(     address underlying_,     bool isWethPool_,     address controller_,     uint256 baseRatePerBlock_,     uint256 multiplierPerBlock_,     uint256 jumpMultiplierPerBlock_,     uint256 kink_,     uint initialExchangeRateMantissa_,     string memory name_,     string memory symbol_,     uint8 decimals_) public {     require(underlying_ != address(0), "underlying_ address cannot be 0");     require(controller_ != address(0), "controller_ address cannot be 0");     require(msg.sender == admin, "Only allow to be called by admin");     require(accrualBlockNumber == 0 &amp;&amp; borrowIndex == 0, "inited once");      // Set initial exchange rate     initialExchangeRateMantissa = initialExchangeRateMantissa_;     require(initialExchangeRateMantissa &gt; 0, "Initial Exchange Rate Mantissa should be greater zero");     //set controller     controller = controller_;     isWethPool = isWethPool_;     //set interestRateModel     baseRatePerBlock = baseRatePerBlock_;     multiplierPerBlock = multiplierPerBlock_;     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     kink = kink_;      // Initialize block number and borrow index (block number mocks depend on controller being set)     accrualBlockNumber = getBlockNumber();     borrowIndex = 1e25;     //80%     borrowCapFactorMantissa = 0.8e18;     //10%     reserveFactorMantissa = 0.1e18;       name = name_;     symbol = symbol_;     decimals = decimals_;      _notEntered = true;      // Set underlying and sanity check it     underlying = underlying_;     IERC20(underlying).totalSupply();     emit Transfer(address(0), msg.sender, 0); }  /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender` /// @dev Called by both `transfer` and `transferFrom` internally /// @param spender The address of the account performing the transfer /// @param src The address of the source account /// @param dst The address of the destination account /// @param tokens The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {     require(dst != address(0), "dst address cannot be 0");     /* Do not allow self-transfers */     require(src != dst, "src = dst");     /* Fail if transfer not allowed */     (ControllerInterface(controller)).transferAllowed(src, dst, tokens);      /* Get the allowance, infinite for the account owner */     uint startingAllowance = 0;     if (spender == src) {         startingAllowance = uint(- 1);     } else {         startingAllowance = transferAllowances[src][spender];     }      /* Do the calculations, checking for {under,over}flow */     MathError mathErr;     uint allowanceNew;     uint srcTokensNew;     uint dstTokensNew;      (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);     require(mathErr == MathError.NO_ERROR, 'not allowed');      (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);     require(mathErr == MathError.NO_ERROR, 'not enough');      (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);     require(mathErr == MathError.NO_ERROR, 'too much');      accountTokens[src] = srcTokensNew;     accountTokens[dst] = dstTokensNew;      /* Eat some of the allowance (if necessary) */     if (startingAllowance != uint(- 1)) {         transferAllowances[src][spender] = allowanceNew;     }     /* We emit a Transfer event */     emit Transfer(src, dst, tokens);     return true; }  /// @notice Transfer `amount` tokens from `msg.sender` to `dst` /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, msg.sender, dst, amount); }  /// @notice Transfer `amount` tokens from `src` to `dst` /// @param src The address of the source account /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, src, dst, amount); }  /// @notice Approve `spender` to transfer up to `amount` from `src` /// @dev This will overwrite the approval amount for `spender` ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve) /// @param spender The address of the account which may transfer tokens /// @param amount The number of tokens that are approved (-1 means infinite) /// @return Whether or not the approval succeeded function approve(address spender, uint256 amount) external override returns (bool) {     address src = msg.sender;     transferAllowances[src][spender] = amount;     emit Approval(src, spender, amount);     return true; }  /// @notice Get the current allowance from `owner` for `spender` /// @param owner The address of the account which owns the tokens to be spent /// @param spender The address of the account which may transfer tokens /// @return The number of tokens allowed to be spent (-1 means infinite) function allowance(address owner, address spender) external override view returns (uint256) {     return transferAllowances[owner][spender]; }  /// @notice Get the token balance of the `owner` /// @param owner The address of the account to query /// @return The number of tokens owned by `owner` function balanceOf(address owner) external override view returns (uint256) {     return accountTokens[owner]; }  /// @notice Get the underlying balance of the `owner` /// @dev This also accrues interest in a transaction /// @param owner The address of the account to query /// @return The amount of underlying owned by `owner` function balanceOfUnderlying(address owner) external override returns (uint) {     Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});     (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);     require(mErr == MathError.NO_ERROR, "calc failed");     return balance; }  /*** User Interface ***/  /// @notice Sender supplies assets into the market and receives lTokens in exchange /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param mintAmount The amount of the underlying asset to supply function mint(uint mintAmount) external override nonReentrant {     accrueInterest();     mintFresh(msg.sender, mintAmount, false); }  function mintTo(address to, uint amount) external payable override nonReentrant {     accrueInterest();     if (isWethPool) {         mintFresh(to, msg.value, false);     } else {         mintFresh(to, amount, true);     } }  function mintEth() external payable override nonReentrant {     require(isWethPool, "not eth pool");     accrueInterest();     mintFresh(msg.sender, msg.value, false); }  /// @notice Sender redeems lTokens in exchange for the underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemTokens The number of lTokens to redeem into underlying function redeem(uint redeemTokens) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, redeemTokens, 0); }  /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemAmount The amount of underlying to redeem function redeemUnderlying(uint redeemAmount) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, 0, redeemAmount); }  function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {     accrueInterest();     // borrowFresh emits borrow-specific logs on errors, so we don't need to     borrowFresh(payable(borrower), msg.sender, borrowAmount); }  /// @notice Sender repays a borrow belonging to borrower /// @param borrower the account with the debt being payed off /// @param repayAmount The amount to repay function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     repayBorrowFresh(msg.sender, borrower, repayAmount, false); }  function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     repayBorrowFresh(msg.sender, borrower, repayAmount, true); }   /*** Safe Token ***/  /// Gets balance of this contract in terms of the underlying /// @dev This excludes the value of the current message, if any /// @return The quantity of underlying tokens owned by this contract function getCashPrior() internal view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }   /**  * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.  *      This will revert due to insufficient balance or insufficient allowance.  *      This function returns the actual amount received,  *      which may be less than `amount` if there is a fee attached to the transfer.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {     if (isWethPool &amp;&amp; convertWeth) {         actualAmount = msg.value;         IWETH(underlying).deposit{value : actualAmount}();     } else {         actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);     } }  /**  * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory  *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to  *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified  *      it is &gt;= amount, this should not revert in normal conditions.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferOut(address payable to, uint amount, bool convertWeth) internal {     if (isWethPool &amp;&amp; convertWeth) {         IWETH(underlying).withdraw(amount);         to.transfer(amount);     } else {         IERC20(underlying).safeTransfer(to, amount);     } }  function availableForBorrow() external view override returns (uint){     uint cash = getCashPrior();     (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);     if (err0 != MathError.NO_ERROR) {         return 0;     }     (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);     if (err1 != MathError.NO_ERROR) {         return 0;     }     if (totalBorrows &gt; maxAvailable) {         return 0;     }     return maxAvailable - totalBorrows; }   /// @notice Get a snapshot of the account's balances, and the cached exchange rate /// @dev This is used by controller to more efficiently perform liquidity checks. /// @param account Address of the account to snapshot /// @return ( token balance, borrow balance, exchange rate mantissa) function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {     uint cTokenBalance = accountTokens[account];     uint borrowBalance;     uint exchangeRateMantissa;      MathError mErr;      (mErr, borrowBalance) = borrowBalanceStoredInternal(account);     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      return (cTokenBalance, borrowBalance, exchangeRateMantissa); }  /// @dev Function to simply retrieve block number ///  This exists mainly for inheriting test contracts to stub this result. function getBlockNumber() internal view returns (uint) {     return block.number; }  /// @notice Returns the current per-block borrow interest rate for this cToken /// @return The borrow interest rate per block, scaled by 1e18 function borrowRatePerBlock() external override view returns (uint) {     return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves); }   /// @notice Returns the current per-block supply interest rate for this cToken /// @return The supply interest rate per block, scaled by 1e18 function supplyRatePerBlock() external override view returns (uint) {     return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa); }  function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {     // Utilization rate is 0 when there are no borrows     if (borrows == 0) {         return 0;     }     return borrows.mul(1e18).div(cash.add(borrows).sub(reserves)); }  /// @notice Calculates the current borrow rate per block, with the error code expected by the market /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18) function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {     uint util = utilizationRate(cash, borrows, reserves);     if (util &lt;= kink) {         return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);     } else {         uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);         uint excessUtil = util.sub(kink);         return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);     } }  /// @notice Calculates the current supply rate per block /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The supply rate percentage per block as a mantissa (scaled by 1e18) function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {     uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);     uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);     uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);     return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18); }  /// @notice Returns the current total borrows plus accrued interest /// @return The total borrows with interest function totalBorrowsCurrent() external override view returns (uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return totalBorrows;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, "calc block delta erro");      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      return totalBorrowsNew; }  /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex /// @param account The address whose balance should be calculated after updating borrowIndex /// @return The calculated balance function borrowBalanceCurrent(address account) external view override returns (uint) {     (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();     require(err0 == MathError.NO_ERROR, "calc borrow index fail");     (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);     require(err1 == MathError.NO_ERROR, "calc fail");     return result; }  function borrowBalanceStored(address account) external override view returns (uint){     return accountBorrows[account].principal; }   /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {     return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex); }  /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {     /* Note: we do not assert that the market is up to date */     MathError mathErr;     uint principalTimesIndex;     uint result;      /* Get borrowBalance and borrowIndex */     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];      /* If borrowBalance = 0 then borrowIndex is likely also 0.      * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.      */     if (borrowSnapshot.principal == 0) {         return (MathError.NO_ERROR, 0);     }      /* Calculate new borrow balance using the interest index:      *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex      */     (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      return (MathError.NO_ERROR, result); }  /// @notice Accrue interest then return the up-to-date exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateCurrent() public override nonReentrant returns (uint) {     accrueInterest();     return exchangeRateStored(); }  /// Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateStored() public override view returns (uint) {     (MathError err, uint result) = exchangeRateStoredInternal();     require(err == MathError.NO_ERROR, "calc fail");     return result; }  /// @notice Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return (error code, calculated exchange rate scaled by 1e18) function exchangeRateStoredInternal() internal view returns (MathError, uint) {     uint _totalSupply = totalSupply;     if (_totalSupply == 0) {         /*          * If there are no tokens minted:          *  exchangeRate = initialExchangeRate          */         return (MathError.NO_ERROR, initialExchangeRateMantissa);     } else {         /*          * Otherwise:          *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply          */         uint _totalCash = getCashPrior();         uint cashPlusBorrowsMinusReserves;         Exp memory exchangeRate;         MathError mathErr;          (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          return (MathError.NO_ERROR, exchangeRate.mantissa);     } }  /// @notice Get cash balance of this cToken in the underlying asset /// @return The quantity of underlying asset owned by this contract function getCash() external override view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }  function calCurrentBorrowIndex() internal view returns (MathError, uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;     uint borrowIndexNew;     /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return (MathError.NO_ERROR, borrowIndex);     }     uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);      Exp memory simpleInterestFactor;     (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }     (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);     return (mathErr, borrowIndexNew); }  /// @notice Applies accrued interest to total borrows and reserves /// @dev This calculates interest accrued from the last checkpointed block ///   up to the current block and writes new checkpoint to storage. function accrueInterest() public override {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint borrowIndexPrior = borrowIndex;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, "calc block delta erro");       /*      * Calculate the interest accumulated into borrows and reserves and the new index:      *  simpleInterestFactor = borrowRate * blockDelta      *  interestAccumulated = simpleInterestFactor * totalBorrows      *  totalBorrowsNew = interestAccumulated + totalBorrows      *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex      */      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;     uint borrowIndexNew;     uint totalReservesNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);     require(mathErr == MathError.NO_ERROR, 'calc total reserves error');      (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);     require(mathErr == MathError.NO_ERROR, 'calc borrows index error');       /* We write the previously calculated values into storage */     accrualBlockNumber = currentBlockNumber;     borrowIndex = borrowIndexNew;     totalBorrows = totalBorrowsNew;     totalReserves = totalReservesNew;      /* We emit an AccrueInterest event */     emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);  }  struct MintLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint mintTokens;     uint totalSupplyNew;     uint accountTokensNew;     uint actualMintAmount; }  /// @notice User supplies assets into the market and receives lTokens in exchange /// @dev Assumes interest has already been accrued up to the current block /// @param minter The address of the account which is supplying the assets /// @param mintAmount The amount of the underlying asset to supply /// @return uint the actual mint amount. function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {     MintLocalVars memory vars;     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /*      *  We call `doTransferIn` for the minter and the mintAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if      *  side-effects occurred. The function returns the amount actually transferred,      *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`      *  of cash.      */     if (isDelegete) {         uint balanceBefore = getCashPrior();         LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);         uint balanceAfter = getCashPrior();         require(balanceAfter &gt; balanceBefore, 'mint 0');         vars.actualMintAmount = balanceAfter - balanceBefore;     } else {         vars.actualMintAmount = doTransferIn(minter, mintAmount, true);     }     /*      * We get the current exchange rate and calculate the number of lTokens to be minted:      *  mintTokens = actualMintAmount / exchangeRate      */      (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));     require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");      /* Fail if mint not allowed */     (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);     /*      * We calculate the new total supply of lTokens and minter token balance, checking for overflow:      *  totalSupplyNew = totalSupply + mintTokens      *  accountTokensNew = accountTokens[minter] + mintTokens      */     (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");      (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[minter] = vars.accountTokensNew;      /* We emit a Mint event, and a Transfer event */     emit Mint(minter, vars.actualMintAmount, vars.mintTokens);     emit Transfer(address(this), minter, vars.mintTokens);      /* We call the defense hook */      return vars.actualMintAmount; }   struct RedeemLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint redeemTokens;     uint redeemAmount;     uint totalSupplyNew;     uint accountTokensNew; }  /// @notice User redeems lTokens in exchange for the underlying asset /// @dev Assumes interest has already been accrued up to the current block /// @param redeemer The address of the account which is redeeming the tokens /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero) /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero) function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {     require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");      RedeemLocalVars memory vars;      /* exchangeRate = invoke Exchange Rate Stored() */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /* If redeemTokensIn &gt; 0: */     if (redeemTokensIn &gt; 0) {         /*          * We calculate the exchange rate and the amount of underlying to be redeemed:          *  redeemTokens = redeemTokensIn          *  redeemAmount = redeemTokensIn x exchangeRateCurrent          */         vars.redeemTokens = redeemTokensIn;          (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');     } else {         /*          * We get the current exchange rate and calculate the amount to be redeemed:          *  redeemTokens = redeemAmountIn / exchangeRate          *  redeemAmount = redeemAmountIn          */          (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');         vars.redeemAmount = redeemAmountIn;     }      /* Fail if redeem not allowed */     (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);      /*      * We calculate the new total supply and redeemer balance, checking for underflow:      *  totalSupplyNew = totalSupply - redeemTokens      *  accountTokensNew = accountTokens[redeemer] - redeemTokens      */     (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');      (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');     require(getCashPrior() &gt;= vars.redeemAmount, 'cash &lt; redeem');      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[redeemer] = vars.accountTokensNew;     /*      * We invoke doTransferOut for the redeemer and the redeemAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken has redeemAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(redeemer, vars.redeemAmount, true);       /* We emit a Transfer event, and a Redeem event */     emit Transfer(redeemer, address(this), vars.redeemTokens);     emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);      /* We call the defense hook */ }  struct BorrowLocalVars {     MathError mathErr;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /// @notice Users borrow assets from the protocol to their own address /// @param borrowAmount The amount of the underlying asset to borrow function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {     /* Fail if borrow not allowed */     (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);      /* Fail gracefully if protocol has insufficient underlying cash */     require(getCashPrior() &gt;= borrowAmount, 'cash&lt;borrow');      BorrowLocalVars memory vars;      /*      * We calculate the new borrower and total borrow balances, failing on overflow:      *  accountBorrowsNew = accountBorrows + borrowAmount      *  totalBorrowsNew = totalBorrows + borrowAmount      */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /*      * We invoke doTransferOut for the borrower and the borrowAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken borrowAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(payee, borrowAmount, false);      /* We emit a Borrow event */     emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */ }  struct RepayBorrowLocalVars {     MathError mathErr;     uint repayAmount;     uint borrowerIndex;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew;     uint actualRepayAmount;     uint badDebtsAmount; }  /// @notice Borrows are repaid by another user (possibly the borrower). /// @param payer the account paying off the borrow /// @param borrower the account with the debt being payed off /// @param repayAmount the amount of undelrying tokens being returned function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {     /* Fail if repayBorrow not allowed */     (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);      RepayBorrowLocalVars memory vars;      /* We remember the original borrowerIndex for verification purposes */     vars.borrowerIndex = accountBorrows[borrower].interestIndex;      /* We fetch the amount the borrower owes, with accumulated interest */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');      /* If repayAmount == -1, repayAmount = accountBorrows */     if (repayAmount == uint(- 1)) {         vars.repayAmount = vars.accountBorrows;     } else {         vars.repayAmount = repayAmount;     }     vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);       if (isEnd &amp;&amp; vars.accountBorrows &gt; vars.actualRepayAmount) {         vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;     }      /*     *  We calculate the new borrower and total borrow balances, failing on underflow:     *  accountBorrowsNew = accountBorrows - repayAmount     *  totalBorrowsNew = totalBorrows - repayAmount     */     if (vars.accountBorrows &lt; vars.actualRepayAmount) {         require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) &lt;= 105e16, 'repay more than 5%');         vars.accountBorrowsNew = 0;     } else {         if (isEnd) {             vars.accountBorrowsNew = 0;         } else {             vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;         }     }     //Avoid mantissa errors     if (vars.actualRepayAmount &gt; totalBorrows) {         vars.totalBorrowsNew = 0;     } else {         if (isEnd) {             vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);         } else {             vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;         }     }      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a RepayBorrow event */     emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */      return vars.actualRepayAmount; }  /*** Admin Functions ***/  /// @notice Sets a new CONTROLLER for the market /// @dev Admin function to set a new controller function setController(address newController) external override onlyAdmin {     require(address(0) != newController, "0x");     address oldController = controller;     controller = newController;     // Emit NewController(oldController, newController)     emit NewController(oldController, newController); }  function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {     require(newBorrowCapFactorMantissa &lt;= 1e18, 'Factor too large');     uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;     borrowCapFactorMantissa = newBorrowCapFactorMantissa;     emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa); }  function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {     //accrueInterest except first     if (baseRatePerBlock != 0) {         accrueInterest();     }     // total rate perYear &lt; 2000%     require(baseRatePerBlock_ &lt; 1e13, 'Base rate too large');     baseRatePerBlock = baseRatePerBlock_;     require(multiplierPerBlock_ &lt; 1e13, 'Mul rate too large');     multiplierPerBlock = multiplierPerBlock_;     require(jumpMultiplierPerBlock_ &lt; 1e13, 'Jump rate too large');     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     require(kink_ &lt;= 1e18, 'Kline too large');     kink = kink_;     emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_); }  function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {     require(newReserveFactorMantissa &lt;= 1e18, 'Factor too large');     accrueInterest();     uint oldReserveFactorMantissa = reserveFactorMantissa;     reserveFactorMantissa = newReserveFactorMantissa;     emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa); }  function addReserves(uint addAmount) external override nonReentrant {     accrueInterest();     uint totalReservesNew;     uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);     totalReservesNew = totalReserves.add(actualAddAmount);     totalReserves = totalReservesNew;     emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew); }  function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {     accrueInterest();     uint totalReservesNew;     totalReservesNew = totalReserves.sub(reduceAmount);     totalReserves = totalReservesNew;     doTransferOut(to, reduceAmount, true);     emit ReservesReduced(to, reduceAmount, totalReservesNew); }  modifier sameBlock() {     require(accrualBlockNumber == getBlockNumber(), 'not same block');     _; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.7.6;\n\n\nimport "./LPoolInterface.sol";\nimport "./LPoolDepositor.sol";\nimport "../lib/Exponential.sol";\nimport "../Adminable.sol";\nimport "../lib/CarefulMath.sol";\nimport "../lib/TransferHelper.sol";\nimport "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\n\nimport "../DelegateInterface.sol";\nimport "../ControllerInterface.sol";\nimport "../IWETH.sol";\n\n/// @title OpenLeverage\'s LToken Contract\n/// @dev Abstract base for LTokens\n/// @author OpenLeverage\ncontract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {\n    using TransferHelper for IERC20;\n    using SafeMath for uint;\n\n    constructor() {\n\n    }\n    \n    /// @notice Initialize the money market\n    /// @param controller_ The address of the Controller\n    /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0\n    /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate\n    /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point\n    /// @param kink_ The utilization point at which the jump multiplier is applied\n    /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n    /// @param name_ EIP-20 name of this token\n    /// @param symbol_ EIP-20 symbol of this token\n    /// @param decimals_ EIP-20 decimal precision of this token\n    function initialize(\n        address underlying_,\n        bool isWethPool_,\n        address controller_,\n        uint256 baseRatePerBlock_,\n        uint256 multiplierPerBlock_,\n        uint256 jumpMultiplierPerBlock_,\n        uint256 kink_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_) public {\n        require(underlying_ != address(0), "underlying_ address cannot be 0");\n        require(controller_ != address(0), "controller_ address cannot be 0");\n        require(msg.sender == admin, "Only allow to be called by admin");\n        require(accrualBlockNumber == 0 &amp;&amp; borrowIndex == 0, "inited once");\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa &gt; 0, "Initial Exchange Rate Mantissa should be greater zero");\n        //set controller\n        controller = controller_;\n        isWethPool = isWethPool_;\n        //set interestRateModel\n        baseRatePerBlock = baseRatePerBlock_;\n        multiplierPerBlock = multiplierPerBlock_;\n        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;\n        kink = kink_;\n\n        // Initialize block number and borrow index (block number mocks depend on controller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = 1e25;\n        //80%\n        borrowCapFactorMantissa = 0.8e18;\n        //10%\n        reserveFactorMantissa = 0.1e18;\n\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n\n        notEntered = true;\n\n        // Set underlying and sanity check it\n        underlying = underlying;\n        IERC20(underlying).totalSupply();\n        emit Transfer(address(0), msg.sender, 0);\n    }\n\n    /// @notice Transfer tokens tokens from src to dst by spender\n    /// @dev Called by both transfer and transferFrom internally\n    /// @param spender The address of the account performing the transfer\n    /// @param src The address of the source account\n    /// @param dst The address of the destination account\n    /// @param tokens The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {\n        require(dst != address(0), "dst address cannot be 0");\n        / Do not allow self-transfers /\n        require(src != dst, "src = dst");\n        / Fail if transfer not allowed /\n        (ControllerInterface(controller)).transferAllowed(src, dst, tokens);\n\n        / Get the allowance, infinite for the account owner /\n        uint startingAllowance = 0;\n        if (spender == src) {\n            startingAllowance = uint(- 1);\n        } else {\n            startingAllowance = transferAllowances[src][spender];\n        }\n\n        / Do the calculations, checking for {under,over}flow /\n        MathError mathErr;\n        uint allowanceNew;\n        uint srcTokensNew;\n        uint dstTokensNew;\n\n        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n        require(mathErr == MathError.NO_ERROR, \'not allowed\');\n\n        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n        require(mathErr == MathError.NO_ERROR, \'not enough\');\n\n        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n        require(mathErr == MathError.NO_ERROR, \'too much\');\n\n        accountTokens[src] = srcTokensNew;\n        accountTokens[dst] = dstTokensNew;\n\n        / Eat some of the allowance (if necessary) /\n        if (startingAllowance != uint(- 1)) {\n            transferAllowances[src][spender] = allowanceNew;\n        }\n        / We emit a Transfer event /\n        emit Transfer(src, dst, tokens);\n        return true;\n    }\n\n    /// @notice Transfer amount tokens from msg.sender to dst\n    /// @param dst The address of the destination account\n    /// @param amount The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, msg.sender, dst, amount);\n    }\n\n    /// @notice Transfer amount tokens from src to dst\n    /// @param src The address of the source account\n    /// @param dst The address of the destination account\n    /// @param amount The number of tokens to transfer\n    /// @return Whether or not the transfer succeeded\n    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {\n        return transferTokens(msg.sender, src, dst, amount);\n    }\n\n    /// @notice Approve spender to transfer up to amount from src\n    /// @dev This will overwrite the approval amount for spender\n    ///  and is subject to issues noted here\n    /// @param spender The address of the account which may transfer tokens\n    /// @param amount The number of tokens that are approved (-1 means infinite)\n    /// @return Whether or not the approval succeeded\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        address src = msg.sender;\n        transferAllowances[src][spender] = amount;\n        emit Approval(src, spender, amount);\n        return true;\n    }\n\n    /// @notice Get the current allowance from owner for spender\n    /// @param owner The address of the account which owns the tokens to be spent\n    /// @param spender The address of the account which may transfer tokens\n    /// @return The number of tokens allowed to be spent (-1 means infinite)\n    function allowance(address owner, address spender) external override view returns (uint256) {\n        return transferAllowances[owner][spender];\n    }\n\n    /// @notice Get the token balance of the owner\n    /// @param owner The address of the account to query\n    /// @return The number of tokens owned by owner\n    function balanceOf(address owner) external override view returns (uint256) {\n        return accountTokens[owner];\n    }\n\n    /// @notice Get the underlying balance of the owner\n    /// @dev This also accrues interest in a transaction\n    /// @param owner The address of the account to query\n    /// @return The amount of underlying owned by owner\n    function balanceOfUnderlying(address owner) external override returns (uint) {\n        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});\n        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n        require(mErr == MathError.NO_ERROR, "calc failed");\n        return balance;\n    }\n\n    / User Interface /\n\n    /// @notice Sender supplies assets into the market and receives lTokens in exchange\n    /// @dev Accrues interest whether or not the operation succeeds, unless reverted\n    /// @param mintAmount The amount of the underlying asset to supply\n    function mint(uint mintAmount) external override nonReentrant {\n        accrueInterest();\n        mintFresh(msg.sender, mintAmount, false);\n    }\n\n    function mintTo(address to, uint amount) external payable override nonReentrant {\n        accrueInterest();\n        if (isWethPool) {\n            mintFresh(to, msg.value, false);\n        } else {\n            mintFresh(to, amount, true);\n        }\n    }\n\n    function mintEth() external payable override nonReentrant {\n        require(isWethPool, "not eth pool");\n        accrueInterest();\n        mintFresh(msg.sender, msg.value, false);\n    }\n\n    /// @notice Sender redeems lTokens in exchange for the underlying asset\n    /// @dev Accrues interest whether or not the operation succeeds, unless reverted\n    /// @param redeemTokens The number of lTokens to redeem into underlying\n    function redeem(uint redeemTokens) external override nonReentrant {\n        accrueInterest();\n        // redeemFresh emits redeem-specific logs on errors, so we don\'t need to\n        redeemFresh(msg.sender, redeemTokens, 0);\n    }\n\n    /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset\n    /// @dev Accrues interest whether or not the operation succeeds, unless reverted\n    /// @param redeemAmount The amount of underlying to redeem\n    function redeemUnderlying(uint redeemAmount) external override nonReentrant {\n        accrueInterest();\n        // redeemFresh emits redeem-specific logs on errors, so we don\'t need to\n        redeemFresh(msg.sender, 0, redeemAmount);\n    }\n\n    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {\n        accrueInterest();\n        // borrowFresh emits borrow-specific logs on errors, so we don\'t need to\n        borrowFresh(payable(borrower), msg.sender, borrowAmount);\n    }\n\n    /// @notice Sender repays a borrow belonging to borrower\n    /// @param borrower the account with the debt being payed off\n    /// @param repayAmount The amount to repay\n    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {\n        accrueInterest();\n        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don\'t need to\n        repayBorrowFresh(msg.sender, borrower, repayAmount, false);\n    }\n\n    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {\n        accrueInterest();\n        repayBorrowFresh(msg.sender, borrower, repayAmount, true);\n    }\n\n\n    / Safe Token /\n\n    /// Gets balance of this contract in terms of the underlying\n    /// @dev This excludes the value of the current message, if any\n    /// @return The quantity of underlying tokens owned by this contract\n    function getCashPrior() internal view returns (uint) {\n        return IERC20(underlying).balanceOf(address(this));\n    }\n\n\n    /\n     * @dev Similar to EIP20 transfer, except it handles a False result from transferFrom and reverts in that case.\n     *      This will revert due to insufficient balance or insufficient allowance.\n     *      This function returns the actual amount received,\n     *      which may be less than amount if there is a fee attached to the transfer.\n     \n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     /\n    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {\n        if (isWethPool &amp;&amp; convertWeth) {\n            actualAmount = msg.value;\n            IWETH(underlying).deposit{value : actualAmount}();\n        } else {\n            actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);\n        }\n    }\n\n    /\n     * @dev Similar to EIP20 transfer, except it handles a False success from transfer and returns an explanatory\n     *      error code rather than reverting. If caller has not called checked protocol\'s balance, this may revert due to\n     *      insufficient cash held in this contract. If caller has checked protocol\'s balance prior to this call, and verified\n     *      it is &gt;= amount, this should not revert in normal conditions.\n     \n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     /\n    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {\n        if (isWethPool &amp;&amp; convertWeth) {\n            IWETH(underlying).withdraw(amount);\n            to.transfer(amount);\n        } else {\n            IERC20(underlying).safeTransfer(to, amount);\n        }\n    }\n\n    function availableForBorrow() external view override returns (uint){\n        uint cash = getCashPrior();\n        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);\n        if (err0 != MathError.NO_ERROR) {\n            return 0;\n        }\n        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);\n        if (err1 != MathError.NO_ERROR) {\n            return 0;\n        }\n        if (totalBorrows &gt; maxAvailable) {\n            return 0;\n        }\n        return maxAvailable - totalBorrows;\n    }\n\n\n    /// @notice Get a snapshot of the account\'s balances, and the cached exchange rate\n    /// @dev This is used by controller to more efficiently perform liquidity checks.\n    /// @param account Address of the account to snapshot\n    /// @return ( token balance, borrow balance, exchange rate mantissa)\n    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {\n        uint cTokenBalance = accountTokens[account];\n        uint borrowBalance;\n        uint exchangeRateMantissa;\n\n        MathError mErr;\n\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n        if (mErr != MathError.NO_ERROR) {\n            return (0, 0, 0);\n        }\n\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (mErr != MathError.NO_ERROR) {\n            return (0, 0, 0);\n        }\n\n        return (cTokenBalance, borrowBalance, exchangeRateMantissa);\n    }\n\n    /// @dev Function to simply retrieve block number\n    ///  This exists mainly for inheriting test contracts to stub this result.\n    function getBlockNumber() internal view returns (uint) {\n        return block.number;\n    }\n\n    /// @notice Returns the current per-block borrow interest rate for this cToken\n    /// @return The borrow interest rate per block, scaled by 1e18\n    function borrowRatePerBlock() external override view returns (uint) {\n        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);\n    }\n\n    \n    /// @notice Returns the current per-block supply interest rate for this cToken\n    /// @return The supply interest rate per block, scaled by 1e18\n    function supplyRatePerBlock() external override view returns (uint) {\n        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\n    }\n\n    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {\n        // Utilization rate is 0 when there are no borrows\n        if (borrows == 0) {\n            return 0;\n        }\n        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));\n    }\n\n    /// @notice Calculates the current borrow rate per block, with the error code expected by the market\n    /// @param cash The amount of cash in the market\n    /// @param borrows The amount of borrows in the market\n    /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\n    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {\n        uint util = utilizationRate(cash, borrows, reserves);\n        if (util &lt;= kink) {\n            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n        } else {\n            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n            uint excessUtil = util.sub(kink);\n            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);\n        }\n    }\n\n    /// @notice Calculates the current supply rate per block\n    /// @param cash The amount of cash in the market\n    /// @param borrows The amount of borrows in the market\n    /// @return The supply rate percentage per block as a mantissa (scaled by 1e18)\n    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {\n        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);\n        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);\n        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\n        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\n    }\n\n    /// @notice Returns the current total borrows plus accrued interest\n    /// @return The total borrows with interest\n    function totalBorrowsCurrent() external override view returns (uint) {\n        / Remember the initial block number /\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        / Short-circuit accumulating 0 interest /\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return totalBorrows;\n        }\n\n        / Read the previous values out of storage /\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint reservesPrior = totalReserves;\n\n        / Calculate the current borrow interest rate /\n        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");\n\n        / Calculate the number of blocks elapsed since the last accrual /\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        require(mathErr == MathError.NO_ERROR, "calc block delta erro");\n\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        require(mathErr == MathError.NO_ERROR, \'calc interest factor error\');\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc interest acc error\');\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc total borrows error\');\n\n        return totalBorrowsNew;\n    }\n\n    /// @notice Accrue interest to updated borrowIndex and then calculate account\'s borrow balance using the updated borrowIndex\n    /// @param account The address whose balance should be calculated after updating borrowIndex\n    /// @return The calculated balance\n    function borrowBalanceCurrent(address account) external view override returns (uint) {\n        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();\n        require(err0 == MathError.NO_ERROR, "calc borrow index fail");\n        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);\n        require(err1 == MathError.NO_ERROR, "calc fail");\n        return result;\n    }\n\n    function borrowBalanceStored(address account) external override view returns (uint){\n        return accountBorrows[account].principal;\n    }\n\n\n    /// @notice Return the borrow balance of account based on stored data\n    /// @param account The address whose balance should be calculated\n    /// @return (error code, the calculated balance or 0 if error code is non-zero)\n    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {\n        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);\n    }\n\n    /// @notice Return the borrow balance of account based on stored data\n    /// @param account The address whose balance should be calculated\n    /// @return (error code, the calculated balance or 0 if error code is non-zero)\n    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {\n        / Note: we do not assert that the market is up to date /\n        MathError mathErr;\n        uint principalTimesIndex;\n        uint result;\n\n        / Get borrowBalance and borrowIndex /\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        / If borrowBalance = 0 then borrowIndex is likely also 0.\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n         /\n        if (borrowSnapshot.principal == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        / Calculate new borrow balance using the interest index:\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n         /\n        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        return (MathError.NO_ERROR, result);\n    }\n\n    /// @notice Accrue interest then return the up-to-date exchange rate\n    /// @return Calculated exchange rate scaled by 1e18\n    function exchangeRateCurrent() public override nonReentrant returns (uint) {\n        accrueInterest();\n        return exchangeRateStored();\n    }\n\n    /// Calculates the exchange rate from the underlying to the LToken\n    /// @dev This function does not accrue interest before calculating the exchange rate\n    /// @return Calculated exchange rate scaled by 1e18\n    function exchangeRateStored() public override view returns (uint) {\n        (MathError err, uint result) = exchangeRateStoredInternal();\n        require(err == MathError.NO_ERROR, "calc fail");\n        return result;\n    }\n\n    /// @notice Calculates the exchange rate from the underlying to the LToken\n    /// @dev This function does not accrue interest before calculating the exchange rate\n    /// @return (error code, calculated exchange rate scaled by 1e18)\n    function exchangeRateStoredInternal() internal view returns (MathError, uint) {\n        uint _totalSupply = totalSupply;\n        if (_totalSupply == 0) {\n            /\n             * If there are no tokens minted:\n             *  exchangeRate = initialExchangeRate\n             /\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\n        } else {\n            /\n             * Otherwise:\n             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n             /\n            uint _totalCash = getCashPrior();\n            uint cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n            MathError mathErr;\n\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\n        }\n    }\n\n    /// @notice Get cash balance of this cToken in the underlying asset\n    /// @return The quantity of underlying asset owned by this contract\n    function getCash() external override view returns (uint) {\n        return IERC20(underlying).balanceOf(address(this));\n    }\n\n    function calCurrentBorrowIndex() internal view returns (MathError, uint) {\n        / Remember the initial block number /\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n        uint borrowIndexNew;\n        / Short-circuit accumulating 0 interest /\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return (MathError.NO_ERROR, borrowIndex);\n        }\n        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n\n        Exp memory simpleInterestFactor;\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);\n        return (mathErr, borrowIndexNew);\n    }\n\n    /// @notice Applies accrued interest to total borrows and reserves\n    /// @dev This calculates interest accrued from the last checkpointed block\n    ///   up to the current block and writes new checkpoint to storage.\n    function accrueInterest() public override {\n        / Remember the initial block number /\n        uint currentBlockNumber = getBlockNumber();\n        uint accrualBlockNumberPrior = accrualBlockNumber;\n\n        / Short-circuit accumulating 0 interest /\n        if (accrualBlockNumberPrior == currentBlockNumber) {\n            return;\n        }\n\n        / Read the previous values out of storage /\n        uint cashPrior = getCashPrior();\n        uint borrowsPrior = totalBorrows;\n        uint borrowIndexPrior = borrowIndex;\n        uint reservesPrior = totalReserves;\n\n        / Calculate the current borrow interest rate /\n        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);\n        require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");\n\n        / Calculate the number of blocks elapsed since the last accrual /\n        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);\n        require(mathErr == MathError.NO_ERROR, "calc block delta erro");\n\n\n        /\n         * Calculate the interest accumulated into borrows and reserves and the new index:\n         *  simpleInterestFactor = borrowRate * blockDelta\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n         /\n\n        Exp memory simpleInterestFactor;\n        uint interestAccumulated;\n        uint totalBorrowsNew;\n        uint borrowIndexNew;\n        uint totalReservesNew;\n\n        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);\n        require(mathErr == MathError.NO_ERROR, \'calc interest factor error\');\n\n        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc interest acc error\');\n\n        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc total borrows error\');\n\n        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc total reserves error\');\n\n        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n        require(mathErr == MathError.NO_ERROR, \'calc borrows index error\');\n\n\n        / We write the previously calculated values into storage /\n        accrualBlockNumber = currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n        totalReserves = totalReservesNew;\n\n        / We emit an AccrueInterest event /\n        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n    }\n\n    struct MintLocalVars {\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint mintTokens;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n        uint actualMintAmount;\n    }\n\n    /// @notice User supplies assets into the market and receives lTokens in exchange\n    /// @dev Assumes interest has already been accrued up to the current block\n    /// @param minter The address of the account which is supplying the assets\n    /// @param mintAmount The amount of the underlying asset to supply\n    /// @return uint the actual mint amount.\n    function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {\n        MintLocalVars memory vars;\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, \'calc exchangerate error\');\n\n        /\n         *  We call doTransferIn for the minter and the mintAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  doTransferIn reverts if anything goes wrong, since we can\'t be sure if\n         *  side-effects occurred. The function returns the amount actually transferred,\n         *  in case of a fee. On success, the cToken holds an additional actualMintAmount\n         *  of cash.\n         /\n        if (isDelegete) {\n            uint balanceBefore = getCashPrior();\n            LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);\n            uint balanceAfter = getCashPrior();\n            require(balanceAfter &gt; balanceBefore, \'mint 0\');\n            vars.actualMintAmount = balanceAfter - balanceBefore;\n        } else {\n            vars.actualMintAmount = doTransferIn(minter, mintAmount, true);\n        }\n        /\n         * We get the current exchange rate and calculate the number of lTokens to be minted:\n         *  mintTokens = actualMintAmount / exchangeRate\n         /\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));\n        require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");\n\n        / Fail if mint not allowed /\n        (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);\n        /\n         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:\n         *  totalSupplyNew = totalSupply + mintTokens\n         *  accountTokensNew = accountTokens[minter] + mintTokens\n         /\n        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\n        require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");\n\n        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);\n        require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");\n\n        / We write previously calculated values into storage /\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[minter] = vars.accountTokensNew;\n\n        / We emit a Mint event, and a Transfer event /\n        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n        emit Transfer(address(this), minter, vars.mintTokens);\n\n        / We call the defense hook /\n\n        return vars.actualMintAmount;\n    }\n\n\n    struct RedeemLocalVars {\n        MathError mathErr;\n        uint exchangeRateMantissa;\n        uint redeemTokens;\n        uint redeemAmount;\n        uint totalSupplyNew;\n        uint accountTokensNew;\n    }\n\n    /// @notice User redeems lTokens in exchange for the underlying asset\n    /// @dev Assumes interest has already been accrued up to the current block\n    /// @param redeemer The address of the account which is redeeming the tokens\n    /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n    /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {\n        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");\n\n        RedeemLocalVars memory vars;\n\n        / exchangeRate = invoke Exchange Rate Stored() /\n        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n        require(vars.mathErr == MathError.NO_ERROR, \'calc exchangerate error\');\n\n        / If redeemTokensIn &gt; 0: /\n        if (redeemTokensIn &gt; 0) {\n            /\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\n             *  redeemTokens = redeemTokensIn\n             *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n             /\n            vars.redeemTokens = redeemTokensIn;\n\n            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);\n            require(vars.mathErr == MathError.NO_ERROR, \'calc redeem amount error\');\n        } else {\n            /\n             * We get the current exchange rate and calculate the amount to be redeemed:\n             *  redeemTokens = redeemAmountIn / exchangeRate\n             *  redeemAmount = redeemAmountIn\n             /\n\n            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));\n            require(vars.mathErr == MathError.NO_ERROR, \'calc redeem tokens error\');\n            vars.redeemAmount = redeemAmountIn;\n        }\n\n        / Fail if redeem not allowed /\n        (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);\n\n        /\n         * We calculate the new total supply and redeemer balance, checking for underflow:\n         *  totalSupplyNew = totalSupply - redeemTokens\n         *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n         /\n        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n        require(vars.mathErr == MathError.NO_ERROR, \'calc supply new error\');\n\n        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n        require(vars.mathErr == MathError.NO_ERROR, \'calc token new error\');\n        require(getCashPrior() &gt;= vars.redeemAmount, \'cash &lt; redeem\');\n\n        / We write previously calculated values into storage /\n        totalSupply = vars.totalSupplyNew;\n        accountTokens[redeemer] = vars.accountTokensNew;\n        /\n         * We invoke doTransferOut for the redeemer and the redeemAmount.\n         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n         *  On success, the cToken has redeemAmount less of cash.\n         *  doTransferOut reverts if anything goes wrong, since we can\'t be sure if side effects occurred.\n         /\n        doTransferOut(redeemer, vars.redeemAmount, true);\n\n\n        / We emit a Transfer event, and a Redeem event /\n        emit Transfer(redeemer, address(this), vars.redeemTokens);\n        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n        / We call the defense hook /\n    }\n\n    struct BorrowLocalVars {\n        MathError mathErr;\n        uint accountBorrows;\n        uint accountBorrowsNew;\n        uint totalBorrowsNew;\n    }\n\n    /// @notice Users borrow assets from the protocol to their own address\n    /// @param borrowAmount The amount of the underlying asset to borrow\n    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {\n        / Fail if borrow not allowed /\n        (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);\n\n        / Fail gracefully if protocol has insufficient underlying cash /\n        require(getCashPrior() &gt;= borrowAmount, \'cash vars.actualRepayAmount) {\n            vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;\n        }\n\n        /\n        *  We calculate the new borrower and total borrow balances, failing on underflow:\n        *  accountBorrowsNew = accountBorrows - repayAmount\n        *  totalBorrowsNew = totalBorrows - repayAmount\n        /\n        if (vars.accountBorrows &lt; vars.actualRepayAmount) {\n            require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) &lt;= 105e16, \'repay more than 5%\');\n            vars.accountBorrowsNew = 0;\n        } else {\n            if (isEnd) {\n                vars.accountBorrowsNew = 0;\n            } else {\n                vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;\n            }\n        }\n        //Avoid mantissa errors\n        if (vars.actualRepayAmount &gt; totalBorrows) {\n            vars.totalBorrowsNew = 0;\n        } else {\n            if (isEnd) {\n                vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);\n            } else {\n                vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;\n            }\n        }\n\n        / We write the previously calculated values into storage /\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        / We emit a RepayBorrow event /\n        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n        / We call the defense hook */\n\n        return vars.actualRepayAmount;\n    }\n\n    / Admin Functions ***/\n\n    /// @notice Sets a new CONTROLLER for the market\n    /// @dev Admin function to set a new controller\n    function setController(address newController) external override onlyAdmin {\n        require(address(0) != newController, "0x");\n        address oldController = controller;\n        controller = newController;\n        // Emit NewController(oldController, newController)\n        emit NewController(oldController, newController);\n    }\n\n    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {\n        require(newBorrowCapFactorMantissa &lt;= 1e18, \'Factor too large\');\n        uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;\n        borrowCapFactorMantissa = newBorrowCapFactorMantissa;\n        emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa);\n    }\n\n    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {\n        //accrueInterest except first\n        if (baseRatePerBlock != 0) {\n            accrueInterest();\n        }\n        // total rate perYear &lt; 2000%\n        require(baseRatePerBlock_ &lt; 1e13, \'Base rate too large\');\n        baseRatePerBlock = baseRatePerBlock_;\n        require(multiplierPerBlock_ &lt; 1e13, \'Mul rate too large\');\n        multiplierPerBlock = multiplierPerBlock_;\n        require(jumpMultiplierPerBlock_ &lt; 1e13, \'Jump rate too large\');\n        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;\n        require(kink_ &lt;= 1e18, \'Kline too large\');\n        kink = kink_;\n        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);\n    }\n\n    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {\n        require(newReserveFactorMantissa &lt;= 1e18, \'Factor too large\');\n        accrueInterest();\n        uint oldReserveFactorMantissa = reserveFactorMantissa;\n        reserveFactorMantissa = newReserveFactorMantissa;\n        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n    }\n\n    function addReserves(uint addAmount) external override nonReentrant {\n        accrueInterest();\n        uint totalReservesNew;\n        uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);\n        totalReservesNew = totalReserves.add(actualAddAmount);\n        totalReserves = totalReservesNew;\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n    }\n\n    function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {\n        accrueInterest();\n        uint totalReservesNew;\n        totalReservesNew = totalReserves.sub(reduceAmount);\n        totalReserves = totalReservesNew;\n        doTransferOut(to, reduceAmount, true);\n        emit ReservesReduced(to, reduceAmount, totalReservesNew);\n    }\n\n    modifier sameBlock() {\n        require(accrualBlockNumber == getBlockNumber(), \'not same block\');\n        _;\n    }\n}\n\n', 'ideas': ' Security', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-24-08 19:28:56 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.7.6; import "./LPoolInterface.sol"; import "./LPoolDepositor.sol"; import "../lib/Exponential.sol"; import "../Adminable.sol"; import "../lib/CarefulMath.sol"; import "../lib/TransferHelper.sol"; import "@openzeppelin/contracts/utils/ReentrancyGuard.sol"; import "../DelegateInterface.sol"; import "../ControllerInterface.sol"; import "../IWETH.sol"; /// @title OpenLeverage's LToken Contract /// @dev Abstract base for LTokens /// @author OpenLeverage contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {     using TransferHelper for IERC20;     using SafeMath for uint; constructor() {  }  /// @notice Initialize the money market /// @param controller_ The address of the Controller /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0 /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point /// @param kink_ The utilization point at which the jump multiplier is applied /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18 /// @param name_ EIP-20 name of this token /// @param symbol_ EIP-20 symbol of this token /// @param decimals_ EIP-20 decimal precision of this token function initialize(     address underlying_,     bool isWethPool_,     address controller_,     uint256 baseRatePerBlock_,     uint256 multiplierPerBlock_,     uint256 jumpMultiplierPerBlock_,     uint256 kink_,     uint initialExchangeRateMantissa_,     string memory name_,     string memory symbol_,     uint8 decimals_) public {     require(underlying_ != address(0), "underlying_ address cannot be 0");     require(controller_ != address(0), "controller_ address cannot be 0");     require(msg.sender == admin, "Only allow to be called by admin");     require(accrualBlockNumber == 0 &amp;&amp; borrowIndex == 0, "inited once");      // Set initial exchange rate     initialExchangeRateMantissa = initialExchangeRateMantissa_;     require(initialExchangeRateMantissa &gt; 0, "Initial Exchange Rate Mantissa should be greater zero");     //set controller     controller = controller_;     isWethPool = isWethPool_;     //set interestRateModel     baseRatePerBlock = baseRatePerBlock_;     multiplierPerBlock = multiplierPerBlock_;     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     kink = kink_;      // Initialize block number and borrow index (block number mocks depend on controller being set)     accrualBlockNumber = getBlockNumber();     borrowIndex = 1e25;     //80%     borrowCapFactorMantissa = 0.8e18;     //10%     reserveFactorMantissa = 0.1e18;       name = name_;     symbol = symbol_;     decimals = decimals_;      _notEntered = true;      // Set underlying and sanity check it     underlying = underlying_;     IERC20(underlying).totalSupply();     emit Transfer(address(0), msg.sender, 0); }  /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender` /// @dev Called by both `transfer` and `transferFrom` internally /// @param spender The address of the account performing the transfer /// @param src The address of the source account /// @param dst The address of the destination account /// @param tokens The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {     require(dst != address(0), "dst address cannot be 0");     /* Do not allow self-transfers */     require(src != dst, "src = dst");     /* Fail if transfer not allowed */     (ControllerInterface(controller)).transferAllowed(src, dst, tokens);      /* Get the allowance, infinite for the account owner */     uint startingAllowance = 0;     if (spender == src) {         startingAllowance = uint(- 1);     } else {         startingAllowance = transferAllowances[src][spender];     }      /* Do the calculations, checking for {under,over}flow */     MathError mathErr;     uint allowanceNew;     uint srcTokensNew;     uint dstTokensNew;      (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);     require(mathErr == MathError.NO_ERROR, 'not allowed');      (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);     require(mathErr == MathError.NO_ERROR, 'not enough');      (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);     require(mathErr == MathError.NO_ERROR, 'too much');      accountTokens[src] = srcTokensNew;     accountTokens[dst] = dstTokensNew;      /* Eat some of the allowance (if necessary) */     if (startingAllowance != uint(- 1)) {         transferAllowances[src][spender] = allowanceNew;     }     /* We emit a Transfer event */     emit Transfer(src, dst, tokens);     return true; }  /// @notice Transfer `amount` tokens from `msg.sender` to `dst` /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, msg.sender, dst, amount); }  /// @notice Transfer `amount` tokens from `src` to `dst` /// @param src The address of the source account /// @param dst The address of the destination account /// @param amount The number of tokens to transfer /// @return Whether or not the transfer succeeded function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {     return transferTokens(msg.sender, src, dst, amount); }  /// @notice Approve `spender` to transfer up to `amount` from `src` /// @dev This will overwrite the approval amount for `spender` ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve) /// @param spender The address of the account which may transfer tokens /// @param amount The number of tokens that are approved (-1 means infinite) /// @return Whether or not the approval succeeded function approve(address spender, uint256 amount) external override returns (bool) {     address src = msg.sender;     transferAllowances[src][spender] = amount;     emit Approval(src, spender, amount);     return true; }  /// @notice Get the current allowance from `owner` for `spender` /// @param owner The address of the account which owns the tokens to be spent /// @param spender The address of the account which may transfer tokens /// @return The number of tokens allowed to be spent (-1 means infinite) function allowance(address owner, address spender) external override view returns (uint256) {     return transferAllowances[owner][spender]; }  /// @notice Get the token balance of the `owner` /// @param owner The address of the account to query /// @return The number of tokens owned by `owner` function balanceOf(address owner) external override view returns (uint256) {     return accountTokens[owner]; }  /// @notice Get the underlying balance of the `owner` /// @dev This also accrues interest in a transaction /// @param owner The address of the account to query /// @return The amount of underlying owned by `owner` function balanceOfUnderlying(address owner) external override returns (uint) {     Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});     (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);     require(mErr == MathError.NO_ERROR, "calc failed");     return balance; }  /*** User Interface ***/  /// @notice Sender supplies assets into the market and receives lTokens in exchange /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param mintAmount The amount of the underlying asset to supply function mint(uint mintAmount) external override nonReentrant {     accrueInterest();     mintFresh(msg.sender, mintAmount, false); }  function mintTo(address to, uint amount) external payable override nonReentrant {     accrueInterest();     if (isWethPool) {         mintFresh(to, msg.value, false);     } else {         mintFresh(to, amount, true);     } }  function mintEth() external payable override nonReentrant {     require(isWethPool, "not eth pool");     accrueInterest();     mintFresh(msg.sender, msg.value, false); }  /// @notice Sender redeems lTokens in exchange for the underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemTokens The number of lTokens to redeem into underlying function redeem(uint redeemTokens) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, redeemTokens, 0); }  /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset /// @dev Accrues interest whether or not the operation succeeds, unless reverted /// @param redeemAmount The amount of underlying to redeem function redeemUnderlying(uint redeemAmount) external override nonReentrant {     accrueInterest();     // redeemFresh emits redeem-specific logs on errors, so we don't need to     redeemFresh(msg.sender, 0, redeemAmount); }  function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {     accrueInterest();     // borrowFresh emits borrow-specific logs on errors, so we don't need to     borrowFresh(payable(borrower), msg.sender, borrowAmount); }  /// @notice Sender repays a borrow belonging to borrower /// @param borrower the account with the debt being payed off /// @param repayAmount The amount to repay function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to     repayBorrowFresh(msg.sender, borrower, repayAmount, false); }  function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {     accrueInterest();     repayBorrowFresh(msg.sender, borrower, repayAmount, true); }   /*** Safe Token ***/  /// Gets balance of this contract in terms of the underlying /// @dev This excludes the value of the current message, if any /// @return The quantity of underlying tokens owned by this contract function getCashPrior() internal view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }   /**  * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.  *      This will revert due to insufficient balance or insufficient allowance.  *      This function returns the actual amount received,  *      which may be less than `amount` if there is a fee attached to the transfer.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {     if (isWethPool &amp;&amp; convertWeth) {         actualAmount = msg.value;         IWETH(underlying).deposit{value : actualAmount}();     } else {         actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);     } }  /**  * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory  *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to  *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified  *      it is &gt;= amount, this should not revert in normal conditions.  *  *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.  *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca  */ function doTransferOut(address payable to, uint amount, bool convertWeth) internal {     if (isWethPool &amp;&amp; convertWeth) {         IWETH(underlying).withdraw(amount);         to.transfer(amount);     } else {         IERC20(underlying).safeTransfer(to, amount);     } }  function availableForBorrow() external view override returns (uint){     uint cash = getCashPrior();     (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);     if (err0 != MathError.NO_ERROR) {         return 0;     }     (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);     if (err1 != MathError.NO_ERROR) {         return 0;     }     if (totalBorrows &gt; maxAvailable) {         return 0;     }     return maxAvailable - totalBorrows; }   /// @notice Get a snapshot of the account's balances, and the cached exchange rate /// @dev This is used by controller to more efficiently perform liquidity checks. /// @param account Address of the account to snapshot /// @return ( token balance, borrow balance, exchange rate mantissa) function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {     uint cTokenBalance = accountTokens[account];     uint borrowBalance;     uint exchangeRateMantissa;      MathError mErr;      (mErr, borrowBalance) = borrowBalanceStoredInternal(account);     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();     if (mErr != MathError.NO_ERROR) {         return (0, 0, 0);     }      return (cTokenBalance, borrowBalance, exchangeRateMantissa); }  /// @dev Function to simply retrieve block number ///  This exists mainly for inheriting test contracts to stub this result. function getBlockNumber() internal view returns (uint) {     return block.number; }  /// @notice Returns the current per-block borrow interest rate for this cToken /// @return The borrow interest rate per block, scaled by 1e18 function borrowRatePerBlock() external override view returns (uint) {     return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves); }   /// @notice Returns the current per-block supply interest rate for this cToken /// @return The supply interest rate per block, scaled by 1e18 function supplyRatePerBlock() external override view returns (uint) {     return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa); }  function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {     // Utilization rate is 0 when there are no borrows     if (borrows == 0) {         return 0;     }     return borrows.mul(1e18).div(cash.add(borrows).sub(reserves)); }  /// @notice Calculates the current borrow rate per block, with the error code expected by the market /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18) function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {     uint util = utilizationRate(cash, borrows, reserves);     if (util &lt;= kink) {         return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);     } else {         uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);         uint excessUtil = util.sub(kink);         return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);     } }  /// @notice Calculates the current supply rate per block /// @param cash The amount of cash in the market /// @param borrows The amount of borrows in the market /// @return The supply rate percentage per block as a mantissa (scaled by 1e18) function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {     uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);     uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);     uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);     return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18); }  /// @notice Returns the current total borrows plus accrued interest /// @return The total borrows with interest function totalBorrowsCurrent() external override view returns (uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return totalBorrows;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, "calc block delta erro");      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      return totalBorrowsNew; }  /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex /// @param account The address whose balance should be calculated after updating borrowIndex /// @return The calculated balance function borrowBalanceCurrent(address account) external view override returns (uint) {     (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();     require(err0 == MathError.NO_ERROR, "calc borrow index fail");     (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);     require(err1 == MathError.NO_ERROR, "calc fail");     return result; }  function borrowBalanceStored(address account) external override view returns (uint){     return accountBorrows[account].principal; }   /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {     return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex); }  /// @notice Return the borrow balance of account based on stored data /// @param account The address whose balance should be calculated /// @return (error code, the calculated balance or 0 if error code is non-zero) function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {     /* Note: we do not assert that the market is up to date */     MathError mathErr;     uint principalTimesIndex;     uint result;      /* Get borrowBalance and borrowIndex */     BorrowSnapshot storage borrowSnapshot = accountBorrows[account];      /* If borrowBalance = 0 then borrowIndex is likely also 0.      * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.      */     if (borrowSnapshot.principal == 0) {         return (MathError.NO_ERROR, 0);     }      /* Calculate new borrow balance using the interest index:      *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex      */     (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }      return (MathError.NO_ERROR, result); }  /// @notice Accrue interest then return the up-to-date exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateCurrent() public override nonReentrant returns (uint) {     accrueInterest();     return exchangeRateStored(); }  /// Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return Calculated exchange rate scaled by 1e18 function exchangeRateStored() public override view returns (uint) {     (MathError err, uint result) = exchangeRateStoredInternal();     require(err == MathError.NO_ERROR, "calc fail");     return result; }  /// @notice Calculates the exchange rate from the underlying to the LToken /// @dev This function does not accrue interest before calculating the exchange rate /// @return (error code, calculated exchange rate scaled by 1e18) function exchangeRateStoredInternal() internal view returns (MathError, uint) {     uint _totalSupply = totalSupply;     if (_totalSupply == 0) {         /*          * If there are no tokens minted:          *  exchangeRate = initialExchangeRate          */         return (MathError.NO_ERROR, initialExchangeRateMantissa);     } else {         /*          * Otherwise:          *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply          */         uint _totalCash = getCashPrior();         uint cashPlusBorrowsMinusReserves;         Exp memory exchangeRate;         MathError mathErr;          (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);         if (mathErr != MathError.NO_ERROR) {             return (mathErr, 0);         }          return (MathError.NO_ERROR, exchangeRate.mantissa);     } }  /// @notice Get cash balance of this cToken in the underlying asset /// @return The quantity of underlying asset owned by this contract function getCash() external override view returns (uint) {     return IERC20(underlying).balanceOf(address(this)); }  function calCurrentBorrowIndex() internal view returns (MathError, uint) {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;     uint borrowIndexNew;     /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return (MathError.NO_ERROR, borrowIndex);     }     uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);      Exp memory simpleInterestFactor;     (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     if (mathErr != MathError.NO_ERROR) {         return (mathErr, 0);     }     (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);     return (mathErr, borrowIndexNew); }  /// @notice Applies accrued interest to total borrows and reserves /// @dev This calculates interest accrued from the last checkpointed block ///   up to the current block and writes new checkpoint to storage. function accrueInterest() public override {     /* Remember the initial block number */     uint currentBlockNumber = getBlockNumber();     uint accrualBlockNumberPrior = accrualBlockNumber;      /* Short-circuit accumulating 0 interest */     if (accrualBlockNumberPrior == currentBlockNumber) {         return;     }      /* Read the previous values out of storage */     uint cashPrior = getCashPrior();     uint borrowsPrior = totalBorrows;     uint borrowIndexPrior = borrowIndex;     uint reservesPrior = totalReserves;      /* Calculate the current borrow interest rate */     uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);     require(borrowRateMantissa &lt;= borrowRateMaxMantissa, "borrower rate higher");      /* Calculate the number of blocks elapsed since the last accrual */     (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);     require(mathErr == MathError.NO_ERROR, "calc block delta erro");       /*      * Calculate the interest accumulated into borrows and reserves and the new index:      *  simpleInterestFactor = borrowRate * blockDelta      *  interestAccumulated = simpleInterestFactor * totalBorrows      *  totalBorrowsNew = interestAccumulated + totalBorrows      *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex      */      Exp memory simpleInterestFactor;     uint interestAccumulated;     uint totalBorrowsNew;     uint borrowIndexNew;     uint totalReservesNew;      (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);     require(mathErr == MathError.NO_ERROR, 'calc interest factor error');      (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc interest acc error');      (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);     require(mathErr == MathError.NO_ERROR, 'calc total borrows error');      (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);     require(mathErr == MathError.NO_ERROR, 'calc total reserves error');      (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);     require(mathErr == MathError.NO_ERROR, 'calc borrows index error');       /* We write the previously calculated values into storage */     accrualBlockNumber = currentBlockNumber;     borrowIndex = borrowIndexNew;     totalBorrows = totalBorrowsNew;     totalReserves = totalReservesNew;      /* We emit an AccrueInterest event */     emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);  }  struct MintLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint mintTokens;     uint totalSupplyNew;     uint accountTokensNew;     uint actualMintAmount; }  /// @notice User supplies assets into the market and receives lTokens in exchange /// @dev Assumes interest has already been accrued up to the current block /// @param minter The address of the account which is supplying the assets /// @param mintAmount The amount of the underlying asset to supply /// @return uint the actual mint amount. function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {     MintLocalVars memory vars;     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /*      *  We call `doTransferIn` for the minter and the mintAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if      *  side-effects occurred. The function returns the amount actually transferred,      *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`      *  of cash.      */     if (isDelegete) {         uint balanceBefore = getCashPrior();         LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);         uint balanceAfter = getCashPrior();         require(balanceAfter &gt; balanceBefore, 'mint 0');         vars.actualMintAmount = balanceAfter - balanceBefore;     } else {         vars.actualMintAmount = doTransferIn(minter, mintAmount, true);     }     /*      * We get the current exchange rate and calculate the number of lTokens to be minted:      *  mintTokens = actualMintAmount / exchangeRate      */      (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));     require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");      /* Fail if mint not allowed */     (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);     /*      * We calculate the new total supply of lTokens and minter token balance, checking for overflow:      *  totalSupplyNew = totalSupply + mintTokens      *  accountTokensNew = accountTokens[minter] + mintTokens      */     (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");      (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);     require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[minter] = vars.accountTokensNew;      /* We emit a Mint event, and a Transfer event */     emit Mint(minter, vars.actualMintAmount, vars.mintTokens);     emit Transfer(address(this), minter, vars.mintTokens);      /* We call the defense hook */      return vars.actualMintAmount; }   struct RedeemLocalVars {     MathError mathErr;     uint exchangeRateMantissa;     uint redeemTokens;     uint redeemAmount;     uint totalSupplyNew;     uint accountTokensNew; }  /// @notice User redeems lTokens in exchange for the underlying asset /// @dev Assumes interest has already been accrued up to the current block /// @param redeemer The address of the account which is redeeming the tokens /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero) /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero) function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {     require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");      RedeemLocalVars memory vars;      /* exchangeRate = invoke Exchange Rate Stored() */     (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();     require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');      /* If redeemTokensIn &gt; 0: */     if (redeemTokensIn &gt; 0) {         /*          * We calculate the exchange rate and the amount of underlying to be redeemed:          *  redeemTokens = redeemTokensIn          *  redeemAmount = redeemTokensIn x exchangeRateCurrent          */         vars.redeemTokens = redeemTokensIn;          (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');     } else {         /*          * We get the current exchange rate and calculate the amount to be redeemed:          *  redeemTokens = redeemAmountIn / exchangeRate          *  redeemAmount = redeemAmountIn          */          (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));         require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');         vars.redeemAmount = redeemAmountIn;     }      /* Fail if redeem not allowed */     (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);      /*      * We calculate the new total supply and redeemer balance, checking for underflow:      *  totalSupplyNew = totalSupply - redeemTokens      *  accountTokensNew = accountTokens[redeemer] - redeemTokens      */     (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');      (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);     require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');     require(getCashPrior() &gt;= vars.redeemAmount, 'cash &lt; redeem');      /* We write previously calculated values into storage */     totalSupply = vars.totalSupplyNew;     accountTokens[redeemer] = vars.accountTokensNew;     /*      * We invoke doTransferOut for the redeemer and the redeemAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken has redeemAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(redeemer, vars.redeemAmount, true);       /* We emit a Transfer event, and a Redeem event */     emit Transfer(redeemer, address(this), vars.redeemTokens);     emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);      /* We call the defense hook */ }  struct BorrowLocalVars {     MathError mathErr;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew; }  /// @notice Users borrow assets from the protocol to their own address /// @param borrowAmount The amount of the underlying asset to borrow function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {     /* Fail if borrow not allowed */     (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);      /* Fail gracefully if protocol has insufficient underlying cash */     require(getCashPrior() &gt;= borrowAmount, 'cash&lt;borrow');      BorrowLocalVars memory vars;      /*      * We calculate the new borrower and total borrow balances, failing on overflow:      *  accountBorrowsNew = accountBorrows + borrowAmount      *  totalBorrowsNew = totalBorrows + borrowAmount      */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');      (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);     require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /*      * We invoke doTransferOut for the borrower and the borrowAmount.      *  Note: The cToken must handle variations between ERC-20 and ETH underlying.      *  On success, the cToken borrowAmount less of cash.      *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.      */     doTransferOut(payee, borrowAmount, false);      /* We emit a Borrow event */     emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */ }  struct RepayBorrowLocalVars {     MathError mathErr;     uint repayAmount;     uint borrowerIndex;     uint accountBorrows;     uint accountBorrowsNew;     uint totalBorrowsNew;     uint actualRepayAmount;     uint badDebtsAmount; }  /// @notice Borrows are repaid by another user (possibly the borrower). /// @param payer the account paying off the borrow /// @param borrower the account with the debt being payed off /// @param repayAmount the amount of undelrying tokens being returned function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {     /* Fail if repayBorrow not allowed */     (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);      RepayBorrowLocalVars memory vars;      /* We remember the original borrowerIndex for verification purposes */     vars.borrowerIndex = accountBorrows[borrower].interestIndex;      /* We fetch the amount the borrower owes, with accumulated interest */     (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);     require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');      /* If repayAmount == -1, repayAmount = accountBorrows */     if (repayAmount == uint(- 1)) {         vars.repayAmount = vars.accountBorrows;     } else {         vars.repayAmount = repayAmount;     }     vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);       if (isEnd &amp;&amp; vars.accountBorrows &gt; vars.actualRepayAmount) {         vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;     }      /*     *  We calculate the new borrower and total borrow balances, failing on underflow:     *  accountBorrowsNew = accountBorrows - repayAmount     *  totalBorrowsNew = totalBorrows - repayAmount     */     if (vars.accountBorrows &lt; vars.actualRepayAmount) {         require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) &lt;= 105e16, 'repay more than 5%');         vars.accountBorrowsNew = 0;     } else {         if (isEnd) {             vars.accountBorrowsNew = 0;         } else {             vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;         }     }     //Avoid mantissa errors     if (vars.actualRepayAmount &gt; totalBorrows) {         vars.totalBorrowsNew = 0;     } else {         if (isEnd) {             vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);         } else {             vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;         }     }      /* We write the previously calculated values into storage */     accountBorrows[borrower].principal = vars.accountBorrowsNew;     accountBorrows[borrower].interestIndex = borrowIndex;     totalBorrows = vars.totalBorrowsNew;      /* We emit a RepayBorrow event */     emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);      /* We call the defense hook */      return vars.actualRepayAmount; }  /*** Admin Functions ***/  /// @notice Sets a new CONTROLLER for the market /// @dev Admin function to set a new controller function setController(address newController) external override onlyAdmin {     require(address(0) != newController, "0x");     address oldController = controller;     controller = newController;     // Emit NewController(oldController, newController)     emit NewController(oldController, newController); }  function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {     require(newBorrowCapFactorMantissa &lt;= 1e18, 'Factor too large');     uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;     borrowCapFactorMantissa = newBorrowCapFactorMantissa;     emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa); }  function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {     //accrueInterest except first     if (baseRatePerBlock != 0) {         accrueInterest();     }     // total rate perYear &lt; 2000%     require(baseRatePerBlock_ &lt; 1e13, 'Base rate too large');     baseRatePerBlock = baseRatePerBlock_;     require(multiplierPerBlock_ &lt; 1e13, 'Mul rate too large');     multiplierPerBlock = multiplierPerBlock_;     require(jumpMultiplierPerBlock_ &lt; 1e13, 'Jump rate too large');     jumpMultiplierPerBlock = jumpMultiplierPerBlock_;     require(kink_ &lt;= 1e18, 'Kline too large');     kink = kink_;     emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_); }  function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {     require(newReserveFactorMantissa &lt;= 1e18, 'Factor too large');     accrueInterest();     uint oldReserveFactorMantissa = reserveFactorMantissa;     reserveFactorMantissa = newReserveFactorMantissa;     emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa); }  function addReserves(uint addAmount) external override nonReentrant {     accrueInterest();     uint totalReservesNew;     uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);     totalReservesNew = totalReserves.add(actualAddAmount);     totalReserves = totalReservesNew;     emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew); }  function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {     accrueInterest();     uint totalReservesNew;     totalReservesNew = totalReserves.sub(reduceAmount);     totalReserves = totalReservesNew;     doTransferOut(to, reduceAmount, true);     emit ReservesReduced(to, reduceAmount, totalReservesNew); }  modifier sameBlock() {     require(accrualBlockNumber == getBlockNumber(), 'not same block');     _; }  } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-24-08 19:28:56 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;


import "./LPoolInterface.sol";
import "./LPoolDepositor.sol";
import "../lib/Exponential.sol";
import "../Adminable.sol";
import "../lib/CarefulMath.sol";
import "../lib/TransferHelper.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import "../DelegateInterface.sol";
import "../ControllerInterface.sol";
import "../IWETH.sol";

/// @title OpenLeverage's LToken Contract
/// @dev Abstract base for LTokens
/// @author OpenLeverage
contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {
    using TransferHelper for IERC20;
    using SafeMath for uint;

    constructor() {

    }
    
    /// @notice Initialize the money market
    /// @param controller_ The address of the Controller
    /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0
    /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate
    /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point
    /// @param kink_ The utilization point at which the jump multiplier is applied
    /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
    /// @param name_ EIP-20 name of this token
    /// @param symbol_ EIP-20 symbol of this token
    /// @param decimals_ EIP-20 decimal precision of this token
    function initialize(
        address underlying_,
        bool isWethPool_,
        address controller_,
        uint256 baseRatePerBlock_,
        uint256 multiplierPerBlock_,
        uint256 jumpMultiplierPerBlock_,
        uint256 kink_,
        uint initialExchangeRateMantissa_,
        string memory name_,
        string memory symbol_,
        uint8 decimals_) public {
        require(underlying_ != address(0), "underlying_ address cannot be 0");
        require(controller_ != address(0), "controller_ address cannot be 0");
        require(msg.sender == admin, "Only allow to be called by admin");
        require(accrualBlockNumber == 0 && borrowIndex == 0, "inited once");

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial Exchange Rate Mantissa should be greater zero");
        //set controller
        controller = controller_;
        isWethPool = isWethPool_;
        //set interestRateModel
        baseRatePerBlock = baseRatePerBlock_;
        multiplierPerBlock = multiplierPerBlock_;
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        kink = kink_;

        // Initialize block number and borrow index (block number mocks depend on controller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = 1e25;
        //80%
        borrowCapFactorMantissa = 0.8e18;
        //10%
        reserveFactorMantissa = 0.1e18;


        name = name_;
        symbol = symbol_;
        decimals = decimals_;

        _notEntered = true;

        // Set underlying and sanity check it
        underlying = underlying_;
        IERC20(underlying).totalSupply();
        emit Transfer(address(0), msg.sender, 0);
    }

    /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
    /// @dev Called by both `transfer` and `transferFrom` internally
    /// @param spender The address of the account performing the transfer
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param tokens The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {
        require(dst != address(0), "dst address cannot be 0");
        /* Do not allow self-transfers */
        require(src != dst, "src = dst");
        /* Fail if transfer not allowed */
        (ControllerInterface(controller)).transferAllowed(src, dst, tokens);

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(- 1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        require(mathErr == MathError.NO_ERROR, 'not allowed');

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        require(mathErr == MathError.NO_ERROR, 'not enough');

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        require(mathErr == MathError.NO_ERROR, 'too much');

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(- 1)) {
            transferAllowances[src][spender] = allowanceNew;
        }
        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);
        return true;
    }

    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount);
    }

    /// @notice Transfer `amount` tokens from `src` to `dst`
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount);
    }

    /// @notice Approve `spender` to transfer up to `amount` from `src`
    /// @dev This will overwrite the approval amount for `spender`
    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
    /// @param spender The address of the account which may transfer tokens
    /// @param amount The number of tokens that are approved (-1 means infinite)
    /// @return Whether or not the approval succeeded
    function approve(address spender, uint256 amount) external override returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /// @notice Get the current allowance from `owner` for `spender`
    /// @param owner The address of the account which owns the tokens to be spent
    /// @param spender The address of the account which may transfer tokens
    /// @return The number of tokens allowed to be spent (-1 means infinite)
    function allowance(address owner, address spender) external override view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /// @notice Get the token balance of the `owner`
    /// @param owner The address of the account to query
    /// @return The number of tokens owned by `owner`
    function balanceOf(address owner) external override view returns (uint256) {
        return accountTokens[owner];
    }

    /// @notice Get the underlying balance of the `owner`
    /// @dev This also accrues interest in a transaction
    /// @param owner The address of the account to query
    /// @return The amount of underlying owned by `owner`
    function balanceOfUnderlying(address owner) external override returns (uint) {
        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR, "calc failed");
        return balance;
    }

    /*** User Interface ***/

    /// @notice Sender supplies assets into the market and receives lTokens in exchange
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param mintAmount The amount of the underlying asset to supply
    function mint(uint mintAmount) external override nonReentrant {
        accrueInterest();
        mintFresh(msg.sender, mintAmount, false);
    }

    function mintTo(address to, uint amount) external payable override nonReentrant {
        accrueInterest();
        if (isWethPool) {
            mintFresh(to, msg.value, false);
        } else {
            mintFresh(to, amount, true);
        }
    }

    function mintEth() external payable override nonReentrant {
        require(isWethPool, "not eth pool");
        accrueInterest();
        mintFresh(msg.sender, msg.value, false);
    }

    /// @notice Sender redeems lTokens in exchange for the underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemTokens The number of lTokens to redeem into underlying
    function redeem(uint redeemTokens) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, redeemTokens, 0);
    }

    /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemAmount The amount of underlying to redeem
    function redeemUnderlying(uint redeemAmount) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, 0, redeemAmount);
    }

    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {
        accrueInterest();
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        borrowFresh(payable(borrower), msg.sender, borrowAmount);
    }

    /// @notice Sender repays a borrow belonging to borrower
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount The amount to repay
    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        repayBorrowFresh(msg.sender, borrower, repayAmount, false);
    }

    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        repayBorrowFresh(msg.sender, borrower, repayAmount, true);
    }


    /*** Safe Token ***/

    /// Gets balance of this contract in terms of the underlying
    /// @dev This excludes the value of the current message, if any
    /// @return The quantity of underlying tokens owned by this contract
    function getCashPrior() internal view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }


    /**
     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.
     *      This will revert due to insufficient balance or insufficient allowance.
     *      This function returns the actual amount received,
     *      which may be less than `amount` if there is a fee attached to the transfer.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {
        if (isWethPool && convertWeth) {
            actualAmount = msg.value;
            IWETH(underlying).deposit{value : actualAmount}();
        } else {
            actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);
        }
    }

    /**
     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory
     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to
     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified
     *      it is >= amount, this should not revert in normal conditions.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {
        if (isWethPool && convertWeth) {
            IWETH(underlying).withdraw(amount);
            to.transfer(amount);
        } else {
            IERC20(underlying).safeTransfer(to, amount);
        }
    }

    function availableForBorrow() external view override returns (uint){
        uint cash = getCashPrior();
        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);
        if (err0 != MathError.NO_ERROR) {
            return 0;
        }
        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);
        if (err1 != MathError.NO_ERROR) {
            return 0;
        }
        if (totalBorrows > maxAvailable) {
            return 0;
        }
        return maxAvailable - totalBorrows;
    }


    /// @notice Get a snapshot of the account's balances, and the cached exchange rate
    /// @dev This is used by controller to more efficiently perform liquidity checks.
    /// @param account Address of the account to snapshot
    /// @return ( token balance, borrow balance, exchange rate mantissa)
    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        return (cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /// @dev Function to simply retrieve block number
    ///  This exists mainly for inheriting test contracts to stub this result.
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /// @notice Returns the current per-block borrow interest rate for this cToken
    /// @return The borrow interest rate per block, scaled by 1e18
    function borrowRatePerBlock() external override view returns (uint) {
        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
    }

    
    /// @notice Returns the current per-block supply interest rate for this cToken
    /// @return The supply interest rate per block, scaled by 1e18
    function supplyRatePerBlock() external override view returns (uint) {
        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);
    }

    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {
        // Utilization rate is 0 when there are no borrows
        if (borrows == 0) {
            return 0;
        }
        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));
    }

    /// @notice Calculates the current borrow rate per block, with the error code expected by the market
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18)
    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {
        uint util = utilizationRate(cash, borrows, reserves);
        if (util <= kink) {
            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
        } else {
            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
            uint excessUtil = util.sub(kink);
            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);
        }
    }

    /// @notice Calculates the current supply rate per block
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The supply rate percentage per block as a mantissa (scaled by 1e18)
    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {
        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);
        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);
        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);
        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);
    }

    /// @notice Returns the current total borrows plus accrued interest
    /// @return The total borrows with interest
    function totalBorrowsCurrent() external override view returns (uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return totalBorrows;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        return totalBorrowsNew;
    }

    /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
    /// @param account The address whose balance should be calculated after updating borrowIndex
    /// @return The calculated balance
    function borrowBalanceCurrent(address account) external view override returns (uint) {
        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();
        require(err0 == MathError.NO_ERROR, "calc borrow index fail");
        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
        require(err1 == MathError.NO_ERROR, "calc fail");
        return result;
    }

    function borrowBalanceStored(address account) external override view returns (uint){
        return accountBorrows[account].principal;
    }


    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
    }

    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /// @notice Accrue interest then return the up-to-date exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateCurrent() public override nonReentrant returns (uint) {
        accrueInterest();
        return exchangeRateStored();
    }

    /// Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateStored() public override view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "calc fail");
        return result;
    }

    /// @notice Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return (error code, calculated exchange rate scaled by 1e18)
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        uint _totalSupply = totalSupply;
        if (_totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint _totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /// @notice Get cash balance of this cToken in the underlying asset
    /// @return The quantity of underlying asset owned by this contract
    function getCash() external override view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }

    function calCurrentBorrowIndex() internal view returns (MathError, uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;
        uint borrowIndexNew;
        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return (MathError.NO_ERROR, borrowIndex);
        }
        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);

        Exp memory simpleInterestFactor;
        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }
        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);
        return (mathErr, borrowIndexNew);
    }

    /// @notice Applies accrued interest to total borrows and reserves
    /// @dev This calculates interest accrued from the last checkpointed block
    ///   up to the current block and writes new checkpoint to storage.
    function accrueInterest() public override {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint borrowIndexPrior = borrowIndex;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");


        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;
        uint borrowIndexNew;
        uint totalReservesNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total reserves error');

        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);
        require(mathErr == MathError.NO_ERROR, 'calc borrows index error');


        /* We write the previously calculated values into storage */
        accrualBlockNumber = currentBlockNumber;
        borrowIndex = borrowIndexNew;
        totalBorrows = totalBorrowsNew;
        totalReserves = totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);

    }

    struct MintLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
        uint actualMintAmount;
    }

    /// @notice User supplies assets into the market and receives lTokens in exchange
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param minter The address of the account which is supplying the assets
    /// @param mintAmount The amount of the underlying asset to supply
    /// @return uint the actual mint amount.
    function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {
        MintLocalVars memory vars;
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /*
         *  We call `doTransferIn` for the minter and the mintAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if
         *  side-effects occurred. The function returns the amount actually transferred,
         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`
         *  of cash.
         */
        if (isDelegete) {
            uint balanceBefore = getCashPrior();
            LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);
            uint balanceAfter = getCashPrior();
            require(balanceAfter > balanceBefore, 'mint 0');
            vars.actualMintAmount = balanceAfter - balanceBefore;
        } else {
            vars.actualMintAmount = doTransferIn(minter, mintAmount, true);
        }
        /*
         * We get the current exchange rate and calculate the number of lTokens to be minted:
         *  mintTokens = actualMintAmount / exchangeRate
         */

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));
        require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");

        /* Fail if mint not allowed */
        (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);
        /*
         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */

        return vars.actualMintAmount;
    }


    struct RedeemLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /// @notice User redeems lTokens in exchange for the underlying asset
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param redeemer The address of the account which is redeeming the tokens
    /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');
            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');
        require(getCashPrior() >= vars.redeemAmount, 'cash < redeem');

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;
        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(redeemer, vars.redeemAmount, true);


        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
    }

    struct BorrowLocalVars {
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /// @notice Users borrow assets from the protocol to their own address
    /// @param borrowAmount The amount of the underlying asset to borrow
    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {
        /* Fail if borrow not allowed */
        (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);

        /* Fail gracefully if protocol has insufficient underlying cash */
        require(getCashPrior() >= borrowAmount, 'cash<borrow');

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(payee, borrowAmount, false);

        /* We emit a Borrow event */
        emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
    }

    struct RepayBorrowLocalVars {
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
        uint actualRepayAmount;
        uint badDebtsAmount;
    }

    /// @notice Borrows are repaid by another user (possibly the borrower).
    /// @param payer the account paying off the borrow
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount the amount of undelrying tokens being returned
    function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {
        /* Fail if repayBorrow not allowed */
        (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(- 1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }
        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);


        if (isEnd && vars.accountBorrows > vars.actualRepayAmount) {
            vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;
        }

        /*
        *  We calculate the new borrower and total borrow balances, failing on underflow:
        *  accountBorrowsNew = accountBorrows - repayAmount
        *  totalBorrowsNew = totalBorrows - repayAmount
        */
        if (vars.accountBorrows < vars.actualRepayAmount) {
            require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) <= 105e16, 'repay more than 5%');
            vars.accountBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.accountBorrowsNew = 0;
            } else {
                vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;
            }
        }
        //Avoid mantissa errors
        if (vars.actualRepayAmount > totalBorrows) {
            vars.totalBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);
            } else {
                vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;
            }
        }

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */

        return vars.actualRepayAmount;
    }

    /*** Admin Functions ***/

    /// @notice Sets a new CONTROLLER for the market
    /// @dev Admin function to set a new controller
    function setController(address newController) external override onlyAdmin {
        require(address(0) != newController, "0x");
        address oldController = controller;
        controller = newController;
        // Emit NewController(oldController, newController)
        emit NewController(oldController, newController);
    }

    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {
        require(newBorrowCapFactorMantissa <= 1e18, 'Factor too large');
        uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;
        borrowCapFactorMantissa = newBorrowCapFactorMantissa;
        emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa);
    }

    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {
        //accrueInterest except first
        if (baseRatePerBlock != 0) {
            accrueInterest();
        }
        // total rate perYear < 2000%
        require(baseRatePerBlock_ < 1e13, 'Base rate too large');
        baseRatePerBlock = baseRatePerBlock_;
        require(multiplierPerBlock_ < 1e13, 'Mul rate too large');
        multiplierPerBlock = multiplierPerBlock_;
        require(jumpMultiplierPerBlock_ < 1e13, 'Jump rate too large');
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        require(kink_ <= 1e18, 'Kline too large');
        kink = kink_;
        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);
    }

    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {
        require(newReserveFactorMantissa <= 1e18, 'Factor too large');
        accrueInterest();
        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;
        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);
    }

    function addReserves(uint addAmount) external override nonReentrant {
        accrueInterest();
        uint totalReservesNew;
        uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);
        totalReservesNew = totalReserves.add(actualAddAmount);
        totalReserves = totalReservesNew;
        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);
    }

    function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {
        accrueInterest();
        uint totalReservesNew;
        totalReservesNew = totalReserves.sub(reduceAmount);
        totalReserves = totalReservesNew;
        doTransferOut(to, reduceAmount, true);
        emit ReservesReduced(to, reduceAmount, totalReservesNew);
    }

    modifier sameBlock() {
        require(accrualBlockNumber == getBlockNumber(), 'not same block');
        _;
    }
}

.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.7.6;


import "./LPoolInterface.sol";
import "./LPoolDepositor.sol";
import "../lib/Exponential.sol";
import "../Adminable.sol";
import "../lib/CarefulMath.sol";
import "../lib/TransferHelper.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import "../DelegateInterface.sol";
import "../ControllerInterface.sol";
import "../IWETH.sol";

/// @title OpenLeverage's LToken Contract
/// @dev Abstract base for LTokens
/// @author OpenLeverage
contract LPool is DelegateInterface, Adminable, LPoolInterface, Exponential, ReentrancyGuard {
    using TransferHelper for IERC20;
    using SafeMath for uint;

    constructor() {

    }
    
    /// @notice Initialize the money market
    /// @param controller_ The address of the Controller
    /// @param baseRatePerBlock_ The base interest rate which is the y-intercept when utilization rate is 0
    /// @param multiplierPerBlock_ The multiplier of utilization rate that gives the slope of the interest rate
    /// @param jumpMultiplierPerBlock_ The multiplierPerBlock after hitting a specified utilization point
    /// @param kink_ The utilization point at which the jump multiplier is applied
    /// @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
    /// @param name_ EIP-20 name of this token
    /// @param symbol_ EIP-20 symbol of this token
    /// @param decimals_ EIP-20 decimal precision of this token
    function initialize(
        address underlying_,
        bool isWethPool_,
        address controller_,
        uint256 baseRatePerBlock_,
        uint256 multiplierPerBlock_,
        uint256 jumpMultiplierPerBlock_,
        uint256 kink_,
        uint initialExchangeRateMantissa_,
        string memory name_,
        string memory symbol_,
        uint8 decimals_) public {
        require(underlying_ != address(0), "underlying_ address cannot be 0");
        require(controller_ != address(0), "controller_ address cannot be 0");
        require(msg.sender == admin, "Only allow to be called by admin");
        require(accrualBlockNumber == 0 && borrowIndex == 0, "inited once");

        // Set initial exchange rate
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        require(initialExchangeRateMantissa > 0, "Initial Exchange Rate Mantissa should be greater zero");
        //set controller
        controller = controller_;
        isWethPool = isWethPool_;
        //set interestRateModel
        baseRatePerBlock = baseRatePerBlock_;
        multiplierPerBlock = multiplierPerBlock_;
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        kink = kink_;

        // Initialize block number and borrow index (block number mocks depend on controller being set)
        accrualBlockNumber = getBlockNumber();
        borrowIndex = 1e25;
        //80%
        borrowCapFactorMantissa = 0.8e18;
        //10%
        reserveFactorMantissa = 0.1e18;


        name = name_;
        symbol = symbol_;
        decimals = decimals_;

        _notEntered = true;

        // Set underlying and sanity check it
        underlying = underlying_;
        IERC20(underlying).totalSupply();
        emit Transfer(address(0), msg.sender, 0);
    }

    /// @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
    /// @dev Called by both `transfer` and `transferFrom` internally
    /// @param spender The address of the account performing the transfer
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param tokens The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (bool) {
        require(dst != address(0), "dst address cannot be 0");
        /* Do not allow self-transfers */
        require(src != dst, "src = dst");
        /* Fail if transfer not allowed */
        (ControllerInterface(controller)).transferAllowed(src, dst, tokens);

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = uint(- 1);
        } else {
            startingAllowance = transferAllowances[src][spender];
        }

        /* Do the calculations, checking for {under,over}flow */
        MathError mathErr;
        uint allowanceNew;
        uint srcTokensNew;
        uint dstTokensNew;

        (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);
        require(mathErr == MathError.NO_ERROR, 'not allowed');

        (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);
        require(mathErr == MathError.NO_ERROR, 'not enough');

        (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);
        require(mathErr == MathError.NO_ERROR, 'too much');

        accountTokens[src] = srcTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != uint(- 1)) {
            transferAllowances[src][spender] = allowanceNew;
        }
        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);
        return true;
    }

    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transfer(address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount);
    }

    /// @notice Transfer `amount` tokens from `src` to `dst`
    /// @param src The address of the source account
    /// @param dst The address of the destination account
    /// @param amount The number of tokens to transfer
    /// @return Whether or not the transfer succeeded
    function transferFrom(address src, address dst, uint256 amount) external override nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount);
    }

    /// @notice Approve `spender` to transfer up to `amount` from `src`
    /// @dev This will overwrite the approval amount for `spender`
    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
    /// @param spender The address of the account which may transfer tokens
    /// @param amount The number of tokens that are approved (-1 means infinite)
    /// @return Whether or not the approval succeeded
    function approve(address spender, uint256 amount) external override returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /// @notice Get the current allowance from `owner` for `spender`
    /// @param owner The address of the account which owns the tokens to be spent
    /// @param spender The address of the account which may transfer tokens
    /// @return The number of tokens allowed to be spent (-1 means infinite)
    function allowance(address owner, address spender) external override view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /// @notice Get the token balance of the `owner`
    /// @param owner The address of the account to query
    /// @return The number of tokens owned by `owner`
    function balanceOf(address owner) external override view returns (uint256) {
        return accountTokens[owner];
    }

    /// @notice Get the underlying balance of the `owner`
    /// @dev This also accrues interest in a transaction
    /// @param owner The address of the account to query
    /// @return The amount of underlying owned by `owner`
    function balanceOfUnderlying(address owner) external override returns (uint) {
        Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});
        (MathError mErr, uint balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);
        require(mErr == MathError.NO_ERROR, "calc failed");
        return balance;
    }

    /*** User Interface ***/

    /// @notice Sender supplies assets into the market and receives lTokens in exchange
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param mintAmount The amount of the underlying asset to supply
    function mint(uint mintAmount) external override nonReentrant {
        accrueInterest();
        mintFresh(msg.sender, mintAmount, false);
    }

    function mintTo(address to, uint amount) external payable override nonReentrant {
        accrueInterest();
        if (isWethPool) {
            mintFresh(to, msg.value, false);
        } else {
            mintFresh(to, amount, true);
        }
    }

    function mintEth() external payable override nonReentrant {
        require(isWethPool, "not eth pool");
        accrueInterest();
        mintFresh(msg.sender, msg.value, false);
    }

    /// @notice Sender redeems lTokens in exchange for the underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemTokens The number of lTokens to redeem into underlying
    function redeem(uint redeemTokens) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, redeemTokens, 0);
    }

    /// @notice Sender redeems lTokens in exchange for a specified amount of underlying asset
    /// @dev Accrues interest whether or not the operation succeeds, unless reverted
    /// @param redeemAmount The amount of underlying to redeem
    function redeemUnderlying(uint redeemAmount) external override nonReentrant {
        accrueInterest();
        // redeemFresh emits redeem-specific logs on errors, so we don't need to
        redeemFresh(msg.sender, 0, redeemAmount);
    }

    function borrowBehalf(address borrower, uint borrowAmount) external override nonReentrant {
        accrueInterest();
        // borrowFresh emits borrow-specific logs on errors, so we don't need to
        borrowFresh(payable(borrower), msg.sender, borrowAmount);
    }

    /// @notice Sender repays a borrow belonging to borrower
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount The amount to repay
    function repayBorrowBehalf(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to
        repayBorrowFresh(msg.sender, borrower, repayAmount, false);
    }

    function repayBorrowEndByOpenLev(address borrower, uint repayAmount) external override nonReentrant {
        accrueInterest();
        repayBorrowFresh(msg.sender, borrower, repayAmount, true);
    }


    /*** Safe Token ***/

    /// Gets balance of this contract in terms of the underlying
    /// @dev This excludes the value of the current message, if any
    /// @return The quantity of underlying tokens owned by this contract
    function getCashPrior() internal view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }


    /**
     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.
     *      This will revert due to insufficient balance or insufficient allowance.
     *      This function returns the actual amount received,
     *      which may be less than `amount` if there is a fee attached to the transfer.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferIn(address from, uint amount, bool convertWeth) internal returns (uint actualAmount) {
        if (isWethPool && convertWeth) {
            actualAmount = msg.value;
            IWETH(underlying).deposit{value : actualAmount}();
        } else {
            actualAmount = IERC20(underlying).safeTransferFrom(from, address(this), amount);
        }
    }

    /**
     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory
     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to
     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified
     *      it is >= amount, this should not revert in normal conditions.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferOut(address payable to, uint amount, bool convertWeth) internal {
        if (isWethPool && convertWeth) {
            IWETH(underlying).withdraw(amount);
            to.transfer(amount);
        } else {
            IERC20(underlying).safeTransfer(to, amount);
        }
    }

    function availableForBorrow() external view override returns (uint){
        uint cash = getCashPrior();
        (MathError err0, uint sum) = addThenSubUInt(cash, totalBorrows, totalReserves);
        if (err0 != MathError.NO_ERROR) {
            return 0;
        }
        (MathError err1, uint maxAvailable) = mulScalarTruncate(Exp({mantissa : sum}), borrowCapFactorMantissa);
        if (err1 != MathError.NO_ERROR) {
            return 0;
        }
        if (totalBorrows > maxAvailable) {
            return 0;
        }
        return maxAvailable - totalBorrows;
    }


    /// @notice Get a snapshot of the account's balances, and the cached exchange rate
    /// @dev This is used by controller to more efficiently perform liquidity checks.
    /// @param account Address of the account to snapshot
    /// @return ( token balance, borrow balance, exchange rate mantissa)
    function getAccountSnapshot(address account) external override view returns (uint, uint, uint) {
        uint cTokenBalance = accountTokens[account];
        uint borrowBalance;
        uint exchangeRateMantissa;

        MathError mErr;

        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();
        if (mErr != MathError.NO_ERROR) {
            return (0, 0, 0);
        }

        return (cTokenBalance, borrowBalance, exchangeRateMantissa);
    }

    /// @dev Function to simply retrieve block number
    ///  This exists mainly for inheriting test contracts to stub this result.
    function getBlockNumber() internal view returns (uint) {
        return block.number;
    }

    /// @notice Returns the current per-block borrow interest rate for this cToken
    /// @return The borrow interest rate per block, scaled by 1e18
    function borrowRatePerBlock() external override view returns (uint) {
        return getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
    }

    
    /// @notice Returns the current per-block supply interest rate for this cToken
    /// @return The supply interest rate per block, scaled by 1e18
    function supplyRatePerBlock() external override view returns (uint) {
        return getSupplyRateInternal(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);
    }

    function utilizationRate(uint cash, uint borrows, uint reserves) internal pure returns (uint) {
        // Utilization rate is 0 when there are no borrows
        if (borrows == 0) {
            return 0;
        }
        return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));
    }

    /// @notice Calculates the current borrow rate per block, with the error code expected by the market
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The borrow rate percentage per block as a mantissa (scaled by 1e18)
    function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {
        uint util = utilizationRate(cash, borrows, reserves);
        if (util <= kink) {
            return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
        } else {
            uint normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);
            uint excessUtil = util.sub(kink);
            return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);
        }
    }

    /// @notice Calculates the current supply rate per block
    /// @param cash The amount of cash in the market
    /// @param borrows The amount of borrows in the market
    /// @return The supply rate percentage per block as a mantissa (scaled by 1e18)
    function getSupplyRateInternal(uint cash, uint borrows, uint reserves, uint reserveFactor) internal view returns (uint) {
        uint oneMinusReserveFactor = uint(1e18).sub(reserveFactor);
        uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);
        uint rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);
        return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);
    }

    /// @notice Returns the current total borrows plus accrued interest
    /// @return The total borrows with interest
    function totalBorrowsCurrent() external override view returns (uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return totalBorrows;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        return totalBorrowsNew;
    }

    /// @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex
    /// @param account The address whose balance should be calculated after updating borrowIndex
    /// @return The calculated balance
    function borrowBalanceCurrent(address account) external view override returns (uint) {
        (MathError err0, uint borrowIndex) = calCurrentBorrowIndex();
        require(err0 == MathError.NO_ERROR, "calc borrow index fail");
        (MathError err1, uint result) = borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
        require(err1 == MathError.NO_ERROR, "calc fail");
        return result;
    }

    function borrowBalanceStored(address account) external override view returns (uint){
        return accountBorrows[account].principal;
    }


    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
        return borrowBalanceStoredInternalWithBorrowerIndex(account, borrowIndex);
    }

    /// @notice Return the borrow balance of account based on stored data
    /// @param account The address whose balance should be calculated
    /// @return (error code, the calculated balance or 0 if error code is non-zero)
    function borrowBalanceStoredInternalWithBorrowerIndex(address account, uint borrowIndex) internal view returns (MathError, uint) {
        /* Note: we do not assert that the market is up to date */
        MathError mathErr;
        uint principalTimesIndex;
        uint result;

        /* Get borrowBalance and borrowIndex */
        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (borrowSnapshot.principal == 0) {
            return (MathError.NO_ERROR, 0);
        }

        /* Calculate new borrow balance using the interest index:
         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex
         */
        (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }

        return (MathError.NO_ERROR, result);
    }

    /// @notice Accrue interest then return the up-to-date exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateCurrent() public override nonReentrant returns (uint) {
        accrueInterest();
        return exchangeRateStored();
    }

    /// Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return Calculated exchange rate scaled by 1e18
    function exchangeRateStored() public override view returns (uint) {
        (MathError err, uint result) = exchangeRateStoredInternal();
        require(err == MathError.NO_ERROR, "calc fail");
        return result;
    }

    /// @notice Calculates the exchange rate from the underlying to the LToken
    /// @dev This function does not accrue interest before calculating the exchange rate
    /// @return (error code, calculated exchange rate scaled by 1e18)
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
        uint _totalSupply = totalSupply;
        if (_totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return (MathError.NO_ERROR, initialExchangeRateMantissa);
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
            uint _totalCash = getCashPrior();
            uint cashPlusBorrowsMinusReserves;
            Exp memory exchangeRate;
            MathError mathErr;

            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(_totalCash, totalBorrows, totalReserves);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);
            if (mathErr != MathError.NO_ERROR) {
                return (mathErr, 0);
            }

            return (MathError.NO_ERROR, exchangeRate.mantissa);
        }
    }

    /// @notice Get cash balance of this cToken in the underlying asset
    /// @return The quantity of underlying asset owned by this contract
    function getCash() external override view returns (uint) {
        return IERC20(underlying).balanceOf(address(this));
    }

    function calCurrentBorrowIndex() internal view returns (MathError, uint) {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;
        uint borrowIndexNew;
        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return (MathError.NO_ERROR, borrowIndex);
        }
        uint borrowRateMantissa = getBorrowRateInternal(getCashPrior(), totalBorrows, totalReserves);
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);

        Exp memory simpleInterestFactor;
        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        if (mathErr != MathError.NO_ERROR) {
            return (mathErr, 0);
        }
        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);
        return (mathErr, borrowIndexNew);
    }

    /// @notice Applies accrued interest to total borrows and reserves
    /// @dev This calculates interest accrued from the last checkpointed block
    ///   up to the current block and writes new checkpoint to storage.
    function accrueInterest() public override {
        /* Remember the initial block number */
        uint currentBlockNumber = getBlockNumber();
        uint accrualBlockNumberPrior = accrualBlockNumber;

        /* Short-circuit accumulating 0 interest */
        if (accrualBlockNumberPrior == currentBlockNumber) {
            return;
        }

        /* Read the previous values out of storage */
        uint cashPrior = getCashPrior();
        uint borrowsPrior = totalBorrows;
        uint borrowIndexPrior = borrowIndex;
        uint reservesPrior = totalReserves;

        /* Calculate the current borrow interest rate */
        uint borrowRateMantissa = getBorrowRateInternal(cashPrior, borrowsPrior, reservesPrior);
        require(borrowRateMantissa <= borrowRateMaxMantissa, "borrower rate higher");

        /* Calculate the number of blocks elapsed since the last accrual */
        (MathError mathErr, uint blockDelta) = subUInt(currentBlockNumber, accrualBlockNumberPrior);
        require(mathErr == MathError.NO_ERROR, "calc block delta erro");


        /*
         * Calculate the interest accumulated into borrows and reserves and the new index:
         *  simpleInterestFactor = borrowRate * blockDelta
         *  interestAccumulated = simpleInterestFactor * totalBorrows
         *  totalBorrowsNew = interestAccumulated + totalBorrows
         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex
         */

        Exp memory simpleInterestFactor;
        uint interestAccumulated;
        uint totalBorrowsNew;
        uint borrowIndexNew;
        uint totalReservesNew;

        (mathErr, simpleInterestFactor) = mulScalar(Exp({mantissa : borrowRateMantissa}), blockDelta);
        require(mathErr == MathError.NO_ERROR, 'calc interest factor error');

        (mathErr, interestAccumulated) = mulScalarTruncate(simpleInterestFactor, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc interest acc error');

        (mathErr, totalBorrowsNew) = addUInt(interestAccumulated, borrowsPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total borrows error');

        (mathErr, totalReservesNew) = mulScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);
        require(mathErr == MathError.NO_ERROR, 'calc total reserves error');

        (mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);
        require(mathErr == MathError.NO_ERROR, 'calc borrows index error');


        /* We write the previously calculated values into storage */
        accrualBlockNumber = currentBlockNumber;
        borrowIndex = borrowIndexNew;
        totalBorrows = totalBorrowsNew;
        totalReserves = totalReservesNew;

        /* We emit an AccrueInterest event */
        emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);

    }

    struct MintLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint mintTokens;
        uint totalSupplyNew;
        uint accountTokensNew;
        uint actualMintAmount;
    }

    /// @notice User supplies assets into the market and receives lTokens in exchange
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param minter The address of the account which is supplying the assets
    /// @param mintAmount The amount of the underlying asset to supply
    /// @return uint the actual mint amount.
    function mintFresh(address minter, uint mintAmount, bool isDelegete) internal sameBlock returns (uint) {
        MintLocalVars memory vars;
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /*
         *  We call `doTransferIn` for the minter and the mintAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if
         *  side-effects occurred. The function returns the amount actually transferred,
         *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`
         *  of cash.
         */
        if (isDelegete) {
            uint balanceBefore = getCashPrior();
            LPoolDepositor(msg.sender).transferToPool(minter, mintAmount);
            uint balanceAfter = getCashPrior();
            require(balanceAfter > balanceBefore, 'mint 0');
            vars.actualMintAmount = balanceAfter - balanceBefore;
        } else {
            vars.actualMintAmount = doTransferIn(minter, mintAmount, true);
        }
        /*
         * We get the current exchange rate and calculate the number of lTokens to be minted:
         *  mintTokens = actualMintAmount / exchangeRate
         */

        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa : vars.exchangeRateMantissa}));
        require(vars.mathErr == MathError.NO_ERROR, "calc mint token error");

        /* Fail if mint not allowed */
        (ControllerInterface(controller)).mintAllowed(minter, vars.mintTokens);
        /*
         * We calculate the new total supply of lTokens and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc supply new failed");

        (vars.mathErr, vars.accountTokensNew) = addUInt(accountTokens[minter], vars.mintTokens);
        require(vars.mathErr == MathError.NO_ERROR, "calc tokens new ailed");

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[minter] = vars.accountTokensNew;

        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, vars.actualMintAmount, vars.mintTokens);
        emit Transfer(address(this), minter, vars.mintTokens);

        /* We call the defense hook */

        return vars.actualMintAmount;
    }


    struct RedeemLocalVars {
        MathError mathErr;
        uint exchangeRateMantissa;
        uint redeemTokens;
        uint redeemAmount;
        uint totalSupplyNew;
        uint accountTokensNew;
    }

    /// @notice User redeems lTokens in exchange for the underlying asset
    /// @dev Assumes interest has already been accrued up to the current block
    /// @param redeemer The address of the account which is redeeming the tokens
    /// @param redeemTokensIn The number of lTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    /// @param redeemAmountIn The number of underlying tokens to receive from redeeming lTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal sameBlock {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, "one be zero");

        RedeemLocalVars memory vars;

        /* exchangeRate = invoke Exchange Rate Stored() */
        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, 'calc exchangerate error');

        /* If redeemTokensIn > 0: */
        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            vars.redeemTokens = redeemTokensIn;

            (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(Exp({mantissa : vars.exchangeRateMantissa}), redeemTokensIn);
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem amount error');
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */

            (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(redeemAmountIn, Exp({mantissa : vars.exchangeRateMantissa}));
            require(vars.mathErr == MathError.NO_ERROR, 'calc redeem tokens error');
            vars.redeemAmount = redeemAmountIn;
        }

        /* Fail if redeem not allowed */
        (ControllerInterface(controller)).redeemAllowed(redeemer, vars.redeemTokens);

        /*
         * We calculate the new total supply and redeemer balance, checking for underflow:
         *  totalSupplyNew = totalSupply - redeemTokens
         *  accountTokensNew = accountTokens[redeemer] - redeemTokens
         */
        (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc supply new error');

        (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);
        require(vars.mathErr == MathError.NO_ERROR, 'calc token new error');
        require(getCashPrior() >= vars.redeemAmount, 'cash < redeem');

        /* We write previously calculated values into storage */
        totalSupply = vars.totalSupplyNew;
        accountTokens[redeemer] = vars.accountTokensNew;
        /*
         * We invoke doTransferOut for the redeemer and the redeemAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken has redeemAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(redeemer, vars.redeemAmount, true);


        /* We emit a Transfer event, and a Redeem event */
        emit Transfer(redeemer, address(this), vars.redeemTokens);
        emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);

        /* We call the defense hook */
    }

    struct BorrowLocalVars {
        MathError mathErr;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
    }

    /// @notice Users borrow assets from the protocol to their own address
    /// @param borrowAmount The amount of the underlying asset to borrow
    function borrowFresh(address payable borrower, address payable payee, uint borrowAmount) internal sameBlock {
        /* Fail if borrow not allowed */
        (ControllerInterface(controller)).borrowAllowed(borrower, payee, borrowAmount);

        /* Fail gracefully if protocol has insufficient underlying cash */
        require(getCashPrior() >= borrowAmount, 'cash<borrow');

        BorrowLocalVars memory vars;

        /*
         * We calculate the new borrower and total borrow balances, failing on overflow:
         *  accountBorrowsNew = accountBorrows + borrowAmount
         *  totalBorrowsNew = totalBorrows + borrowAmount
         */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrows error');

        (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);
        require(vars.mathErr == MathError.NO_ERROR, 'calc total borrows error');

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /*
         * We invoke doTransferOut for the borrower and the borrowAmount.
         *  Note: The cToken must handle variations between ERC-20 and ETH underlying.
         *  On success, the cToken borrowAmount less of cash.
         *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
         */
        doTransferOut(payee, borrowAmount, false);

        /* We emit a Borrow event */
        emit Borrow(borrower, payee, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */
    }

    struct RepayBorrowLocalVars {
        MathError mathErr;
        uint repayAmount;
        uint borrowerIndex;
        uint accountBorrows;
        uint accountBorrowsNew;
        uint totalBorrowsNew;
        uint actualRepayAmount;
        uint badDebtsAmount;
    }

    /// @notice Borrows are repaid by another user (possibly the borrower).
    /// @param payer the account paying off the borrow
    /// @param borrower the account with the debt being payed off
    /// @param repayAmount the amount of undelrying tokens being returned
    function repayBorrowFresh(address payer, address borrower, uint repayAmount, bool isEnd) internal sameBlock returns (uint) {
        /* Fail if repayBorrow not allowed */
        (ControllerInterface(controller)).repayBorrowAllowed(payer, borrower, repayAmount, isEnd);

        RepayBorrowLocalVars memory vars;

        /* We remember the original borrowerIndex for verification purposes */
        vars.borrowerIndex = accountBorrows[borrower].interestIndex;

        /* We fetch the amount the borrower owes, with accumulated interest */
        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);
        require(vars.mathErr == MathError.NO_ERROR, 'calc acc borrow error');

        /* If repayAmount == -1, repayAmount = accountBorrows */
        if (repayAmount == uint(- 1)) {
            vars.repayAmount = vars.accountBorrows;
        } else {
            vars.repayAmount = repayAmount;
        }
        vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount, false);


        if (isEnd && vars.accountBorrows > vars.actualRepayAmount) {
            vars.badDebtsAmount = vars.accountBorrows - vars.actualRepayAmount;
        }

        /*
        *  We calculate the new borrower and total borrow balances, failing on underflow:
        *  accountBorrowsNew = accountBorrows - repayAmount
        *  totalBorrowsNew = totalBorrows - repayAmount
        */
        if (vars.accountBorrows < vars.actualRepayAmount) {
            require(vars.actualRepayAmount.mul(1e18).div(vars.accountBorrows) <= 105e16, 'repay more than 5%');
            vars.accountBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.accountBorrowsNew = 0;
            } else {
                vars.accountBorrowsNew = vars.accountBorrows - vars.actualRepayAmount;
            }
        }
        //Avoid mantissa errors
        if (vars.actualRepayAmount > totalBorrows) {
            vars.totalBorrowsNew = 0;
        } else {
            if (isEnd) {
                vars.totalBorrowsNew = totalBorrows.sub(vars.accountBorrows);
            } else {
                vars.totalBorrowsNew = totalBorrows - vars.actualRepayAmount;
            }
        }

        /* We write the previously calculated values into storage */
        accountBorrows[borrower].principal = vars.accountBorrowsNew;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows = vars.totalBorrowsNew;

        /* We emit a RepayBorrow event */
        emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.badDebtsAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);

        /* We call the defense hook */

        return vars.actualRepayAmount;
    }

    /*** Admin Functions ***/

    /// @notice Sets a new CONTROLLER for the market
    /// @dev Admin function to set a new controller
    function setController(address newController) external override onlyAdmin {
        require(address(0) != newController, "0x");
        address oldController = controller;
        controller = newController;
        // Emit NewController(oldController, newController)
        emit NewController(oldController, newController);
    }

    function setBorrowCapFactorMantissa(uint newBorrowCapFactorMantissa) external override onlyAdmin {
        require(newBorrowCapFactorMantissa <= 1e18, 'Factor too large');
        uint oldBorrowCapFactorMantissa = borrowCapFactorMantissa;
        borrowCapFactorMantissa = newBorrowCapFactorMantissa;
        emit NewBorrowCapFactorMantissa(oldBorrowCapFactorMantissa, borrowCapFactorMantissa);
    }

    function setInterestParams(uint baseRatePerBlock_, uint multiplierPerBlock_, uint jumpMultiplierPerBlock_, uint kink_) external override onlyAdmin {
        //accrueInterest except first
        if (baseRatePerBlock != 0) {
            accrueInterest();
        }
        // total rate perYear < 2000%
        require(baseRatePerBlock_ < 1e13, 'Base rate too large');
        baseRatePerBlock = baseRatePerBlock_;
        require(multiplierPerBlock_ < 1e13, 'Mul rate too large');
        multiplierPerBlock = multiplierPerBlock_;
        require(jumpMultiplierPerBlock_ < 1e13, 'Jump rate too large');
        jumpMultiplierPerBlock = jumpMultiplierPerBlock_;
        require(kink_ <= 1e18, 'Kline too large');
        kink = kink_;
        emit NewInterestParam(baseRatePerBlock_, multiplierPerBlock_, jumpMultiplierPerBlock_, kink_);
    }

    function setReserveFactor(uint newReserveFactorMantissa) external override onlyAdmin {
        require(newReserveFactorMantissa <= 1e18, 'Factor too large');
        accrueInterest();
        uint oldReserveFactorMantissa = reserveFactorMantissa;
        reserveFactorMantissa = newReserveFactorMantissa;
        emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);
    }

    function addReserves(uint addAmount) external override nonReentrant {
        accrueInterest();
        uint totalReservesNew;
        uint actualAddAmount = doTransferIn(msg.sender, addAmount, true);
        totalReservesNew = totalReserves.add(actualAddAmount);
        totalReserves = totalReservesNew;
        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);
    }

    function reduceReserves(address payable to, uint reduceAmount) external override nonReentrant onlyAdmin {
        accrueInterest();
        uint totalReservesNew;
        totalReservesNew = totalReserves.sub(reduceAmount);
        totalReserves = totalReservesNew;
        doTransferOut(to, reduceAmount, true);
        emit ReservesReduced(to, reduceAmount, totalReservesNew);
    }

    modifier sameBlock() {
        require(accrualBlockNumber == getBlockNumber(), 'not same block');
        _;
    }
}

".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

