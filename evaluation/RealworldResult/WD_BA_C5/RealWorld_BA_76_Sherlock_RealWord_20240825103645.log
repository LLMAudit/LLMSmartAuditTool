[2024-25-08 10:36:47 INFO] **[Preprocessing]**

**ChatDev Starts** (20240825103645)

**Timestamp**: 20240825103645

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';

import './interfaces/ISherlock.sol';

/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions

contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;

  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;

  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;

  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;

  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%

  // USDC address
  IERC20 public immutable token;

  // SHER token address
  IERC20 public immutable sher;

  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;

  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;

  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;

  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;

  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;

  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;

  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;

  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;

  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;

  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;

  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();

    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;

    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }

    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }

  //
  // View functions
  //

  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return lockupEnd_[_tokenID];
  }

  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return sherRewards_[_tokenID];
  }

  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }

  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }

  //
  // Gov functions
  //

  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }

  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }

  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();

    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }

  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();

    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }

  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();

    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }

  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();

    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }

  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();

    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }

  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();

    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }

    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }

  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }

  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    yieldStrategy.withdraw(_amount);
  }

  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }

  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }

  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }

  //
  // Access control functions
  //

  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];

    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }

  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();

    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }

  //
  // Non-access control functions
  //

  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;

    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;

    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));

    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);

    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }

  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }

  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;

    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }

  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();

    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));

    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }

    token.safeTransfer(_receiver, _amount);
  }

  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);

    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }

  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);

    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);

    emit Restaked(_id);
  }

  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;

    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);

    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;

    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;

    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);

    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }

  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);

    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);

    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);

    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }

  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }

  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;

    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);

    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;

    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;

    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];

    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }

  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }

  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);

    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();

    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);

    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);

    emit ArbRestaked(_id, _arbReward);
  }
}


**project_name**: RealWorld_BA_76_Sherlock

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_76_Sherlock_RealWord_20240825103645.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-25-08 10:36:47 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@openzeppelin/contracts/token/ERC721/ERC721.sol'; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol'; import '@openzeppelin/contracts/security/Pausable.sol'; import './interfaces/ISherlock.sol'; /// @title Sherlock core interface for stakers /// @author Evert Kors // This is the contract that manages staking actions contract Sherlock is ISherlock, ERC721, Ownable, Pausable {   using SafeERC20 for IERC20; // The initial period for a staker to restake/withdraw without being auto-restaked   uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks; // The period during which the reward for restaking an account (after the inital period) grows   uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks; // Anyone who gets auto-restaked is restaked for this period (3 months)   uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks; // The percentage of someone's stake that can be paid to an arb for restaking   uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20% // USDC address   IERC20 public immutable token; // SHER token address   IERC20 public immutable sher; // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not   mapping(uint256 =&gt; bool) public override stakingPeriods; // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked   mapping(uint256 =&gt; uint256) internal lockupEnd_; // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position   mapping(uint256 =&gt; uint256) internal sherRewards_; // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)   mapping(uint256 =&gt; uint256) internal stakeShares; // Key is account, value is the sum of underlying shares of all the NFTs the account owns.   mapping(address =&gt; uint256) internal addressShares; // Total amount of shares that have been issued to all NFT positions   uint256 internal totalStakeShares; // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)   IStrategyManager public override yieldStrategy; // Instances of relevant Sherlock contracts   ISherDistributionManager public override sherDistributionManager;   ISherlockProtocolManager public override sherlockProtocolManager;   ISherlockClaimManager public override sherlockClaimManager; // Address to which nonstaker payments are made   // This will start out as a multi-sig address, then become a contract address later   address public override nonStakersAddress; // Stores the ID of the most recently created NFT   // This variable is incremented by 1 to create a new NFT ID   uint256 internal nftCounter; // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.   constructor(     IERC20 _token, // USDC address     IERC20 _sher, // SHER token address     string memory _name, // Token collection name (see ERC-721 docs)     string memory _symbol, // Token collection symbol (see ERC-721 docs)     IStrategyManager _yieldStrategy, // The active yield strategy contract     ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract     address _nonStakersAddress, // The address to which nonstakers payments go     ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract     ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract     uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for   ) ERC721(_name, _symbol) {     if (address(_token) == address(0)) revert ZeroArgument();     if (address(_sher) == address(0)) revert ZeroArgument();     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (_nonStakersAddress == address(0)) revert ZeroArgument();     if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();     if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument(); token = _token; sher = _sher; yieldStrategy = _yieldStrategy; sherDistributionManager = _sherDistributionManager; nonStakersAddress = _nonStakersAddress; sherlockProtocolManager = _sherlockProtocolManager; sherlockClaimManager = _sherlockClaimManager;  // Enabling the first set of staking periods that were provided in constructor args for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {   enableStakingPeriod(_initialstakingPeriods[i]); }  emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy); emit SherDistributionManagerUpdated(   ISherDistributionManager(address(0)),   _sherDistributionManager ); emit NonStakerAddressUpdated(address(0), _nonStakersAddress); emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager); emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);  } //   // View functions   // // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked   /// @notice View the current lockup end timestamp of _tokenID   /// @return Timestamp when NFT position unlocks   function lockupEnd(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return lockupEnd_[_tokenID];  } // Returns the SHER rewards owed to this position   /// @notice View the current SHER reward of _tokenID   /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup   function sherRewards(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return sherRewards_[_tokenID];  } // Returns the tokens (USDC) owed to a position   /// @notice View the current token balance claimable upon reaching end of the lockup   /// @return Amount of tokens assigned to owner when unstaking position   function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent();     // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers     return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;   } // Returns the tokens (USDC) owed to an address   /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup   /// @return Amount of tokens assigned to owner when unstaking all positions   function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {     if (_staker == address(0)) revert ZeroArgument();     uint256 _totalStakeShares = totalStakeShares;     if (_totalStakeShares == 0) return 0;     // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers     return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;   } // Gets the total amount of tokens (USDC) owed to stakers   // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract   /// @notice View the current TVL for all stakers   /// @return Total amount of tokens staked   /// @dev Adds principal + strategy + premiums   /// @dev Will calculate the most up to date value for each piece   function totalTokenBalanceStakers() public view override returns (uint256) {     return       token.balanceOf(address(this)) +       yieldStrategy.balanceOf() +       sherlockProtocolManager.claimablePremiums();   } //   // Gov functions   // // Allows governance to add a new staking period (4 months, etc.)   /// @notice Allows stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already enabled   function enableStakingPeriod(uint256 _period) public override onlyOwner {     if (_period == 0) revert ZeroArgument();     // Revert if staking period is already active     if (stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to true stakingPeriods[_period] = true; emit StakingPeriodEnabled(_period);  } // Allows governance to remove a staking period (4 months, etc.)   /// @notice Disallow stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already disabled   function disableStakingPeriod(uint256 _period) external override onlyOwner {     // Revert if staking period is already inactive     if (!stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to false stakingPeriods[_period] = false; emit StakingPeriodDisabled(_period);  } // Sets a new contract to be the active SHER distribution manager   /// @notice Update SHER distribution manager contract   /// @param _sherDistributionManager New adddress of the manager   function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)     external     override     onlyOwner   {     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument(); emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager); sherDistributionManager = _sherDistributionManager;  } // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)   /// @notice Remove SHER token rewards   function removeSherDistributionManager() external override onlyOwner {     if (address(sherDistributionManager) == address(0)) revert InvalidConditions(); emit SherDistributionManagerUpdated(   sherDistributionManager,   ISherDistributionManager(address(0)) ); delete sherDistributionManager;  } // Sets a new address for nonstakers payments   /// @notice Update address eligble for non staker rewards from protocol premiums   /// @param _nonStakers Address eligble for non staker rewards   function updateNonStakersAddress(address _nonStakers) external override onlyOwner {     if (address(_nonStakers) == address(0)) revert ZeroArgument();     if (nonStakersAddress == _nonStakers) revert InvalidArgument(); emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers); nonStakersAddress = _nonStakers;  } // Sets a new protocol manager contract   /// @notice Transfer protocol manager implementation address   /// @param _protocolManager new implementation address   function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)     external     override     onlyOwner   {     if (address(_protocolManager) == address(0)) revert ZeroArgument();     if (sherlockProtocolManager == _protocolManager) revert InvalidArgument(); emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager); sherlockProtocolManager = _protocolManager;  } // Sets a new claim manager contract   /// @notice Transfer claim manager role to different address   /// @param _claimManager New address of claim manager   function updateSherlockClaimManager(ISherlockClaimManager _claimManager)     external     override     onlyOwner   {     if (address(_claimManager) == address(0)) revert ZeroArgument();     if (sherlockClaimManager == _claimManager) revert InvalidArgument(); emit ClaimManagerUpdated(sherlockClaimManager, _claimManager); sherlockClaimManager = _claimManager;  } // Sets a new yield strategy manager contract   /// @notice Update yield strategy   /// @param _yieldStrategy News address of the strategy   /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure   function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (yieldStrategy == _yieldStrategy) revert InvalidArgument(); // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason. // In case this happens. We still want the yield strategy to be updated. // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again. try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {   emit YieldStrategyUpdateWithdrawAllError(reason); }  emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy); yieldStrategy = _yieldStrategy;  } // Deposits a chosen amount of tokens (USDC) into the active yield strategy   /// @notice Deposit _amount into active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); // Transfers any tokens owed to stakers from the protocol manager contract to this contract first sherlockProtocolManager.claimPremiumsForStakers(); // Transfers the amount of tokens to the yield strategy contract token.safeTransfer(address(yieldStrategy), _amount); // Deposits all tokens in the yield strategy contract into the actual yield strategy yieldStrategy.deposit();  } // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract   /// @notice Withdraw _amount from active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); yieldStrategy.withdraw(_amount);  } // Withdraws all tokens from the yield strategy back into this contract   /// @notice Withdraw all funds from active strategy   /// @dev gov only   function yieldStrategyWithdrawAll() external override onlyOwner {     yieldStrategy.withdrawAll();   } /// @notice Pause external functions in all contracts   /// @dev A manager can be replaced with the new contract in a paused state   /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused   function pause() external onlyOwner {     _pause();     if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();     // sherDistributionManager can be 0, pause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       !Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.pause();     }     if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();     if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();   } /// @notice Unpause external functions in all contracts   /// @dev A manager can be replaced with the new contract in an unpaused state   /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused   function unpause() external onlyOwner {     _unpause();     if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();     // sherDistributionManager can be 0, unpause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.unpause();     }     if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();     if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();   } //   // Access control functions   // /// @notice Account sum of all underlying posiiton shares for _from and _to   /// @dev this enables the tokenBalanceOfAddress to exist   function _beforeTokenTransfer(     address _from,     address _to,     uint256 _tokenID   ) internal override {     uint256 _stakeShares = stakeShares[_tokenID]; if (_from != address(0)) addressShares[_from] -= _stakeShares; if (_to != address(0)) addressShares[_to] += _stakeShares;  } // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)   // This function is called by the Sherlock claim manager contract if a claim is approved   /// @notice Initiate a payout of _amount to _receiver   /// @param _receiver Receiver of payout   /// @param _amount Amount to send   /// @dev only payout manager should call this   /// @dev should pull money out of strategy   function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {     // Can only be called by the Sherlock claim manager contract     if (msg.sender != address(sherlockClaimManager)) revert Unauthorized(); if (_amount != 0) {   // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)   _transferTokensOut(_receiver, _amount); } emit ClaimPayout(_receiver, _amount);  } //   // Non-access control functions   // // Helper function for initial staking and restaking   // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position   /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds   /// @param amount Amount of tokens to stake   /// @param _period Period of time for which funds get locked   /// @param _id ID for this NFT position   /// @param _receiver Address that will be linked to this position   /// @return _sher Amount of SHER tokens awarded to this position after _period ends   /// @dev _period needs to be whitelisted   function _stake(     uint256 _amount,     uint256 _period,     uint256 _id,     address _receiver   ) internal returns (uint256 _sher) {     // Sets the timestamp at which this position can first be unstaked/restaked     lockupEnd[_id] = block.timestamp + _period; if (address(sherDistributionManager) == address(0)) return 0; // Does not allow restaking of 0 tokens if (_amount == 0) return 0;  // Checks this amount of SHER tokens in this contract before we transfer new ones uint256 before = sher.balanceOf(address(this));  // pullReward() calcs then actually transfers the SHER tokens to this contract // in case this call fails, whole (re)staking transaction fails _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);  // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position uint256 actualAmount = sher.balanceOf(address(this)) - before; if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount); // Assigns the newly created SHER tokens to the current stake position if (_sher != 0) sherRewards_[_id] = _sher;  } // Checks to see if the NFT owner is the caller and that the position is unlockable   function verifyUnlockableByOwner(uint256 _id) internal view {     if (ownerOf(_id) != msg.sender) revert Unauthorized();     if (lockupEnd[_id] &gt; block.timestamp) revert InvalidConditions();   } // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner   function sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards[_id];     if (sherReward == 0) return; // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner sher.safeTransfer(_nftOwner, sherReward); // Deletes the SHER reward mapping for this NFT ID delete sherRewards_[_id];  } // Transfers an amount of tokens to the receiver address   // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)   function _transferTokensOut(address _receiver, uint256 _amount) internal {     // Transfers any premiums owed to stakers from the protocol manager to this contract     sherlockProtocolManager.claimPremiumsForStakers(); // The amount of tokens in this contract uint256 mainBalance = token.balanceOf(address(this));  // If the amount to transfer out is still greater than the amount of tokens in this contract, // Withdraw yield strategy tokens to make up the difference if (_amount &gt; mainBalance) {   yieldStrategy.withdraw(_amount - mainBalance); }  token.safeTransfer(_receiver, _amount);  } // Returns the amount of USDC owed to this amount of stakeShares   function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {     // Finds fraction that the given amount of stakeShares represents of the total     // Then multiplies it by the total amount of tokens (USDC) owed to all stakers     return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;   } // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted   // Also burns the requisite amount of shares associated with this NFT position   // Returns the amount of USDC owed to these shares   function _redeemShares(     uint256 _id,     uint256 _stakeShares,     address _receiver   ) internal returns (uint256 _amount) {     // Returns the amount of USDC owed to this amount of stakeShares     _amount = _redeemSharesCalc(_stakeShares);     // Transfers _amount of tokens to _receiver address     if (_amount != 0) _transferTokensOut(_receiver, _amount); // Subtracts this amount of stakeShares from the NFT position stakeShares[_id] -= _stakeShares; // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding totalStakeShares -= _stakeShares;  } // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager   // Restakes an NFT position (_id) for a given period (_period) and   // Sends any previously earned SHER rewards to the _nftOwner address   function _restake(     uint256 _id,     uint256 _period,     address _nftOwner   ) internal returns (uint256 _sher) {     // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner     // NOTE This function deletes the SHER reward mapping for this NFT ID     _sendSherRewardsToOwner(_id, _nftOwner); // tokenBalanceOf() returns the USDC amount owed to this NFT ID // _stake() restakes that amount of USDC for the period inputted // We use the same ID that we just deleted the SHER rewards mapping for // Resets the lockupEnd mapping and SHER token rewards mapping for this ID // Note stakeShares for this position do not change so no need to update _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);  emit Restaked(_id);  } // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)   /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt   /// @param _amount Amount of tokens to stake   /// @param _period Period of time, in seconds, to lockup your funds   /// @param _receiver Address that will receive the NFT representing the position   /// @return _id ID of the position   /// @return _sher Amount of SHER tokens to be released to this ID after _period ends   /// @dev _period needs to be whitelisted   function initialStake(     uint256 _amount,     uint256 _period,     address _receiver   ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {     if (_amount == 0) revert ZeroArgument();     // Makes sure the period is a whitelisted period     if (!stakingPeriods[_period]) revert InvalidArgument();     if (address(_receiver) == address(0)) revert ZeroArgument();     // Adds 1 to the ID of the last NFT created for the new NFT ID     _id = ++nftCounter; // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action) token.safeTransferFrom(msg.sender, address(this), _amount);  uint256 stakeShares_; uint256 totalStakeShares_ = totalStakeShares; // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares if (totalStakeShares_ != 0)   stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);   // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked else stakeShares_ = _amount;  // Assigns this NFT ID the calc'd amount of stake shares above stakeShares[_id] = stakeShares_; // Adds the newly created stake shares to the total amount of stake shares totalStakeShares += stakeShares_;  // Locks up the USDC amount and calcs the SHER token amount to receive on unstake _sher = _stake(_amount, _period, _id, _receiver);  // This is an ERC-721 function that creates an NFT and sends it to the receiver _safeMint(_receiver, _id);  } // This is how a staker unstakes and cashes out on their position   /// @notice Redeem NFT _id and receive _amount of tokens   /// @param _id TokenID of the position   /// @return _amount Amount of tokens (USDC) owed to NFT ID   /// @dev Only the owner of _id will be able to redeem their position   /// @dev The SHER rewards are sent to the NFT owner   /// @dev Can only be called after lockup _period has ended   function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // This is the ERC-721 function to destroy an NFT (with owner's approval) _burn(_id);  // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC owed to these shares _amount = _redeemShares(_id, stakeShares[_id], msg.sender);  // Sends the SHER tokens associated with this NFT ID to the NFT owner _sendSherRewardsToOwner(_id, msg.sender);  // Removes the unlock deadline associated with this NFT delete lockupEnd_[_id];  } // This is how a staker restakes an expired position   /// @notice Owner restakes position with ID: _id for _period seconds   /// @param _id ID of the position   /// @param _period Period of time, in seconds, to lockup your funds   /// @return _sher Amount of SHER tokens to be released to owner address after _period ends   /// @dev Only the owner of _id will be able to restake their position using this call   /// @dev _period needs to be whitelisted   /// @dev Can only be called after lockup _period has ended   function ownerRestake(uint256 _id, uint256 _period)     external     override     whenNotPaused     returns (uint256 _sher)   {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // Checks to make sure the staking period is a whitelisted one if (!stakingPeriods[_period]) revert InvalidArgument();  // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position _sher = _restake(_id, _period, msg.sender);  } // Calcs the reward (in stake shares) an arb would get for restaking a position   // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb   function calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {     // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)     uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME; // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position if (initialArbTime &gt; block.timestamp) return (0, false);  // The max rewards (as a % of the position's shares) for the arb are available at this timestamp uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;  // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100% uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;  // Scaled by 10**18 // Represents the max amount of stake shares that an arb could get from restaking this position uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];  // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled return (   ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,   true );  } /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position   /// @return profit How much profit an arb would make in USDC   /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)   function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {     // Returns the stake shares that an arb would get, and whether the position can currently be arbed     // profit variable is used to store the amount of shares     (profit, able) = _calcSharesForArbRestake(_id);     // Calculates the tokens (USDC) represented by that amount of stake shares     // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit     profit = _redeemSharesCalc(profit);   } /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)   /// @param _id ID of the position   /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup   /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function   /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)   /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)   /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)   function arbRestake(uint256 _id)     external     override     whenNotPaused     returns (uint256 _sher, uint256 _arbReward)   {     address nftOwner = ownerOf(_id); // Returns the stake shares that an arb would get, and whether the position can currently be arbed (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id); // Revert if not able to be arbed if (!able) revert InvalidConditions();  // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC paid to the arbitrager _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);  // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months) // Sends previously earned SHER rewards to the NFT owner address _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);  emit ArbRestaked(_id, _arbReward);  } } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/***********\\n Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x)\n Sherlock Protocol: https://sherlock.xyz\n/***********/\n\nimport \'@openzeppelin/contracts/token/ERC20/IERC20.sol\';\nimport \'@openzeppelin/contracts/token/ERC721/ERC721.sol\';\nimport \'@openzeppelin/contracts/access/Ownable.sol\';\nimport \'@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\';\nimport \'@openzeppelin/contracts/security/Pausable.sol\';\n\nimport \'./interfaces/ISherlock.sol\';\n\n/// @title Sherlock core interface for stakers\n/// @author Evert Kors\n// This is the contract that manages staking actions\n\ncontract Sherlock is ISherlock, ERC721, Ownable, Pausable {\n  using SafeERC20 for IERC20;\n\n  // The initial period for a staker to restake/withdraw without being auto-restaked\n  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;\n\n  // The period during which the reward for restaking an account (after the inital period) grows\n  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;\n\n  // Anyone who gets auto-restaked is restaked for this period (3 months)\n  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;\n\n  // The percentage of someone\'s stake that can be paid to an arb for restaking\n  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (1018 / 100) * 20; // 20%\n\n  // USDC address\n  IERC20 public immutable token;\n\n  // SHER token address\n  IERC20 public immutable sher;\n\n  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not\n  mapping(uint256 =&gt; bool) public override stakingPeriods;\n\n  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked\n  mapping(uint256 =&gt; uint256) internal lockupEnd_;\n\n  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position\n  mapping(uint256 =&gt; uint256) internal sherRewards_;\n\n  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)\n  mapping(uint256 =&gt; uint256) internal stakeShares;\n\n  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.\n  mapping(address =&gt; uint256) internal addressShares;\n\n  // Total amount of shares that have been issued to all NFT positions\n  uint256 internal totalStakeShares;\n\n  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)\n  IStrategyManager public override yieldStrategy;\n\n  // Instances of relevant Sherlock contracts\n  ISherDistributionManager public override sherDistributionManager;\n  ISherlockProtocolManager public override sherlockProtocolManager;\n  ISherlockClaimManager public override sherlockClaimManager;\n\n  // Address to which nonstaker payments are made\n  // This will start out as a multi-sig address, then become a contract address later\n  address public override nonStakersAddress;\n\n  // Stores the ID of the most recently created NFT\n  // This variable is incremented by 1 to create a new NFT ID\n  uint256 internal nftCounter;\n\n  // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.\n  constructor(\n    IERC20 token, // USDC address\n    IERC20 _sher, // SHER token address\n    string memory _name, // Token collection name (see ERC-721 docs)\n    string memory _symbol, // Token collection symbol (see ERC-721 docs)\n    IStrategyManager _yieldStrategy, // The active yield strategy contract\n    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract\n    address _nonStakersAddress, // The address to which nonstakers payments go\n    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract\n    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract\n    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for\n  ) ERC721(_name, _symbol) {\n    if (address(_token) == address(0)) revert ZeroArgument();\n    if (address(_sher) == address(0)) revert ZeroArgument();\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();\n    if (_nonStakersAddress == address(0)) revert ZeroArgument();\n    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();\n    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();\n\n    token = _token;\n    sher = _sher;\n    yieldStrategy = _yieldStrategy;\n    sherDistributionManager = _sherDistributionManager;\n    nonStakersAddress = _nonStakersAddress;\n    sherlockProtocolManager = _sherlockProtocolManager;\n    sherlockClaimManager = _sherlockClaimManager;\n\n    // Enabling the first set of staking periods that were provided in constructor args\n    for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {\n      enableStakingPeriod(_initialstakingPeriods[i]);\n    }\n\n    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);\n    emit SherDistributionManagerUpdated(\n      ISherDistributionManager(address(0)),\n      _sherDistributionManager\n    );\n    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);\n    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);\n    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);\n  }\n\n  //\n  // View functions\n  //\n\n  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked\n  /// @notice View the current lockup end timestamp of _tokenID\n  /// @return Timestamp when NFT position unlocks\n  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n\n    return lockupEnd[tokenID];\n  }\n\n  // Returns the SHER rewards owed to this position\n  /// @notice View the current SHER reward of _tokenID\n  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup\n  function sherRewards(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n\n    return sherRewards[tokenID];\n  }\n\n  // Returns the tokens (USDC) owed to a position\n  /// @notice View the current token balance claimable upon reaching end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking position\n  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers\n    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;\n  }\n\n  // Returns the tokens (USDC) owed to an address\n  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking all positions\n  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {\n    if (_staker == address(0)) revert ZeroArgument();\n    uint256 _totalStakeShares = totalStakeShares;\n    if (_totalStakeShares == 0) return 0;\n    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers\n    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;\n  }\n\n  // Gets the total amount of tokens (USDC) owed to stakers\n  // Adds this contract\'s balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract\n  /// @notice View the current TVL for all stakers\n  /// @return Total amount of tokens staked\n  /// @dev Adds principal + strategy + premiums\n  /// @dev Will calculate the most up to date value for each piece\n  function totalTokenBalanceStakers() public view override returns (uint256) {\n    return\n      token.balanceOf(address(this)) +\n      yieldStrategy.balanceOf() +\n      sherlockProtocolManager.claimablePremiums();\n  }\n\n  //\n  // Gov functions\n  //\n\n  // Allows governance to add a new staking period (4 months, etc.)\n  /// @notice Allows stakers to stake for _period of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already enabled\n  function enableStakingPeriod(uint256 _period) public override onlyOwner {\n    if (_period == 0) revert ZeroArgument();\n    // Revert if staking period is already active\n    if (stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sets the staking period to true\n    stakingPeriods[_period] = true;\n    emit StakingPeriodEnabled(_period);\n  }\n\n  // Allows governance to remove a staking period (4 months, etc.)\n  /// @notice Disallow stakers to stake for _period of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already disabled\n  function disableStakingPeriod(uint256 _period) external override onlyOwner {\n    // Revert if staking period is already inactive\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sets the staking period to false\n    stakingPeriods[_period] = false;\n    emit StakingPeriodDisabled(_period);\n  }\n\n  // Sets a new contract to be the active SHER distribution manager\n  /// @notice Update SHER distribution manager contract\n  /// @param _sherDistributionManager New adddress of the manager\n  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();\n    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();\n\n    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);\n    sherDistributionManager = _sherDistributionManager;\n  }\n\n  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)\n  /// @notice Remove SHER token rewards\n  function removeSherDistributionManager() external override onlyOwner {\n    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();\n\n    emit SherDistributionManagerUpdated(\n      sherDistributionManager,\n      ISherDistributionManager(address(0))\n    );\n    delete sherDistributionManager;\n  }\n\n  // Sets a new address for nonstakers payments\n  /// @notice Update address eligble for non staker rewards from protocol premiums\n  /// @param _nonStakers Address eligble for non staker rewards\n  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {\n    if (address(_nonStakers) == address(0)) revert ZeroArgument();\n    if (nonStakersAddress == _nonStakers) revert InvalidArgument();\n\n    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);\n    nonStakersAddress = _nonStakers;\n  }\n\n  // Sets a new protocol manager contract\n  /// @notice Transfer protocol manager implementation address\n  /// @param _protocolManager new implementation address\n  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_protocolManager) == address(0)) revert ZeroArgument();\n    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();\n\n    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);\n    sherlockProtocolManager = _protocolManager;\n  }\n\n  // Sets a new claim manager contract\n  /// @notice Transfer claim manager role to different address\n  /// @param _claimManager New address of claim manager\n  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_claimManager) == address(0)) revert ZeroArgument();\n    if (sherlockClaimManager == _claimManager) revert InvalidArgument();\n\n    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);\n    sherlockClaimManager = _claimManager;\n  }\n\n  // Sets a new yield strategy manager contract\n  /// @notice Update yield strategy\n  /// @param _yieldStrategy News address of the strategy\n  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure\n  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();\n\n    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail\n    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.\n    // In case this happens. We still want the yield strategy to be updated.\n    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.\n    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {\n      emit YieldStrategyUpdateWithdrawAllError(reason);\n    }\n\n    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);\n    yieldStrategy = _yieldStrategy;\n  }\n\n  // Deposits a chosen amount of tokens (USDC) into the active yield strategy\n  /// @notice Deposit _amount into active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {\n    if (_amount == 0) revert ZeroArgument();\n\n    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first\n    sherlockProtocolManager.claimPremiumsForStakers();\n    // Transfers the amount of tokens to the yield strategy contract\n    token.safeTransfer(address(yieldStrategy), _amount);\n    // Deposits all tokens in the yield strategy contract into the actual yield strategy\n    yieldStrategy.deposit();\n  }\n\n  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract\n  /// @notice Withdraw _amount from active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {\n    if (_amount == 0) revert ZeroArgument();\n\n    yieldStrategy.withdraw(_amount);\n  }\n\n  // Withdraws all tokens from the yield strategy back into this contract\n  /// @notice Withdraw all funds from active strategy\n  /// @dev gov only\n  function yieldStrategyWithdrawAll() external override onlyOwner {\n    yieldStrategy.withdrawAll();\n  }\n\n  /// @notice Pause external functions in all contracts\n  /// @dev A manager can be replaced with the new contract in a paused state\n  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused\n  function pause() external onlyOwner {\n    _pause();\n    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();\n    // sherDistributionManager can be 0, pause isn\'t needed in that case\n    if (\n      address(sherDistributionManager) != address(0) &amp;&amp;\n      !Pausable(address(sherDistributionManager)).paused()\n    ) {\n      sherDistributionManager.pause();\n    }\n    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();\n    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();\n  }\n\n  /// @notice Unpause external functions in all contracts\n  /// @dev A manager can be replaced with the new contract in an unpaused state\n  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused\n  function unpause() external onlyOwner {\n    _unpause();\n    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();\n    // sherDistributionManager can be 0, unpause isn\'t needed in that case\n    if (\n      address(sherDistributionManager) != address(0) &amp;&amp;\n      Pausable(address(sherDistributionManager)).paused()\n    ) {\n      sherDistributionManager.unpause();\n    }\n    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();\n    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();\n  }\n\n  //\n  // Access control functions\n  //\n\n  /// @notice Account sum of all underlying posiiton shares for _from and _to\n  /// @dev this enables the tokenBalanceOfAddress to exist\n  function _beforeTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenID\n  ) internal override {\n    uint256 _stakeShares = stakeShares[_tokenID];\n\n    if (_from != address(0)) addressShares[_from] -= _stakeShares;\n    if (_to != address(0)) addressShares[_to] += _stakeShares;\n  }\n\n  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)\n  // This function is called by the Sherlock claim manager contract if a claim is approved\n  /// @notice Initiate a payout of _amount to _receiver\n  /// @param _receiver Receiver of payout\n  /// @param _amount Amount to send\n  /// @dev only payout manager should call this\n  /// @dev should pull money out of strategy\n  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {\n    // Can only be called by the Sherlock claim manager contract\n    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();\n\n    if (_amount != 0) {\n      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)\n      _transferTokensOut(_receiver, _amount);\n    }\n    emit ClaimPayout(_receiver, _amount);\n  }\n\n  //\n  // Non-access control functions\n  //\n\n  // Helper function for initial staking and restaking\n  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position\n  /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time for which funds get locked\n  /// @param _id ID for this NFT position\n  /// @param _receiver Address that will be linked to this position\n  /// @return _sher Amount of SHER tokens awarded to this position after _period ends\n  /// @dev _period needs to be whitelisted\n  function _stake(\n    uint256 _amount,\n    uint256 _period,\n    uint256 _id,\n    address _receiver\n  ) internal returns (uint256 _sher) {\n    // Sets the timestamp at which this position can first be unstaked/restaked\n    lockupEnd[id] = block.timestamp + _period;\n\n    if (address(sherDistributionManager) == address(0)) return 0;\n    // Does not allow restaking of 0 tokens\n    if (_amount == 0) return 0;\n\n    // Checks this amount of SHER tokens in this contract before we transfer new ones\n    uint256 before = sher.balanceOf(address(this));\n\n    // pullReward() calcs then actually transfers the SHER tokens to this contract\n    // in case this call fails, whole (re)staking transaction fails\n    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);\n\n    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position\n    uint256 actualAmount = sher.balanceOf(address(this)) - before;\n    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);\n    // Assigns the newly created SHER tokens to the current stake position\n    if (_sher != 0) sherRewards[id] = _sher;\n  }\n\n  // Checks to see if the NFT owner is the caller and that the position is unlockable\n  function _verifyUnlockableByOwner(uint256 _id) internal view {\n    if (ownerOf(_id) != msg.sender) revert Unauthorized();\n    if (lockupEnd[id] &gt; block.timestamp) revert InvalidConditions();\n  }\n\n  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner\n  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {\n    uint256 sherReward = sherRewards[id];\n    if (sherReward == 0) return;\n\n    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner\n    sher.safeTransfer(_nftOwner, sherReward);\n    // Deletes the SHER reward mapping for this NFT ID\n    delete sherRewards[id];\n  }\n\n  // Transfers an amount of tokens to the receiver address\n  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)\n  function _transferTokensOut(address _receiver, uint256 _amount) internal {\n    // Transfers any premiums owed to stakers from the protocol manager to this contract\n    sherlockProtocolManager.claimPremiumsForStakers();\n\n    // The amount of tokens in this contract\n    uint256 mainBalance = token.balanceOf(address(this));\n\n    // If the amount to transfer out is still greater than the amount of tokens in this contract,\n    // Withdraw yield strategy tokens to make up the difference\n    if (_amount &gt; mainBalance) {\n      yieldStrategy.withdraw(_amount - mainBalance);\n    }\n\n    token.safeTransfer(_receiver, _amount);\n  }\n\n  // Returns the amount of USDC owed to this amount of stakeShares\n  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {\n    // Finds fraction that the given amount of stakeShares represents of the total\n    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers\n    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;\n  }\n\n  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted\n  // Also burns the requisite amount of shares associated with this NFT position\n  // Returns the amount of USDC owed to these shares\n  function _redeemShares(\n    uint256 _id,\n    uint256 _stakeShares,\n    address _receiver\n  ) internal returns (uint256 _amount) {\n    // Returns the amount of USDC owed to this amount of stakeShares\n    _amount = _redeemSharesCalc(_stakeShares);\n    // Transfers _amount of tokens to _receiver address\n    if (_amount != 0) _transferTokensOut(_receiver, _amount);\n\n    // Subtracts this amount of stakeShares from the NFT position\n    stakeShares[_id] -= _stakeShares;\n    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding\n    totalStakeShares -= _stakeShares;\n  }\n\n  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager\n  // Restakes an NFT position (_id) for a given period (_period) and\n  // Sends any previously earned SHER rewards to the _nftOwner address\n  function _restake(\n    uint256 _id,\n    uint256 _period,\n    address _nftOwner\n  ) internal returns (uint256 _sher) {\n    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner\n    // NOTE This function deletes the SHER reward mapping for this NFT ID\n    _sendSherRewardsToOwner(_id, _nftOwner);\n\n    // tokenBalanceOf() returns the USDC amount owed to this NFT ID\n    // _stake() restakes that amount of USDC for the period inputted\n    // We use the same ID that we just deleted the SHER rewards mapping for\n    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID\n    // Note stakeShares for this position do not change so no need to update\n    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);\n\n    emit Restaked(_id);\n  }\n\n  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)\n  /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @param _receiver Address that will receive the NFT representing the position\n  /// @return _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to this ID after _period ends\n  /// @dev _period needs to be whitelisted\n  function initialStake(\n    uint256 _amount,\n    uint256 _period,\n    address _receiver\n  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {\n    if (_amount == 0) revert ZeroArgument();\n    // Makes sure the period is a whitelisted period\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n    if (address(_receiver) == address(0)) revert ZeroArgument();\n    // Adds 1 to the ID of the last NFT created for the new NFT ID\n    _id = ++nftCounter;\n\n    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)\n    token.safeTransferFrom(msg.sender, address(this), _amount);\n\n    uint256 stakeShares;\n    uint256 totalStakeShares_ = totalStakeShares;\n    // amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares\n    if (totalStakeShares != 0)\n      stakeShares_ = (amount * totalStakeShares) / (totalTokenBalanceStakers() - amount);\n      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked\n    else stakeShares = amount;\n\n    // Assigns this NFT ID the calc\'d amount of stake shares above\n    stakeShares[_id] = stakeShares;\n    // Adds the newly created stake shares to the total amount of stake shares\n    totalStakeShares += stakeShares_;\n\n    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake\n    sher = _stake(_amount, _period, _id, _receiver);\n\n    // This is an ERC-721 function that creates an NFT and sends it to the receiver\n    _safeMint(_receiver, _id);\n  }\n\n  // This is how a staker unstakes and cashes out on their position\n  /// @notice Redeem NFT _id and receive _amount of tokens\n  /// @param _id TokenID of the position\n  /// @return _amount Amount of tokens (USDC) owed to NFT ID\n  /// @dev Only the owner of _id will be able to redeem their position\n  /// @dev The SHER rewards are sent to the NFT owner\n  /// @dev Can only be called after lockup _period has ended\n  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {\n    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over\n    _verifyUnlockableByOwner(_id);\n\n    // This is the ERC-721 function to destroy an NFT (with owner\'s approval)\n    _burn(_id);\n\n    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID\n    // Also burns the requisite amount of shares associated with this NFT position\n    // Returns the amount of USDC owed to these shares\n    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);\n\n    // Sends the SHER tokens associated with this NFT ID to the NFT owner\n    _sendSherRewardsToOwner(_id, msg.sender);\n\n    // Removes the unlock deadline associated with this NFT\n    delete lockupEnd[id];\n  }\n\n  // This is how a staker restakes an expired position\n  /// @notice Owner restakes position with ID: _id for _period seconds\n  /// @param _id ID of the position\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @return _sher Amount of SHER tokens to be released to owner address after _period ends\n  /// @dev Only the owner of _id will be able to restake their position using this call\n  /// @dev _period needs to be whitelisted\n  /// @dev Can only be called after lockup _period has ended\n  function ownerRestake(uint256 _id, uint256 _period)\n    external\n    override\n    whenNotPaused\n    returns (uint256 _sher)\n  {\n    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over\n    _verifyUnlockableByOwner(_id);\n\n    // Checks to make sure the staking period is a whitelisted one\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position\n    _sher = _restake(_id, _period, msg.sender);\n  }\n\n  // Calcs the reward (in stake shares) an arb would get for restaking a position\n  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb\n  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {\n    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)\n    uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME;\n\n    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position\n    if (initialArbTime &gt; block.timestamp) return (0, false);\n\n    // The max rewards (as a % of the position\'s shares) for the arb are available at this timestamp\n    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;\n\n    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%\n    uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;\n\n    // Scaled by 1018\n    // Represents the max amount of stake shares that an arb could get from restaking this position\n    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];\n\n    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function\n    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled\n    return (\n      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10*18,\n      true\n    );\n  }\n\n  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position\n  /// @return profit How much profit an arb would make in USDC\n  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)\n  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {\n    // Returns the stake shares that an arb would get, and whether the position can currently be arbed\n    // profit variable is used to store the amount of shares\n    (profit, able) = _calcSharesForArbRestake(_id);\n    // Calculates the tokens (USDC) represented by that amount of stake shares\n    // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit\n    profit = _redeemSharesCalc(profit);\n  }\n\n  /// @notice Allows someone who doesn\'t own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)\n  /// @param _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup\n  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function\n  /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)\n  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)\n  /// @dev During a 2 week period the reward ratio will move from 0% to 100% ( x)\n  function arbRestake(uint256 _id)\n    external\n    override\n    whenNotPaused\n    returns (uint256 _sher, uint256 _arbReward)\n  {\n    address nftOwner = ownerOf(_id);\n\n    // Returns the stake shares that an arb would get, and whether the position can currently be arbed\n    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);\n    // Revert if not able to be arbed\n    if (!able) revert InvalidConditions();\n\n    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward\n    // Also burns the requisite amount of shares associated with this NFT position\n    // Returns the amount of USDC paid to the arbitrager\n    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);\n\n    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)\n    // Sends previously earned SHER rewards to the NFT owner address\n    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);\n\n    emit ArbRestaked(_id, _arbReward);\n  }\n}\n'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-25-08 10:36:47 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@openzeppelin/contracts/token/ERC721/ERC721.sol'; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol'; import '@openzeppelin/contracts/security/Pausable.sol'; import './interfaces/ISherlock.sol'; /// @title Sherlock core interface for stakers /// @author Evert Kors // This is the contract that manages staking actions contract Sherlock is ISherlock, ERC721, Ownable, Pausable {   using SafeERC20 for IERC20; // The initial period for a staker to restake/withdraw without being auto-restaked   uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks; // The period during which the reward for restaking an account (after the inital period) grows   uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks; // Anyone who gets auto-restaked is restaked for this period (3 months)   uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks; // The percentage of someone's stake that can be paid to an arb for restaking   uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20% // USDC address   IERC20 public immutable token; // SHER token address   IERC20 public immutable sher; // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not   mapping(uint256 =&gt; bool) public override stakingPeriods; // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked   mapping(uint256 =&gt; uint256) internal lockupEnd_; // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position   mapping(uint256 =&gt; uint256) internal sherRewards_; // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)   mapping(uint256 =&gt; uint256) internal stakeShares; // Key is account, value is the sum of underlying shares of all the NFTs the account owns.   mapping(address =&gt; uint256) internal addressShares; // Total amount of shares that have been issued to all NFT positions   uint256 internal totalStakeShares; // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)   IStrategyManager public override yieldStrategy; // Instances of relevant Sherlock contracts   ISherDistributionManager public override sherDistributionManager;   ISherlockProtocolManager public override sherlockProtocolManager;   ISherlockClaimManager public override sherlockClaimManager; // Address to which nonstaker payments are made   // This will start out as a multi-sig address, then become a contract address later   address public override nonStakersAddress; // Stores the ID of the most recently created NFT   // This variable is incremented by 1 to create a new NFT ID   uint256 internal nftCounter; // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.   constructor(     IERC20 _token, // USDC address     IERC20 _sher, // SHER token address     string memory _name, // Token collection name (see ERC-721 docs)     string memory _symbol, // Token collection symbol (see ERC-721 docs)     IStrategyManager _yieldStrategy, // The active yield strategy contract     ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract     address _nonStakersAddress, // The address to which nonstakers payments go     ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract     ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract     uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for   ) ERC721(_name, _symbol) {     if (address(_token) == address(0)) revert ZeroArgument();     if (address(_sher) == address(0)) revert ZeroArgument();     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (_nonStakersAddress == address(0)) revert ZeroArgument();     if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();     if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument(); token = _token; sher = _sher; yieldStrategy = _yieldStrategy; sherDistributionManager = _sherDistributionManager; nonStakersAddress = _nonStakersAddress; sherlockProtocolManager = _sherlockProtocolManager; sherlockClaimManager = _sherlockClaimManager;  // Enabling the first set of staking periods that were provided in constructor args for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {   enableStakingPeriod(_initialstakingPeriods[i]); }  emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy); emit SherDistributionManagerUpdated(   ISherDistributionManager(address(0)),   _sherDistributionManager ); emit NonStakerAddressUpdated(address(0), _nonStakersAddress); emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager); emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);  } //   // View functions   // // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked   /// @notice View the current lockup end timestamp of _tokenID   /// @return Timestamp when NFT position unlocks   function lockupEnd(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return lockupEnd_[_tokenID];  } // Returns the SHER rewards owed to this position   /// @notice View the current SHER reward of _tokenID   /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup   function sherRewards(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return sherRewards_[_tokenID];  } // Returns the tokens (USDC) owed to a position   /// @notice View the current token balance claimable upon reaching end of the lockup   /// @return Amount of tokens assigned to owner when unstaking position   function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent();     // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers     return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;   } // Returns the tokens (USDC) owed to an address   /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup   /// @return Amount of tokens assigned to owner when unstaking all positions   function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {     if (_staker == address(0)) revert ZeroArgument();     uint256 _totalStakeShares = totalStakeShares;     if (_totalStakeShares == 0) return 0;     // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers     return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;   } // Gets the total amount of tokens (USDC) owed to stakers   // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract   /// @notice View the current TVL for all stakers   /// @return Total amount of tokens staked   /// @dev Adds principal + strategy + premiums   /// @dev Will calculate the most up to date value for each piece   function totalTokenBalanceStakers() public view override returns (uint256) {     return       token.balanceOf(address(this)) +       yieldStrategy.balanceOf() +       sherlockProtocolManager.claimablePremiums();   } //   // Gov functions   // // Allows governance to add a new staking period (4 months, etc.)   /// @notice Allows stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already enabled   function enableStakingPeriod(uint256 _period) public override onlyOwner {     if (_period == 0) revert ZeroArgument();     // Revert if staking period is already active     if (stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to true stakingPeriods[_period] = true; emit StakingPeriodEnabled(_period);  } // Allows governance to remove a staking period (4 months, etc.)   /// @notice Disallow stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already disabled   function disableStakingPeriod(uint256 _period) external override onlyOwner {     // Revert if staking period is already inactive     if (!stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to false stakingPeriods[_period] = false; emit StakingPeriodDisabled(_period);  } // Sets a new contract to be the active SHER distribution manager   /// @notice Update SHER distribution manager contract   /// @param _sherDistributionManager New adddress of the manager   function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)     external     override     onlyOwner   {     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument(); emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager); sherDistributionManager = _sherDistributionManager;  } // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)   /// @notice Remove SHER token rewards   function removeSherDistributionManager() external override onlyOwner {     if (address(sherDistributionManager) == address(0)) revert InvalidConditions(); emit SherDistributionManagerUpdated(   sherDistributionManager,   ISherDistributionManager(address(0)) ); delete sherDistributionManager;  } // Sets a new address for nonstakers payments   /// @notice Update address eligble for non staker rewards from protocol premiums   /// @param _nonStakers Address eligble for non staker rewards   function updateNonStakersAddress(address _nonStakers) external override onlyOwner {     if (address(_nonStakers) == address(0)) revert ZeroArgument();     if (nonStakersAddress == _nonStakers) revert InvalidArgument(); emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers); nonStakersAddress = _nonStakers;  } // Sets a new protocol manager contract   /// @notice Transfer protocol manager implementation address   /// @param _protocolManager new implementation address   function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)     external     override     onlyOwner   {     if (address(_protocolManager) == address(0)) revert ZeroArgument();     if (sherlockProtocolManager == _protocolManager) revert InvalidArgument(); emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager); sherlockProtocolManager = _protocolManager;  } // Sets a new claim manager contract   /// @notice Transfer claim manager role to different address   /// @param _claimManager New address of claim manager   function updateSherlockClaimManager(ISherlockClaimManager _claimManager)     external     override     onlyOwner   {     if (address(_claimManager) == address(0)) revert ZeroArgument();     if (sherlockClaimManager == _claimManager) revert InvalidArgument(); emit ClaimManagerUpdated(sherlockClaimManager, _claimManager); sherlockClaimManager = _claimManager;  } // Sets a new yield strategy manager contract   /// @notice Update yield strategy   /// @param _yieldStrategy News address of the strategy   /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure   function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (yieldStrategy == _yieldStrategy) revert InvalidArgument(); // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason. // In case this happens. We still want the yield strategy to be updated. // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again. try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {   emit YieldStrategyUpdateWithdrawAllError(reason); }  emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy); yieldStrategy = _yieldStrategy;  } // Deposits a chosen amount of tokens (USDC) into the active yield strategy   /// @notice Deposit _amount into active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); // Transfers any tokens owed to stakers from the protocol manager contract to this contract first sherlockProtocolManager.claimPremiumsForStakers(); // Transfers the amount of tokens to the yield strategy contract token.safeTransfer(address(yieldStrategy), _amount); // Deposits all tokens in the yield strategy contract into the actual yield strategy yieldStrategy.deposit();  } // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract   /// @notice Withdraw _amount from active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); yieldStrategy.withdraw(_amount);  } // Withdraws all tokens from the yield strategy back into this contract   /// @notice Withdraw all funds from active strategy   /// @dev gov only   function yieldStrategyWithdrawAll() external override onlyOwner {     yieldStrategy.withdrawAll();   } /// @notice Pause external functions in all contracts   /// @dev A manager can be replaced with the new contract in a paused state   /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused   function pause() external onlyOwner {     _pause();     if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();     // sherDistributionManager can be 0, pause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       !Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.pause();     }     if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();     if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();   } /// @notice Unpause external functions in all contracts   /// @dev A manager can be replaced with the new contract in an unpaused state   /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused   function unpause() external onlyOwner {     _unpause();     if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();     // sherDistributionManager can be 0, unpause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.unpause();     }     if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();     if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();   } //   // Access control functions   // /// @notice Account sum of all underlying posiiton shares for _from and _to   /// @dev this enables the tokenBalanceOfAddress to exist   function _beforeTokenTransfer(     address _from,     address _to,     uint256 _tokenID   ) internal override {     uint256 _stakeShares = stakeShares[_tokenID]; if (_from != address(0)) addressShares[_from] -= _stakeShares; if (_to != address(0)) addressShares[_to] += _stakeShares;  } // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)   // This function is called by the Sherlock claim manager contract if a claim is approved   /// @notice Initiate a payout of _amount to _receiver   /// @param _receiver Receiver of payout   /// @param _amount Amount to send   /// @dev only payout manager should call this   /// @dev should pull money out of strategy   function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {     // Can only be called by the Sherlock claim manager contract     if (msg.sender != address(sherlockClaimManager)) revert Unauthorized(); if (_amount != 0) {   // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)   _transferTokensOut(_receiver, _amount); } emit ClaimPayout(_receiver, _amount);  } //   // Non-access control functions   // // Helper function for initial staking and restaking   // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position   /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds   /// @param amount Amount of tokens to stake   /// @param _period Period of time for which funds get locked   /// @param _id ID for this NFT position   /// @param _receiver Address that will be linked to this position   /// @return _sher Amount of SHER tokens awarded to this position after _period ends   /// @dev _period needs to be whitelisted   function _stake(     uint256 _amount,     uint256 _period,     uint256 _id,     address _receiver   ) internal returns (uint256 _sher) {     // Sets the timestamp at which this position can first be unstaked/restaked     lockupEnd[_id] = block.timestamp + _period; if (address(sherDistributionManager) == address(0)) return 0; // Does not allow restaking of 0 tokens if (_amount == 0) return 0;  // Checks this amount of SHER tokens in this contract before we transfer new ones uint256 before = sher.balanceOf(address(this));  // pullReward() calcs then actually transfers the SHER tokens to this contract // in case this call fails, whole (re)staking transaction fails _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);  // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position uint256 actualAmount = sher.balanceOf(address(this)) - before; if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount); // Assigns the newly created SHER tokens to the current stake position if (_sher != 0) sherRewards_[_id] = _sher;  } // Checks to see if the NFT owner is the caller and that the position is unlockable   function verifyUnlockableByOwner(uint256 _id) internal view {     if (ownerOf(_id) != msg.sender) revert Unauthorized();     if (lockupEnd[_id] &gt; block.timestamp) revert InvalidConditions();   } // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner   function sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards[_id];     if (sherReward == 0) return; // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner sher.safeTransfer(_nftOwner, sherReward); // Deletes the SHER reward mapping for this NFT ID delete sherRewards_[_id];  } // Transfers an amount of tokens to the receiver address   // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)   function _transferTokensOut(address _receiver, uint256 _amount) internal {     // Transfers any premiums owed to stakers from the protocol manager to this contract     sherlockProtocolManager.claimPremiumsForStakers(); // The amount of tokens in this contract uint256 mainBalance = token.balanceOf(address(this));  // If the amount to transfer out is still greater than the amount of tokens in this contract, // Withdraw yield strategy tokens to make up the difference if (_amount &gt; mainBalance) {   yieldStrategy.withdraw(_amount - mainBalance); }  token.safeTransfer(_receiver, _amount);  } // Returns the amount of USDC owed to this amount of stakeShares   function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {     // Finds fraction that the given amount of stakeShares represents of the total     // Then multiplies it by the total amount of tokens (USDC) owed to all stakers     return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;   } // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted   // Also burns the requisite amount of shares associated with this NFT position   // Returns the amount of USDC owed to these shares   function _redeemShares(     uint256 _id,     uint256 _stakeShares,     address _receiver   ) internal returns (uint256 _amount) {     // Returns the amount of USDC owed to this amount of stakeShares     _amount = _redeemSharesCalc(_stakeShares);     // Transfers _amount of tokens to _receiver address     if (_amount != 0) _transferTokensOut(_receiver, _amount); // Subtracts this amount of stakeShares from the NFT position stakeShares[_id] -= _stakeShares; // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding totalStakeShares -= _stakeShares;  } // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager   // Restakes an NFT position (_id) for a given period (_period) and   // Sends any previously earned SHER rewards to the _nftOwner address   function _restake(     uint256 _id,     uint256 _period,     address _nftOwner   ) internal returns (uint256 _sher) {     // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner     // NOTE This function deletes the SHER reward mapping for this NFT ID     _sendSherRewardsToOwner(_id, _nftOwner); // tokenBalanceOf() returns the USDC amount owed to this NFT ID // _stake() restakes that amount of USDC for the period inputted // We use the same ID that we just deleted the SHER rewards mapping for // Resets the lockupEnd mapping and SHER token rewards mapping for this ID // Note stakeShares for this position do not change so no need to update _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);  emit Restaked(_id);  } // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)   /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt   /// @param _amount Amount of tokens to stake   /// @param _period Period of time, in seconds, to lockup your funds   /// @param _receiver Address that will receive the NFT representing the position   /// @return _id ID of the position   /// @return _sher Amount of SHER tokens to be released to this ID after _period ends   /// @dev _period needs to be whitelisted   function initialStake(     uint256 _amount,     uint256 _period,     address _receiver   ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {     if (_amount == 0) revert ZeroArgument();     // Makes sure the period is a whitelisted period     if (!stakingPeriods[_period]) revert InvalidArgument();     if (address(_receiver) == address(0)) revert ZeroArgument();     // Adds 1 to the ID of the last NFT created for the new NFT ID     _id = ++nftCounter; // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action) token.safeTransferFrom(msg.sender, address(this), _amount);  uint256 stakeShares_; uint256 totalStakeShares_ = totalStakeShares; // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares if (totalStakeShares_ != 0)   stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);   // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked else stakeShares_ = _amount;  // Assigns this NFT ID the calc'd amount of stake shares above stakeShares[_id] = stakeShares_; // Adds the newly created stake shares to the total amount of stake shares totalStakeShares += stakeShares_;  // Locks up the USDC amount and calcs the SHER token amount to receive on unstake _sher = _stake(_amount, _period, _id, _receiver);  // This is an ERC-721 function that creates an NFT and sends it to the receiver _safeMint(_receiver, _id);  } // This is how a staker unstakes and cashes out on their position   /// @notice Redeem NFT _id and receive _amount of tokens   /// @param _id TokenID of the position   /// @return _amount Amount of tokens (USDC) owed to NFT ID   /// @dev Only the owner of _id will be able to redeem their position   /// @dev The SHER rewards are sent to the NFT owner   /// @dev Can only be called after lockup _period has ended   function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // This is the ERC-721 function to destroy an NFT (with owner's approval) _burn(_id);  // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC owed to these shares _amount = _redeemShares(_id, stakeShares[_id], msg.sender);  // Sends the SHER tokens associated with this NFT ID to the NFT owner _sendSherRewardsToOwner(_id, msg.sender);  // Removes the unlock deadline associated with this NFT delete lockupEnd_[_id];  } // This is how a staker restakes an expired position   /// @notice Owner restakes position with ID: _id for _period seconds   /// @param _id ID of the position   /// @param _period Period of time, in seconds, to lockup your funds   /// @return _sher Amount of SHER tokens to be released to owner address after _period ends   /// @dev Only the owner of _id will be able to restake their position using this call   /// @dev _period needs to be whitelisted   /// @dev Can only be called after lockup _period has ended   function ownerRestake(uint256 _id, uint256 _period)     external     override     whenNotPaused     returns (uint256 _sher)   {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // Checks to make sure the staking period is a whitelisted one if (!stakingPeriods[_period]) revert InvalidArgument();  // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position _sher = _restake(_id, _period, msg.sender);  } // Calcs the reward (in stake shares) an arb would get for restaking a position   // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb   function calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {     // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)     uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME; // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position if (initialArbTime &gt; block.timestamp) return (0, false);  // The max rewards (as a % of the position's shares) for the arb are available at this timestamp uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;  // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100% uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;  // Scaled by 10**18 // Represents the max amount of stake shares that an arb could get from restaking this position uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];  // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled return (   ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,   true );  } /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position   /// @return profit How much profit an arb would make in USDC   /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)   function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {     // Returns the stake shares that an arb would get, and whether the position can currently be arbed     // profit variable is used to store the amount of shares     (profit, able) = _calcSharesForArbRestake(_id);     // Calculates the tokens (USDC) represented by that amount of stake shares     // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit     profit = _redeemSharesCalc(profit);   } /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)   /// @param _id ID of the position   /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup   /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function   /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)   /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)   /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)   function arbRestake(uint256 _id)     external     override     whenNotPaused     returns (uint256 _sher, uint256 _arbReward)   {     address nftOwner = ownerOf(_id); // Returns the stake shares that an arb would get, and whether the position can currently be arbed (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id); // Revert if not able to be arbed if (!able) revert InvalidConditions();  // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC paid to the arbitrager _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);  // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months) // Sends previously earned SHER rewards to the NFT owner address _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);  emit ArbRestaked(_id, _arbReward);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-25-08 10:36:47 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';

import './interfaces/ISherlock.sol';

/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions

contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;

  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;

  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;

  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;

  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%

  // USDC address
  IERC20 public immutable token;

  // SHER token address
  IERC20 public immutable sher;

  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;

  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;

  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;

  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;

  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;

  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;

  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;

  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;

  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;

  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;

  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();

    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;

    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }

    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }

  //
  // View functions
  //

  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return lockupEnd_[_tokenID];
  }

  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return sherRewards_[_tokenID];
  }

  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }

  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }

  //
  // Gov functions
  //

  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }

  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }

  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();

    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }

  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();

    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }

  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();

    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }

  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();

    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }

  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();

    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }

  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();

    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }

    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }

  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }

  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    yieldStrategy.withdraw(_amount);
  }

  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }

  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }

  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }

  //
  // Access control functions
  //

  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];

    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }

  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();

    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }

  //
  // Non-access control functions
  //

  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;

    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;

    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));

    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);

    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }

  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }

  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;

    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }

  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();

    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));

    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }

    token.safeTransfer(_receiver, _amount);
  }

  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);

    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }

  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);

    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);

    emit Restaked(_id);
  }

  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;

    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);

    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;

    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;

    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);

    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }

  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);

    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);

    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);

    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }

  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }

  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;

    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);

    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;

    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;

    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];

    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }

  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }

  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);

    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();

    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);

    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);

    emit ArbRestaked(_id, _arbReward);
  }
}
.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';

import './interfaces/ISherlock.sol';

/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions

contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;

  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;

  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;

  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;

  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%

  // USDC address
  IERC20 public immutable token;

  // SHER token address
  IERC20 public immutable sher;

  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;

  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;

  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;

  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;

  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;

  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;

  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;

  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;

  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;

  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;

  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();

    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;

    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }

    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }

  //
  // View functions
  //

  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return lockupEnd_[_tokenID];
  }

  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return sherRewards_[_tokenID];
  }

  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }

  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }

  //
  // Gov functions
  //

  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }

  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }

  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();

    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }

  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();

    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }

  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();

    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }

  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();

    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }

  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();

    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }

  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();

    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }

    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }

  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }

  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    yieldStrategy.withdraw(_amount);
  }

  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }

  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }

  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }

  //
  // Access control functions
  //

  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];

    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }

  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();

    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }

  //
  // Non-access control functions
  //

  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;

    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;

    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));

    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);

    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }

  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }

  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;

    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }

  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();

    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));

    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }

    token.safeTransfer(_receiver, _amount);
  }

  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);

    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }

  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);

    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);

    emit Restaked(_id);
  }

  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;

    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);

    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;

    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;

    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);

    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }

  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);

    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);

    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);

    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }

  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }

  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;

    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);

    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;

    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;

    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];

    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }

  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }

  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);

    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();

    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);

    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);

    emit ArbRestaked(_id, _arbReward);
  }
}
".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-25-08 10:36:56 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-25-08 10:36:56 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 15572
completion_tokens: 517
total_tokens: 16089
cost: $-1.000000


[2024-25-08 10:36:56 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';

import './interfaces/ISherlock.sol';

/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions

contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;

  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;

  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;

  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;

  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%

  // USDC address
  IERC20 public immutable token;

  // SHER token address
  IERC20 public immutable sher;

  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;

  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;

  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;

  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;

  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;

  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;

  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;

  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;

  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;

  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;

  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();

    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;

    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }

    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }

  //
  // View functions
  //

  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return lockupEnd_[_tokenID];
  }

  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return sherRewards_[_tokenID];
  }

  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }

  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }

  //
  // Gov functions
  //

  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }

  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }

  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();

    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }

  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();

    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }

  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();

    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }

  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();

    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }

  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();

    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }

  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();

    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }

    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }

  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }

  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    yieldStrategy.withdraw(_amount);
  }

  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }

  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }

  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }

  //
  // Access control functions
  //

  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];

    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }

  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();

    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }

  //
  // Non-access control functions
  //

  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;

    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;

    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));

    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);

    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }

  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }

  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;

    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }

  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();

    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));

    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }

    token.safeTransfer(_receiver, _amount);
  }

  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);

    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }

  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);

    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);

    emit Restaked(_id);
  }

  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;

    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);

    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;

    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;

    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);

    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }

  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);

    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);

    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);

    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }

  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }

  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;

    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);

    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;

    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;

    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];

    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }

  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }

  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);

    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();

    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);

    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);

    emit ArbRestaked(_id, _arbReward);
  }
}
.]

Let's analyze the provided Solidity contract and brainstorm potential improvements or enhancements.

1. **Reentrancy Guard**: The contract currently does not implement any protection against reentrancy attacks, especially in functions that transfer tokens or interact with external contracts (like `payoutClaim`, `yieldStrategyWithdraw`, etc.). We could implement a reentrancy guard using the `nonReentrant` modifier from OpenZeppelin.

2. **Event Emission for State Changes**: While there are several events emitted, we could ensure that every state-changing function emits an event. For example, functions like `enableStakingPeriod`, `disableStakingPeriod`, and others that modify mappings could benefit from additional events to track changes more effectively.

3. **Gas Optimization**: We could optimize the gas usage in functions by minimizing state variable reads and writes. For instance, in the `_redeemSharesCalc` function, we could cache `totalTokenBalanceStakers()` in a local variable to avoid multiple calls.

4. **Access Control Enhancements**: Currently, the `onlyOwner` modifier is used for several functions. We could consider implementing role-based access control using OpenZeppelin's `AccessControl` to allow for more granular permissions in the future.

5. **Input Validation**: While there are some checks in place, we could enhance input validation in functions like `initialStake` and `ownerRestake` to ensure that the `_period` is not only whitelisted but also falls within a reasonable range to prevent potential misuse.

6. **Upgradeability**: If the contract is intended to be used long-term, we could consider implementing a proxy pattern for upgradeability. This would allow for future improvements without losing the state of the contract.

7. **Emergency Withdrawals**: Implementing a mechanism for emergency withdrawals could be beneficial in case of unforeseen circumstances, allowing users to withdraw their funds without waiting for the lockup period to end.

8. **Detailed Documentation**: While the contract has some comments, enhancing the documentation for each function, especially the more complex ones, could improve maintainability and understanding for future developers.

9. **Testing and Auditing**: Ensure that comprehensive unit tests are written for all functionalities, especially edge cases. Additionally, consider a third-party audit for security assurance.

10. **User Feedback Mechanism**: Implementing a way for users to provide feedback or report issues directly through the contract could enhance user engagement and trust.

Which of these suggestions do you think would be the most impactful, or do you have any other ideas to add?

[2024-25-08 10:36:56 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@openzeppelin/contracts/token/ERC721/ERC721.sol'; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol'; import '@openzeppelin/contracts/security/Pausable.sol'; import './interfaces/ISherlock.sol'; /// @title Sherlock core interface for stakers /// @author Evert Kors // This is the contract that manages staking actions contract Sherlock is ISherlock, ERC721, Ownable, Pausable {   using SafeERC20 for IERC20; // The initial period for a staker to restake/withdraw without being auto-restaked   uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks; // The period during which the reward for restaking an account (after the inital period) grows   uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks; // Anyone who gets auto-restaked is restaked for this period (3 months)   uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks; // The percentage of someone's stake that can be paid to an arb for restaking   uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20% // USDC address   IERC20 public immutable token; // SHER token address   IERC20 public immutable sher; // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not   mapping(uint256 =&gt; bool) public override stakingPeriods; // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked   mapping(uint256 =&gt; uint256) internal lockupEnd_; // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position   mapping(uint256 =&gt; uint256) internal sherRewards_; // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)   mapping(uint256 =&gt; uint256) internal stakeShares; // Key is account, value is the sum of underlying shares of all the NFTs the account owns.   mapping(address =&gt; uint256) internal addressShares; // Total amount of shares that have been issued to all NFT positions   uint256 internal totalStakeShares; // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)   IStrategyManager public override yieldStrategy; // Instances of relevant Sherlock contracts   ISherDistributionManager public override sherDistributionManager;   ISherlockProtocolManager public override sherlockProtocolManager;   ISherlockClaimManager public override sherlockClaimManager; // Address to which nonstaker payments are made   // This will start out as a multi-sig address, then become a contract address later   address public override nonStakersAddress; // Stores the ID of the most recently created NFT   // This variable is incremented by 1 to create a new NFT ID   uint256 internal nftCounter; // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.   constructor(     IERC20 _token, // USDC address     IERC20 _sher, // SHER token address     string memory _name, // Token collection name (see ERC-721 docs)     string memory _symbol, // Token collection symbol (see ERC-721 docs)     IStrategyManager _yieldStrategy, // The active yield strategy contract     ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract     address _nonStakersAddress, // The address to which nonstakers payments go     ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract     ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract     uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for   ) ERC721(_name, _symbol) {     if (address(_token) == address(0)) revert ZeroArgument();     if (address(_sher) == address(0)) revert ZeroArgument();     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (_nonStakersAddress == address(0)) revert ZeroArgument();     if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();     if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument(); token = _token; sher = _sher; yieldStrategy = _yieldStrategy; sherDistributionManager = _sherDistributionManager; nonStakersAddress = _nonStakersAddress; sherlockProtocolManager = _sherlockProtocolManager; sherlockClaimManager = _sherlockClaimManager;  // Enabling the first set of staking periods that were provided in constructor args for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {   enableStakingPeriod(_initialstakingPeriods[i]); }  emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy); emit SherDistributionManagerUpdated(   ISherDistributionManager(address(0)),   _sherDistributionManager ); emit NonStakerAddressUpdated(address(0), _nonStakersAddress); emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager); emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);  } //   // View functions   // // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked   /// @notice View the current lockup end timestamp of _tokenID   /// @return Timestamp when NFT position unlocks   function lockupEnd(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return lockupEnd_[_tokenID];  } // Returns the SHER rewards owed to this position   /// @notice View the current SHER reward of _tokenID   /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup   function sherRewards(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return sherRewards_[_tokenID];  } // Returns the tokens (USDC) owed to a position   /// @notice View the current token balance claimable upon reaching end of the lockup   /// @return Amount of tokens assigned to owner when unstaking position   function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent();     // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers     return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;   } // Returns the tokens (USDC) owed to an address   /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup   /// @return Amount of tokens assigned to owner when unstaking all positions   function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {     if (_staker == address(0)) revert ZeroArgument();     uint256 _totalStakeShares = totalStakeShares;     if (_totalStakeShares == 0) return 0;     // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers     return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;   } // Gets the total amount of tokens (USDC) owed to stakers   // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract   /// @notice View the current TVL for all stakers   /// @return Total amount of tokens staked   /// @dev Adds principal + strategy + premiums   /// @dev Will calculate the most up to date value for each piece   function totalTokenBalanceStakers() public view override returns (uint256) {     return       token.balanceOf(address(this)) +       yieldStrategy.balanceOf() +       sherlockProtocolManager.claimablePremiums();   } //   // Gov functions   // // Allows governance to add a new staking period (4 months, etc.)   /// @notice Allows stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already enabled   function enableStakingPeriod(uint256 _period) public override onlyOwner {     if (_period == 0) revert ZeroArgument();     // Revert if staking period is already active     if (stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to true stakingPeriods[_period] = true; emit StakingPeriodEnabled(_period);  } // Allows governance to remove a staking period (4 months, etc.)   /// @notice Disallow stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already disabled   function disableStakingPeriod(uint256 _period) external override onlyOwner {     // Revert if staking period is already inactive     if (!stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to false stakingPeriods[_period] = false; emit StakingPeriodDisabled(_period);  } // Sets a new contract to be the active SHER distribution manager   /// @notice Update SHER distribution manager contract   /// @param _sherDistributionManager New adddress of the manager   function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)     external     override     onlyOwner   {     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument(); emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager); sherDistributionManager = _sherDistributionManager;  } // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)   /// @notice Remove SHER token rewards   function removeSherDistributionManager() external override onlyOwner {     if (address(sherDistributionManager) == address(0)) revert InvalidConditions(); emit SherDistributionManagerUpdated(   sherDistributionManager,   ISherDistributionManager(address(0)) ); delete sherDistributionManager;  } // Sets a new address for nonstakers payments   /// @notice Update address eligble for non staker rewards from protocol premiums   /// @param _nonStakers Address eligble for non staker rewards   function updateNonStakersAddress(address _nonStakers) external override onlyOwner {     if (address(_nonStakers) == address(0)) revert ZeroArgument();     if (nonStakersAddress == _nonStakers) revert InvalidArgument(); emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers); nonStakersAddress = _nonStakers;  } // Sets a new protocol manager contract   /// @notice Transfer protocol manager implementation address   /// @param _protocolManager new implementation address   function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)     external     override     onlyOwner   {     if (address(_protocolManager) == address(0)) revert ZeroArgument();     if (sherlockProtocolManager == _protocolManager) revert InvalidArgument(); emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager); sherlockProtocolManager = _protocolManager;  } // Sets a new claim manager contract   /// @notice Transfer claim manager role to different address   /// @param _claimManager New address of claim manager   function updateSherlockClaimManager(ISherlockClaimManager _claimManager)     external     override     onlyOwner   {     if (address(_claimManager) == address(0)) revert ZeroArgument();     if (sherlockClaimManager == _claimManager) revert InvalidArgument(); emit ClaimManagerUpdated(sherlockClaimManager, _claimManager); sherlockClaimManager = _claimManager;  } // Sets a new yield strategy manager contract   /// @notice Update yield strategy   /// @param _yieldStrategy News address of the strategy   /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure   function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (yieldStrategy == _yieldStrategy) revert InvalidArgument(); // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason. // In case this happens. We still want the yield strategy to be updated. // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again. try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {   emit YieldStrategyUpdateWithdrawAllError(reason); }  emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy); yieldStrategy = _yieldStrategy;  } // Deposits a chosen amount of tokens (USDC) into the active yield strategy   /// @notice Deposit _amount into active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); // Transfers any tokens owed to stakers from the protocol manager contract to this contract first sherlockProtocolManager.claimPremiumsForStakers(); // Transfers the amount of tokens to the yield strategy contract token.safeTransfer(address(yieldStrategy), _amount); // Deposits all tokens in the yield strategy contract into the actual yield strategy yieldStrategy.deposit();  } // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract   /// @notice Withdraw _amount from active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); yieldStrategy.withdraw(_amount);  } // Withdraws all tokens from the yield strategy back into this contract   /// @notice Withdraw all funds from active strategy   /// @dev gov only   function yieldStrategyWithdrawAll() external override onlyOwner {     yieldStrategy.withdrawAll();   } /// @notice Pause external functions in all contracts   /// @dev A manager can be replaced with the new contract in a paused state   /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused   function pause() external onlyOwner {     _pause();     if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();     // sherDistributionManager can be 0, pause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       !Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.pause();     }     if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();     if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();   } /// @notice Unpause external functions in all contracts   /// @dev A manager can be replaced with the new contract in an unpaused state   /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused   function unpause() external onlyOwner {     _unpause();     if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();     // sherDistributionManager can be 0, unpause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.unpause();     }     if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();     if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();   } //   // Access control functions   // /// @notice Account sum of all underlying posiiton shares for _from and _to   /// @dev this enables the tokenBalanceOfAddress to exist   function _beforeTokenTransfer(     address _from,     address _to,     uint256 _tokenID   ) internal override {     uint256 _stakeShares = stakeShares[_tokenID]; if (_from != address(0)) addressShares[_from] -= _stakeShares; if (_to != address(0)) addressShares[_to] += _stakeShares;  } // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)   // This function is called by the Sherlock claim manager contract if a claim is approved   /// @notice Initiate a payout of _amount to _receiver   /// @param _receiver Receiver of payout   /// @param _amount Amount to send   /// @dev only payout manager should call this   /// @dev should pull money out of strategy   function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {     // Can only be called by the Sherlock claim manager contract     if (msg.sender != address(sherlockClaimManager)) revert Unauthorized(); if (_amount != 0) {   // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)   _transferTokensOut(_receiver, _amount); } emit ClaimPayout(_receiver, _amount);  } //   // Non-access control functions   // // Helper function for initial staking and restaking   // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position   /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds   /// @param amount Amount of tokens to stake   /// @param _period Period of time for which funds get locked   /// @param _id ID for this NFT position   /// @param _receiver Address that will be linked to this position   /// @return _sher Amount of SHER tokens awarded to this position after _period ends   /// @dev _period needs to be whitelisted   function _stake(     uint256 _amount,     uint256 _period,     uint256 _id,     address _receiver   ) internal returns (uint256 _sher) {     // Sets the timestamp at which this position can first be unstaked/restaked     lockupEnd[_id] = block.timestamp + _period; if (address(sherDistributionManager) == address(0)) return 0; // Does not allow restaking of 0 tokens if (_amount == 0) return 0;  // Checks this amount of SHER tokens in this contract before we transfer new ones uint256 before = sher.balanceOf(address(this));  // pullReward() calcs then actually transfers the SHER tokens to this contract // in case this call fails, whole (re)staking transaction fails _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);  // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position uint256 actualAmount = sher.balanceOf(address(this)) - before; if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount); // Assigns the newly created SHER tokens to the current stake position if (_sher != 0) sherRewards_[_id] = _sher;  } // Checks to see if the NFT owner is the caller and that the position is unlockable   function verifyUnlockableByOwner(uint256 _id) internal view {     if (ownerOf(_id) != msg.sender) revert Unauthorized();     if (lockupEnd[_id] &gt; block.timestamp) revert InvalidConditions();   } // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner   function sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards[_id];     if (sherReward == 0) return; // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner sher.safeTransfer(_nftOwner, sherReward); // Deletes the SHER reward mapping for this NFT ID delete sherRewards_[_id];  } // Transfers an amount of tokens to the receiver address   // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)   function _transferTokensOut(address _receiver, uint256 _amount) internal {     // Transfers any premiums owed to stakers from the protocol manager to this contract     sherlockProtocolManager.claimPremiumsForStakers(); // The amount of tokens in this contract uint256 mainBalance = token.balanceOf(address(this));  // If the amount to transfer out is still greater than the amount of tokens in this contract, // Withdraw yield strategy tokens to make up the difference if (_amount &gt; mainBalance) {   yieldStrategy.withdraw(_amount - mainBalance); }  token.safeTransfer(_receiver, _amount);  } // Returns the amount of USDC owed to this amount of stakeShares   function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {     // Finds fraction that the given amount of stakeShares represents of the total     // Then multiplies it by the total amount of tokens (USDC) owed to all stakers     return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;   } // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted   // Also burns the requisite amount of shares associated with this NFT position   // Returns the amount of USDC owed to these shares   function _redeemShares(     uint256 _id,     uint256 _stakeShares,     address _receiver   ) internal returns (uint256 _amount) {     // Returns the amount of USDC owed to this amount of stakeShares     _amount = _redeemSharesCalc(_stakeShares);     // Transfers _amount of tokens to _receiver address     if (_amount != 0) _transferTokensOut(_receiver, _amount); // Subtracts this amount of stakeShares from the NFT position stakeShares[_id] -= _stakeShares; // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding totalStakeShares -= _stakeShares;  } // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager   // Restakes an NFT position (_id) for a given period (_period) and   // Sends any previously earned SHER rewards to the _nftOwner address   function _restake(     uint256 _id,     uint256 _period,     address _nftOwner   ) internal returns (uint256 _sher) {     // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner     // NOTE This function deletes the SHER reward mapping for this NFT ID     _sendSherRewardsToOwner(_id, _nftOwner); // tokenBalanceOf() returns the USDC amount owed to this NFT ID // _stake() restakes that amount of USDC for the period inputted // We use the same ID that we just deleted the SHER rewards mapping for // Resets the lockupEnd mapping and SHER token rewards mapping for this ID // Note stakeShares for this position do not change so no need to update _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);  emit Restaked(_id);  } // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)   /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt   /// @param _amount Amount of tokens to stake   /// @param _period Period of time, in seconds, to lockup your funds   /// @param _receiver Address that will receive the NFT representing the position   /// @return _id ID of the position   /// @return _sher Amount of SHER tokens to be released to this ID after _period ends   /// @dev _period needs to be whitelisted   function initialStake(     uint256 _amount,     uint256 _period,     address _receiver   ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {     if (_amount == 0) revert ZeroArgument();     // Makes sure the period is a whitelisted period     if (!stakingPeriods[_period]) revert InvalidArgument();     if (address(_receiver) == address(0)) revert ZeroArgument();     // Adds 1 to the ID of the last NFT created for the new NFT ID     _id = ++nftCounter; // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action) token.safeTransferFrom(msg.sender, address(this), _amount);  uint256 stakeShares_; uint256 totalStakeShares_ = totalStakeShares; // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares if (totalStakeShares_ != 0)   stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);   // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked else stakeShares_ = _amount;  // Assigns this NFT ID the calc'd amount of stake shares above stakeShares[_id] = stakeShares_; // Adds the newly created stake shares to the total amount of stake shares totalStakeShares += stakeShares_;  // Locks up the USDC amount and calcs the SHER token amount to receive on unstake _sher = _stake(_amount, _period, _id, _receiver);  // This is an ERC-721 function that creates an NFT and sends it to the receiver _safeMint(_receiver, _id);  } // This is how a staker unstakes and cashes out on their position   /// @notice Redeem NFT _id and receive _amount of tokens   /// @param _id TokenID of the position   /// @return _amount Amount of tokens (USDC) owed to NFT ID   /// @dev Only the owner of _id will be able to redeem their position   /// @dev The SHER rewards are sent to the NFT owner   /// @dev Can only be called after lockup _period has ended   function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // This is the ERC-721 function to destroy an NFT (with owner's approval) _burn(_id);  // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC owed to these shares _amount = _redeemShares(_id, stakeShares[_id], msg.sender);  // Sends the SHER tokens associated with this NFT ID to the NFT owner _sendSherRewardsToOwner(_id, msg.sender);  // Removes the unlock deadline associated with this NFT delete lockupEnd_[_id];  } // This is how a staker restakes an expired position   /// @notice Owner restakes position with ID: _id for _period seconds   /// @param _id ID of the position   /// @param _period Period of time, in seconds, to lockup your funds   /// @return _sher Amount of SHER tokens to be released to owner address after _period ends   /// @dev Only the owner of _id will be able to restake their position using this call   /// @dev _period needs to be whitelisted   /// @dev Can only be called after lockup _period has ended   function ownerRestake(uint256 _id, uint256 _period)     external     override     whenNotPaused     returns (uint256 _sher)   {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // Checks to make sure the staking period is a whitelisted one if (!stakingPeriods[_period]) revert InvalidArgument();  // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position _sher = _restake(_id, _period, msg.sender);  } // Calcs the reward (in stake shares) an arb would get for restaking a position   // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb   function calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {     // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)     uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME; // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position if (initialArbTime &gt; block.timestamp) return (0, false);  // The max rewards (as a % of the position's shares) for the arb are available at this timestamp uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;  // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100% uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;  // Scaled by 10**18 // Represents the max amount of stake shares that an arb could get from restaking this position uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];  // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled return (   ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,   true );  } /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position   /// @return profit How much profit an arb would make in USDC   /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)   function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {     // Returns the stake shares that an arb would get, and whether the position can currently be arbed     // profit variable is used to store the amount of shares     (profit, able) = _calcSharesForArbRestake(_id);     // Calculates the tokens (USDC) represented by that amount of stake shares     // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit     profit = _redeemSharesCalc(profit);   } /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)   /// @param _id ID of the position   /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup   /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function   /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)   /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)   /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)   function arbRestake(uint256 _id)     external     override     whenNotPaused     returns (uint256 _sher, uint256 _arbReward)   {     address nftOwner = ownerOf(_id); // Returns the stake shares that an arb would get, and whether the position can currently be arbed (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id); // Revert if not able to be arbed if (!able) revert InvalidConditions();  // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC paid to the arbitrager _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);  // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months) // Sends previously earned SHER rewards to the NFT owner address _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);  emit ArbRestaked(_id, _arbReward);  } } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: // SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n/***********\\n Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x)\n Sherlock Protocol: https://sherlock.xyz\n/***********/\nimport \'@openzeppelin/contracts/token/ERC20/IERC20.sol\';\nimport \'@openzeppelin/contracts/token/ERC721/ERC721.sol\';\nimport \'@openzeppelin/contracts/access/Ownable.sol\';\nimport \'@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\';\nimport \'@openzeppelin/contracts/security/Pausable.sol\';\nimport \'./interfaces/ISherlock.sol\';\n/// @title Sherlock core interface for stakers\n/// @author Evert Kors\n// This is the contract that manages staking actions\ncontract Sherlock is ISherlock, ERC721, Ownable, Pausable {\n  using SafeERC20 for IERC20;\n  // The initial period for a staker to restake/withdraw without being auto-restaked\n  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;\n  // The period during which the reward for restaking an account (after the inital period) grows\n  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;\n  // Anyone who gets auto-restaked is restaked for this period (3 months)\n  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;\n  // The percentage of someone\'s stake that can be paid to an arb for restaking\n  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (1018 / 100) * 20; // 20%\n  // USDC address\n  IERC20 public immutable token;\n  // SHER token address\n  IERC20 public immutable sher;\n  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not\n  mapping(uint256 =&gt; bool) public override stakingPeriods;\n  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked\n  mapping(uint256 =&gt; uint256) internal lockupEnd_;\n  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position\n  mapping(uint256 =&gt; uint256) internal sherRewards_;\n  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)\n  mapping(uint256 =&gt; uint256) internal stakeShares;\n  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.\n  mapping(address =&gt; uint256) internal addressShares;\n  // Total amount of shares that have been issued to all NFT positions\n  uint256 internal totalStakeShares;\n  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)\n  IStrategyManager public override yieldStrategy;\n  // Instances of relevant Sherlock contracts\n  ISherDistributionManager public override sherDistributionManager;\n  ISherlockProtocolManager public override sherlockProtocolManager;\n  ISherlockClaimManager public override sherlockClaimManager;\n  // Address to which nonstaker payments are made\n  // This will start out as a multi-sig address, then become a contract address later\n  address public override nonStakersAddress;\n  // Stores the ID of the most recently created NFT\n  // This variable is incremented by 1 to create a new NFT ID\n  uint256 internal nftCounter;\n  // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.\n  constructor(\n    IERC20 token, // USDC address\n    IERC20 _sher, // SHER token address\n    string memory _name, // Token collection name (see ERC-721 docs)\n    string memory _symbol, // Token collection symbol (see ERC-721 docs)\n    IStrategyManager _yieldStrategy, // The active yield strategy contract\n    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract\n    address _nonStakersAddress, // The address to which nonstakers payments go\n    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract\n    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract\n    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for\n  ) ERC721(_name, _symbol) {\n    if (address(_token) == address(0)) revert ZeroArgument();\n    if (address(_sher) == address(0)) revert ZeroArgument();\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();\n    if (_nonStakersAddress == address(0)) revert ZeroArgument();\n    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();\n    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();\n    token = _token;\n    sher = _sher;\n    yieldStrategy = _yieldStrategy;\n    sherDistributionManager = _sherDistributionManager;\n    nonStakersAddress = _nonStakersAddress;\n    sherlockProtocolManager = _sherlockProtocolManager;\n    sherlockClaimManager = _sherlockClaimManager;\n    // Enabling the first set of staking periods that were provided in constructor args\n    for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {\n      enableStakingPeriod(_initialstakingPeriods[i]);\n    }\n    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);\n    emit SherDistributionManagerUpdated(\n      ISherDistributionManager(address(0)),\n      _sherDistributionManager\n    );\n    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);\n    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);\n    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);\n  }\n  //\n  // View functions\n  //\n  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked\n  /// @notice View the current lockup end timestamp of _tokenID\n  /// @return Timestamp when NFT position unlocks\n  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n    return lockupEnd[tokenID];\n  }\n  // Returns the SHER rewards owed to this position\n  /// @notice View the current SHER reward of _tokenID\n  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup\n  function sherRewards(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n    return sherRewards[tokenID];\n  }\n  // Returns the tokens (USDC) owed to a position\n  /// @notice View the current token balance claimable upon reaching end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking position\n  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers\n    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;\n  }\n  // Returns the tokens (USDC) owed to an address\n  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking all positions\n  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {\n    if (_staker == address(0)) revert ZeroArgument();\n    uint256 _totalStakeShares = totalStakeShares;\n    if (_totalStakeShares == 0) return 0;\n    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers\n    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;\n  }\n  // Gets the total amount of tokens (USDC) owed to stakers\n  // Adds this contract\'s balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract\n  /// @notice View the current TVL for all stakers\n  /// @return Total amount of tokens staked\n  /// @dev Adds principal + strategy + premiums\n  /// @dev Will calculate the most up to date value for each piece\n  function totalTokenBalanceStakers() public view override returns (uint256) {\n    return\n      token.balanceOf(address(this)) +\n      yieldStrategy.balanceOf() +\n      sherlockProtocolManager.claimablePremiums();\n  }\n  //\n  // Gov functions\n  //\n  // Allows governance to add a new staking period (4 months, etc.)\n  /// @notice Allows stakers to stake for _period of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already enabled\n  function enableStakingPeriod(uint256 _period) public override onlyOwner {\n    if (_period == 0) revert ZeroArgument();\n    // Revert if staking period is already active\n    if (stakingPeriods[_period]) revert InvalidArgument();\n    // Sets the staking period to true\n    stakingPeriods[_period] = true;\n    emit StakingPeriodEnabled(_period);\n  }\n  // Allows governance to remove a staking period (4 months, etc.)\n  /// @notice Disallow stakers to stake for _period of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already disabled\n  function disableStakingPeriod(uint256 _period) external override onlyOwner {\n    // Revert if staking period is already inactive\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n    // Sets the staking period to false\n    stakingPeriods[_period] = false;\n    emit StakingPeriodDisabled(_period);\n  }\n  // Sets a new contract to be the active SHER distribution manager\n  /// @notice Update SHER distribution manager contract\n  /// @param _sherDistributionManager New adddress of the manager\n  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();\n    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();\n    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);\n    sherDistributionManager = _sherDistributionManager;\n  }\n  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)\n  /// @notice Remove SHER token rewards\n  function removeSherDistributionManager() external override onlyOwner {\n    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();\n    emit SherDistributionManagerUpdated(\n      sherDistributionManager,\n      ISherDistributionManager(address(0))\n    );\n    delete sherDistributionManager;\n  }\n  // Sets a new address for nonstakers payments\n  /// @notice Update address eligble for non staker rewards from protocol premiums\n  /// @param _nonStakers Address eligble for non staker rewards\n  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {\n    if (address(_nonStakers) == address(0)) revert ZeroArgument();\n    if (nonStakersAddress == _nonStakers) revert InvalidArgument();\n    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);\n    nonStakersAddress = _nonStakers;\n  }\n  // Sets a new protocol manager contract\n  /// @notice Transfer protocol manager implementation address\n  /// @param _protocolManager new implementation address\n  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_protocolManager) == address(0)) revert ZeroArgument();\n    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();\n    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);\n    sherlockProtocolManager = _protocolManager;\n  }\n  // Sets a new claim manager contract\n  /// @notice Transfer claim manager role to different address\n  /// @param _claimManager New address of claim manager\n  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_claimManager) == address(0)) revert ZeroArgument();\n    if (sherlockClaimManager == _claimManager) revert InvalidArgument();\n    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);\n    sherlockClaimManager = _claimManager;\n  }\n  // Sets a new yield strategy manager contract\n  /// @notice Update yield strategy\n  /// @param _yieldStrategy News address of the strategy\n  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure\n  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();\n    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail\n    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.\n    // In case this happens. We still want the yield strategy to be updated.\n    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.\n    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {\n      emit YieldStrategyUpdateWithdrawAllError(reason);\n    }\n    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);\n    yieldStrategy = _yieldStrategy;\n  }\n  // Deposits a chosen amount of tokens (USDC) into the active yield strategy\n  /// @notice Deposit _amount into active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {\n    if (_amount == 0) revert ZeroArgument();\n    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first\n    sherlockProtocolManager.claimPremiumsForStakers();\n    // Transfers the amount of tokens to the yield strategy contract\n    token.safeTransfer(address(yieldStrategy), _amount);\n    // Deposits all tokens in the yield strategy contract into the actual yield strategy\n    yieldStrategy.deposit();\n  }\n  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract\n  /// @notice Withdraw _amount from active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {\n    if (_amount == 0) revert ZeroArgument();\n    yieldStrategy.withdraw(_amount);\n  }\n  // Withdraws all tokens from the yield strategy back into this contract\n  /// @notice Withdraw all funds from active strategy\n  /// @dev gov only\n  function yieldStrategyWithdrawAll() external override onlyOwner {\n    yieldStrategy.withdrawAll();\n  }\n  /// @notice Pause external functions in all contracts\n  /// @dev A manager can be replaced with the new contract in a paused state\n  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused\n  function pause() external onlyOwner {\n    _pause();\n    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();\n    // sherDistributionManager can be 0, pause isn\'t needed in that case\n    if (\n      address(sherDistributionManager) != address(0) &amp;&amp;\n      !Pausable(address(sherDistributionManager)).paused()\n    ) {\n      sherDistributionManager.pause();\n    }\n    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();\n    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();\n  }\n  /// @notice Unpause external functions in all contracts\n  /// @dev A manager can be replaced with the new contract in an unpaused state\n  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused\n  function unpause() external onlyOwner {\n    _unpause();\n    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();\n    // sherDistributionManager can be 0, unpause isn\'t needed in that case\n    if (\n      address(sherDistributionManager) != address(0) &amp;&amp;\n      Pausable(address(sherDistributionManager)).paused()\n    ) {\n      sherDistributionManager.unpause();\n    }\n    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();\n    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();\n  }\n  //\n  // Access control functions\n  //\n  /// @notice Account sum of all underlying posiiton shares for _from and _to\n  /// @dev this enables the tokenBalanceOfAddress to exist\n  function _beforeTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenID\n  ) internal override {\n    uint256 _stakeShares = stakeShares[_tokenID];\n    if (_from != address(0)) addressShares[_from] -= _stakeShares;\n    if (_to != address(0)) addressShares[_to] += _stakeShares;\n  }\n  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)\n  // This function is called by the Sherlock claim manager contract if a claim is approved\n  /// @notice Initiate a payout of _amount to _receiver\n  /// @param _receiver Receiver of payout\n  /// @param _amount Amount to send\n  /// @dev only payout manager should call this\n  /// @dev should pull money out of strategy\n  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {\n    // Can only be called by the Sherlock claim manager contract\n    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();\n    if (_amount != 0) {\n      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)\n      _transferTokensOut(_receiver, _amount);\n    }\n    emit ClaimPayout(_receiver, _amount);\n  }\n  //\n  // Non-access control functions\n  //\n  // Helper function for initial staking and restaking\n  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position\n  /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time for which funds get locked\n  /// @param _id ID for this NFT position\n  /// @param _receiver Address that will be linked to this position\n  /// @return _sher Amount of SHER tokens awarded to this position after _period ends\n  /// @dev _period needs to be whitelisted\n  function _stake(\n    uint256 _amount,\n    uint256 _period,\n    uint256 _id,\n    address _receiver\n  ) internal returns (uint256 _sher) {\n    // Sets the timestamp at which this position can first be unstaked/restaked\n    lockupEnd[id] = block.timestamp + _period;\n    if (address(sherDistributionManager) == address(0)) return 0;\n    // Does not allow restaking of 0 tokens\n    if (_amount == 0) return 0;\n    // Checks this amount of SHER tokens in this contract before we transfer new ones\n    uint256 before = sher.balanceOf(address(this));\n    // pullReward() calcs then actually transfers the SHER tokens to this contract\n    // in case this call fails, whole (re)staking transaction fails\n    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);\n    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position\n    uint256 actualAmount = sher.balanceOf(address(this)) - before;\n    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);\n    // Assigns the newly created SHER tokens to the current stake position\n    if (_sher != 0) sherRewards[id] = _sher;\n  }\n  // Checks to see if the NFT owner is the caller and that the position is unlockable\n  function _verifyUnlockableByOwner(uint256 _id) internal view {\n    if (ownerOf(_id) != msg.sender) revert Unauthorized();\n    if (lockupEnd[id] &gt; block.timestamp) revert InvalidConditions();\n  }\n  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner\n  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {\n    uint256 sherReward = sherRewards[id];\n    if (sherReward == 0) return;\n    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner\n    sher.safeTransfer(_nftOwner, sherReward);\n    // Deletes the SHER reward mapping for this NFT ID\n    delete sherRewards[id];\n  }\n  // Transfers an amount of tokens to the receiver address\n  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)\n  function _transferTokensOut(address _receiver, uint256 _amount) internal {\n    // Transfers any premiums owed to stakers from the protocol manager to this contract\n    sherlockProtocolManager.claimPremiumsForStakers();\n    // The amount of tokens in this contract\n    uint256 mainBalance = token.balanceOf(address(this));\n    // If the amount to transfer out is still greater than the amount of tokens in this contract,\n    // Withdraw yield strategy tokens to make up the difference\n    if (_amount &gt; mainBalance) {\n      yieldStrategy.withdraw(_amount - mainBalance);\n    }\n    token.safeTransfer(_receiver, _amount);\n  }\n  // Returns the amount of USDC owed to this amount of stakeShares\n  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {\n    // Finds fraction that the given amount of stakeShares represents of the total\n    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers\n    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;\n  }\n  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted\n  // Also burns the requisite amount of shares associated with this NFT position\n  // Returns the amount of USDC owed to these shares\n  function _redeemShares(\n    uint256 _id,\n    uint256 _stakeShares,\n    address _receiver\n  ) internal returns (uint256 _amount) {\n    // Returns the amount of USDC owed to this amount of stakeShares\n    _amount = _redeemSharesCalc(_stakeShares);\n    // Transfers _amount of tokens to _receiver address\n    if (_amount != 0) _transferTokensOut(_receiver, _amount);\n    // Subtracts this amount of stakeShares from the NFT position\n    stakeShares[_id] -= _stakeShares;\n    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding\n    totalStakeShares -= _stakeShares;\n  }\n  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager\n  // Restakes an NFT position (_id) for a given period (_period) and\n  // Sends any previously earned SHER rewards to the _nftOwner address\n  function _restake(\n    uint256 _id,\n    uint256 _period,\n    address _nftOwner\n  ) internal returns (uint256 _sher) {\n    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner\n    // NOTE This function deletes the SHER reward mapping for this NFT ID\n    _sendSherRewardsToOwner(_id, _nftOwner);\n    // tokenBalanceOf() returns the USDC amount owed to this NFT ID\n    // _stake() restakes that amount of USDC for the period inputted\n    // We use the same ID that we just deleted the SHER rewards mapping for\n    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID\n    // Note stakeShares for this position do not change so no need to update\n    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);\n    emit Restaked(_id);\n  }\n  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)\n  /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @param _receiver Address that will receive the NFT representing the position\n  /// @return _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to this ID after _period ends\n  /// @dev _period needs to be whitelisted\n  function initialStake(\n    uint256 _amount,\n    uint256 _period,\n    address _receiver\n  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {\n    if (_amount == 0) revert ZeroArgument();\n    // Makes sure the period is a whitelisted period\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n    if (address(_receiver) == address(0)) revert ZeroArgument();\n    // Adds 1 to the ID of the last NFT created for the new NFT ID\n    _id = ++nftCounter;\n    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)\n    token.safeTransferFrom(msg.sender, address(this), _amount);\n    uint256 stakeShares;\n    uint256 totalStakeShares_ = totalStakeShares;\n    // amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares\n    if (totalStakeShares != 0)\n      stakeShares_ = (amount * totalStakeShares) / (totalTokenBalanceStakers() - amount);\n      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked\n    else stakeShares = amount;\n    // Assigns this NFT ID the calc\'d amount of stake shares above\n    stakeShares[_id] = stakeShares;\n    // Adds the newly created stake shares to the total amount of stake shares\n    totalStakeShares += stakeShares_;\n    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake\n    sher = _stake(_amount, _period, _id, _receiver);\n    // This is an ERC-721 function that creates an NFT and sends it to the receiver\n    _safeMint(_receiver, _id);\n  }\n  // This is how a staker unstakes and cashes out on their position\n  /// @notice Redeem NFT _id and receive _amount of tokens\n  /// @param _id TokenID of the position\n  /// @return _amount Amount of tokens (USDC) owed to NFT ID\n  /// @dev Only the owner of _id will be able to redeem their position\n  /// @dev The SHER rewards are sent to the NFT owner\n  /// @dev Can only be called after lockup _period has ended\n  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {\n    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over\n    _verifyUnlockableByOwner(_id);\n    // This is the ERC-721 function to destroy an NFT (with owner\'s approval)\n    _burn(_id);\n    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID\n    // Also burns the requisite amount of shares associated with this NFT position\n    // Returns the amount of USDC owed to these shares\n    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);\n    // Sends the SHER tokens associated with this NFT ID to the NFT owner\n    _sendSherRewardsToOwner(_id, msg.sender);\n    // Removes the unlock deadline associated with this NFT\n    delete lockupEnd[id];\n  }\n  // This is how a staker restakes an expired position\n  /// @notice Owner restakes position with ID: _id for _period seconds\n  /// @param _id ID of the position\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @return _sher Amount of SHER tokens to be released to owner address after _period ends\n  /// @dev Only the owner of _id will be able to restake their position using this call\n  /// @dev _period needs to be whitelisted\n  /// @dev Can only be called after lockup _period has ended\n  function ownerRestake(uint256 _id, uint256 _period)\n    external\n    override\n    whenNotPaused\n    returns (uint256 _sher)\n  {\n    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over\n    _verifyUnlockableByOwner(_id);\n    // Checks to make sure the staking period is a whitelisted one\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position\n    _sher = _restake(_id, _period, msg.sender);\n  }\n  // Calcs the reward (in stake shares) an arb would get for restaking a position\n  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb\n  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {\n    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)\n    uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME;\n    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position\n    if (initialArbTime &gt; block.timestamp) return (0, false);\n    // The max rewards (as a % of the position\'s shares) for the arb are available at this timestamp\n    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;\n    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%\n    uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;\n    // Scaled by 1018\n    // Represents the max amount of stake shares that an arb could get from restaking this position\n    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[id];\n    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function\n    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled\n    return (\n      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 1018,\n      true\n    );\n  }\n  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position\n  /// @return profit How much profit an arb would make in USDC\n  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)\n  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {\n    // Returns the stake shares that an arb would get, and whether the position can currently be arbed\n    // profit variable is used to store the amount of shares\n    (profit, able) = _calcSharesForArbRestake(_id);\n    // Calculates the tokens (USDC) represented by that amount of stake shares\n    // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit\n    profit = _redeemSharesCalc(profit);\n  }\n  /// @notice Allows someone who doesn\'t own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)\n  /// @param _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup\n  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function\n  /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)\n  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)\n  /// @dev During a 2 week period the reward ratio will move from 0% to 100% ( x)\n  function arbRestake(uint256 _id)\n    external\n    override\n    whenNotPaused\n    returns (uint256 _sher, uint256 _arbReward)\n  {\n    address nftOwner = ownerOf(_id);\n    // Returns the stake shares that an arb would get, and whether the position can currently be arbed\n    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);\n    // Revert if not able to be arbed\n    if (!able) revert InvalidConditions();\n    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward\n    // Also burns the requisite amount of shares associated with this NFT position\n    // Returns the amount of USDC paid to the arbitrager\n    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);\n    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)\n    // Sends previously earned SHER rewards to the NFT owner address\n    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);\n    emit ArbRestaked(_id, _arbReward);\n  }\n}\n.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n/***********\\n Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x)\n Sherlock Protocol: https://sherlock.xyz\n/************/\nimport \'@openzeppelin/contracts/token/ERC20/IERC20.sol\';\nimport \'@openzeppelin/contracts/token/ERC721/ERC721.sol\';\nimport \'@openzeppelin/contracts/access/Ownable.sol\';\nimport \'@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\';\nimport \'@openzeppelin/contracts/security/Pausable.sol\';\nimport \'./interfaces/ISherlock.sol\';\n/// @title Sherlock core interface for stakers\n/// @author Evert Kors\n// This is the contract that manages staking actions\ncontract Sherlock is ISherlock, ERC721, Ownable, Pausable {\n  using SafeERC20 for IERC20;\n  // The initial period for a staker to restake/withdraw without being auto-restaked\n  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;\n  // The period during which the reward for restaking an account (after the inital period) grows\n  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;\n  // Anyone who gets auto-restaked is restaked for this period (3 months)\n  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;\n  // The percentage of someone\'s stake that can be paid to an arb for restaking\n  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (1018 / 100) * 20; // 20%\n  // USDC address\n  IERC20 public immutable token;\n  // SHER token address\n  IERC20 public immutable sher;\n  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not\n  mapping(uint256 =&gt; bool) public override stakingPeriods;\n  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked\n  mapping(uint256 =&gt; uint256) internal lockupEnd;\n  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position\n  mapping(uint256 =&gt; uint256) internal sherRewards_;\n  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)\n  mapping(uint256 =&gt; uint256) internal stakeShares;\n  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.\n  mapping(address =&gt; uint256) internal addressShares;\n  // Total amount of shares that have been issued to all NFT positions\n  uint256 internal totalStakeShares;\n  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)\n  IStrategyManager public override yieldStrategy;\n  // Instances of relevant Sherlock contracts\n  ISherDistributionManager public override sherDistributionManager;\n  ISherlockProtocolManager public override sherlockProtocolManager;\n  ISherlockClaimManager public override sherlockClaimManager;\n  // Address to which nonstaker payments are made\n  // This will start out as a multi-sig address, then become a contract address later\n  address public override nonStakersAddress;\n  // Stores the ID of the most recently created NFT\n  // This variable is incremented by 1 to create a new NFT ID\n  uint256 internal nftCounter;\n  // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.\n  constructor(\n    IERC20 token, // USDC address\n    IERC20 _sher, // SHER token address\n    string memory _name, // Token collection name (see ERC-721 docs)\n    string memory _symbol, // Token collection symbol (see ERC-721 docs)\n    IStrategyManager _yieldStrategy, // The active yield strategy contract\n    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract\n    address _nonStakersAddress, // The address to which nonstakers payments go\n    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract\n    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract\n    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for\n  ) ERC721(_name, _symbol) {\n    if (address(_token) == address(0)) revert ZeroArgument();\n    if (address(_sher) == address(0)) revert ZeroArgument();\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();\n    if (_nonStakersAddress == address(0)) revert ZeroArgument();\n    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();\n    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();\n    token = _token;\n    sher = _sher;\n    yieldStrategy = _yieldStrategy;\n    sherDistributionManager = _sherDistributionManager;\n    nonStakersAddress = _nonStakersAddress;\n    sherlockProtocolManager = _sherlockProtocolManager;\n    sherlockClaimManager = _sherlockClaimManager;\n    // Enabling the first set of staking periods that were provided in constructor args\n    for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {\n      enableStakingPeriod(_initialstakingPeriods[i]);\n    }\n    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);\n    emit SherDistributionManagerUpdated(\n      ISherDistributionManager(address(0)),\n      _sherDistributionManager\n    );\n    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);\n    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);\n    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);\n  }\n  //\n  // View functions\n  //\n  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked\n  /// @notice View the current lockup end timestamp of _tokenID\n  /// @return Timestamp when NFT position unlocks\n  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n    return lockupEnd[tokenID];\n  }\n  // Returns the SHER rewards owed to this position\n  /// @notice View the current SHER reward of _tokenID\n  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup\n  function sherRewards(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n    return sherRewards[tokenID];\n  }\n  // Returns the tokens (USDC) owed to a position\n  /// @notice View the current token balance claimable upon reaching end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking position\n  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers\n    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;\n  }\n  // Returns the tokens (USDC) owed to an address\n  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking all positions\n  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {\n    if (_staker == address(0)) revert ZeroArgument();\n    uint256 _totalStakeShares = totalStakeShares;\n    if (_totalStakeShares == 0) return 0;\n    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers\n    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;\n  }\n  // Gets the total amount of tokens (USDC) owed to stakers\n  // Adds this contract\'s balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract\n  /// @notice View the current TVL for all stakers\n  /// @return Total amount of tokens staked\n  /// @dev Adds principal + strategy + premiums\n  /// @dev Will calculate the most up to date value for each piece\n  function totalTokenBalanceStakers() public view override returns (uint256) {\n    return\n      token.balanceOf(address(this)) +\n      yieldStrategy.balanceOf() +\n      sherlockProtocolManager.claimablePremiums();\n  }\n  //\n  // Gov functions\n  //\n  // Allows governance to add a new staking period (4 months, etc.)\n  /// @notice Allows stakers to stake for _period of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already enabled\n  function enableStakingPeriod(uint256 _period) public override onlyOwner {\n    if (_period == 0) revert ZeroArgument();\n    // Revert if staking period is already active\n    if (stakingPeriods[_period]) revert InvalidArgument();\n    // Sets the staking period to true\n    stakingPeriods[_period] = true;\n    emit StakingPeriodEnabled(_period);\n  }\n  // Allows governance to remove a staking period (4 months, etc.)\n  /// @notice Disallow stakers to stake for _period of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already disabled\n  function disableStakingPeriod(uint256 _period) external override onlyOwner {\n    // Revert if staking period is already inactive\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n    // Sets the staking period to false\n    stakingPeriods[_period] = false;\n    emit StakingPeriodDisabled(_period);\n  }\n  // Sets a new contract to be the active SHER distribution manager\n  /// @notice Update SHER distribution manager contract\n  /// @param _sherDistributionManager New adddress of the manager\n  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();\n    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();\n    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);\n    sherDistributionManager = _sherDistributionManager;\n  }\n  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)\n  /// @notice Remove SHER token rewards\n  function removeSherDistributionManager() external override onlyOwner {\n    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();\n    emit SherDistributionManagerUpdated(\n      sherDistributionManager,\n      ISherDistributionManager(address(0))\n    );\n    delete sherDistributionManager;\n  }\n  // Sets a new address for nonstakers payments\n  /// @notice Update address eligble for non staker rewards from protocol premiums\n  /// @param _nonStakers Address eligble for non staker rewards\n  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {\n    if (address(_nonStakers) == address(0)) revert ZeroArgument();\n    if (nonStakersAddress == _nonStakers) revert InvalidArgument();\n    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);\n    nonStakersAddress = _nonStakers;\n  }\n  // Sets a new protocol manager contract\n  /// @notice Transfer protocol manager implementation address\n  /// @param _protocolManager new implementation address\n  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_protocolManager) == address(0)) revert ZeroArgument();\n    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();\n    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);\n    sherlockProtocolManager = _protocolManager;\n  }\n  // Sets a new claim manager contract\n  /// @notice Transfer claim manager role to different address\n  /// @param _claimManager New address of claim manager\n  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_claimManager) == address(0)) revert ZeroArgument();\n    if (sherlockClaimManager == _claimManager) revert InvalidArgument();\n    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);\n    sherlockClaimManager = _claimManager;\n  }\n  // Sets a new yield strategy manager contract\n  /// @notice Update yield strategy\n  /// @param _yieldStrategy News address of the strategy\n  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure\n  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();\n    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail\n    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.\n    // In case this happens. We still want the yield strategy to be updated.\n    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.\n    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {\n      emit YieldStrategyUpdateWithdrawAllError(reason);\n    }\n    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);\n    yieldStrategy = _yieldStrategy;\n  }\n  // Deposits a chosen amount of tokens (USDC) into the active yield strategy\n  /// @notice Deposit _amount into active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {\n    if (_amount == 0) revert ZeroArgument();\n    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first\n    sherlockProtocolManager.claimPremiumsForStakers();\n    // Transfers the amount of tokens to the yield strategy contract\n    token.safeTransfer(address(yieldStrategy), _amount);\n    // Deposits all tokens in the yield strategy contract into the actual yield strategy\n    yieldStrategy.deposit();\n  }\n  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract\n  /// @notice Withdraw _amount from active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {\n    if (_amount == 0) revert ZeroArgument();\n    yieldStrategy.withdraw(_amount);\n  }\n  // Withdraws all tokens from the yield strategy back into this contract\n  /// @notice Withdraw all funds from active strategy\n  /// @dev gov only\n  function yieldStrategyWithdrawAll() external override onlyOwner {\n    yieldStrategy.withdrawAll();\n  }\n  /// @notice Pause external functions in all contracts\n  /// @dev A manager can be replaced with the new contract in a paused state\n  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused\n  function pause() external onlyOwner {\n    _pause();\n    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();\n    // sherDistributionManager can be 0, pause isn\'t needed in that case\n    if (\n      address(sherDistributionManager) != address(0) &amp;&amp;\n      !Pausable(address(sherDistributionManager)).paused()\n    ) {\n      sherDistributionManager.pause();\n    }\n    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();\n    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();\n  }\n  /// @notice Unpause external functions in all contracts\n  /// @dev A manager can be replaced with the new contract in an unpaused state\n  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused\n  function unpause() external onlyOwner {\n    _unpause();\n    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();\n    // sherDistributionManager can be 0, unpause isn\'t needed in that case\n    if (\n      address(sherDistributionManager) != address(0) &amp;&amp;\n      Pausable(address(sherDistributionManager)).paused()\n    ) {\n      sherDistributionManager.unpause();\n    }\n    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();\n    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();\n  }\n  //\n  // Access control functions\n  //\n  /// @notice Account sum of all underlying posiiton shares for _from and _to\n  /// @dev this enables the tokenBalanceOfAddress to exist\n  function _beforeTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenID\n  ) internal override {\n    uint256 _stakeShares = stakeShares[_tokenID];\n    if (_from != address(0)) addressShares[_from] -= _stakeShares;\n    if (_to != address(0)) addressShares[_to] += _stakeShares;\n  }\n  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)\n  // This function is called by the Sherlock claim manager contract if a claim is approved\n  /// @notice Initiate a payout of _amount to _receiver\n  /// @param _receiver Receiver of payout\n  /// @param _amount Amount to send\n  /// @dev only payout manager should call this\n  /// @dev should pull money out of strategy\n  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {\n    // Can only be called by the Sherlock claim manager contract\n    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();\n    if (_amount != 0) {\n      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)\n      _transferTokensOut(_receiver, _amount);\n    }\n    emit ClaimPayout(_receiver, _amount);\n  }\n  //\n  // Non-access control functions\n  //\n  // Helper function for initial staking and restaking\n  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position\n  /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time for which funds get locked\n  /// @param _id ID for this NFT position\n  /// @param _receiver Address that will be linked to this position\n  /// @return _sher Amount of SHER tokens awarded to this position after _period ends\n  /// @dev _period needs to be whitelisted\n  function _stake(\n    uint256 _amount,\n    uint256 _period,\n    uint256 _id,\n    address _receiver\n  ) internal returns (uint256 _sher) {\n    // Sets the timestamp at which this position can first be unstaked/restaked\n    lockupEnd[id] = block.timestamp + _period;\n    if (address(sherDistributionManager) == address(0)) return 0;\n    // Does not allow restaking of 0 tokens\n    if (_amount == 0) return 0;\n    // Checks this amount of SHER tokens in this contract before we transfer new ones\n    uint256 before = sher.balanceOf(address(this));\n    // pullReward() calcs then actually transfers the SHER tokens to this contract\n    // in case this call fails, whole (re)staking transaction fails\n    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);\n    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position\n    uint256 actualAmount = sher.balanceOf(address(this)) - before;\n    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);\n    // Assigns the newly created SHER tokens to the current stake position\n    if (_sher != 0) sherRewards[id] = _sher;\n  }\n  // Checks to see if the NFT owner is the caller and that the position is unlockable\n  function _verifyUnlockableByOwner(uint256 _id) internal view {\n    if (ownerOf(_id) != msg.sender) revert Unauthorized();\n    if (lockupEnd[id] &gt; block.timestamp) revert InvalidConditions();\n  }\n  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner\n  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {\n    uint256 sherReward = sherRewards[id];\n    if (sherReward == 0) return;\n    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner\n    sher.safeTransfer(_nftOwner, sherReward);\n    // Deletes the SHER reward mapping for this NFT ID\n    delete sherRewards[id];\n  }\n  // Transfers an amount of tokens to the receiver address\n  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)\n  function _transferTokensOut(address _receiver, uint256 _amount) internal {\n    // Transfers any premiums owed to stakers from the protocol manager to this contract\n    sherlockProtocolManager.claimPremiumsForStakers();\n    // The amount of tokens in this contract\n    uint256 mainBalance = token.balanceOf(address(this));\n    // If the amount to transfer out is still greater than the amount of tokens in this contract,\n    // Withdraw yield strategy tokens to make up the difference\n    if (_amount &gt; mainBalance) {\n      yieldStrategy.withdraw(_amount - mainBalance);\n    }\n    token.safeTransfer(_receiver, _amount);\n  }\n  // Returns the amount of USDC owed to this amount of stakeShares\n  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {\n    // Finds fraction that the given amount of stakeShares represents of the total\n    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers\n    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;\n  }\n  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted\n  // Also burns the requisite amount of shares associated with this NFT position\n  // Returns the amount of USDC owed to these shares\n  function _redeemShares(\n    uint256 _id,\n    uint256 _stakeShares,\n    address _receiver\n  ) internal returns (uint256 _amount) {\n    // Returns the amount of USDC owed to this amount of stakeShares\n    _amount = _redeemSharesCalc(_stakeShares);\n    // Transfers _amount of tokens to _receiver address\n    if (_amount != 0) _transferTokensOut(_receiver, _amount);\n    // Subtracts this amount of stakeShares from the NFT position\n    stakeShares[_id] -= _stakeShares;\n    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding\n    totalStakeShares -= _stakeShares;\n  }\n  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager\n  // Restakes an NFT position (_id) for a given period (_period) and\n  // Sends any previously earned SHER rewards to the _nftOwner address\n  function _restake(\n    uint256 _id,\n    uint256 _period,\n    address _nftOwner\n  ) internal returns (uint256 _sher) {\n    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner\n    // NOTE This function deletes the SHER reward mapping for this NFT ID\n    _sendSherRewardsToOwner(_id, _nftOwner);\n    // tokenBalanceOf() returns the USDC amount owed to this NFT ID\n    // _stake() restakes that amount of USDC for the period inputted\n    // We use the same ID that we just deleted the SHER rewards mapping for\n    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID\n    // Note stakeShares for this position do not change so no need to update\n    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);\n    emit Restaked(_id);\n  }\n  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)\n  /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @param _receiver Address that will receive the NFT representing the position\n  /// @return _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to this ID after _period ends\n  /// @dev _period needs to be whitelisted\n  function initialStake(\n    uint256 _amount,\n    uint256 _period,\n    address _receiver\n  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {\n    if (_amount == 0) revert ZeroArgument();\n    // Makes sure the period is a whitelisted period\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n    if (address(_receiver) == address(0)) revert ZeroArgument();\n    // Adds 1 to the ID of the last NFT created for the new NFT ID\n    _id = ++nftCounter;\n    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)\n    token.safeTransferFrom(msg.sender, address(this), _amount);\n    uint256 stakeShares;\n    uint256 totalStakeShares_ = totalStakeShares;\n    // amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares\n    if (totalStakeShares != 0)\n      stakeShares_ = (amount * totalStakeShares) / (totalTokenBalanceStakers() - amount);\n      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked\n    else stakeShares = amount;\n    // Assigns this NFT ID the calc\'d amount of stake shares above\n    stakeShares[_id] = stakeShares;\n    // Adds the newly created stake shares to the total amount of stake shares\n    totalStakeShares += stakeShares_;\n    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake\n    sher = _stake(_amount, _period, _id, _receiver);\n    // This is an ERC-721 function that creates an NFT and sends it to the receiver\n    _safeMint(_receiver, _id);\n  }\n  // This is how a staker unstakes and cashes out on their position\n  /// @notice Redeem NFT _id and receive _amount of tokens\n  /// @param _id TokenID of the position\n  /// @return _amount Amount of tokens (USDC) owed to NFT ID\n  /// @dev Only the owner of _id will be able to redeem their position\n  /// @dev The SHER rewards are sent to the NFT owner\n  /// @dev Can only be called after lockup _period has ended\n  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {\n    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over\n    _verifyUnlockableByOwner(_id);\n    // This is the ERC-721 function to destroy an NFT (with owner\'s approval)\n    _burn(_id);\n    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID\n    // Also burns the requisite amount of shares associated with this NFT position\n    // Returns the amount of USDC owed to these shares\n    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);\n    // Sends the SHER tokens associated with this NFT ID to the NFT owner\n    _sendSherRewardsToOwner(_id, msg.sender);\n    // Removes the unlock deadline associated with this NFT\n    delete lockupEnd[id];\n  }\n  // This is how a staker restakes an expired position\n  /// @notice Owner restakes position with ID: _id for _period seconds\n  /// @param _id ID of the position\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @return _sher Amount of SHER tokens to be released to owner address after _period ends\n  /// @dev Only the owner of _id will be able to restake their position using this call\n  /// @dev _period needs to be whitelisted\n  /// @dev Can only be called after lockup _period has ended\n  function ownerRestake(uint256 _id, uint256 _period)\n    external\n    override\n    whenNotPaused\n    returns (uint256 _sher)\n  {\n    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over\n    _verifyUnlockableByOwner(_id);\n    // Checks to make sure the staking period is a whitelisted one\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position\n    _sher = _restake(_id, _period, msg.sender);\n  }\n  // Calcs the reward (in stake shares) an arb would get for restaking a position\n  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb\n  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {\n    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)\n    uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME;\n    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position\n    if (initialArbTime &gt; block.timestamp) return (0, false);\n    // The max rewards (as a % of the position\'s shares) for the arb are available at this timestamp\n    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;\n    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%\n    uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;\n    // Scaled by 1018\n    // Represents the max amount of stake shares that an arb could get from restaking this position\n    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];\n    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function\n    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled\n    return (\n      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 1018,\n      true\n    );\n  }\n  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position\n  /// @return profit How much profit an arb would make in USDC\n  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)\n  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {\n    // Returns the stake shares that an arb would get, and whether the position can currently be arbed\n    // profit variable is used to store the amount of shares\n    (profit, able) = _calcSharesForArbRestake(_id);\n    // Calculates the tokens (USDC) represented by that amount of stake shares\n    // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit\n    profit = _redeemSharesCalc(profit);\n  }\n  /// @notice Allows someone who doesn\'t own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)\n  /// @param _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup\n  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function\n  /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)\n  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)\n  /// @dev During a 2 week period the reward ratio will move from 0% to 100% ( x)\n  function arbRestake(uint256 _id)\n    external\n    override\n    whenNotPaused\n    returns (uint256 _sher, uint256 _arbReward)\n  {\n    address nftOwner = ownerOf(_id);\n    // Returns the stake shares that an arb would get, and whether the position can currently be arbed\n    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);\n    // Revert if not able to be arbed\n    if (!able) revert InvalidConditions();\n    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward\n    // Also burns the requisite amount of shares associated with this NFT position\n    // Returns the amount of USDC paid to the arbitrager\n    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);\n    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)\n    // Sends previously earned SHER rewards to the NFT owner address\n    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);\n    emit ArbRestaked(_id, _arbReward);\n  }\n}\n".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Let\'s analyze the provided Solidity contract and brainstorm potential improvements or enhancements.\n1. Reentrancy Guard: The contract currently does not implement any protection against reentrancy attacks, especially in functions that transfer tokens or interact with external contracts (like payoutClaim, yieldStrategyWithdraw, etc.). We could implement a reentrancy guard using the nonReentrant modifier from OpenZeppelin.\n2. Event Emission for State Changes: While there are several events emitted, we could ensure that every state-changing function emits an event. For example, functions like enableStakingPeriod, disableStakingPeriod, and others that modify mappings could benefit from additional events to track changes more effectively.\n3. Gas Optimization: We could optimize the gas usage in functions by minimizing state variable reads and writes. For instance, in the _redeemSharesCalc function, we could cache totalTokenBalanceStakers() in a local variable to avoid multiple calls.\n4. Access Control Enhancements: Currently, the onlyOwner modifier is used for several functions. We could consider implementing role-based access control using OpenZeppelin\'s AccessControl to allow for more granular permissions in the future.\n5. Input Validation: While there are some checks in place, we could enhance input validation in functions like initialStake and ownerRestake to ensure that the _period is not only whitelisted but also falls within a reasonable range to prevent potential misuse.\n6. Upgradeability: If the contract is intended to be used long-term, we could consider implementing a proxy pattern for upgradeability. This would allow for future improvements without losing the state of the contract.\n7. Emergency Withdrawals: Implementing a mechanism for emergency withdrawals could be beneficial in case of unforeseen circumstances, allowing users to withdraw their funds without waiting for the lockup period to end.\n8. Detailed Documentation: While the contract has some comments, enhancing the documentation for each function, especially the more complex ones, could improve maintainability and understanding for future developers.\n9. Testing and Auditing: Ensure that comprehensive unit tests are written for all functionalities, especially edge cases. Additionally, consider a third-party audit for security assurance.\n10. User Feedback Mechanism*: Implementing a way for users to provide feedback or report issues directly through the contract could enhance user engagement and trust.\nWhich of these suggestions do you think would be the most impactful, or do you have any other ideas to add?', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-25-08 10:36:56 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@openzeppelin/contracts/token/ERC721/ERC721.sol'; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol'; import '@openzeppelin/contracts/security/Pausable.sol'; import './interfaces/ISherlock.sol'; /// @title Sherlock core interface for stakers /// @author Evert Kors // This is the contract that manages staking actions contract Sherlock is ISherlock, ERC721, Ownable, Pausable {   using SafeERC20 for IERC20; // The initial period for a staker to restake/withdraw without being auto-restaked   uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks; // The period during which the reward for restaking an account (after the inital period) grows   uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks; // Anyone who gets auto-restaked is restaked for this period (3 months)   uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks; // The percentage of someone's stake that can be paid to an arb for restaking   uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20% // USDC address   IERC20 public immutable token; // SHER token address   IERC20 public immutable sher; // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not   mapping(uint256 =&gt; bool) public override stakingPeriods; // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked   mapping(uint256 =&gt; uint256) internal lockupEnd_; // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position   mapping(uint256 =&gt; uint256) internal sherRewards_; // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)   mapping(uint256 =&gt; uint256) internal stakeShares; // Key is account, value is the sum of underlying shares of all the NFTs the account owns.   mapping(address =&gt; uint256) internal addressShares; // Total amount of shares that have been issued to all NFT positions   uint256 internal totalStakeShares; // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)   IStrategyManager public override yieldStrategy; // Instances of relevant Sherlock contracts   ISherDistributionManager public override sherDistributionManager;   ISherlockProtocolManager public override sherlockProtocolManager;   ISherlockClaimManager public override sherlockClaimManager; // Address to which nonstaker payments are made   // This will start out as a multi-sig address, then become a contract address later   address public override nonStakersAddress; // Stores the ID of the most recently created NFT   // This variable is incremented by 1 to create a new NFT ID   uint256 internal nftCounter; // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.   constructor(     IERC20 _token, // USDC address     IERC20 _sher, // SHER token address     string memory _name, // Token collection name (see ERC-721 docs)     string memory _symbol, // Token collection symbol (see ERC-721 docs)     IStrategyManager _yieldStrategy, // The active yield strategy contract     ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract     address _nonStakersAddress, // The address to which nonstakers payments go     ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract     ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract     uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for   ) ERC721(_name, _symbol) {     if (address(_token) == address(0)) revert ZeroArgument();     if (address(_sher) == address(0)) revert ZeroArgument();     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (_nonStakersAddress == address(0)) revert ZeroArgument();     if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();     if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument(); token = _token; sher = _sher; yieldStrategy = _yieldStrategy; sherDistributionManager = _sherDistributionManager; nonStakersAddress = _nonStakersAddress; sherlockProtocolManager = _sherlockProtocolManager; sherlockClaimManager = _sherlockClaimManager;  // Enabling the first set of staking periods that were provided in constructor args for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {   enableStakingPeriod(_initialstakingPeriods[i]); }  emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy); emit SherDistributionManagerUpdated(   ISherDistributionManager(address(0)),   _sherDistributionManager ); emit NonStakerAddressUpdated(address(0), _nonStakersAddress); emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager); emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);  } //   // View functions   // // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked   /// @notice View the current lockup end timestamp of _tokenID   /// @return Timestamp when NFT position unlocks   function lockupEnd(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return lockupEnd_[_tokenID];  } // Returns the SHER rewards owed to this position   /// @notice View the current SHER reward of _tokenID   /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup   function sherRewards(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return sherRewards_[_tokenID];  } // Returns the tokens (USDC) owed to a position   /// @notice View the current token balance claimable upon reaching end of the lockup   /// @return Amount of tokens assigned to owner when unstaking position   function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent();     // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers     return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;   } // Returns the tokens (USDC) owed to an address   /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup   /// @return Amount of tokens assigned to owner when unstaking all positions   function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {     if (_staker == address(0)) revert ZeroArgument();     uint256 _totalStakeShares = totalStakeShares;     if (_totalStakeShares == 0) return 0;     // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers     return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;   } // Gets the total amount of tokens (USDC) owed to stakers   // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract   /// @notice View the current TVL for all stakers   /// @return Total amount of tokens staked   /// @dev Adds principal + strategy + premiums   /// @dev Will calculate the most up to date value for each piece   function totalTokenBalanceStakers() public view override returns (uint256) {     return       token.balanceOf(address(this)) +       yieldStrategy.balanceOf() +       sherlockProtocolManager.claimablePremiums();   } //   // Gov functions   // // Allows governance to add a new staking period (4 months, etc.)   /// @notice Allows stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already enabled   function enableStakingPeriod(uint256 _period) public override onlyOwner {     if (_period == 0) revert ZeroArgument();     // Revert if staking period is already active     if (stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to true stakingPeriods[_period] = true; emit StakingPeriodEnabled(_period);  } // Allows governance to remove a staking period (4 months, etc.)   /// @notice Disallow stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already disabled   function disableStakingPeriod(uint256 _period) external override onlyOwner {     // Revert if staking period is already inactive     if (!stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to false stakingPeriods[_period] = false; emit StakingPeriodDisabled(_period);  } // Sets a new contract to be the active SHER distribution manager   /// @notice Update SHER distribution manager contract   /// @param _sherDistributionManager New adddress of the manager   function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)     external     override     onlyOwner   {     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument(); emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager); sherDistributionManager = _sherDistributionManager;  } // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)   /// @notice Remove SHER token rewards   function removeSherDistributionManager() external override onlyOwner {     if (address(sherDistributionManager) == address(0)) revert InvalidConditions(); emit SherDistributionManagerUpdated(   sherDistributionManager,   ISherDistributionManager(address(0)) ); delete sherDistributionManager;  } // Sets a new address for nonstakers payments   /// @notice Update address eligble for non staker rewards from protocol premiums   /// @param _nonStakers Address eligble for non staker rewards   function updateNonStakersAddress(address _nonStakers) external override onlyOwner {     if (address(_nonStakers) == address(0)) revert ZeroArgument();     if (nonStakersAddress == _nonStakers) revert InvalidArgument(); emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers); nonStakersAddress = _nonStakers;  } // Sets a new protocol manager contract   /// @notice Transfer protocol manager implementation address   /// @param _protocolManager new implementation address   function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)     external     override     onlyOwner   {     if (address(_protocolManager) == address(0)) revert ZeroArgument();     if (sherlockProtocolManager == _protocolManager) revert InvalidArgument(); emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager); sherlockProtocolManager = _protocolManager;  } // Sets a new claim manager contract   /// @notice Transfer claim manager role to different address   /// @param _claimManager New address of claim manager   function updateSherlockClaimManager(ISherlockClaimManager _claimManager)     external     override     onlyOwner   {     if (address(_claimManager) == address(0)) revert ZeroArgument();     if (sherlockClaimManager == _claimManager) revert InvalidArgument(); emit ClaimManagerUpdated(sherlockClaimManager, _claimManager); sherlockClaimManager = _claimManager;  } // Sets a new yield strategy manager contract   /// @notice Update yield strategy   /// @param _yieldStrategy News address of the strategy   /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure   function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (yieldStrategy == _yieldStrategy) revert InvalidArgument(); // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason. // In case this happens. We still want the yield strategy to be updated. // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again. try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {   emit YieldStrategyUpdateWithdrawAllError(reason); }  emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy); yieldStrategy = _yieldStrategy;  } // Deposits a chosen amount of tokens (USDC) into the active yield strategy   /// @notice Deposit _amount into active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); // Transfers any tokens owed to stakers from the protocol manager contract to this contract first sherlockProtocolManager.claimPremiumsForStakers(); // Transfers the amount of tokens to the yield strategy contract token.safeTransfer(address(yieldStrategy), _amount); // Deposits all tokens in the yield strategy contract into the actual yield strategy yieldStrategy.deposit();  } // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract   /// @notice Withdraw _amount from active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); yieldStrategy.withdraw(_amount);  } // Withdraws all tokens from the yield strategy back into this contract   /// @notice Withdraw all funds from active strategy   /// @dev gov only   function yieldStrategyWithdrawAll() external override onlyOwner {     yieldStrategy.withdrawAll();   } /// @notice Pause external functions in all contracts   /// @dev A manager can be replaced with the new contract in a paused state   /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused   function pause() external onlyOwner {     _pause();     if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();     // sherDistributionManager can be 0, pause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       !Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.pause();     }     if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();     if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();   } /// @notice Unpause external functions in all contracts   /// @dev A manager can be replaced with the new contract in an unpaused state   /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused   function unpause() external onlyOwner {     _unpause();     if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();     // sherDistributionManager can be 0, unpause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.unpause();     }     if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();     if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();   } //   // Access control functions   // /// @notice Account sum of all underlying posiiton shares for _from and _to   /// @dev this enables the tokenBalanceOfAddress to exist   function _beforeTokenTransfer(     address _from,     address _to,     uint256 _tokenID   ) internal override {     uint256 _stakeShares = stakeShares[_tokenID]; if (_from != address(0)) addressShares[_from] -= _stakeShares; if (_to != address(0)) addressShares[_to] += _stakeShares;  } // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)   // This function is called by the Sherlock claim manager contract if a claim is approved   /// @notice Initiate a payout of _amount to _receiver   /// @param _receiver Receiver of payout   /// @param _amount Amount to send   /// @dev only payout manager should call this   /// @dev should pull money out of strategy   function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {     // Can only be called by the Sherlock claim manager contract     if (msg.sender != address(sherlockClaimManager)) revert Unauthorized(); if (_amount != 0) {   // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)   _transferTokensOut(_receiver, _amount); } emit ClaimPayout(_receiver, _amount);  } //   // Non-access control functions   // // Helper function for initial staking and restaking   // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position   /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds   /// @param amount Amount of tokens to stake   /// @param _period Period of time for which funds get locked   /// @param _id ID for this NFT position   /// @param _receiver Address that will be linked to this position   /// @return _sher Amount of SHER tokens awarded to this position after _period ends   /// @dev _period needs to be whitelisted   function _stake(     uint256 _amount,     uint256 _period,     uint256 _id,     address _receiver   ) internal returns (uint256 _sher) {     // Sets the timestamp at which this position can first be unstaked/restaked     lockupEnd[_id] = block.timestamp + _period; if (address(sherDistributionManager) == address(0)) return 0; // Does not allow restaking of 0 tokens if (_amount == 0) return 0;  // Checks this amount of SHER tokens in this contract before we transfer new ones uint256 before = sher.balanceOf(address(this));  // pullReward() calcs then actually transfers the SHER tokens to this contract // in case this call fails, whole (re)staking transaction fails _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);  // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position uint256 actualAmount = sher.balanceOf(address(this)) - before; if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount); // Assigns the newly created SHER tokens to the current stake position if (_sher != 0) sherRewards_[_id] = _sher;  } // Checks to see if the NFT owner is the caller and that the position is unlockable   function verifyUnlockableByOwner(uint256 _id) internal view {     if (ownerOf(_id) != msg.sender) revert Unauthorized();     if (lockupEnd[_id] &gt; block.timestamp) revert InvalidConditions();   } // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner   function sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards[_id];     if (sherReward == 0) return; // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner sher.safeTransfer(_nftOwner, sherReward); // Deletes the SHER reward mapping for this NFT ID delete sherRewards_[_id];  } // Transfers an amount of tokens to the receiver address   // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)   function _transferTokensOut(address _receiver, uint256 _amount) internal {     // Transfers any premiums owed to stakers from the protocol manager to this contract     sherlockProtocolManager.claimPremiumsForStakers(); // The amount of tokens in this contract uint256 mainBalance = token.balanceOf(address(this));  // If the amount to transfer out is still greater than the amount of tokens in this contract, // Withdraw yield strategy tokens to make up the difference if (_amount &gt; mainBalance) {   yieldStrategy.withdraw(_amount - mainBalance); }  token.safeTransfer(_receiver, _amount);  } // Returns the amount of USDC owed to this amount of stakeShares   function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {     // Finds fraction that the given amount of stakeShares represents of the total     // Then multiplies it by the total amount of tokens (USDC) owed to all stakers     return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;   } // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted   // Also burns the requisite amount of shares associated with this NFT position   // Returns the amount of USDC owed to these shares   function _redeemShares(     uint256 _id,     uint256 _stakeShares,     address _receiver   ) internal returns (uint256 _amount) {     // Returns the amount of USDC owed to this amount of stakeShares     _amount = _redeemSharesCalc(_stakeShares);     // Transfers _amount of tokens to _receiver address     if (_amount != 0) _transferTokensOut(_receiver, _amount); // Subtracts this amount of stakeShares from the NFT position stakeShares[_id] -= _stakeShares; // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding totalStakeShares -= _stakeShares;  } // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager   // Restakes an NFT position (_id) for a given period (_period) and   // Sends any previously earned SHER rewards to the _nftOwner address   function _restake(     uint256 _id,     uint256 _period,     address _nftOwner   ) internal returns (uint256 _sher) {     // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner     // NOTE This function deletes the SHER reward mapping for this NFT ID     _sendSherRewardsToOwner(_id, _nftOwner); // tokenBalanceOf() returns the USDC amount owed to this NFT ID // _stake() restakes that amount of USDC for the period inputted // We use the same ID that we just deleted the SHER rewards mapping for // Resets the lockupEnd mapping and SHER token rewards mapping for this ID // Note stakeShares for this position do not change so no need to update _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);  emit Restaked(_id);  } // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)   /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt   /// @param _amount Amount of tokens to stake   /// @param _period Period of time, in seconds, to lockup your funds   /// @param _receiver Address that will receive the NFT representing the position   /// @return _id ID of the position   /// @return _sher Amount of SHER tokens to be released to this ID after _period ends   /// @dev _period needs to be whitelisted   function initialStake(     uint256 _amount,     uint256 _period,     address _receiver   ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {     if (_amount == 0) revert ZeroArgument();     // Makes sure the period is a whitelisted period     if (!stakingPeriods[_period]) revert InvalidArgument();     if (address(_receiver) == address(0)) revert ZeroArgument();     // Adds 1 to the ID of the last NFT created for the new NFT ID     _id = ++nftCounter; // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action) token.safeTransferFrom(msg.sender, address(this), _amount);  uint256 stakeShares_; uint256 totalStakeShares_ = totalStakeShares; // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares if (totalStakeShares_ != 0)   stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);   // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked else stakeShares_ = _amount;  // Assigns this NFT ID the calc'd amount of stake shares above stakeShares[_id] = stakeShares_; // Adds the newly created stake shares to the total amount of stake shares totalStakeShares += stakeShares_;  // Locks up the USDC amount and calcs the SHER token amount to receive on unstake _sher = _stake(_amount, _period, _id, _receiver);  // This is an ERC-721 function that creates an NFT and sends it to the receiver _safeMint(_receiver, _id);  } // This is how a staker unstakes and cashes out on their position   /// @notice Redeem NFT _id and receive _amount of tokens   /// @param _id TokenID of the position   /// @return _amount Amount of tokens (USDC) owed to NFT ID   /// @dev Only the owner of _id will be able to redeem their position   /// @dev The SHER rewards are sent to the NFT owner   /// @dev Can only be called after lockup _period has ended   function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // This is the ERC-721 function to destroy an NFT (with owner's approval) _burn(_id);  // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC owed to these shares _amount = _redeemShares(_id, stakeShares[_id], msg.sender);  // Sends the SHER tokens associated with this NFT ID to the NFT owner _sendSherRewardsToOwner(_id, msg.sender);  // Removes the unlock deadline associated with this NFT delete lockupEnd_[_id];  } // This is how a staker restakes an expired position   /// @notice Owner restakes position with ID: _id for _period seconds   /// @param _id ID of the position   /// @param _period Period of time, in seconds, to lockup your funds   /// @return _sher Amount of SHER tokens to be released to owner address after _period ends   /// @dev Only the owner of _id will be able to restake their position using this call   /// @dev _period needs to be whitelisted   /// @dev Can only be called after lockup _period has ended   function ownerRestake(uint256 _id, uint256 _period)     external     override     whenNotPaused     returns (uint256 _sher)   {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // Checks to make sure the staking period is a whitelisted one if (!stakingPeriods[_period]) revert InvalidArgument();  // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position _sher = _restake(_id, _period, msg.sender);  } // Calcs the reward (in stake shares) an arb would get for restaking a position   // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb   function calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {     // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)     uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME; // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position if (initialArbTime &gt; block.timestamp) return (0, false);  // The max rewards (as a % of the position's shares) for the arb are available at this timestamp uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;  // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100% uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;  // Scaled by 10**18 // Represents the max amount of stake shares that an arb could get from restaking this position uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];  // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled return (   ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,   true );  } /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position   /// @return profit How much profit an arb would make in USDC   /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)   function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {     // Returns the stake shares that an arb would get, and whether the position can currently be arbed     // profit variable is used to store the amount of shares     (profit, able) = _calcSharesForArbRestake(_id);     // Calculates the tokens (USDC) represented by that amount of stake shares     // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit     profit = _redeemSharesCalc(profit);   } /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)   /// @param _id ID of the position   /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup   /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function   /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)   /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)   /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)   function arbRestake(uint256 _id)     external     override     whenNotPaused     returns (uint256 _sher, uint256 _arbReward)   {     address nftOwner = ownerOf(_id); // Returns the stake shares that an arb would get, and whether the position can currently be arbed (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id); // Revert if not able to be arbed if (!able) revert InvalidConditions();  // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC paid to the arbitrager _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);  // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months) // Sends previously earned SHER rewards to the NFT owner address _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);  emit ArbRestaked(_id, _arbReward);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-25-08 10:36:56 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';

import './interfaces/ISherlock.sol';

/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions

contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;

  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;

  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;

  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;

  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%

  // USDC address
  IERC20 public immutable token;

  // SHER token address
  IERC20 public immutable sher;

  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;

  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;

  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;

  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;

  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;

  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;

  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;

  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;

  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;

  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;

  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();

    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;

    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }

    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }

  //
  // View functions
  //

  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return lockupEnd_[_tokenID];
  }

  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return sherRewards_[_tokenID];
  }

  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }

  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }

  //
  // Gov functions
  //

  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }

  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }

  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();

    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }

  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();

    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }

  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();

    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }

  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();

    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }

  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();

    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }

  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();

    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }

    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }

  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }

  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    yieldStrategy.withdraw(_amount);
  }

  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }

  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }

  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }

  //
  // Access control functions
  //

  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];

    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }

  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();

    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }

  //
  // Non-access control functions
  //

  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;

    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;

    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));

    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);

    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }

  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }

  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;

    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }

  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();

    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));

    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }

    token.safeTransfer(_receiver, _amount);
  }

  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);

    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }

  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);

    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);

    emit Restaked(_id);
  }

  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;

    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);

    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;

    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;

    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);

    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }

  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);

    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);

    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);

    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }

  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }

  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;

    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);

    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;

    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;

    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];

    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }

  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }

  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);

    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();

    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);

    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);

    emit ArbRestaked(_id, _arbReward);
  }
}
.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;
/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';
import './interfaces/ISherlock.sol';
/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions
contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;
  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;
  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;
  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;
  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%
  // USDC address
  IERC20 public immutable token;
  // SHER token address
  IERC20 public immutable sher;
  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;
  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;
  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;
  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;
  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;
  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;
  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;
  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;
  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;
  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;
  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();
    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;
    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }
    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }
  //
  // View functions
  //
  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    return lockupEnd_[_tokenID];
  }
  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    return sherRewards_[_tokenID];
  }
  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }
  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }
  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }
  //
  // Gov functions
  //
  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();
    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }
  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();
    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }
  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();
    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }
  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();
    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }
  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();
    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }
  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();
    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }
  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();
    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }
  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();
    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }
    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }
  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();
    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }
  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();
    yieldStrategy.withdraw(_amount);
  }
  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }
  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }
  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }
  //
  // Access control functions
  //
  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];
    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }
  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();
    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }
  //
  // Non-access control functions
  //
  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;
    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;
    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));
    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);
    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }
  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }
  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;
    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }
  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();
    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));
    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }
    token.safeTransfer(_receiver, _amount);
  }
  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }
  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);
    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }
  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);
    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);
    emit Restaked(_id);
  }
  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;
    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);
    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;
    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;
    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);
    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }
  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);
    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);
    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);
    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);
    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }
  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);
    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();
    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }
  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;
    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);
    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;
    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;
    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];
    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }
  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }
  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();
    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);
    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);
    emit ArbRestaked(_id, _arbReward);
  }
}
.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;
/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';
import './interfaces/ISherlock.sol';
/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions
contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;
  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;
  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;
  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;
  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%
  // USDC address
  IERC20 public immutable token;
  // SHER token address
  IERC20 public immutable sher;
  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;
  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;
  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;
  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;
  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;
  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;
  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;
  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;
  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;
  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;
  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();
    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;
    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }
    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }
  //
  // View functions
  //
  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    return lockupEnd_[_tokenID];
  }
  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    return sherRewards_[_tokenID];
  }
  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }
  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }
  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }
  //
  // Gov functions
  //
  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();
    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }
  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();
    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }
  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();
    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }
  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();
    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }
  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();
    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }
  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();
    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }
  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();
    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }
  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();
    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }
    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }
  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();
    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }
  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();
    yieldStrategy.withdraw(_amount);
  }
  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }
  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }
  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }
  //
  // Access control functions
  //
  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];
    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }
  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();
    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }
  //
  // Non-access control functions
  //
  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;
    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;
    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));
    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);
    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }
  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }
  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;
    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }
  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();
    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));
    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }
    token.safeTransfer(_receiver, _amount);
  }
  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }
  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);
    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }
  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);
    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);
    emit Restaked(_id);
  }
  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;
    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);
    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;
    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;
    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);
    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }
  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);
    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);
    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);
    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);
    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }
  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);
    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();
    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }
  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;
    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);
    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;
    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;
    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];
    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }
  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }
  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();
    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);
    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);
    emit ArbRestaked(_id, _arbReward);
  }
}
".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Let's analyze the provided Solidity contract and brainstorm potential improvements or enhancements.
1. **Reentrancy Guard**: The contract currently does not implement any protection against reentrancy attacks, especially in functions that transfer tokens or interact with external contracts (like `payoutClaim`, `yieldStrategyWithdraw`, etc.). We could implement a reentrancy guard using the `nonReentrant` modifier from OpenZeppelin.
2. **Event Emission for State Changes**: While there are several events emitted, we could ensure that every state-changing function emits an event. For example, functions like `enableStakingPeriod`, `disableStakingPeriod`, and others that modify mappings could benefit from additional events to track changes more effectively.
3. **Gas Optimization**: We could optimize the gas usage in functions by minimizing state variable reads and writes. For instance, in the `_redeemSharesCalc` function, we could cache `totalTokenBalanceStakers()` in a local variable to avoid multiple calls.
4. **Access Control Enhancements**: Currently, the `onlyOwner` modifier is used for several functions. We could consider implementing role-based access control using OpenZeppelin's `AccessControl` to allow for more granular permissions in the future.
5. **Input Validation**: While there are some checks in place, we could enhance input validation in functions like `initialStake` and `ownerRestake` to ensure that the `_period` is not only whitelisted but also falls within a reasonable range to prevent potential misuse.
6. **Upgradeability**: If the contract is intended to be used long-term, we could consider implementing a proxy pattern for upgradeability. This would allow for future improvements without losing the state of the contract.
7. **Emergency Withdrawals**: Implementing a mechanism for emergency withdrawals could be beneficial in case of unforeseen circumstances, allowing users to withdraw their funds without waiting for the lockup period to end.
8. **Detailed Documentation**: While the contract has some comments, enhancing the documentation for each function, especially the more complex ones, could improve maintainability and understanding for future developers.
9. **Testing and Auditing**: Ensure that comprehensive unit tests are written for all functionalities, especially edge cases. Additionally, consider a third-party audit for security assurance.
10. **User Feedback Mechanism**: Implementing a way for users to provide feedback or report issues directly through the contract could enhance user engagement and trust.
Which of these suggestions do you think would be the most impactful, or do you have any other ideas to add? Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-25-08 10:37:00 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-25-08 10:37:00 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 23929
completion_tokens: 1
total_tokens: 23930
cost: $-1.000000


[2024-25-08 10:37:00 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';

import './interfaces/ISherlock.sol';

/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions

contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;

  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;

  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;

  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;

  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%

  // USDC address
  IERC20 public immutable token;

  // SHER token address
  IERC20 public immutable sher;

  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;

  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;

  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;

  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;

  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;

  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;

  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;

  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;

  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;

  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;

  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();

    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;

    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }

    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }

  //
  // View functions
  //

  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return lockupEnd_[_tokenID];
  }

  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return sherRewards_[_tokenID];
  }

  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }

  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }

  //
  // Gov functions
  //

  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }

  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }

  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();

    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }

  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();

    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }

  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();

    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }

  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();

    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }

  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();

    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }

  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();

    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }

    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }

  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }

  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    yieldStrategy.withdraw(_amount);
  }

  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }

  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }

  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }

  //
  // Access control functions
  //

  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];

    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }

  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();

    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }

  //
  // Non-access control functions
  //

  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;

    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;

    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));

    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);

    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }

  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }

  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;

    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }

  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();

    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));

    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }

    token.safeTransfer(_receiver, _amount);
  }

  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);

    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }

  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);

    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);

    emit Restaked(_id);
  }

  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;

    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);

    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;

    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;

    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);

    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }

  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);

    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);

    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);

    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }

  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }

  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;

    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);

    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;

    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;

    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];

    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }

  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }

  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);

    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();

    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);

    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);

    emit ArbRestaked(_id, _arbReward);
  }
}
.]

1

[2024-25-08 10:37:00 INFO] **[Seminar Conclusion]**:

 1

[2024-25-08 10:37:00 INFO] **[Seminar Conclusion]**:

 <INFO> 1

[2024-25-08 10:37:00 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-25-08 10:37:00 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@openzeppelin/contracts/token/ERC721/ERC721.sol'; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol'; import '@openzeppelin/contracts/security/Pausable.sol'; import './interfaces/ISherlock.sol'; /// @title Sherlock core interface for stakers /// @author Evert Kors // This is the contract that manages staking actions contract Sherlock is ISherlock, ERC721, Ownable, Pausable {   using SafeERC20 for IERC20; // The initial period for a staker to restake/withdraw without being auto-restaked   uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks; // The period during which the reward for restaking an account (after the inital period) grows   uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks; // Anyone who gets auto-restaked is restaked for this period (3 months)   uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks; // The percentage of someone's stake that can be paid to an arb for restaking   uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20% // USDC address   IERC20 public immutable token; // SHER token address   IERC20 public immutable sher; // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not   mapping(uint256 =&gt; bool) public override stakingPeriods; // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked   mapping(uint256 =&gt; uint256) internal lockupEnd_; // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position   mapping(uint256 =&gt; uint256) internal sherRewards_; // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)   mapping(uint256 =&gt; uint256) internal stakeShares; // Key is account, value is the sum of underlying shares of all the NFTs the account owns.   mapping(address =&gt; uint256) internal addressShares; // Total amount of shares that have been issued to all NFT positions   uint256 internal totalStakeShares; // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)   IStrategyManager public override yieldStrategy; // Instances of relevant Sherlock contracts   ISherDistributionManager public override sherDistributionManager;   ISherlockProtocolManager public override sherlockProtocolManager;   ISherlockClaimManager public override sherlockClaimManager; // Address to which nonstaker payments are made   // This will start out as a multi-sig address, then become a contract address later   address public override nonStakersAddress; // Stores the ID of the most recently created NFT   // This variable is incremented by 1 to create a new NFT ID   uint256 internal nftCounter; // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.   constructor(     IERC20 _token, // USDC address     IERC20 _sher, // SHER token address     string memory _name, // Token collection name (see ERC-721 docs)     string memory _symbol, // Token collection symbol (see ERC-721 docs)     IStrategyManager _yieldStrategy, // The active yield strategy contract     ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract     address _nonStakersAddress, // The address to which nonstakers payments go     ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract     ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract     uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for   ) ERC721(_name, _symbol) {     if (address(_token) == address(0)) revert ZeroArgument();     if (address(_sher) == address(0)) revert ZeroArgument();     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (_nonStakersAddress == address(0)) revert ZeroArgument();     if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();     if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument(); token = _token; sher = _sher; yieldStrategy = _yieldStrategy; sherDistributionManager = _sherDistributionManager; nonStakersAddress = _nonStakersAddress; sherlockProtocolManager = _sherlockProtocolManager; sherlockClaimManager = _sherlockClaimManager;  // Enabling the first set of staking periods that were provided in constructor args for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {   enableStakingPeriod(_initialstakingPeriods[i]); }  emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy); emit SherDistributionManagerUpdated(   ISherDistributionManager(address(0)),   _sherDistributionManager ); emit NonStakerAddressUpdated(address(0), _nonStakersAddress); emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager); emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);  } //   // View functions   // // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked   /// @notice View the current lockup end timestamp of _tokenID   /// @return Timestamp when NFT position unlocks   function lockupEnd(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return lockupEnd_[_tokenID];  } // Returns the SHER rewards owed to this position   /// @notice View the current SHER reward of _tokenID   /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup   function sherRewards(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return sherRewards_[_tokenID];  } // Returns the tokens (USDC) owed to a position   /// @notice View the current token balance claimable upon reaching end of the lockup   /// @return Amount of tokens assigned to owner when unstaking position   function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent();     // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers     return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;   } // Returns the tokens (USDC) owed to an address   /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup   /// @return Amount of tokens assigned to owner when unstaking all positions   function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {     if (_staker == address(0)) revert ZeroArgument();     uint256 _totalStakeShares = totalStakeShares;     if (_totalStakeShares == 0) return 0;     // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers     return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;   } // Gets the total amount of tokens (USDC) owed to stakers   // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract   /// @notice View the current TVL for all stakers   /// @return Total amount of tokens staked   /// @dev Adds principal + strategy + premiums   /// @dev Will calculate the most up to date value for each piece   function totalTokenBalanceStakers() public view override returns (uint256) {     return       token.balanceOf(address(this)) +       yieldStrategy.balanceOf() +       sherlockProtocolManager.claimablePremiums();   } //   // Gov functions   // // Allows governance to add a new staking period (4 months, etc.)   /// @notice Allows stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already enabled   function enableStakingPeriod(uint256 _period) public override onlyOwner {     if (_period == 0) revert ZeroArgument();     // Revert if staking period is already active     if (stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to true stakingPeriods[_period] = true; emit StakingPeriodEnabled(_period);  } // Allows governance to remove a staking period (4 months, etc.)   /// @notice Disallow stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already disabled   function disableStakingPeriod(uint256 _period) external override onlyOwner {     // Revert if staking period is already inactive     if (!stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to false stakingPeriods[_period] = false; emit StakingPeriodDisabled(_period);  } // Sets a new contract to be the active SHER distribution manager   /// @notice Update SHER distribution manager contract   /// @param _sherDistributionManager New adddress of the manager   function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)     external     override     onlyOwner   {     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument(); emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager); sherDistributionManager = _sherDistributionManager;  } // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)   /// @notice Remove SHER token rewards   function removeSherDistributionManager() external override onlyOwner {     if (address(sherDistributionManager) == address(0)) revert InvalidConditions(); emit SherDistributionManagerUpdated(   sherDistributionManager,   ISherDistributionManager(address(0)) ); delete sherDistributionManager;  } // Sets a new address for nonstakers payments   /// @notice Update address eligble for non staker rewards from protocol premiums   /// @param _nonStakers Address eligble for non staker rewards   function updateNonStakersAddress(address _nonStakers) external override onlyOwner {     if (address(_nonStakers) == address(0)) revert ZeroArgument();     if (nonStakersAddress == _nonStakers) revert InvalidArgument(); emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers); nonStakersAddress = _nonStakers;  } // Sets a new protocol manager contract   /// @notice Transfer protocol manager implementation address   /// @param _protocolManager new implementation address   function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)     external     override     onlyOwner   {     if (address(_protocolManager) == address(0)) revert ZeroArgument();     if (sherlockProtocolManager == _protocolManager) revert InvalidArgument(); emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager); sherlockProtocolManager = _protocolManager;  } // Sets a new claim manager contract   /// @notice Transfer claim manager role to different address   /// @param _claimManager New address of claim manager   function updateSherlockClaimManager(ISherlockClaimManager _claimManager)     external     override     onlyOwner   {     if (address(_claimManager) == address(0)) revert ZeroArgument();     if (sherlockClaimManager == _claimManager) revert InvalidArgument(); emit ClaimManagerUpdated(sherlockClaimManager, _claimManager); sherlockClaimManager = _claimManager;  } // Sets a new yield strategy manager contract   /// @notice Update yield strategy   /// @param _yieldStrategy News address of the strategy   /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure   function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (yieldStrategy == _yieldStrategy) revert InvalidArgument(); // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason. // In case this happens. We still want the yield strategy to be updated. // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again. try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {   emit YieldStrategyUpdateWithdrawAllError(reason); }  emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy); yieldStrategy = _yieldStrategy;  } // Deposits a chosen amount of tokens (USDC) into the active yield strategy   /// @notice Deposit _amount into active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); // Transfers any tokens owed to stakers from the protocol manager contract to this contract first sherlockProtocolManager.claimPremiumsForStakers(); // Transfers the amount of tokens to the yield strategy contract token.safeTransfer(address(yieldStrategy), _amount); // Deposits all tokens in the yield strategy contract into the actual yield strategy yieldStrategy.deposit();  } // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract   /// @notice Withdraw _amount from active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); yieldStrategy.withdraw(_amount);  } // Withdraws all tokens from the yield strategy back into this contract   /// @notice Withdraw all funds from active strategy   /// @dev gov only   function yieldStrategyWithdrawAll() external override onlyOwner {     yieldStrategy.withdrawAll();   } /// @notice Pause external functions in all contracts   /// @dev A manager can be replaced with the new contract in a paused state   /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused   function pause() external onlyOwner {     _pause();     if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();     // sherDistributionManager can be 0, pause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       !Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.pause();     }     if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();     if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();   } /// @notice Unpause external functions in all contracts   /// @dev A manager can be replaced with the new contract in an unpaused state   /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused   function unpause() external onlyOwner {     _unpause();     if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();     // sherDistributionManager can be 0, unpause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.unpause();     }     if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();     if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();   } //   // Access control functions   // /// @notice Account sum of all underlying posiiton shares for _from and _to   /// @dev this enables the tokenBalanceOfAddress to exist   function _beforeTokenTransfer(     address _from,     address _to,     uint256 _tokenID   ) internal override {     uint256 _stakeShares = stakeShares[_tokenID]; if (_from != address(0)) addressShares[_from] -= _stakeShares; if (_to != address(0)) addressShares[_to] += _stakeShares;  } // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)   // This function is called by the Sherlock claim manager contract if a claim is approved   /// @notice Initiate a payout of _amount to _receiver   /// @param _receiver Receiver of payout   /// @param _amount Amount to send   /// @dev only payout manager should call this   /// @dev should pull money out of strategy   function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {     // Can only be called by the Sherlock claim manager contract     if (msg.sender != address(sherlockClaimManager)) revert Unauthorized(); if (_amount != 0) {   // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)   _transferTokensOut(_receiver, _amount); } emit ClaimPayout(_receiver, _amount);  } //   // Non-access control functions   // // Helper function for initial staking and restaking   // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position   /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds   /// @param amount Amount of tokens to stake   /// @param _period Period of time for which funds get locked   /// @param _id ID for this NFT position   /// @param _receiver Address that will be linked to this position   /// @return _sher Amount of SHER tokens awarded to this position after _period ends   /// @dev _period needs to be whitelisted   function _stake(     uint256 _amount,     uint256 _period,     uint256 _id,     address _receiver   ) internal returns (uint256 _sher) {     // Sets the timestamp at which this position can first be unstaked/restaked     lockupEnd[_id] = block.timestamp + _period; if (address(sherDistributionManager) == address(0)) return 0; // Does not allow restaking of 0 tokens if (_amount == 0) return 0;  // Checks this amount of SHER tokens in this contract before we transfer new ones uint256 before = sher.balanceOf(address(this));  // pullReward() calcs then actually transfers the SHER tokens to this contract // in case this call fails, whole (re)staking transaction fails _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);  // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position uint256 actualAmount = sher.balanceOf(address(this)) - before; if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount); // Assigns the newly created SHER tokens to the current stake position if (_sher != 0) sherRewards_[_id] = _sher;  } // Checks to see if the NFT owner is the caller and that the position is unlockable   function verifyUnlockableByOwner(uint256 _id) internal view {     if (ownerOf(_id) != msg.sender) revert Unauthorized();     if (lockupEnd[_id] &gt; block.timestamp) revert InvalidConditions();   } // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner   function sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards[_id];     if (sherReward == 0) return; // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner sher.safeTransfer(_nftOwner, sherReward); // Deletes the SHER reward mapping for this NFT ID delete sherRewards_[_id];  } // Transfers an amount of tokens to the receiver address   // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)   function _transferTokensOut(address _receiver, uint256 _amount) internal {     // Transfers any premiums owed to stakers from the protocol manager to this contract     sherlockProtocolManager.claimPremiumsForStakers(); // The amount of tokens in this contract uint256 mainBalance = token.balanceOf(address(this));  // If the amount to transfer out is still greater than the amount of tokens in this contract, // Withdraw yield strategy tokens to make up the difference if (_amount &gt; mainBalance) {   yieldStrategy.withdraw(_amount - mainBalance); }  token.safeTransfer(_receiver, _amount);  } // Returns the amount of USDC owed to this amount of stakeShares   function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {     // Finds fraction that the given amount of stakeShares represents of the total     // Then multiplies it by the total amount of tokens (USDC) owed to all stakers     return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;   } // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted   // Also burns the requisite amount of shares associated with this NFT position   // Returns the amount of USDC owed to these shares   function _redeemShares(     uint256 _id,     uint256 _stakeShares,     address _receiver   ) internal returns (uint256 _amount) {     // Returns the amount of USDC owed to this amount of stakeShares     _amount = _redeemSharesCalc(_stakeShares);     // Transfers _amount of tokens to _receiver address     if (_amount != 0) _transferTokensOut(_receiver, _amount); // Subtracts this amount of stakeShares from the NFT position stakeShares[_id] -= _stakeShares; // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding totalStakeShares -= _stakeShares;  } // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager   // Restakes an NFT position (_id) for a given period (_period) and   // Sends any previously earned SHER rewards to the _nftOwner address   function _restake(     uint256 _id,     uint256 _period,     address _nftOwner   ) internal returns (uint256 _sher) {     // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner     // NOTE This function deletes the SHER reward mapping for this NFT ID     _sendSherRewardsToOwner(_id, _nftOwner); // tokenBalanceOf() returns the USDC amount owed to this NFT ID // _stake() restakes that amount of USDC for the period inputted // We use the same ID that we just deleted the SHER rewards mapping for // Resets the lockupEnd mapping and SHER token rewards mapping for this ID // Note stakeShares for this position do not change so no need to update _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);  emit Restaked(_id);  } // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)   /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt   /// @param _amount Amount of tokens to stake   /// @param _period Period of time, in seconds, to lockup your funds   /// @param _receiver Address that will receive the NFT representing the position   /// @return _id ID of the position   /// @return _sher Amount of SHER tokens to be released to this ID after _period ends   /// @dev _period needs to be whitelisted   function initialStake(     uint256 _amount,     uint256 _period,     address _receiver   ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {     if (_amount == 0) revert ZeroArgument();     // Makes sure the period is a whitelisted period     if (!stakingPeriods[_period]) revert InvalidArgument();     if (address(_receiver) == address(0)) revert ZeroArgument();     // Adds 1 to the ID of the last NFT created for the new NFT ID     _id = ++nftCounter; // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action) token.safeTransferFrom(msg.sender, address(this), _amount);  uint256 stakeShares_; uint256 totalStakeShares_ = totalStakeShares; // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares if (totalStakeShares_ != 0)   stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);   // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked else stakeShares_ = _amount;  // Assigns this NFT ID the calc'd amount of stake shares above stakeShares[_id] = stakeShares_; // Adds the newly created stake shares to the total amount of stake shares totalStakeShares += stakeShares_;  // Locks up the USDC amount and calcs the SHER token amount to receive on unstake _sher = _stake(_amount, _period, _id, _receiver);  // This is an ERC-721 function that creates an NFT and sends it to the receiver _safeMint(_receiver, _id);  } // This is how a staker unstakes and cashes out on their position   /// @notice Redeem NFT _id and receive _amount of tokens   /// @param _id TokenID of the position   /// @return _amount Amount of tokens (USDC) owed to NFT ID   /// @dev Only the owner of _id will be able to redeem their position   /// @dev The SHER rewards are sent to the NFT owner   /// @dev Can only be called after lockup _period has ended   function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // This is the ERC-721 function to destroy an NFT (with owner's approval) _burn(_id);  // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC owed to these shares _amount = _redeemShares(_id, stakeShares[_id], msg.sender);  // Sends the SHER tokens associated with this NFT ID to the NFT owner _sendSherRewardsToOwner(_id, msg.sender);  // Removes the unlock deadline associated with this NFT delete lockupEnd_[_id];  } // This is how a staker restakes an expired position   /// @notice Owner restakes position with ID: _id for _period seconds   /// @param _id ID of the position   /// @param _period Period of time, in seconds, to lockup your funds   /// @return _sher Amount of SHER tokens to be released to owner address after _period ends   /// @dev Only the owner of _id will be able to restake their position using this call   /// @dev _period needs to be whitelisted   /// @dev Can only be called after lockup _period has ended   function ownerRestake(uint256 _id, uint256 _period)     external     override     whenNotPaused     returns (uint256 _sher)   {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // Checks to make sure the staking period is a whitelisted one if (!stakingPeriods[_period]) revert InvalidArgument();  // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position _sher = _restake(_id, _period, msg.sender);  } // Calcs the reward (in stake shares) an arb would get for restaking a position   // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb   function calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {     // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)     uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME; // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position if (initialArbTime &gt; block.timestamp) return (0, false);  // The max rewards (as a % of the position's shares) for the arb are available at this timestamp uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;  // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100% uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;  // Scaled by 10**18 // Represents the max amount of stake shares that an arb could get from restaking this position uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];  // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled return (   ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,   true );  } /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position   /// @return profit How much profit an arb would make in USDC   /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)   function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {     // Returns the stake shares that an arb would get, and whether the position can currently be arbed     // profit variable is used to store the amount of shares     (profit, able) = _calcSharesForArbRestake(_id);     // Calculates the tokens (USDC) represented by that amount of stake shares     // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit     profit = _redeemSharesCalc(profit);   } /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)   /// @param _id ID of the position   /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup   /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function   /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)   /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)   /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)   function arbRestake(uint256 _id)     external     override     whenNotPaused     returns (uint256 _sher, uint256 _arbReward)   {     address nftOwner = ownerOf(_id); // Returns the stake shares that an arb would get, and whether the position can currently be arbed (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id); // Revert if not able to be arbed if (!able) revert InvalidConditions();  // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC paid to the arbitrager _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);  // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months) // Sends previously earned SHER rewards to the NFT owner address _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);  emit ArbRestaked(_id, _arbReward);  } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/***********\\n Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x)\n Sherlock Protocol: https://sherlock.xyz\n/***********/\n\nimport \'@openzeppelin/contracts/token/ERC20/IERC20.sol\';\nimport \'@openzeppelin/contracts/token/ERC721/ERC721.sol\';\nimport \'@openzeppelin/contracts/access/Ownable.sol\';\nimport \'@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\';\nimport \'@openzeppelin/contracts/security/Pausable.sol\';\n\nimport \'./interfaces/ISherlock.sol\';\n\n/// @title Sherlock core interface for stakers\n/// @author Evert Kors\n// This is the contract that manages staking actions\n\ncontract Sherlock is ISherlock, ERC721, Ownable, Pausable {\n  using SafeERC20 for IERC20;\n\n  // The initial period for a staker to restake/withdraw without being auto-restaked\n  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;\n\n  // The period during which the reward for restaking an account (after the inital period) grows\n  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;\n\n  // Anyone who gets auto-restaked is restaked for this period (3 months)\n  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;\n\n  // The percentage of someone\'s stake that can be paid to an arb for restaking\n  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (1018 / 100) * 20; // 20%\n\n  // USDC address\n  IERC20 public immutable token;\n\n  // SHER token address\n  IERC20 public immutable sher;\n\n  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not\n  mapping(uint256 =&gt; bool) public override stakingPeriods;\n\n  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked\n  mapping(uint256 =&gt; uint256) internal lockupEnd_;\n\n  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position\n  mapping(uint256 =&gt; uint256) internal sherRewards_;\n\n  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)\n  mapping(uint256 =&gt; uint256) internal stakeShares;\n\n  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.\n  mapping(address =&gt; uint256) internal addressShares;\n\n  // Total amount of shares that have been issued to all NFT positions\n  uint256 internal totalStakeShares;\n\n  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)\n  IStrategyManager public override yieldStrategy;\n\n  // Instances of relevant Sherlock contracts\n  ISherDistributionManager public override sherDistributionManager;\n  ISherlockProtocolManager public override sherlockProtocolManager;\n  ISherlockClaimManager public override sherlockClaimManager;\n\n  // Address to which nonstaker payments are made\n  // This will start out as a multi-sig address, then become a contract address later\n  address public override nonStakersAddress;\n\n  // Stores the ID of the most recently created NFT\n  // This variable is incremented by 1 to create a new NFT ID\n  uint256 internal nftCounter;\n\n  // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.\n  constructor(\n    IERC20 token, // USDC address\n    IERC20 _sher, // SHER token address\n    string memory _name, // Token collection name (see ERC-721 docs)\n    string memory _symbol, // Token collection symbol (see ERC-721 docs)\n    IStrategyManager _yieldStrategy, // The active yield strategy contract\n    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract\n    address _nonStakersAddress, // The address to which nonstakers payments go\n    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract\n    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract\n    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for\n  ) ERC721(_name, _symbol) {\n    if (address(_token) == address(0)) revert ZeroArgument();\n    if (address(_sher) == address(0)) revert ZeroArgument();\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();\n    if (_nonStakersAddress == address(0)) revert ZeroArgument();\n    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();\n    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();\n\n    token = _token;\n    sher = _sher;\n    yieldStrategy = _yieldStrategy;\n    sherDistributionManager = _sherDistributionManager;\n    nonStakersAddress = _nonStakersAddress;\n    sherlockProtocolManager = _sherlockProtocolManager;\n    sherlockClaimManager = _sherlockClaimManager;\n\n    // Enabling the first set of staking periods that were provided in constructor args\n    for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {\n      enableStakingPeriod(_initialstakingPeriods[i]);\n    }\n\n    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);\n    emit SherDistributionManagerUpdated(\n      ISherDistributionManager(address(0)),\n      _sherDistributionManager\n    );\n    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);\n    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);\n    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);\n  }\n\n  //\n  // View functions\n  //\n\n  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked\n  /// @notice View the current lockup end timestamp of _tokenID\n  /// @return Timestamp when NFT position unlocks\n  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n\n    return lockupEnd[tokenID];\n  }\n\n  // Returns the SHER rewards owed to this position\n  /// @notice View the current SHER reward of _tokenID\n  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup\n  function sherRewards(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n\n    return sherRewards[tokenID];\n  }\n\n  // Returns the tokens (USDC) owed to a position\n  /// @notice View the current token balance claimable upon reaching end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking position\n  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers\n    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;\n  }\n\n  // Returns the tokens (USDC) owed to an address\n  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking all positions\n  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {\n    if (_staker == address(0)) revert ZeroArgument();\n    uint256 _totalStakeShares = totalStakeShares;\n    if (_totalStakeShares == 0) return 0;\n    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers\n    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;\n  }\n\n  // Gets the total amount of tokens (USDC) owed to stakers\n  // Adds this contract\'s balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract\n  /// @notice View the current TVL for all stakers\n  /// @return Total amount of tokens staked\n  /// @dev Adds principal + strategy + premiums\n  /// @dev Will calculate the most up to date value for each piece\n  function totalTokenBalanceStakers() public view override returns (uint256) {\n    return\n      token.balanceOf(address(this)) +\n      yieldStrategy.balanceOf() +\n      sherlockProtocolManager.claimablePremiums();\n  }\n\n  //\n  // Gov functions\n  //\n\n  // Allows governance to add a new staking period (4 months, etc.)\n  /// @notice Allows stakers to stake for _period of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already enabled\n  function enableStakingPeriod(uint256 _period) public override onlyOwner {\n    if (_period == 0) revert ZeroArgument();\n    // Revert if staking period is already active\n    if (stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sets the staking period to true\n    stakingPeriods[_period] = true;\n    emit StakingPeriodEnabled(_period);\n  }\n\n  // Allows governance to remove a staking period (4 months, etc.)\n  /// @notice Disallow stakers to stake for _period of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already disabled\n  function disableStakingPeriod(uint256 _period) external override onlyOwner {\n    // Revert if staking period is already inactive\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sets the staking period to false\n    stakingPeriods[_period] = false;\n    emit StakingPeriodDisabled(_period);\n  }\n\n  // Sets a new contract to be the active SHER distribution manager\n  /// @notice Update SHER distribution manager contract\n  /// @param _sherDistributionManager New adddress of the manager\n  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();\n    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();\n\n    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);\n    sherDistributionManager = _sherDistributionManager;\n  }\n\n  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)\n  /// @notice Remove SHER token rewards\n  function removeSherDistributionManager() external override onlyOwner {\n    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();\n\n    emit SherDistributionManagerUpdated(\n      sherDistributionManager,\n      ISherDistributionManager(address(0))\n    );\n    delete sherDistributionManager;\n  }\n\n  // Sets a new address for nonstakers payments\n  /// @notice Update address eligble for non staker rewards from protocol premiums\n  /// @param _nonStakers Address eligble for non staker rewards\n  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {\n    if (address(_nonStakers) == address(0)) revert ZeroArgument();\n    if (nonStakersAddress == _nonStakers) revert InvalidArgument();\n\n    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);\n    nonStakersAddress = _nonStakers;\n  }\n\n  // Sets a new protocol manager contract\n  /// @notice Transfer protocol manager implementation address\n  /// @param _protocolManager new implementation address\n  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_protocolManager) == address(0)) revert ZeroArgument();\n    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();\n\n    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);\n    sherlockProtocolManager = _protocolManager;\n  }\n\n  // Sets a new claim manager contract\n  /// @notice Transfer claim manager role to different address\n  /// @param _claimManager New address of claim manager\n  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_claimManager) == address(0)) revert ZeroArgument();\n    if (sherlockClaimManager == _claimManager) revert InvalidArgument();\n\n    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);\n    sherlockClaimManager = _claimManager;\n  }\n\n  // Sets a new yield strategy manager contract\n  /// @notice Update yield strategy\n  /// @param _yieldStrategy News address of the strategy\n  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure\n  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();\n\n    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail\n    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.\n    // In case this happens. We still want the yield strategy to be updated.\n    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.\n    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {\n      emit YieldStrategyUpdateWithdrawAllError(reason);\n    }\n\n    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);\n    yieldStrategy = _yieldStrategy;\n  }\n\n  // Deposits a chosen amount of tokens (USDC) into the active yield strategy\n  /// @notice Deposit _amount into active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {\n    if (_amount == 0) revert ZeroArgument();\n\n    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first\n    sherlockProtocolManager.claimPremiumsForStakers();\n    // Transfers the amount of tokens to the yield strategy contract\n    token.safeTransfer(address(yieldStrategy), _amount);\n    // Deposits all tokens in the yield strategy contract into the actual yield strategy\n    yieldStrategy.deposit();\n  }\n\n  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract\n  /// @notice Withdraw _amount from active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {\n    if (_amount == 0) revert ZeroArgument();\n\n    yieldStrategy.withdraw(_amount);\n  }\n\n  // Withdraws all tokens from the yield strategy back into this contract\n  /// @notice Withdraw all funds from active strategy\n  /// @dev gov only\n  function yieldStrategyWithdrawAll() external override onlyOwner {\n    yieldStrategy.withdrawAll();\n  }\n\n  /// @notice Pause external functions in all contracts\n  /// @dev A manager can be replaced with the new contract in a paused state\n  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused\n  function pause() external onlyOwner {\n    _pause();\n    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();\n    // sherDistributionManager can be 0, pause isn\'t needed in that case\n    if (\n      address(sherDistributionManager) != address(0) &amp;&amp;\n      !Pausable(address(sherDistributionManager)).paused()\n    ) {\n      sherDistributionManager.pause();\n    }\n    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();\n    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();\n  }\n\n  /// @notice Unpause external functions in all contracts\n  /// @dev A manager can be replaced with the new contract in an unpaused state\n  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused\n  function unpause() external onlyOwner {\n    _unpause();\n    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();\n    // sherDistributionManager can be 0, unpause isn\'t needed in that case\n    if (\n      address(sherDistributionManager) != address(0) &amp;&amp;\n      Pausable(address(sherDistributionManager)).paused()\n    ) {\n      sherDistributionManager.unpause();\n    }\n    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();\n    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();\n  }\n\n  //\n  // Access control functions\n  //\n\n  /// @notice Account sum of all underlying posiiton shares for _from and _to\n  /// @dev this enables the tokenBalanceOfAddress to exist\n  function _beforeTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenID\n  ) internal override {\n    uint256 _stakeShares = stakeShares[_tokenID];\n\n    if (_from != address(0)) addressShares[_from] -= _stakeShares;\n    if (_to != address(0)) addressShares[_to] += _stakeShares;\n  }\n\n  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)\n  // This function is called by the Sherlock claim manager contract if a claim is approved\n  /// @notice Initiate a payout of _amount to _receiver\n  /// @param _receiver Receiver of payout\n  /// @param _amount Amount to send\n  /// @dev only payout manager should call this\n  /// @dev should pull money out of strategy\n  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {\n    // Can only be called by the Sherlock claim manager contract\n    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();\n\n    if (_amount != 0) {\n      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)\n      _transferTokensOut(_receiver, _amount);\n    }\n    emit ClaimPayout(_receiver, _amount);\n  }\n\n  //\n  // Non-access control functions\n  //\n\n  // Helper function for initial staking and restaking\n  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position\n  /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time for which funds get locked\n  /// @param _id ID for this NFT position\n  /// @param _receiver Address that will be linked to this position\n  /// @return _sher Amount of SHER tokens awarded to this position after _period ends\n  /// @dev _period needs to be whitelisted\n  function _stake(\n    uint256 _amount,\n    uint256 _period,\n    uint256 _id,\n    address _receiver\n  ) internal returns (uint256 _sher) {\n    // Sets the timestamp at which this position can first be unstaked/restaked\n    lockupEnd[id] = block.timestamp + _period;\n\n    if (address(sherDistributionManager) == address(0)) return 0;\n    // Does not allow restaking of 0 tokens\n    if (_amount == 0) return 0;\n\n    // Checks this amount of SHER tokens in this contract before we transfer new ones\n    uint256 before = sher.balanceOf(address(this));\n\n    // pullReward() calcs then actually transfers the SHER tokens to this contract\n    // in case this call fails, whole (re)staking transaction fails\n    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);\n\n    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position\n    uint256 actualAmount = sher.balanceOf(address(this)) - before;\n    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);\n    // Assigns the newly created SHER tokens to the current stake position\n    if (_sher != 0) sherRewards[id] = _sher;\n  }\n\n  // Checks to see if the NFT owner is the caller and that the position is unlockable\n  function _verifyUnlockableByOwner(uint256 _id) internal view {\n    if (ownerOf(_id) != msg.sender) revert Unauthorized();\n    if (lockupEnd[id] &gt; block.timestamp) revert InvalidConditions();\n  }\n\n  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner\n  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {\n    uint256 sherReward = sherRewards[id];\n    if (sherReward == 0) return;\n\n    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner\n    sher.safeTransfer(_nftOwner, sherReward);\n    // Deletes the SHER reward mapping for this NFT ID\n    delete sherRewards[id];\n  }\n\n  // Transfers an amount of tokens to the receiver address\n  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)\n  function _transferTokensOut(address _receiver, uint256 _amount) internal {\n    // Transfers any premiums owed to stakers from the protocol manager to this contract\n    sherlockProtocolManager.claimPremiumsForStakers();\n\n    // The amount of tokens in this contract\n    uint256 mainBalance = token.balanceOf(address(this));\n\n    // If the amount to transfer out is still greater than the amount of tokens in this contract,\n    // Withdraw yield strategy tokens to make up the difference\n    if (_amount &gt; mainBalance) {\n      yieldStrategy.withdraw(_amount - mainBalance);\n    }\n\n    token.safeTransfer(_receiver, _amount);\n  }\n\n  // Returns the amount of USDC owed to this amount of stakeShares\n  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {\n    // Finds fraction that the given amount of stakeShares represents of the total\n    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers\n    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;\n  }\n\n  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted\n  // Also burns the requisite amount of shares associated with this NFT position\n  // Returns the amount of USDC owed to these shares\n  function _redeemShares(\n    uint256 _id,\n    uint256 _stakeShares,\n    address _receiver\n  ) internal returns (uint256 _amount) {\n    // Returns the amount of USDC owed to this amount of stakeShares\n    _amount = _redeemSharesCalc(_stakeShares);\n    // Transfers _amount of tokens to _receiver address\n    if (_amount != 0) _transferTokensOut(_receiver, _amount);\n\n    // Subtracts this amount of stakeShares from the NFT position\n    stakeShares[_id] -= _stakeShares;\n    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding\n    totalStakeShares -= _stakeShares;\n  }\n\n  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager\n  // Restakes an NFT position (_id) for a given period (_period) and\n  // Sends any previously earned SHER rewards to the _nftOwner address\n  function _restake(\n    uint256 _id,\n    uint256 _period,\n    address _nftOwner\n  ) internal returns (uint256 _sher) {\n    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner\n    // NOTE This function deletes the SHER reward mapping for this NFT ID\n    _sendSherRewardsToOwner(_id, _nftOwner);\n\n    // tokenBalanceOf() returns the USDC amount owed to this NFT ID\n    // _stake() restakes that amount of USDC for the period inputted\n    // We use the same ID that we just deleted the SHER rewards mapping for\n    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID\n    // Note stakeShares for this position do not change so no need to update\n    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);\n\n    emit Restaked(_id);\n  }\n\n  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)\n  /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @param _receiver Address that will receive the NFT representing the position\n  /// @return _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to this ID after _period ends\n  /// @dev _period needs to be whitelisted\n  function initialStake(\n    uint256 _amount,\n    uint256 _period,\n    address _receiver\n  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {\n    if (_amount == 0) revert ZeroArgument();\n    // Makes sure the period is a whitelisted period\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n    if (address(_receiver) == address(0)) revert ZeroArgument();\n    // Adds 1 to the ID of the last NFT created for the new NFT ID\n    _id = ++nftCounter;\n\n    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)\n    token.safeTransferFrom(msg.sender, address(this), _amount);\n\n    uint256 stakeShares;\n    uint256 totalStakeShares_ = totalStakeShares;\n    // amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares\n    if (totalStakeShares != 0)\n      stakeShares_ = (amount * totalStakeShares) / (totalTokenBalanceStakers() - amount);\n      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked\n    else stakeShares = amount;\n\n    // Assigns this NFT ID the calc\'d amount of stake shares above\n    stakeShares[_id] = stakeShares;\n    // Adds the newly created stake shares to the total amount of stake shares\n    totalStakeShares += stakeShares_;\n\n    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake\n    sher = _stake(_amount, _period, _id, _receiver);\n\n    // This is an ERC-721 function that creates an NFT and sends it to the receiver\n    _safeMint(_receiver, _id);\n  }\n\n  // This is how a staker unstakes and cashes out on their position\n  /// @notice Redeem NFT _id and receive _amount of tokens\n  /// @param _id TokenID of the position\n  /// @return _amount Amount of tokens (USDC) owed to NFT ID\n  /// @dev Only the owner of _id will be able to redeem their position\n  /// @dev The SHER rewards are sent to the NFT owner\n  /// @dev Can only be called after lockup _period has ended\n  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {\n    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over\n    _verifyUnlockableByOwner(_id);\n\n    // This is the ERC-721 function to destroy an NFT (with owner\'s approval)\n    _burn(_id);\n\n    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID\n    // Also burns the requisite amount of shares associated with this NFT position\n    // Returns the amount of USDC owed to these shares\n    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);\n\n    // Sends the SHER tokens associated with this NFT ID to the NFT owner\n    _sendSherRewardsToOwner(_id, msg.sender);\n\n    // Removes the unlock deadline associated with this NFT\n    delete lockupEnd[id];\n  }\n\n  // This is how a staker restakes an expired position\n  /// @notice Owner restakes position with ID: _id for _period seconds\n  /// @param _id ID of the position\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @return _sher Amount of SHER tokens to be released to owner address after _period ends\n  /// @dev Only the owner of _id will be able to restake their position using this call\n  /// @dev _period needs to be whitelisted\n  /// @dev Can only be called after lockup _period has ended\n  function ownerRestake(uint256 _id, uint256 _period)\n    external\n    override\n    whenNotPaused\n    returns (uint256 _sher)\n  {\n    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over\n    _verifyUnlockableByOwner(_id);\n\n    // Checks to make sure the staking period is a whitelisted one\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position\n    _sher = _restake(_id, _period, msg.sender);\n  }\n\n  // Calcs the reward (in stake shares) an arb would get for restaking a position\n  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb\n  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {\n    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)\n    uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME;\n\n    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position\n    if (initialArbTime &gt; block.timestamp) return (0, false);\n\n    // The max rewards (as a % of the position\'s shares) for the arb are available at this timestamp\n    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;\n\n    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%\n    uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;\n\n    // Scaled by 1018\n    // Represents the max amount of stake shares that an arb could get from restaking this position\n    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];\n\n    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function\n    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled\n    return (\n      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10*18,\n      true\n    );\n  }\n\n  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position\n  /// @return profit How much profit an arb would make in USDC\n  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)\n  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {\n    // Returns the stake shares that an arb would get, and whether the position can currently be arbed\n    // profit variable is used to store the amount of shares\n    (profit, able) = _calcSharesForArbRestake(_id);\n    // Calculates the tokens (USDC) represented by that amount of stake shares\n    // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit\n    profit = _redeemSharesCalc(profit);\n  }\n\n  /// @notice Allows someone who doesn\'t own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)\n  /// @param _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup\n  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function\n  /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)\n  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)\n  /// @dev During a 2 week period the reward ratio will move from 0% to 100% ( x)\n  function arbRestake(uint256 _id)\n    external\n    override\n    whenNotPaused\n    returns (uint256 _sher, uint256 _arbReward)\n  {\n    address nftOwner = ownerOf(_id);\n\n    // Returns the stake shares that an arb would get, and whether the position can currently be arbed\n    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);\n    // Revert if not able to be arbed\n    if (!able) revert InvalidConditions();\n\n    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward\n    // Also burns the requisite amount of shares associated with this NFT position\n    // Returns the amount of USDC paid to the arbitrager\n    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);\n\n    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)\n    // Sends previously earned SHER rewards to the NFT owner address\n    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);\n\n    emit ArbRestaked(_id, _arbReward);\n  }\n}\n', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-25-08 10:37:00 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@openzeppelin/contracts/token/ERC721/ERC721.sol'; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol'; import '@openzeppelin/contracts/security/Pausable.sol'; import './interfaces/ISherlock.sol'; /// @title Sherlock core interface for stakers /// @author Evert Kors // This is the contract that manages staking actions contract Sherlock is ISherlock, ERC721, Ownable, Pausable {   using SafeERC20 for IERC20; // The initial period for a staker to restake/withdraw without being auto-restaked   uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks; // The period during which the reward for restaking an account (after the inital period) grows   uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks; // Anyone who gets auto-restaked is restaked for this period (3 months)   uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks; // The percentage of someone's stake that can be paid to an arb for restaking   uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20% // USDC address   IERC20 public immutable token; // SHER token address   IERC20 public immutable sher; // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not   mapping(uint256 =&gt; bool) public override stakingPeriods; // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked   mapping(uint256 =&gt; uint256) internal lockupEnd_; // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position   mapping(uint256 =&gt; uint256) internal sherRewards_; // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)   mapping(uint256 =&gt; uint256) internal stakeShares; // Key is account, value is the sum of underlying shares of all the NFTs the account owns.   mapping(address =&gt; uint256) internal addressShares; // Total amount of shares that have been issued to all NFT positions   uint256 internal totalStakeShares; // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)   IStrategyManager public override yieldStrategy; // Instances of relevant Sherlock contracts   ISherDistributionManager public override sherDistributionManager;   ISherlockProtocolManager public override sherlockProtocolManager;   ISherlockClaimManager public override sherlockClaimManager; // Address to which nonstaker payments are made   // This will start out as a multi-sig address, then become a contract address later   address public override nonStakersAddress; // Stores the ID of the most recently created NFT   // This variable is incremented by 1 to create a new NFT ID   uint256 internal nftCounter; // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.   constructor(     IERC20 _token, // USDC address     IERC20 _sher, // SHER token address     string memory _name, // Token collection name (see ERC-721 docs)     string memory _symbol, // Token collection symbol (see ERC-721 docs)     IStrategyManager _yieldStrategy, // The active yield strategy contract     ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract     address _nonStakersAddress, // The address to which nonstakers payments go     ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract     ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract     uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for   ) ERC721(_name, _symbol) {     if (address(_token) == address(0)) revert ZeroArgument();     if (address(_sher) == address(0)) revert ZeroArgument();     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (_nonStakersAddress == address(0)) revert ZeroArgument();     if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();     if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument(); token = _token; sher = _sher; yieldStrategy = _yieldStrategy; sherDistributionManager = _sherDistributionManager; nonStakersAddress = _nonStakersAddress; sherlockProtocolManager = _sherlockProtocolManager; sherlockClaimManager = _sherlockClaimManager;  // Enabling the first set of staking periods that were provided in constructor args for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {   enableStakingPeriod(_initialstakingPeriods[i]); }  emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy); emit SherDistributionManagerUpdated(   ISherDistributionManager(address(0)),   _sherDistributionManager ); emit NonStakerAddressUpdated(address(0), _nonStakersAddress); emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager); emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);  } //   // View functions   // // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked   /// @notice View the current lockup end timestamp of _tokenID   /// @return Timestamp when NFT position unlocks   function lockupEnd(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return lockupEnd_[_tokenID];  } // Returns the SHER rewards owed to this position   /// @notice View the current SHER reward of _tokenID   /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup   function sherRewards(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return sherRewards_[_tokenID];  } // Returns the tokens (USDC) owed to a position   /// @notice View the current token balance claimable upon reaching end of the lockup   /// @return Amount of tokens assigned to owner when unstaking position   function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent();     // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers     return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;   } // Returns the tokens (USDC) owed to an address   /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup   /// @return Amount of tokens assigned to owner when unstaking all positions   function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {     if (_staker == address(0)) revert ZeroArgument();     uint256 _totalStakeShares = totalStakeShares;     if (_totalStakeShares == 0) return 0;     // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers     return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;   } // Gets the total amount of tokens (USDC) owed to stakers   // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract   /// @notice View the current TVL for all stakers   /// @return Total amount of tokens staked   /// @dev Adds principal + strategy + premiums   /// @dev Will calculate the most up to date value for each piece   function totalTokenBalanceStakers() public view override returns (uint256) {     return       token.balanceOf(address(this)) +       yieldStrategy.balanceOf() +       sherlockProtocolManager.claimablePremiums();   } //   // Gov functions   // // Allows governance to add a new staking period (4 months, etc.)   /// @notice Allows stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already enabled   function enableStakingPeriod(uint256 _period) public override onlyOwner {     if (_period == 0) revert ZeroArgument();     // Revert if staking period is already active     if (stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to true stakingPeriods[_period] = true; emit StakingPeriodEnabled(_period);  } // Allows governance to remove a staking period (4 months, etc.)   /// @notice Disallow stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already disabled   function disableStakingPeriod(uint256 _period) external override onlyOwner {     // Revert if staking period is already inactive     if (!stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to false stakingPeriods[_period] = false; emit StakingPeriodDisabled(_period);  } // Sets a new contract to be the active SHER distribution manager   /// @notice Update SHER distribution manager contract   /// @param _sherDistributionManager New adddress of the manager   function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)     external     override     onlyOwner   {     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument(); emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager); sherDistributionManager = _sherDistributionManager;  } // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)   /// @notice Remove SHER token rewards   function removeSherDistributionManager() external override onlyOwner {     if (address(sherDistributionManager) == address(0)) revert InvalidConditions(); emit SherDistributionManagerUpdated(   sherDistributionManager,   ISherDistributionManager(address(0)) ); delete sherDistributionManager;  } // Sets a new address for nonstakers payments   /// @notice Update address eligble for non staker rewards from protocol premiums   /// @param _nonStakers Address eligble for non staker rewards   function updateNonStakersAddress(address _nonStakers) external override onlyOwner {     if (address(_nonStakers) == address(0)) revert ZeroArgument();     if (nonStakersAddress == _nonStakers) revert InvalidArgument(); emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers); nonStakersAddress = _nonStakers;  } // Sets a new protocol manager contract   /// @notice Transfer protocol manager implementation address   /// @param _protocolManager new implementation address   function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)     external     override     onlyOwner   {     if (address(_protocolManager) == address(0)) revert ZeroArgument();     if (sherlockProtocolManager == _protocolManager) revert InvalidArgument(); emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager); sherlockProtocolManager = _protocolManager;  } // Sets a new claim manager contract   /// @notice Transfer claim manager role to different address   /// @param _claimManager New address of claim manager   function updateSherlockClaimManager(ISherlockClaimManager _claimManager)     external     override     onlyOwner   {     if (address(_claimManager) == address(0)) revert ZeroArgument();     if (sherlockClaimManager == _claimManager) revert InvalidArgument(); emit ClaimManagerUpdated(sherlockClaimManager, _claimManager); sherlockClaimManager = _claimManager;  } // Sets a new yield strategy manager contract   /// @notice Update yield strategy   /// @param _yieldStrategy News address of the strategy   /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure   function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (yieldStrategy == _yieldStrategy) revert InvalidArgument(); // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason. // In case this happens. We still want the yield strategy to be updated. // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again. try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {   emit YieldStrategyUpdateWithdrawAllError(reason); }  emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy); yieldStrategy = _yieldStrategy;  } // Deposits a chosen amount of tokens (USDC) into the active yield strategy   /// @notice Deposit _amount into active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); // Transfers any tokens owed to stakers from the protocol manager contract to this contract first sherlockProtocolManager.claimPremiumsForStakers(); // Transfers the amount of tokens to the yield strategy contract token.safeTransfer(address(yieldStrategy), _amount); // Deposits all tokens in the yield strategy contract into the actual yield strategy yieldStrategy.deposit();  } // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract   /// @notice Withdraw _amount from active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); yieldStrategy.withdraw(_amount);  } // Withdraws all tokens from the yield strategy back into this contract   /// @notice Withdraw all funds from active strategy   /// @dev gov only   function yieldStrategyWithdrawAll() external override onlyOwner {     yieldStrategy.withdrawAll();   } /// @notice Pause external functions in all contracts   /// @dev A manager can be replaced with the new contract in a paused state   /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused   function pause() external onlyOwner {     _pause();     if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();     // sherDistributionManager can be 0, pause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       !Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.pause();     }     if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();     if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();   } /// @notice Unpause external functions in all contracts   /// @dev A manager can be replaced with the new contract in an unpaused state   /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused   function unpause() external onlyOwner {     _unpause();     if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();     // sherDistributionManager can be 0, unpause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.unpause();     }     if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();     if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();   } //   // Access control functions   // /// @notice Account sum of all underlying posiiton shares for _from and _to   /// @dev this enables the tokenBalanceOfAddress to exist   function _beforeTokenTransfer(     address _from,     address _to,     uint256 _tokenID   ) internal override {     uint256 _stakeShares = stakeShares[_tokenID]; if (_from != address(0)) addressShares[_from] -= _stakeShares; if (_to != address(0)) addressShares[_to] += _stakeShares;  } // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)   // This function is called by the Sherlock claim manager contract if a claim is approved   /// @notice Initiate a payout of _amount to _receiver   /// @param _receiver Receiver of payout   /// @param _amount Amount to send   /// @dev only payout manager should call this   /// @dev should pull money out of strategy   function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {     // Can only be called by the Sherlock claim manager contract     if (msg.sender != address(sherlockClaimManager)) revert Unauthorized(); if (_amount != 0) {   // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)   _transferTokensOut(_receiver, _amount); } emit ClaimPayout(_receiver, _amount);  } //   // Non-access control functions   // // Helper function for initial staking and restaking   // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position   /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds   /// @param amount Amount of tokens to stake   /// @param _period Period of time for which funds get locked   /// @param _id ID for this NFT position   /// @param _receiver Address that will be linked to this position   /// @return _sher Amount of SHER tokens awarded to this position after _period ends   /// @dev _period needs to be whitelisted   function _stake(     uint256 _amount,     uint256 _period,     uint256 _id,     address _receiver   ) internal returns (uint256 _sher) {     // Sets the timestamp at which this position can first be unstaked/restaked     lockupEnd[_id] = block.timestamp + _period; if (address(sherDistributionManager) == address(0)) return 0; // Does not allow restaking of 0 tokens if (_amount == 0) return 0;  // Checks this amount of SHER tokens in this contract before we transfer new ones uint256 before = sher.balanceOf(address(this));  // pullReward() calcs then actually transfers the SHER tokens to this contract // in case this call fails, whole (re)staking transaction fails _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);  // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position uint256 actualAmount = sher.balanceOf(address(this)) - before; if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount); // Assigns the newly created SHER tokens to the current stake position if (_sher != 0) sherRewards_[_id] = _sher;  } // Checks to see if the NFT owner is the caller and that the position is unlockable   function verifyUnlockableByOwner(uint256 _id) internal view {     if (ownerOf(_id) != msg.sender) revert Unauthorized();     if (lockupEnd[_id] &gt; block.timestamp) revert InvalidConditions();   } // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner   function sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards[_id];     if (sherReward == 0) return; // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner sher.safeTransfer(_nftOwner, sherReward); // Deletes the SHER reward mapping for this NFT ID delete sherRewards_[_id];  } // Transfers an amount of tokens to the receiver address   // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)   function _transferTokensOut(address _receiver, uint256 _amount) internal {     // Transfers any premiums owed to stakers from the protocol manager to this contract     sherlockProtocolManager.claimPremiumsForStakers(); // The amount of tokens in this contract uint256 mainBalance = token.balanceOf(address(this));  // If the amount to transfer out is still greater than the amount of tokens in this contract, // Withdraw yield strategy tokens to make up the difference if (_amount &gt; mainBalance) {   yieldStrategy.withdraw(_amount - mainBalance); }  token.safeTransfer(_receiver, _amount);  } // Returns the amount of USDC owed to this amount of stakeShares   function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {     // Finds fraction that the given amount of stakeShares represents of the total     // Then multiplies it by the total amount of tokens (USDC) owed to all stakers     return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;   } // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted   // Also burns the requisite amount of shares associated with this NFT position   // Returns the amount of USDC owed to these shares   function _redeemShares(     uint256 _id,     uint256 _stakeShares,     address _receiver   ) internal returns (uint256 _amount) {     // Returns the amount of USDC owed to this amount of stakeShares     _amount = _redeemSharesCalc(_stakeShares);     // Transfers _amount of tokens to _receiver address     if (_amount != 0) _transferTokensOut(_receiver, _amount); // Subtracts this amount of stakeShares from the NFT position stakeShares[_id] -= _stakeShares; // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding totalStakeShares -= _stakeShares;  } // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager   // Restakes an NFT position (_id) for a given period (_period) and   // Sends any previously earned SHER rewards to the _nftOwner address   function _restake(     uint256 _id,     uint256 _period,     address _nftOwner   ) internal returns (uint256 _sher) {     // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner     // NOTE This function deletes the SHER reward mapping for this NFT ID     _sendSherRewardsToOwner(_id, _nftOwner); // tokenBalanceOf() returns the USDC amount owed to this NFT ID // _stake() restakes that amount of USDC for the period inputted // We use the same ID that we just deleted the SHER rewards mapping for // Resets the lockupEnd mapping and SHER token rewards mapping for this ID // Note stakeShares for this position do not change so no need to update _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);  emit Restaked(_id);  } // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)   /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt   /// @param _amount Amount of tokens to stake   /// @param _period Period of time, in seconds, to lockup your funds   /// @param _receiver Address that will receive the NFT representing the position   /// @return _id ID of the position   /// @return _sher Amount of SHER tokens to be released to this ID after _period ends   /// @dev _period needs to be whitelisted   function initialStake(     uint256 _amount,     uint256 _period,     address _receiver   ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {     if (_amount == 0) revert ZeroArgument();     // Makes sure the period is a whitelisted period     if (!stakingPeriods[_period]) revert InvalidArgument();     if (address(_receiver) == address(0)) revert ZeroArgument();     // Adds 1 to the ID of the last NFT created for the new NFT ID     _id = ++nftCounter; // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action) token.safeTransferFrom(msg.sender, address(this), _amount);  uint256 stakeShares_; uint256 totalStakeShares_ = totalStakeShares; // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares if (totalStakeShares_ != 0)   stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);   // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked else stakeShares_ = _amount;  // Assigns this NFT ID the calc'd amount of stake shares above stakeShares[_id] = stakeShares_; // Adds the newly created stake shares to the total amount of stake shares totalStakeShares += stakeShares_;  // Locks up the USDC amount and calcs the SHER token amount to receive on unstake _sher = _stake(_amount, _period, _id, _receiver);  // This is an ERC-721 function that creates an NFT and sends it to the receiver _safeMint(_receiver, _id);  } // This is how a staker unstakes and cashes out on their position   /// @notice Redeem NFT _id and receive _amount of tokens   /// @param _id TokenID of the position   /// @return _amount Amount of tokens (USDC) owed to NFT ID   /// @dev Only the owner of _id will be able to redeem their position   /// @dev The SHER rewards are sent to the NFT owner   /// @dev Can only be called after lockup _period has ended   function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // This is the ERC-721 function to destroy an NFT (with owner's approval) _burn(_id);  // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC owed to these shares _amount = _redeemShares(_id, stakeShares[_id], msg.sender);  // Sends the SHER tokens associated with this NFT ID to the NFT owner _sendSherRewardsToOwner(_id, msg.sender);  // Removes the unlock deadline associated with this NFT delete lockupEnd_[_id];  } // This is how a staker restakes an expired position   /// @notice Owner restakes position with ID: _id for _period seconds   /// @param _id ID of the position   /// @param _period Period of time, in seconds, to lockup your funds   /// @return _sher Amount of SHER tokens to be released to owner address after _period ends   /// @dev Only the owner of _id will be able to restake their position using this call   /// @dev _period needs to be whitelisted   /// @dev Can only be called after lockup _period has ended   function ownerRestake(uint256 _id, uint256 _period)     external     override     whenNotPaused     returns (uint256 _sher)   {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // Checks to make sure the staking period is a whitelisted one if (!stakingPeriods[_period]) revert InvalidArgument();  // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position _sher = _restake(_id, _period, msg.sender);  } // Calcs the reward (in stake shares) an arb would get for restaking a position   // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb   function calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {     // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)     uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME; // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position if (initialArbTime &gt; block.timestamp) return (0, false);  // The max rewards (as a % of the position's shares) for the arb are available at this timestamp uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;  // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100% uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;  // Scaled by 10**18 // Represents the max amount of stake shares that an arb could get from restaking this position uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];  // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled return (   ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,   true );  } /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position   /// @return profit How much profit an arb would make in USDC   /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)   function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {     // Returns the stake shares that an arb would get, and whether the position can currently be arbed     // profit variable is used to store the amount of shares     (profit, able) = _calcSharesForArbRestake(_id);     // Calculates the tokens (USDC) represented by that amount of stake shares     // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit     profit = _redeemSharesCalc(profit);   } /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)   /// @param _id ID of the position   /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup   /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function   /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)   /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)   /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)   function arbRestake(uint256 _id)     external     override     whenNotPaused     returns (uint256 _sher, uint256 _arbReward)   {     address nftOwner = ownerOf(_id); // Returns the stake shares that an arb would get, and whether the position can currently be arbed (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id); // Revert if not able to be arbed if (!able) revert InvalidConditions();  // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC paid to the arbitrager _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);  // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months) // Sends previously earned SHER rewards to the NFT owner address _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);  emit ArbRestaked(_id, _arbReward);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-25-08 10:37:00 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';

import './interfaces/ISherlock.sol';

/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions

contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;

  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;

  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;

  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;

  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%

  // USDC address
  IERC20 public immutable token;

  // SHER token address
  IERC20 public immutable sher;

  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;

  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;

  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;

  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;

  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;

  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;

  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;

  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;

  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;

  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;

  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();

    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;

    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }

    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }

  //
  // View functions
  //

  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return lockupEnd_[_tokenID];
  }

  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return sherRewards_[_tokenID];
  }

  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }

  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }

  //
  // Gov functions
  //

  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }

  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }

  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();

    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }

  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();

    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }

  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();

    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }

  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();

    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }

  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();

    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }

  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();

    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }

    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }

  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }

  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    yieldStrategy.withdraw(_amount);
  }

  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }

  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }

  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }

  //
  // Access control functions
  //

  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];

    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }

  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();

    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }

  //
  // Non-access control functions
  //

  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;

    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;

    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));

    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);

    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }

  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }

  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;

    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }

  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();

    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));

    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }

    token.safeTransfer(_receiver, _amount);
  }

  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);

    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }

  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);

    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);

    emit Restaked(_id);
  }

  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;

    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);

    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;

    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;

    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);

    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }

  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);

    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);

    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);

    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }

  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }

  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;

    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);

    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;

    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;

    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];

    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }

  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }

  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);

    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();

    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);

    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);

    emit ArbRestaked(_id, _arbReward);
  }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';

import './interfaces/ISherlock.sol';

/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions

contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;

  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;

  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;

  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;

  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%

  // USDC address
  IERC20 public immutable token;

  // SHER token address
  IERC20 public immutable sher;

  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;

  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;

  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;

  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;

  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;

  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;

  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;

  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;

  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;

  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;

  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();

    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;

    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }

    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }

  //
  // View functions
  //

  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return lockupEnd_[_tokenID];
  }

  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return sherRewards_[_tokenID];
  }

  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }

  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }

  //
  // Gov functions
  //

  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }

  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }

  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();

    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }

  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();

    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }

  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();

    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }

  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();

    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }

  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();

    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }

  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();

    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }

    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }

  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }

  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    yieldStrategy.withdraw(_amount);
  }

  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }

  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }

  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }

  //
  // Access control functions
  //

  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];

    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }

  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();

    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }

  //
  // Non-access control functions
  //

  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;

    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;

    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));

    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);

    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }

  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }

  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;

    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }

  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();

    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));

    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }

    token.safeTransfer(_receiver, _amount);
  }

  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);

    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }

  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);

    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);

    emit Restaked(_id);
  }

  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;

    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);

    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;

    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;

    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);

    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }

  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);

    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);

    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);

    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }

  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }

  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;

    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);

    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;

    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;

    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];

    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }

  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }

  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);

    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();

    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);

    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);

    emit ArbRestaked(_id, _arbReward);
  }
}
".
Ideas: " 1".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-25-08 10:37:11 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-25-08 10:37:11 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 15564
completion_tokens: 801
total_tokens: 16365
cost: $-1.000000


[2024-25-08 10:37:11 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';

import './interfaces/ISherlock.sol';

/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions

contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;

  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;

  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;

  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;

  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%

  // USDC address
  IERC20 public immutable token;

  // SHER token address
  IERC20 public immutable sher;

  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;

  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;

  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;

  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;

  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;

  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;

  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;

  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;

  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;

  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;

  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();

    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;

    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }

    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }

  //
  // View functions
  //

  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return lockupEnd_[_tokenID];
  }

  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return sherRewards_[_tokenID];
  }

  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }

  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }

  //
  // Gov functions
  //

  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }

  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }

  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();

    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }

  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();

    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }

  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();

    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }

  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();

    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }

  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();

    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }

  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();

    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }

    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }

  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }

  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    yieldStrategy.withdraw(_amount);
  }

  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }

  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }

  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }

  //
  // Access control functions
  //

  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];

    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }

  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();

    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }

  //
  // Non-access control functions
  //

  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;

    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;

    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));

    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);

    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }

  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }

  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;

    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }

  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();

    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));

    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }

    token.safeTransfer(_receiver, _amount);
  }

  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);

    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }

  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);

    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);

    emit Restaked(_id);
  }

  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;

    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);

    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;

    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;

    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);

    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }

  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);

    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);

    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);

    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }

  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }

  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;

    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);

    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;

    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;

    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];

    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }

  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }

  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);

    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();

    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);

    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);

    emit ArbRestaked(_id, _arbReward);
  }
}
.]

### VULNERABILITY 1: Reentrancy Attack
```
DETAILED DESCRIPTION: The contract does not implement a reentrancy guard in functions that transfer tokens (e.g., `_transferTokensOut`, `payoutClaim`, and `_redeemShares`). This could allow an attacker to recursively call these functions before the state changes are finalized, leading to unexpected behavior and potential loss of funds.

RECOMMENDED MITIGATION: Implement a reentrancy guard using the `nonReentrant` modifier from OpenZeppelin's ReentrancyGuard contract. This should be applied to any function that transfers tokens or modifies state variables.
```

### VULNERABILITY 2: Integer Overflow/Underflow
```
DETAILED DESCRIPTION: Although Solidity 0.8.x has built-in overflow and underflow checks, there are still areas where calculations could lead to unexpected results, particularly in functions like `_redeemSharesCalc` and `_stake`. If not properly handled, this could lead to incorrect calculations of shares or rewards.

RECOMMENDED MITIGATION: Ensure that all arithmetic operations are checked for potential overflows or underflows, especially when dealing with user inputs or external calls. Consider using SafeMath for clarity, even though it's not strictly necessary in Solidity 0.8.x.
```

### VULNERABILITY 3: Improper Access Control
```
DETAILED DESCRIPTION: The `payoutClaim` function can be called by any address, but it should only be callable by the `sherlockClaimManager`. If the `sherlockClaimManager` address is compromised, an attacker could initiate payouts to any address.

RECOMMENDED MITIGATION: Ensure that the `payoutClaim` function has proper access control checks. Use the `onlyOwner` modifier or a similar access control mechanism to restrict who can call this function.
```

### VULNERABILITY 4: Lack of Input Validation
```
DETAILED DESCRIPTION: Functions such as `enableStakingPeriod`, `disableStakingPeriod`, and `updateSherDistributionManager` do not validate the input parameters thoroughly. For example, enabling a staking period with a value of zero is allowed, which could lead to unexpected behavior.

RECOMMENDED MITIGATION: Add additional checks to validate input parameters. For instance, ensure that staking periods are greater than zero and that the new distribution manager address is not the zero address.
```

### VULNERABILITY 5: Potential for Denial of Service (DoS)
```
DETAILED DESCRIPTION: The contract relies on external calls to other contracts (e.g., `yieldStrategy`, `sherDistributionManager`, etc.). If any of these contracts revert during execution, it could lead to a denial of service for the entire function call, preventing legitimate users from interacting with the contract.

RECOMMENDED MITIGATION: Use try/catch blocks for external calls to handle failures gracefully. This will allow the contract to continue functioning even if an external call fails.
```

### VULNERABILITY 6: Unchecked External Calls
```
DETAILED DESCRIPTION: The contract makes external calls to other contracts (e.g., `sherDistributionManager.pullReward`). If these calls fail, the contract does not handle the failure, which could lead to unexpected behavior or loss of funds.

RECOMMENDED MITIGATION: Always check the return value of external calls and handle failures appropriately. Consider using `require` statements to ensure that external calls succeed.
```

### VULNERABILITY 7: Token Transfer Issues
```
DETAILED DESCRIPTION: The `_transferTokensOut` function does not check if the token transfer was successful. If the token contract has a non-standard implementation that does not return a boolean value, the transfer could fail silently.

RECOMMENDED MITIGATION: Use `require` statements to ensure that token transfers are successful. For example, after calling `token.safeTransfer`, check that the transfer was successful.


[2024-25-08 10:37:11 INFO] **[Seminar Conclusion]**:

 ### VULNERABILITY 1: Reentrancy Attack
```
DETAILED DESCRIPTION: The contract does not implement a reentrancy guard in functions that transfer tokens (e.g., `_transferTokensOut`, `payoutClaim`, and `_redeemShares`). This could allow an attacker to recursively call these functions before the state changes are finalized, leading to unexpected behavior and potential loss of funds.

RECOMMENDED MITIGATION: Implement a reentrancy guard using the `nonReentrant` modifier from OpenZeppelin's ReentrancyGuard contract. This should be applied to any function that transfers tokens or modifies state variables.
```

### VULNERABILITY 2: Integer Overflow/Underflow
```
DETAILED DESCRIPTION: Although Solidity 0.8.x has built-in overflow and underflow checks, there are still areas where calculations could lead to unexpected results, particularly in functions like `_redeemSharesCalc` and `_stake`. If not properly handled, this could lead to incorrect calculations of shares or rewards.

RECOMMENDED MITIGATION: Ensure that all arithmetic operations are checked for potential overflows or underflows, especially when dealing with user inputs or external calls. Consider using SafeMath for clarity, even though it's not strictly necessary in Solidity 0.8.x.
```

### VULNERABILITY 3: Improper Access Control
```
DETAILED DESCRIPTION: The `payoutClaim` function can be called by any address, but it should only be callable by the `sherlockClaimManager`. If the `sherlockClaimManager` address is compromised, an attacker could initiate payouts to any address.

RECOMMENDED MITIGATION: Ensure that the `payoutClaim` function has proper access control checks. Use the `onlyOwner` modifier or a similar access control mechanism to restrict who can call this function.
```

### VULNERABILITY 4: Lack of Input Validation
```
DETAILED DESCRIPTION: Functions such as `enableStakingPeriod`, `disableStakingPeriod`, and `updateSherDistributionManager` do not validate the input parameters thoroughly. For example, enabling a staking period with a value of zero is allowed, which could lead to unexpected behavior.

RECOMMENDED MITIGATION: Add additional checks to validate input parameters. For instance, ensure that staking periods are greater than zero and that the new distribution manager address is not the zero address.
```

### VULNERABILITY 5: Potential for Denial of Service (DoS)
```
DETAILED DESCRIPTION: The contract relies on external calls to other contracts (e.g., `yieldStrategy`, `sherDistributionManager`, etc.). If any of these contracts revert during execution, it could lead to a denial of service for the entire function call, preventing legitimate users from interacting with the contract.

RECOMMENDED MITIGATION: Use try/catch blocks for external calls to handle failures gracefully. This will allow the contract to continue functioning even if an external call fails.
```

### VULNERABILITY 6: Unchecked External Calls
```
DETAILED DESCRIPTION: The contract makes external calls to other contracts (e.g., `sherDistributionManager.pullReward`). If these calls fail, the contract does not handle the failure, which could lead to unexpected behavior or loss of funds.

RECOMMENDED MITIGATION: Always check the return value of external calls and handle failures appropriately. Consider using `require` statements to ensure that external calls succeed.
```

### VULNERABILITY 7: Token Transfer Issues
```
DETAILED DESCRIPTION: The `_transferTokensOut` function does not check if the token transfer was successful. If the token contract has a non-standard implementation that does not return a boolean value, the transfer could fail silently.

RECOMMENDED MITIGATION: Use `require` statements to ensure that token transfers are successful. For example, after calling `token.safeTransfer`, check that the transfer was successful.


[2024-25-08 10:37:11 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-25-08 10:37:11 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@openzeppelin/contracts/token/ERC721/ERC721.sol'; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol'; import '@openzeppelin/contracts/security/Pausable.sol'; import './interfaces/ISherlock.sol'; /// @title Sherlock core interface for stakers /// @author Evert Kors // This is the contract that manages staking actions contract Sherlock is ISherlock, ERC721, Ownable, Pausable {   using SafeERC20 for IERC20; // The initial period for a staker to restake/withdraw without being auto-restaked   uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks; // The period during which the reward for restaking an account (after the inital period) grows   uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks; // Anyone who gets auto-restaked is restaked for this period (3 months)   uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks; // The percentage of someone's stake that can be paid to an arb for restaking   uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20% // USDC address   IERC20 public immutable token; // SHER token address   IERC20 public immutable sher; // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not   mapping(uint256 =&gt; bool) public override stakingPeriods; // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked   mapping(uint256 =&gt; uint256) internal lockupEnd_; // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position   mapping(uint256 =&gt; uint256) internal sherRewards_; // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)   mapping(uint256 =&gt; uint256) internal stakeShares; // Key is account, value is the sum of underlying shares of all the NFTs the account owns.   mapping(address =&gt; uint256) internal addressShares; // Total amount of shares that have been issued to all NFT positions   uint256 internal totalStakeShares; // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)   IStrategyManager public override yieldStrategy; // Instances of relevant Sherlock contracts   ISherDistributionManager public override sherDistributionManager;   ISherlockProtocolManager public override sherlockProtocolManager;   ISherlockClaimManager public override sherlockClaimManager; // Address to which nonstaker payments are made   // This will start out as a multi-sig address, then become a contract address later   address public override nonStakersAddress; // Stores the ID of the most recently created NFT   // This variable is incremented by 1 to create a new NFT ID   uint256 internal nftCounter; // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.   constructor(     IERC20 _token, // USDC address     IERC20 _sher, // SHER token address     string memory _name, // Token collection name (see ERC-721 docs)     string memory _symbol, // Token collection symbol (see ERC-721 docs)     IStrategyManager _yieldStrategy, // The active yield strategy contract     ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract     address _nonStakersAddress, // The address to which nonstakers payments go     ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract     ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract     uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for   ) ERC721(_name, _symbol) {     if (address(_token) == address(0)) revert ZeroArgument();     if (address(_sher) == address(0)) revert ZeroArgument();     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (_nonStakersAddress == address(0)) revert ZeroArgument();     if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();     if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument(); token = _token; sher = _sher; yieldStrategy = _yieldStrategy; sherDistributionManager = _sherDistributionManager; nonStakersAddress = _nonStakersAddress; sherlockProtocolManager = _sherlockProtocolManager; sherlockClaimManager = _sherlockClaimManager;  // Enabling the first set of staking periods that were provided in constructor args for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {   enableStakingPeriod(_initialstakingPeriods[i]); }  emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy); emit SherDistributionManagerUpdated(   ISherDistributionManager(address(0)),   _sherDistributionManager ); emit NonStakerAddressUpdated(address(0), _nonStakersAddress); emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager); emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);  } //   // View functions   // // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked   /// @notice View the current lockup end timestamp of _tokenID   /// @return Timestamp when NFT position unlocks   function lockupEnd(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return lockupEnd_[_tokenID];  } // Returns the SHER rewards owed to this position   /// @notice View the current SHER reward of _tokenID   /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup   function sherRewards(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return sherRewards_[_tokenID];  } // Returns the tokens (USDC) owed to a position   /// @notice View the current token balance claimable upon reaching end of the lockup   /// @return Amount of tokens assigned to owner when unstaking position   function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent();     // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers     return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;   } // Returns the tokens (USDC) owed to an address   /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup   /// @return Amount of tokens assigned to owner when unstaking all positions   function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {     if (_staker == address(0)) revert ZeroArgument();     uint256 _totalStakeShares = totalStakeShares;     if (_totalStakeShares == 0) return 0;     // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers     return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;   } // Gets the total amount of tokens (USDC) owed to stakers   // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract   /// @notice View the current TVL for all stakers   /// @return Total amount of tokens staked   /// @dev Adds principal + strategy + premiums   /// @dev Will calculate the most up to date value for each piece   function totalTokenBalanceStakers() public view override returns (uint256) {     return       token.balanceOf(address(this)) +       yieldStrategy.balanceOf() +       sherlockProtocolManager.claimablePremiums();   } //   // Gov functions   // // Allows governance to add a new staking period (4 months, etc.)   /// @notice Allows stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already enabled   function enableStakingPeriod(uint256 _period) public override onlyOwner {     if (_period == 0) revert ZeroArgument();     // Revert if staking period is already active     if (stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to true stakingPeriods[_period] = true; emit StakingPeriodEnabled(_period);  } // Allows governance to remove a staking period (4 months, etc.)   /// @notice Disallow stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already disabled   function disableStakingPeriod(uint256 _period) external override onlyOwner {     // Revert if staking period is already inactive     if (!stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to false stakingPeriods[_period] = false; emit StakingPeriodDisabled(_period);  } // Sets a new contract to be the active SHER distribution manager   /// @notice Update SHER distribution manager contract   /// @param _sherDistributionManager New adddress of the manager   function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)     external     override     onlyOwner   {     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument(); emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager); sherDistributionManager = _sherDistributionManager;  } // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)   /// @notice Remove SHER token rewards   function removeSherDistributionManager() external override onlyOwner {     if (address(sherDistributionManager) == address(0)) revert InvalidConditions(); emit SherDistributionManagerUpdated(   sherDistributionManager,   ISherDistributionManager(address(0)) ); delete sherDistributionManager;  } // Sets a new address for nonstakers payments   /// @notice Update address eligble for non staker rewards from protocol premiums   /// @param _nonStakers Address eligble for non staker rewards   function updateNonStakersAddress(address _nonStakers) external override onlyOwner {     if (address(_nonStakers) == address(0)) revert ZeroArgument();     if (nonStakersAddress == _nonStakers) revert InvalidArgument(); emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers); nonStakersAddress = _nonStakers;  } // Sets a new protocol manager contract   /// @notice Transfer protocol manager implementation address   /// @param _protocolManager new implementation address   function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)     external     override     onlyOwner   {     if (address(_protocolManager) == address(0)) revert ZeroArgument();     if (sherlockProtocolManager == _protocolManager) revert InvalidArgument(); emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager); sherlockProtocolManager = _protocolManager;  } // Sets a new claim manager contract   /// @notice Transfer claim manager role to different address   /// @param _claimManager New address of claim manager   function updateSherlockClaimManager(ISherlockClaimManager _claimManager)     external     override     onlyOwner   {     if (address(_claimManager) == address(0)) revert ZeroArgument();     if (sherlockClaimManager == _claimManager) revert InvalidArgument(); emit ClaimManagerUpdated(sherlockClaimManager, _claimManager); sherlockClaimManager = _claimManager;  } // Sets a new yield strategy manager contract   /// @notice Update yield strategy   /// @param _yieldStrategy News address of the strategy   /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure   function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (yieldStrategy == _yieldStrategy) revert InvalidArgument(); // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason. // In case this happens. We still want the yield strategy to be updated. // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again. try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {   emit YieldStrategyUpdateWithdrawAllError(reason); }  emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy); yieldStrategy = _yieldStrategy;  } // Deposits a chosen amount of tokens (USDC) into the active yield strategy   /// @notice Deposit _amount into active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); // Transfers any tokens owed to stakers from the protocol manager contract to this contract first sherlockProtocolManager.claimPremiumsForStakers(); // Transfers the amount of tokens to the yield strategy contract token.safeTransfer(address(yieldStrategy), _amount); // Deposits all tokens in the yield strategy contract into the actual yield strategy yieldStrategy.deposit();  } // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract   /// @notice Withdraw _amount from active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); yieldStrategy.withdraw(_amount);  } // Withdraws all tokens from the yield strategy back into this contract   /// @notice Withdraw all funds from active strategy   /// @dev gov only   function yieldStrategyWithdrawAll() external override onlyOwner {     yieldStrategy.withdrawAll();   } /// @notice Pause external functions in all contracts   /// @dev A manager can be replaced with the new contract in a paused state   /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused   function pause() external onlyOwner {     _pause();     if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();     // sherDistributionManager can be 0, pause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       !Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.pause();     }     if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();     if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();   } /// @notice Unpause external functions in all contracts   /// @dev A manager can be replaced with the new contract in an unpaused state   /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused   function unpause() external onlyOwner {     _unpause();     if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();     // sherDistributionManager can be 0, unpause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.unpause();     }     if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();     if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();   } //   // Access control functions   // /// @notice Account sum of all underlying posiiton shares for _from and _to   /// @dev this enables the tokenBalanceOfAddress to exist   function _beforeTokenTransfer(     address _from,     address _to,     uint256 _tokenID   ) internal override {     uint256 _stakeShares = stakeShares[_tokenID]; if (_from != address(0)) addressShares[_from] -= _stakeShares; if (_to != address(0)) addressShares[_to] += _stakeShares;  } // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)   // This function is called by the Sherlock claim manager contract if a claim is approved   /// @notice Initiate a payout of _amount to _receiver   /// @param _receiver Receiver of payout   /// @param _amount Amount to send   /// @dev only payout manager should call this   /// @dev should pull money out of strategy   function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {     // Can only be called by the Sherlock claim manager contract     if (msg.sender != address(sherlockClaimManager)) revert Unauthorized(); if (_amount != 0) {   // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)   _transferTokensOut(_receiver, _amount); } emit ClaimPayout(_receiver, _amount);  } //   // Non-access control functions   // // Helper function for initial staking and restaking   // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position   /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds   /// @param amount Amount of tokens to stake   /// @param _period Period of time for which funds get locked   /// @param _id ID for this NFT position   /// @param _receiver Address that will be linked to this position   /// @return _sher Amount of SHER tokens awarded to this position after _period ends   /// @dev _period needs to be whitelisted   function _stake(     uint256 _amount,     uint256 _period,     uint256 _id,     address _receiver   ) internal returns (uint256 _sher) {     // Sets the timestamp at which this position can first be unstaked/restaked     lockupEnd[_id] = block.timestamp + _period; if (address(sherDistributionManager) == address(0)) return 0; // Does not allow restaking of 0 tokens if (_amount == 0) return 0;  // Checks this amount of SHER tokens in this contract before we transfer new ones uint256 before = sher.balanceOf(address(this));  // pullReward() calcs then actually transfers the SHER tokens to this contract // in case this call fails, whole (re)staking transaction fails _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);  // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position uint256 actualAmount = sher.balanceOf(address(this)) - before; if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount); // Assigns the newly created SHER tokens to the current stake position if (_sher != 0) sherRewards_[_id] = _sher;  } // Checks to see if the NFT owner is the caller and that the position is unlockable   function verifyUnlockableByOwner(uint256 _id) internal view {     if (ownerOf(_id) != msg.sender) revert Unauthorized();     if (lockupEnd[_id] &gt; block.timestamp) revert InvalidConditions();   } // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner   function sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards[_id];     if (sherReward == 0) return; // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner sher.safeTransfer(_nftOwner, sherReward); // Deletes the SHER reward mapping for this NFT ID delete sherRewards_[_id];  } // Transfers an amount of tokens to the receiver address   // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)   function _transferTokensOut(address _receiver, uint256 _amount) internal {     // Transfers any premiums owed to stakers from the protocol manager to this contract     sherlockProtocolManager.claimPremiumsForStakers(); // The amount of tokens in this contract uint256 mainBalance = token.balanceOf(address(this));  // If the amount to transfer out is still greater than the amount of tokens in this contract, // Withdraw yield strategy tokens to make up the difference if (_amount &gt; mainBalance) {   yieldStrategy.withdraw(_amount - mainBalance); }  token.safeTransfer(_receiver, _amount);  } // Returns the amount of USDC owed to this amount of stakeShares   function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {     // Finds fraction that the given amount of stakeShares represents of the total     // Then multiplies it by the total amount of tokens (USDC) owed to all stakers     return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;   } // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted   // Also burns the requisite amount of shares associated with this NFT position   // Returns the amount of USDC owed to these shares   function _redeemShares(     uint256 _id,     uint256 _stakeShares,     address _receiver   ) internal returns (uint256 _amount) {     // Returns the amount of USDC owed to this amount of stakeShares     _amount = _redeemSharesCalc(_stakeShares);     // Transfers _amount of tokens to _receiver address     if (_amount != 0) _transferTokensOut(_receiver, _amount); // Subtracts this amount of stakeShares from the NFT position stakeShares[_id] -= _stakeShares; // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding totalStakeShares -= _stakeShares;  } // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager   // Restakes an NFT position (_id) for a given period (_period) and   // Sends any previously earned SHER rewards to the _nftOwner address   function _restake(     uint256 _id,     uint256 _period,     address _nftOwner   ) internal returns (uint256 _sher) {     // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner     // NOTE This function deletes the SHER reward mapping for this NFT ID     _sendSherRewardsToOwner(_id, _nftOwner); // tokenBalanceOf() returns the USDC amount owed to this NFT ID // _stake() restakes that amount of USDC for the period inputted // We use the same ID that we just deleted the SHER rewards mapping for // Resets the lockupEnd mapping and SHER token rewards mapping for this ID // Note stakeShares for this position do not change so no need to update _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);  emit Restaked(_id);  } // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)   /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt   /// @param _amount Amount of tokens to stake   /// @param _period Period of time, in seconds, to lockup your funds   /// @param _receiver Address that will receive the NFT representing the position   /// @return _id ID of the position   /// @return _sher Amount of SHER tokens to be released to this ID after _period ends   /// @dev _period needs to be whitelisted   function initialStake(     uint256 _amount,     uint256 _period,     address _receiver   ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {     if (_amount == 0) revert ZeroArgument();     // Makes sure the period is a whitelisted period     if (!stakingPeriods[_period]) revert InvalidArgument();     if (address(_receiver) == address(0)) revert ZeroArgument();     // Adds 1 to the ID of the last NFT created for the new NFT ID     _id = ++nftCounter; // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action) token.safeTransferFrom(msg.sender, address(this), _amount);  uint256 stakeShares_; uint256 totalStakeShares_ = totalStakeShares; // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares if (totalStakeShares_ != 0)   stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);   // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked else stakeShares_ = _amount;  // Assigns this NFT ID the calc'd amount of stake shares above stakeShares[_id] = stakeShares_; // Adds the newly created stake shares to the total amount of stake shares totalStakeShares += stakeShares_;  // Locks up the USDC amount and calcs the SHER token amount to receive on unstake _sher = _stake(_amount, _period, _id, _receiver);  // This is an ERC-721 function that creates an NFT and sends it to the receiver _safeMint(_receiver, _id);  } // This is how a staker unstakes and cashes out on their position   /// @notice Redeem NFT _id and receive _amount of tokens   /// @param _id TokenID of the position   /// @return _amount Amount of tokens (USDC) owed to NFT ID   /// @dev Only the owner of _id will be able to redeem their position   /// @dev The SHER rewards are sent to the NFT owner   /// @dev Can only be called after lockup _period has ended   function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // This is the ERC-721 function to destroy an NFT (with owner's approval) _burn(_id);  // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC owed to these shares _amount = _redeemShares(_id, stakeShares[_id], msg.sender);  // Sends the SHER tokens associated with this NFT ID to the NFT owner _sendSherRewardsToOwner(_id, msg.sender);  // Removes the unlock deadline associated with this NFT delete lockupEnd_[_id];  } // This is how a staker restakes an expired position   /// @notice Owner restakes position with ID: _id for _period seconds   /// @param _id ID of the position   /// @param _period Period of time, in seconds, to lockup your funds   /// @return _sher Amount of SHER tokens to be released to owner address after _period ends   /// @dev Only the owner of _id will be able to restake their position using this call   /// @dev _period needs to be whitelisted   /// @dev Can only be called after lockup _period has ended   function ownerRestake(uint256 _id, uint256 _period)     external     override     whenNotPaused     returns (uint256 _sher)   {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // Checks to make sure the staking period is a whitelisted one if (!stakingPeriods[_period]) revert InvalidArgument();  // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position _sher = _restake(_id, _period, msg.sender);  } // Calcs the reward (in stake shares) an arb would get for restaking a position   // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb   function calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {     // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)     uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME; // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position if (initialArbTime &gt; block.timestamp) return (0, false);  // The max rewards (as a % of the position's shares) for the arb are available at this timestamp uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;  // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100% uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;  // Scaled by 10**18 // Represents the max amount of stake shares that an arb could get from restaking this position uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];  // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled return (   ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,   true );  } /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position   /// @return profit How much profit an arb would make in USDC   /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)   function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {     // Returns the stake shares that an arb would get, and whether the position can currently be arbed     // profit variable is used to store the amount of shares     (profit, able) = _calcSharesForArbRestake(_id);     // Calculates the tokens (USDC) represented by that amount of stake shares     // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit     profit = _redeemSharesCalc(profit);   } /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)   /// @param _id ID of the position   /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup   /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function   /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)   /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)   /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)   function arbRestake(uint256 _id)     external     override     whenNotPaused     returns (uint256 _sher, uint256 _arbReward)   {     address nftOwner = ownerOf(_id); // Returns the stake shares that an arb would get, and whether the position can currently be arbed (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id); // Revert if not able to be arbed if (!able) revert InvalidConditions();  // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC paid to the arbitrager _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);  // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months) // Sends previously earned SHER rewards to the NFT owner address _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);  emit ArbRestaked(_id, _arbReward);  } } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-25-08 10:37:11 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@openzeppelin/contracts/token/ERC721/ERC721.sol'; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol'; import '@openzeppelin/contracts/security/Pausable.sol'; import './interfaces/ISherlock.sol'; /// @title Sherlock core interface for stakers /// @author Evert Kors // This is the contract that manages staking actions contract Sherlock is ISherlock, ERC721, Ownable, Pausable {   using SafeERC20 for IERC20; // The initial period for a staker to restake/withdraw without being auto-restaked   uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks; // The period during which the reward for restaking an account (after the inital period) grows   uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks; // Anyone who gets auto-restaked is restaked for this period (3 months)   uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks; // The percentage of someone's stake that can be paid to an arb for restaking   uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20% // USDC address   IERC20 public immutable token; // SHER token address   IERC20 public immutable sher; // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not   mapping(uint256 =&gt; bool) public override stakingPeriods; // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked   mapping(uint256 =&gt; uint256) internal lockupEnd_; // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position   mapping(uint256 =&gt; uint256) internal sherRewards_; // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)   mapping(uint256 =&gt; uint256) internal stakeShares; // Key is account, value is the sum of underlying shares of all the NFTs the account owns.   mapping(address =&gt; uint256) internal addressShares; // Total amount of shares that have been issued to all NFT positions   uint256 internal totalStakeShares; // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)   IStrategyManager public override yieldStrategy; // Instances of relevant Sherlock contracts   ISherDistributionManager public override sherDistributionManager;   ISherlockProtocolManager public override sherlockProtocolManager;   ISherlockClaimManager public override sherlockClaimManager; // Address to which nonstaker payments are made   // This will start out as a multi-sig address, then become a contract address later   address public override nonStakersAddress; // Stores the ID of the most recently created NFT   // This variable is incremented by 1 to create a new NFT ID   uint256 internal nftCounter; // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.   constructor(     IERC20 _token, // USDC address     IERC20 _sher, // SHER token address     string memory _name, // Token collection name (see ERC-721 docs)     string memory _symbol, // Token collection symbol (see ERC-721 docs)     IStrategyManager _yieldStrategy, // The active yield strategy contract     ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract     address _nonStakersAddress, // The address to which nonstakers payments go     ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract     ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract     uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for   ) ERC721(_name, _symbol) {     if (address(_token) == address(0)) revert ZeroArgument();     if (address(_sher) == address(0)) revert ZeroArgument();     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (_nonStakersAddress == address(0)) revert ZeroArgument();     if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();     if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument(); token = _token; sher = _sher; yieldStrategy = _yieldStrategy; sherDistributionManager = _sherDistributionManager; nonStakersAddress = _nonStakersAddress; sherlockProtocolManager = _sherlockProtocolManager; sherlockClaimManager = _sherlockClaimManager;  // Enabling the first set of staking periods that were provided in constructor args for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {   enableStakingPeriod(_initialstakingPeriods[i]); }  emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy); emit SherDistributionManagerUpdated(   ISherDistributionManager(address(0)),   _sherDistributionManager ); emit NonStakerAddressUpdated(address(0), _nonStakersAddress); emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager); emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);  } //   // View functions   // // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked   /// @notice View the current lockup end timestamp of _tokenID   /// @return Timestamp when NFT position unlocks   function lockupEnd(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return lockupEnd_[_tokenID];  } // Returns the SHER rewards owed to this position   /// @notice View the current SHER reward of _tokenID   /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup   function sherRewards(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return sherRewards_[_tokenID];  } // Returns the tokens (USDC) owed to a position   /// @notice View the current token balance claimable upon reaching end of the lockup   /// @return Amount of tokens assigned to owner when unstaking position   function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent();     // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers     return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;   } // Returns the tokens (USDC) owed to an address   /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup   /// @return Amount of tokens assigned to owner when unstaking all positions   function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {     if (_staker == address(0)) revert ZeroArgument();     uint256 _totalStakeShares = totalStakeShares;     if (_totalStakeShares == 0) return 0;     // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers     return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;   } // Gets the total amount of tokens (USDC) owed to stakers   // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract   /// @notice View the current TVL for all stakers   /// @return Total amount of tokens staked   /// @dev Adds principal + strategy + premiums   /// @dev Will calculate the most up to date value for each piece   function totalTokenBalanceStakers() public view override returns (uint256) {     return       token.balanceOf(address(this)) +       yieldStrategy.balanceOf() +       sherlockProtocolManager.claimablePremiums();   } //   // Gov functions   // // Allows governance to add a new staking period (4 months, etc.)   /// @notice Allows stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already enabled   function enableStakingPeriod(uint256 _period) public override onlyOwner {     if (_period == 0) revert ZeroArgument();     // Revert if staking period is already active     if (stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to true stakingPeriods[_period] = true; emit StakingPeriodEnabled(_period);  } // Allows governance to remove a staking period (4 months, etc.)   /// @notice Disallow stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already disabled   function disableStakingPeriod(uint256 _period) external override onlyOwner {     // Revert if staking period is already inactive     if (!stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to false stakingPeriods[_period] = false; emit StakingPeriodDisabled(_period);  } // Sets a new contract to be the active SHER distribution manager   /// @notice Update SHER distribution manager contract   /// @param _sherDistributionManager New adddress of the manager   function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)     external     override     onlyOwner   {     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument(); emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager); sherDistributionManager = _sherDistributionManager;  } // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)   /// @notice Remove SHER token rewards   function removeSherDistributionManager() external override onlyOwner {     if (address(sherDistributionManager) == address(0)) revert InvalidConditions(); emit SherDistributionManagerUpdated(   sherDistributionManager,   ISherDistributionManager(address(0)) ); delete sherDistributionManager;  } // Sets a new address for nonstakers payments   /// @notice Update address eligble for non staker rewards from protocol premiums   /// @param _nonStakers Address eligble for non staker rewards   function updateNonStakersAddress(address _nonStakers) external override onlyOwner {     if (address(_nonStakers) == address(0)) revert ZeroArgument();     if (nonStakersAddress == _nonStakers) revert InvalidArgument(); emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers); nonStakersAddress = _nonStakers;  } // Sets a new protocol manager contract   /// @notice Transfer protocol manager implementation address   /// @param _protocolManager new implementation address   function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)     external     override     onlyOwner   {     if (address(_protocolManager) == address(0)) revert ZeroArgument();     if (sherlockProtocolManager == _protocolManager) revert InvalidArgument(); emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager); sherlockProtocolManager = _protocolManager;  } // Sets a new claim manager contract   /// @notice Transfer claim manager role to different address   /// @param _claimManager New address of claim manager   function updateSherlockClaimManager(ISherlockClaimManager _claimManager)     external     override     onlyOwner   {     if (address(_claimManager) == address(0)) revert ZeroArgument();     if (sherlockClaimManager == _claimManager) revert InvalidArgument(); emit ClaimManagerUpdated(sherlockClaimManager, _claimManager); sherlockClaimManager = _claimManager;  } // Sets a new yield strategy manager contract   /// @notice Update yield strategy   /// @param _yieldStrategy News address of the strategy   /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure   function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (yieldStrategy == _yieldStrategy) revert InvalidArgument(); // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason. // In case this happens. We still want the yield strategy to be updated. // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again. try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {   emit YieldStrategyUpdateWithdrawAllError(reason); }  emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy); yieldStrategy = _yieldStrategy;  } // Deposits a chosen amount of tokens (USDC) into the active yield strategy   /// @notice Deposit _amount into active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); // Transfers any tokens owed to stakers from the protocol manager contract to this contract first sherlockProtocolManager.claimPremiumsForStakers(); // Transfers the amount of tokens to the yield strategy contract token.safeTransfer(address(yieldStrategy), _amount); // Deposits all tokens in the yield strategy contract into the actual yield strategy yieldStrategy.deposit();  } // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract   /// @notice Withdraw _amount from active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); yieldStrategy.withdraw(_amount);  } // Withdraws all tokens from the yield strategy back into this contract   /// @notice Withdraw all funds from active strategy   /// @dev gov only   function yieldStrategyWithdrawAll() external override onlyOwner {     yieldStrategy.withdrawAll();   } /// @notice Pause external functions in all contracts   /// @dev A manager can be replaced with the new contract in a paused state   /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused   function pause() external onlyOwner {     _pause();     if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();     // sherDistributionManager can be 0, pause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       !Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.pause();     }     if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();     if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();   } /// @notice Unpause external functions in all contracts   /// @dev A manager can be replaced with the new contract in an unpaused state   /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused   function unpause() external onlyOwner {     _unpause();     if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();     // sherDistributionManager can be 0, unpause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.unpause();     }     if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();     if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();   } //   // Access control functions   // /// @notice Account sum of all underlying posiiton shares for _from and _to   /// @dev this enables the tokenBalanceOfAddress to exist   function _beforeTokenTransfer(     address _from,     address _to,     uint256 _tokenID   ) internal override {     uint256 _stakeShares = stakeShares[_tokenID]; if (_from != address(0)) addressShares[_from] -= _stakeShares; if (_to != address(0)) addressShares[_to] += _stakeShares;  } // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)   // This function is called by the Sherlock claim manager contract if a claim is approved   /// @notice Initiate a payout of _amount to _receiver   /// @param _receiver Receiver of payout   /// @param _amount Amount to send   /// @dev only payout manager should call this   /// @dev should pull money out of strategy   function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {     // Can only be called by the Sherlock claim manager contract     if (msg.sender != address(sherlockClaimManager)) revert Unauthorized(); if (_amount != 0) {   // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)   _transferTokensOut(_receiver, _amount); } emit ClaimPayout(_receiver, _amount);  } //   // Non-access control functions   // // Helper function for initial staking and restaking   // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position   /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds   /// @param amount Amount of tokens to stake   /// @param _period Period of time for which funds get locked   /// @param _id ID for this NFT position   /// @param _receiver Address that will be linked to this position   /// @return _sher Amount of SHER tokens awarded to this position after _period ends   /// @dev _period needs to be whitelisted   function _stake(     uint256 _amount,     uint256 _period,     uint256 _id,     address _receiver   ) internal returns (uint256 _sher) {     // Sets the timestamp at which this position can first be unstaked/restaked     lockupEnd[_id] = block.timestamp + _period; if (address(sherDistributionManager) == address(0)) return 0; // Does not allow restaking of 0 tokens if (_amount == 0) return 0;  // Checks this amount of SHER tokens in this contract before we transfer new ones uint256 before = sher.balanceOf(address(this));  // pullReward() calcs then actually transfers the SHER tokens to this contract // in case this call fails, whole (re)staking transaction fails _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);  // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position uint256 actualAmount = sher.balanceOf(address(this)) - before; if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount); // Assigns the newly created SHER tokens to the current stake position if (_sher != 0) sherRewards_[_id] = _sher;  } // Checks to see if the NFT owner is the caller and that the position is unlockable   function verifyUnlockableByOwner(uint256 _id) internal view {     if (ownerOf(_id) != msg.sender) revert Unauthorized();     if (lockupEnd[_id] &gt; block.timestamp) revert InvalidConditions();   } // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner   function sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards[_id];     if (sherReward == 0) return; // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner sher.safeTransfer(_nftOwner, sherReward); // Deletes the SHER reward mapping for this NFT ID delete sherRewards_[_id];  } // Transfers an amount of tokens to the receiver address   // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)   function _transferTokensOut(address _receiver, uint256 _amount) internal {     // Transfers any premiums owed to stakers from the protocol manager to this contract     sherlockProtocolManager.claimPremiumsForStakers(); // The amount of tokens in this contract uint256 mainBalance = token.balanceOf(address(this));  // If the amount to transfer out is still greater than the amount of tokens in this contract, // Withdraw yield strategy tokens to make up the difference if (_amount &gt; mainBalance) {   yieldStrategy.withdraw(_amount - mainBalance); }  token.safeTransfer(_receiver, _amount);  } // Returns the amount of USDC owed to this amount of stakeShares   function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {     // Finds fraction that the given amount of stakeShares represents of the total     // Then multiplies it by the total amount of tokens (USDC) owed to all stakers     return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;   } // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted   // Also burns the requisite amount of shares associated with this NFT position   // Returns the amount of USDC owed to these shares   function _redeemShares(     uint256 _id,     uint256 _stakeShares,     address _receiver   ) internal returns (uint256 _amount) {     // Returns the amount of USDC owed to this amount of stakeShares     _amount = _redeemSharesCalc(_stakeShares);     // Transfers _amount of tokens to _receiver address     if (_amount != 0) _transferTokensOut(_receiver, _amount); // Subtracts this amount of stakeShares from the NFT position stakeShares[_id] -= _stakeShares; // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding totalStakeShares -= _stakeShares;  } // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager   // Restakes an NFT position (_id) for a given period (_period) and   // Sends any previously earned SHER rewards to the _nftOwner address   function _restake(     uint256 _id,     uint256 _period,     address _nftOwner   ) internal returns (uint256 _sher) {     // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner     // NOTE This function deletes the SHER reward mapping for this NFT ID     _sendSherRewardsToOwner(_id, _nftOwner); // tokenBalanceOf() returns the USDC amount owed to this NFT ID // _stake() restakes that amount of USDC for the period inputted // We use the same ID that we just deleted the SHER rewards mapping for // Resets the lockupEnd mapping and SHER token rewards mapping for this ID // Note stakeShares for this position do not change so no need to update _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);  emit Restaked(_id);  } // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)   /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt   /// @param _amount Amount of tokens to stake   /// @param _period Period of time, in seconds, to lockup your funds   /// @param _receiver Address that will receive the NFT representing the position   /// @return _id ID of the position   /// @return _sher Amount of SHER tokens to be released to this ID after _period ends   /// @dev _period needs to be whitelisted   function initialStake(     uint256 _amount,     uint256 _period,     address _receiver   ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {     if (_amount == 0) revert ZeroArgument();     // Makes sure the period is a whitelisted period     if (!stakingPeriods[_period]) revert InvalidArgument();     if (address(_receiver) == address(0)) revert ZeroArgument();     // Adds 1 to the ID of the last NFT created for the new NFT ID     _id = ++nftCounter; // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action) token.safeTransferFrom(msg.sender, address(this), _amount);  uint256 stakeShares_; uint256 totalStakeShares_ = totalStakeShares; // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares if (totalStakeShares_ != 0)   stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);   // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked else stakeShares_ = _amount;  // Assigns this NFT ID the calc'd amount of stake shares above stakeShares[_id] = stakeShares_; // Adds the newly created stake shares to the total amount of stake shares totalStakeShares += stakeShares_;  // Locks up the USDC amount and calcs the SHER token amount to receive on unstake _sher = _stake(_amount, _period, _id, _receiver);  // This is an ERC-721 function that creates an NFT and sends it to the receiver _safeMint(_receiver, _id);  } // This is how a staker unstakes and cashes out on their position   /// @notice Redeem NFT _id and receive _amount of tokens   /// @param _id TokenID of the position   /// @return _amount Amount of tokens (USDC) owed to NFT ID   /// @dev Only the owner of _id will be able to redeem their position   /// @dev The SHER rewards are sent to the NFT owner   /// @dev Can only be called after lockup _period has ended   function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // This is the ERC-721 function to destroy an NFT (with owner's approval) _burn(_id);  // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC owed to these shares _amount = _redeemShares(_id, stakeShares[_id], msg.sender);  // Sends the SHER tokens associated with this NFT ID to the NFT owner _sendSherRewardsToOwner(_id, msg.sender);  // Removes the unlock deadline associated with this NFT delete lockupEnd_[_id];  } // This is how a staker restakes an expired position   /// @notice Owner restakes position with ID: _id for _period seconds   /// @param _id ID of the position   /// @param _period Period of time, in seconds, to lockup your funds   /// @return _sher Amount of SHER tokens to be released to owner address after _period ends   /// @dev Only the owner of _id will be able to restake their position using this call   /// @dev _period needs to be whitelisted   /// @dev Can only be called after lockup _period has ended   function ownerRestake(uint256 _id, uint256 _period)     external     override     whenNotPaused     returns (uint256 _sher)   {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // Checks to make sure the staking period is a whitelisted one if (!stakingPeriods[_period]) revert InvalidArgument();  // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position _sher = _restake(_id, _period, msg.sender);  } // Calcs the reward (in stake shares) an arb would get for restaking a position   // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb   function calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {     // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)     uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME; // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position if (initialArbTime &gt; block.timestamp) return (0, false);  // The max rewards (as a % of the position's shares) for the arb are available at this timestamp uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;  // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100% uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;  // Scaled by 10**18 // Represents the max amount of stake shares that an arb could get from restaking this position uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];  // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled return (   ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,   true );  } /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position   /// @return profit How much profit an arb would make in USDC   /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)   function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {     // Returns the stake shares that an arb would get, and whether the position can currently be arbed     // profit variable is used to store the amount of shares     (profit, able) = _calcSharesForArbRestake(_id);     // Calculates the tokens (USDC) represented by that amount of stake shares     // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit     profit = _redeemSharesCalc(profit);   } /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)   /// @param _id ID of the position   /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup   /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function   /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)   /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)   /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)   function arbRestake(uint256 _id)     external     override     whenNotPaused     returns (uint256 _sher, uint256 _arbReward)   {     address nftOwner = ownerOf(_id); // Returns the stake shares that an arb would get, and whether the position can currently be arbed (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id); // Revert if not able to be arbed if (!able) revert InvalidConditions();  // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC paid to the arbitrager _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);  // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months) // Sends previously earned SHER rewards to the NFT owner address _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);  emit ArbRestaked(_id, _arbReward);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-25-08 10:37:11 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';

import './interfaces/ISherlock.sol';

/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions

contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;

  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;

  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;

  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;

  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%

  // USDC address
  IERC20 public immutable token;

  // SHER token address
  IERC20 public immutable sher;

  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;

  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;

  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;

  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;

  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;

  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;

  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;

  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;

  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;

  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;

  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();

    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;

    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }

    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }

  //
  // View functions
  //

  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return lockupEnd_[_tokenID];
  }

  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return sherRewards_[_tokenID];
  }

  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }

  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }

  //
  // Gov functions
  //

  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }

  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }

  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();

    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }

  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();

    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }

  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();

    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }

  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();

    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }

  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();

    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }

  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();

    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }

    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }

  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }

  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    yieldStrategy.withdraw(_amount);
  }

  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }

  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }

  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }

  //
  // Access control functions
  //

  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];

    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }

  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();

    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }

  //
  // Non-access control functions
  //

  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;

    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;

    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));

    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);

    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }

  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }

  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;

    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }

  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();

    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));

    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }

    token.safeTransfer(_receiver, _amount);
  }

  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);

    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }

  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);

    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);

    emit Restaked(_id);
  }

  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;

    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);

    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;

    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;

    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);

    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }

  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);

    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);

    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);

    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }

  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }

  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;

    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);

    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;

    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;

    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];

    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }

  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }

  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);

    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();

    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);

    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);

    emit ArbRestaked(_id, _arbReward);
  }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-25-08 10:37:21 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-25-08 10:37:21 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 7841
completion_tokens: 774
total_tokens: 8615
cost: $-1.000000


[2024-25-08 10:37:21 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';

import './interfaces/ISherlock.sol';

/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions

contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;

  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;

  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;

  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;

  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%

  // USDC address
  IERC20 public immutable token;

  // SHER token address
  IERC20 public immutable sher;

  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;

  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;

  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;

  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;

  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;

  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;

  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;

  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;

  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;

  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;

  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();

    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;

    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }

    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }

  //
  // View functions
  //

  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return lockupEnd_[_tokenID];
  }

  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return sherRewards_[_tokenID];
  }

  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }

  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }

  //
  // Gov functions
  //

  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }

  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }

  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();

    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }

  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();

    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }

  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();

    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }

  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();

    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }

  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();

    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }

  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();

    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }

    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }

  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }

  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    yieldStrategy.withdraw(_amount);
  }

  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }

  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }

  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }

  //
  // Access control functions
  //

  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];

    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }

  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();

    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }

  //
  // Non-access control functions
  //

  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;

    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;

    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));

    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);

    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }

  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }

  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;

    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }

  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();

    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));

    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }

    token.safeTransfer(_receiver, _amount);
  }

  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);

    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }

  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);

    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);

    emit Restaked(_id);
  }

  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;

    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);

    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;

    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;

    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);

    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }

  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);

    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);

    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);

    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }

  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }

  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;

    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);

    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;

    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;

    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];

    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }

  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }

  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);

    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();

    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);

    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);

    emit ArbRestaked(_id, _arbReward);
  }
}
.]

Based on the provided Solidity smart contract code for the Sherlock protocol, here is a succinct summary of potential security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract does not implement a reentrancy guard, which could allow malicious actors to exploit functions that transfer tokens or manage state changes, particularly in functions like `payoutClaim`, `_transferTokensOut`, and `_redeemShares`.

2. **Access Control Issues**:
   - Functions such as `payoutClaim` are only restricted to the `sherlockClaimManager`, but if this address is compromised, it could lead to unauthorized access to funds.
   - The contract relies heavily on the `onlyOwner` modifier for critical functions, which could be a single point of failure if the owners private key is compromised.

3. **Gas Limit and Block Size Issues**:
   - The `enableStakingPeriod` and `disableStakingPeriod` functions could potentially lead to a situation where the owner runs out of gas if a large number of staking periods are added or removed in a single transaction.

4. **Integer Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow and underflow checks, any arithmetic operations that are not carefully managed could still lead to unexpected behavior, especially when dealing with shares and balances.

5. **Improper Error Handling**:
   - The contract uses `revert` statements without providing detailed error messages in some cases, which could make debugging difficult. For example, the `ZeroArgument` and `InvalidArgument` errors do not specify which argument is causing the issue.

6. **Token Transfer Failures**:
   - The contract does not handle scenarios where token transfers fail. For instance, in `_transferTokensOut`, if the transfer fails, it could lead to inconsistent states where funds are deducted but not transferred.

7. **Lack of Event Emissions**:
   - Certain state-changing functions do not emit events, which is crucial for tracking changes on-chain and for front-end applications to react to state changes.

8. **Potential for Front-Running**:
   - Functions that involve staking and rewards could be susceptible to front-running attacks, where an attacker could observe a transaction and submit their own transaction with higher gas fees to gain an advantage.

### Comprehensive Analysis Report:

The Sherlock smart contract is designed to manage staking actions and rewards distribution through an ERC721 NFT mechanism. While the contract incorporates several best practices, including the use of OpenZeppelin libraries for security, there are notable vulnerabilities that could be exploited if not addressed.

The absence of a reentrancy guard poses a significant risk, particularly in functions that handle token transfers and state changes. Access control mechanisms should be strengthened to prevent unauthorized access, especially in critical functions that manage funds. Additionally, the reliance on the `onlyOwner` modifier could lead to centralization risks.

Gas limit issues could arise from functions that modify multiple staking periods, potentially leading to failed transactions. Although Solidity 0.8.x mitigates overflow and underflow risks, careful management of arithmetic operations is still necessary.

Error handling could be improved by providing more informative revert messages, aiding in debugging and user experience. The contract should also ensure that token transfers are handled safely, with appropriate checks for transfer success.

To enhance transparency and traceability, it is recommended that all state-changing functions emit relevant events. Lastly, measures should be taken to mitigate front-running risks, possibly by implementing time locks or other mechanisms to ensure fair access to staking and reward functions.

In conclusion, while the Sherlock contract demonstrates a solid foundation for managing staking and rewards, addressing the identified vulnerabilities is crucial to ensure the security and integrity of the protocol. A thorough audit and testing phase should be conducted before deployment to mitigate these risks effectively.

[2024-25-08 10:37:21 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code for the Sherlock protocol, here is a succinct summary of potential security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract does not implement a reentrancy guard, which could allow malicious actors to exploit functions that transfer tokens or manage state changes, particularly in functions like `payoutClaim`, `_transferTokensOut`, and `_redeemShares`.

2. **Access Control Issues**:
   - Functions such as `payoutClaim` are only restricted to the `sherlockClaimManager`, but if this address is compromised, it could lead to unauthorized access to funds.
   - The contract relies heavily on the `onlyOwner` modifier for critical functions, which could be a single point of failure if the owners private key is compromised.

3. **Gas Limit and Block Size Issues**:
   - The `enableStakingPeriod` and `disableStakingPeriod` functions could potentially lead to a situation where the owner runs out of gas if a large number of staking periods are added or removed in a single transaction.

4. **Integer Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow and underflow checks, any arithmetic operations that are not carefully managed could still lead to unexpected behavior, especially when dealing with shares and balances.

5. **Improper Error Handling**:
   - The contract uses `revert` statements without providing detailed error messages in some cases, which could make debugging difficult. For example, the `ZeroArgument` and `InvalidArgument` errors do not specify which argument is causing the issue.

6. **Token Transfer Failures**:
   - The contract does not handle scenarios where token transfers fail. For instance, in `_transferTokensOut`, if the transfer fails, it could lead to inconsistent states where funds are deducted but not transferred.

7. **Lack of Event Emissions**:
   - Certain state-changing functions do not emit events, which is crucial for tracking changes on-chain and for front-end applications to react to state changes.

8. **Potential for Front-Running**:
   - Functions that involve staking and rewards could be susceptible to front-running attacks, where an attacker could observe a transaction and submit their own transaction with higher gas fees to gain an advantage.

### Comprehensive Analysis Report:

The Sherlock smart contract is designed to manage staking actions and rewards distribution through an ERC721 NFT mechanism. While the contract incorporates several best practices, including the use of OpenZeppelin libraries for security, there are notable vulnerabilities that could be exploited if not addressed.

The absence of a reentrancy guard poses a significant risk, particularly in functions that handle token transfers and state changes. Access control mechanisms should be strengthened to prevent unauthorized access, especially in critical functions that manage funds. Additionally, the reliance on the `onlyOwner` modifier could lead to centralization risks.

Gas limit issues could arise from functions that modify multiple staking periods, potentially leading to failed transactions. Although Solidity 0.8.x mitigates overflow and underflow risks, careful management of arithmetic operations is still necessary.

Error handling could be improved by providing more informative revert messages, aiding in debugging and user experience. The contract should also ensure that token transfers are handled safely, with appropriate checks for transfer success.

To enhance transparency and traceability, it is recommended that all state-changing functions emit relevant events. Lastly, measures should be taken to mitigate front-running risks, possibly by implementing time locks or other mechanisms to ensure fair access to staking and reward functions.

In conclusion, while the Sherlock contract demonstrates a solid foundation for managing staking and rewards, addressing the identified vulnerabilities is crucial to ensure the security and integrity of the protocol. A thorough audit and testing phase should be conducted before deployment to mitigate these risks effectively.

[2024-25-08 10:37:21 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-25-08 10:37:21 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@openzeppelin/contracts/token/ERC721/ERC721.sol'; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol'; import '@openzeppelin/contracts/security/Pausable.sol'; import './interfaces/ISherlock.sol'; /// @title Sherlock core interface for stakers /// @author Evert Kors // This is the contract that manages staking actions contract Sherlock is ISherlock, ERC721, Ownable, Pausable {   using SafeERC20 for IERC20; // The initial period for a staker to restake/withdraw without being auto-restaked   uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks; // The period during which the reward for restaking an account (after the inital period) grows   uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks; // Anyone who gets auto-restaked is restaked for this period (3 months)   uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks; // The percentage of someone's stake that can be paid to an arb for restaking   uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20% // USDC address   IERC20 public immutable token; // SHER token address   IERC20 public immutable sher; // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not   mapping(uint256 =&gt; bool) public override stakingPeriods; // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked   mapping(uint256 =&gt; uint256) internal lockupEnd_; // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position   mapping(uint256 =&gt; uint256) internal sherRewards_; // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)   mapping(uint256 =&gt; uint256) internal stakeShares; // Key is account, value is the sum of underlying shares of all the NFTs the account owns.   mapping(address =&gt; uint256) internal addressShares; // Total amount of shares that have been issued to all NFT positions   uint256 internal totalStakeShares; // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)   IStrategyManager public override yieldStrategy; // Instances of relevant Sherlock contracts   ISherDistributionManager public override sherDistributionManager;   ISherlockProtocolManager public override sherlockProtocolManager;   ISherlockClaimManager public override sherlockClaimManager; // Address to which nonstaker payments are made   // This will start out as a multi-sig address, then become a contract address later   address public override nonStakersAddress; // Stores the ID of the most recently created NFT   // This variable is incremented by 1 to create a new NFT ID   uint256 internal nftCounter; // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.   constructor(     IERC20 _token, // USDC address     IERC20 _sher, // SHER token address     string memory _name, // Token collection name (see ERC-721 docs)     string memory _symbol, // Token collection symbol (see ERC-721 docs)     IStrategyManager _yieldStrategy, // The active yield strategy contract     ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract     address _nonStakersAddress, // The address to which nonstakers payments go     ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract     ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract     uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for   ) ERC721(_name, _symbol) {     if (address(_token) == address(0)) revert ZeroArgument();     if (address(_sher) == address(0)) revert ZeroArgument();     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (_nonStakersAddress == address(0)) revert ZeroArgument();     if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();     if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument(); token = _token; sher = _sher; yieldStrategy = _yieldStrategy; sherDistributionManager = _sherDistributionManager; nonStakersAddress = _nonStakersAddress; sherlockProtocolManager = _sherlockProtocolManager; sherlockClaimManager = _sherlockClaimManager;  // Enabling the first set of staking periods that were provided in constructor args for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {   enableStakingPeriod(_initialstakingPeriods[i]); }  emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy); emit SherDistributionManagerUpdated(   ISherDistributionManager(address(0)),   _sherDistributionManager ); emit NonStakerAddressUpdated(address(0), _nonStakersAddress); emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager); emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);  } //   // View functions   // // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked   /// @notice View the current lockup end timestamp of _tokenID   /// @return Timestamp when NFT position unlocks   function lockupEnd(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return lockupEnd_[_tokenID];  } // Returns the SHER rewards owed to this position   /// @notice View the current SHER reward of _tokenID   /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup   function sherRewards(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return sherRewards_[_tokenID];  } // Returns the tokens (USDC) owed to a position   /// @notice View the current token balance claimable upon reaching end of the lockup   /// @return Amount of tokens assigned to owner when unstaking position   function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent();     // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers     return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;   } // Returns the tokens (USDC) owed to an address   /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup   /// @return Amount of tokens assigned to owner when unstaking all positions   function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {     if (_staker == address(0)) revert ZeroArgument();     uint256 _totalStakeShares = totalStakeShares;     if (_totalStakeShares == 0) return 0;     // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers     return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;   } // Gets the total amount of tokens (USDC) owed to stakers   // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract   /// @notice View the current TVL for all stakers   /// @return Total amount of tokens staked   /// @dev Adds principal + strategy + premiums   /// @dev Will calculate the most up to date value for each piece   function totalTokenBalanceStakers() public view override returns (uint256) {     return       token.balanceOf(address(this)) +       yieldStrategy.balanceOf() +       sherlockProtocolManager.claimablePremiums();   } //   // Gov functions   // // Allows governance to add a new staking period (4 months, etc.)   /// @notice Allows stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already enabled   function enableStakingPeriod(uint256 _period) public override onlyOwner {     if (_period == 0) revert ZeroArgument();     // Revert if staking period is already active     if (stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to true stakingPeriods[_period] = true; emit StakingPeriodEnabled(_period);  } // Allows governance to remove a staking period (4 months, etc.)   /// @notice Disallow stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already disabled   function disableStakingPeriod(uint256 _period) external override onlyOwner {     // Revert if staking period is already inactive     if (!stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to false stakingPeriods[_period] = false; emit StakingPeriodDisabled(_period);  } // Sets a new contract to be the active SHER distribution manager   /// @notice Update SHER distribution manager contract   /// @param _sherDistributionManager New adddress of the manager   function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)     external     override     onlyOwner   {     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument(); emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager); sherDistributionManager = _sherDistributionManager;  } // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)   /// @notice Remove SHER token rewards   function removeSherDistributionManager() external override onlyOwner {     if (address(sherDistributionManager) == address(0)) revert InvalidConditions(); emit SherDistributionManagerUpdated(   sherDistributionManager,   ISherDistributionManager(address(0)) ); delete sherDistributionManager;  } // Sets a new address for nonstakers payments   /// @notice Update address eligble for non staker rewards from protocol premiums   /// @param _nonStakers Address eligble for non staker rewards   function updateNonStakersAddress(address _nonStakers) external override onlyOwner {     if (address(_nonStakers) == address(0)) revert ZeroArgument();     if (nonStakersAddress == _nonStakers) revert InvalidArgument(); emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers); nonStakersAddress = _nonStakers;  } // Sets a new protocol manager contract   /// @notice Transfer protocol manager implementation address   /// @param _protocolManager new implementation address   function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)     external     override     onlyOwner   {     if (address(_protocolManager) == address(0)) revert ZeroArgument();     if (sherlockProtocolManager == _protocolManager) revert InvalidArgument(); emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager); sherlockProtocolManager = _protocolManager;  } // Sets a new claim manager contract   /// @notice Transfer claim manager role to different address   /// @param _claimManager New address of claim manager   function updateSherlockClaimManager(ISherlockClaimManager _claimManager)     external     override     onlyOwner   {     if (address(_claimManager) == address(0)) revert ZeroArgument();     if (sherlockClaimManager == _claimManager) revert InvalidArgument(); emit ClaimManagerUpdated(sherlockClaimManager, _claimManager); sherlockClaimManager = _claimManager;  } // Sets a new yield strategy manager contract   /// @notice Update yield strategy   /// @param _yieldStrategy News address of the strategy   /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure   function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (yieldStrategy == _yieldStrategy) revert InvalidArgument(); // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason. // In case this happens. We still want the yield strategy to be updated. // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again. try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {   emit YieldStrategyUpdateWithdrawAllError(reason); }  emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy); yieldStrategy = _yieldStrategy;  } // Deposits a chosen amount of tokens (USDC) into the active yield strategy   /// @notice Deposit _amount into active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); // Transfers any tokens owed to stakers from the protocol manager contract to this contract first sherlockProtocolManager.claimPremiumsForStakers(); // Transfers the amount of tokens to the yield strategy contract token.safeTransfer(address(yieldStrategy), _amount); // Deposits all tokens in the yield strategy contract into the actual yield strategy yieldStrategy.deposit();  } // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract   /// @notice Withdraw _amount from active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); yieldStrategy.withdraw(_amount);  } // Withdraws all tokens from the yield strategy back into this contract   /// @notice Withdraw all funds from active strategy   /// @dev gov only   function yieldStrategyWithdrawAll() external override onlyOwner {     yieldStrategy.withdrawAll();   } /// @notice Pause external functions in all contracts   /// @dev A manager can be replaced with the new contract in a paused state   /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused   function pause() external onlyOwner {     _pause();     if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();     // sherDistributionManager can be 0, pause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       !Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.pause();     }     if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();     if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();   } /// @notice Unpause external functions in all contracts   /// @dev A manager can be replaced with the new contract in an unpaused state   /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused   function unpause() external onlyOwner {     _unpause();     if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();     // sherDistributionManager can be 0, unpause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.unpause();     }     if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();     if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();   } //   // Access control functions   // /// @notice Account sum of all underlying posiiton shares for _from and _to   /// @dev this enables the tokenBalanceOfAddress to exist   function _beforeTokenTransfer(     address _from,     address _to,     uint256 _tokenID   ) internal override {     uint256 _stakeShares = stakeShares[_tokenID]; if (_from != address(0)) addressShares[_from] -= _stakeShares; if (_to != address(0)) addressShares[_to] += _stakeShares;  } // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)   // This function is called by the Sherlock claim manager contract if a claim is approved   /// @notice Initiate a payout of _amount to _receiver   /// @param _receiver Receiver of payout   /// @param _amount Amount to send   /// @dev only payout manager should call this   /// @dev should pull money out of strategy   function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {     // Can only be called by the Sherlock claim manager contract     if (msg.sender != address(sherlockClaimManager)) revert Unauthorized(); if (_amount != 0) {   // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)   _transferTokensOut(_receiver, _amount); } emit ClaimPayout(_receiver, _amount);  } //   // Non-access control functions   // // Helper function for initial staking and restaking   // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position   /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds   /// @param amount Amount of tokens to stake   /// @param _period Period of time for which funds get locked   /// @param _id ID for this NFT position   /// @param _receiver Address that will be linked to this position   /// @return _sher Amount of SHER tokens awarded to this position after _period ends   /// @dev _period needs to be whitelisted   function _stake(     uint256 _amount,     uint256 _period,     uint256 _id,     address _receiver   ) internal returns (uint256 _sher) {     // Sets the timestamp at which this position can first be unstaked/restaked     lockupEnd[_id] = block.timestamp + _period; if (address(sherDistributionManager) == address(0)) return 0; // Does not allow restaking of 0 tokens if (_amount == 0) return 0;  // Checks this amount of SHER tokens in this contract before we transfer new ones uint256 before = sher.balanceOf(address(this));  // pullReward() calcs then actually transfers the SHER tokens to this contract // in case this call fails, whole (re)staking transaction fails _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);  // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position uint256 actualAmount = sher.balanceOf(address(this)) - before; if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount); // Assigns the newly created SHER tokens to the current stake position if (_sher != 0) sherRewards_[_id] = _sher;  } // Checks to see if the NFT owner is the caller and that the position is unlockable   function verifyUnlockableByOwner(uint256 _id) internal view {     if (ownerOf(_id) != msg.sender) revert Unauthorized();     if (lockupEnd[_id] &gt; block.timestamp) revert InvalidConditions();   } // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner   function sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards[_id];     if (sherReward == 0) return; // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner sher.safeTransfer(_nftOwner, sherReward); // Deletes the SHER reward mapping for this NFT ID delete sherRewards_[_id];  } // Transfers an amount of tokens to the receiver address   // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)   function _transferTokensOut(address _receiver, uint256 _amount) internal {     // Transfers any premiums owed to stakers from the protocol manager to this contract     sherlockProtocolManager.claimPremiumsForStakers(); // The amount of tokens in this contract uint256 mainBalance = token.balanceOf(address(this));  // If the amount to transfer out is still greater than the amount of tokens in this contract, // Withdraw yield strategy tokens to make up the difference if (_amount &gt; mainBalance) {   yieldStrategy.withdraw(_amount - mainBalance); }  token.safeTransfer(_receiver, _amount);  } // Returns the amount of USDC owed to this amount of stakeShares   function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {     // Finds fraction that the given amount of stakeShares represents of the total     // Then multiplies it by the total amount of tokens (USDC) owed to all stakers     return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;   } // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted   // Also burns the requisite amount of shares associated with this NFT position   // Returns the amount of USDC owed to these shares   function _redeemShares(     uint256 _id,     uint256 _stakeShares,     address _receiver   ) internal returns (uint256 _amount) {     // Returns the amount of USDC owed to this amount of stakeShares     _amount = _redeemSharesCalc(_stakeShares);     // Transfers _amount of tokens to _receiver address     if (_amount != 0) _transferTokensOut(_receiver, _amount); // Subtracts this amount of stakeShares from the NFT position stakeShares[_id] -= _stakeShares; // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding totalStakeShares -= _stakeShares;  } // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager   // Restakes an NFT position (_id) for a given period (_period) and   // Sends any previously earned SHER rewards to the _nftOwner address   function _restake(     uint256 _id,     uint256 _period,     address _nftOwner   ) internal returns (uint256 _sher) {     // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner     // NOTE This function deletes the SHER reward mapping for this NFT ID     _sendSherRewardsToOwner(_id, _nftOwner); // tokenBalanceOf() returns the USDC amount owed to this NFT ID // _stake() restakes that amount of USDC for the period inputted // We use the same ID that we just deleted the SHER rewards mapping for // Resets the lockupEnd mapping and SHER token rewards mapping for this ID // Note stakeShares for this position do not change so no need to update _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);  emit Restaked(_id);  } // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)   /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt   /// @param _amount Amount of tokens to stake   /// @param _period Period of time, in seconds, to lockup your funds   /// @param _receiver Address that will receive the NFT representing the position   /// @return _id ID of the position   /// @return _sher Amount of SHER tokens to be released to this ID after _period ends   /// @dev _period needs to be whitelisted   function initialStake(     uint256 _amount,     uint256 _period,     address _receiver   ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {     if (_amount == 0) revert ZeroArgument();     // Makes sure the period is a whitelisted period     if (!stakingPeriods[_period]) revert InvalidArgument();     if (address(_receiver) == address(0)) revert ZeroArgument();     // Adds 1 to the ID of the last NFT created for the new NFT ID     _id = ++nftCounter; // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action) token.safeTransferFrom(msg.sender, address(this), _amount);  uint256 stakeShares_; uint256 totalStakeShares_ = totalStakeShares; // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares if (totalStakeShares_ != 0)   stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);   // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked else stakeShares_ = _amount;  // Assigns this NFT ID the calc'd amount of stake shares above stakeShares[_id] = stakeShares_; // Adds the newly created stake shares to the total amount of stake shares totalStakeShares += stakeShares_;  // Locks up the USDC amount and calcs the SHER token amount to receive on unstake _sher = _stake(_amount, _period, _id, _receiver);  // This is an ERC-721 function that creates an NFT and sends it to the receiver _safeMint(_receiver, _id);  } // This is how a staker unstakes and cashes out on their position   /// @notice Redeem NFT _id and receive _amount of tokens   /// @param _id TokenID of the position   /// @return _amount Amount of tokens (USDC) owed to NFT ID   /// @dev Only the owner of _id will be able to redeem their position   /// @dev The SHER rewards are sent to the NFT owner   /// @dev Can only be called after lockup _period has ended   function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // This is the ERC-721 function to destroy an NFT (with owner's approval) _burn(_id);  // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC owed to these shares _amount = _redeemShares(_id, stakeShares[_id], msg.sender);  // Sends the SHER tokens associated with this NFT ID to the NFT owner _sendSherRewardsToOwner(_id, msg.sender);  // Removes the unlock deadline associated with this NFT delete lockupEnd_[_id];  } // This is how a staker restakes an expired position   /// @notice Owner restakes position with ID: _id for _period seconds   /// @param _id ID of the position   /// @param _period Period of time, in seconds, to lockup your funds   /// @return _sher Amount of SHER tokens to be released to owner address after _period ends   /// @dev Only the owner of _id will be able to restake their position using this call   /// @dev _period needs to be whitelisted   /// @dev Can only be called after lockup _period has ended   function ownerRestake(uint256 _id, uint256 _period)     external     override     whenNotPaused     returns (uint256 _sher)   {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // Checks to make sure the staking period is a whitelisted one if (!stakingPeriods[_period]) revert InvalidArgument();  // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position _sher = _restake(_id, _period, msg.sender);  } // Calcs the reward (in stake shares) an arb would get for restaking a position   // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb   function calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {     // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)     uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME; // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position if (initialArbTime &gt; block.timestamp) return (0, false);  // The max rewards (as a % of the position's shares) for the arb are available at this timestamp uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;  // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100% uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;  // Scaled by 10**18 // Represents the max amount of stake shares that an arb could get from restaking this position uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];  // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled return (   ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,   true );  } /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position   /// @return profit How much profit an arb would make in USDC   /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)   function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {     // Returns the stake shares that an arb would get, and whether the position can currently be arbed     // profit variable is used to store the amount of shares     (profit, able) = _calcSharesForArbRestake(_id);     // Calculates the tokens (USDC) represented by that amount of stake shares     // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit     profit = _redeemSharesCalc(profit);   } /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)   /// @param _id ID of the position   /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup   /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function   /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)   /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)   /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)   function arbRestake(uint256 _id)     external     override     whenNotPaused     returns (uint256 _sher, uint256 _arbReward)   {     address nftOwner = ownerOf(_id); // Returns the stake shares that an arb would get, and whether the position can currently be arbed (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id); // Revert if not able to be arbed if (!able) revert InvalidConditions();  // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC paid to the arbitrager _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);  // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months) // Sends previously earned SHER rewards to the NFT owner address _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);  emit ArbRestaked(_id, _arbReward);  } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/***********\\n Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x)\n Sherlock Protocol: https://sherlock.xyz\n/***********/\n\nimport \'@openzeppelin/contracts/token/ERC20/IERC20.sol\';\nimport \'@openzeppelin/contracts/token/ERC721/ERC721.sol\';\nimport \'@openzeppelin/contracts/access/Ownable.sol\';\nimport \'@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\';\nimport \'@openzeppelin/contracts/security/Pausable.sol\';\n\nimport \'./interfaces/ISherlock.sol\';\n\n/// @title Sherlock core interface for stakers\n/// @author Evert Kors\n// This is the contract that manages staking actions\n\ncontract Sherlock is ISherlock, ERC721, Ownable, Pausable {\n  using SafeERC20 for IERC20;\n\n  // The initial period for a staker to restake/withdraw without being auto-restaked\n  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;\n\n  // The period during which the reward for restaking an account (after the inital period) grows\n  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;\n\n  // Anyone who gets auto-restaked is restaked for this period (3 months)\n  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;\n\n  // The percentage of someone\'s stake that can be paid to an arb for restaking\n  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (1018 / 100) * 20; // 20%\n\n  // USDC address\n  IERC20 public immutable token;\n\n  // SHER token address\n  IERC20 public immutable sher;\n\n  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not\n  mapping(uint256 =&gt; bool) public override stakingPeriods;\n\n  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked\n  mapping(uint256 =&gt; uint256) internal lockupEnd_;\n\n  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position\n  mapping(uint256 =&gt; uint256) internal sherRewards_;\n\n  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)\n  mapping(uint256 =&gt; uint256) internal stakeShares;\n\n  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.\n  mapping(address =&gt; uint256) internal addressShares;\n\n  // Total amount of shares that have been issued to all NFT positions\n  uint256 internal totalStakeShares;\n\n  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)\n  IStrategyManager public override yieldStrategy;\n\n  // Instances of relevant Sherlock contracts\n  ISherDistributionManager public override sherDistributionManager;\n  ISherlockProtocolManager public override sherlockProtocolManager;\n  ISherlockClaimManager public override sherlockClaimManager;\n\n  // Address to which nonstaker payments are made\n  // This will start out as a multi-sig address, then become a contract address later\n  address public override nonStakersAddress;\n\n  // Stores the ID of the most recently created NFT\n  // This variable is incremented by 1 to create a new NFT ID\n  uint256 internal nftCounter;\n\n  // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.\n  constructor(\n    IERC20 token, // USDC address\n    IERC20 _sher, // SHER token address\n    string memory _name, // Token collection name (see ERC-721 docs)\n    string memory _symbol, // Token collection symbol (see ERC-721 docs)\n    IStrategyManager _yieldStrategy, // The active yield strategy contract\n    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract\n    address _nonStakersAddress, // The address to which nonstakers payments go\n    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract\n    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract\n    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for\n  ) ERC721(_name, _symbol) {\n    if (address(_token) == address(0)) revert ZeroArgument();\n    if (address(_sher) == address(0)) revert ZeroArgument();\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();\n    if (_nonStakersAddress == address(0)) revert ZeroArgument();\n    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();\n    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();\n\n    token = _token;\n    sher = _sher;\n    yieldStrategy = _yieldStrategy;\n    sherDistributionManager = _sherDistributionManager;\n    nonStakersAddress = _nonStakersAddress;\n    sherlockProtocolManager = _sherlockProtocolManager;\n    sherlockClaimManager = _sherlockClaimManager;\n\n    // Enabling the first set of staking periods that were provided in constructor args\n    for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {\n      enableStakingPeriod(_initialstakingPeriods[i]);\n    }\n\n    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);\n    emit SherDistributionManagerUpdated(\n      ISherDistributionManager(address(0)),\n      _sherDistributionManager\n    );\n    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);\n    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);\n    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);\n  }\n\n  //\n  // View functions\n  //\n\n  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked\n  /// @notice View the current lockup end timestamp of _tokenID\n  /// @return Timestamp when NFT position unlocks\n  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n\n    return lockupEnd[tokenID];\n  }\n\n  // Returns the SHER rewards owed to this position\n  /// @notice View the current SHER reward of _tokenID\n  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup\n  function sherRewards(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n\n    return sherRewards[tokenID];\n  }\n\n  // Returns the tokens (USDC) owed to a position\n  /// @notice View the current token balance claimable upon reaching end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking position\n  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers\n    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;\n  }\n\n  // Returns the tokens (USDC) owed to an address\n  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking all positions\n  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {\n    if (_staker == address(0)) revert ZeroArgument();\n    uint256 _totalStakeShares = totalStakeShares;\n    if (_totalStakeShares == 0) return 0;\n    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers\n    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;\n  }\n\n  // Gets the total amount of tokens (USDC) owed to stakers\n  // Adds this contract\'s balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract\n  /// @notice View the current TVL for all stakers\n  /// @return Total amount of tokens staked\n  /// @dev Adds principal + strategy + premiums\n  /// @dev Will calculate the most up to date value for each piece\n  function totalTokenBalanceStakers() public view override returns (uint256) {\n    return\n      token.balanceOf(address(this)) +\n      yieldStrategy.balanceOf() +\n      sherlockProtocolManager.claimablePremiums();\n  }\n\n  //\n  // Gov functions\n  //\n\n  // Allows governance to add a new staking period (4 months, etc.)\n  /// @notice Allows stakers to stake for _period of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already enabled\n  function enableStakingPeriod(uint256 _period) public override onlyOwner {\n    if (_period == 0) revert ZeroArgument();\n    // Revert if staking period is already active\n    if (stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sets the staking period to true\n    stakingPeriods[_period] = true;\n    emit StakingPeriodEnabled(_period);\n  }\n\n  // Allows governance to remove a staking period (4 months, etc.)\n  /// @notice Disallow stakers to stake for _period of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already disabled\n  function disableStakingPeriod(uint256 _period) external override onlyOwner {\n    // Revert if staking period is already inactive\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sets the staking period to false\n    stakingPeriods[_period] = false;\n    emit StakingPeriodDisabled(_period);\n  }\n\n  // Sets a new contract to be the active SHER distribution manager\n  /// @notice Update SHER distribution manager contract\n  /// @param _sherDistributionManager New adddress of the manager\n  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();\n    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();\n\n    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);\n    sherDistributionManager = _sherDistributionManager;\n  }\n\n  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)\n  /// @notice Remove SHER token rewards\n  function removeSherDistributionManager() external override onlyOwner {\n    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();\n\n    emit SherDistributionManagerUpdated(\n      sherDistributionManager,\n      ISherDistributionManager(address(0))\n    );\n    delete sherDistributionManager;\n  }\n\n  // Sets a new address for nonstakers payments\n  /// @notice Update address eligble for non staker rewards from protocol premiums\n  /// @param _nonStakers Address eligble for non staker rewards\n  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {\n    if (address(_nonStakers) == address(0)) revert ZeroArgument();\n    if (nonStakersAddress == _nonStakers) revert InvalidArgument();\n\n    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);\n    nonStakersAddress = _nonStakers;\n  }\n\n  // Sets a new protocol manager contract\n  /// @notice Transfer protocol manager implementation address\n  /// @param _protocolManager new implementation address\n  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_protocolManager) == address(0)) revert ZeroArgument();\n    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();\n\n    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);\n    sherlockProtocolManager = _protocolManager;\n  }\n\n  // Sets a new claim manager contract\n  /// @notice Transfer claim manager role to different address\n  /// @param _claimManager New address of claim manager\n  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_claimManager) == address(0)) revert ZeroArgument();\n    if (sherlockClaimManager == _claimManager) revert InvalidArgument();\n\n    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);\n    sherlockClaimManager = _claimManager;\n  }\n\n  // Sets a new yield strategy manager contract\n  /// @notice Update yield strategy\n  /// @param _yieldStrategy News address of the strategy\n  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure\n  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();\n\n    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail\n    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.\n    // In case this happens. We still want the yield strategy to be updated.\n    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.\n    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {\n      emit YieldStrategyUpdateWithdrawAllError(reason);\n    }\n\n    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);\n    yieldStrategy = _yieldStrategy;\n  }\n\n  // Deposits a chosen amount of tokens (USDC) into the active yield strategy\n  /// @notice Deposit _amount into active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {\n    if (_amount == 0) revert ZeroArgument();\n\n    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first\n    sherlockProtocolManager.claimPremiumsForStakers();\n    // Transfers the amount of tokens to the yield strategy contract\n    token.safeTransfer(address(yieldStrategy), _amount);\n    // Deposits all tokens in the yield strategy contract into the actual yield strategy\n    yieldStrategy.deposit();\n  }\n\n  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract\n  /// @notice Withdraw _amount from active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {\n    if (_amount == 0) revert ZeroArgument();\n\n    yieldStrategy.withdraw(_amount);\n  }\n\n  // Withdraws all tokens from the yield strategy back into this contract\n  /// @notice Withdraw all funds from active strategy\n  /// @dev gov only\n  function yieldStrategyWithdrawAll() external override onlyOwner {\n    yieldStrategy.withdrawAll();\n  }\n\n  /// @notice Pause external functions in all contracts\n  /// @dev A manager can be replaced with the new contract in a paused state\n  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused\n  function pause() external onlyOwner {\n    _pause();\n    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();\n    // sherDistributionManager can be 0, pause isn\'t needed in that case\n    if (\n      address(sherDistributionManager) != address(0) &amp;&amp;\n      !Pausable(address(sherDistributionManager)).paused()\n    ) {\n      sherDistributionManager.pause();\n    }\n    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();\n    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();\n  }\n\n  /// @notice Unpause external functions in all contracts\n  /// @dev A manager can be replaced with the new contract in an unpaused state\n  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused\n  function unpause() external onlyOwner {\n    _unpause();\n    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();\n    // sherDistributionManager can be 0, unpause isn\'t needed in that case\n    if (\n      address(sherDistributionManager) != address(0) &amp;&amp;\n      Pausable(address(sherDistributionManager)).paused()\n    ) {\n      sherDistributionManager.unpause();\n    }\n    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();\n    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();\n  }\n\n  //\n  // Access control functions\n  //\n\n  /// @notice Account sum of all underlying posiiton shares for _from and _to\n  /// @dev this enables the tokenBalanceOfAddress to exist\n  function _beforeTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenID\n  ) internal override {\n    uint256 _stakeShares = stakeShares[_tokenID];\n\n    if (_from != address(0)) addressShares[_from] -= _stakeShares;\n    if (_to != address(0)) addressShares[_to] += _stakeShares;\n  }\n\n  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)\n  // This function is called by the Sherlock claim manager contract if a claim is approved\n  /// @notice Initiate a payout of _amount to _receiver\n  /// @param _receiver Receiver of payout\n  /// @param _amount Amount to send\n  /// @dev only payout manager should call this\n  /// @dev should pull money out of strategy\n  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {\n    // Can only be called by the Sherlock claim manager contract\n    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();\n\n    if (_amount != 0) {\n      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)\n      _transferTokensOut(_receiver, _amount);\n    }\n    emit ClaimPayout(_receiver, _amount);\n  }\n\n  //\n  // Non-access control functions\n  //\n\n  // Helper function for initial staking and restaking\n  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position\n  /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time for which funds get locked\n  /// @param _id ID for this NFT position\n  /// @param _receiver Address that will be linked to this position\n  /// @return _sher Amount of SHER tokens awarded to this position after _period ends\n  /// @dev _period needs to be whitelisted\n  function _stake(\n    uint256 _amount,\n    uint256 _period,\n    uint256 _id,\n    address _receiver\n  ) internal returns (uint256 _sher) {\n    // Sets the timestamp at which this position can first be unstaked/restaked\n    lockupEnd[id] = block.timestamp + _period;\n\n    if (address(sherDistributionManager) == address(0)) return 0;\n    // Does not allow restaking of 0 tokens\n    if (_amount == 0) return 0;\n\n    // Checks this amount of SHER tokens in this contract before we transfer new ones\n    uint256 before = sher.balanceOf(address(this));\n\n    // pullReward() calcs then actually transfers the SHER tokens to this contract\n    // in case this call fails, whole (re)staking transaction fails\n    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);\n\n    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position\n    uint256 actualAmount = sher.balanceOf(address(this)) - before;\n    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);\n    // Assigns the newly created SHER tokens to the current stake position\n    if (_sher != 0) sherRewards[id] = _sher;\n  }\n\n  // Checks to see if the NFT owner is the caller and that the position is unlockable\n  function _verifyUnlockableByOwner(uint256 _id) internal view {\n    if (ownerOf(_id) != msg.sender) revert Unauthorized();\n    if (lockupEnd[id] &gt; block.timestamp) revert InvalidConditions();\n  }\n\n  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner\n  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {\n    uint256 sherReward = sherRewards[id];\n    if (sherReward == 0) return;\n\n    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner\n    sher.safeTransfer(_nftOwner, sherReward);\n    // Deletes the SHER reward mapping for this NFT ID\n    delete sherRewards[id];\n  }\n\n  // Transfers an amount of tokens to the receiver address\n  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)\n  function _transferTokensOut(address _receiver, uint256 _amount) internal {\n    // Transfers any premiums owed to stakers from the protocol manager to this contract\n    sherlockProtocolManager.claimPremiumsForStakers();\n\n    // The amount of tokens in this contract\n    uint256 mainBalance = token.balanceOf(address(this));\n\n    // If the amount to transfer out is still greater than the amount of tokens in this contract,\n    // Withdraw yield strategy tokens to make up the difference\n    if (_amount &gt; mainBalance) {\n      yieldStrategy.withdraw(_amount - mainBalance);\n    }\n\n    token.safeTransfer(_receiver, _amount);\n  }\n\n  // Returns the amount of USDC owed to this amount of stakeShares\n  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {\n    // Finds fraction that the given amount of stakeShares represents of the total\n    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers\n    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;\n  }\n\n  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted\n  // Also burns the requisite amount of shares associated with this NFT position\n  // Returns the amount of USDC owed to these shares\n  function _redeemShares(\n    uint256 _id,\n    uint256 _stakeShares,\n    address _receiver\n  ) internal returns (uint256 _amount) {\n    // Returns the amount of USDC owed to this amount of stakeShares\n    _amount = _redeemSharesCalc(_stakeShares);\n    // Transfers _amount of tokens to _receiver address\n    if (_amount != 0) _transferTokensOut(_receiver, _amount);\n\n    // Subtracts this amount of stakeShares from the NFT position\n    stakeShares[_id] -= _stakeShares;\n    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding\n    totalStakeShares -= _stakeShares;\n  }\n\n  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager\n  // Restakes an NFT position (_id) for a given period (_period) and\n  // Sends any previously earned SHER rewards to the _nftOwner address\n  function _restake(\n    uint256 _id,\n    uint256 _period,\n    address _nftOwner\n  ) internal returns (uint256 _sher) {\n    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner\n    // NOTE This function deletes the SHER reward mapping for this NFT ID\n    _sendSherRewardsToOwner(_id, _nftOwner);\n\n    // tokenBalanceOf() returns the USDC amount owed to this NFT ID\n    // _stake() restakes that amount of USDC for the period inputted\n    // We use the same ID that we just deleted the SHER rewards mapping for\n    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID\n    // Note stakeShares for this position do not change so no need to update\n    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);\n\n    emit Restaked(_id);\n  }\n\n  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)\n  /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @param _receiver Address that will receive the NFT representing the position\n  /// @return _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to this ID after _period ends\n  /// @dev _period needs to be whitelisted\n  function initialStake(\n    uint256 _amount,\n    uint256 _period,\n    address _receiver\n  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {\n    if (_amount == 0) revert ZeroArgument();\n    // Makes sure the period is a whitelisted period\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n    if (address(_receiver) == address(0)) revert ZeroArgument();\n    // Adds 1 to the ID of the last NFT created for the new NFT ID\n    _id = ++nftCounter;\n\n    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)\n    token.safeTransferFrom(msg.sender, address(this), _amount);\n\n    uint256 stakeShares;\n    uint256 totalStakeShares_ = totalStakeShares;\n    // amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares\n    if (totalStakeShares != 0)\n      stakeShares_ = (amount * totalStakeShares) / (totalTokenBalanceStakers() - amount);\n      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked\n    else stakeShares = amount;\n\n    // Assigns this NFT ID the calc\'d amount of stake shares above\n    stakeShares[_id] = stakeShares;\n    // Adds the newly created stake shares to the total amount of stake shares\n    totalStakeShares += stakeShares_;\n\n    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake\n    sher = _stake(_amount, _period, _id, _receiver);\n\n    // This is an ERC-721 function that creates an NFT and sends it to the receiver\n    _safeMint(_receiver, _id);\n  }\n\n  // This is how a staker unstakes and cashes out on their position\n  /// @notice Redeem NFT _id and receive _amount of tokens\n  /// @param _id TokenID of the position\n  /// @return _amount Amount of tokens (USDC) owed to NFT ID\n  /// @dev Only the owner of _id will be able to redeem their position\n  /// @dev The SHER rewards are sent to the NFT owner\n  /// @dev Can only be called after lockup _period has ended\n  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {\n    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over\n    _verifyUnlockableByOwner(_id);\n\n    // This is the ERC-721 function to destroy an NFT (with owner\'s approval)\n    _burn(_id);\n\n    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID\n    // Also burns the requisite amount of shares associated with this NFT position\n    // Returns the amount of USDC owed to these shares\n    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);\n\n    // Sends the SHER tokens associated with this NFT ID to the NFT owner\n    _sendSherRewardsToOwner(_id, msg.sender);\n\n    // Removes the unlock deadline associated with this NFT\n    delete lockupEnd[id];\n  }\n\n  // This is how a staker restakes an expired position\n  /// @notice Owner restakes position with ID: _id for _period seconds\n  /// @param _id ID of the position\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @return _sher Amount of SHER tokens to be released to owner address after _period ends\n  /// @dev Only the owner of _id will be able to restake their position using this call\n  /// @dev _period needs to be whitelisted\n  /// @dev Can only be called after lockup _period has ended\n  function ownerRestake(uint256 _id, uint256 _period)\n    external\n    override\n    whenNotPaused\n    returns (uint256 _sher)\n  {\n    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over\n    _verifyUnlockableByOwner(_id);\n\n    // Checks to make sure the staking period is a whitelisted one\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position\n    _sher = _restake(_id, _period, msg.sender);\n  }\n\n  // Calcs the reward (in stake shares) an arb would get for restaking a position\n  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb\n  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {\n    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)\n    uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME;\n\n    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position\n    if (initialArbTime &gt; block.timestamp) return (0, false);\n\n    // The max rewards (as a % of the position\'s shares) for the arb are available at this timestamp\n    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;\n\n    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%\n    uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;\n\n    // Scaled by 1018\n    // Represents the max amount of stake shares that an arb could get from restaking this position\n    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];\n\n    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function\n    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled\n    return (\n      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10*18,\n      true\n    );\n  }\n\n  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position\n  /// @return profit How much profit an arb would make in USDC\n  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)\n  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {\n    // Returns the stake shares that an arb would get, and whether the position can currently be arbed\n    // profit variable is used to store the amount of shares\n    (profit, able) = _calcSharesForArbRestake(_id);\n    // Calculates the tokens (USDC) represented by that amount of stake shares\n    // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit\n    profit = _redeemSharesCalc(profit);\n  }\n\n  /// @notice Allows someone who doesn\'t own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)\n  /// @param _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup\n  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function\n  /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)\n  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)\n  /// @dev During a 2 week period the reward ratio will move from 0% to 100% ( x)\n  function arbRestake(uint256 _id)\n    external\n    override\n    whenNotPaused\n    returns (uint256 _sher, uint256 _arbReward)\n  {\n    address nftOwner = ownerOf(_id);\n\n    // Returns the stake shares that an arb would get, and whether the position can currently be arbed\n    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);\n    // Revert if not able to be arbed\n    if (!able) revert InvalidConditions();\n\n    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward\n    // Also burns the requisite amount of shares associated with this NFT position\n    // Returns the amount of USDC paid to the arbitrager\n    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);\n\n    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)\n    // Sends previously earned SHER rewards to the NFT owner address\n    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);\n\n    emit ArbRestaked(_id, _arbReward);\n  }\n}\n', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-25-08 10:37:21 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@openzeppelin/contracts/token/ERC721/ERC721.sol'; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol'; import '@openzeppelin/contracts/security/Pausable.sol'; import './interfaces/ISherlock.sol'; /// @title Sherlock core interface for stakers /// @author Evert Kors // This is the contract that manages staking actions contract Sherlock is ISherlock, ERC721, Ownable, Pausable {   using SafeERC20 for IERC20; // The initial period for a staker to restake/withdraw without being auto-restaked   uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks; // The period during which the reward for restaking an account (after the inital period) grows   uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks; // Anyone who gets auto-restaked is restaked for this period (3 months)   uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks; // The percentage of someone's stake that can be paid to an arb for restaking   uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20% // USDC address   IERC20 public immutable token; // SHER token address   IERC20 public immutable sher; // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not   mapping(uint256 =&gt; bool) public override stakingPeriods; // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked   mapping(uint256 =&gt; uint256) internal lockupEnd_; // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position   mapping(uint256 =&gt; uint256) internal sherRewards_; // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)   mapping(uint256 =&gt; uint256) internal stakeShares; // Key is account, value is the sum of underlying shares of all the NFTs the account owns.   mapping(address =&gt; uint256) internal addressShares; // Total amount of shares that have been issued to all NFT positions   uint256 internal totalStakeShares; // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)   IStrategyManager public override yieldStrategy; // Instances of relevant Sherlock contracts   ISherDistributionManager public override sherDistributionManager;   ISherlockProtocolManager public override sherlockProtocolManager;   ISherlockClaimManager public override sherlockClaimManager; // Address to which nonstaker payments are made   // This will start out as a multi-sig address, then become a contract address later   address public override nonStakersAddress; // Stores the ID of the most recently created NFT   // This variable is incremented by 1 to create a new NFT ID   uint256 internal nftCounter; // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.   constructor(     IERC20 _token, // USDC address     IERC20 _sher, // SHER token address     string memory _name, // Token collection name (see ERC-721 docs)     string memory _symbol, // Token collection symbol (see ERC-721 docs)     IStrategyManager _yieldStrategy, // The active yield strategy contract     ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract     address _nonStakersAddress, // The address to which nonstakers payments go     ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract     ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract     uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for   ) ERC721(_name, _symbol) {     if (address(_token) == address(0)) revert ZeroArgument();     if (address(_sher) == address(0)) revert ZeroArgument();     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (_nonStakersAddress == address(0)) revert ZeroArgument();     if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();     if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument(); token = _token; sher = _sher; yieldStrategy = _yieldStrategy; sherDistributionManager = _sherDistributionManager; nonStakersAddress = _nonStakersAddress; sherlockProtocolManager = _sherlockProtocolManager; sherlockClaimManager = _sherlockClaimManager;  // Enabling the first set of staking periods that were provided in constructor args for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {   enableStakingPeriod(_initialstakingPeriods[i]); }  emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy); emit SherDistributionManagerUpdated(   ISherDistributionManager(address(0)),   _sherDistributionManager ); emit NonStakerAddressUpdated(address(0), _nonStakersAddress); emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager); emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);  } //   // View functions   // // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked   /// @notice View the current lockup end timestamp of _tokenID   /// @return Timestamp when NFT position unlocks   function lockupEnd(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return lockupEnd_[_tokenID];  } // Returns the SHER rewards owed to this position   /// @notice View the current SHER reward of _tokenID   /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup   function sherRewards(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return sherRewards_[_tokenID];  } // Returns the tokens (USDC) owed to a position   /// @notice View the current token balance claimable upon reaching end of the lockup   /// @return Amount of tokens assigned to owner when unstaking position   function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent();     // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers     return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;   } // Returns the tokens (USDC) owed to an address   /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup   /// @return Amount of tokens assigned to owner when unstaking all positions   function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {     if (_staker == address(0)) revert ZeroArgument();     uint256 _totalStakeShares = totalStakeShares;     if (_totalStakeShares == 0) return 0;     // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers     return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;   } // Gets the total amount of tokens (USDC) owed to stakers   // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract   /// @notice View the current TVL for all stakers   /// @return Total amount of tokens staked   /// @dev Adds principal + strategy + premiums   /// @dev Will calculate the most up to date value for each piece   function totalTokenBalanceStakers() public view override returns (uint256) {     return       token.balanceOf(address(this)) +       yieldStrategy.balanceOf() +       sherlockProtocolManager.claimablePremiums();   } //   // Gov functions   // // Allows governance to add a new staking period (4 months, etc.)   /// @notice Allows stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already enabled   function enableStakingPeriod(uint256 _period) public override onlyOwner {     if (_period == 0) revert ZeroArgument();     // Revert if staking period is already active     if (stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to true stakingPeriods[_period] = true; emit StakingPeriodEnabled(_period);  } // Allows governance to remove a staking period (4 months, etc.)   /// @notice Disallow stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already disabled   function disableStakingPeriod(uint256 _period) external override onlyOwner {     // Revert if staking period is already inactive     if (!stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to false stakingPeriods[_period] = false; emit StakingPeriodDisabled(_period);  } // Sets a new contract to be the active SHER distribution manager   /// @notice Update SHER distribution manager contract   /// @param _sherDistributionManager New adddress of the manager   function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)     external     override     onlyOwner   {     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument(); emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager); sherDistributionManager = _sherDistributionManager;  } // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)   /// @notice Remove SHER token rewards   function removeSherDistributionManager() external override onlyOwner {     if (address(sherDistributionManager) == address(0)) revert InvalidConditions(); emit SherDistributionManagerUpdated(   sherDistributionManager,   ISherDistributionManager(address(0)) ); delete sherDistributionManager;  } // Sets a new address for nonstakers payments   /// @notice Update address eligble for non staker rewards from protocol premiums   /// @param _nonStakers Address eligble for non staker rewards   function updateNonStakersAddress(address _nonStakers) external override onlyOwner {     if (address(_nonStakers) == address(0)) revert ZeroArgument();     if (nonStakersAddress == _nonStakers) revert InvalidArgument(); emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers); nonStakersAddress = _nonStakers;  } // Sets a new protocol manager contract   /// @notice Transfer protocol manager implementation address   /// @param _protocolManager new implementation address   function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)     external     override     onlyOwner   {     if (address(_protocolManager) == address(0)) revert ZeroArgument();     if (sherlockProtocolManager == _protocolManager) revert InvalidArgument(); emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager); sherlockProtocolManager = _protocolManager;  } // Sets a new claim manager contract   /// @notice Transfer claim manager role to different address   /// @param _claimManager New address of claim manager   function updateSherlockClaimManager(ISherlockClaimManager _claimManager)     external     override     onlyOwner   {     if (address(_claimManager) == address(0)) revert ZeroArgument();     if (sherlockClaimManager == _claimManager) revert InvalidArgument(); emit ClaimManagerUpdated(sherlockClaimManager, _claimManager); sherlockClaimManager = _claimManager;  } // Sets a new yield strategy manager contract   /// @notice Update yield strategy   /// @param _yieldStrategy News address of the strategy   /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure   function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (yieldStrategy == _yieldStrategy) revert InvalidArgument(); // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason. // In case this happens. We still want the yield strategy to be updated. // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again. try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {   emit YieldStrategyUpdateWithdrawAllError(reason); }  emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy); yieldStrategy = _yieldStrategy;  } // Deposits a chosen amount of tokens (USDC) into the active yield strategy   /// @notice Deposit _amount into active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); // Transfers any tokens owed to stakers from the protocol manager contract to this contract first sherlockProtocolManager.claimPremiumsForStakers(); // Transfers the amount of tokens to the yield strategy contract token.safeTransfer(address(yieldStrategy), _amount); // Deposits all tokens in the yield strategy contract into the actual yield strategy yieldStrategy.deposit();  } // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract   /// @notice Withdraw _amount from active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); yieldStrategy.withdraw(_amount);  } // Withdraws all tokens from the yield strategy back into this contract   /// @notice Withdraw all funds from active strategy   /// @dev gov only   function yieldStrategyWithdrawAll() external override onlyOwner {     yieldStrategy.withdrawAll();   } /// @notice Pause external functions in all contracts   /// @dev A manager can be replaced with the new contract in a paused state   /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused   function pause() external onlyOwner {     _pause();     if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();     // sherDistributionManager can be 0, pause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       !Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.pause();     }     if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();     if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();   } /// @notice Unpause external functions in all contracts   /// @dev A manager can be replaced with the new contract in an unpaused state   /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused   function unpause() external onlyOwner {     _unpause();     if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();     // sherDistributionManager can be 0, unpause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.unpause();     }     if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();     if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();   } //   // Access control functions   // /// @notice Account sum of all underlying posiiton shares for _from and _to   /// @dev this enables the tokenBalanceOfAddress to exist   function _beforeTokenTransfer(     address _from,     address _to,     uint256 _tokenID   ) internal override {     uint256 _stakeShares = stakeShares[_tokenID]; if (_from != address(0)) addressShares[_from] -= _stakeShares; if (_to != address(0)) addressShares[_to] += _stakeShares;  } // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)   // This function is called by the Sherlock claim manager contract if a claim is approved   /// @notice Initiate a payout of _amount to _receiver   /// @param _receiver Receiver of payout   /// @param _amount Amount to send   /// @dev only payout manager should call this   /// @dev should pull money out of strategy   function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {     // Can only be called by the Sherlock claim manager contract     if (msg.sender != address(sherlockClaimManager)) revert Unauthorized(); if (_amount != 0) {   // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)   _transferTokensOut(_receiver, _amount); } emit ClaimPayout(_receiver, _amount);  } //   // Non-access control functions   // // Helper function for initial staking and restaking   // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position   /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds   /// @param amount Amount of tokens to stake   /// @param _period Period of time for which funds get locked   /// @param _id ID for this NFT position   /// @param _receiver Address that will be linked to this position   /// @return _sher Amount of SHER tokens awarded to this position after _period ends   /// @dev _period needs to be whitelisted   function _stake(     uint256 _amount,     uint256 _period,     uint256 _id,     address _receiver   ) internal returns (uint256 _sher) {     // Sets the timestamp at which this position can first be unstaked/restaked     lockupEnd[_id] = block.timestamp + _period; if (address(sherDistributionManager) == address(0)) return 0; // Does not allow restaking of 0 tokens if (_amount == 0) return 0;  // Checks this amount of SHER tokens in this contract before we transfer new ones uint256 before = sher.balanceOf(address(this));  // pullReward() calcs then actually transfers the SHER tokens to this contract // in case this call fails, whole (re)staking transaction fails _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);  // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position uint256 actualAmount = sher.balanceOf(address(this)) - before; if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount); // Assigns the newly created SHER tokens to the current stake position if (_sher != 0) sherRewards_[_id] = _sher;  } // Checks to see if the NFT owner is the caller and that the position is unlockable   function verifyUnlockableByOwner(uint256 _id) internal view {     if (ownerOf(_id) != msg.sender) revert Unauthorized();     if (lockupEnd[_id] &gt; block.timestamp) revert InvalidConditions();   } // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner   function sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards[_id];     if (sherReward == 0) return; // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner sher.safeTransfer(_nftOwner, sherReward); // Deletes the SHER reward mapping for this NFT ID delete sherRewards_[_id];  } // Transfers an amount of tokens to the receiver address   // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)   function _transferTokensOut(address _receiver, uint256 _amount) internal {     // Transfers any premiums owed to stakers from the protocol manager to this contract     sherlockProtocolManager.claimPremiumsForStakers(); // The amount of tokens in this contract uint256 mainBalance = token.balanceOf(address(this));  // If the amount to transfer out is still greater than the amount of tokens in this contract, // Withdraw yield strategy tokens to make up the difference if (_amount &gt; mainBalance) {   yieldStrategy.withdraw(_amount - mainBalance); }  token.safeTransfer(_receiver, _amount);  } // Returns the amount of USDC owed to this amount of stakeShares   function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {     // Finds fraction that the given amount of stakeShares represents of the total     // Then multiplies it by the total amount of tokens (USDC) owed to all stakers     return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;   } // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted   // Also burns the requisite amount of shares associated with this NFT position   // Returns the amount of USDC owed to these shares   function _redeemShares(     uint256 _id,     uint256 _stakeShares,     address _receiver   ) internal returns (uint256 _amount) {     // Returns the amount of USDC owed to this amount of stakeShares     _amount = _redeemSharesCalc(_stakeShares);     // Transfers _amount of tokens to _receiver address     if (_amount != 0) _transferTokensOut(_receiver, _amount); // Subtracts this amount of stakeShares from the NFT position stakeShares[_id] -= _stakeShares; // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding totalStakeShares -= _stakeShares;  } // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager   // Restakes an NFT position (_id) for a given period (_period) and   // Sends any previously earned SHER rewards to the _nftOwner address   function _restake(     uint256 _id,     uint256 _period,     address _nftOwner   ) internal returns (uint256 _sher) {     // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner     // NOTE This function deletes the SHER reward mapping for this NFT ID     _sendSherRewardsToOwner(_id, _nftOwner); // tokenBalanceOf() returns the USDC amount owed to this NFT ID // _stake() restakes that amount of USDC for the period inputted // We use the same ID that we just deleted the SHER rewards mapping for // Resets the lockupEnd mapping and SHER token rewards mapping for this ID // Note stakeShares for this position do not change so no need to update _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);  emit Restaked(_id);  } // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)   /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt   /// @param _amount Amount of tokens to stake   /// @param _period Period of time, in seconds, to lockup your funds   /// @param _receiver Address that will receive the NFT representing the position   /// @return _id ID of the position   /// @return _sher Amount of SHER tokens to be released to this ID after _period ends   /// @dev _period needs to be whitelisted   function initialStake(     uint256 _amount,     uint256 _period,     address _receiver   ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {     if (_amount == 0) revert ZeroArgument();     // Makes sure the period is a whitelisted period     if (!stakingPeriods[_period]) revert InvalidArgument();     if (address(_receiver) == address(0)) revert ZeroArgument();     // Adds 1 to the ID of the last NFT created for the new NFT ID     _id = ++nftCounter; // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action) token.safeTransferFrom(msg.sender, address(this), _amount);  uint256 stakeShares_; uint256 totalStakeShares_ = totalStakeShares; // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares if (totalStakeShares_ != 0)   stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);   // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked else stakeShares_ = _amount;  // Assigns this NFT ID the calc'd amount of stake shares above stakeShares[_id] = stakeShares_; // Adds the newly created stake shares to the total amount of stake shares totalStakeShares += stakeShares_;  // Locks up the USDC amount and calcs the SHER token amount to receive on unstake _sher = _stake(_amount, _period, _id, _receiver);  // This is an ERC-721 function that creates an NFT and sends it to the receiver _safeMint(_receiver, _id);  } // This is how a staker unstakes and cashes out on their position   /// @notice Redeem NFT _id and receive _amount of tokens   /// @param _id TokenID of the position   /// @return _amount Amount of tokens (USDC) owed to NFT ID   /// @dev Only the owner of _id will be able to redeem their position   /// @dev The SHER rewards are sent to the NFT owner   /// @dev Can only be called after lockup _period has ended   function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // This is the ERC-721 function to destroy an NFT (with owner's approval) _burn(_id);  // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC owed to these shares _amount = _redeemShares(_id, stakeShares[_id], msg.sender);  // Sends the SHER tokens associated with this NFT ID to the NFT owner _sendSherRewardsToOwner(_id, msg.sender);  // Removes the unlock deadline associated with this NFT delete lockupEnd_[_id];  } // This is how a staker restakes an expired position   /// @notice Owner restakes position with ID: _id for _period seconds   /// @param _id ID of the position   /// @param _period Period of time, in seconds, to lockup your funds   /// @return _sher Amount of SHER tokens to be released to owner address after _period ends   /// @dev Only the owner of _id will be able to restake their position using this call   /// @dev _period needs to be whitelisted   /// @dev Can only be called after lockup _period has ended   function ownerRestake(uint256 _id, uint256 _period)     external     override     whenNotPaused     returns (uint256 _sher)   {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // Checks to make sure the staking period is a whitelisted one if (!stakingPeriods[_period]) revert InvalidArgument();  // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position _sher = _restake(_id, _period, msg.sender);  } // Calcs the reward (in stake shares) an arb would get for restaking a position   // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb   function calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {     // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)     uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME; // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position if (initialArbTime &gt; block.timestamp) return (0, false);  // The max rewards (as a % of the position's shares) for the arb are available at this timestamp uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;  // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100% uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;  // Scaled by 10**18 // Represents the max amount of stake shares that an arb could get from restaking this position uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];  // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled return (   ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,   true );  } /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position   /// @return profit How much profit an arb would make in USDC   /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)   function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {     // Returns the stake shares that an arb would get, and whether the position can currently be arbed     // profit variable is used to store the amount of shares     (profit, able) = _calcSharesForArbRestake(_id);     // Calculates the tokens (USDC) represented by that amount of stake shares     // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit     profit = _redeemSharesCalc(profit);   } /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)   /// @param _id ID of the position   /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup   /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function   /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)   /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)   /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)   function arbRestake(uint256 _id)     external     override     whenNotPaused     returns (uint256 _sher, uint256 _arbReward)   {     address nftOwner = ownerOf(_id); // Returns the stake shares that an arb would get, and whether the position can currently be arbed (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id); // Revert if not able to be arbed if (!able) revert InvalidConditions();  // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC paid to the arbitrager _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);  // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months) // Sends previously earned SHER rewards to the NFT owner address _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);  emit ArbRestaked(_id, _arbReward);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-25-08 10:37:21 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';

import './interfaces/ISherlock.sol';

/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions

contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;

  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;

  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;

  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;

  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%

  // USDC address
  IERC20 public immutable token;

  // SHER token address
  IERC20 public immutable sher;

  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;

  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;

  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;

  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;

  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;

  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;

  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;

  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;

  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;

  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;

  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();

    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;

    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }

    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }

  //
  // View functions
  //

  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return lockupEnd_[_tokenID];
  }

  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return sherRewards_[_tokenID];
  }

  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }

  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }

  //
  // Gov functions
  //

  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }

  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }

  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();

    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }

  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();

    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }

  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();

    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }

  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();

    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }

  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();

    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }

  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();

    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }

    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }

  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }

  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    yieldStrategy.withdraw(_amount);
  }

  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }

  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }

  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }

  //
  // Access control functions
  //

  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];

    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }

  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();

    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }

  //
  // Non-access control functions
  //

  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;

    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;

    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));

    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);

    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }

  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }

  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;

    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }

  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();

    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));

    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }

    token.safeTransfer(_receiver, _amount);
  }

  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);

    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }

  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);

    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);

    emit Restaked(_id);
  }

  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;

    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);

    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;

    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;

    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);

    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }

  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);

    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);

    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);

    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }

  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }

  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;

    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);

    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;

    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;

    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];

    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }

  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }

  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);

    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();

    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);

    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);

    emit ArbRestaked(_id, _arbReward);
  }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';

import './interfaces/ISherlock.sol';

/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions

contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;

  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;

  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;

  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;

  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%

  // USDC address
  IERC20 public immutable token;

  // SHER token address
  IERC20 public immutable sher;

  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;

  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;

  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;

  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;

  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;

  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;

  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;

  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;

  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;

  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;

  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();

    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;

    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }

    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }

  //
  // View functions
  //

  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return lockupEnd_[_tokenID];
  }

  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return sherRewards_[_tokenID];
  }

  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }

  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }

  //
  // Gov functions
  //

  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }

  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }

  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();

    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }

  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();

    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }

  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();

    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }

  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();

    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }

  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();

    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }

  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();

    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }

    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }

  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }

  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    yieldStrategy.withdraw(_amount);
  }

  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }

  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }

  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }

  //
  // Access control functions
  //

  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];

    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }

  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();

    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }

  //
  // Non-access control functions
  //

  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;

    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;

    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));

    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);

    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }

  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }

  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;

    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }

  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();

    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));

    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }

    token.safeTransfer(_receiver, _amount);
  }

  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);

    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }

  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);

    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);

    emit Restaked(_id);
  }

  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;

    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);

    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;

    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;

    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);

    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }

  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);

    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);

    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);

    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }

  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }

  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;

    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);

    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;

    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;

    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];

    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }

  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }

  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);

    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();

    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);

    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);

    emit ArbRestaked(_id, _arbReward);
  }
}
".
Ideas: " 1".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-25-08 10:37:31 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-25-08 10:37:31 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 15564
completion_tokens: 801
total_tokens: 16365
cost: $-1.000000


[2024-25-08 10:37:31 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';

import './interfaces/ISherlock.sol';

/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions

contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;

  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;

  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;

  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;

  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%

  // USDC address
  IERC20 public immutable token;

  // SHER token address
  IERC20 public immutable sher;

  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;

  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;

  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;

  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;

  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;

  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;

  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;

  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;

  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;

  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;

  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();

    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;

    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }

    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }

  //
  // View functions
  //

  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return lockupEnd_[_tokenID];
  }

  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return sherRewards_[_tokenID];
  }

  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }

  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }

  //
  // Gov functions
  //

  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }

  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }

  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();

    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }

  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();

    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }

  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();

    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }

  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();

    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }

  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();

    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }

  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();

    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }

    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }

  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }

  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    yieldStrategy.withdraw(_amount);
  }

  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }

  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }

  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }

  //
  // Access control functions
  //

  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];

    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }

  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();

    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }

  //
  // Non-access control functions
  //

  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;

    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;

    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));

    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);

    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }

  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }

  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;

    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }

  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();

    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));

    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }

    token.safeTransfer(_receiver, _amount);
  }

  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);

    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }

  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);

    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);

    emit Restaked(_id);
  }

  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;

    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);

    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;

    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;

    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);

    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }

  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);

    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);

    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);

    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }

  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }

  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;

    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);

    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;

    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;

    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];

    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }

  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }

  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);

    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();

    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);

    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);

    emit ArbRestaked(_id, _arbReward);
  }
}
.]

### VULNERABILITY 1: Reentrancy Attack
```
DETAILED DESCRIPTION: The contract does not implement a reentrancy guard in functions that transfer tokens or call external contracts. For example, in the `_transferTokensOut` function, if an external contract is called (like the yield strategy or the token transfer), it could potentially call back into the contract before the first call completes, leading to unexpected behavior or draining of funds.

POTENTIAL IMPACT: An attacker could exploit this vulnerability to repeatedly call the `payoutClaim` or `_transferTokensOut` function, draining the contract's funds.

RECOMMENDED MITIGATION: Implement a reentrancy guard using the `nonReentrant` modifier from OpenZeppelin's `ReentrancyGuard` contract. This should be applied to any function that transfers tokens or interacts with external contracts.
```

### VULNERABILITY 2: Integer Overflow/Underflow
```
DETAILED DESCRIPTION: Although Solidity 0.8.x has built-in overflow and underflow checks, there are still areas where the logic could lead to unexpected behavior, especially in calculations involving shares and balances. For instance, in the `_redeemShares` function, if `_stakeShares` is greater than `stakeShares[_id]`, it could lead to an underflow.

POTENTIAL IMPACT: This could allow an attacker to manipulate the contract's state, leading to incorrect balances and potential loss of funds.

RECOMMENDED MITIGATION: Ensure that all calculations involving shares and balances include checks to prevent underflow and overflow, even though Solidity 0.8.x provides automatic checks.
```

### VULNERABILITY 3: Improper Access Control
```
DETAILED DESCRIPTION: The contract relies on the `onlyOwner` modifier for critical functions such as `updateSherDistributionManager`, `updateYieldStrategy`, and others. If the owner's private key is compromised, an attacker could gain control over these functions.

POTENTIAL IMPACT: An attacker could change critical parameters of the contract, redirect funds, or disable the contract's functionality.

RECOMMENDED MITIGATION: Consider implementing a multi-signature wallet for ownership or a time-lock mechanism for sensitive functions to reduce the risk of a single point of failure.
```

### VULNERABILITY 4: Lack of Input Validation
```
DETAILED DESCRIPTION: Functions such as `enableStakingPeriod` and `disableStakingPeriod` do not validate the input period against a reasonable range. There is also no check to ensure that the period is not excessively long or short.

POTENTIAL IMPACT: This could lead to unintended consequences, such as allowing staking periods that are impractically long or short, which could disrupt the staking mechanism.

RECOMMENDED MITIGATION: Implement checks to ensure that the staking period is within a reasonable range (e.g., between a minimum and maximum threshold).
```

### VULNERABILITY 5: Token Transfer Failures
```
DETAILED DESCRIPTION: The contract does not handle the case where token transfers fail. For example, in the `_transferTokensOut` function, if the `safeTransfer` call fails, the contract will not revert, leading to inconsistent states.

POTENTIAL IMPACT: This could result in funds being lost or incorrectly accounted for, as the state of the contract may not reflect the actual balances.

RECOMMENDED MITIGATION: Use the `require` statement to ensure that token transfers succeed. For example, after `token.safeTransfer`, check that the balance has decreased as expected.
```

### VULNERABILITY 6: Unchecked External Calls
```
DETAILED DESCRIPTION: The contract makes external calls to other contracts (e.g., `yieldStrategy`, `sherDistributionManager`) without checking their return values. If these calls fail, it can lead to unexpected behavior.

POTENTIAL IMPACT: If an external contract fails or behaves unexpectedly

[2024-25-08 10:37:31 INFO] **[Seminar Conclusion]**:

 ### VULNERABILITY 1: Reentrancy Attack
```
DETAILED DESCRIPTION: The contract does not implement a reentrancy guard in functions that transfer tokens or call external contracts. For example, in the `_transferTokensOut` function, if an external contract is called (like the yield strategy or the token transfer), it could potentially call back into the contract before the first call completes, leading to unexpected behavior or draining of funds.

POTENTIAL IMPACT: An attacker could exploit this vulnerability to repeatedly call the `payoutClaim` or `_transferTokensOut` function, draining the contract's funds.

RECOMMENDED MITIGATION: Implement a reentrancy guard using the `nonReentrant` modifier from OpenZeppelin's `ReentrancyGuard` contract. This should be applied to any function that transfers tokens or interacts with external contracts.
```

### VULNERABILITY 2: Integer Overflow/Underflow
```
DETAILED DESCRIPTION: Although Solidity 0.8.x has built-in overflow and underflow checks, there are still areas where the logic could lead to unexpected behavior, especially in calculations involving shares and balances. For instance, in the `_redeemShares` function, if `_stakeShares` is greater than `stakeShares[_id]`, it could lead to an underflow.

POTENTIAL IMPACT: This could allow an attacker to manipulate the contract's state, leading to incorrect balances and potential loss of funds.

RECOMMENDED MITIGATION: Ensure that all calculations involving shares and balances include checks to prevent underflow and overflow, even though Solidity 0.8.x provides automatic checks.
```

### VULNERABILITY 3: Improper Access Control
```
DETAILED DESCRIPTION: The contract relies on the `onlyOwner` modifier for critical functions such as `updateSherDistributionManager`, `updateYieldStrategy`, and others. If the owner's private key is compromised, an attacker could gain control over these functions.

POTENTIAL IMPACT: An attacker could change critical parameters of the contract, redirect funds, or disable the contract's functionality.

RECOMMENDED MITIGATION: Consider implementing a multi-signature wallet for ownership or a time-lock mechanism for sensitive functions to reduce the risk of a single point of failure.
```

### VULNERABILITY 4: Lack of Input Validation
```
DETAILED DESCRIPTION: Functions such as `enableStakingPeriod` and `disableStakingPeriod` do not validate the input period against a reasonable range. There is also no check to ensure that the period is not excessively long or short.

POTENTIAL IMPACT: This could lead to unintended consequences, such as allowing staking periods that are impractically long or short, which could disrupt the staking mechanism.

RECOMMENDED MITIGATION: Implement checks to ensure that the staking period is within a reasonable range (e.g., between a minimum and maximum threshold).
```

### VULNERABILITY 5: Token Transfer Failures
```
DETAILED DESCRIPTION: The contract does not handle the case where token transfers fail. For example, in the `_transferTokensOut` function, if the `safeTransfer` call fails, the contract will not revert, leading to inconsistent states.

POTENTIAL IMPACT: This could result in funds being lost or incorrectly accounted for, as the state of the contract may not reflect the actual balances.

RECOMMENDED MITIGATION: Use the `require` statement to ensure that token transfers succeed. For example, after `token.safeTransfer`, check that the balance has decreased as expected.
```

### VULNERABILITY 6: Unchecked External Calls
```
DETAILED DESCRIPTION: The contract makes external calls to other contracts (e.g., `yieldStrategy`, `sherDistributionManager`) without checking their return values. If these calls fail, it can lead to unexpected behavior.

POTENTIAL IMPACT: If an external contract fails or behaves unexpectedly

[2024-25-08 10:37:31 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-25-08 10:37:31 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@openzeppelin/contracts/token/ERC721/ERC721.sol'; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol'; import '@openzeppelin/contracts/security/Pausable.sol'; import './interfaces/ISherlock.sol'; /// @title Sherlock core interface for stakers /// @author Evert Kors // This is the contract that manages staking actions contract Sherlock is ISherlock, ERC721, Ownable, Pausable {   using SafeERC20 for IERC20; // The initial period for a staker to restake/withdraw without being auto-restaked   uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks; // The period during which the reward for restaking an account (after the inital period) grows   uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks; // Anyone who gets auto-restaked is restaked for this period (3 months)   uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks; // The percentage of someone's stake that can be paid to an arb for restaking   uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20% // USDC address   IERC20 public immutable token; // SHER token address   IERC20 public immutable sher; // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not   mapping(uint256 =&gt; bool) public override stakingPeriods; // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked   mapping(uint256 =&gt; uint256) internal lockupEnd_; // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position   mapping(uint256 =&gt; uint256) internal sherRewards_; // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)   mapping(uint256 =&gt; uint256) internal stakeShares; // Key is account, value is the sum of underlying shares of all the NFTs the account owns.   mapping(address =&gt; uint256) internal addressShares; // Total amount of shares that have been issued to all NFT positions   uint256 internal totalStakeShares; // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)   IStrategyManager public override yieldStrategy; // Instances of relevant Sherlock contracts   ISherDistributionManager public override sherDistributionManager;   ISherlockProtocolManager public override sherlockProtocolManager;   ISherlockClaimManager public override sherlockClaimManager; // Address to which nonstaker payments are made   // This will start out as a multi-sig address, then become a contract address later   address public override nonStakersAddress; // Stores the ID of the most recently created NFT   // This variable is incremented by 1 to create a new NFT ID   uint256 internal nftCounter; // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.   constructor(     IERC20 _token, // USDC address     IERC20 _sher, // SHER token address     string memory _name, // Token collection name (see ERC-721 docs)     string memory _symbol, // Token collection symbol (see ERC-721 docs)     IStrategyManager _yieldStrategy, // The active yield strategy contract     ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract     address _nonStakersAddress, // The address to which nonstakers payments go     ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract     ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract     uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for   ) ERC721(_name, _symbol) {     if (address(_token) == address(0)) revert ZeroArgument();     if (address(_sher) == address(0)) revert ZeroArgument();     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (_nonStakersAddress == address(0)) revert ZeroArgument();     if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();     if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument(); token = _token; sher = _sher; yieldStrategy = _yieldStrategy; sherDistributionManager = _sherDistributionManager; nonStakersAddress = _nonStakersAddress; sherlockProtocolManager = _sherlockProtocolManager; sherlockClaimManager = _sherlockClaimManager;  // Enabling the first set of staking periods that were provided in constructor args for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {   enableStakingPeriod(_initialstakingPeriods[i]); }  emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy); emit SherDistributionManagerUpdated(   ISherDistributionManager(address(0)),   _sherDistributionManager ); emit NonStakerAddressUpdated(address(0), _nonStakersAddress); emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager); emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);  } //   // View functions   // // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked   /// @notice View the current lockup end timestamp of _tokenID   /// @return Timestamp when NFT position unlocks   function lockupEnd(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return lockupEnd_[_tokenID];  } // Returns the SHER rewards owed to this position   /// @notice View the current SHER reward of _tokenID   /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup   function sherRewards(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return sherRewards_[_tokenID];  } // Returns the tokens (USDC) owed to a position   /// @notice View the current token balance claimable upon reaching end of the lockup   /// @return Amount of tokens assigned to owner when unstaking position   function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent();     // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers     return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;   } // Returns the tokens (USDC) owed to an address   /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup   /// @return Amount of tokens assigned to owner when unstaking all positions   function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {     if (_staker == address(0)) revert ZeroArgument();     uint256 _totalStakeShares = totalStakeShares;     if (_totalStakeShares == 0) return 0;     // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers     return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;   } // Gets the total amount of tokens (USDC) owed to stakers   // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract   /// @notice View the current TVL for all stakers   /// @return Total amount of tokens staked   /// @dev Adds principal + strategy + premiums   /// @dev Will calculate the most up to date value for each piece   function totalTokenBalanceStakers() public view override returns (uint256) {     return       token.balanceOf(address(this)) +       yieldStrategy.balanceOf() +       sherlockProtocolManager.claimablePremiums();   } //   // Gov functions   // // Allows governance to add a new staking period (4 months, etc.)   /// @notice Allows stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already enabled   function enableStakingPeriod(uint256 _period) public override onlyOwner {     if (_period == 0) revert ZeroArgument();     // Revert if staking period is already active     if (stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to true stakingPeriods[_period] = true; emit StakingPeriodEnabled(_period);  } // Allows governance to remove a staking period (4 months, etc.)   /// @notice Disallow stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already disabled   function disableStakingPeriod(uint256 _period) external override onlyOwner {     // Revert if staking period is already inactive     if (!stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to false stakingPeriods[_period] = false; emit StakingPeriodDisabled(_period);  } // Sets a new contract to be the active SHER distribution manager   /// @notice Update SHER distribution manager contract   /// @param _sherDistributionManager New adddress of the manager   function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)     external     override     onlyOwner   {     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument(); emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager); sherDistributionManager = _sherDistributionManager;  } // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)   /// @notice Remove SHER token rewards   function removeSherDistributionManager() external override onlyOwner {     if (address(sherDistributionManager) == address(0)) revert InvalidConditions(); emit SherDistributionManagerUpdated(   sherDistributionManager,   ISherDistributionManager(address(0)) ); delete sherDistributionManager;  } // Sets a new address for nonstakers payments   /// @notice Update address eligble for non staker rewards from protocol premiums   /// @param _nonStakers Address eligble for non staker rewards   function updateNonStakersAddress(address _nonStakers) external override onlyOwner {     if (address(_nonStakers) == address(0)) revert ZeroArgument();     if (nonStakersAddress == _nonStakers) revert InvalidArgument(); emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers); nonStakersAddress = _nonStakers;  } // Sets a new protocol manager contract   /// @notice Transfer protocol manager implementation address   /// @param _protocolManager new implementation address   function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)     external     override     onlyOwner   {     if (address(_protocolManager) == address(0)) revert ZeroArgument();     if (sherlockProtocolManager == _protocolManager) revert InvalidArgument(); emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager); sherlockProtocolManager = _protocolManager;  } // Sets a new claim manager contract   /// @notice Transfer claim manager role to different address   /// @param _claimManager New address of claim manager   function updateSherlockClaimManager(ISherlockClaimManager _claimManager)     external     override     onlyOwner   {     if (address(_claimManager) == address(0)) revert ZeroArgument();     if (sherlockClaimManager == _claimManager) revert InvalidArgument(); emit ClaimManagerUpdated(sherlockClaimManager, _claimManager); sherlockClaimManager = _claimManager;  } // Sets a new yield strategy manager contract   /// @notice Update yield strategy   /// @param _yieldStrategy News address of the strategy   /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure   function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (yieldStrategy == _yieldStrategy) revert InvalidArgument(); // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason. // In case this happens. We still want the yield strategy to be updated. // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again. try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {   emit YieldStrategyUpdateWithdrawAllError(reason); }  emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy); yieldStrategy = _yieldStrategy;  } // Deposits a chosen amount of tokens (USDC) into the active yield strategy   /// @notice Deposit _amount into active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); // Transfers any tokens owed to stakers from the protocol manager contract to this contract first sherlockProtocolManager.claimPremiumsForStakers(); // Transfers the amount of tokens to the yield strategy contract token.safeTransfer(address(yieldStrategy), _amount); // Deposits all tokens in the yield strategy contract into the actual yield strategy yieldStrategy.deposit();  } // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract   /// @notice Withdraw _amount from active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); yieldStrategy.withdraw(_amount);  } // Withdraws all tokens from the yield strategy back into this contract   /// @notice Withdraw all funds from active strategy   /// @dev gov only   function yieldStrategyWithdrawAll() external override onlyOwner {     yieldStrategy.withdrawAll();   } /// @notice Pause external functions in all contracts   /// @dev A manager can be replaced with the new contract in a paused state   /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused   function pause() external onlyOwner {     _pause();     if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();     // sherDistributionManager can be 0, pause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       !Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.pause();     }     if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();     if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();   } /// @notice Unpause external functions in all contracts   /// @dev A manager can be replaced with the new contract in an unpaused state   /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused   function unpause() external onlyOwner {     _unpause();     if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();     // sherDistributionManager can be 0, unpause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.unpause();     }     if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();     if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();   } //   // Access control functions   // /// @notice Account sum of all underlying posiiton shares for _from and _to   /// @dev this enables the tokenBalanceOfAddress to exist   function _beforeTokenTransfer(     address _from,     address _to,     uint256 _tokenID   ) internal override {     uint256 _stakeShares = stakeShares[_tokenID]; if (_from != address(0)) addressShares[_from] -= _stakeShares; if (_to != address(0)) addressShares[_to] += _stakeShares;  } // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)   // This function is called by the Sherlock claim manager contract if a claim is approved   /// @notice Initiate a payout of _amount to _receiver   /// @param _receiver Receiver of payout   /// @param _amount Amount to send   /// @dev only payout manager should call this   /// @dev should pull money out of strategy   function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {     // Can only be called by the Sherlock claim manager contract     if (msg.sender != address(sherlockClaimManager)) revert Unauthorized(); if (_amount != 0) {   // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)   _transferTokensOut(_receiver, _amount); } emit ClaimPayout(_receiver, _amount);  } //   // Non-access control functions   // // Helper function for initial staking and restaking   // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position   /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds   /// @param amount Amount of tokens to stake   /// @param _period Period of time for which funds get locked   /// @param _id ID for this NFT position   /// @param _receiver Address that will be linked to this position   /// @return _sher Amount of SHER tokens awarded to this position after _period ends   /// @dev _period needs to be whitelisted   function _stake(     uint256 _amount,     uint256 _period,     uint256 _id,     address _receiver   ) internal returns (uint256 _sher) {     // Sets the timestamp at which this position can first be unstaked/restaked     lockupEnd[_id] = block.timestamp + _period; if (address(sherDistributionManager) == address(0)) return 0; // Does not allow restaking of 0 tokens if (_amount == 0) return 0;  // Checks this amount of SHER tokens in this contract before we transfer new ones uint256 before = sher.balanceOf(address(this));  // pullReward() calcs then actually transfers the SHER tokens to this contract // in case this call fails, whole (re)staking transaction fails _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);  // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position uint256 actualAmount = sher.balanceOf(address(this)) - before; if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount); // Assigns the newly created SHER tokens to the current stake position if (_sher != 0) sherRewards_[_id] = _sher;  } // Checks to see if the NFT owner is the caller and that the position is unlockable   function verifyUnlockableByOwner(uint256 _id) internal view {     if (ownerOf(_id) != msg.sender) revert Unauthorized();     if (lockupEnd[_id] &gt; block.timestamp) revert InvalidConditions();   } // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner   function sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards[_id];     if (sherReward == 0) return; // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner sher.safeTransfer(_nftOwner, sherReward); // Deletes the SHER reward mapping for this NFT ID delete sherRewards_[_id];  } // Transfers an amount of tokens to the receiver address   // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)   function _transferTokensOut(address _receiver, uint256 _amount) internal {     // Transfers any premiums owed to stakers from the protocol manager to this contract     sherlockProtocolManager.claimPremiumsForStakers(); // The amount of tokens in this contract uint256 mainBalance = token.balanceOf(address(this));  // If the amount to transfer out is still greater than the amount of tokens in this contract, // Withdraw yield strategy tokens to make up the difference if (_amount &gt; mainBalance) {   yieldStrategy.withdraw(_amount - mainBalance); }  token.safeTransfer(_receiver, _amount);  } // Returns the amount of USDC owed to this amount of stakeShares   function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {     // Finds fraction that the given amount of stakeShares represents of the total     // Then multiplies it by the total amount of tokens (USDC) owed to all stakers     return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;   } // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted   // Also burns the requisite amount of shares associated with this NFT position   // Returns the amount of USDC owed to these shares   function _redeemShares(     uint256 _id,     uint256 _stakeShares,     address _receiver   ) internal returns (uint256 _amount) {     // Returns the amount of USDC owed to this amount of stakeShares     _amount = _redeemSharesCalc(_stakeShares);     // Transfers _amount of tokens to _receiver address     if (_amount != 0) _transferTokensOut(_receiver, _amount); // Subtracts this amount of stakeShares from the NFT position stakeShares[_id] -= _stakeShares; // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding totalStakeShares -= _stakeShares;  } // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager   // Restakes an NFT position (_id) for a given period (_period) and   // Sends any previously earned SHER rewards to the _nftOwner address   function _restake(     uint256 _id,     uint256 _period,     address _nftOwner   ) internal returns (uint256 _sher) {     // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner     // NOTE This function deletes the SHER reward mapping for this NFT ID     _sendSherRewardsToOwner(_id, _nftOwner); // tokenBalanceOf() returns the USDC amount owed to this NFT ID // _stake() restakes that amount of USDC for the period inputted // We use the same ID that we just deleted the SHER rewards mapping for // Resets the lockupEnd mapping and SHER token rewards mapping for this ID // Note stakeShares for this position do not change so no need to update _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);  emit Restaked(_id);  } // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)   /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt   /// @param _amount Amount of tokens to stake   /// @param _period Period of time, in seconds, to lockup your funds   /// @param _receiver Address that will receive the NFT representing the position   /// @return _id ID of the position   /// @return _sher Amount of SHER tokens to be released to this ID after _period ends   /// @dev _period needs to be whitelisted   function initialStake(     uint256 _amount,     uint256 _period,     address _receiver   ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {     if (_amount == 0) revert ZeroArgument();     // Makes sure the period is a whitelisted period     if (!stakingPeriods[_period]) revert InvalidArgument();     if (address(_receiver) == address(0)) revert ZeroArgument();     // Adds 1 to the ID of the last NFT created for the new NFT ID     _id = ++nftCounter; // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action) token.safeTransferFrom(msg.sender, address(this), _amount);  uint256 stakeShares_; uint256 totalStakeShares_ = totalStakeShares; // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares if (totalStakeShares_ != 0)   stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);   // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked else stakeShares_ = _amount;  // Assigns this NFT ID the calc'd amount of stake shares above stakeShares[_id] = stakeShares_; // Adds the newly created stake shares to the total amount of stake shares totalStakeShares += stakeShares_;  // Locks up the USDC amount and calcs the SHER token amount to receive on unstake _sher = _stake(_amount, _period, _id, _receiver);  // This is an ERC-721 function that creates an NFT and sends it to the receiver _safeMint(_receiver, _id);  } // This is how a staker unstakes and cashes out on their position   /// @notice Redeem NFT _id and receive _amount of tokens   /// @param _id TokenID of the position   /// @return _amount Amount of tokens (USDC) owed to NFT ID   /// @dev Only the owner of _id will be able to redeem their position   /// @dev The SHER rewards are sent to the NFT owner   /// @dev Can only be called after lockup _period has ended   function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // This is the ERC-721 function to destroy an NFT (with owner's approval) _burn(_id);  // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC owed to these shares _amount = _redeemShares(_id, stakeShares[_id], msg.sender);  // Sends the SHER tokens associated with this NFT ID to the NFT owner _sendSherRewardsToOwner(_id, msg.sender);  // Removes the unlock deadline associated with this NFT delete lockupEnd_[_id];  } // This is how a staker restakes an expired position   /// @notice Owner restakes position with ID: _id for _period seconds   /// @param _id ID of the position   /// @param _period Period of time, in seconds, to lockup your funds   /// @return _sher Amount of SHER tokens to be released to owner address after _period ends   /// @dev Only the owner of _id will be able to restake their position using this call   /// @dev _period needs to be whitelisted   /// @dev Can only be called after lockup _period has ended   function ownerRestake(uint256 _id, uint256 _period)     external     override     whenNotPaused     returns (uint256 _sher)   {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // Checks to make sure the staking period is a whitelisted one if (!stakingPeriods[_period]) revert InvalidArgument();  // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position _sher = _restake(_id, _period, msg.sender);  } // Calcs the reward (in stake shares) an arb would get for restaking a position   // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb   function calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {     // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)     uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME; // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position if (initialArbTime &gt; block.timestamp) return (0, false);  // The max rewards (as a % of the position's shares) for the arb are available at this timestamp uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;  // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100% uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;  // Scaled by 10**18 // Represents the max amount of stake shares that an arb could get from restaking this position uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];  // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled return (   ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,   true );  } /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position   /// @return profit How much profit an arb would make in USDC   /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)   function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {     // Returns the stake shares that an arb would get, and whether the position can currently be arbed     // profit variable is used to store the amount of shares     (profit, able) = _calcSharesForArbRestake(_id);     // Calculates the tokens (USDC) represented by that amount of stake shares     // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit     profit = _redeemSharesCalc(profit);   } /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)   /// @param _id ID of the position   /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup   /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function   /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)   /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)   /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)   function arbRestake(uint256 _id)     external     override     whenNotPaused     returns (uint256 _sher, uint256 _arbReward)   {     address nftOwner = ownerOf(_id); // Returns the stake shares that an arb would get, and whether the position can currently be arbed (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id); // Revert if not able to be arbed if (!able) revert InvalidConditions();  // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC paid to the arbitrager _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);  // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months) // Sends previously earned SHER rewards to the NFT owner address _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);  emit ArbRestaked(_id, _arbReward);  } } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-25-08 10:37:32 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@openzeppelin/contracts/token/ERC721/ERC721.sol'; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol'; import '@openzeppelin/contracts/security/Pausable.sol'; import './interfaces/ISherlock.sol'; /// @title Sherlock core interface for stakers /// @author Evert Kors // This is the contract that manages staking actions contract Sherlock is ISherlock, ERC721, Ownable, Pausable {   using SafeERC20 for IERC20; // The initial period for a staker to restake/withdraw without being auto-restaked   uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks; // The period during which the reward for restaking an account (after the inital period) grows   uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks; // Anyone who gets auto-restaked is restaked for this period (3 months)   uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks; // The percentage of someone's stake that can be paid to an arb for restaking   uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20% // USDC address   IERC20 public immutable token; // SHER token address   IERC20 public immutable sher; // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not   mapping(uint256 =&gt; bool) public override stakingPeriods; // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked   mapping(uint256 =&gt; uint256) internal lockupEnd_; // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position   mapping(uint256 =&gt; uint256) internal sherRewards_; // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)   mapping(uint256 =&gt; uint256) internal stakeShares; // Key is account, value is the sum of underlying shares of all the NFTs the account owns.   mapping(address =&gt; uint256) internal addressShares; // Total amount of shares that have been issued to all NFT positions   uint256 internal totalStakeShares; // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)   IStrategyManager public override yieldStrategy; // Instances of relevant Sherlock contracts   ISherDistributionManager public override sherDistributionManager;   ISherlockProtocolManager public override sherlockProtocolManager;   ISherlockClaimManager public override sherlockClaimManager; // Address to which nonstaker payments are made   // This will start out as a multi-sig address, then become a contract address later   address public override nonStakersAddress; // Stores the ID of the most recently created NFT   // This variable is incremented by 1 to create a new NFT ID   uint256 internal nftCounter; // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.   constructor(     IERC20 _token, // USDC address     IERC20 _sher, // SHER token address     string memory _name, // Token collection name (see ERC-721 docs)     string memory _symbol, // Token collection symbol (see ERC-721 docs)     IStrategyManager _yieldStrategy, // The active yield strategy contract     ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract     address _nonStakersAddress, // The address to which nonstakers payments go     ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract     ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract     uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for   ) ERC721(_name, _symbol) {     if (address(_token) == address(0)) revert ZeroArgument();     if (address(_sher) == address(0)) revert ZeroArgument();     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (_nonStakersAddress == address(0)) revert ZeroArgument();     if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();     if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument(); token = _token; sher = _sher; yieldStrategy = _yieldStrategy; sherDistributionManager = _sherDistributionManager; nonStakersAddress = _nonStakersAddress; sherlockProtocolManager = _sherlockProtocolManager; sherlockClaimManager = _sherlockClaimManager;  // Enabling the first set of staking periods that were provided in constructor args for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {   enableStakingPeriod(_initialstakingPeriods[i]); }  emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy); emit SherDistributionManagerUpdated(   ISherDistributionManager(address(0)),   _sherDistributionManager ); emit NonStakerAddressUpdated(address(0), _nonStakersAddress); emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager); emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);  } //   // View functions   // // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked   /// @notice View the current lockup end timestamp of _tokenID   /// @return Timestamp when NFT position unlocks   function lockupEnd(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return lockupEnd_[_tokenID];  } // Returns the SHER rewards owed to this position   /// @notice View the current SHER reward of _tokenID   /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup   function sherRewards(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return sherRewards_[_tokenID];  } // Returns the tokens (USDC) owed to a position   /// @notice View the current token balance claimable upon reaching end of the lockup   /// @return Amount of tokens assigned to owner when unstaking position   function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent();     // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers     return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;   } // Returns the tokens (USDC) owed to an address   /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup   /// @return Amount of tokens assigned to owner when unstaking all positions   function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {     if (_staker == address(0)) revert ZeroArgument();     uint256 _totalStakeShares = totalStakeShares;     if (_totalStakeShares == 0) return 0;     // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers     return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;   } // Gets the total amount of tokens (USDC) owed to stakers   // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract   /// @notice View the current TVL for all stakers   /// @return Total amount of tokens staked   /// @dev Adds principal + strategy + premiums   /// @dev Will calculate the most up to date value for each piece   function totalTokenBalanceStakers() public view override returns (uint256) {     return       token.balanceOf(address(this)) +       yieldStrategy.balanceOf() +       sherlockProtocolManager.claimablePremiums();   } //   // Gov functions   // // Allows governance to add a new staking period (4 months, etc.)   /// @notice Allows stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already enabled   function enableStakingPeriod(uint256 _period) public override onlyOwner {     if (_period == 0) revert ZeroArgument();     // Revert if staking period is already active     if (stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to true stakingPeriods[_period] = true; emit StakingPeriodEnabled(_period);  } // Allows governance to remove a staking period (4 months, etc.)   /// @notice Disallow stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already disabled   function disableStakingPeriod(uint256 _period) external override onlyOwner {     // Revert if staking period is already inactive     if (!stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to false stakingPeriods[_period] = false; emit StakingPeriodDisabled(_period);  } // Sets a new contract to be the active SHER distribution manager   /// @notice Update SHER distribution manager contract   /// @param _sherDistributionManager New adddress of the manager   function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)     external     override     onlyOwner   {     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument(); emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager); sherDistributionManager = _sherDistributionManager;  } // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)   /// @notice Remove SHER token rewards   function removeSherDistributionManager() external override onlyOwner {     if (address(sherDistributionManager) == address(0)) revert InvalidConditions(); emit SherDistributionManagerUpdated(   sherDistributionManager,   ISherDistributionManager(address(0)) ); delete sherDistributionManager;  } // Sets a new address for nonstakers payments   /// @notice Update address eligble for non staker rewards from protocol premiums   /// @param _nonStakers Address eligble for non staker rewards   function updateNonStakersAddress(address _nonStakers) external override onlyOwner {     if (address(_nonStakers) == address(0)) revert ZeroArgument();     if (nonStakersAddress == _nonStakers) revert InvalidArgument(); emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers); nonStakersAddress = _nonStakers;  } // Sets a new protocol manager contract   /// @notice Transfer protocol manager implementation address   /// @param _protocolManager new implementation address   function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)     external     override     onlyOwner   {     if (address(_protocolManager) == address(0)) revert ZeroArgument();     if (sherlockProtocolManager == _protocolManager) revert InvalidArgument(); emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager); sherlockProtocolManager = _protocolManager;  } // Sets a new claim manager contract   /// @notice Transfer claim manager role to different address   /// @param _claimManager New address of claim manager   function updateSherlockClaimManager(ISherlockClaimManager _claimManager)     external     override     onlyOwner   {     if (address(_claimManager) == address(0)) revert ZeroArgument();     if (sherlockClaimManager == _claimManager) revert InvalidArgument(); emit ClaimManagerUpdated(sherlockClaimManager, _claimManager); sherlockClaimManager = _claimManager;  } // Sets a new yield strategy manager contract   /// @notice Update yield strategy   /// @param _yieldStrategy News address of the strategy   /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure   function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (yieldStrategy == _yieldStrategy) revert InvalidArgument(); // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason. // In case this happens. We still want the yield strategy to be updated. // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again. try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {   emit YieldStrategyUpdateWithdrawAllError(reason); }  emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy); yieldStrategy = _yieldStrategy;  } // Deposits a chosen amount of tokens (USDC) into the active yield strategy   /// @notice Deposit _amount into active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); // Transfers any tokens owed to stakers from the protocol manager contract to this contract first sherlockProtocolManager.claimPremiumsForStakers(); // Transfers the amount of tokens to the yield strategy contract token.safeTransfer(address(yieldStrategy), _amount); // Deposits all tokens in the yield strategy contract into the actual yield strategy yieldStrategy.deposit();  } // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract   /// @notice Withdraw _amount from active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); yieldStrategy.withdraw(_amount);  } // Withdraws all tokens from the yield strategy back into this contract   /// @notice Withdraw all funds from active strategy   /// @dev gov only   function yieldStrategyWithdrawAll() external override onlyOwner {     yieldStrategy.withdrawAll();   } /// @notice Pause external functions in all contracts   /// @dev A manager can be replaced with the new contract in a paused state   /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused   function pause() external onlyOwner {     _pause();     if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();     // sherDistributionManager can be 0, pause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       !Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.pause();     }     if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();     if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();   } /// @notice Unpause external functions in all contracts   /// @dev A manager can be replaced with the new contract in an unpaused state   /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused   function unpause() external onlyOwner {     _unpause();     if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();     // sherDistributionManager can be 0, unpause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.unpause();     }     if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();     if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();   } //   // Access control functions   // /// @notice Account sum of all underlying posiiton shares for _from and _to   /// @dev this enables the tokenBalanceOfAddress to exist   function _beforeTokenTransfer(     address _from,     address _to,     uint256 _tokenID   ) internal override {     uint256 _stakeShares = stakeShares[_tokenID]; if (_from != address(0)) addressShares[_from] -= _stakeShares; if (_to != address(0)) addressShares[_to] += _stakeShares;  } // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)   // This function is called by the Sherlock claim manager contract if a claim is approved   /// @notice Initiate a payout of _amount to _receiver   /// @param _receiver Receiver of payout   /// @param _amount Amount to send   /// @dev only payout manager should call this   /// @dev should pull money out of strategy   function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {     // Can only be called by the Sherlock claim manager contract     if (msg.sender != address(sherlockClaimManager)) revert Unauthorized(); if (_amount != 0) {   // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)   _transferTokensOut(_receiver, _amount); } emit ClaimPayout(_receiver, _amount);  } //   // Non-access control functions   // // Helper function for initial staking and restaking   // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position   /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds   /// @param amount Amount of tokens to stake   /// @param _period Period of time for which funds get locked   /// @param _id ID for this NFT position   /// @param _receiver Address that will be linked to this position   /// @return _sher Amount of SHER tokens awarded to this position after _period ends   /// @dev _period needs to be whitelisted   function _stake(     uint256 _amount,     uint256 _period,     uint256 _id,     address _receiver   ) internal returns (uint256 _sher) {     // Sets the timestamp at which this position can first be unstaked/restaked     lockupEnd[_id] = block.timestamp + _period; if (address(sherDistributionManager) == address(0)) return 0; // Does not allow restaking of 0 tokens if (_amount == 0) return 0;  // Checks this amount of SHER tokens in this contract before we transfer new ones uint256 before = sher.balanceOf(address(this));  // pullReward() calcs then actually transfers the SHER tokens to this contract // in case this call fails, whole (re)staking transaction fails _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);  // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position uint256 actualAmount = sher.balanceOf(address(this)) - before; if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount); // Assigns the newly created SHER tokens to the current stake position if (_sher != 0) sherRewards_[_id] = _sher;  } // Checks to see if the NFT owner is the caller and that the position is unlockable   function verifyUnlockableByOwner(uint256 _id) internal view {     if (ownerOf(_id) != msg.sender) revert Unauthorized();     if (lockupEnd[_id] &gt; block.timestamp) revert InvalidConditions();   } // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner   function sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards[_id];     if (sherReward == 0) return; // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner sher.safeTransfer(_nftOwner, sherReward); // Deletes the SHER reward mapping for this NFT ID delete sherRewards_[_id];  } // Transfers an amount of tokens to the receiver address   // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)   function _transferTokensOut(address _receiver, uint256 _amount) internal {     // Transfers any premiums owed to stakers from the protocol manager to this contract     sherlockProtocolManager.claimPremiumsForStakers(); // The amount of tokens in this contract uint256 mainBalance = token.balanceOf(address(this));  // If the amount to transfer out is still greater than the amount of tokens in this contract, // Withdraw yield strategy tokens to make up the difference if (_amount &gt; mainBalance) {   yieldStrategy.withdraw(_amount - mainBalance); }  token.safeTransfer(_receiver, _amount);  } // Returns the amount of USDC owed to this amount of stakeShares   function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {     // Finds fraction that the given amount of stakeShares represents of the total     // Then multiplies it by the total amount of tokens (USDC) owed to all stakers     return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;   } // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted   // Also burns the requisite amount of shares associated with this NFT position   // Returns the amount of USDC owed to these shares   function _redeemShares(     uint256 _id,     uint256 _stakeShares,     address _receiver   ) internal returns (uint256 _amount) {     // Returns the amount of USDC owed to this amount of stakeShares     _amount = _redeemSharesCalc(_stakeShares);     // Transfers _amount of tokens to _receiver address     if (_amount != 0) _transferTokensOut(_receiver, _amount); // Subtracts this amount of stakeShares from the NFT position stakeShares[_id] -= _stakeShares; // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding totalStakeShares -= _stakeShares;  } // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager   // Restakes an NFT position (_id) for a given period (_period) and   // Sends any previously earned SHER rewards to the _nftOwner address   function _restake(     uint256 _id,     uint256 _period,     address _nftOwner   ) internal returns (uint256 _sher) {     // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner     // NOTE This function deletes the SHER reward mapping for this NFT ID     _sendSherRewardsToOwner(_id, _nftOwner); // tokenBalanceOf() returns the USDC amount owed to this NFT ID // _stake() restakes that amount of USDC for the period inputted // We use the same ID that we just deleted the SHER rewards mapping for // Resets the lockupEnd mapping and SHER token rewards mapping for this ID // Note stakeShares for this position do not change so no need to update _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);  emit Restaked(_id);  } // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)   /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt   /// @param _amount Amount of tokens to stake   /// @param _period Period of time, in seconds, to lockup your funds   /// @param _receiver Address that will receive the NFT representing the position   /// @return _id ID of the position   /// @return _sher Amount of SHER tokens to be released to this ID after _period ends   /// @dev _period needs to be whitelisted   function initialStake(     uint256 _amount,     uint256 _period,     address _receiver   ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {     if (_amount == 0) revert ZeroArgument();     // Makes sure the period is a whitelisted period     if (!stakingPeriods[_period]) revert InvalidArgument();     if (address(_receiver) == address(0)) revert ZeroArgument();     // Adds 1 to the ID of the last NFT created for the new NFT ID     _id = ++nftCounter; // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action) token.safeTransferFrom(msg.sender, address(this), _amount);  uint256 stakeShares_; uint256 totalStakeShares_ = totalStakeShares; // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares if (totalStakeShares_ != 0)   stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);   // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked else stakeShares_ = _amount;  // Assigns this NFT ID the calc'd amount of stake shares above stakeShares[_id] = stakeShares_; // Adds the newly created stake shares to the total amount of stake shares totalStakeShares += stakeShares_;  // Locks up the USDC amount and calcs the SHER token amount to receive on unstake _sher = _stake(_amount, _period, _id, _receiver);  // This is an ERC-721 function that creates an NFT and sends it to the receiver _safeMint(_receiver, _id);  } // This is how a staker unstakes and cashes out on their position   /// @notice Redeem NFT _id and receive _amount of tokens   /// @param _id TokenID of the position   /// @return _amount Amount of tokens (USDC) owed to NFT ID   /// @dev Only the owner of _id will be able to redeem their position   /// @dev The SHER rewards are sent to the NFT owner   /// @dev Can only be called after lockup _period has ended   function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // This is the ERC-721 function to destroy an NFT (with owner's approval) _burn(_id);  // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC owed to these shares _amount = _redeemShares(_id, stakeShares[_id], msg.sender);  // Sends the SHER tokens associated with this NFT ID to the NFT owner _sendSherRewardsToOwner(_id, msg.sender);  // Removes the unlock deadline associated with this NFT delete lockupEnd_[_id];  } // This is how a staker restakes an expired position   /// @notice Owner restakes position with ID: _id for _period seconds   /// @param _id ID of the position   /// @param _period Period of time, in seconds, to lockup your funds   /// @return _sher Amount of SHER tokens to be released to owner address after _period ends   /// @dev Only the owner of _id will be able to restake their position using this call   /// @dev _period needs to be whitelisted   /// @dev Can only be called after lockup _period has ended   function ownerRestake(uint256 _id, uint256 _period)     external     override     whenNotPaused     returns (uint256 _sher)   {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // Checks to make sure the staking period is a whitelisted one if (!stakingPeriods[_period]) revert InvalidArgument();  // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position _sher = _restake(_id, _period, msg.sender);  } // Calcs the reward (in stake shares) an arb would get for restaking a position   // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb   function calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {     // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)     uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME; // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position if (initialArbTime &gt; block.timestamp) return (0, false);  // The max rewards (as a % of the position's shares) for the arb are available at this timestamp uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;  // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100% uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;  // Scaled by 10**18 // Represents the max amount of stake shares that an arb could get from restaking this position uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];  // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled return (   ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,   true );  } /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position   /// @return profit How much profit an arb would make in USDC   /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)   function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {     // Returns the stake shares that an arb would get, and whether the position can currently be arbed     // profit variable is used to store the amount of shares     (profit, able) = _calcSharesForArbRestake(_id);     // Calculates the tokens (USDC) represented by that amount of stake shares     // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit     profit = _redeemSharesCalc(profit);   } /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)   /// @param _id ID of the position   /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup   /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function   /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)   /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)   /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)   function arbRestake(uint256 _id)     external     override     whenNotPaused     returns (uint256 _sher, uint256 _arbReward)   {     address nftOwner = ownerOf(_id); // Returns the stake shares that an arb would get, and whether the position can currently be arbed (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id); // Revert if not able to be arbed if (!able) revert InvalidConditions();  // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC paid to the arbitrager _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);  // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months) // Sends previously earned SHER rewards to the NFT owner address _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);  emit ArbRestaked(_id, _arbReward);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-25-08 10:37:32 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';

import './interfaces/ISherlock.sol';

/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions

contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;

  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;

  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;

  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;

  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%

  // USDC address
  IERC20 public immutable token;

  // SHER token address
  IERC20 public immutable sher;

  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;

  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;

  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;

  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;

  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;

  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;

  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;

  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;

  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;

  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;

  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();

    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;

    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }

    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }

  //
  // View functions
  //

  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return lockupEnd_[_tokenID];
  }

  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return sherRewards_[_tokenID];
  }

  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }

  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }

  //
  // Gov functions
  //

  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }

  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }

  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();

    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }

  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();

    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }

  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();

    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }

  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();

    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }

  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();

    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }

  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();

    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }

    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }

  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }

  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    yieldStrategy.withdraw(_amount);
  }

  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }

  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }

  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }

  //
  // Access control functions
  //

  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];

    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }

  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();

    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }

  //
  // Non-access control functions
  //

  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;

    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;

    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));

    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);

    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }

  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }

  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;

    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }

  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();

    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));

    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }

    token.safeTransfer(_receiver, _amount);
  }

  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);

    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }

  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);

    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);

    emit Restaked(_id);
  }

  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;

    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);

    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;

    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;

    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);

    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }

  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);

    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);

    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);

    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }

  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }

  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;

    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);

    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;

    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;

    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];

    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }

  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }

  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);

    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();

    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);

    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);

    emit ArbRestaked(_id, _arbReward);
  }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-25-08 10:37:40 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-25-08 10:37:40 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 7841
completion_tokens: 745
total_tokens: 8586
cost: $-1.000000


[2024-25-08 10:37:40 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';

import './interfaces/ISherlock.sol';

/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions

contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;

  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;

  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;

  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;

  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%

  // USDC address
  IERC20 public immutable token;

  // SHER token address
  IERC20 public immutable sher;

  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;

  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;

  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;

  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;

  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;

  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;

  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;

  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;

  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;

  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;

  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();

    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;

    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }

    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }

  //
  // View functions
  //

  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return lockupEnd_[_tokenID];
  }

  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return sherRewards_[_tokenID];
  }

  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }

  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }

  //
  // Gov functions
  //

  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }

  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }

  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();

    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }

  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();

    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }

  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();

    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }

  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();

    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }

  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();

    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }

  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();

    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }

    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }

  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }

  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    yieldStrategy.withdraw(_amount);
  }

  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }

  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }

  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }

  //
  // Access control functions
  //

  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];

    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }

  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();

    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }

  //
  // Non-access control functions
  //

  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;

    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;

    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));

    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);

    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }

  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }

  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;

    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }

  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();

    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));

    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }

    token.safeTransfer(_receiver, _amount);
  }

  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);

    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }

  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);

    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);

    emit Restaked(_id);
  }

  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;

    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);

    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;

    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;

    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);

    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }

  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);

    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);

    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);

    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }

  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }

  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;

    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);

    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;

    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;

    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];

    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }

  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }

  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);

    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();

    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);

    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);

    emit ArbRestaked(_id, _arbReward);
  }
}
.]

### Summary of Security Vulnerabilities in the Sherlock Smart Contract

1. **Reentrancy Vulnerability**: 
   - The contract does not implement a reentrancy guard on functions that transfer tokens, such as `_transferTokensOut`. This could allow an attacker to re-enter the function before the state is updated, potentially leading to unexpected behavior or loss of funds.

2. **Lack of Input Validation**: 
   - Several functions do not adequately validate inputs. For instance, in functions like `initialStake`, `_stake`, and `ownerRestake`, the contract assumes that the provided `_amount` and `_period` are valid without thorough checks beyond zero checks. This could lead to unintended consequences if invalid values are passed.

3. **Potential for Integer Overflow/Underflow**: 
   - Although Solidity 0.8.x has built-in overflow/underflow protection, there are still areas where calculations could lead to unexpected results if not handled properly, especially in arithmetic operations involving shares and balances.

4. **Access Control Issues**: 
   - The contract relies heavily on the `onlyOwner` modifier for critical functions. If the owners private key is compromised, an attacker could gain control over the contract and execute malicious actions.

5. **Gas Limit Issues**: 
   - Functions that involve loops, such as enabling multiple staking periods in the constructor, could run into gas limit issues if a large number of periods are provided. This could lead to failed transactions.

6. **Token Transfer Failures**: 
   - The contract does not handle scenarios where token transfers fail. For instance, in the `_transferTokensOut` function, if the token transfer fails, the contract does not revert, which could leave the contract in an inconsistent state.

7. **Pausable Functionality**: 
   - While the contract implements a pausable mechanism, it does not ensure that all critical functions are paused appropriately. If the contract is paused, it should prevent all state-changing functions from executing.

8. **Unrestricted Functionality**: 
   - Certain functions, such as `yieldStrategyWithdraw` and `yieldStrategyWithdrawAll`, can be called by the owner without any restrictions on the amount withdrawn. This could lead to potential abuse if the owner decides to withdraw all funds.

### Comprehensive Analysis Report

The Sherlock smart contract presents a robust framework for managing staking and rewards through NFTs. However, several security vulnerabilities have been identified that could potentially compromise the integrity and safety of the contract. 

1. **Reentrancy attacks** pose a significant risk, especially in functions that involve transferring tokens. Implementing a reentrancy guard would mitigate this risk effectively.

2. **Input validation** is crucial for ensuring that only valid data is processed. Enhancing the validation checks in critical functions will help prevent unintended behaviors.

3. **Access control** mechanisms should be reviewed to ensure that only authorized entities can execute sensitive functions. Consider implementing multi-signature wallets or time-locks for critical operations.

4. **Gas limit issues** should be addressed by optimizing loops and ensuring that functions can handle a large number of inputs without exceeding gas limits.

5. **Error handling** for token transfers must be improved to ensure that the contract can revert to a safe state in case of failures.

6. The **pausable functionality** should be enforced across all state-changing functions to ensure that the contract can be safely paused in case of emergencies.

In conclusion, while the Sherlock contract is well-structured, addressing the identified vulnerabilities is essential to enhance its security and reliability. A thorough audit and implementation of best practices in smart contract development will help safeguard against potential attacks and ensure the contract operates as intended.

[2024-25-08 10:37:40 INFO] **[Seminar Conclusion]**:

 ### Summary of Security Vulnerabilities in the Sherlock Smart Contract

1. **Reentrancy Vulnerability**: 
   - The contract does not implement a reentrancy guard on functions that transfer tokens, such as `_transferTokensOut`. This could allow an attacker to re-enter the function before the state is updated, potentially leading to unexpected behavior or loss of funds.

2. **Lack of Input Validation**: 
   - Several functions do not adequately validate inputs. For instance, in functions like `initialStake`, `_stake`, and `ownerRestake`, the contract assumes that the provided `_amount` and `_period` are valid without thorough checks beyond zero checks. This could lead to unintended consequences if invalid values are passed.

3. **Potential for Integer Overflow/Underflow**: 
   - Although Solidity 0.8.x has built-in overflow/underflow protection, there are still areas where calculations could lead to unexpected results if not handled properly, especially in arithmetic operations involving shares and balances.

4. **Access Control Issues**: 
   - The contract relies heavily on the `onlyOwner` modifier for critical functions. If the owners private key is compromised, an attacker could gain control over the contract and execute malicious actions.

5. **Gas Limit Issues**: 
   - Functions that involve loops, such as enabling multiple staking periods in the constructor, could run into gas limit issues if a large number of periods are provided. This could lead to failed transactions.

6. **Token Transfer Failures**: 
   - The contract does not handle scenarios where token transfers fail. For instance, in the `_transferTokensOut` function, if the token transfer fails, the contract does not revert, which could leave the contract in an inconsistent state.

7. **Pausable Functionality**: 
   - While the contract implements a pausable mechanism, it does not ensure that all critical functions are paused appropriately. If the contract is paused, it should prevent all state-changing functions from executing.

8. **Unrestricted Functionality**: 
   - Certain functions, such as `yieldStrategyWithdraw` and `yieldStrategyWithdrawAll`, can be called by the owner without any restrictions on the amount withdrawn. This could lead to potential abuse if the owner decides to withdraw all funds.

### Comprehensive Analysis Report

The Sherlock smart contract presents a robust framework for managing staking and rewards through NFTs. However, several security vulnerabilities have been identified that could potentially compromise the integrity and safety of the contract. 

1. **Reentrancy attacks** pose a significant risk, especially in functions that involve transferring tokens. Implementing a reentrancy guard would mitigate this risk effectively.

2. **Input validation** is crucial for ensuring that only valid data is processed. Enhancing the validation checks in critical functions will help prevent unintended behaviors.

3. **Access control** mechanisms should be reviewed to ensure that only authorized entities can execute sensitive functions. Consider implementing multi-signature wallets or time-locks for critical operations.

4. **Gas limit issues** should be addressed by optimizing loops and ensuring that functions can handle a large number of inputs without exceeding gas limits.

5. **Error handling** for token transfers must be improved to ensure that the contract can revert to a safe state in case of failures.

6. The **pausable functionality** should be enforced across all state-changing functions to ensure that the contract can be safely paused in case of emergencies.

In conclusion, while the Sherlock contract is well-structured, addressing the identified vulnerabilities is essential to enhance its security and reliability. A thorough audit and implementation of best practices in smart contract development will help safeguard against potential attacks and ensure the contract operates as intended.

[2024-25-08 10:37:40 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-25-08 10:37:40 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@openzeppelin/contracts/token/ERC721/ERC721.sol'; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol'; import '@openzeppelin/contracts/security/Pausable.sol'; import './interfaces/ISherlock.sol'; /// @title Sherlock core interface for stakers /// @author Evert Kors // This is the contract that manages staking actions contract Sherlock is ISherlock, ERC721, Ownable, Pausable {   using SafeERC20 for IERC20; // The initial period for a staker to restake/withdraw without being auto-restaked   uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks; // The period during which the reward for restaking an account (after the inital period) grows   uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks; // Anyone who gets auto-restaked is restaked for this period (3 months)   uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks; // The percentage of someone's stake that can be paid to an arb for restaking   uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20% // USDC address   IERC20 public immutable token; // SHER token address   IERC20 public immutable sher; // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not   mapping(uint256 =&gt; bool) public override stakingPeriods; // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked   mapping(uint256 =&gt; uint256) internal lockupEnd_; // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position   mapping(uint256 =&gt; uint256) internal sherRewards_; // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)   mapping(uint256 =&gt; uint256) internal stakeShares; // Key is account, value is the sum of underlying shares of all the NFTs the account owns.   mapping(address =&gt; uint256) internal addressShares; // Total amount of shares that have been issued to all NFT positions   uint256 internal totalStakeShares; // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)   IStrategyManager public override yieldStrategy; // Instances of relevant Sherlock contracts   ISherDistributionManager public override sherDistributionManager;   ISherlockProtocolManager public override sherlockProtocolManager;   ISherlockClaimManager public override sherlockClaimManager; // Address to which nonstaker payments are made   // This will start out as a multi-sig address, then become a contract address later   address public override nonStakersAddress; // Stores the ID of the most recently created NFT   // This variable is incremented by 1 to create a new NFT ID   uint256 internal nftCounter; // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.   constructor(     IERC20 _token, // USDC address     IERC20 _sher, // SHER token address     string memory _name, // Token collection name (see ERC-721 docs)     string memory _symbol, // Token collection symbol (see ERC-721 docs)     IStrategyManager _yieldStrategy, // The active yield strategy contract     ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract     address _nonStakersAddress, // The address to which nonstakers payments go     ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract     ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract     uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for   ) ERC721(_name, _symbol) {     if (address(_token) == address(0)) revert ZeroArgument();     if (address(_sher) == address(0)) revert ZeroArgument();     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (_nonStakersAddress == address(0)) revert ZeroArgument();     if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();     if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument(); token = _token; sher = _sher; yieldStrategy = _yieldStrategy; sherDistributionManager = _sherDistributionManager; nonStakersAddress = _nonStakersAddress; sherlockProtocolManager = _sherlockProtocolManager; sherlockClaimManager = _sherlockClaimManager;  // Enabling the first set of staking periods that were provided in constructor args for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {   enableStakingPeriod(_initialstakingPeriods[i]); }  emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy); emit SherDistributionManagerUpdated(   ISherDistributionManager(address(0)),   _sherDistributionManager ); emit NonStakerAddressUpdated(address(0), _nonStakersAddress); emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager); emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);  } //   // View functions   // // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked   /// @notice View the current lockup end timestamp of _tokenID   /// @return Timestamp when NFT position unlocks   function lockupEnd(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return lockupEnd_[_tokenID];  } // Returns the SHER rewards owed to this position   /// @notice View the current SHER reward of _tokenID   /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup   function sherRewards(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return sherRewards_[_tokenID];  } // Returns the tokens (USDC) owed to a position   /// @notice View the current token balance claimable upon reaching end of the lockup   /// @return Amount of tokens assigned to owner when unstaking position   function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent();     // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers     return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;   } // Returns the tokens (USDC) owed to an address   /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup   /// @return Amount of tokens assigned to owner when unstaking all positions   function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {     if (_staker == address(0)) revert ZeroArgument();     uint256 _totalStakeShares = totalStakeShares;     if (_totalStakeShares == 0) return 0;     // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers     return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;   } // Gets the total amount of tokens (USDC) owed to stakers   // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract   /// @notice View the current TVL for all stakers   /// @return Total amount of tokens staked   /// @dev Adds principal + strategy + premiums   /// @dev Will calculate the most up to date value for each piece   function totalTokenBalanceStakers() public view override returns (uint256) {     return       token.balanceOf(address(this)) +       yieldStrategy.balanceOf() +       sherlockProtocolManager.claimablePremiums();   } //   // Gov functions   // // Allows governance to add a new staking period (4 months, etc.)   /// @notice Allows stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already enabled   function enableStakingPeriod(uint256 _period) public override onlyOwner {     if (_period == 0) revert ZeroArgument();     // Revert if staking period is already active     if (stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to true stakingPeriods[_period] = true; emit StakingPeriodEnabled(_period);  } // Allows governance to remove a staking period (4 months, etc.)   /// @notice Disallow stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already disabled   function disableStakingPeriod(uint256 _period) external override onlyOwner {     // Revert if staking period is already inactive     if (!stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to false stakingPeriods[_period] = false; emit StakingPeriodDisabled(_period);  } // Sets a new contract to be the active SHER distribution manager   /// @notice Update SHER distribution manager contract   /// @param _sherDistributionManager New adddress of the manager   function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)     external     override     onlyOwner   {     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument(); emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager); sherDistributionManager = _sherDistributionManager;  } // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)   /// @notice Remove SHER token rewards   function removeSherDistributionManager() external override onlyOwner {     if (address(sherDistributionManager) == address(0)) revert InvalidConditions(); emit SherDistributionManagerUpdated(   sherDistributionManager,   ISherDistributionManager(address(0)) ); delete sherDistributionManager;  } // Sets a new address for nonstakers payments   /// @notice Update address eligble for non staker rewards from protocol premiums   /// @param _nonStakers Address eligble for non staker rewards   function updateNonStakersAddress(address _nonStakers) external override onlyOwner {     if (address(_nonStakers) == address(0)) revert ZeroArgument();     if (nonStakersAddress == _nonStakers) revert InvalidArgument(); emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers); nonStakersAddress = _nonStakers;  } // Sets a new protocol manager contract   /// @notice Transfer protocol manager implementation address   /// @param _protocolManager new implementation address   function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)     external     override     onlyOwner   {     if (address(_protocolManager) == address(0)) revert ZeroArgument();     if (sherlockProtocolManager == _protocolManager) revert InvalidArgument(); emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager); sherlockProtocolManager = _protocolManager;  } // Sets a new claim manager contract   /// @notice Transfer claim manager role to different address   /// @param _claimManager New address of claim manager   function updateSherlockClaimManager(ISherlockClaimManager _claimManager)     external     override     onlyOwner   {     if (address(_claimManager) == address(0)) revert ZeroArgument();     if (sherlockClaimManager == _claimManager) revert InvalidArgument(); emit ClaimManagerUpdated(sherlockClaimManager, _claimManager); sherlockClaimManager = _claimManager;  } // Sets a new yield strategy manager contract   /// @notice Update yield strategy   /// @param _yieldStrategy News address of the strategy   /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure   function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (yieldStrategy == _yieldStrategy) revert InvalidArgument(); // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason. // In case this happens. We still want the yield strategy to be updated. // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again. try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {   emit YieldStrategyUpdateWithdrawAllError(reason); }  emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy); yieldStrategy = _yieldStrategy;  } // Deposits a chosen amount of tokens (USDC) into the active yield strategy   /// @notice Deposit _amount into active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); // Transfers any tokens owed to stakers from the protocol manager contract to this contract first sherlockProtocolManager.claimPremiumsForStakers(); // Transfers the amount of tokens to the yield strategy contract token.safeTransfer(address(yieldStrategy), _amount); // Deposits all tokens in the yield strategy contract into the actual yield strategy yieldStrategy.deposit();  } // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract   /// @notice Withdraw _amount from active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); yieldStrategy.withdraw(_amount);  } // Withdraws all tokens from the yield strategy back into this contract   /// @notice Withdraw all funds from active strategy   /// @dev gov only   function yieldStrategyWithdrawAll() external override onlyOwner {     yieldStrategy.withdrawAll();   } /// @notice Pause external functions in all contracts   /// @dev A manager can be replaced with the new contract in a paused state   /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused   function pause() external onlyOwner {     _pause();     if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();     // sherDistributionManager can be 0, pause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       !Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.pause();     }     if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();     if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();   } /// @notice Unpause external functions in all contracts   /// @dev A manager can be replaced with the new contract in an unpaused state   /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused   function unpause() external onlyOwner {     _unpause();     if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();     // sherDistributionManager can be 0, unpause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.unpause();     }     if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();     if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();   } //   // Access control functions   // /// @notice Account sum of all underlying posiiton shares for _from and _to   /// @dev this enables the tokenBalanceOfAddress to exist   function _beforeTokenTransfer(     address _from,     address _to,     uint256 _tokenID   ) internal override {     uint256 _stakeShares = stakeShares[_tokenID]; if (_from != address(0)) addressShares[_from] -= _stakeShares; if (_to != address(0)) addressShares[_to] += _stakeShares;  } // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)   // This function is called by the Sherlock claim manager contract if a claim is approved   /// @notice Initiate a payout of _amount to _receiver   /// @param _receiver Receiver of payout   /// @param _amount Amount to send   /// @dev only payout manager should call this   /// @dev should pull money out of strategy   function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {     // Can only be called by the Sherlock claim manager contract     if (msg.sender != address(sherlockClaimManager)) revert Unauthorized(); if (_amount != 0) {   // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)   _transferTokensOut(_receiver, _amount); } emit ClaimPayout(_receiver, _amount);  } //   // Non-access control functions   // // Helper function for initial staking and restaking   // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position   /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds   /// @param amount Amount of tokens to stake   /// @param _period Period of time for which funds get locked   /// @param _id ID for this NFT position   /// @param _receiver Address that will be linked to this position   /// @return _sher Amount of SHER tokens awarded to this position after _period ends   /// @dev _period needs to be whitelisted   function _stake(     uint256 _amount,     uint256 _period,     uint256 _id,     address _receiver   ) internal returns (uint256 _sher) {     // Sets the timestamp at which this position can first be unstaked/restaked     lockupEnd[_id] = block.timestamp + _period; if (address(sherDistributionManager) == address(0)) return 0; // Does not allow restaking of 0 tokens if (_amount == 0) return 0;  // Checks this amount of SHER tokens in this contract before we transfer new ones uint256 before = sher.balanceOf(address(this));  // pullReward() calcs then actually transfers the SHER tokens to this contract // in case this call fails, whole (re)staking transaction fails _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);  // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position uint256 actualAmount = sher.balanceOf(address(this)) - before; if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount); // Assigns the newly created SHER tokens to the current stake position if (_sher != 0) sherRewards_[_id] = _sher;  } // Checks to see if the NFT owner is the caller and that the position is unlockable   function verifyUnlockableByOwner(uint256 _id) internal view {     if (ownerOf(_id) != msg.sender) revert Unauthorized();     if (lockupEnd[_id] &gt; block.timestamp) revert InvalidConditions();   } // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner   function sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards[_id];     if (sherReward == 0) return; // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner sher.safeTransfer(_nftOwner, sherReward); // Deletes the SHER reward mapping for this NFT ID delete sherRewards_[_id];  } // Transfers an amount of tokens to the receiver address   // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)   function _transferTokensOut(address _receiver, uint256 _amount) internal {     // Transfers any premiums owed to stakers from the protocol manager to this contract     sherlockProtocolManager.claimPremiumsForStakers(); // The amount of tokens in this contract uint256 mainBalance = token.balanceOf(address(this));  // If the amount to transfer out is still greater than the amount of tokens in this contract, // Withdraw yield strategy tokens to make up the difference if (_amount &gt; mainBalance) {   yieldStrategy.withdraw(_amount - mainBalance); }  token.safeTransfer(_receiver, _amount);  } // Returns the amount of USDC owed to this amount of stakeShares   function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {     // Finds fraction that the given amount of stakeShares represents of the total     // Then multiplies it by the total amount of tokens (USDC) owed to all stakers     return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;   } // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted   // Also burns the requisite amount of shares associated with this NFT position   // Returns the amount of USDC owed to these shares   function _redeemShares(     uint256 _id,     uint256 _stakeShares,     address _receiver   ) internal returns (uint256 _amount) {     // Returns the amount of USDC owed to this amount of stakeShares     _amount = _redeemSharesCalc(_stakeShares);     // Transfers _amount of tokens to _receiver address     if (_amount != 0) _transferTokensOut(_receiver, _amount); // Subtracts this amount of stakeShares from the NFT position stakeShares[_id] -= _stakeShares; // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding totalStakeShares -= _stakeShares;  } // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager   // Restakes an NFT position (_id) for a given period (_period) and   // Sends any previously earned SHER rewards to the _nftOwner address   function _restake(     uint256 _id,     uint256 _period,     address _nftOwner   ) internal returns (uint256 _sher) {     // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner     // NOTE This function deletes the SHER reward mapping for this NFT ID     _sendSherRewardsToOwner(_id, _nftOwner); // tokenBalanceOf() returns the USDC amount owed to this NFT ID // _stake() restakes that amount of USDC for the period inputted // We use the same ID that we just deleted the SHER rewards mapping for // Resets the lockupEnd mapping and SHER token rewards mapping for this ID // Note stakeShares for this position do not change so no need to update _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);  emit Restaked(_id);  } // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)   /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt   /// @param _amount Amount of tokens to stake   /// @param _period Period of time, in seconds, to lockup your funds   /// @param _receiver Address that will receive the NFT representing the position   /// @return _id ID of the position   /// @return _sher Amount of SHER tokens to be released to this ID after _period ends   /// @dev _period needs to be whitelisted   function initialStake(     uint256 _amount,     uint256 _period,     address _receiver   ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {     if (_amount == 0) revert ZeroArgument();     // Makes sure the period is a whitelisted period     if (!stakingPeriods[_period]) revert InvalidArgument();     if (address(_receiver) == address(0)) revert ZeroArgument();     // Adds 1 to the ID of the last NFT created for the new NFT ID     _id = ++nftCounter; // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action) token.safeTransferFrom(msg.sender, address(this), _amount);  uint256 stakeShares_; uint256 totalStakeShares_ = totalStakeShares; // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares if (totalStakeShares_ != 0)   stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);   // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked else stakeShares_ = _amount;  // Assigns this NFT ID the calc'd amount of stake shares above stakeShares[_id] = stakeShares_; // Adds the newly created stake shares to the total amount of stake shares totalStakeShares += stakeShares_;  // Locks up the USDC amount and calcs the SHER token amount to receive on unstake _sher = _stake(_amount, _period, _id, _receiver);  // This is an ERC-721 function that creates an NFT and sends it to the receiver _safeMint(_receiver, _id);  } // This is how a staker unstakes and cashes out on their position   /// @notice Redeem NFT _id and receive _amount of tokens   /// @param _id TokenID of the position   /// @return _amount Amount of tokens (USDC) owed to NFT ID   /// @dev Only the owner of _id will be able to redeem their position   /// @dev The SHER rewards are sent to the NFT owner   /// @dev Can only be called after lockup _period has ended   function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // This is the ERC-721 function to destroy an NFT (with owner's approval) _burn(_id);  // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC owed to these shares _amount = _redeemShares(_id, stakeShares[_id], msg.sender);  // Sends the SHER tokens associated with this NFT ID to the NFT owner _sendSherRewardsToOwner(_id, msg.sender);  // Removes the unlock deadline associated with this NFT delete lockupEnd_[_id];  } // This is how a staker restakes an expired position   /// @notice Owner restakes position with ID: _id for _period seconds   /// @param _id ID of the position   /// @param _period Period of time, in seconds, to lockup your funds   /// @return _sher Amount of SHER tokens to be released to owner address after _period ends   /// @dev Only the owner of _id will be able to restake their position using this call   /// @dev _period needs to be whitelisted   /// @dev Can only be called after lockup _period has ended   function ownerRestake(uint256 _id, uint256 _period)     external     override     whenNotPaused     returns (uint256 _sher)   {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // Checks to make sure the staking period is a whitelisted one if (!stakingPeriods[_period]) revert InvalidArgument();  // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position _sher = _restake(_id, _period, msg.sender);  } // Calcs the reward (in stake shares) an arb would get for restaking a position   // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb   function calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {     // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)     uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME; // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position if (initialArbTime &gt; block.timestamp) return (0, false);  // The max rewards (as a % of the position's shares) for the arb are available at this timestamp uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;  // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100% uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;  // Scaled by 10**18 // Represents the max amount of stake shares that an arb could get from restaking this position uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];  // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled return (   ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,   true );  } /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position   /// @return profit How much profit an arb would make in USDC   /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)   function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {     // Returns the stake shares that an arb would get, and whether the position can currently be arbed     // profit variable is used to store the amount of shares     (profit, able) = _calcSharesForArbRestake(_id);     // Calculates the tokens (USDC) represented by that amount of stake shares     // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit     profit = _redeemSharesCalc(profit);   } /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)   /// @param _id ID of the position   /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup   /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function   /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)   /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)   /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)   function arbRestake(uint256 _id)     external     override     whenNotPaused     returns (uint256 _sher, uint256 _arbReward)   {     address nftOwner = ownerOf(_id); // Returns the stake shares that an arb would get, and whether the position can currently be arbed (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id); // Revert if not able to be arbed if (!able) revert InvalidConditions();  // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC paid to the arbitrager _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);  // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months) // Sends previously earned SHER rewards to the NFT owner address _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);  emit ArbRestaked(_id, _arbReward);  } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/***********\\n Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x)\n Sherlock Protocol: https://sherlock.xyz\n/***********/\n\nimport \'@openzeppelin/contracts/token/ERC20/IERC20.sol\';\nimport \'@openzeppelin/contracts/token/ERC721/ERC721.sol\';\nimport \'@openzeppelin/contracts/access/Ownable.sol\';\nimport \'@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\';\nimport \'@openzeppelin/contracts/security/Pausable.sol\';\n\nimport \'./interfaces/ISherlock.sol\';\n\n/// @title Sherlock core interface for stakers\n/// @author Evert Kors\n// This is the contract that manages staking actions\n\ncontract Sherlock is ISherlock, ERC721, Ownable, Pausable {\n  using SafeERC20 for IERC20;\n\n  // The initial period for a staker to restake/withdraw without being auto-restaked\n  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;\n\n  // The period during which the reward for restaking an account (after the inital period) grows\n  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;\n\n  // Anyone who gets auto-restaked is restaked for this period (3 months)\n  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;\n\n  // The percentage of someone\'s stake that can be paid to an arb for restaking\n  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (1018 / 100) * 20; // 20%\n\n  // USDC address\n  IERC20 public immutable token;\n\n  // SHER token address\n  IERC20 public immutable sher;\n\n  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not\n  mapping(uint256 =&gt; bool) public override stakingPeriods;\n\n  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked\n  mapping(uint256 =&gt; uint256) internal lockupEnd_;\n\n  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position\n  mapping(uint256 =&gt; uint256) internal sherRewards_;\n\n  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)\n  mapping(uint256 =&gt; uint256) internal stakeShares;\n\n  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.\n  mapping(address =&gt; uint256) internal addressShares;\n\n  // Total amount of shares that have been issued to all NFT positions\n  uint256 internal totalStakeShares;\n\n  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)\n  IStrategyManager public override yieldStrategy;\n\n  // Instances of relevant Sherlock contracts\n  ISherDistributionManager public override sherDistributionManager;\n  ISherlockProtocolManager public override sherlockProtocolManager;\n  ISherlockClaimManager public override sherlockClaimManager;\n\n  // Address to which nonstaker payments are made\n  // This will start out as a multi-sig address, then become a contract address later\n  address public override nonStakersAddress;\n\n  // Stores the ID of the most recently created NFT\n  // This variable is incremented by 1 to create a new NFT ID\n  uint256 internal nftCounter;\n\n  // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.\n  constructor(\n    IERC20 token, // USDC address\n    IERC20 _sher, // SHER token address\n    string memory _name, // Token collection name (see ERC-721 docs)\n    string memory _symbol, // Token collection symbol (see ERC-721 docs)\n    IStrategyManager _yieldStrategy, // The active yield strategy contract\n    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract\n    address _nonStakersAddress, // The address to which nonstakers payments go\n    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract\n    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract\n    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for\n  ) ERC721(_name, _symbol) {\n    if (address(_token) == address(0)) revert ZeroArgument();\n    if (address(_sher) == address(0)) revert ZeroArgument();\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();\n    if (_nonStakersAddress == address(0)) revert ZeroArgument();\n    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();\n    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();\n\n    token = _token;\n    sher = _sher;\n    yieldStrategy = _yieldStrategy;\n    sherDistributionManager = _sherDistributionManager;\n    nonStakersAddress = _nonStakersAddress;\n    sherlockProtocolManager = _sherlockProtocolManager;\n    sherlockClaimManager = _sherlockClaimManager;\n\n    // Enabling the first set of staking periods that were provided in constructor args\n    for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {\n      enableStakingPeriod(_initialstakingPeriods[i]);\n    }\n\n    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);\n    emit SherDistributionManagerUpdated(\n      ISherDistributionManager(address(0)),\n      _sherDistributionManager\n    );\n    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);\n    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);\n    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);\n  }\n\n  //\n  // View functions\n  //\n\n  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked\n  /// @notice View the current lockup end timestamp of _tokenID\n  /// @return Timestamp when NFT position unlocks\n  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n\n    return lockupEnd[tokenID];\n  }\n\n  // Returns the SHER rewards owed to this position\n  /// @notice View the current SHER reward of _tokenID\n  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup\n  function sherRewards(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n\n    return sherRewards[tokenID];\n  }\n\n  // Returns the tokens (USDC) owed to a position\n  /// @notice View the current token balance claimable upon reaching end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking position\n  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers\n    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;\n  }\n\n  // Returns the tokens (USDC) owed to an address\n  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking all positions\n  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {\n    if (_staker == address(0)) revert ZeroArgument();\n    uint256 _totalStakeShares = totalStakeShares;\n    if (_totalStakeShares == 0) return 0;\n    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers\n    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;\n  }\n\n  // Gets the total amount of tokens (USDC) owed to stakers\n  // Adds this contract\'s balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract\n  /// @notice View the current TVL for all stakers\n  /// @return Total amount of tokens staked\n  /// @dev Adds principal + strategy + premiums\n  /// @dev Will calculate the most up to date value for each piece\n  function totalTokenBalanceStakers() public view override returns (uint256) {\n    return\n      token.balanceOf(address(this)) +\n      yieldStrategy.balanceOf() +\n      sherlockProtocolManager.claimablePremiums();\n  }\n\n  //\n  // Gov functions\n  //\n\n  // Allows governance to add a new staking period (4 months, etc.)\n  /// @notice Allows stakers to stake for _period of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already enabled\n  function enableStakingPeriod(uint256 _period) public override onlyOwner {\n    if (_period == 0) revert ZeroArgument();\n    // Revert if staking period is already active\n    if (stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sets the staking period to true\n    stakingPeriods[_period] = true;\n    emit StakingPeriodEnabled(_period);\n  }\n\n  // Allows governance to remove a staking period (4 months, etc.)\n  /// @notice Disallow stakers to stake for _period of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already disabled\n  function disableStakingPeriod(uint256 _period) external override onlyOwner {\n    // Revert if staking period is already inactive\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sets the staking period to false\n    stakingPeriods[_period] = false;\n    emit StakingPeriodDisabled(_period);\n  }\n\n  // Sets a new contract to be the active SHER distribution manager\n  /// @notice Update SHER distribution manager contract\n  /// @param _sherDistributionManager New adddress of the manager\n  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();\n    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();\n\n    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);\n    sherDistributionManager = _sherDistributionManager;\n  }\n\n  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)\n  /// @notice Remove SHER token rewards\n  function removeSherDistributionManager() external override onlyOwner {\n    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();\n\n    emit SherDistributionManagerUpdated(\n      sherDistributionManager,\n      ISherDistributionManager(address(0))\n    );\n    delete sherDistributionManager;\n  }\n\n  // Sets a new address for nonstakers payments\n  /// @notice Update address eligble for non staker rewards from protocol premiums\n  /// @param _nonStakers Address eligble for non staker rewards\n  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {\n    if (address(_nonStakers) == address(0)) revert ZeroArgument();\n    if (nonStakersAddress == _nonStakers) revert InvalidArgument();\n\n    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);\n    nonStakersAddress = _nonStakers;\n  }\n\n  // Sets a new protocol manager contract\n  /// @notice Transfer protocol manager implementation address\n  /// @param _protocolManager new implementation address\n  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_protocolManager) == address(0)) revert ZeroArgument();\n    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();\n\n    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);\n    sherlockProtocolManager = _protocolManager;\n  }\n\n  // Sets a new claim manager contract\n  /// @notice Transfer claim manager role to different address\n  /// @param _claimManager New address of claim manager\n  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_claimManager) == address(0)) revert ZeroArgument();\n    if (sherlockClaimManager == _claimManager) revert InvalidArgument();\n\n    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);\n    sherlockClaimManager = _claimManager;\n  }\n\n  // Sets a new yield strategy manager contract\n  /// @notice Update yield strategy\n  /// @param _yieldStrategy News address of the strategy\n  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure\n  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();\n\n    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail\n    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.\n    // In case this happens. We still want the yield strategy to be updated.\n    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.\n    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {\n      emit YieldStrategyUpdateWithdrawAllError(reason);\n    }\n\n    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);\n    yieldStrategy = _yieldStrategy;\n  }\n\n  // Deposits a chosen amount of tokens (USDC) into the active yield strategy\n  /// @notice Deposit _amount into active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {\n    if (_amount == 0) revert ZeroArgument();\n\n    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first\n    sherlockProtocolManager.claimPremiumsForStakers();\n    // Transfers the amount of tokens to the yield strategy contract\n    token.safeTransfer(address(yieldStrategy), _amount);\n    // Deposits all tokens in the yield strategy contract into the actual yield strategy\n    yieldStrategy.deposit();\n  }\n\n  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract\n  /// @notice Withdraw _amount from active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {\n    if (_amount == 0) revert ZeroArgument();\n\n    yieldStrategy.withdraw(_amount);\n  }\n\n  // Withdraws all tokens from the yield strategy back into this contract\n  /// @notice Withdraw all funds from active strategy\n  /// @dev gov only\n  function yieldStrategyWithdrawAll() external override onlyOwner {\n    yieldStrategy.withdrawAll();\n  }\n\n  /// @notice Pause external functions in all contracts\n  /// @dev A manager can be replaced with the new contract in a paused state\n  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused\n  function pause() external onlyOwner {\n    _pause();\n    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();\n    // sherDistributionManager can be 0, pause isn\'t needed in that case\n    if (\n      address(sherDistributionManager) != address(0) &amp;&amp;\n      !Pausable(address(sherDistributionManager)).paused()\n    ) {\n      sherDistributionManager.pause();\n    }\n    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();\n    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();\n  }\n\n  /// @notice Unpause external functions in all contracts\n  /// @dev A manager can be replaced with the new contract in an unpaused state\n  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused\n  function unpause() external onlyOwner {\n    _unpause();\n    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();\n    // sherDistributionManager can be 0, unpause isn\'t needed in that case\n    if (\n      address(sherDistributionManager) != address(0) &amp;&amp;\n      Pausable(address(sherDistributionManager)).paused()\n    ) {\n      sherDistributionManager.unpause();\n    }\n    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();\n    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();\n  }\n\n  //\n  // Access control functions\n  //\n\n  /// @notice Account sum of all underlying posiiton shares for _from and _to\n  /// @dev this enables the tokenBalanceOfAddress to exist\n  function _beforeTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenID\n  ) internal override {\n    uint256 _stakeShares = stakeShares[_tokenID];\n\n    if (_from != address(0)) addressShares[_from] -= _stakeShares;\n    if (_to != address(0)) addressShares[_to] += _stakeShares;\n  }\n\n  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)\n  // This function is called by the Sherlock claim manager contract if a claim is approved\n  /// @notice Initiate a payout of _amount to _receiver\n  /// @param _receiver Receiver of payout\n  /// @param _amount Amount to send\n  /// @dev only payout manager should call this\n  /// @dev should pull money out of strategy\n  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {\n    // Can only be called by the Sherlock claim manager contract\n    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();\n\n    if (_amount != 0) {\n      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)\n      _transferTokensOut(_receiver, _amount);\n    }\n    emit ClaimPayout(_receiver, _amount);\n  }\n\n  //\n  // Non-access control functions\n  //\n\n  // Helper function for initial staking and restaking\n  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position\n  /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time for which funds get locked\n  /// @param _id ID for this NFT position\n  /// @param _receiver Address that will be linked to this position\n  /// @return _sher Amount of SHER tokens awarded to this position after _period ends\n  /// @dev _period needs to be whitelisted\n  function _stake(\n    uint256 _amount,\n    uint256 _period,\n    uint256 _id,\n    address _receiver\n  ) internal returns (uint256 _sher) {\n    // Sets the timestamp at which this position can first be unstaked/restaked\n    lockupEnd[id] = block.timestamp + _period;\n\n    if (address(sherDistributionManager) == address(0)) return 0;\n    // Does not allow restaking of 0 tokens\n    if (_amount == 0) return 0;\n\n    // Checks this amount of SHER tokens in this contract before we transfer new ones\n    uint256 before = sher.balanceOf(address(this));\n\n    // pullReward() calcs then actually transfers the SHER tokens to this contract\n    // in case this call fails, whole (re)staking transaction fails\n    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);\n\n    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position\n    uint256 actualAmount = sher.balanceOf(address(this)) - before;\n    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);\n    // Assigns the newly created SHER tokens to the current stake position\n    if (_sher != 0) sherRewards[id] = _sher;\n  }\n\n  // Checks to see if the NFT owner is the caller and that the position is unlockable\n  function _verifyUnlockableByOwner(uint256 _id) internal view {\n    if (ownerOf(_id) != msg.sender) revert Unauthorized();\n    if (lockupEnd[id] &gt; block.timestamp) revert InvalidConditions();\n  }\n\n  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner\n  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {\n    uint256 sherReward = sherRewards[id];\n    if (sherReward == 0) return;\n\n    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner\n    sher.safeTransfer(_nftOwner, sherReward);\n    // Deletes the SHER reward mapping for this NFT ID\n    delete sherRewards[id];\n  }\n\n  // Transfers an amount of tokens to the receiver address\n  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)\n  function _transferTokensOut(address _receiver, uint256 _amount) internal {\n    // Transfers any premiums owed to stakers from the protocol manager to this contract\n    sherlockProtocolManager.claimPremiumsForStakers();\n\n    // The amount of tokens in this contract\n    uint256 mainBalance = token.balanceOf(address(this));\n\n    // If the amount to transfer out is still greater than the amount of tokens in this contract,\n    // Withdraw yield strategy tokens to make up the difference\n    if (_amount &gt; mainBalance) {\n      yieldStrategy.withdraw(_amount - mainBalance);\n    }\n\n    token.safeTransfer(_receiver, _amount);\n  }\n\n  // Returns the amount of USDC owed to this amount of stakeShares\n  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {\n    // Finds fraction that the given amount of stakeShares represents of the total\n    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers\n    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;\n  }\n\n  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted\n  // Also burns the requisite amount of shares associated with this NFT position\n  // Returns the amount of USDC owed to these shares\n  function _redeemShares(\n    uint256 _id,\n    uint256 _stakeShares,\n    address _receiver\n  ) internal returns (uint256 _amount) {\n    // Returns the amount of USDC owed to this amount of stakeShares\n    _amount = _redeemSharesCalc(_stakeShares);\n    // Transfers _amount of tokens to _receiver address\n    if (_amount != 0) _transferTokensOut(_receiver, _amount);\n\n    // Subtracts this amount of stakeShares from the NFT position\n    stakeShares[_id] -= _stakeShares;\n    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding\n    totalStakeShares -= _stakeShares;\n  }\n\n  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager\n  // Restakes an NFT position (_id) for a given period (_period) and\n  // Sends any previously earned SHER rewards to the _nftOwner address\n  function _restake(\n    uint256 _id,\n    uint256 _period,\n    address _nftOwner\n  ) internal returns (uint256 _sher) {\n    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner\n    // NOTE This function deletes the SHER reward mapping for this NFT ID\n    _sendSherRewardsToOwner(_id, _nftOwner);\n\n    // tokenBalanceOf() returns the USDC amount owed to this NFT ID\n    // _stake() restakes that amount of USDC for the period inputted\n    // We use the same ID that we just deleted the SHER rewards mapping for\n    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID\n    // Note stakeShares for this position do not change so no need to update\n    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);\n\n    emit Restaked(_id);\n  }\n\n  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)\n  /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @param _receiver Address that will receive the NFT representing the position\n  /// @return _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to this ID after _period ends\n  /// @dev _period needs to be whitelisted\n  function initialStake(\n    uint256 _amount,\n    uint256 _period,\n    address _receiver\n  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {\n    if (_amount == 0) revert ZeroArgument();\n    // Makes sure the period is a whitelisted period\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n    if (address(_receiver) == address(0)) revert ZeroArgument();\n    // Adds 1 to the ID of the last NFT created for the new NFT ID\n    _id = ++nftCounter;\n\n    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)\n    token.safeTransferFrom(msg.sender, address(this), _amount);\n\n    uint256 stakeShares;\n    uint256 totalStakeShares_ = totalStakeShares;\n    // amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares\n    if (totalStakeShares != 0)\n      stakeShares_ = (amount * totalStakeShares) / (totalTokenBalanceStakers() - amount);\n      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked\n    else stakeShares = amount;\n\n    // Assigns this NFT ID the calc\'d amount of stake shares above\n    stakeShares[_id] = stakeShares;\n    // Adds the newly created stake shares to the total amount of stake shares\n    totalStakeShares += stakeShares_;\n\n    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake\n    sher = _stake(_amount, _period, _id, _receiver);\n\n    // This is an ERC-721 function that creates an NFT and sends it to the receiver\n    _safeMint(_receiver, _id);\n  }\n\n  // This is how a staker unstakes and cashes out on their position\n  /// @notice Redeem NFT _id and receive _amount of tokens\n  /// @param _id TokenID of the position\n  /// @return _amount Amount of tokens (USDC) owed to NFT ID\n  /// @dev Only the owner of _id will be able to redeem their position\n  /// @dev The SHER rewards are sent to the NFT owner\n  /// @dev Can only be called after lockup _period has ended\n  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {\n    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over\n    _verifyUnlockableByOwner(_id);\n\n    // This is the ERC-721 function to destroy an NFT (with owner\'s approval)\n    _burn(_id);\n\n    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID\n    // Also burns the requisite amount of shares associated with this NFT position\n    // Returns the amount of USDC owed to these shares\n    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);\n\n    // Sends the SHER tokens associated with this NFT ID to the NFT owner\n    _sendSherRewardsToOwner(_id, msg.sender);\n\n    // Removes the unlock deadline associated with this NFT\n    delete lockupEnd[id];\n  }\n\n  // This is how a staker restakes an expired position\n  /// @notice Owner restakes position with ID: _id for _period seconds\n  /// @param _id ID of the position\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @return _sher Amount of SHER tokens to be released to owner address after _period ends\n  /// @dev Only the owner of _id will be able to restake their position using this call\n  /// @dev _period needs to be whitelisted\n  /// @dev Can only be called after lockup _period has ended\n  function ownerRestake(uint256 _id, uint256 _period)\n    external\n    override\n    whenNotPaused\n    returns (uint256 _sher)\n  {\n    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over\n    _verifyUnlockableByOwner(_id);\n\n    // Checks to make sure the staking period is a whitelisted one\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position\n    _sher = _restake(_id, _period, msg.sender);\n  }\n\n  // Calcs the reward (in stake shares) an arb would get for restaking a position\n  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb\n  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {\n    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)\n    uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME;\n\n    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position\n    if (initialArbTime &gt; block.timestamp) return (0, false);\n\n    // The max rewards (as a % of the position\'s shares) for the arb are available at this timestamp\n    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;\n\n    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%\n    uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;\n\n    // Scaled by 1018\n    // Represents the max amount of stake shares that an arb could get from restaking this position\n    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];\n\n    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function\n    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled\n    return (\n      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10*18,\n      true\n    );\n  }\n\n  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position\n  /// @return profit How much profit an arb would make in USDC\n  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)\n  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {\n    // Returns the stake shares that an arb would get, and whether the position can currently be arbed\n    // profit variable is used to store the amount of shares\n    (profit, able) = _calcSharesForArbRestake(_id);\n    // Calculates the tokens (USDC) represented by that amount of stake shares\n    // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit\n    profit = _redeemSharesCalc(profit);\n  }\n\n  /// @notice Allows someone who doesn\'t own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)\n  /// @param _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup\n  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function\n  /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)\n  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)\n  /// @dev During a 2 week period the reward ratio will move from 0% to 100% ( x)\n  function arbRestake(uint256 _id)\n    external\n    override\n    whenNotPaused\n    returns (uint256 _sher, uint256 _arbReward)\n  {\n    address nftOwner = ownerOf(_id);\n\n    // Returns the stake shares that an arb would get, and whether the position can currently be arbed\n    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);\n    // Revert if not able to be arbed\n    if (!able) revert InvalidConditions();\n\n    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward\n    // Also burns the requisite amount of shares associated with this NFT position\n    // Returns the amount of USDC paid to the arbitrager\n    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);\n\n    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)\n    // Sends previously earned SHER rewards to the NFT owner address\n    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);\n\n    emit ArbRestaked(_id, _arbReward);\n  }\n}\n', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-25-08 10:37:40 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@openzeppelin/contracts/token/ERC721/ERC721.sol'; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol'; import '@openzeppelin/contracts/security/Pausable.sol'; import './interfaces/ISherlock.sol'; /// @title Sherlock core interface for stakers /// @author Evert Kors // This is the contract that manages staking actions contract Sherlock is ISherlock, ERC721, Ownable, Pausable {   using SafeERC20 for IERC20; // The initial period for a staker to restake/withdraw without being auto-restaked   uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks; // The period during which the reward for restaking an account (after the inital period) grows   uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks; // Anyone who gets auto-restaked is restaked for this period (3 months)   uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks; // The percentage of someone's stake that can be paid to an arb for restaking   uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20% // USDC address   IERC20 public immutable token; // SHER token address   IERC20 public immutable sher; // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not   mapping(uint256 =&gt; bool) public override stakingPeriods; // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked   mapping(uint256 =&gt; uint256) internal lockupEnd_; // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position   mapping(uint256 =&gt; uint256) internal sherRewards_; // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)   mapping(uint256 =&gt; uint256) internal stakeShares; // Key is account, value is the sum of underlying shares of all the NFTs the account owns.   mapping(address =&gt; uint256) internal addressShares; // Total amount of shares that have been issued to all NFT positions   uint256 internal totalStakeShares; // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)   IStrategyManager public override yieldStrategy; // Instances of relevant Sherlock contracts   ISherDistributionManager public override sherDistributionManager;   ISherlockProtocolManager public override sherlockProtocolManager;   ISherlockClaimManager public override sherlockClaimManager; // Address to which nonstaker payments are made   // This will start out as a multi-sig address, then become a contract address later   address public override nonStakersAddress; // Stores the ID of the most recently created NFT   // This variable is incremented by 1 to create a new NFT ID   uint256 internal nftCounter; // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.   constructor(     IERC20 _token, // USDC address     IERC20 _sher, // SHER token address     string memory _name, // Token collection name (see ERC-721 docs)     string memory _symbol, // Token collection symbol (see ERC-721 docs)     IStrategyManager _yieldStrategy, // The active yield strategy contract     ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract     address _nonStakersAddress, // The address to which nonstakers payments go     ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract     ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract     uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for   ) ERC721(_name, _symbol) {     if (address(_token) == address(0)) revert ZeroArgument();     if (address(_sher) == address(0)) revert ZeroArgument();     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (_nonStakersAddress == address(0)) revert ZeroArgument();     if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();     if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument(); token = _token; sher = _sher; yieldStrategy = _yieldStrategy; sherDistributionManager = _sherDistributionManager; nonStakersAddress = _nonStakersAddress; sherlockProtocolManager = _sherlockProtocolManager; sherlockClaimManager = _sherlockClaimManager;  // Enabling the first set of staking periods that were provided in constructor args for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {   enableStakingPeriod(_initialstakingPeriods[i]); }  emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy); emit SherDistributionManagerUpdated(   ISherDistributionManager(address(0)),   _sherDistributionManager ); emit NonStakerAddressUpdated(address(0), _nonStakersAddress); emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager); emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);  } //   // View functions   // // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked   /// @notice View the current lockup end timestamp of _tokenID   /// @return Timestamp when NFT position unlocks   function lockupEnd(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return lockupEnd_[_tokenID];  } // Returns the SHER rewards owed to this position   /// @notice View the current SHER reward of _tokenID   /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup   function sherRewards(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return sherRewards_[_tokenID];  } // Returns the tokens (USDC) owed to a position   /// @notice View the current token balance claimable upon reaching end of the lockup   /// @return Amount of tokens assigned to owner when unstaking position   function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent();     // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers     return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;   } // Returns the tokens (USDC) owed to an address   /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup   /// @return Amount of tokens assigned to owner when unstaking all positions   function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {     if (_staker == address(0)) revert ZeroArgument();     uint256 _totalStakeShares = totalStakeShares;     if (_totalStakeShares == 0) return 0;     // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers     return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;   } // Gets the total amount of tokens (USDC) owed to stakers   // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract   /// @notice View the current TVL for all stakers   /// @return Total amount of tokens staked   /// @dev Adds principal + strategy + premiums   /// @dev Will calculate the most up to date value for each piece   function totalTokenBalanceStakers() public view override returns (uint256) {     return       token.balanceOf(address(this)) +       yieldStrategy.balanceOf() +       sherlockProtocolManager.claimablePremiums();   } //   // Gov functions   // // Allows governance to add a new staking period (4 months, etc.)   /// @notice Allows stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already enabled   function enableStakingPeriod(uint256 _period) public override onlyOwner {     if (_period == 0) revert ZeroArgument();     // Revert if staking period is already active     if (stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to true stakingPeriods[_period] = true; emit StakingPeriodEnabled(_period);  } // Allows governance to remove a staking period (4 months, etc.)   /// @notice Disallow stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already disabled   function disableStakingPeriod(uint256 _period) external override onlyOwner {     // Revert if staking period is already inactive     if (!stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to false stakingPeriods[_period] = false; emit StakingPeriodDisabled(_period);  } // Sets a new contract to be the active SHER distribution manager   /// @notice Update SHER distribution manager contract   /// @param _sherDistributionManager New adddress of the manager   function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)     external     override     onlyOwner   {     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument(); emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager); sherDistributionManager = _sherDistributionManager;  } // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)   /// @notice Remove SHER token rewards   function removeSherDistributionManager() external override onlyOwner {     if (address(sherDistributionManager) == address(0)) revert InvalidConditions(); emit SherDistributionManagerUpdated(   sherDistributionManager,   ISherDistributionManager(address(0)) ); delete sherDistributionManager;  } // Sets a new address for nonstakers payments   /// @notice Update address eligble for non staker rewards from protocol premiums   /// @param _nonStakers Address eligble for non staker rewards   function updateNonStakersAddress(address _nonStakers) external override onlyOwner {     if (address(_nonStakers) == address(0)) revert ZeroArgument();     if (nonStakersAddress == _nonStakers) revert InvalidArgument(); emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers); nonStakersAddress = _nonStakers;  } // Sets a new protocol manager contract   /// @notice Transfer protocol manager implementation address   /// @param _protocolManager new implementation address   function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)     external     override     onlyOwner   {     if (address(_protocolManager) == address(0)) revert ZeroArgument();     if (sherlockProtocolManager == _protocolManager) revert InvalidArgument(); emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager); sherlockProtocolManager = _protocolManager;  } // Sets a new claim manager contract   /// @notice Transfer claim manager role to different address   /// @param _claimManager New address of claim manager   function updateSherlockClaimManager(ISherlockClaimManager _claimManager)     external     override     onlyOwner   {     if (address(_claimManager) == address(0)) revert ZeroArgument();     if (sherlockClaimManager == _claimManager) revert InvalidArgument(); emit ClaimManagerUpdated(sherlockClaimManager, _claimManager); sherlockClaimManager = _claimManager;  } // Sets a new yield strategy manager contract   /// @notice Update yield strategy   /// @param _yieldStrategy News address of the strategy   /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure   function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (yieldStrategy == _yieldStrategy) revert InvalidArgument(); // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason. // In case this happens. We still want the yield strategy to be updated. // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again. try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {   emit YieldStrategyUpdateWithdrawAllError(reason); }  emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy); yieldStrategy = _yieldStrategy;  } // Deposits a chosen amount of tokens (USDC) into the active yield strategy   /// @notice Deposit _amount into active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); // Transfers any tokens owed to stakers from the protocol manager contract to this contract first sherlockProtocolManager.claimPremiumsForStakers(); // Transfers the amount of tokens to the yield strategy contract token.safeTransfer(address(yieldStrategy), _amount); // Deposits all tokens in the yield strategy contract into the actual yield strategy yieldStrategy.deposit();  } // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract   /// @notice Withdraw _amount from active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); yieldStrategy.withdraw(_amount);  } // Withdraws all tokens from the yield strategy back into this contract   /// @notice Withdraw all funds from active strategy   /// @dev gov only   function yieldStrategyWithdrawAll() external override onlyOwner {     yieldStrategy.withdrawAll();   } /// @notice Pause external functions in all contracts   /// @dev A manager can be replaced with the new contract in a paused state   /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused   function pause() external onlyOwner {     _pause();     if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();     // sherDistributionManager can be 0, pause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       !Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.pause();     }     if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();     if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();   } /// @notice Unpause external functions in all contracts   /// @dev A manager can be replaced with the new contract in an unpaused state   /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused   function unpause() external onlyOwner {     _unpause();     if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();     // sherDistributionManager can be 0, unpause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.unpause();     }     if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();     if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();   } //   // Access control functions   // /// @notice Account sum of all underlying posiiton shares for _from and _to   /// @dev this enables the tokenBalanceOfAddress to exist   function _beforeTokenTransfer(     address _from,     address _to,     uint256 _tokenID   ) internal override {     uint256 _stakeShares = stakeShares[_tokenID]; if (_from != address(0)) addressShares[_from] -= _stakeShares; if (_to != address(0)) addressShares[_to] += _stakeShares;  } // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)   // This function is called by the Sherlock claim manager contract if a claim is approved   /// @notice Initiate a payout of _amount to _receiver   /// @param _receiver Receiver of payout   /// @param _amount Amount to send   /// @dev only payout manager should call this   /// @dev should pull money out of strategy   function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {     // Can only be called by the Sherlock claim manager contract     if (msg.sender != address(sherlockClaimManager)) revert Unauthorized(); if (_amount != 0) {   // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)   _transferTokensOut(_receiver, _amount); } emit ClaimPayout(_receiver, _amount);  } //   // Non-access control functions   // // Helper function for initial staking and restaking   // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position   /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds   /// @param amount Amount of tokens to stake   /// @param _period Period of time for which funds get locked   /// @param _id ID for this NFT position   /// @param _receiver Address that will be linked to this position   /// @return _sher Amount of SHER tokens awarded to this position after _period ends   /// @dev _period needs to be whitelisted   function _stake(     uint256 _amount,     uint256 _period,     uint256 _id,     address _receiver   ) internal returns (uint256 _sher) {     // Sets the timestamp at which this position can first be unstaked/restaked     lockupEnd[_id] = block.timestamp + _period; if (address(sherDistributionManager) == address(0)) return 0; // Does not allow restaking of 0 tokens if (_amount == 0) return 0;  // Checks this amount of SHER tokens in this contract before we transfer new ones uint256 before = sher.balanceOf(address(this));  // pullReward() calcs then actually transfers the SHER tokens to this contract // in case this call fails, whole (re)staking transaction fails _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);  // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position uint256 actualAmount = sher.balanceOf(address(this)) - before; if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount); // Assigns the newly created SHER tokens to the current stake position if (_sher != 0) sherRewards_[_id] = _sher;  } // Checks to see if the NFT owner is the caller and that the position is unlockable   function verifyUnlockableByOwner(uint256 _id) internal view {     if (ownerOf(_id) != msg.sender) revert Unauthorized();     if (lockupEnd[_id] &gt; block.timestamp) revert InvalidConditions();   } // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner   function sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards[_id];     if (sherReward == 0) return; // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner sher.safeTransfer(_nftOwner, sherReward); // Deletes the SHER reward mapping for this NFT ID delete sherRewards_[_id];  } // Transfers an amount of tokens to the receiver address   // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)   function _transferTokensOut(address _receiver, uint256 _amount) internal {     // Transfers any premiums owed to stakers from the protocol manager to this contract     sherlockProtocolManager.claimPremiumsForStakers(); // The amount of tokens in this contract uint256 mainBalance = token.balanceOf(address(this));  // If the amount to transfer out is still greater than the amount of tokens in this contract, // Withdraw yield strategy tokens to make up the difference if (_amount &gt; mainBalance) {   yieldStrategy.withdraw(_amount - mainBalance); }  token.safeTransfer(_receiver, _amount);  } // Returns the amount of USDC owed to this amount of stakeShares   function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {     // Finds fraction that the given amount of stakeShares represents of the total     // Then multiplies it by the total amount of tokens (USDC) owed to all stakers     return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;   } // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted   // Also burns the requisite amount of shares associated with this NFT position   // Returns the amount of USDC owed to these shares   function _redeemShares(     uint256 _id,     uint256 _stakeShares,     address _receiver   ) internal returns (uint256 _amount) {     // Returns the amount of USDC owed to this amount of stakeShares     _amount = _redeemSharesCalc(_stakeShares);     // Transfers _amount of tokens to _receiver address     if (_amount != 0) _transferTokensOut(_receiver, _amount); // Subtracts this amount of stakeShares from the NFT position stakeShares[_id] -= _stakeShares; // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding totalStakeShares -= _stakeShares;  } // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager   // Restakes an NFT position (_id) for a given period (_period) and   // Sends any previously earned SHER rewards to the _nftOwner address   function _restake(     uint256 _id,     uint256 _period,     address _nftOwner   ) internal returns (uint256 _sher) {     // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner     // NOTE This function deletes the SHER reward mapping for this NFT ID     _sendSherRewardsToOwner(_id, _nftOwner); // tokenBalanceOf() returns the USDC amount owed to this NFT ID // _stake() restakes that amount of USDC for the period inputted // We use the same ID that we just deleted the SHER rewards mapping for // Resets the lockupEnd mapping and SHER token rewards mapping for this ID // Note stakeShares for this position do not change so no need to update _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);  emit Restaked(_id);  } // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)   /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt   /// @param _amount Amount of tokens to stake   /// @param _period Period of time, in seconds, to lockup your funds   /// @param _receiver Address that will receive the NFT representing the position   /// @return _id ID of the position   /// @return _sher Amount of SHER tokens to be released to this ID after _period ends   /// @dev _period needs to be whitelisted   function initialStake(     uint256 _amount,     uint256 _period,     address _receiver   ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {     if (_amount == 0) revert ZeroArgument();     // Makes sure the period is a whitelisted period     if (!stakingPeriods[_period]) revert InvalidArgument();     if (address(_receiver) == address(0)) revert ZeroArgument();     // Adds 1 to the ID of the last NFT created for the new NFT ID     _id = ++nftCounter; // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action) token.safeTransferFrom(msg.sender, address(this), _amount);  uint256 stakeShares_; uint256 totalStakeShares_ = totalStakeShares; // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares if (totalStakeShares_ != 0)   stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);   // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked else stakeShares_ = _amount;  // Assigns this NFT ID the calc'd amount of stake shares above stakeShares[_id] = stakeShares_; // Adds the newly created stake shares to the total amount of stake shares totalStakeShares += stakeShares_;  // Locks up the USDC amount and calcs the SHER token amount to receive on unstake _sher = _stake(_amount, _period, _id, _receiver);  // This is an ERC-721 function that creates an NFT and sends it to the receiver _safeMint(_receiver, _id);  } // This is how a staker unstakes and cashes out on their position   /// @notice Redeem NFT _id and receive _amount of tokens   /// @param _id TokenID of the position   /// @return _amount Amount of tokens (USDC) owed to NFT ID   /// @dev Only the owner of _id will be able to redeem their position   /// @dev The SHER rewards are sent to the NFT owner   /// @dev Can only be called after lockup _period has ended   function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // This is the ERC-721 function to destroy an NFT (with owner's approval) _burn(_id);  // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC owed to these shares _amount = _redeemShares(_id, stakeShares[_id], msg.sender);  // Sends the SHER tokens associated with this NFT ID to the NFT owner _sendSherRewardsToOwner(_id, msg.sender);  // Removes the unlock deadline associated with this NFT delete lockupEnd_[_id];  } // This is how a staker restakes an expired position   /// @notice Owner restakes position with ID: _id for _period seconds   /// @param _id ID of the position   /// @param _period Period of time, in seconds, to lockup your funds   /// @return _sher Amount of SHER tokens to be released to owner address after _period ends   /// @dev Only the owner of _id will be able to restake their position using this call   /// @dev _period needs to be whitelisted   /// @dev Can only be called after lockup _period has ended   function ownerRestake(uint256 _id, uint256 _period)     external     override     whenNotPaused     returns (uint256 _sher)   {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // Checks to make sure the staking period is a whitelisted one if (!stakingPeriods[_period]) revert InvalidArgument();  // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position _sher = _restake(_id, _period, msg.sender);  } // Calcs the reward (in stake shares) an arb would get for restaking a position   // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb   function calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {     // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)     uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME; // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position if (initialArbTime &gt; block.timestamp) return (0, false);  // The max rewards (as a % of the position's shares) for the arb are available at this timestamp uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;  // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100% uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;  // Scaled by 10**18 // Represents the max amount of stake shares that an arb could get from restaking this position uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];  // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled return (   ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,   true );  } /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position   /// @return profit How much profit an arb would make in USDC   /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)   function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {     // Returns the stake shares that an arb would get, and whether the position can currently be arbed     // profit variable is used to store the amount of shares     (profit, able) = _calcSharesForArbRestake(_id);     // Calculates the tokens (USDC) represented by that amount of stake shares     // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit     profit = _redeemSharesCalc(profit);   } /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)   /// @param _id ID of the position   /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup   /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function   /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)   /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)   /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)   function arbRestake(uint256 _id)     external     override     whenNotPaused     returns (uint256 _sher, uint256 _arbReward)   {     address nftOwner = ownerOf(_id); // Returns the stake shares that an arb would get, and whether the position can currently be arbed (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id); // Revert if not able to be arbed if (!able) revert InvalidConditions();  // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC paid to the arbitrager _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);  // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months) // Sends previously earned SHER rewards to the NFT owner address _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);  emit ArbRestaked(_id, _arbReward);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-25-08 10:37:40 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';

import './interfaces/ISherlock.sol';

/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions

contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;

  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;

  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;

  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;

  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%

  // USDC address
  IERC20 public immutable token;

  // SHER token address
  IERC20 public immutable sher;

  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;

  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;

  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;

  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;

  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;

  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;

  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;

  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;

  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;

  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;

  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();

    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;

    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }

    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }

  //
  // View functions
  //

  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return lockupEnd_[_tokenID];
  }

  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return sherRewards_[_tokenID];
  }

  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }

  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }

  //
  // Gov functions
  //

  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }

  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }

  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();

    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }

  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();

    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }

  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();

    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }

  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();

    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }

  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();

    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }

  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();

    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }

    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }

  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }

  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    yieldStrategy.withdraw(_amount);
  }

  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }

  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }

  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }

  //
  // Access control functions
  //

  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];

    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }

  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();

    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }

  //
  // Non-access control functions
  //

  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;

    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;

    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));

    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);

    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }

  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }

  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;

    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }

  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();

    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));

    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }

    token.safeTransfer(_receiver, _amount);
  }

  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);

    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }

  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);

    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);

    emit Restaked(_id);
  }

  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;

    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);

    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;

    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;

    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);

    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }

  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);

    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);

    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);

    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }

  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }

  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;

    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);

    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;

    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;

    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];

    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }

  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }

  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);

    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();

    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);

    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);

    emit ArbRestaked(_id, _arbReward);
  }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';

import './interfaces/ISherlock.sol';

/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions

contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;

  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;

  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;

  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;

  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%

  // USDC address
  IERC20 public immutable token;

  // SHER token address
  IERC20 public immutable sher;

  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;

  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;

  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;

  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;

  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;

  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;

  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;

  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;

  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;

  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;

  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();

    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;

    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }

    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }

  //
  // View functions
  //

  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return lockupEnd_[_tokenID];
  }

  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return sherRewards_[_tokenID];
  }

  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }

  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }

  //
  // Gov functions
  //

  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }

  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }

  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();

    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }

  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();

    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }

  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();

    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }

  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();

    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }

  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();

    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }

  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();

    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }

    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }

  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }

  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    yieldStrategy.withdraw(_amount);
  }

  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }

  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }

  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }

  //
  // Access control functions
  //

  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];

    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }

  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();

    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }

  //
  // Non-access control functions
  //

  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;

    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;

    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));

    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);

    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }

  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }

  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;

    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }

  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();

    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));

    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }

    token.safeTransfer(_receiver, _amount);
  }

  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);

    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }

  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);

    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);

    emit Restaked(_id);
  }

  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;

    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);

    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;

    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;

    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);

    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }

  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);

    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);

    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);

    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }

  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }

  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;

    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);

    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;

    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;

    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];

    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }

  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }

  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);

    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();

    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);

    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);

    emit ArbRestaked(_id, _arbReward);
  }
}
".
Ideas: " 1".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-25-08 10:37:56 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-25-08 10:37:56 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 15564
completion_tokens: 801
total_tokens: 16365
cost: $-1.000000


[2024-25-08 10:37:56 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';

import './interfaces/ISherlock.sol';

/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions

contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;

  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;

  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;

  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;

  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%

  // USDC address
  IERC20 public immutable token;

  // SHER token address
  IERC20 public immutable sher;

  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;

  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;

  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;

  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;

  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;

  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;

  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;

  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;

  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;

  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;

  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();

    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;

    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }

    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }

  //
  // View functions
  //

  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return lockupEnd_[_tokenID];
  }

  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return sherRewards_[_tokenID];
  }

  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }

  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }

  //
  // Gov functions
  //

  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }

  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }

  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();

    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }

  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();

    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }

  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();

    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }

  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();

    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }

  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();

    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }

  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();

    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }

    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }

  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }

  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    yieldStrategy.withdraw(_amount);
  }

  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }

  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }

  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }

  //
  // Access control functions
  //

  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];

    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }

  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();

    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }

  //
  // Non-access control functions
  //

  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;

    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;

    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));

    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);

    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }

  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }

  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;

    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }

  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();

    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));

    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }

    token.safeTransfer(_receiver, _amount);
  }

  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);

    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }

  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);

    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);

    emit Restaked(_id);
  }

  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;

    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);

    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;

    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;

    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);

    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }

  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);

    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);

    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);

    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }

  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }

  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;

    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);

    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;

    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;

    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];

    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }

  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }

  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);

    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();

    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);

    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);

    emit ArbRestaked(_id, _arbReward);
  }
}
.]

### VULNERABILITY 1: Reentrancy Attack
```
DETAILED DESCRIPTION: The contract allows external calls to transfer tokens (e.g., in the `_transferTokensOut` function) after state changes (like updating mappings). This can lead to a reentrancy attack where an attacker can call back into the contract before the state is updated, potentially draining funds.

RECOMMENDED MITIGATION: Use the Checks-Effects-Interactions pattern. Ensure that all state changes are made before any external calls. Additionally, consider using a reentrancy guard modifier (e.g., `nonReentrant`) to prevent reentrant calls.
```

### VULNERABILITY 2: Arithmetic Underflow/Overflow
```
DETAILED DESCRIPTION: Although Solidity 0.8.0 and later versions have built-in overflow and underflow checks, there are still areas where arithmetic operations could lead to unexpected results, especially when dealing with shares and balances. For example, if `stakeShares[_id]` is subtracted without checking if it is greater than the amount being subtracted, it could lead to underflow.

RECOMMENDED MITIGATION: Ensure that all arithmetic operations are checked for underflow/overflow conditions. Use SafeMath libraries or ensure that the logic prevents such conditions explicitly.
```

### VULNERABILITY 3: Improper Access Control
```
DETAILED DESCRIPTION: The `payoutClaim` function can only be called by the `sherlockClaimManager`, but there is no check to ensure that the caller is indeed the authorized contract. This could lead to unauthorized access if the address of `sherlockClaimManager` is compromised.

RECOMMENDED MITIGATION: Implement a modifier to check that the caller is the `sherlockClaimManager` and ensure that the address is set correctly during contract initialization.
```

### VULNERABILITY 4: Lack of Input Validation
```
DETAILED DESCRIPTION: Functions like `enableStakingPeriod` and `disableStakingPeriod` do not validate whether the staking period is reasonable (e.g., not too long or too short). This could lead to unintended consequences if a malicious actor or a bug allows setting an extreme value.

RECOMMENDED MITIGATION: Implement checks to ensure that the staking periods are within a reasonable range (e.g., not less than a minimum threshold and not excessively long).
```

### VULNERABILITY 5: Token Transfer Failures
```
DETAILED DESCRIPTION: The contract does not handle cases where token transfers fail (e.g., in `_transferTokensOut` or `_sendSherRewardsToOwner`). If a transfer fails, it could leave the contract in an inconsistent state.

RECOMMENDED MITIGATION: Ensure that all token transfers are checked for success. If a transfer fails, revert the transaction to maintain consistency in the contract state.
```

### VULNERABILITY 6: Unchecked External Calls
```
DETAILED DESCRIPTION: The contract makes external calls to other contracts (e.g., `yieldStrategy`, `sherDistributionManager`) without checking the return values. If these calls fail, it could lead to unexpected behavior or loss of funds.

RECOMMENDED MITIGATION: Always check the return values of external calls and handle failures appropriately. Consider using `require` statements to enforce successful execution.
```

### VULNERABILITY 7: Emergency Pause Functionality
```
DETAILED DESCRIPTION: While the contract has pause functionality, it does not provide a mechanism for emergency withdrawal of funds in case of a critical vulnerability. If a vulnerability is discovered, the contract owner may not be able to withdraw funds quickly.

RECOMMENDED MITIGATION: Implement an emergency withdrawal function that allows the owner to withdraw all funds to a secure address in case of an emergency, ensuring that the contract can be paused and funds can be secured.
```

### VULNERABILITY 8: Potential Gas Limit Issues
```


[2024-25-08 10:37:56 INFO] **[Seminar Conclusion]**:

 ### VULNERABILITY 1: Reentrancy Attack
```
DETAILED DESCRIPTION: The contract allows external calls to transfer tokens (e.g., in the `_transferTokensOut` function) after state changes (like updating mappings). This can lead to a reentrancy attack where an attacker can call back into the contract before the state is updated, potentially draining funds.

RECOMMENDED MITIGATION: Use the Checks-Effects-Interactions pattern. Ensure that all state changes are made before any external calls. Additionally, consider using a reentrancy guard modifier (e.g., `nonReentrant`) to prevent reentrant calls.
```

### VULNERABILITY 2: Arithmetic Underflow/Overflow
```
DETAILED DESCRIPTION: Although Solidity 0.8.0 and later versions have built-in overflow and underflow checks, there are still areas where arithmetic operations could lead to unexpected results, especially when dealing with shares and balances. For example, if `stakeShares[_id]` is subtracted without checking if it is greater than the amount being subtracted, it could lead to underflow.

RECOMMENDED MITIGATION: Ensure that all arithmetic operations are checked for underflow/overflow conditions. Use SafeMath libraries or ensure that the logic prevents such conditions explicitly.
```

### VULNERABILITY 3: Improper Access Control
```
DETAILED DESCRIPTION: The `payoutClaim` function can only be called by the `sherlockClaimManager`, but there is no check to ensure that the caller is indeed the authorized contract. This could lead to unauthorized access if the address of `sherlockClaimManager` is compromised.

RECOMMENDED MITIGATION: Implement a modifier to check that the caller is the `sherlockClaimManager` and ensure that the address is set correctly during contract initialization.
```

### VULNERABILITY 4: Lack of Input Validation
```
DETAILED DESCRIPTION: Functions like `enableStakingPeriod` and `disableStakingPeriod` do not validate whether the staking period is reasonable (e.g., not too long or too short). This could lead to unintended consequences if a malicious actor or a bug allows setting an extreme value.

RECOMMENDED MITIGATION: Implement checks to ensure that the staking periods are within a reasonable range (e.g., not less than a minimum threshold and not excessively long).
```

### VULNERABILITY 5: Token Transfer Failures
```
DETAILED DESCRIPTION: The contract does not handle cases where token transfers fail (e.g., in `_transferTokensOut` or `_sendSherRewardsToOwner`). If a transfer fails, it could leave the contract in an inconsistent state.

RECOMMENDED MITIGATION: Ensure that all token transfers are checked for success. If a transfer fails, revert the transaction to maintain consistency in the contract state.
```

### VULNERABILITY 6: Unchecked External Calls
```
DETAILED DESCRIPTION: The contract makes external calls to other contracts (e.g., `yieldStrategy`, `sherDistributionManager`) without checking the return values. If these calls fail, it could lead to unexpected behavior or loss of funds.

RECOMMENDED MITIGATION: Always check the return values of external calls and handle failures appropriately. Consider using `require` statements to enforce successful execution.
```

### VULNERABILITY 7: Emergency Pause Functionality
```
DETAILED DESCRIPTION: While the contract has pause functionality, it does not provide a mechanism for emergency withdrawal of funds in case of a critical vulnerability. If a vulnerability is discovered, the contract owner may not be able to withdraw funds quickly.

RECOMMENDED MITIGATION: Implement an emergency withdrawal function that allows the owner to withdraw all funds to a secure address in case of an emergency, ensuring that the contract can be paused and funds can be secured.
```

### VULNERABILITY 8: Potential Gas Limit Issues
```


[2024-25-08 10:37:56 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-25-08 10:37:56 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@openzeppelin/contracts/token/ERC721/ERC721.sol'; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol'; import '@openzeppelin/contracts/security/Pausable.sol'; import './interfaces/ISherlock.sol'; /// @title Sherlock core interface for stakers /// @author Evert Kors // This is the contract that manages staking actions contract Sherlock is ISherlock, ERC721, Ownable, Pausable {   using SafeERC20 for IERC20; // The initial period for a staker to restake/withdraw without being auto-restaked   uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks; // The period during which the reward for restaking an account (after the inital period) grows   uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks; // Anyone who gets auto-restaked is restaked for this period (3 months)   uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks; // The percentage of someone's stake that can be paid to an arb for restaking   uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20% // USDC address   IERC20 public immutable token; // SHER token address   IERC20 public immutable sher; // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not   mapping(uint256 =&gt; bool) public override stakingPeriods; // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked   mapping(uint256 =&gt; uint256) internal lockupEnd_; // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position   mapping(uint256 =&gt; uint256) internal sherRewards_; // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)   mapping(uint256 =&gt; uint256) internal stakeShares; // Key is account, value is the sum of underlying shares of all the NFTs the account owns.   mapping(address =&gt; uint256) internal addressShares; // Total amount of shares that have been issued to all NFT positions   uint256 internal totalStakeShares; // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)   IStrategyManager public override yieldStrategy; // Instances of relevant Sherlock contracts   ISherDistributionManager public override sherDistributionManager;   ISherlockProtocolManager public override sherlockProtocolManager;   ISherlockClaimManager public override sherlockClaimManager; // Address to which nonstaker payments are made   // This will start out as a multi-sig address, then become a contract address later   address public override nonStakersAddress; // Stores the ID of the most recently created NFT   // This variable is incremented by 1 to create a new NFT ID   uint256 internal nftCounter; // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.   constructor(     IERC20 _token, // USDC address     IERC20 _sher, // SHER token address     string memory _name, // Token collection name (see ERC-721 docs)     string memory _symbol, // Token collection symbol (see ERC-721 docs)     IStrategyManager _yieldStrategy, // The active yield strategy contract     ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract     address _nonStakersAddress, // The address to which nonstakers payments go     ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract     ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract     uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for   ) ERC721(_name, _symbol) {     if (address(_token) == address(0)) revert ZeroArgument();     if (address(_sher) == address(0)) revert ZeroArgument();     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (_nonStakersAddress == address(0)) revert ZeroArgument();     if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();     if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument(); token = _token; sher = _sher; yieldStrategy = _yieldStrategy; sherDistributionManager = _sherDistributionManager; nonStakersAddress = _nonStakersAddress; sherlockProtocolManager = _sherlockProtocolManager; sherlockClaimManager = _sherlockClaimManager;  // Enabling the first set of staking periods that were provided in constructor args for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {   enableStakingPeriod(_initialstakingPeriods[i]); }  emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy); emit SherDistributionManagerUpdated(   ISherDistributionManager(address(0)),   _sherDistributionManager ); emit NonStakerAddressUpdated(address(0), _nonStakersAddress); emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager); emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);  } //   // View functions   // // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked   /// @notice View the current lockup end timestamp of _tokenID   /// @return Timestamp when NFT position unlocks   function lockupEnd(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return lockupEnd_[_tokenID];  } // Returns the SHER rewards owed to this position   /// @notice View the current SHER reward of _tokenID   /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup   function sherRewards(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return sherRewards_[_tokenID];  } // Returns the tokens (USDC) owed to a position   /// @notice View the current token balance claimable upon reaching end of the lockup   /// @return Amount of tokens assigned to owner when unstaking position   function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent();     // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers     return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;   } // Returns the tokens (USDC) owed to an address   /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup   /// @return Amount of tokens assigned to owner when unstaking all positions   function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {     if (_staker == address(0)) revert ZeroArgument();     uint256 _totalStakeShares = totalStakeShares;     if (_totalStakeShares == 0) return 0;     // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers     return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;   } // Gets the total amount of tokens (USDC) owed to stakers   // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract   /// @notice View the current TVL for all stakers   /// @return Total amount of tokens staked   /// @dev Adds principal + strategy + premiums   /// @dev Will calculate the most up to date value for each piece   function totalTokenBalanceStakers() public view override returns (uint256) {     return       token.balanceOf(address(this)) +       yieldStrategy.balanceOf() +       sherlockProtocolManager.claimablePremiums();   } //   // Gov functions   // // Allows governance to add a new staking period (4 months, etc.)   /// @notice Allows stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already enabled   function enableStakingPeriod(uint256 _period) public override onlyOwner {     if (_period == 0) revert ZeroArgument();     // Revert if staking period is already active     if (stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to true stakingPeriods[_period] = true; emit StakingPeriodEnabled(_period);  } // Allows governance to remove a staking period (4 months, etc.)   /// @notice Disallow stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already disabled   function disableStakingPeriod(uint256 _period) external override onlyOwner {     // Revert if staking period is already inactive     if (!stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to false stakingPeriods[_period] = false; emit StakingPeriodDisabled(_period);  } // Sets a new contract to be the active SHER distribution manager   /// @notice Update SHER distribution manager contract   /// @param _sherDistributionManager New adddress of the manager   function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)     external     override     onlyOwner   {     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument(); emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager); sherDistributionManager = _sherDistributionManager;  } // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)   /// @notice Remove SHER token rewards   function removeSherDistributionManager() external override onlyOwner {     if (address(sherDistributionManager) == address(0)) revert InvalidConditions(); emit SherDistributionManagerUpdated(   sherDistributionManager,   ISherDistributionManager(address(0)) ); delete sherDistributionManager;  } // Sets a new address for nonstakers payments   /// @notice Update address eligble for non staker rewards from protocol premiums   /// @param _nonStakers Address eligble for non staker rewards   function updateNonStakersAddress(address _nonStakers) external override onlyOwner {     if (address(_nonStakers) == address(0)) revert ZeroArgument();     if (nonStakersAddress == _nonStakers) revert InvalidArgument(); emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers); nonStakersAddress = _nonStakers;  } // Sets a new protocol manager contract   /// @notice Transfer protocol manager implementation address   /// @param _protocolManager new implementation address   function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)     external     override     onlyOwner   {     if (address(_protocolManager) == address(0)) revert ZeroArgument();     if (sherlockProtocolManager == _protocolManager) revert InvalidArgument(); emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager); sherlockProtocolManager = _protocolManager;  } // Sets a new claim manager contract   /// @notice Transfer claim manager role to different address   /// @param _claimManager New address of claim manager   function updateSherlockClaimManager(ISherlockClaimManager _claimManager)     external     override     onlyOwner   {     if (address(_claimManager) == address(0)) revert ZeroArgument();     if (sherlockClaimManager == _claimManager) revert InvalidArgument(); emit ClaimManagerUpdated(sherlockClaimManager, _claimManager); sherlockClaimManager = _claimManager;  } // Sets a new yield strategy manager contract   /// @notice Update yield strategy   /// @param _yieldStrategy News address of the strategy   /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure   function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (yieldStrategy == _yieldStrategy) revert InvalidArgument(); // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason. // In case this happens. We still want the yield strategy to be updated. // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again. try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {   emit YieldStrategyUpdateWithdrawAllError(reason); }  emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy); yieldStrategy = _yieldStrategy;  } // Deposits a chosen amount of tokens (USDC) into the active yield strategy   /// @notice Deposit _amount into active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); // Transfers any tokens owed to stakers from the protocol manager contract to this contract first sherlockProtocolManager.claimPremiumsForStakers(); // Transfers the amount of tokens to the yield strategy contract token.safeTransfer(address(yieldStrategy), _amount); // Deposits all tokens in the yield strategy contract into the actual yield strategy yieldStrategy.deposit();  } // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract   /// @notice Withdraw _amount from active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); yieldStrategy.withdraw(_amount);  } // Withdraws all tokens from the yield strategy back into this contract   /// @notice Withdraw all funds from active strategy   /// @dev gov only   function yieldStrategyWithdrawAll() external override onlyOwner {     yieldStrategy.withdrawAll();   } /// @notice Pause external functions in all contracts   /// @dev A manager can be replaced with the new contract in a paused state   /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused   function pause() external onlyOwner {     _pause();     if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();     // sherDistributionManager can be 0, pause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       !Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.pause();     }     if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();     if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();   } /// @notice Unpause external functions in all contracts   /// @dev A manager can be replaced with the new contract in an unpaused state   /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused   function unpause() external onlyOwner {     _unpause();     if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();     // sherDistributionManager can be 0, unpause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.unpause();     }     if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();     if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();   } //   // Access control functions   // /// @notice Account sum of all underlying posiiton shares for _from and _to   /// @dev this enables the tokenBalanceOfAddress to exist   function _beforeTokenTransfer(     address _from,     address _to,     uint256 _tokenID   ) internal override {     uint256 _stakeShares = stakeShares[_tokenID]; if (_from != address(0)) addressShares[_from] -= _stakeShares; if (_to != address(0)) addressShares[_to] += _stakeShares;  } // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)   // This function is called by the Sherlock claim manager contract if a claim is approved   /// @notice Initiate a payout of _amount to _receiver   /// @param _receiver Receiver of payout   /// @param _amount Amount to send   /// @dev only payout manager should call this   /// @dev should pull money out of strategy   function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {     // Can only be called by the Sherlock claim manager contract     if (msg.sender != address(sherlockClaimManager)) revert Unauthorized(); if (_amount != 0) {   // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)   _transferTokensOut(_receiver, _amount); } emit ClaimPayout(_receiver, _amount);  } //   // Non-access control functions   // // Helper function for initial staking and restaking   // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position   /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds   /// @param amount Amount of tokens to stake   /// @param _period Period of time for which funds get locked   /// @param _id ID for this NFT position   /// @param _receiver Address that will be linked to this position   /// @return _sher Amount of SHER tokens awarded to this position after _period ends   /// @dev _period needs to be whitelisted   function _stake(     uint256 _amount,     uint256 _period,     uint256 _id,     address _receiver   ) internal returns (uint256 _sher) {     // Sets the timestamp at which this position can first be unstaked/restaked     lockupEnd[_id] = block.timestamp + _period; if (address(sherDistributionManager) == address(0)) return 0; // Does not allow restaking of 0 tokens if (_amount == 0) return 0;  // Checks this amount of SHER tokens in this contract before we transfer new ones uint256 before = sher.balanceOf(address(this));  // pullReward() calcs then actually transfers the SHER tokens to this contract // in case this call fails, whole (re)staking transaction fails _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);  // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position uint256 actualAmount = sher.balanceOf(address(this)) - before; if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount); // Assigns the newly created SHER tokens to the current stake position if (_sher != 0) sherRewards_[_id] = _sher;  } // Checks to see if the NFT owner is the caller and that the position is unlockable   function verifyUnlockableByOwner(uint256 _id) internal view {     if (ownerOf(_id) != msg.sender) revert Unauthorized();     if (lockupEnd[_id] &gt; block.timestamp) revert InvalidConditions();   } // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner   function sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards[_id];     if (sherReward == 0) return; // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner sher.safeTransfer(_nftOwner, sherReward); // Deletes the SHER reward mapping for this NFT ID delete sherRewards_[_id];  } // Transfers an amount of tokens to the receiver address   // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)   function _transferTokensOut(address _receiver, uint256 _amount) internal {     // Transfers any premiums owed to stakers from the protocol manager to this contract     sherlockProtocolManager.claimPremiumsForStakers(); // The amount of tokens in this contract uint256 mainBalance = token.balanceOf(address(this));  // If the amount to transfer out is still greater than the amount of tokens in this contract, // Withdraw yield strategy tokens to make up the difference if (_amount &gt; mainBalance) {   yieldStrategy.withdraw(_amount - mainBalance); }  token.safeTransfer(_receiver, _amount);  } // Returns the amount of USDC owed to this amount of stakeShares   function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {     // Finds fraction that the given amount of stakeShares represents of the total     // Then multiplies it by the total amount of tokens (USDC) owed to all stakers     return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;   } // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted   // Also burns the requisite amount of shares associated with this NFT position   // Returns the amount of USDC owed to these shares   function _redeemShares(     uint256 _id,     uint256 _stakeShares,     address _receiver   ) internal returns (uint256 _amount) {     // Returns the amount of USDC owed to this amount of stakeShares     _amount = _redeemSharesCalc(_stakeShares);     // Transfers _amount of tokens to _receiver address     if (_amount != 0) _transferTokensOut(_receiver, _amount); // Subtracts this amount of stakeShares from the NFT position stakeShares[_id] -= _stakeShares; // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding totalStakeShares -= _stakeShares;  } // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager   // Restakes an NFT position (_id) for a given period (_period) and   // Sends any previously earned SHER rewards to the _nftOwner address   function _restake(     uint256 _id,     uint256 _period,     address _nftOwner   ) internal returns (uint256 _sher) {     // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner     // NOTE This function deletes the SHER reward mapping for this NFT ID     _sendSherRewardsToOwner(_id, _nftOwner); // tokenBalanceOf() returns the USDC amount owed to this NFT ID // _stake() restakes that amount of USDC for the period inputted // We use the same ID that we just deleted the SHER rewards mapping for // Resets the lockupEnd mapping and SHER token rewards mapping for this ID // Note stakeShares for this position do not change so no need to update _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);  emit Restaked(_id);  } // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)   /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt   /// @param _amount Amount of tokens to stake   /// @param _period Period of time, in seconds, to lockup your funds   /// @param _receiver Address that will receive the NFT representing the position   /// @return _id ID of the position   /// @return _sher Amount of SHER tokens to be released to this ID after _period ends   /// @dev _period needs to be whitelisted   function initialStake(     uint256 _amount,     uint256 _period,     address _receiver   ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {     if (_amount == 0) revert ZeroArgument();     // Makes sure the period is a whitelisted period     if (!stakingPeriods[_period]) revert InvalidArgument();     if (address(_receiver) == address(0)) revert ZeroArgument();     // Adds 1 to the ID of the last NFT created for the new NFT ID     _id = ++nftCounter; // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action) token.safeTransferFrom(msg.sender, address(this), _amount);  uint256 stakeShares_; uint256 totalStakeShares_ = totalStakeShares; // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares if (totalStakeShares_ != 0)   stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);   // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked else stakeShares_ = _amount;  // Assigns this NFT ID the calc'd amount of stake shares above stakeShares[_id] = stakeShares_; // Adds the newly created stake shares to the total amount of stake shares totalStakeShares += stakeShares_;  // Locks up the USDC amount and calcs the SHER token amount to receive on unstake _sher = _stake(_amount, _period, _id, _receiver);  // This is an ERC-721 function that creates an NFT and sends it to the receiver _safeMint(_receiver, _id);  } // This is how a staker unstakes and cashes out on their position   /// @notice Redeem NFT _id and receive _amount of tokens   /// @param _id TokenID of the position   /// @return _amount Amount of tokens (USDC) owed to NFT ID   /// @dev Only the owner of _id will be able to redeem their position   /// @dev The SHER rewards are sent to the NFT owner   /// @dev Can only be called after lockup _period has ended   function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // This is the ERC-721 function to destroy an NFT (with owner's approval) _burn(_id);  // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC owed to these shares _amount = _redeemShares(_id, stakeShares[_id], msg.sender);  // Sends the SHER tokens associated with this NFT ID to the NFT owner _sendSherRewardsToOwner(_id, msg.sender);  // Removes the unlock deadline associated with this NFT delete lockupEnd_[_id];  } // This is how a staker restakes an expired position   /// @notice Owner restakes position with ID: _id for _period seconds   /// @param _id ID of the position   /// @param _period Period of time, in seconds, to lockup your funds   /// @return _sher Amount of SHER tokens to be released to owner address after _period ends   /// @dev Only the owner of _id will be able to restake their position using this call   /// @dev _period needs to be whitelisted   /// @dev Can only be called after lockup _period has ended   function ownerRestake(uint256 _id, uint256 _period)     external     override     whenNotPaused     returns (uint256 _sher)   {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // Checks to make sure the staking period is a whitelisted one if (!stakingPeriods[_period]) revert InvalidArgument();  // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position _sher = _restake(_id, _period, msg.sender);  } // Calcs the reward (in stake shares) an arb would get for restaking a position   // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb   function calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {     // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)     uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME; // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position if (initialArbTime &gt; block.timestamp) return (0, false);  // The max rewards (as a % of the position's shares) for the arb are available at this timestamp uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;  // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100% uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;  // Scaled by 10**18 // Represents the max amount of stake shares that an arb could get from restaking this position uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];  // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled return (   ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,   true );  } /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position   /// @return profit How much profit an arb would make in USDC   /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)   function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {     // Returns the stake shares that an arb would get, and whether the position can currently be arbed     // profit variable is used to store the amount of shares     (profit, able) = _calcSharesForArbRestake(_id);     // Calculates the tokens (USDC) represented by that amount of stake shares     // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit     profit = _redeemSharesCalc(profit);   } /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)   /// @param _id ID of the position   /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup   /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function   /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)   /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)   /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)   function arbRestake(uint256 _id)     external     override     whenNotPaused     returns (uint256 _sher, uint256 _arbReward)   {     address nftOwner = ownerOf(_id); // Returns the stake shares that an arb would get, and whether the position can currently be arbed (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id); // Revert if not able to be arbed if (!able) revert InvalidConditions();  // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC paid to the arbitrager _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);  // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months) // Sends previously earned SHER rewards to the NFT owner address _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);  emit ArbRestaked(_id, _arbReward);  } } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' 1'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-25-08 10:37:56 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@openzeppelin/contracts/token/ERC721/ERC721.sol'; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol'; import '@openzeppelin/contracts/security/Pausable.sol'; import './interfaces/ISherlock.sol'; /// @title Sherlock core interface for stakers /// @author Evert Kors // This is the contract that manages staking actions contract Sherlock is ISherlock, ERC721, Ownable, Pausable {   using SafeERC20 for IERC20; // The initial period for a staker to restake/withdraw without being auto-restaked   uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks; // The period during which the reward for restaking an account (after the inital period) grows   uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks; // Anyone who gets auto-restaked is restaked for this period (3 months)   uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks; // The percentage of someone's stake that can be paid to an arb for restaking   uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20% // USDC address   IERC20 public immutable token; // SHER token address   IERC20 public immutable sher; // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not   mapping(uint256 =&gt; bool) public override stakingPeriods; // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked   mapping(uint256 =&gt; uint256) internal lockupEnd_; // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position   mapping(uint256 =&gt; uint256) internal sherRewards_; // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)   mapping(uint256 =&gt; uint256) internal stakeShares; // Key is account, value is the sum of underlying shares of all the NFTs the account owns.   mapping(address =&gt; uint256) internal addressShares; // Total amount of shares that have been issued to all NFT positions   uint256 internal totalStakeShares; // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)   IStrategyManager public override yieldStrategy; // Instances of relevant Sherlock contracts   ISherDistributionManager public override sherDistributionManager;   ISherlockProtocolManager public override sherlockProtocolManager;   ISherlockClaimManager public override sherlockClaimManager; // Address to which nonstaker payments are made   // This will start out as a multi-sig address, then become a contract address later   address public override nonStakersAddress; // Stores the ID of the most recently created NFT   // This variable is incremented by 1 to create a new NFT ID   uint256 internal nftCounter; // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.   constructor(     IERC20 _token, // USDC address     IERC20 _sher, // SHER token address     string memory _name, // Token collection name (see ERC-721 docs)     string memory _symbol, // Token collection symbol (see ERC-721 docs)     IStrategyManager _yieldStrategy, // The active yield strategy contract     ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract     address _nonStakersAddress, // The address to which nonstakers payments go     ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract     ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract     uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for   ) ERC721(_name, _symbol) {     if (address(_token) == address(0)) revert ZeroArgument();     if (address(_sher) == address(0)) revert ZeroArgument();     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (_nonStakersAddress == address(0)) revert ZeroArgument();     if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();     if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument(); token = _token; sher = _sher; yieldStrategy = _yieldStrategy; sherDistributionManager = _sherDistributionManager; nonStakersAddress = _nonStakersAddress; sherlockProtocolManager = _sherlockProtocolManager; sherlockClaimManager = _sherlockClaimManager;  // Enabling the first set of staking periods that were provided in constructor args for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {   enableStakingPeriod(_initialstakingPeriods[i]); }  emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy); emit SherDistributionManagerUpdated(   ISherDistributionManager(address(0)),   _sherDistributionManager ); emit NonStakerAddressUpdated(address(0), _nonStakersAddress); emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager); emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);  } //   // View functions   // // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked   /// @notice View the current lockup end timestamp of _tokenID   /// @return Timestamp when NFT position unlocks   function lockupEnd(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return lockupEnd_[_tokenID];  } // Returns the SHER rewards owed to this position   /// @notice View the current SHER reward of _tokenID   /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup   function sherRewards(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return sherRewards_[_tokenID];  } // Returns the tokens (USDC) owed to a position   /// @notice View the current token balance claimable upon reaching end of the lockup   /// @return Amount of tokens assigned to owner when unstaking position   function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent();     // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers     return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;   } // Returns the tokens (USDC) owed to an address   /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup   /// @return Amount of tokens assigned to owner when unstaking all positions   function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {     if (_staker == address(0)) revert ZeroArgument();     uint256 _totalStakeShares = totalStakeShares;     if (_totalStakeShares == 0) return 0;     // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers     return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;   } // Gets the total amount of tokens (USDC) owed to stakers   // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract   /// @notice View the current TVL for all stakers   /// @return Total amount of tokens staked   /// @dev Adds principal + strategy + premiums   /// @dev Will calculate the most up to date value for each piece   function totalTokenBalanceStakers() public view override returns (uint256) {     return       token.balanceOf(address(this)) +       yieldStrategy.balanceOf() +       sherlockProtocolManager.claimablePremiums();   } //   // Gov functions   // // Allows governance to add a new staking period (4 months, etc.)   /// @notice Allows stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already enabled   function enableStakingPeriod(uint256 _period) public override onlyOwner {     if (_period == 0) revert ZeroArgument();     // Revert if staking period is already active     if (stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to true stakingPeriods[_period] = true; emit StakingPeriodEnabled(_period);  } // Allows governance to remove a staking period (4 months, etc.)   /// @notice Disallow stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already disabled   function disableStakingPeriod(uint256 _period) external override onlyOwner {     // Revert if staking period is already inactive     if (!stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to false stakingPeriods[_period] = false; emit StakingPeriodDisabled(_period);  } // Sets a new contract to be the active SHER distribution manager   /// @notice Update SHER distribution manager contract   /// @param _sherDistributionManager New adddress of the manager   function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)     external     override     onlyOwner   {     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument(); emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager); sherDistributionManager = _sherDistributionManager;  } // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)   /// @notice Remove SHER token rewards   function removeSherDistributionManager() external override onlyOwner {     if (address(sherDistributionManager) == address(0)) revert InvalidConditions(); emit SherDistributionManagerUpdated(   sherDistributionManager,   ISherDistributionManager(address(0)) ); delete sherDistributionManager;  } // Sets a new address for nonstakers payments   /// @notice Update address eligble for non staker rewards from protocol premiums   /// @param _nonStakers Address eligble for non staker rewards   function updateNonStakersAddress(address _nonStakers) external override onlyOwner {     if (address(_nonStakers) == address(0)) revert ZeroArgument();     if (nonStakersAddress == _nonStakers) revert InvalidArgument(); emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers); nonStakersAddress = _nonStakers;  } // Sets a new protocol manager contract   /// @notice Transfer protocol manager implementation address   /// @param _protocolManager new implementation address   function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)     external     override     onlyOwner   {     if (address(_protocolManager) == address(0)) revert ZeroArgument();     if (sherlockProtocolManager == _protocolManager) revert InvalidArgument(); emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager); sherlockProtocolManager = _protocolManager;  } // Sets a new claim manager contract   /// @notice Transfer claim manager role to different address   /// @param _claimManager New address of claim manager   function updateSherlockClaimManager(ISherlockClaimManager _claimManager)     external     override     onlyOwner   {     if (address(_claimManager) == address(0)) revert ZeroArgument();     if (sherlockClaimManager == _claimManager) revert InvalidArgument(); emit ClaimManagerUpdated(sherlockClaimManager, _claimManager); sherlockClaimManager = _claimManager;  } // Sets a new yield strategy manager contract   /// @notice Update yield strategy   /// @param _yieldStrategy News address of the strategy   /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure   function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (yieldStrategy == _yieldStrategy) revert InvalidArgument(); // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason. // In case this happens. We still want the yield strategy to be updated. // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again. try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {   emit YieldStrategyUpdateWithdrawAllError(reason); }  emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy); yieldStrategy = _yieldStrategy;  } // Deposits a chosen amount of tokens (USDC) into the active yield strategy   /// @notice Deposit _amount into active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); // Transfers any tokens owed to stakers from the protocol manager contract to this contract first sherlockProtocolManager.claimPremiumsForStakers(); // Transfers the amount of tokens to the yield strategy contract token.safeTransfer(address(yieldStrategy), _amount); // Deposits all tokens in the yield strategy contract into the actual yield strategy yieldStrategy.deposit();  } // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract   /// @notice Withdraw _amount from active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); yieldStrategy.withdraw(_amount);  } // Withdraws all tokens from the yield strategy back into this contract   /// @notice Withdraw all funds from active strategy   /// @dev gov only   function yieldStrategyWithdrawAll() external override onlyOwner {     yieldStrategy.withdrawAll();   } /// @notice Pause external functions in all contracts   /// @dev A manager can be replaced with the new contract in a paused state   /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused   function pause() external onlyOwner {     _pause();     if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();     // sherDistributionManager can be 0, pause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       !Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.pause();     }     if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();     if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();   } /// @notice Unpause external functions in all contracts   /// @dev A manager can be replaced with the new contract in an unpaused state   /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused   function unpause() external onlyOwner {     _unpause();     if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();     // sherDistributionManager can be 0, unpause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.unpause();     }     if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();     if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();   } //   // Access control functions   // /// @notice Account sum of all underlying posiiton shares for _from and _to   /// @dev this enables the tokenBalanceOfAddress to exist   function _beforeTokenTransfer(     address _from,     address _to,     uint256 _tokenID   ) internal override {     uint256 _stakeShares = stakeShares[_tokenID]; if (_from != address(0)) addressShares[_from] -= _stakeShares; if (_to != address(0)) addressShares[_to] += _stakeShares;  } // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)   // This function is called by the Sherlock claim manager contract if a claim is approved   /// @notice Initiate a payout of _amount to _receiver   /// @param _receiver Receiver of payout   /// @param _amount Amount to send   /// @dev only payout manager should call this   /// @dev should pull money out of strategy   function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {     // Can only be called by the Sherlock claim manager contract     if (msg.sender != address(sherlockClaimManager)) revert Unauthorized(); if (_amount != 0) {   // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)   _transferTokensOut(_receiver, _amount); } emit ClaimPayout(_receiver, _amount);  } //   // Non-access control functions   // // Helper function for initial staking and restaking   // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position   /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds   /// @param amount Amount of tokens to stake   /// @param _period Period of time for which funds get locked   /// @param _id ID for this NFT position   /// @param _receiver Address that will be linked to this position   /// @return _sher Amount of SHER tokens awarded to this position after _period ends   /// @dev _period needs to be whitelisted   function _stake(     uint256 _amount,     uint256 _period,     uint256 _id,     address _receiver   ) internal returns (uint256 _sher) {     // Sets the timestamp at which this position can first be unstaked/restaked     lockupEnd[_id] = block.timestamp + _period; if (address(sherDistributionManager) == address(0)) return 0; // Does not allow restaking of 0 tokens if (_amount == 0) return 0;  // Checks this amount of SHER tokens in this contract before we transfer new ones uint256 before = sher.balanceOf(address(this));  // pullReward() calcs then actually transfers the SHER tokens to this contract // in case this call fails, whole (re)staking transaction fails _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);  // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position uint256 actualAmount = sher.balanceOf(address(this)) - before; if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount); // Assigns the newly created SHER tokens to the current stake position if (_sher != 0) sherRewards_[_id] = _sher;  } // Checks to see if the NFT owner is the caller and that the position is unlockable   function verifyUnlockableByOwner(uint256 _id) internal view {     if (ownerOf(_id) != msg.sender) revert Unauthorized();     if (lockupEnd[_id] &gt; block.timestamp) revert InvalidConditions();   } // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner   function sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards[_id];     if (sherReward == 0) return; // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner sher.safeTransfer(_nftOwner, sherReward); // Deletes the SHER reward mapping for this NFT ID delete sherRewards_[_id];  } // Transfers an amount of tokens to the receiver address   // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)   function _transferTokensOut(address _receiver, uint256 _amount) internal {     // Transfers any premiums owed to stakers from the protocol manager to this contract     sherlockProtocolManager.claimPremiumsForStakers(); // The amount of tokens in this contract uint256 mainBalance = token.balanceOf(address(this));  // If the amount to transfer out is still greater than the amount of tokens in this contract, // Withdraw yield strategy tokens to make up the difference if (_amount &gt; mainBalance) {   yieldStrategy.withdraw(_amount - mainBalance); }  token.safeTransfer(_receiver, _amount);  } // Returns the amount of USDC owed to this amount of stakeShares   function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {     // Finds fraction that the given amount of stakeShares represents of the total     // Then multiplies it by the total amount of tokens (USDC) owed to all stakers     return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;   } // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted   // Also burns the requisite amount of shares associated with this NFT position   // Returns the amount of USDC owed to these shares   function _redeemShares(     uint256 _id,     uint256 _stakeShares,     address _receiver   ) internal returns (uint256 _amount) {     // Returns the amount of USDC owed to this amount of stakeShares     _amount = _redeemSharesCalc(_stakeShares);     // Transfers _amount of tokens to _receiver address     if (_amount != 0) _transferTokensOut(_receiver, _amount); // Subtracts this amount of stakeShares from the NFT position stakeShares[_id] -= _stakeShares; // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding totalStakeShares -= _stakeShares;  } // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager   // Restakes an NFT position (_id) for a given period (_period) and   // Sends any previously earned SHER rewards to the _nftOwner address   function _restake(     uint256 _id,     uint256 _period,     address _nftOwner   ) internal returns (uint256 _sher) {     // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner     // NOTE This function deletes the SHER reward mapping for this NFT ID     _sendSherRewardsToOwner(_id, _nftOwner); // tokenBalanceOf() returns the USDC amount owed to this NFT ID // _stake() restakes that amount of USDC for the period inputted // We use the same ID that we just deleted the SHER rewards mapping for // Resets the lockupEnd mapping and SHER token rewards mapping for this ID // Note stakeShares for this position do not change so no need to update _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);  emit Restaked(_id);  } // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)   /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt   /// @param _amount Amount of tokens to stake   /// @param _period Period of time, in seconds, to lockup your funds   /// @param _receiver Address that will receive the NFT representing the position   /// @return _id ID of the position   /// @return _sher Amount of SHER tokens to be released to this ID after _period ends   /// @dev _period needs to be whitelisted   function initialStake(     uint256 _amount,     uint256 _period,     address _receiver   ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {     if (_amount == 0) revert ZeroArgument();     // Makes sure the period is a whitelisted period     if (!stakingPeriods[_period]) revert InvalidArgument();     if (address(_receiver) == address(0)) revert ZeroArgument();     // Adds 1 to the ID of the last NFT created for the new NFT ID     _id = ++nftCounter; // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action) token.safeTransferFrom(msg.sender, address(this), _amount);  uint256 stakeShares_; uint256 totalStakeShares_ = totalStakeShares; // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares if (totalStakeShares_ != 0)   stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);   // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked else stakeShares_ = _amount;  // Assigns this NFT ID the calc'd amount of stake shares above stakeShares[_id] = stakeShares_; // Adds the newly created stake shares to the total amount of stake shares totalStakeShares += stakeShares_;  // Locks up the USDC amount and calcs the SHER token amount to receive on unstake _sher = _stake(_amount, _period, _id, _receiver);  // This is an ERC-721 function that creates an NFT and sends it to the receiver _safeMint(_receiver, _id);  } // This is how a staker unstakes and cashes out on their position   /// @notice Redeem NFT _id and receive _amount of tokens   /// @param _id TokenID of the position   /// @return _amount Amount of tokens (USDC) owed to NFT ID   /// @dev Only the owner of _id will be able to redeem their position   /// @dev The SHER rewards are sent to the NFT owner   /// @dev Can only be called after lockup _period has ended   function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // This is the ERC-721 function to destroy an NFT (with owner's approval) _burn(_id);  // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC owed to these shares _amount = _redeemShares(_id, stakeShares[_id], msg.sender);  // Sends the SHER tokens associated with this NFT ID to the NFT owner _sendSherRewardsToOwner(_id, msg.sender);  // Removes the unlock deadline associated with this NFT delete lockupEnd_[_id];  } // This is how a staker restakes an expired position   /// @notice Owner restakes position with ID: _id for _period seconds   /// @param _id ID of the position   /// @param _period Period of time, in seconds, to lockup your funds   /// @return _sher Amount of SHER tokens to be released to owner address after _period ends   /// @dev Only the owner of _id will be able to restake their position using this call   /// @dev _period needs to be whitelisted   /// @dev Can only be called after lockup _period has ended   function ownerRestake(uint256 _id, uint256 _period)     external     override     whenNotPaused     returns (uint256 _sher)   {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // Checks to make sure the staking period is a whitelisted one if (!stakingPeriods[_period]) revert InvalidArgument();  // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position _sher = _restake(_id, _period, msg.sender);  } // Calcs the reward (in stake shares) an arb would get for restaking a position   // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb   function calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {     // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)     uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME; // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position if (initialArbTime &gt; block.timestamp) return (0, false);  // The max rewards (as a % of the position's shares) for the arb are available at this timestamp uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;  // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100% uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;  // Scaled by 10**18 // Represents the max amount of stake shares that an arb could get from restaking this position uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];  // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled return (   ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,   true );  } /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position   /// @return profit How much profit an arb would make in USDC   /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)   function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {     // Returns the stake shares that an arb would get, and whether the position can currently be arbed     // profit variable is used to store the amount of shares     (profit, able) = _calcSharesForArbRestake(_id);     // Calculates the tokens (USDC) represented by that amount of stake shares     // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit     profit = _redeemSharesCalc(profit);   } /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)   /// @param _id ID of the position   /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup   /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function   /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)   /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)   /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)   function arbRestake(uint256 _id)     external     override     whenNotPaused     returns (uint256 _sher, uint256 _arbReward)   {     address nftOwner = ownerOf(_id); // Returns the stake shares that an arb would get, and whether the position can currently be arbed (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id); // Revert if not able to be arbed if (!able) revert InvalidConditions();  // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC paid to the arbitrager _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);  // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months) // Sends previously earned SHER rewards to the NFT owner address _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);  emit ArbRestaked(_id, _arbReward);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-25-08 10:37:56 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';

import './interfaces/ISherlock.sol';

/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions

contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;

  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;

  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;

  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;

  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%

  // USDC address
  IERC20 public immutable token;

  // SHER token address
  IERC20 public immutable sher;

  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;

  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;

  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;

  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;

  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;

  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;

  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;

  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;

  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;

  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;

  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();

    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;

    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }

    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }

  //
  // View functions
  //

  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return lockupEnd_[_tokenID];
  }

  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return sherRewards_[_tokenID];
  }

  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }

  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }

  //
  // Gov functions
  //

  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }

  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }

  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();

    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }

  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();

    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }

  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();

    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }

  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();

    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }

  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();

    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }

  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();

    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }

    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }

  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }

  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    yieldStrategy.withdraw(_amount);
  }

  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }

  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }

  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }

  //
  // Access control functions
  //

  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];

    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }

  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();

    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }

  //
  // Non-access control functions
  //

  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;

    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;

    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));

    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);

    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }

  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }

  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;

    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }

  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();

    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));

    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }

    token.safeTransfer(_receiver, _amount);
  }

  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);

    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }

  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);

    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);

    emit Restaked(_id);
  }

  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;

    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);

    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;

    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;

    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);

    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }

  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);

    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);

    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);

    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }

  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }

  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;

    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);

    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;

    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;

    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];

    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }

  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }

  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);

    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();

    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);

    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);

    emit ArbRestaked(_id, _arbReward);
  }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-25-08 10:38:03 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-25-08 10:38:03 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 7841
completion_tokens: 810
total_tokens: 8651
cost: $-1.000000


[2024-25-08 10:38:03 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';

import './interfaces/ISherlock.sol';

/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions

contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;

  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;

  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;

  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;

  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%

  // USDC address
  IERC20 public immutable token;

  // SHER token address
  IERC20 public immutable sher;

  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;

  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;

  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;

  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;

  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;

  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;

  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;

  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;

  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;

  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;

  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();

    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;

    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }

    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }

  //
  // View functions
  //

  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return lockupEnd_[_tokenID];
  }

  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return sherRewards_[_tokenID];
  }

  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }

  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }

  //
  // Gov functions
  //

  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }

  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }

  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();

    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }

  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();

    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }

  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();

    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }

  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();

    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }

  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();

    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }

  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();

    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }

    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }

  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }

  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    yieldStrategy.withdraw(_amount);
  }

  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }

  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }

  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }

  //
  // Access control functions
  //

  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];

    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }

  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();

    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }

  //
  // Non-access control functions
  //

  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;

    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;

    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));

    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);

    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }

  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }

  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;

    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }

  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();

    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));

    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }

    token.safeTransfer(_receiver, _amount);
  }

  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);

    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }

  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);

    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);

    emit Restaked(_id);
  }

  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;

    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);

    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;

    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;

    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);

    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }

  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);

    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);

    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);

    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }

  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }

  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;

    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);

    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;

    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;

    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];

    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }

  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }

  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);

    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();

    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);

    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);

    emit ArbRestaked(_id, _arbReward);
  }
}
.]

### Summary of Security Vulnerabilities in the Sherlock Smart Contract

1. **Reentrancy Risk**: 
   - The contract does not implement a reentrancy guard, which could allow malicious actors to exploit functions that transfer tokens or call external contracts, potentially leading to unexpected behavior or loss of funds.

2. **Access Control Issues**:
   - The `payoutClaim` function can only be called by the `sherlockClaimManager`, but there is no explicit check to ensure that the `sherlockClaimManager` is set correctly. If it is not set, this function could be called by anyone, leading to unauthorized payouts.
   - Functions that update critical addresses (like `updateSherDistributionManager`, `updateNonStakersAddress`, etc.) are only protected by the `onlyOwner` modifier. If the owners private key is compromised, an attacker could change these addresses maliciously.

3. **Lack of Input Validation**:
   - Several functions do not validate the input parameters thoroughly. For example, in functions like `enableStakingPeriod`, there is a check for zero but no checks for excessively large values that could lead to overflow or unintended consequences.

4. **Token Transfer Failures**:
   - The contract relies on the assumption that token transfers will always succeed. If a transfer fails (e.g., due to insufficient balance or allowance), the contract does not handle this gracefully, which could lead to funds being locked or lost.

5. **Potential for Denial of Service (DoS)**:
   - The `yieldStrategyDeposit` and `yieldStrategyWithdraw` functions could be susceptible to DoS attacks if the underlying yield strategy contract fails or is paused, preventing the contract from functioning as intended.

6. **Gas Limit Issues**:
   - The contract has several loops (e.g., in the constructor for enabling staking periods) that could run into gas limit issues if a large number of staking periods are provided, potentially causing the contract to fail during deployment.

7. **Lack of Event Emissions**:
   - Certain state-changing functions do not emit events, which could hinder tracking and debugging of contract interactions. For example, functions that modify staking periods or update addresses should emit events to provide transparency.

8. **Uncontrolled External Calls**:
   - The contract makes external calls to other contracts (like `yieldStrategy`, `sherDistributionManager`, etc.) without proper checks on their state or behavior, which could lead to unexpected results if those contracts are compromised or behave maliciously.

### Comprehensive Analysis Report

The Sherlock smart contract exhibits several security vulnerabilities that could potentially be exploited by malicious actors. The most pressing concerns include the lack of reentrancy protection, which could allow attackers to manipulate state during token transfers, and insufficient access control measures that could lead to unauthorized actions if the owner's key is compromised.

Moreover, the reliance on external contracts without adequate checks poses a risk of unexpected failures, which could lead to denial of service or loss of funds. The absence of thorough input validation and event emissions further complicates the contract's reliability and transparency.

To mitigate these vulnerabilities, it is recommended to implement the following measures:

- **Reentrancy Guard**: Introduce a reentrancy guard to critical functions that involve external calls or token transfers.
- **Enhanced Access Control**: Implement multi-signature wallets for critical functions and ensure that all external calls are validated.
- **Input Validation**: Add checks for input parameters to prevent overflow and ensure they are within acceptable limits.
- **Error Handling for Token Transfers**: Implement checks for the success of token transfers and handle failures gracefully.
- **Event Emissions**: Ensure that all state-changing functions emit relevant events for better tracking and debugging.
- **Gas Limit Considerations**: Review loops and recursive calls to ensure they do not exceed gas limits, especially during contract deployment.

By addressing these vulnerabilities, the security and reliability of the Sherlock smart contract can be significantly enhanced, providing a safer environment for users and stakeholders.

[2024-25-08 10:38:03 INFO] **[Seminar Conclusion]**:

 ### Summary of Security Vulnerabilities in the Sherlock Smart Contract

1. **Reentrancy Risk**: 
   - The contract does not implement a reentrancy guard, which could allow malicious actors to exploit functions that transfer tokens or call external contracts, potentially leading to unexpected behavior or loss of funds.

2. **Access Control Issues**:
   - The `payoutClaim` function can only be called by the `sherlockClaimManager`, but there is no explicit check to ensure that the `sherlockClaimManager` is set correctly. If it is not set, this function could be called by anyone, leading to unauthorized payouts.
   - Functions that update critical addresses (like `updateSherDistributionManager`, `updateNonStakersAddress`, etc.) are only protected by the `onlyOwner` modifier. If the owners private key is compromised, an attacker could change these addresses maliciously.

3. **Lack of Input Validation**:
   - Several functions do not validate the input parameters thoroughly. For example, in functions like `enableStakingPeriod`, there is a check for zero but no checks for excessively large values that could lead to overflow or unintended consequences.

4. **Token Transfer Failures**:
   - The contract relies on the assumption that token transfers will always succeed. If a transfer fails (e.g., due to insufficient balance or allowance), the contract does not handle this gracefully, which could lead to funds being locked or lost.

5. **Potential for Denial of Service (DoS)**:
   - The `yieldStrategyDeposit` and `yieldStrategyWithdraw` functions could be susceptible to DoS attacks if the underlying yield strategy contract fails or is paused, preventing the contract from functioning as intended.

6. **Gas Limit Issues**:
   - The contract has several loops (e.g., in the constructor for enabling staking periods) that could run into gas limit issues if a large number of staking periods are provided, potentially causing the contract to fail during deployment.

7. **Lack of Event Emissions**:
   - Certain state-changing functions do not emit events, which could hinder tracking and debugging of contract interactions. For example, functions that modify staking periods or update addresses should emit events to provide transparency.

8. **Uncontrolled External Calls**:
   - The contract makes external calls to other contracts (like `yieldStrategy`, `sherDistributionManager`, etc.) without proper checks on their state or behavior, which could lead to unexpected results if those contracts are compromised or behave maliciously.

### Comprehensive Analysis Report

The Sherlock smart contract exhibits several security vulnerabilities that could potentially be exploited by malicious actors. The most pressing concerns include the lack of reentrancy protection, which could allow attackers to manipulate state during token transfers, and insufficient access control measures that could lead to unauthorized actions if the owner's key is compromised.

Moreover, the reliance on external contracts without adequate checks poses a risk of unexpected failures, which could lead to denial of service or loss of funds. The absence of thorough input validation and event emissions further complicates the contract's reliability and transparency.

To mitigate these vulnerabilities, it is recommended to implement the following measures:

- **Reentrancy Guard**: Introduce a reentrancy guard to critical functions that involve external calls or token transfers.
- **Enhanced Access Control**: Implement multi-signature wallets for critical functions and ensure that all external calls are validated.
- **Input Validation**: Add checks for input parameters to prevent overflow and ensure they are within acceptable limits.
- **Error Handling for Token Transfers**: Implement checks for the success of token transfers and handle failures gracefully.
- **Event Emissions**: Ensure that all state-changing functions emit relevant events for better tracking and debugging.
- **Gas Limit Considerations**: Review loops and recursive calls to ensure they do not exceed gas limits, especially during contract deployment.

By addressing these vulnerabilities, the security and reliability of the Sherlock smart contract can be significantly enhanced, providing a safer environment for users and stakeholders.

[2024-25-08 10:38:06 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@openzeppelin/contracts/token/ERC721/ERC721.sol'; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol'; import '@openzeppelin/contracts/security/Pausable.sol'; import './interfaces/ISherlock.sol'; /// @title Sherlock core interface for stakers /// @author Evert Kors // This is the contract that manages staking actions contract Sherlock is ISherlock, ERC721, Ownable, Pausable {   using SafeERC20 for IERC20; // The initial period for a staker to restake/withdraw without being auto-restaked   uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks; // The period during which the reward for restaking an account (after the inital period) grows   uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks; // Anyone who gets auto-restaked is restaked for this period (3 months)   uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks; // The percentage of someone's stake that can be paid to an arb for restaking   uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20% // USDC address   IERC20 public immutable token; // SHER token address   IERC20 public immutable sher; // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not   mapping(uint256 =&gt; bool) public override stakingPeriods; // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked   mapping(uint256 =&gt; uint256) internal lockupEnd_; // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position   mapping(uint256 =&gt; uint256) internal sherRewards_; // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)   mapping(uint256 =&gt; uint256) internal stakeShares; // Key is account, value is the sum of underlying shares of all the NFTs the account owns.   mapping(address =&gt; uint256) internal addressShares; // Total amount of shares that have been issued to all NFT positions   uint256 internal totalStakeShares; // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)   IStrategyManager public override yieldStrategy; // Instances of relevant Sherlock contracts   ISherDistributionManager public override sherDistributionManager;   ISherlockProtocolManager public override sherlockProtocolManager;   ISherlockClaimManager public override sherlockClaimManager; // Address to which nonstaker payments are made   // This will start out as a multi-sig address, then become a contract address later   address public override nonStakersAddress; // Stores the ID of the most recently created NFT   // This variable is incremented by 1 to create a new NFT ID   uint256 internal nftCounter; // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.   constructor(     IERC20 _token, // USDC address     IERC20 _sher, // SHER token address     string memory _name, // Token collection name (see ERC-721 docs)     string memory _symbol, // Token collection symbol (see ERC-721 docs)     IStrategyManager _yieldStrategy, // The active yield strategy contract     ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract     address _nonStakersAddress, // The address to which nonstakers payments go     ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract     ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract     uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for   ) ERC721(_name, _symbol) {     if (address(_token) == address(0)) revert ZeroArgument();     if (address(_sher) == address(0)) revert ZeroArgument();     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (_nonStakersAddress == address(0)) revert ZeroArgument();     if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();     if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument(); token = _token; sher = _sher; yieldStrategy = _yieldStrategy; sherDistributionManager = _sherDistributionManager; nonStakersAddress = _nonStakersAddress; sherlockProtocolManager = _sherlockProtocolManager; sherlockClaimManager = _sherlockClaimManager;  // Enabling the first set of staking periods that were provided in constructor args for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {   enableStakingPeriod(_initialstakingPeriods[i]); }  emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy); emit SherDistributionManagerUpdated(   ISherDistributionManager(address(0)),   _sherDistributionManager ); emit NonStakerAddressUpdated(address(0), _nonStakersAddress); emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager); emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);  } //   // View functions   // // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked   /// @notice View the current lockup end timestamp of _tokenID   /// @return Timestamp when NFT position unlocks   function lockupEnd(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return lockupEnd_[_tokenID];  } // Returns the SHER rewards owed to this position   /// @notice View the current SHER reward of _tokenID   /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup   function sherRewards(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return sherRewards_[_tokenID];  } // Returns the tokens (USDC) owed to a position   /// @notice View the current token balance claimable upon reaching end of the lockup   /// @return Amount of tokens assigned to owner when unstaking position   function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent();     // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers     return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;   } // Returns the tokens (USDC) owed to an address   /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup   /// @return Amount of tokens assigned to owner when unstaking all positions   function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {     if (_staker == address(0)) revert ZeroArgument();     uint256 _totalStakeShares = totalStakeShares;     if (_totalStakeShares == 0) return 0;     // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers     return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;   } // Gets the total amount of tokens (USDC) owed to stakers   // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract   /// @notice View the current TVL for all stakers   /// @return Total amount of tokens staked   /// @dev Adds principal + strategy + premiums   /// @dev Will calculate the most up to date value for each piece   function totalTokenBalanceStakers() public view override returns (uint256) {     return       token.balanceOf(address(this)) +       yieldStrategy.balanceOf() +       sherlockProtocolManager.claimablePremiums();   } //   // Gov functions   // // Allows governance to add a new staking period (4 months, etc.)   /// @notice Allows stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already enabled   function enableStakingPeriod(uint256 _period) public override onlyOwner {     if (_period == 0) revert ZeroArgument();     // Revert if staking period is already active     if (stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to true stakingPeriods[_period] = true; emit StakingPeriodEnabled(_period);  } // Allows governance to remove a staking period (4 months, etc.)   /// @notice Disallow stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already disabled   function disableStakingPeriod(uint256 _period) external override onlyOwner {     // Revert if staking period is already inactive     if (!stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to false stakingPeriods[_period] = false; emit StakingPeriodDisabled(_period);  } // Sets a new contract to be the active SHER distribution manager   /// @notice Update SHER distribution manager contract   /// @param _sherDistributionManager New adddress of the manager   function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)     external     override     onlyOwner   {     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument(); emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager); sherDistributionManager = _sherDistributionManager;  } // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)   /// @notice Remove SHER token rewards   function removeSherDistributionManager() external override onlyOwner {     if (address(sherDistributionManager) == address(0)) revert InvalidConditions(); emit SherDistributionManagerUpdated(   sherDistributionManager,   ISherDistributionManager(address(0)) ); delete sherDistributionManager;  } // Sets a new address for nonstakers payments   /// @notice Update address eligble for non staker rewards from protocol premiums   /// @param _nonStakers Address eligble for non staker rewards   function updateNonStakersAddress(address _nonStakers) external override onlyOwner {     if (address(_nonStakers) == address(0)) revert ZeroArgument();     if (nonStakersAddress == _nonStakers) revert InvalidArgument(); emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers); nonStakersAddress = _nonStakers;  } // Sets a new protocol manager contract   /// @notice Transfer protocol manager implementation address   /// @param _protocolManager new implementation address   function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)     external     override     onlyOwner   {     if (address(_protocolManager) == address(0)) revert ZeroArgument();     if (sherlockProtocolManager == _protocolManager) revert InvalidArgument(); emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager); sherlockProtocolManager = _protocolManager;  } // Sets a new claim manager contract   /// @notice Transfer claim manager role to different address   /// @param _claimManager New address of claim manager   function updateSherlockClaimManager(ISherlockClaimManager _claimManager)     external     override     onlyOwner   {     if (address(_claimManager) == address(0)) revert ZeroArgument();     if (sherlockClaimManager == _claimManager) revert InvalidArgument(); emit ClaimManagerUpdated(sherlockClaimManager, _claimManager); sherlockClaimManager = _claimManager;  } // Sets a new yield strategy manager contract   /// @notice Update yield strategy   /// @param _yieldStrategy News address of the strategy   /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure   function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (yieldStrategy == _yieldStrategy) revert InvalidArgument(); // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason. // In case this happens. We still want the yield strategy to be updated. // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again. try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {   emit YieldStrategyUpdateWithdrawAllError(reason); }  emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy); yieldStrategy = _yieldStrategy;  } // Deposits a chosen amount of tokens (USDC) into the active yield strategy   /// @notice Deposit _amount into active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); // Transfers any tokens owed to stakers from the protocol manager contract to this contract first sherlockProtocolManager.claimPremiumsForStakers(); // Transfers the amount of tokens to the yield strategy contract token.safeTransfer(address(yieldStrategy), _amount); // Deposits all tokens in the yield strategy contract into the actual yield strategy yieldStrategy.deposit();  } // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract   /// @notice Withdraw _amount from active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); yieldStrategy.withdraw(_amount);  } // Withdraws all tokens from the yield strategy back into this contract   /// @notice Withdraw all funds from active strategy   /// @dev gov only   function yieldStrategyWithdrawAll() external override onlyOwner {     yieldStrategy.withdrawAll();   } /// @notice Pause external functions in all contracts   /// @dev A manager can be replaced with the new contract in a paused state   /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused   function pause() external onlyOwner {     _pause();     if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();     // sherDistributionManager can be 0, pause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       !Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.pause();     }     if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();     if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();   } /// @notice Unpause external functions in all contracts   /// @dev A manager can be replaced with the new contract in an unpaused state   /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused   function unpause() external onlyOwner {     _unpause();     if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();     // sherDistributionManager can be 0, unpause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.unpause();     }     if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();     if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();   } //   // Access control functions   // /// @notice Account sum of all underlying posiiton shares for _from and _to   /// @dev this enables the tokenBalanceOfAddress to exist   function _beforeTokenTransfer(     address _from,     address _to,     uint256 _tokenID   ) internal override {     uint256 _stakeShares = stakeShares[_tokenID]; if (_from != address(0)) addressShares[_from] -= _stakeShares; if (_to != address(0)) addressShares[_to] += _stakeShares;  } // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)   // This function is called by the Sherlock claim manager contract if a claim is approved   /// @notice Initiate a payout of _amount to _receiver   /// @param _receiver Receiver of payout   /// @param _amount Amount to send   /// @dev only payout manager should call this   /// @dev should pull money out of strategy   function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {     // Can only be called by the Sherlock claim manager contract     if (msg.sender != address(sherlockClaimManager)) revert Unauthorized(); if (_amount != 0) {   // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)   _transferTokensOut(_receiver, _amount); } emit ClaimPayout(_receiver, _amount);  } //   // Non-access control functions   // // Helper function for initial staking and restaking   // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position   /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds   /// @param amount Amount of tokens to stake   /// @param _period Period of time for which funds get locked   /// @param _id ID for this NFT position   /// @param _receiver Address that will be linked to this position   /// @return _sher Amount of SHER tokens awarded to this position after _period ends   /// @dev _period needs to be whitelisted   function _stake(     uint256 _amount,     uint256 _period,     uint256 _id,     address _receiver   ) internal returns (uint256 _sher) {     // Sets the timestamp at which this position can first be unstaked/restaked     lockupEnd[_id] = block.timestamp + _period; if (address(sherDistributionManager) == address(0)) return 0; // Does not allow restaking of 0 tokens if (_amount == 0) return 0;  // Checks this amount of SHER tokens in this contract before we transfer new ones uint256 before = sher.balanceOf(address(this));  // pullReward() calcs then actually transfers the SHER tokens to this contract // in case this call fails, whole (re)staking transaction fails _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);  // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position uint256 actualAmount = sher.balanceOf(address(this)) - before; if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount); // Assigns the newly created SHER tokens to the current stake position if (_sher != 0) sherRewards_[_id] = _sher;  } // Checks to see if the NFT owner is the caller and that the position is unlockable   function verifyUnlockableByOwner(uint256 _id) internal view {     if (ownerOf(_id) != msg.sender) revert Unauthorized();     if (lockupEnd[_id] &gt; block.timestamp) revert InvalidConditions();   } // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner   function sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards[_id];     if (sherReward == 0) return; // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner sher.safeTransfer(_nftOwner, sherReward); // Deletes the SHER reward mapping for this NFT ID delete sherRewards_[_id];  } // Transfers an amount of tokens to the receiver address   // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)   function _transferTokensOut(address _receiver, uint256 _amount) internal {     // Transfers any premiums owed to stakers from the protocol manager to this contract     sherlockProtocolManager.claimPremiumsForStakers(); // The amount of tokens in this contract uint256 mainBalance = token.balanceOf(address(this));  // If the amount to transfer out is still greater than the amount of tokens in this contract, // Withdraw yield strategy tokens to make up the difference if (_amount &gt; mainBalance) {   yieldStrategy.withdraw(_amount - mainBalance); }  token.safeTransfer(_receiver, _amount);  } // Returns the amount of USDC owed to this amount of stakeShares   function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {     // Finds fraction that the given amount of stakeShares represents of the total     // Then multiplies it by the total amount of tokens (USDC) owed to all stakers     return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;   } // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted   // Also burns the requisite amount of shares associated with this NFT position   // Returns the amount of USDC owed to these shares   function _redeemShares(     uint256 _id,     uint256 _stakeShares,     address _receiver   ) internal returns (uint256 _amount) {     // Returns the amount of USDC owed to this amount of stakeShares     _amount = _redeemSharesCalc(_stakeShares);     // Transfers _amount of tokens to _receiver address     if (_amount != 0) _transferTokensOut(_receiver, _amount); // Subtracts this amount of stakeShares from the NFT position stakeShares[_id] -= _stakeShares; // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding totalStakeShares -= _stakeShares;  } // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager   // Restakes an NFT position (_id) for a given period (_period) and   // Sends any previously earned SHER rewards to the _nftOwner address   function _restake(     uint256 _id,     uint256 _period,     address _nftOwner   ) internal returns (uint256 _sher) {     // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner     // NOTE This function deletes the SHER reward mapping for this NFT ID     _sendSherRewardsToOwner(_id, _nftOwner); // tokenBalanceOf() returns the USDC amount owed to this NFT ID // _stake() restakes that amount of USDC for the period inputted // We use the same ID that we just deleted the SHER rewards mapping for // Resets the lockupEnd mapping and SHER token rewards mapping for this ID // Note stakeShares for this position do not change so no need to update _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);  emit Restaked(_id);  } // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)   /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt   /// @param _amount Amount of tokens to stake   /// @param _period Period of time, in seconds, to lockup your funds   /// @param _receiver Address that will receive the NFT representing the position   /// @return _id ID of the position   /// @return _sher Amount of SHER tokens to be released to this ID after _period ends   /// @dev _period needs to be whitelisted   function initialStake(     uint256 _amount,     uint256 _period,     address _receiver   ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {     if (_amount == 0) revert ZeroArgument();     // Makes sure the period is a whitelisted period     if (!stakingPeriods[_period]) revert InvalidArgument();     if (address(_receiver) == address(0)) revert ZeroArgument();     // Adds 1 to the ID of the last NFT created for the new NFT ID     _id = ++nftCounter; // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action) token.safeTransferFrom(msg.sender, address(this), _amount);  uint256 stakeShares_; uint256 totalStakeShares_ = totalStakeShares; // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares if (totalStakeShares_ != 0)   stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);   // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked else stakeShares_ = _amount;  // Assigns this NFT ID the calc'd amount of stake shares above stakeShares[_id] = stakeShares_; // Adds the newly created stake shares to the total amount of stake shares totalStakeShares += stakeShares_;  // Locks up the USDC amount and calcs the SHER token amount to receive on unstake _sher = _stake(_amount, _period, _id, _receiver);  // This is an ERC-721 function that creates an NFT and sends it to the receiver _safeMint(_receiver, _id);  } // This is how a staker unstakes and cashes out on their position   /// @notice Redeem NFT _id and receive _amount of tokens   /// @param _id TokenID of the position   /// @return _amount Amount of tokens (USDC) owed to NFT ID   /// @dev Only the owner of _id will be able to redeem their position   /// @dev The SHER rewards are sent to the NFT owner   /// @dev Can only be called after lockup _period has ended   function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // This is the ERC-721 function to destroy an NFT (with owner's approval) _burn(_id);  // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC owed to these shares _amount = _redeemShares(_id, stakeShares[_id], msg.sender);  // Sends the SHER tokens associated with this NFT ID to the NFT owner _sendSherRewardsToOwner(_id, msg.sender);  // Removes the unlock deadline associated with this NFT delete lockupEnd_[_id];  } // This is how a staker restakes an expired position   /// @notice Owner restakes position with ID: _id for _period seconds   /// @param _id ID of the position   /// @param _period Period of time, in seconds, to lockup your funds   /// @return _sher Amount of SHER tokens to be released to owner address after _period ends   /// @dev Only the owner of _id will be able to restake their position using this call   /// @dev _period needs to be whitelisted   /// @dev Can only be called after lockup _period has ended   function ownerRestake(uint256 _id, uint256 _period)     external     override     whenNotPaused     returns (uint256 _sher)   {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // Checks to make sure the staking period is a whitelisted one if (!stakingPeriods[_period]) revert InvalidArgument();  // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position _sher = _restake(_id, _period, msg.sender);  } // Calcs the reward (in stake shares) an arb would get for restaking a position   // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb   function calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {     // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)     uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME; // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position if (initialArbTime &gt; block.timestamp) return (0, false);  // The max rewards (as a % of the position's shares) for the arb are available at this timestamp uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;  // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100% uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;  // Scaled by 10**18 // Represents the max amount of stake shares that an arb could get from restaking this position uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];  // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled return (   ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,   true );  } /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position   /// @return profit How much profit an arb would make in USDC   /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)   function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {     // Returns the stake shares that an arb would get, and whether the position can currently be arbed     // profit variable is used to store the amount of shares     (profit, able) = _calcSharesForArbRestake(_id);     // Calculates the tokens (USDC) represented by that amount of stake shares     // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit     profit = _redeemSharesCalc(profit);   } /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)   /// @param _id ID of the position   /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup   /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function   /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)   /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)   /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)   function arbRestake(uint256 _id)     external     override     whenNotPaused     returns (uint256 _sher, uint256 _arbReward)   {     address nftOwner = ownerOf(_id); // Returns the stake shares that an arb would get, and whether the position can currently be arbed (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id); // Revert if not able to be arbed if (!able) revert InvalidConditions();  // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC paid to the arbitrager _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);  // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months) // Sends previously earned SHER rewards to the NFT owner address _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);  emit ArbRestaked(_id, _arbReward);  } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/***********\\n Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x)\n Sherlock Protocol: https://sherlock.xyz\n/***********/\n\nimport \'@openzeppelin/contracts/token/ERC20/IERC20.sol\';\nimport \'@openzeppelin/contracts/token/ERC721/ERC721.sol\';\nimport \'@openzeppelin/contracts/access/Ownable.sol\';\nimport \'@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\';\nimport \'@openzeppelin/contracts/security/Pausable.sol\';\n\nimport \'./interfaces/ISherlock.sol\';\n\n/// @title Sherlock core interface for stakers\n/// @author Evert Kors\n// This is the contract that manages staking actions\n\ncontract Sherlock is ISherlock, ERC721, Ownable, Pausable {\n  using SafeERC20 for IERC20;\n\n  // The initial period for a staker to restake/withdraw without being auto-restaked\n  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;\n\n  // The period during which the reward for restaking an account (after the inital period) grows\n  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;\n\n  // Anyone who gets auto-restaked is restaked for this period (3 months)\n  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;\n\n  // The percentage of someone\'s stake that can be paid to an arb for restaking\n  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (1018 / 100) * 20; // 20%\n\n  // USDC address\n  IERC20 public immutable token;\n\n  // SHER token address\n  IERC20 public immutable sher;\n\n  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not\n  mapping(uint256 =&gt; bool) public override stakingPeriods;\n\n  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked\n  mapping(uint256 =&gt; uint256) internal lockupEnd_;\n\n  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position\n  mapping(uint256 =&gt; uint256) internal sherRewards_;\n\n  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)\n  mapping(uint256 =&gt; uint256) internal stakeShares;\n\n  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.\n  mapping(address =&gt; uint256) internal addressShares;\n\n  // Total amount of shares that have been issued to all NFT positions\n  uint256 internal totalStakeShares;\n\n  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)\n  IStrategyManager public override yieldStrategy;\n\n  // Instances of relevant Sherlock contracts\n  ISherDistributionManager public override sherDistributionManager;\n  ISherlockProtocolManager public override sherlockProtocolManager;\n  ISherlockClaimManager public override sherlockClaimManager;\n\n  // Address to which nonstaker payments are made\n  // This will start out as a multi-sig address, then become a contract address later\n  address public override nonStakersAddress;\n\n  // Stores the ID of the most recently created NFT\n  // This variable is incremented by 1 to create a new NFT ID\n  uint256 internal nftCounter;\n\n  // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.\n  constructor(\n    IERC20 token, // USDC address\n    IERC20 _sher, // SHER token address\n    string memory _name, // Token collection name (see ERC-721 docs)\n    string memory _symbol, // Token collection symbol (see ERC-721 docs)\n    IStrategyManager _yieldStrategy, // The active yield strategy contract\n    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract\n    address _nonStakersAddress, // The address to which nonstakers payments go\n    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract\n    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract\n    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for\n  ) ERC721(_name, _symbol) {\n    if (address(_token) == address(0)) revert ZeroArgument();\n    if (address(_sher) == address(0)) revert ZeroArgument();\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();\n    if (_nonStakersAddress == address(0)) revert ZeroArgument();\n    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();\n    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();\n\n    token = _token;\n    sher = _sher;\n    yieldStrategy = _yieldStrategy;\n    sherDistributionManager = _sherDistributionManager;\n    nonStakersAddress = _nonStakersAddress;\n    sherlockProtocolManager = _sherlockProtocolManager;\n    sherlockClaimManager = _sherlockClaimManager;\n\n    // Enabling the first set of staking periods that were provided in constructor args\n    for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {\n      enableStakingPeriod(_initialstakingPeriods[i]);\n    }\n\n    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);\n    emit SherDistributionManagerUpdated(\n      ISherDistributionManager(address(0)),\n      _sherDistributionManager\n    );\n    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);\n    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);\n    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);\n  }\n\n  //\n  // View functions\n  //\n\n  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked\n  /// @notice View the current lockup end timestamp of _tokenID\n  /// @return Timestamp when NFT position unlocks\n  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n\n    return lockupEnd[tokenID];\n  }\n\n  // Returns the SHER rewards owed to this position\n  /// @notice View the current SHER reward of _tokenID\n  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup\n  function sherRewards(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n\n    return sherRewards[tokenID];\n  }\n\n  // Returns the tokens (USDC) owed to a position\n  /// @notice View the current token balance claimable upon reaching end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking position\n  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {\n    if (!_exists(_tokenID)) revert NonExistent();\n    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers\n    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;\n  }\n\n  // Returns the tokens (USDC) owed to an address\n  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking all positions\n  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {\n    if (_staker == address(0)) revert ZeroArgument();\n    uint256 _totalStakeShares = totalStakeShares;\n    if (_totalStakeShares == 0) return 0;\n    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers\n    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;\n  }\n\n  // Gets the total amount of tokens (USDC) owed to stakers\n  // Adds this contract\'s balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract\n  /// @notice View the current TVL for all stakers\n  /// @return Total amount of tokens staked\n  /// @dev Adds principal + strategy + premiums\n  /// @dev Will calculate the most up to date value for each piece\n  function totalTokenBalanceStakers() public view override returns (uint256) {\n    return\n      token.balanceOf(address(this)) +\n      yieldStrategy.balanceOf() +\n      sherlockProtocolManager.claimablePremiums();\n  }\n\n  //\n  // Gov functions\n  //\n\n  // Allows governance to add a new staking period (4 months, etc.)\n  /// @notice Allows stakers to stake for _period of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already enabled\n  function enableStakingPeriod(uint256 _period) public override onlyOwner {\n    if (_period == 0) revert ZeroArgument();\n    // Revert if staking period is already active\n    if (stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sets the staking period to true\n    stakingPeriods[_period] = true;\n    emit StakingPeriodEnabled(_period);\n  }\n\n  // Allows governance to remove a staking period (4 months, etc.)\n  /// @notice Disallow stakers to stake for _period of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already disabled\n  function disableStakingPeriod(uint256 _period) external override onlyOwner {\n    // Revert if staking period is already inactive\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sets the staking period to false\n    stakingPeriods[_period] = false;\n    emit StakingPeriodDisabled(_period);\n  }\n\n  // Sets a new contract to be the active SHER distribution manager\n  /// @notice Update SHER distribution manager contract\n  /// @param _sherDistributionManager New adddress of the manager\n  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();\n    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();\n\n    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);\n    sherDistributionManager = _sherDistributionManager;\n  }\n\n  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)\n  /// @notice Remove SHER token rewards\n  function removeSherDistributionManager() external override onlyOwner {\n    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();\n\n    emit SherDistributionManagerUpdated(\n      sherDistributionManager,\n      ISherDistributionManager(address(0))\n    );\n    delete sherDistributionManager;\n  }\n\n  // Sets a new address for nonstakers payments\n  /// @notice Update address eligble for non staker rewards from protocol premiums\n  /// @param _nonStakers Address eligble for non staker rewards\n  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {\n    if (address(_nonStakers) == address(0)) revert ZeroArgument();\n    if (nonStakersAddress == _nonStakers) revert InvalidArgument();\n\n    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);\n    nonStakersAddress = _nonStakers;\n  }\n\n  // Sets a new protocol manager contract\n  /// @notice Transfer protocol manager implementation address\n  /// @param _protocolManager new implementation address\n  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_protocolManager) == address(0)) revert ZeroArgument();\n    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();\n\n    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);\n    sherlockProtocolManager = _protocolManager;\n  }\n\n  // Sets a new claim manager contract\n  /// @notice Transfer claim manager role to different address\n  /// @param _claimManager New address of claim manager\n  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)\n    external\n    override\n    onlyOwner\n  {\n    if (address(_claimManager) == address(0)) revert ZeroArgument();\n    if (sherlockClaimManager == _claimManager) revert InvalidArgument();\n\n    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);\n    sherlockClaimManager = _claimManager;\n  }\n\n  // Sets a new yield strategy manager contract\n  /// @notice Update yield strategy\n  /// @param _yieldStrategy News address of the strategy\n  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure\n  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {\n    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();\n    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();\n\n    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail\n    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.\n    // In case this happens. We still want the yield strategy to be updated.\n    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.\n    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {\n      emit YieldStrategyUpdateWithdrawAllError(reason);\n    }\n\n    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);\n    yieldStrategy = _yieldStrategy;\n  }\n\n  // Deposits a chosen amount of tokens (USDC) into the active yield strategy\n  /// @notice Deposit _amount into active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {\n    if (_amount == 0) revert ZeroArgument();\n\n    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first\n    sherlockProtocolManager.claimPremiumsForStakers();\n    // Transfers the amount of tokens to the yield strategy contract\n    token.safeTransfer(address(yieldStrategy), _amount);\n    // Deposits all tokens in the yield strategy contract into the actual yield strategy\n    yieldStrategy.deposit();\n  }\n\n  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract\n  /// @notice Withdraw _amount from active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {\n    if (_amount == 0) revert ZeroArgument();\n\n    yieldStrategy.withdraw(_amount);\n  }\n\n  // Withdraws all tokens from the yield strategy back into this contract\n  /// @notice Withdraw all funds from active strategy\n  /// @dev gov only\n  function yieldStrategyWithdrawAll() external override onlyOwner {\n    yieldStrategy.withdrawAll();\n  }\n\n  /// @notice Pause external functions in all contracts\n  /// @dev A manager can be replaced with the new contract in a paused state\n  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused\n  function pause() external onlyOwner {\n    _pause();\n    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();\n    // sherDistributionManager can be 0, pause isn\'t needed in that case\n    if (\n      address(sherDistributionManager) != address(0) &amp;&amp;\n      !Pausable(address(sherDistributionManager)).paused()\n    ) {\n      sherDistributionManager.pause();\n    }\n    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();\n    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();\n  }\n\n  /// @notice Unpause external functions in all contracts\n  /// @dev A manager can be replaced with the new contract in an unpaused state\n  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused\n  function unpause() external onlyOwner {\n    _unpause();\n    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();\n    // sherDistributionManager can be 0, unpause isn\'t needed in that case\n    if (\n      address(sherDistributionManager) != address(0) &amp;&amp;\n      Pausable(address(sherDistributionManager)).paused()\n    ) {\n      sherDistributionManager.unpause();\n    }\n    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();\n    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();\n  }\n\n  //\n  // Access control functions\n  //\n\n  /// @notice Account sum of all underlying posiiton shares for _from and _to\n  /// @dev this enables the tokenBalanceOfAddress to exist\n  function _beforeTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenID\n  ) internal override {\n    uint256 _stakeShares = stakeShares[_tokenID];\n\n    if (_from != address(0)) addressShares[_from] -= _stakeShares;\n    if (_to != address(0)) addressShares[_to] += _stakeShares;\n  }\n\n  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)\n  // This function is called by the Sherlock claim manager contract if a claim is approved\n  /// @notice Initiate a payout of _amount to _receiver\n  /// @param _receiver Receiver of payout\n  /// @param _amount Amount to send\n  /// @dev only payout manager should call this\n  /// @dev should pull money out of strategy\n  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {\n    // Can only be called by the Sherlock claim manager contract\n    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();\n\n    if (_amount != 0) {\n      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)\n      _transferTokensOut(_receiver, _amount);\n    }\n    emit ClaimPayout(_receiver, _amount);\n  }\n\n  //\n  // Non-access control functions\n  //\n\n  // Helper function for initial staking and restaking\n  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position\n  /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time for which funds get locked\n  /// @param _id ID for this NFT position\n  /// @param _receiver Address that will be linked to this position\n  /// @return _sher Amount of SHER tokens awarded to this position after _period ends\n  /// @dev _period needs to be whitelisted\n  function _stake(\n    uint256 _amount,\n    uint256 _period,\n    uint256 _id,\n    address _receiver\n  ) internal returns (uint256 _sher) {\n    // Sets the timestamp at which this position can first be unstaked/restaked\n    lockupEnd[id] = block.timestamp + _period;\n\n    if (address(sherDistributionManager) == address(0)) return 0;\n    // Does not allow restaking of 0 tokens\n    if (_amount == 0) return 0;\n\n    // Checks this amount of SHER tokens in this contract before we transfer new ones\n    uint256 before = sher.balanceOf(address(this));\n\n    // pullReward() calcs then actually transfers the SHER tokens to this contract\n    // in case this call fails, whole (re)staking transaction fails\n    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);\n\n    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position\n    uint256 actualAmount = sher.balanceOf(address(this)) - before;\n    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);\n    // Assigns the newly created SHER tokens to the current stake position\n    if (_sher != 0) sherRewards[id] = _sher;\n  }\n\n  // Checks to see if the NFT owner is the caller and that the position is unlockable\n  function _verifyUnlockableByOwner(uint256 _id) internal view {\n    if (ownerOf(_id) != msg.sender) revert Unauthorized();\n    if (lockupEnd[id] &gt; block.timestamp) revert InvalidConditions();\n  }\n\n  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner\n  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {\n    uint256 sherReward = sherRewards[id];\n    if (sherReward == 0) return;\n\n    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner\n    sher.safeTransfer(_nftOwner, sherReward);\n    // Deletes the SHER reward mapping for this NFT ID\n    delete sherRewards[id];\n  }\n\n  // Transfers an amount of tokens to the receiver address\n  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)\n  function _transferTokensOut(address _receiver, uint256 _amount) internal {\n    // Transfers any premiums owed to stakers from the protocol manager to this contract\n    sherlockProtocolManager.claimPremiumsForStakers();\n\n    // The amount of tokens in this contract\n    uint256 mainBalance = token.balanceOf(address(this));\n\n    // If the amount to transfer out is still greater than the amount of tokens in this contract,\n    // Withdraw yield strategy tokens to make up the difference\n    if (_amount &gt; mainBalance) {\n      yieldStrategy.withdraw(_amount - mainBalance);\n    }\n\n    token.safeTransfer(_receiver, _amount);\n  }\n\n  // Returns the amount of USDC owed to this amount of stakeShares\n  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {\n    // Finds fraction that the given amount of stakeShares represents of the total\n    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers\n    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;\n  }\n\n  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted\n  // Also burns the requisite amount of shares associated with this NFT position\n  // Returns the amount of USDC owed to these shares\n  function _redeemShares(\n    uint256 _id,\n    uint256 _stakeShares,\n    address _receiver\n  ) internal returns (uint256 _amount) {\n    // Returns the amount of USDC owed to this amount of stakeShares\n    _amount = _redeemSharesCalc(_stakeShares);\n    // Transfers _amount of tokens to _receiver address\n    if (_amount != 0) _transferTokensOut(_receiver, _amount);\n\n    // Subtracts this amount of stakeShares from the NFT position\n    stakeShares[_id] -= _stakeShares;\n    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding\n    totalStakeShares -= _stakeShares;\n  }\n\n  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager\n  // Restakes an NFT position (_id) for a given period (_period) and\n  // Sends any previously earned SHER rewards to the _nftOwner address\n  function _restake(\n    uint256 _id,\n    uint256 _period,\n    address _nftOwner\n  ) internal returns (uint256 _sher) {\n    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner\n    // NOTE This function deletes the SHER reward mapping for this NFT ID\n    _sendSherRewardsToOwner(_id, _nftOwner);\n\n    // tokenBalanceOf() returns the USDC amount owed to this NFT ID\n    // _stake() restakes that amount of USDC for the period inputted\n    // We use the same ID that we just deleted the SHER rewards mapping for\n    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID\n    // Note stakeShares for this position do not change so no need to update\n    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);\n\n    emit Restaked(_id);\n  }\n\n  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)\n  /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @param _receiver Address that will receive the NFT representing the position\n  /// @return _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to this ID after _period ends\n  /// @dev _period needs to be whitelisted\n  function initialStake(\n    uint256 _amount,\n    uint256 _period,\n    address _receiver\n  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {\n    if (_amount == 0) revert ZeroArgument();\n    // Makes sure the period is a whitelisted period\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n    if (address(_receiver) == address(0)) revert ZeroArgument();\n    // Adds 1 to the ID of the last NFT created for the new NFT ID\n    _id = ++nftCounter;\n\n    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)\n    token.safeTransferFrom(msg.sender, address(this), _amount);\n\n    uint256 stakeShares;\n    uint256 totalStakeShares_ = totalStakeShares;\n    // amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares\n    if (totalStakeShares != 0)\n      stakeShares_ = (amount * totalStakeShares) / (totalTokenBalanceStakers() - amount);\n      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked\n    else stakeShares = amount;\n\n    // Assigns this NFT ID the calc\'d amount of stake shares above\n    stakeShares[_id] = stakeShares;\n    // Adds the newly created stake shares to the total amount of stake shares\n    totalStakeShares += stakeShares_;\n\n    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake\n    sher = _stake(_amount, _period, _id, _receiver);\n\n    // This is an ERC-721 function that creates an NFT and sends it to the receiver\n    _safeMint(_receiver, _id);\n  }\n\n  // This is how a staker unstakes and cashes out on their position\n  /// @notice Redeem NFT _id and receive _amount of tokens\n  /// @param _id TokenID of the position\n  /// @return _amount Amount of tokens (USDC) owed to NFT ID\n  /// @dev Only the owner of _id will be able to redeem their position\n  /// @dev The SHER rewards are sent to the NFT owner\n  /// @dev Can only be called after lockup _period has ended\n  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {\n    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over\n    _verifyUnlockableByOwner(_id);\n\n    // This is the ERC-721 function to destroy an NFT (with owner\'s approval)\n    _burn(_id);\n\n    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID\n    // Also burns the requisite amount of shares associated with this NFT position\n    // Returns the amount of USDC owed to these shares\n    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);\n\n    // Sends the SHER tokens associated with this NFT ID to the NFT owner\n    _sendSherRewardsToOwner(_id, msg.sender);\n\n    // Removes the unlock deadline associated with this NFT\n    delete lockupEnd[id];\n  }\n\n  // This is how a staker restakes an expired position\n  /// @notice Owner restakes position with ID: _id for _period seconds\n  /// @param _id ID of the position\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @return _sher Amount of SHER tokens to be released to owner address after _period ends\n  /// @dev Only the owner of _id will be able to restake their position using this call\n  /// @dev _period needs to be whitelisted\n  /// @dev Can only be called after lockup _period has ended\n  function ownerRestake(uint256 _id, uint256 _period)\n    external\n    override\n    whenNotPaused\n    returns (uint256 _sher)\n  {\n    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over\n    _verifyUnlockableByOwner(_id);\n\n    // Checks to make sure the staking period is a whitelisted one\n    if (!stakingPeriods[_period]) revert InvalidArgument();\n\n    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position\n    _sher = _restake(_id, _period, msg.sender);\n  }\n\n  // Calcs the reward (in stake shares) an arb would get for restaking a position\n  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb\n  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {\n    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)\n    uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME;\n\n    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position\n    if (initialArbTime &gt; block.timestamp) return (0, false);\n\n    // The max rewards (as a % of the position\'s shares) for the arb are available at this timestamp\n    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;\n\n    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%\n    uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;\n\n    // Scaled by 1018\n    // Represents the max amount of stake shares that an arb could get from restaking this position\n    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];\n\n    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function\n    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled\n    return (\n      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10*18,\n      true\n    );\n  }\n\n  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position\n  /// @return profit How much profit an arb would make in USDC\n  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)\n  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {\n    // Returns the stake shares that an arb would get, and whether the position can currently be arbed\n    // profit variable is used to store the amount of shares\n    (profit, able) = _calcSharesForArbRestake(_id);\n    // Calculates the tokens (USDC) represented by that amount of stake shares\n    // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit\n    profit = _redeemSharesCalc(profit);\n  }\n\n  /// @notice Allows someone who doesn\'t own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)\n  /// @param _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup\n  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function\n  /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)\n  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)\n  /// @dev During a 2 week period the reward ratio will move from 0% to 100% ( x)\n  function arbRestake(uint256 _id)\n    external\n    override\n    whenNotPaused\n    returns (uint256 _sher, uint256 _arbReward)\n  {\n    address nftOwner = ownerOf(_id);\n\n    // Returns the stake shares that an arb would get, and whether the position can currently be arbed\n    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);\n    // Revert if not able to be arbed\n    if (!able) revert InvalidConditions();\n\n    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward\n    // Also burns the requisite amount of shares associated with this NFT position\n    // Returns the amount of USDC paid to the arbitrager\n    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);\n\n    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)\n    // Sends previously earned SHER rewards to the NFT owner address\n    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);\n\n    emit ArbRestaked(_id, _arbReward);\n  }\n}\n', 'ideas': ' 1', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-25-08 10:38:06 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: GPL-2.0-or-later pragma solidity 0.8.10; /***********\ * Author: Evert Kors &#100;&#101;&#118;&#64;&#115;&#104;&#101;&#114;&#108;&#111;&#99;&#107;&#46;&#120;&#121;&#122; (https://twitter.com/evert0x) * Sherlock Protocol: https://sherlock.xyz /***********/ import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '@openzeppelin/contracts/token/ERC721/ERC721.sol'; import '@openzeppelin/contracts/access/Ownable.sol'; import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol'; import '@openzeppelin/contracts/security/Pausable.sol'; import './interfaces/ISherlock.sol'; /// @title Sherlock core interface for stakers /// @author Evert Kors // This is the contract that manages staking actions contract Sherlock is ISherlock, ERC721, Ownable, Pausable {   using SafeERC20 for IERC20; // The initial period for a staker to restake/withdraw without being auto-restaked   uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks; // The period during which the reward for restaking an account (after the inital period) grows   uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks; // Anyone who gets auto-restaked is restaked for this period (3 months)   uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks; // The percentage of someone's stake that can be paid to an arb for restaking   uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20% // USDC address   IERC20 public immutable token; // SHER token address   IERC20 public immutable sher; // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not   mapping(uint256 =&gt; bool) public override stakingPeriods; // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked   mapping(uint256 =&gt; uint256) internal lockupEnd_; // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position   mapping(uint256 =&gt; uint256) internal sherRewards_; // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)   mapping(uint256 =&gt; uint256) internal stakeShares; // Key is account, value is the sum of underlying shares of all the NFTs the account owns.   mapping(address =&gt; uint256) internal addressShares; // Total amount of shares that have been issued to all NFT positions   uint256 internal totalStakeShares; // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)   IStrategyManager public override yieldStrategy; // Instances of relevant Sherlock contracts   ISherDistributionManager public override sherDistributionManager;   ISherlockProtocolManager public override sherlockProtocolManager;   ISherlockClaimManager public override sherlockClaimManager; // Address to which nonstaker payments are made   // This will start out as a multi-sig address, then become a contract address later   address public override nonStakersAddress; // Stores the ID of the most recently created NFT   // This variable is incremented by 1 to create a new NFT ID   uint256 internal nftCounter; // Even though _sherDistributionManager can be removed once deployed, every initial deployment will have an active instance.   constructor(     IERC20 _token, // USDC address     IERC20 _sher, // SHER token address     string memory _name, // Token collection name (see ERC-721 docs)     string memory _symbol, // Token collection symbol (see ERC-721 docs)     IStrategyManager _yieldStrategy, // The active yield strategy contract     ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract     address _nonStakersAddress, // The address to which nonstakers payments go     ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract     ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract     uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for   ) ERC721(_name, _symbol) {     if (address(_token) == address(0)) revert ZeroArgument();     if (address(_sher) == address(0)) revert ZeroArgument();     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (_nonStakersAddress == address(0)) revert ZeroArgument();     if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();     if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument(); token = _token; sher = _sher; yieldStrategy = _yieldStrategy; sherDistributionManager = _sherDistributionManager; nonStakersAddress = _nonStakersAddress; sherlockProtocolManager = _sherlockProtocolManager; sherlockClaimManager = _sherlockClaimManager;  // Enabling the first set of staking periods that were provided in constructor args for (uint256 i; i &lt; _initialstakingPeriods.length; i++) {   enableStakingPeriod(_initialstakingPeriods[i]); }  emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy); emit SherDistributionManagerUpdated(   ISherDistributionManager(address(0)),   _sherDistributionManager ); emit NonStakerAddressUpdated(address(0), _nonStakersAddress); emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager); emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);  } //   // View functions   // // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked   /// @notice View the current lockup end timestamp of _tokenID   /// @return Timestamp when NFT position unlocks   function lockupEnd(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return lockupEnd_[_tokenID];  } // Returns the SHER rewards owed to this position   /// @notice View the current SHER reward of _tokenID   /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup   function sherRewards(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent(); return sherRewards_[_tokenID];  } // Returns the tokens (USDC) owed to a position   /// @notice View the current token balance claimable upon reaching end of the lockup   /// @return Amount of tokens assigned to owner when unstaking position   function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {     if (!_exists(_tokenID)) revert NonExistent();     // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers     return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;   } // Returns the tokens (USDC) owed to an address   /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup   /// @return Amount of tokens assigned to owner when unstaking all positions   function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {     if (_staker == address(0)) revert ZeroArgument();     uint256 _totalStakeShares = totalStakeShares;     if (_totalStakeShares == 0) return 0;     // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers     return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;   } // Gets the total amount of tokens (USDC) owed to stakers   // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract   /// @notice View the current TVL for all stakers   /// @return Total amount of tokens staked   /// @dev Adds principal + strategy + premiums   /// @dev Will calculate the most up to date value for each piece   function totalTokenBalanceStakers() public view override returns (uint256) {     return       token.balanceOf(address(this)) +       yieldStrategy.balanceOf() +       sherlockProtocolManager.claimablePremiums();   } //   // Gov functions   // // Allows governance to add a new staking period (4 months, etc.)   /// @notice Allows stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already enabled   function enableStakingPeriod(uint256 _period) public override onlyOwner {     if (_period == 0) revert ZeroArgument();     // Revert if staking period is already active     if (stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to true stakingPeriods[_period] = true; emit StakingPeriodEnabled(_period);  } // Allows governance to remove a staking period (4 months, etc.)   /// @notice Disallow stakers to stake for _period of time   /// @param _period Period of time, in seconds,   /// @dev should revert if already disabled   function disableStakingPeriod(uint256 _period) external override onlyOwner {     // Revert if staking period is already inactive     if (!stakingPeriods[_period]) revert InvalidArgument(); // Sets the staking period to false stakingPeriods[_period] = false; emit StakingPeriodDisabled(_period);  } // Sets a new contract to be the active SHER distribution manager   /// @notice Update SHER distribution manager contract   /// @param _sherDistributionManager New adddress of the manager   function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)     external     override     onlyOwner   {     if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();     if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument(); emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager); sherDistributionManager = _sherDistributionManager;  } // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)   /// @notice Remove SHER token rewards   function removeSherDistributionManager() external override onlyOwner {     if (address(sherDistributionManager) == address(0)) revert InvalidConditions(); emit SherDistributionManagerUpdated(   sherDistributionManager,   ISherDistributionManager(address(0)) ); delete sherDistributionManager;  } // Sets a new address for nonstakers payments   /// @notice Update address eligble for non staker rewards from protocol premiums   /// @param _nonStakers Address eligble for non staker rewards   function updateNonStakersAddress(address _nonStakers) external override onlyOwner {     if (address(_nonStakers) == address(0)) revert ZeroArgument();     if (nonStakersAddress == _nonStakers) revert InvalidArgument(); emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers); nonStakersAddress = _nonStakers;  } // Sets a new protocol manager contract   /// @notice Transfer protocol manager implementation address   /// @param _protocolManager new implementation address   function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)     external     override     onlyOwner   {     if (address(_protocolManager) == address(0)) revert ZeroArgument();     if (sherlockProtocolManager == _protocolManager) revert InvalidArgument(); emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager); sherlockProtocolManager = _protocolManager;  } // Sets a new claim manager contract   /// @notice Transfer claim manager role to different address   /// @param _claimManager New address of claim manager   function updateSherlockClaimManager(ISherlockClaimManager _claimManager)     external     override     onlyOwner   {     if (address(_claimManager) == address(0)) revert ZeroArgument();     if (sherlockClaimManager == _claimManager) revert InvalidArgument(); emit ClaimManagerUpdated(sherlockClaimManager, _claimManager); sherlockClaimManager = _claimManager;  } // Sets a new yield strategy manager contract   /// @notice Update yield strategy   /// @param _yieldStrategy News address of the strategy   /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure   function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {     if (address(_yieldStrategy) == address(0)) revert ZeroArgument();     if (yieldStrategy == _yieldStrategy) revert InvalidArgument(); // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason. // In case this happens. We still want the yield strategy to be updated. // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again. try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {   emit YieldStrategyUpdateWithdrawAllError(reason); }  emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy); yieldStrategy = _yieldStrategy;  } // Deposits a chosen amount of tokens (USDC) into the active yield strategy   /// @notice Deposit _amount into active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); // Transfers any tokens owed to stakers from the protocol manager contract to this contract first sherlockProtocolManager.claimPremiumsForStakers(); // Transfers the amount of tokens to the yield strategy contract token.safeTransfer(address(yieldStrategy), _amount); // Deposits all tokens in the yield strategy contract into the actual yield strategy yieldStrategy.deposit();  } // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract   /// @notice Withdraw _amount from active strategy   /// @param _amount Amount of tokens   /// @dev gov only   function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {     if (_amount == 0) revert ZeroArgument(); yieldStrategy.withdraw(_amount);  } // Withdraws all tokens from the yield strategy back into this contract   /// @notice Withdraw all funds from active strategy   /// @dev gov only   function yieldStrategyWithdrawAll() external override onlyOwner {     yieldStrategy.withdrawAll();   } /// @notice Pause external functions in all contracts   /// @dev A manager can be replaced with the new contract in a paused state   /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused   function pause() external onlyOwner {     _pause();     if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();     // sherDistributionManager can be 0, pause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       !Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.pause();     }     if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();     if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();   } /// @notice Unpause external functions in all contracts   /// @dev A manager can be replaced with the new contract in an unpaused state   /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused   function unpause() external onlyOwner {     _unpause();     if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();     // sherDistributionManager can be 0, unpause isn't needed in that case     if (       address(sherDistributionManager) != address(0) &amp;&amp;       Pausable(address(sherDistributionManager)).paused()     ) {       sherDistributionManager.unpause();     }     if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();     if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();   } //   // Access control functions   // /// @notice Account sum of all underlying posiiton shares for _from and _to   /// @dev this enables the tokenBalanceOfAddress to exist   function _beforeTokenTransfer(     address _from,     address _to,     uint256 _tokenID   ) internal override {     uint256 _stakeShares = stakeShares[_tokenID]; if (_from != address(0)) addressShares[_from] -= _stakeShares; if (_to != address(0)) addressShares[_to] += _stakeShares;  } // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)   // This function is called by the Sherlock claim manager contract if a claim is approved   /// @notice Initiate a payout of _amount to _receiver   /// @param _receiver Receiver of payout   /// @param _amount Amount to send   /// @dev only payout manager should call this   /// @dev should pull money out of strategy   function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {     // Can only be called by the Sherlock claim manager contract     if (msg.sender != address(sherlockClaimManager)) revert Unauthorized(); if (_amount != 0) {   // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)   _transferTokensOut(_receiver, _amount); } emit ClaimPayout(_receiver, _amount);  } //   // Non-access control functions   // // Helper function for initial staking and restaking   // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position   /// @notice Stakes _amount of tokens and locks up the _id position for _period seconds   /// @param amount Amount of tokens to stake   /// @param _period Period of time for which funds get locked   /// @param _id ID for this NFT position   /// @param _receiver Address that will be linked to this position   /// @return _sher Amount of SHER tokens awarded to this position after _period ends   /// @dev _period needs to be whitelisted   function _stake(     uint256 _amount,     uint256 _period,     uint256 _id,     address _receiver   ) internal returns (uint256 _sher) {     // Sets the timestamp at which this position can first be unstaked/restaked     lockupEnd[_id] = block.timestamp + _period; if (address(sherDistributionManager) == address(0)) return 0; // Does not allow restaking of 0 tokens if (_amount == 0) return 0;  // Checks this amount of SHER tokens in this contract before we transfer new ones uint256 before = sher.balanceOf(address(this));  // pullReward() calcs then actually transfers the SHER tokens to this contract // in case this call fails, whole (re)staking transaction fails _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);  // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position uint256 actualAmount = sher.balanceOf(address(this)) - before; if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount); // Assigns the newly created SHER tokens to the current stake position if (_sher != 0) sherRewards_[_id] = _sher;  } // Checks to see if the NFT owner is the caller and that the position is unlockable   function verifyUnlockableByOwner(uint256 _id) internal view {     if (ownerOf(_id) != msg.sender) revert Unauthorized();     if (lockupEnd[_id] &gt; block.timestamp) revert InvalidConditions();   } // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner   function sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {     uint256 sherReward = sherRewards[_id];     if (sherReward == 0) return; // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner sher.safeTransfer(_nftOwner, sherReward); // Deletes the SHER reward mapping for this NFT ID delete sherRewards_[_id];  } // Transfers an amount of tokens to the receiver address   // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)   function _transferTokensOut(address _receiver, uint256 _amount) internal {     // Transfers any premiums owed to stakers from the protocol manager to this contract     sherlockProtocolManager.claimPremiumsForStakers(); // The amount of tokens in this contract uint256 mainBalance = token.balanceOf(address(this));  // If the amount to transfer out is still greater than the amount of tokens in this contract, // Withdraw yield strategy tokens to make up the difference if (_amount &gt; mainBalance) {   yieldStrategy.withdraw(_amount - mainBalance); }  token.safeTransfer(_receiver, _amount);  } // Returns the amount of USDC owed to this amount of stakeShares   function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {     // Finds fraction that the given amount of stakeShares represents of the total     // Then multiplies it by the total amount of tokens (USDC) owed to all stakers     return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;   } // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted   // Also burns the requisite amount of shares associated with this NFT position   // Returns the amount of USDC owed to these shares   function _redeemShares(     uint256 _id,     uint256 _stakeShares,     address _receiver   ) internal returns (uint256 _amount) {     // Returns the amount of USDC owed to this amount of stakeShares     _amount = _redeemSharesCalc(_stakeShares);     // Transfers _amount of tokens to _receiver address     if (_amount != 0) _transferTokensOut(_receiver, _amount); // Subtracts this amount of stakeShares from the NFT position stakeShares[_id] -= _stakeShares; // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding totalStakeShares -= _stakeShares;  } // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager   // Restakes an NFT position (_id) for a given period (_period) and   // Sends any previously earned SHER rewards to the _nftOwner address   function _restake(     uint256 _id,     uint256 _period,     address _nftOwner   ) internal returns (uint256 _sher) {     // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner     // NOTE This function deletes the SHER reward mapping for this NFT ID     _sendSherRewardsToOwner(_id, _nftOwner); // tokenBalanceOf() returns the USDC amount owed to this NFT ID // _stake() restakes that amount of USDC for the period inputted // We use the same ID that we just deleted the SHER rewards mapping for // Resets the lockupEnd mapping and SHER token rewards mapping for this ID // Note stakeShares for this position do not change so no need to update _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);  emit Restaked(_id);  } // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)   /// @notice Stakes _amount of tokens and locks up for _period seconds, _receiver will receive the NFT receipt   /// @param _amount Amount of tokens to stake   /// @param _period Period of time, in seconds, to lockup your funds   /// @param _receiver Address that will receive the NFT representing the position   /// @return _id ID of the position   /// @return _sher Amount of SHER tokens to be released to this ID after _period ends   /// @dev _period needs to be whitelisted   function initialStake(     uint256 _amount,     uint256 _period,     address _receiver   ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {     if (_amount == 0) revert ZeroArgument();     // Makes sure the period is a whitelisted period     if (!stakingPeriods[_period]) revert InvalidArgument();     if (address(_receiver) == address(0)) revert ZeroArgument();     // Adds 1 to the ID of the last NFT created for the new NFT ID     _id = ++nftCounter; // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action) token.safeTransferFrom(msg.sender, address(this), _amount);  uint256 stakeShares_; uint256 totalStakeShares_ = totalStakeShares; // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares if (totalStakeShares_ != 0)   stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);   // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked else stakeShares_ = _amount;  // Assigns this NFT ID the calc'd amount of stake shares above stakeShares[_id] = stakeShares_; // Adds the newly created stake shares to the total amount of stake shares totalStakeShares += stakeShares_;  // Locks up the USDC amount and calcs the SHER token amount to receive on unstake _sher = _stake(_amount, _period, _id, _receiver);  // This is an ERC-721 function that creates an NFT and sends it to the receiver _safeMint(_receiver, _id);  } // This is how a staker unstakes and cashes out on their position   /// @notice Redeem NFT _id and receive _amount of tokens   /// @param _id TokenID of the position   /// @return _amount Amount of tokens (USDC) owed to NFT ID   /// @dev Only the owner of _id will be able to redeem their position   /// @dev The SHER rewards are sent to the NFT owner   /// @dev Can only be called after lockup _period has ended   function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // This is the ERC-721 function to destroy an NFT (with owner's approval) _burn(_id);  // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC owed to these shares _amount = _redeemShares(_id, stakeShares[_id], msg.sender);  // Sends the SHER tokens associated with this NFT ID to the NFT owner _sendSherRewardsToOwner(_id, msg.sender);  // Removes the unlock deadline associated with this NFT delete lockupEnd_[_id];  } // This is how a staker restakes an expired position   /// @notice Owner restakes position with ID: _id for _period seconds   /// @param _id ID of the position   /// @param _period Period of time, in seconds, to lockup your funds   /// @return _sher Amount of SHER tokens to be released to owner address after _period ends   /// @dev Only the owner of _id will be able to restake their position using this call   /// @dev _period needs to be whitelisted   /// @dev Can only be called after lockup _period has ended   function ownerRestake(uint256 _id, uint256 _period)     external     override     whenNotPaused     returns (uint256 _sher)   {     // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over     _verifyUnlockableByOwner(_id); // Checks to make sure the staking period is a whitelisted one if (!stakingPeriods[_period]) revert InvalidArgument();  // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position _sher = _restake(_id, _period, msg.sender);  } // Calcs the reward (in stake shares) an arb would get for restaking a position   // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb   function calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {     // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)     uint256 initialArbTime = lockupEnd[_id] + ARB_RESTAKE_WAIT_TIME; // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position if (initialArbTime &gt; block.timestamp) return (0, false);  // The max rewards (as a % of the position's shares) for the arb are available at this timestamp uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;  // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100% uint256 targetTime = block.timestamp &lt; maxRewardArbTime ? block.timestamp : maxRewardArbTime;  // Scaled by 10**18 // Represents the max amount of stake shares that an arb could get from restaking this position uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];  // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled return (   ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,   true );  } /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position   /// @return profit How much profit an arb would make in USDC   /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)   function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {     // Returns the stake shares that an arb would get, and whether the position can currently be arbed     // profit variable is used to store the amount of shares     (profit, able) = _calcSharesForArbRestake(_id);     // Calculates the tokens (USDC) represented by that amount of stake shares     // Amount of shares stored in profit is used to calculate the reward in USDC, which is stored in profit     profit = _redeemSharesCalc(profit);   } /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)   /// @param _id ID of the position   /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup   /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function   /// @dev Can only be called after lockup _period is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)   /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)   /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)   function arbRestake(uint256 _id)     external     override     whenNotPaused     returns (uint256 _sher, uint256 _arbReward)   {     address nftOwner = ownerOf(_id); // Returns the stake shares that an arb would get, and whether the position can currently be arbed (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id); // Revert if not able to be arbed if (!able) revert InvalidConditions();  // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward // Also burns the requisite amount of shares associated with this NFT position // Returns the amount of USDC paid to the arbitrager _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);  // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months) // Sends previously earned SHER rewards to the NFT owner address _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);  emit ArbRestaked(_id, _arbReward);  } } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-25-08 10:38:06 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';

import './interfaces/ISherlock.sol';

/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions

contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;

  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;

  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;

  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;

  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%

  // USDC address
  IERC20 public immutable token;

  // SHER token address
  IERC20 public immutable sher;

  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;

  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;

  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;

  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;

  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;

  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;

  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;

  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;

  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;

  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;

  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();

    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;

    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }

    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }

  //
  // View functions
  //

  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return lockupEnd_[_tokenID];
  }

  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return sherRewards_[_tokenID];
  }

  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }

  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }

  //
  // Gov functions
  //

  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }

  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }

  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();

    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }

  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();

    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }

  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();

    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }

  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();

    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }

  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();

    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }

  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();

    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }

    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }

  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }

  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    yieldStrategy.withdraw(_amount);
  }

  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }

  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }

  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }

  //
  // Access control functions
  //

  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];

    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }

  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();

    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }

  //
  // Non-access control functions
  //

  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;

    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;

    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));

    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);

    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }

  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }

  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;

    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }

  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();

    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));

    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }

    token.safeTransfer(_receiver, _amount);
  }

  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);

    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }

  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);

    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);

    emit Restaked(_id);
  }

  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;

    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);

    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;

    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;

    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);

    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }

  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);

    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);

    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);

    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }

  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }

  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;

    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);

    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;

    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;

    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];

    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }

  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }

  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);

    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();

    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);

    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);

    emit ArbRestaked(_id, _arbReward);
  }
}
.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';

import './interfaces/ISherlock.sol';

/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions

contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;

  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;

  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;

  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;

  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%

  // USDC address
  IERC20 public immutable token;

  // SHER token address
  IERC20 public immutable sher;

  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;

  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;

  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;

  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;

  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;

  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;

  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;

  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;

  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;

  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;

  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();

    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;

    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }

    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }

  //
  // View functions
  //

  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return lockupEnd_[_tokenID];
  }

  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return sherRewards_[_tokenID];
  }

  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }

  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }

  //
  // Gov functions
  //

  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }

  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }

  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();

    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }

  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();

    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }

  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();

    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }

  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();

    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }

  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();

    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }

  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();

    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }

    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }

  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }

  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    yieldStrategy.withdraw(_amount);
  }

  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }

  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }

  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }

  //
  // Access control functions
  //

  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];

    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }

  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();

    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }

  //
  // Non-access control functions
  //

  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;

    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;

    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));

    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);

    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }

  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }

  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;

    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }

  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();

    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));

    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }

    token.safeTransfer(_receiver, _amount);
  }

  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);

    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }

  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);

    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);

    emit Restaked(_id);
  }

  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;

    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);

    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;

    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;

    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);

    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }

  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);

    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);

    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);

    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }

  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }

  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;

    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);

    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;

    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;

    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];

    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }

  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }

  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);

    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();

    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);

    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);

    emit ArbRestaked(_id, _arbReward);
  }
}
".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

[2024-25-08 10:38:09 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-25-08 10:38:09 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 15763
completion_tokens: 1
total_tokens: 15764
cost: $0.047293


[2024-25-08 10:38:09 INFO] Security Testing Engineer: **Security Testing Engineer<->Solidity Programming Expert on : TestBugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity 0.8.10;

/******************************************************************************\
* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)
* Sherlock Protocol: https://sherlock.xyz
/******************************************************************************/

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import '@openzeppelin/contracts/security/Pausable.sol';

import './interfaces/ISherlock.sol';

/// @title Sherlock core interface for stakers
/// @author Evert Kors
// This is the contract that manages staking actions

contract Sherlock is ISherlock, ERC721, Ownable, Pausable {
  using SafeERC20 for IERC20;

  // The initial period for a staker to restake/withdraw without being auto-restaked
  uint256 public constant ARB_RESTAKE_WAIT_TIME = 2 weeks;

  // The period during which the reward for restaking an account (after the inital period) grows
  uint256 public constant ARB_RESTAKE_GROWTH_TIME = 1 weeks;

  // Anyone who gets auto-restaked is restaked for this period (3 months)
  uint256 public constant ARB_RESTAKE_PERIOD = 12 weeks;

  // The percentage of someone's stake that can be paid to an arb for restaking
  uint256 public constant ARB_RESTAKE_MAX_PERCENTAGE = (10**18 / 100) * 20; // 20%

  // USDC address
  IERC20 public immutable token;

  // SHER token address
  IERC20 public immutable sher;

  // Key is the staking period (3 months, 6 months, etc.), value will be whether it is allowed or not
  mapping(uint256 => bool) public override stakingPeriods;

  // Key is a specific position ID (NFT ID), value represents the timestamp at which the position can be unstaked/restaked
  mapping(uint256 => uint256) internal lockupEnd_;

  // Key is NFT ID, value is the amount of SHER rewards owed to that NFT position
  mapping(uint256 => uint256) internal sherRewards_;

  // Key is NFT ID, value is the amount of shares representing the USDC owed to this position (includes principal, interest, etc.)
  mapping(uint256 => uint256) internal stakeShares;

  // Key is account, value is the sum of underlying shares of all the NFTs the account owns.
  mapping(address => uint256) internal addressShares;

  // Total amount of shares that have been issued to all NFT positions
  uint256 internal totalStakeShares;

  // Contract representing the current yield strategy (deposits staker funds into Aave, etc.)
  IStrategyManager public override yieldStrategy;

  // Instances of relevant Sherlock contracts
  ISherDistributionManager public override sherDistributionManager;
  ISherlockProtocolManager public override sherlockProtocolManager;
  ISherlockClaimManager public override sherlockClaimManager;

  // Address to which nonstaker payments are made
  // This will start out as a multi-sig address, then become a contract address later
  address public override nonStakersAddress;

  // Stores the ID of the most recently created NFT
  // This variable is incremented by 1 to create a new NFT ID
  uint256 internal nftCounter;

  // Even though `_sherDistributionManager` can be removed once deployed, every initial deployment will have an active instance.
  constructor(
    IERC20 _token, // USDC address
    IERC20 _sher, // SHER token address
    string memory _name, // Token collection name (see ERC-721 docs)
    string memory _symbol, // Token collection symbol (see ERC-721 docs)
    IStrategyManager _yieldStrategy, // The active yield strategy contract
    ISherDistributionManager _sherDistributionManager, // The active DistributionManager contract
    address _nonStakersAddress, // The address to which nonstakers payments go
    ISherlockProtocolManager _sherlockProtocolManager, // The address for the ProtocolManager contract
    ISherlockClaimManager _sherlockClaimManager, // The address for the ClaimManager contract
    uint256[] memory _initialstakingPeriods // The initial periods (3m, 6m, etc.) that someone can stake for
  ) ERC721(_name, _symbol) {
    if (address(_token) == address(0)) revert ZeroArgument();
    if (address(_sher) == address(0)) revert ZeroArgument();
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (_nonStakersAddress == address(0)) revert ZeroArgument();
    if (address(_sherlockProtocolManager) == address(0)) revert ZeroArgument();
    if (address(_sherlockClaimManager) == address(0)) revert ZeroArgument();

    token = _token;
    sher = _sher;
    yieldStrategy = _yieldStrategy;
    sherDistributionManager = _sherDistributionManager;
    nonStakersAddress = _nonStakersAddress;
    sherlockProtocolManager = _sherlockProtocolManager;
    sherlockClaimManager = _sherlockClaimManager;

    // Enabling the first set of staking periods that were provided in constructor args
    for (uint256 i; i < _initialstakingPeriods.length; i++) {
      enableStakingPeriod(_initialstakingPeriods[i]);
    }

    emit YieldStrategyUpdated(IStrategyManager(address(0)), _yieldStrategy);
    emit SherDistributionManagerUpdated(
      ISherDistributionManager(address(0)),
      _sherDistributionManager
    );
    emit NonStakerAddressUpdated(address(0), _nonStakersAddress);
    emit ProtocolManagerUpdated(ISherlockProtocolManager(address(0)), _sherlockProtocolManager);
    emit ClaimManagerUpdated(ISherlockClaimManager(address(0)), _sherlockClaimManager);
  }

  //
  // View functions
  //

  // Returns the timestamp at which the position represented by _tokenID can first be unstaked/restaked
  /// @notice View the current lockup end timestamp of `_tokenID`
  /// @return Timestamp when NFT position unlocks
  function lockupEnd(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return lockupEnd_[_tokenID];
  }

  // Returns the SHER rewards owed to this position
  /// @notice View the current SHER reward of `_tokenID`
  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup
  function sherRewards(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();

    return sherRewards_[_tokenID];
  }

  // Returns the tokens (USDC) owed to a position
  /// @notice View the current token balance claimable upon reaching end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking position
  function tokenBalanceOf(uint256 _tokenID) public view override returns (uint256) {
    if (!_exists(_tokenID)) revert NonExistent();
    // Finds the fraction of total shares owed to this position and multiplies by the total amount of tokens (USDC) owed to stakers
    return (stakeShares[_tokenID] * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Returns the tokens (USDC) owed to an address
  /// @notice View the current token balance claimable upon reaching all underlying positions at end of the lockup
  /// @return Amount of tokens assigned to owner when unstaking all positions
  function tokenBalanceOfAddress(address _staker) external view override returns (uint256) {
    if (_staker == address(0)) revert ZeroArgument();
    uint256 _totalStakeShares = totalStakeShares;
    if (_totalStakeShares == 0) return 0;
    // Finds the fraction of total shares owed to this address and multiplies by the total amount of tokens (USDC) owed to stakers
    return (addressShares[_staker] * totalTokenBalanceStakers()) / _totalStakeShares;
  }

  // Gets the total amount of tokens (USDC) owed to stakers
  // Adds this contract's balance, the tokens in the yield strategy, and the claimable premiums in the protocol manager contract
  /// @notice View the current TVL for all stakers
  /// @return Total amount of tokens staked
  /// @dev Adds principal + strategy + premiums
  /// @dev Will calculate the most up to date value for each piece
  function totalTokenBalanceStakers() public view override returns (uint256) {
    return
      token.balanceOf(address(this)) +
      yieldStrategy.balanceOf() +
      sherlockProtocolManager.claimablePremiums();
  }

  //
  // Gov functions
  //

  // Allows governance to add a new staking period (4 months, etc.)
  /// @notice Allows stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already enabled
  function enableStakingPeriod(uint256 _period) public override onlyOwner {
    if (_period == 0) revert ZeroArgument();
    // Revert if staking period is already active
    if (stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to true
    stakingPeriods[_period] = true;
    emit StakingPeriodEnabled(_period);
  }

  // Allows governance to remove a staking period (4 months, etc.)
  /// @notice Disallow stakers to stake for `_period` of time
  /// @param _period Period of time, in seconds,
  /// @dev should revert if already disabled
  function disableStakingPeriod(uint256 _period) external override onlyOwner {
    // Revert if staking period is already inactive
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sets the staking period to false
    stakingPeriods[_period] = false;
    emit StakingPeriodDisabled(_period);
  }

  // Sets a new contract to be the active SHER distribution manager
  /// @notice Update SHER distribution manager contract
  /// @param _sherDistributionManager New adddress of the manager
  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)
    external
    override
    onlyOwner
  {
    if (address(_sherDistributionManager) == address(0)) revert ZeroArgument();
    if (sherDistributionManager == _sherDistributionManager) revert InvalidArgument();

    emit SherDistributionManagerUpdated(sherDistributionManager, _sherDistributionManager);
    sherDistributionManager = _sherDistributionManager;
  }

  // Deletes the SHER distribution manager altogether (if Sherlock decides to no longer pay out SHER rewards)
  /// @notice Remove SHER token rewards
  function removeSherDistributionManager() external override onlyOwner {
    if (address(sherDistributionManager) == address(0)) revert InvalidConditions();

    emit SherDistributionManagerUpdated(
      sherDistributionManager,
      ISherDistributionManager(address(0))
    );
    delete sherDistributionManager;
  }

  // Sets a new address for nonstakers payments
  /// @notice Update address eligble for non staker rewards from protocol premiums
  /// @param _nonStakers Address eligble for non staker rewards
  function updateNonStakersAddress(address _nonStakers) external override onlyOwner {
    if (address(_nonStakers) == address(0)) revert ZeroArgument();
    if (nonStakersAddress == _nonStakers) revert InvalidArgument();

    emit NonStakerAddressUpdated(nonStakersAddress, _nonStakers);
    nonStakersAddress = _nonStakers;
  }

  // Sets a new protocol manager contract
  /// @notice Transfer protocol manager implementation address
  /// @param _protocolManager new implementation address
  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager)
    external
    override
    onlyOwner
  {
    if (address(_protocolManager) == address(0)) revert ZeroArgument();
    if (sherlockProtocolManager == _protocolManager) revert InvalidArgument();

    emit ProtocolManagerUpdated(sherlockProtocolManager, _protocolManager);
    sherlockProtocolManager = _protocolManager;
  }

  // Sets a new claim manager contract
  /// @notice Transfer claim manager role to different address
  /// @param _claimManager New address of claim manager
  function updateSherlockClaimManager(ISherlockClaimManager _claimManager)
    external
    override
    onlyOwner
  {
    if (address(_claimManager) == address(0)) revert ZeroArgument();
    if (sherlockClaimManager == _claimManager) revert InvalidArgument();

    emit ClaimManagerUpdated(sherlockClaimManager, _claimManager);
    sherlockClaimManager = _claimManager;
  }

  // Sets a new yield strategy manager contract
  /// @notice Update yield strategy
  /// @param _yieldStrategy News address of the strategy
  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure
  function updateYieldStrategy(IStrategyManager _yieldStrategy) external override onlyOwner {
    if (address(_yieldStrategy) == address(0)) revert ZeroArgument();
    if (yieldStrategy == _yieldStrategy) revert InvalidArgument();

    // This call is surrounded with a try catch as there is a non-zero chance the underlying yield protocol(s) will fail
    // For example; the Aave V2 withdraw can fail in case there is not enough liquidity available for whatever reason.
    // In case this happens. We still want the yield strategy to be updated.
    // As the worst case could be that the Aave V2 withdraw will never work again, forcing us to never use a yield strategy ever again.
    try yieldStrategy.withdrawAll() {} catch (bytes memory reason) {
      emit YieldStrategyUpdateWithdrawAllError(reason);
    }

    emit YieldStrategyUpdated(yieldStrategy, _yieldStrategy);
    yieldStrategy = _yieldStrategy;
  }

  // Deposits a chosen amount of tokens (USDC) into the active yield strategy
  /// @notice Deposit `_amount` into active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyDeposit(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    // Transfers any tokens owed to stakers from the protocol manager contract to this contract first
    sherlockProtocolManager.claimPremiumsForStakers();
    // Transfers the amount of tokens to the yield strategy contract
    token.safeTransfer(address(yieldStrategy), _amount);
    // Deposits all tokens in the yield strategy contract into the actual yield strategy
    yieldStrategy.deposit();
  }

  // Withdraws a chosen amount of tokens (USDC) from the yield strategy back into this contract
  /// @notice Withdraw `_amount` from active strategy
  /// @param _amount Amount of tokens
  /// @dev gov only
  function yieldStrategyWithdraw(uint256 _amount) external override onlyOwner {
    if (_amount == 0) revert ZeroArgument();

    yieldStrategy.withdraw(_amount);
  }

  // Withdraws all tokens from the yield strategy back into this contract
  /// @notice Withdraw all funds from active strategy
  /// @dev gov only
  function yieldStrategyWithdrawAll() external override onlyOwner {
    yieldStrategy.withdrawAll();
  }

  /// @notice Pause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in a `paused` state
  /// @dev To ensure we are still able to pause all contracts, we check if the manager is unpaused
  function pause() external onlyOwner {
    _pause();
    if (!Pausable(address(yieldStrategy)).paused()) yieldStrategy.pause();
    // sherDistributionManager can be 0, pause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      !Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.pause();
    }
    if (!Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.pause();
    if (!Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.pause();
  }

  /// @notice Unpause external functions in all contracts
  /// @dev A manager can be replaced with the new contract in an `unpaused` state
  /// @dev To ensure we are still able to unpause all contracts, we check if the manager is paused
  function unpause() external onlyOwner {
    _unpause();
    if (Pausable(address(yieldStrategy)).paused()) yieldStrategy.unpause();
    // sherDistributionManager can be 0, unpause isn't needed in that case
    if (
      address(sherDistributionManager) != address(0) &&
      Pausable(address(sherDistributionManager)).paused()
    ) {
      sherDistributionManager.unpause();
    }
    if (Pausable(address(sherlockProtocolManager)).paused()) sherlockProtocolManager.unpause();
    if (Pausable(address(sherlockClaimManager)).paused()) sherlockClaimManager.unpause();
  }

  //
  // Access control functions
  //

  /// @notice Account sum of all underlying posiiton shares for `_from` and `_to`
  /// @dev this enables the `tokenBalanceOfAddress` to exist
  function _beforeTokenTransfer(
    address _from,
    address _to,
    uint256 _tokenID
  ) internal override {
    uint256 _stakeShares = stakeShares[_tokenID];

    if (_from != address(0)) addressShares[_from] -= _stakeShares;
    if (_to != address(0)) addressShares[_to] += _stakeShares;
  }

  // Transfers specified amount of tokens to the address specified by the claim creator (protocol agent)
  // This function is called by the Sherlock claim manager contract if a claim is approved
  /// @notice Initiate a payout of `_amount` to `_receiver`
  /// @param _receiver Receiver of payout
  /// @param _amount Amount to send
  /// @dev only payout manager should call this
  /// @dev should pull money out of strategy
  function payoutClaim(address _receiver, uint256 _amount) external override whenNotPaused {
    // Can only be called by the Sherlock claim manager contract
    if (msg.sender != address(sherlockClaimManager)) revert Unauthorized();

    if (_amount != 0) {
      // Sends the amount of tokens to the receiver address (specified by the protocol agent who created the claim)
      _transferTokensOut(_receiver, _amount);
    }
    emit ClaimPayout(_receiver, _amount);
  }

  //
  // Non-access control functions
  //

  // Helper function for initial staking and restaking
  // Sets the unlock period, mints and transfers SHER tokens to this contract, assigns SHER tokens to this NFT position
  /// @notice Stakes `_amount` of tokens and locks up the `_id` position for `_period` seconds
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time for which funds get locked
  /// @param _id ID for this NFT position
  /// @param _receiver Address that will be linked to this position
  /// @return _sher Amount of SHER tokens awarded to this position after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function _stake(
    uint256 _amount,
    uint256 _period,
    uint256 _id,
    address _receiver
  ) internal returns (uint256 _sher) {
    // Sets the timestamp at which this position can first be unstaked/restaked
    lockupEnd_[_id] = block.timestamp + _period;

    if (address(sherDistributionManager) == address(0)) return 0;
    // Does not allow restaking of 0 tokens
    if (_amount == 0) return 0;

    // Checks this amount of SHER tokens in this contract before we transfer new ones
    uint256 before = sher.balanceOf(address(this));

    // pullReward() calcs then actually transfers the SHER tokens to this contract
    // in case this call fails, whole (re)staking transaction fails
    _sher = sherDistributionManager.pullReward(_amount, _period, _id, _receiver);

    // actualAmount should represent the amount of SHER tokens transferred to this contract for the current stake position
    uint256 actualAmount = sher.balanceOf(address(this)) - before;
    if (actualAmount != _sher) revert InvalidSherAmount(_sher, actualAmount);
    // Assigns the newly created SHER tokens to the current stake position
    if (_sher != 0) sherRewards_[_id] = _sher;
  }

  // Checks to see if the NFT owner is the caller and that the position is unlockable
  function _verifyUnlockableByOwner(uint256 _id) internal view {
    if (ownerOf(_id) != msg.sender) revert Unauthorized();
    if (lockupEnd_[_id] > block.timestamp) revert InvalidConditions();
  }

  // Sends the SHER tokens associated with this NFT ID to the address of the NFT owner
  function _sendSherRewardsToOwner(uint256 _id, address _nftOwner) internal {
    uint256 sherReward = sherRewards_[_id];
    if (sherReward == 0) return;

    // Transfers the SHER tokens associated with this NFT ID to the address of the NFT owner
    sher.safeTransfer(_nftOwner, sherReward);
    // Deletes the SHER reward mapping for this NFT ID
    delete sherRewards_[_id];
  }

  // Transfers an amount of tokens to the receiver address
  // This is the logic for a payout AND for an unstake (used by the payoutClaim() function above and in _redeemShares() below)
  function _transferTokensOut(address _receiver, uint256 _amount) internal {
    // Transfers any premiums owed to stakers from the protocol manager to this contract
    sherlockProtocolManager.claimPremiumsForStakers();

    // The amount of tokens in this contract
    uint256 mainBalance = token.balanceOf(address(this));

    // If the amount to transfer out is still greater than the amount of tokens in this contract,
    // Withdraw yield strategy tokens to make up the difference
    if (_amount > mainBalance) {
      yieldStrategy.withdraw(_amount - mainBalance);
    }

    token.safeTransfer(_receiver, _amount);
  }

  // Returns the amount of USDC owed to this amount of stakeShares
  function _redeemSharesCalc(uint256 _stakeShares) internal view returns (uint256) {
    // Finds fraction that the given amount of stakeShares represents of the total
    // Then multiplies it by the total amount of tokens (USDC) owed to all stakers
    return (_stakeShares * totalTokenBalanceStakers()) / totalStakeShares;
  }

  // Transfers USDC to the receiver (arbitrager OR NFT owner) based on the stakeShares inputted
  // Also burns the requisite amount of shares associated with this NFT position
  // Returns the amount of USDC owed to these shares
  function _redeemShares(
    uint256 _id,
    uint256 _stakeShares,
    address _receiver
  ) internal returns (uint256 _amount) {
    // Returns the amount of USDC owed to this amount of stakeShares
    _amount = _redeemSharesCalc(_stakeShares);
    // Transfers _amount of tokens to _receiver address
    if (_amount != 0) _transferTokensOut(_receiver, _amount);

    // Subtracts this amount of stakeShares from the NFT position
    stakeShares[_id] -= _stakeShares;
    // Subtracts this amount of stakeShares from the total amount of stakeShares outstanding
    totalStakeShares -= _stakeShares;
  }

  // Helper function to restake an eligible NFT position on behalf of the NFT owner OR an arbitrager
  // Restakes an NFT position (_id) for a given period (_period) and
  // Sends any previously earned SHER rewards to the _nftOwner address
  function _restake(
    uint256 _id,
    uint256 _period,
    address _nftOwner
  ) internal returns (uint256 _sher) {
    // Sends the SHER tokens previously earned by this NFT ID to the address of the NFT owner
    // NOTE This function deletes the SHER reward mapping for this NFT ID
    _sendSherRewardsToOwner(_id, _nftOwner);

    // tokenBalanceOf() returns the USDC amount owed to this NFT ID
    // _stake() restakes that amount of USDC for the period inputted
    // We use the same ID that we just deleted the SHER rewards mapping for
    // Resets the lockupEnd mapping and SHER token rewards mapping for this ID
    // Note stakeShares for this position do not change so no need to update
    _sher = _stake(tokenBalanceOf(_id), _period, _id, _nftOwner);

    emit Restaked(_id);
  }

  // This function is called in the UI by anyone who is staking for the first time (not restaking a previous position)
  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt
  /// @param _amount Amount of tokens to stake
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @param _receiver Address that will receive the NFT representing the position
  /// @return _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends
  /// @dev `_period` needs to be whitelisted
  function initialStake(
    uint256 _amount,
    uint256 _period,
    address _receiver
  ) external override whenNotPaused returns (uint256 _id, uint256 _sher) {
    if (_amount == 0) revert ZeroArgument();
    // Makes sure the period is a whitelisted period
    if (!stakingPeriods[_period]) revert InvalidArgument();
    if (address(_receiver) == address(0)) revert ZeroArgument();
    // Adds 1 to the ID of the last NFT created for the new NFT ID
    _id = ++nftCounter;

    // Transfers the USDC from the msg.sender to this contract for the amount specified (this is the staking action)
    token.safeTransferFrom(msg.sender, address(this), _amount);

    uint256 stakeShares_;
    uint256 totalStakeShares_ = totalStakeShares;
    // _amount of tokens divided by the "before" total amount of tokens, multiplied by the "before" amount of stake shares
    if (totalStakeShares_ != 0)
      stakeShares_ = (_amount * totalStakeShares_) / (totalTokenBalanceStakers() - _amount);
      // If this is the first stake ever, we just mint stake shares equal to the amount of USDC staked
    else stakeShares_ = _amount;

    // Assigns this NFT ID the calc'd amount of stake shares above
    stakeShares[_id] = stakeShares_;
    // Adds the newly created stake shares to the total amount of stake shares
    totalStakeShares += stakeShares_;

    // Locks up the USDC amount and calcs the SHER token amount to receive on unstake
    _sher = _stake(_amount, _period, _id, _receiver);

    // This is an ERC-721 function that creates an NFT and sends it to the receiver
    _safeMint(_receiver, _id);
  }

  // This is how a staker unstakes and cashes out on their position
  /// @notice Redeem NFT `_id` and receive `_amount` of tokens
  /// @param _id TokenID of the position
  /// @return _amount Amount of tokens (USDC) owed to NFT ID
  /// @dev Only the owner of `_id` will be able to redeem their position
  /// @dev The SHER rewards are sent to the NFT owner
  /// @dev Can only be called after lockup `_period` has ended
  function redeemNFT(uint256 _id) external override whenNotPaused returns (uint256 _amount) {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // This is the ERC-721 function to destroy an NFT (with owner's approval)
    _burn(_id);

    // Transfers USDC to the NFT owner based on the stake shares associated with this NFT ID
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC owed to these shares
    _amount = _redeemShares(_id, stakeShares[_id], msg.sender);

    // Sends the SHER tokens associated with this NFT ID to the NFT owner
    _sendSherRewardsToOwner(_id, msg.sender);

    // Removes the unlock deadline associated with this NFT
    delete lockupEnd_[_id];
  }

  // This is how a staker restakes an expired position
  /// @notice Owner restakes position with ID: `_id` for `_period` seconds
  /// @param _id ID of the position
  /// @param _period Period of time, in seconds, to lockup your funds
  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends
  /// @dev Only the owner of `_id` will be able to restake their position using this call
  /// @dev `_period` needs to be whitelisted
  /// @dev Can only be called after lockup `_period` has ended
  function ownerRestake(uint256 _id, uint256 _period)
    external
    override
    whenNotPaused
    returns (uint256 _sher)
  {
    // Checks to make sure caller is the owner of the NFT position, and that the lockup period is over
    _verifyUnlockableByOwner(_id);

    // Checks to make sure the staking period is a whitelisted one
    if (!stakingPeriods[_period]) revert InvalidArgument();

    // Sends the previously earned SHER token rewards to the owner and restakes the USDC value of the position
    _sher = _restake(_id, _period, msg.sender);
  }

  // Calcs the reward (in stake shares) an arb would get for restaking a position
  // Takes the NFT ID as a param and outputs the stake shares (which can be redeemed for USDC) for the arb
  function _calcSharesForArbRestake(uint256 _id) internal view returns (uint256, bool) {
    // this is the first point at which an arb can restake a position (i.e. two weeks after the initial lockup ends)
    uint256 initialArbTime = lockupEnd_[_id] + ARB_RESTAKE_WAIT_TIME;

    // If the initialArbTime has not passed, return 0 for the stake shares and false for whether an arb can restake the position
    if (initialArbTime > block.timestamp) return (0, false);

    // The max rewards (as a % of the position's shares) for the arb are available at this timestamp
    uint256 maxRewardArbTime = initialArbTime + ARB_RESTAKE_GROWTH_TIME;

    // Caps the timestamp at the maxRewardArbTime so the calc below never goes above 100%
    uint256 targetTime = block.timestamp < maxRewardArbTime ? block.timestamp : maxRewardArbTime;

    // Scaled by 10**18
    // Represents the max amount of stake shares that an arb could get from restaking this position
    uint256 maxRewardScaled = ARB_RESTAKE_MAX_PERCENTAGE * stakeShares[_id];

    // Calcs what % of the max reward an arb gets based on the timestamp at which they call this function
    // If targetTime == maxRewardArbTime, then the arb gets 100% of the maxRewardScaled
    return (
      ((targetTime - initialArbTime) * maxRewardScaled) / (ARB_RESTAKE_GROWTH_TIME) / 10**18,
      true
    );
  }

  /// @notice Calculates the reward in tokens (USDC) that an arb would get for calling restake on a position
  /// @return profit How much profit an arb would make in USDC
  /// @return able If the transaction can be executed (the current timestamp is during an arb period, etc.)
  function viewRewardForArbRestake(uint256 _id) external view returns (uint256 profit, bool able) {
    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    // `profit` variable is used to store the amount of shares
    (profit, able) = _calcSharesForArbRestake(_id);
    // Calculates the tokens (USDC) represented by that amount of stake shares
    // Amount of shares stored in `profit` is used to calculate the reward in USDC, which is stored in `profit`
    profit = _redeemSharesCalc(profit);
  }

  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)
  /// @param _id ID of the position
  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup
  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function
  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)
  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)
  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)
  function arbRestake(uint256 _id)
    external
    override
    whenNotPaused
    returns (uint256 _sher, uint256 _arbReward)
  {
    address nftOwner = ownerOf(_id);

    // Returns the stake shares that an arb would get, and whether the position can currently be arbed
    (uint256 arbRewardShares, bool able) = _calcSharesForArbRestake(_id);
    // Revert if not able to be arbed
    if (!able) revert InvalidConditions();

    // Transfers USDC to the arbitrager based on the stake shares associated with the arb reward
    // Also burns the requisite amount of shares associated with this NFT position
    // Returns the amount of USDC paid to the arbitrager
    _arbReward = _redeemShares(_id, arbRewardShares, msg.sender);

    // Restakes the tokens (USDC) associated with this position for the ARB_RESTAKE PERIOD (3 months)
    // Sends previously earned SHER rewards to the NFT owner address
    _sher = _restake(_id, ARB_RESTAKE_PERIOD, nftOwner);

    emit ArbRestaked(_id, _arbReward);
  }
}
.]

###

[2024-25-08 10:38:09 INFO] **[Seminar Conclusion]**:

 ###

[2024-25-08 10:38:09 INFO] **[Post Info]**

Software Info: 

**cost**=$0.000000

**version_updates**=1.0

**num_code_files**=0

**num_png_files**=0

**num_doc_files**=5

**code_lines**=0

**env_lines**=-1

**manual_lines**=-1

**num_utterances**=18

**num_self_reflections**=1

**num_prompt_tokens**=125479

**num_completion_tokens**=5251

**num_total_tokens**=130730

**duration**=84.00s

ChatDev Starts (20240825103645)

ChatDev Ends (20240825103809)



