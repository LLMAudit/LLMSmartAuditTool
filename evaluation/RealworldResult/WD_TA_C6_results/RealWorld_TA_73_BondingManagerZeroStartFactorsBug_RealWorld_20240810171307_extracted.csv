Integer Overflow/Underflow Identified,Reentrancy Identified,Unchecked External Calls Identified,Unchecked Low-level Calls Identified,Transactions Order Dependence Identified,Timestamp Manipulation Identified,Predictable Randomness Identified,Unsafe `tx.origin` Identified,Unsafe Suicide Identified,Gas Limit Identified,Price Manipulation Identified,Assumption of Fixed-Length Array Identified,Lack of Withdrawal Function Identified,Lack of Authorization Identified,Potential Data Inconsistency Identified,Hash Collision Identified,Uninitialized Return Variable Identified,Misdeclared Constructor Identified,Missing 'onlyOwner' Modifier Identified,Misuse of `msg.value` within a Loop Identified,Precision Loss Identified,Redundant Conditional Check Identified,External Oracle Dependency Identified,Ownership Hijacking Identified,Centralization Risk Identified,Incorrect Funding Rate Calculation Identified,Flash Loan Fee Manipulation Identified,Misuse of Mapping Getter Identified,Lack of Getter Function Implementation Identified,Unnecessary Comparison Identified,Inconsistent Initialization Identified,Potential Inconsistency in Yield Source Swapping Identified,Incorrect Signer Verification Identified,Order of Inheritance Initialization Identified,Impracticality of Exact Match Identified,Inconsistent Base Tokens Identified,Handling Partial Withdrawals Identified,Fallback Function Identified,Unlimited Token Approval Identified,Lack of Input Validation Identified,DoS Vulnerability Identified
"<INFO> Integer Overflow/Underflow Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Reentrancy Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unchecked External Calls Identified."".
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unchecked Low-level Calls Identified."".
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Transactions Order Dependence Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades
'''
```
If you don't find any Transactions Order Dependence vulnerabilities, respond only with: ""","<INFO> Timestamp Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Predictable Randomness Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unsafe `tx.origin` Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unsafe Suicide Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Lack of Restriction on `selfdestruct` is found, respond only with: ""","<INFO> Gas Limit Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Price Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Assumption of Fixed-Length Array Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Withdrawal Function Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If a secure withdrawal function is found and no issues are identified, respond only with: ""","<INFO> Lack of Authorization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Lack of Authorization vulnerabilities are found, respond only with: ""","<INFO> Potential Data Inconsistency Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Potential Data Inconsistency vulnerabilities are found, respond only with: ""","<INFO> Hash Collision Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Hash Collision vulnerabilities are found, respond only with: ""","<INFO> Uninitialized Return Variable Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Uninitialized Return Variable vulnerabilities are found, respond only with: ""","<INFO> Misdeclared Constructor Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Misdeclared Constructor vulnerabilities are found, respond only with: ""","<INFO> Missing 'onlyOwner' Modifier Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Misuse of `msg.value` within a Loop Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Precision Loss Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Redundant Conditional Check Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> External Oracle Dependency Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: """,,"<INFO> Centralization Risk Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Incorrect Funding Rate Calculation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Flash Loan Fee Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Misuse of Mapping Getter Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Getter Function Implementation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unnecessary Comparison Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Inconsistent Initialization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Potential Inconsistency in Yield Source Swapping Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Incorrect Signer Verification Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Order of Inheritance Initialization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Impracticality of Exact Match Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Inconsistent Base Tokens Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Handling Partial Withdrawals Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Fallback Function Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unlimited Token Approval Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Input Validation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> DoS Vulnerability Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades.
'''
```
If you don't find any vulnerabilities, respond only with: """
,,,"<INFO> Unchecked Low-level Calls Identified.

VULNERABILITY NAME: Unchecked Low-level Call in `withdrawStake`
'''
In the `withdrawStake` function, the contract calls `minter().trustedTransferTokens(msg.sender, amount);` which is a low-level call to transfer tokens to the delegator. This call does not

[2024-10-08 17:13:42 INFO] **[Seminar Conclusion]**:

 ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,"<INFO> Unchecked Low-level Calls Identified.

VULNERABILITY NAME: Unchecked Low-level Call in `withdrawStake`
'''
In the `withdrawStake` function, the contract calls `minter().trustedTransferTokens(msg.sender, amount);` which is a low-level call to transfer tokens to the delegator. This call does not

[2024-10-08 17:13:42 INFO] **[Execute Detail]**

execute SimplePhase:[TODDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-10-08 17:13:42 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | pragma solidity 0.5.11; import ""../../ManagerProxyTarget.sol""; import ""../IBondingManager.sol""; import ""../../libraries/SortedDoublyLL.sol""; import ""../../libraries/MathUtils.sol""; import ""../libraries/EarningsPool.sol""; import ""../libraries/EarningsPoolLIP36.sol""; import ""../../token/ILivepeerToken.sol""; import ""../../token/IMinter.sol""; import ""../../rounds/IRoundsManager.sol""; import ""../../snapshots/IMerkleSnapshot.sol""; import ""openzeppelin-solidity/contracts/math/SafeMath.sol""; /*  * @title BondingManager  * @notice Manages bonding, transcoder and rewards/fee accounting related operations of the Livepeer protocol  / contract BondingManagerZeroStartFactorsBug is ManagerProxyTarget, IBondingManager {     using SafeMath for uint256;     using SortedDoublyLL for SortedDoublyLL.Data;     using EarningsPool for EarningsPool.Data;     using EarningsPoolLIP36 for EarningsPool.Data; // Constants // Occurances are replaced at compile time // and computed to a single value if possible by the optimizer uint256 constant MAX_FUTURE_ROUND = 2**256 - 1;  // Time between unbonding and possible withdrawl in rounds uint64 public unbondingPeriod; // DEPRECATED - DO NOT USE uint256 public numActiveTranscodersDEPRECATED; // Max number of rounds that a caller can claim earnings for at once uint256 public maxEarningsClaimsRounds;  // Represents a transcoder's current state struct Transcoder {     uint256 lastRewardRound; // Last round that the transcoder called reward     uint256 rewardCut; // % of reward paid to transcoder by a delegator     uint256 feeShare; // % of fees paid to delegators by transcoder     uint256 pricePerSegmentDEPRECATED; // DEPRECATED - DO NOT USE     uint256 pendingRewardCutDEPRECATED; // DEPRECATED - DO NOT USE     uint256 pendingFeeShareDEPRECATED; // DEPRECATED - DO NOT USE     uint256 pendingPricePerSegmentDEPRECATED; // DEPRECATED - DO NOT USE     mapping(uint256 =&gt; EarningsPool.Data) earningsPoolPerRound; // Mapping of round =&gt; earnings pool for the round     uint256 lastActiveStakeUpdateRound; // Round for which the stake was last updated while the transcoder is active     uint256 activationRound; // Round in which the transcoder became active - 0 if inactive     uint256 deactivationRound; // Round in which the transcoder will become inactive     uint256 activeCumulativeRewards; // The transcoder's cumulative rewards that are active in the current round     uint256 cumulativeRewards; // The transcoder's cumulative rewards (earned via the its active staked rewards and its reward cut).     uint256 cumulativeFees; // The transcoder's cumulative fees (earned via the its active staked rewards and its fee share)     uint256 lastFeeRound; // Latest round in which the transcoder received fees }  // The various states a transcoder can be in enum TranscoderStatus {     NotRegistered,     Registered }  // Represents a delegator's current state struct Delegator {     uint256 bondedAmount; // The amount of bonded tokens     uint256 fees; // The amount of fees collected     address delegateAddress; // The address delegated to     uint256 delegatedAmount; // The amount of tokens delegated to the delegator     uint256 startRound; // The round the delegator transitions to bonded phase and is delegated to someone     uint256 withdrawRoundDEPRECATED; // DEPRECATED - DO NOT USE     uint256 lastClaimRound; // The last round during which the delegator claimed its earnings     uint256 nextUnbondingLockId; // ID for the next unbonding lock created     mapping(uint256 =&gt; UnbondingLock) unbondingLocks; // Mapping of unbonding lock ID =&gt; unbonding lock }  // The various states a delegator can be in enum DelegatorStatus {     Pending,     Bonded,     Unbonded }  // Represents an amount of tokens that are being unbonded struct UnbondingLock {     uint256 amount; // Amount of tokens being unbonded     uint256 withdrawRound; // Round at which unbonding period is over and tokens can be withdrawn }  // Keep track of the known transcoders and delegators mapping(address =&gt; Delegator) private delegators; mapping(address =&gt; Transcoder) private transcoders;  // DEPRECATED - DO NOT USE // The function getTotalBonded() no longer uses this variable // and instead calculates the total bonded value separately uint256 private totalBondedDEPRECATED;  // DEPRECATED - DO NOT USE SortedDoublyLL.Data private transcoderPoolDEPRECATED;  // DEPRECATED - DO NOT USE struct ActiveTranscoderSetDEPRECATED {     address[] transcoders;     mapping(address =&gt; bool) isActive;     uint256 totalStake; }  // DEPRECATED - DO NOT USE mapping(uint256 =&gt; ActiveTranscoderSetDEPRECATED) public activeTranscoderSetDEPRECATED;  // The total active stake (sum of the stake of active set members) for the current round uint256 public currentRoundTotalActiveStake; // The total active stake (sum of the stake of active set members) for the next round uint256 public nextRoundTotalActiveStake;  // The transcoder pool is used to keep track of the transcoders that are eligible for activation. // The pool keeps track of the pending active set in round N and the start of round N + 1 transcoders // in the pool are locked into the active set for round N + 1 SortedDoublyLL.Data private transcoderPoolV2;  // Check if sender is TicketBroker modifier onlyTicketBroker() {     _onlyTicketBroker();     _; }  // Check if sender is RoundsManager modifier onlyRoundsManager() {     _onlyRoundsManager();     _; }  // Check if sender is Verifier modifier onlyVerifier() {     _onlyVerifier();     _; }  // Check if current round is initialized modifier currentRoundInitialized() {     _currentRoundInitialized();     _; }  // Automatically claim earnings from lastClaimRound through the current round modifier autoClaimEarnings() {     _autoClaimEarnings();     _; }  /**  * @notice BondingManager constructor. Only invokes constructor of base Manager contract with provided Controller address  * @dev This constructor will not initialize any state variables besides `controller`. The following setter functions  * should be used to initialize state variables post-deployment:  * - setUnbondingPeriod()  * - setNumActiveTranscoders()  * - setMaxEarningsClaimsRounds()  * @param _controller Address of Controller that this contract will be registered with  */ constructor(address _controller) public Manager(_controller) {}  /**  * @notice Set unbonding period. Only callable by Controller owner  * @param _unbondingPeriod Rounds between unbonding and possible withdrawal  */ function setUnbondingPeriod(uint64 _unbondingPeriod) external onlyControllerOwner {     unbondingPeriod = _unbondingPeriod;      emit ParameterUpdate(""unbondingPeriod""); }  /**  * @notice Set maximum number of active transcoders. Only callable by Controller owner  * @param _numActiveTranscoders Number of active transcoders  */ function setNumActiveTranscoders(uint256 _numActiveTranscoders) external onlyControllerOwner {     transcoderPoolV2.setMaxSize(_numActiveTranscoders);      emit ParameterUpdate(""numActiveTranscoders""); }  /**  * @notice Set max number of rounds a caller can claim earnings for at once. Only callable by Controller owner  * @param _maxEarningsClaimsRounds Max number of rounds a caller can claim earnings for at once  */ function setMaxEarningsClaimsRounds(uint256 _maxEarningsClaimsRounds) external onlyControllerOwner {     maxEarningsClaimsRounds = _maxEarningsClaimsRounds;      emit ParameterUpdate(""maxEarningsClaimsRounds""); }  /**  * @notice Sets commission rates as a transcoder and if the caller is not in the transcoder pool tries to add it  * @dev Percentages are represented as numerators of fractions over MathUtils.PERC_DIVISOR  * @param _rewardCut % of reward paid to transcoder by a delegator  * @param _feeShare % of fees paid to delegators by a transcoder  */ function transcoder(uint256 _rewardCut, uint256 _feeShare) external {     transcoderWithHint(_rewardCut, _feeShare, address(0), address(0)); }  /**  * @notice Delegate stake towards a specific address  * @param _amount The amount of tokens to stake  * @param _to The address of the transcoder to stake towards  */ function bond(uint256 _amount, address _to) external {     bondWithHint(_amount, _to, address(0), address(0), address(0), address(0)); }  /**  * @notice Unbond an amount of the delegator's bonded stake  * @param _amount Amount of tokens to unbond  */ function unbond(uint256 _amount) external {     unbondWithHint(_amount, address(0), address(0)); }  /**  * @notice Rebond tokens for an unbonding lock to a delegator's current delegate while a delegator is in the Bonded or Pending status  * @param _unbondingLockId ID of unbonding lock to rebond with  */ function rebond(uint256 _unbondingLockId) external {     rebondWithHint(_unbondingLockId, address(0), address(0)); }  /**  * @notice Rebond tokens for an unbonding lock to a delegate while a delegator is in the Unbonded status  * @param _to Address of delegate  * @param _unbondingLockId ID of unbonding lock to rebond with  */ function rebondFromUnbonded(address _to, uint256 _unbondingLockId) external {     rebondFromUnbondedWithHint(_to, _unbondingLockId, address(0), address(0)); }  /**  * @notice Withdraws tokens for an unbonding lock that has existed through an unbonding period  * @param _unbondingLockId ID of unbonding lock to withdraw with  */ function withdrawStake(uint256 _unbondingLockId) external whenSystemNotPaused currentRoundInitialized {     Delegator storage del = delegators[msg.sender];     UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];      require(isValidUnbondingLock(msg.sender, _unbondingLockId), ""invalid unbonding lock ID"");     require(         lock.withdrawRound &lt;= roundsManager().currentRound(),         ""withdraw round must be before or equal to the current round""     );      uint256 amount = lock.amount;     uint256 withdrawRound = lock.withdrawRound;     // Delete unbonding lock     delete del.unbondingLocks[_unbondingLockId];      // Tell Minter to transfer stake (LPT) to the delegator     minter().trustedTransferTokens(msg.sender, amount);      emit WithdrawStake(msg.sender, _unbondingLockId, amount, withdrawRound); }  /**  * @notice Withdraws fees to the caller  */ function withdrawFees() external whenSystemNotPaused currentRoundInitialized autoClaimEarnings {     uint256 fees = delegators[msg.sender].fees;     require(fees &gt; 0, ""no fees to withdraw"");     delegators[msg.sender].fees = 0;      // Tell Minter to transfer fees (ETH) to the delegator     minter().trustedWithdrawETH(msg.sender, fees);      emit WithdrawFees(msg.sender); }  /**  * @notice Mint token rewards for an active transcoder and its delegators  */ function reward() external {     rewardWithHint(address(0), address(0)); }  /**  * @notice Update transcoder's fee pool. Only callable by the TicketBroker  * @param _transcoder Transcoder address  * @param _fees Fees to be added to the fee pool  */ function updateTranscoderWithFees(     address _transcoder,     uint256 _fees,     uint256 _round ) external whenSystemNotPaused onlyTicketBroker {     // Silence unused param compiler warning     _round;      require(isRegisteredTranscoder(_transcoder), ""transcoder must be registered"");      uint256 currentRound = roundsManager().currentRound();      Transcoder storage t = transcoders[_transcoder];      uint256 lastRewardRound = t.lastRewardRound;     uint256 activeCumulativeRewards = t.activeCumulativeRewards;      // LIP-36: Add fees for the current round instead of '_round'     // https://github.com/livepeer/LIPs/issues/35#issuecomment-673659199     EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[currentRound];     EarningsPool.Data memory prevEarningsPool = latestCumulativeFactorsPool(t, currentRound.sub(1));      // if transcoder hasn't called 'reward()' for '_round' its 'transcoderFeeShare', 'transcoderRewardCut' and 'totalStake'     // on the 'EarningsPool' for '_round' would not be initialized and the fee distribution wouldn't happen as expected     // for cumulative fee calculation this would result in division by zero.     if (currentRound &gt; lastRewardRound) {         earningsPool.setCommission(t.rewardCut, t.feeShare);          uint256 lastUpdateRound = t.lastActiveStakeUpdateRound;         if (lastUpdateRound &lt; currentRound) {             earningsPool.setStake(t.earningsPoolPerRound[lastUpdateRound].totalStake);         }          // If reward() has not been called yet in the current round, then the transcoder's activeCumulativeRewards has not         // yet been set in for the round. When the transcoder calls reward() its activeCumulativeRewards will be set to its         // current cumulativeRewards. So, we can just use the transcoder's cumulativeRewards here because this will become         // the transcoder's activeCumulativeRewards if it calls reward() later on in the current round         activeCumulativeRewards = t.cumulativeRewards;     }      uint256 totalStake = earningsPool.totalStake;     if (prevEarningsPool.cumulativeRewardFactor == 0 &amp;&amp; lastRewardRound == currentRound) {         // if transcoder called reward for 'currentRound' but not for 'currentRound - 1' (missed reward call)         // retroactively calculate what its cumulativeRewardFactor would have been for 'currentRound - 1' (cfr. previous lastRewardRound for transcoder)         // based on rewards for currentRound         IMinter mtr = minter();         uint256 rewards = MathUtils.percOf(             mtr.currentMintableTokens().add(mtr.currentMintedTokens()),             totalStake,             currentRoundTotalActiveStake         );         uint256 transcoderCommissionRewards = MathUtils.percOf(rewards, earningsPool.transcoderRewardCut);         uint256 delegatorsRewards = rewards.sub(transcoderCommissionRewards);          prevEarningsPool.cumulativeRewardFactor = MathUtils.percOf(             earningsPool.cumulativeRewardFactor,             totalStake,             delegatorsRewards.add(totalStake)         );     }      uint256 delegatorsFees = MathUtils.percOf(_fees, earningsPool.transcoderFeeShare);     uint256 transcoderCommissionFees = _fees.sub(delegatorsFees);     // Calculate the fees earned by the transcoder's earned rewards     uint256 transcoderRewardStakeFees = MathUtils.percOf(delegatorsFees, activeCumulativeRewards, totalStake);     // Track fees earned by the transcoder based on its earned rewards and feeShare     t.cumulativeFees = t.cumulativeFees.add(transcoderRewardStakeFees).add(transcoderCommissionFees);     // Update cumulative fee factor with new fees     // The cumulativeFeeFactor is used to calculate fees for all delegators including the transcoder (self-delegated)     // Note that delegatorsFees includes transcoderRewardStakeFees, but no delegator will claim that amount using     // the earnings claiming algorithm and instead that amount is accounted for in the transcoder's cumulativeFees field     earningsPool.updateCumulativeFeeFactor(prevEarningsPool, delegatorsFees);      t.lastFeeRound = currentRound; }  /**  * @notice Slash a transcoder. Only callable by the Verifier  * @param _transcoder Transcoder address  * @param _finder Finder that proved a transcoder violated a slashing condition. Null address if there is no finder  * @param _slashAmount Percentage of transcoder bond to be slashed  * @param _finderFee Percentage of penalty awarded to finder. Zero if there is no finder  */ function slashTranscoder(     address _transcoder,     address _finder,     uint256 _slashAmount,     uint256 _finderFee ) external whenSystemNotPaused onlyVerifier {     Delegator storage del = delegators[_transcoder];      if (del.bondedAmount &gt; 0) {         uint256 penalty = MathUtils.percOf(delegators[_transcoder].bondedAmount, _slashAmount);          // If active transcoder, resign it         if (transcoderPoolV2.contains(_transcoder)) {             resignTranscoder(_transcoder);         }          // Decrease bonded stake         del.bondedAmount = del.bondedAmount.sub(penalty);          // If still bonded decrease delegate's delegated amount         if (delegatorStatus(_transcoder) == DelegatorStatus.Bonded) {             delegators[del.delegateAddress].delegatedAmount = delegators[del.delegateAddress].delegatedAmount.sub(                 penalty             );         }          // Account for penalty         uint256 burnAmount = penalty;          // Award finder fee if there is a finder address         if (_finder != address(0)) {             uint256 finderAmount = MathUtils.percOf(penalty, _finderFee);             minter().trustedTransferTokens(_finder, finderAmount);              // Minter burns the slashed funds - finder reward             minter().trustedBurnTokens(burnAmount.sub(finderAmount));              emit TranscoderSlashed(_transcoder, _finder, penalty, finderAmount);         } else {             // Minter burns the slashed funds             minter().trustedBurnTokens(burnAmount);              emit TranscoderSlashed(_transcoder, address(0), penalty, 0);         }     } else {         emit TranscoderSlashed(_transcoder, _finder, 0, 0);     } }  /**  * @notice Claim token pools shares for a delegator from its lastClaimRound through the end round  * @param _endRound The last round for which to claim token pools shares for a delegator  */ function claimEarnings(uint256 _endRound) external whenSystemNotPaused currentRoundInitialized {     uint256 lastClaimRound = delegators[msg.sender].lastClaimRound;     require(lastClaimRound &lt; _endRound, ""end round must be after last claim round"");     require(_endRound &lt;= roundsManager().currentRound(), ""end round must be before or equal to current round"");      updateDelegatorWithEarnings(msg.sender, _endRound, lastClaimRound); }  /**  * @notice Claim earnings for a delegator based on the snapshot taken in LIP-52  * @dev https://github.com/livepeer/LIPs/blob/master/LIPs/LIP-52.md  * @param _pendingStake the amount of pending stake for the delegator (current stake + pending rewards)  * @param _pendingFees the amount of pending fees for the delegator (current fees + pending fees)  * @param _earningsProof array of keccak256 sibling hashes on the branch of the leaf for the delegator up to the root  * @param _data (optional) raw transaction data to be executed on behalf of msg.sender after claiming snapshot earnings  */ function claimSnapshotEarnings(     uint256 _pendingStake,     uint256 _pendingFees,     bytes32[] calldata _earningsProof,     bytes calldata _data ) external whenSystemNotPaused currentRoundInitialized {     Delegator storage del = delegators[msg.sender];      uint256 lip52Round = roundsManager().lipUpgradeRound(52);      uint256 lastClaimRound = del.lastClaimRound;      require(lastClaimRound &lt; lip52Round, ""Already claimed for LIP-52"");      bytes32 leaf = keccak256(abi.encode(msg.sender, _pendingStake, _pendingFees));      require(         IMerkleSnapshot(controller.getContract(keccak256(""MerkleSnapshot""))).verify(             keccak256(""LIP-52""),             _earningsProof,             leaf         ),         ""Merkle proof is invalid""     );      emit EarningsClaimed(         del.delegateAddress,         msg.sender,         _pendingStake.sub(del.bondedAmount),         _pendingFees.sub(del.fees),         lastClaimRound.add(1),         lip52Round     );      del.lastClaimRound = lip52Round;     del.bondedAmount = _pendingStake;     del.fees = _pendingFees;      // allow for execution of subsequent claiming or staking operations     if (_data.length &gt; 0) {         (bool success, bytes memory returnData) = address(this).delegatecall(_data);         require(success, string(returnData));     } }  /**  * @notice Called during round initialization to set the total active stake for the round. Only callable by the RoundsManager  */ function setCurrentRoundTotalActiveStake() external onlyRoundsManager {     currentRoundTotalActiveStake = nextRoundTotalActiveStake; }  /**  * @notice Sets commission rates as a transcoder and if the caller is not in the transcoder pool tries to add it using an optional list hint  * @dev Percentages are represented as numerators of fractions over MathUtils.PERC_DIVISOR. If the caller is going to be added to the pool, the  * caller can provide an optional hint for the insertion position in the pool via the `_newPosPrev` and `_newPosNext` params. A linear search will  * be executed starting at the hint to find the correct position - in the best case, the hint is the correct position so no search is executed.  * See SortedDoublyLL.sol for details on list hints  * @param _rewardCut % of reward paid to transcoder by a delegator  * @param _feeShare % of fees paid to delegators by a transcoder  * @param _newPosPrev Address of previous transcoder in pool if the caller joins the pool  * @param _newPosNext Address of next transcoder in pool if the caller joins the pool  */ function transcoderWithHint(     uint256 _rewardCut,     uint256 _feeShare,     address _newPosPrev,     address _newPosNext ) public whenSystemNotPaused currentRoundInitialized {     require(!roundsManager().currentRoundLocked(), ""can't update transcoder params, current round is locked"");     require(MathUtils.validPerc(_rewardCut), ""invalid rewardCut percentage"");     require(MathUtils.validPerc(_feeShare), ""invalid feeShare percentage"");     require(isRegisteredTranscoder(msg.sender), ""transcoder must be registered"");      Transcoder storage t = transcoders[msg.sender];     uint256 currentRound = roundsManager().currentRound();      require(         !isActiveTranscoder(msg.sender) || t.lastRewardRound == currentRound,         ""caller can't be active or must have already called reward for the current round""     );      t.rewardCut = _rewardCut;     t.feeShare = _feeShare;      if (!transcoderPoolV2.contains(msg.sender)) {         tryToJoinActiveSet(             msg.sender,             delegators[msg.sender].delegatedAmount,             currentRound.add(1),             _newPosPrev,             _newPosNext         );     }      emit TranscoderUpdate(msg.sender, _rewardCut, _feeShare); }  /**  * @notice Delegate stake towards a specific address and updates the transcoder pool using optional list hints if needed  * @dev If the caller is decreasing the stake of its old delegate in the transcoder pool, the caller can provide an optional hint  * for the insertion position of the old delegate via the `_oldDelegateNewPosPrev` and `_oldDelegateNewPosNext` params.  * If the caller is delegating to a delegate that is in the transcoder pool, the caller can provide an optional hint for the  * insertion position of the delegate via the `_currDelegateNewPosPrev` and `_currDelegateNewPosNext` params.  * In both cases, a linear search will be executed starting at the hint to find the correct position. In the best case, the hint  * is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints  * @param _amount The amount of tokens to stake.  * @param _to The address of the transcoder to stake towards  * @param _oldDelegateNewPosPrev The address of the previous transcoder in the pool for the old delegate  * @param _oldDelegateNewPosNext The address of the next transcoder in the pool for the old delegate  * @param _currDelegateNewPosPrev The address of the previous transcoder in the pool for the current delegate  * @param _currDelegateNewPosNext The address of the next transcoder in the pool for the current delegate  */ function bondWithHint(     uint256 _amount,     address _to,     address _oldDelegateNewPosPrev,     address _oldDelegateNewPosNext,     address _currDelegateNewPosPrev,     address _currDelegateNewPosNext ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {     Delegator storage del = delegators[msg.sender];      uint256 currentRound = roundsManager().currentRound();     // Amount to delegate     uint256 delegationAmount = _amount;     // Current delegate     address currentDelegate = del.delegateAddress;      if (delegatorStatus(msg.sender) == DelegatorStatus.Unbonded) {         // New delegate         // Set start round         // Don't set start round if delegator is in pending state because the start round would not change         del.startRound = currentRound.add(1);         // Unbonded state = no existing delegate and no bonded stake         // Thus, delegation amount = provided amount     } else if (currentDelegate != address(0) &amp;&amp; currentDelegate != _to) {         // A registered transcoder cannot delegate its bonded stake toward another address         // because it can only be delegated toward itself         // In the future, if delegation towards another registered transcoder as an already         // registered transcoder becomes useful (i.e. for transitive delegation), this restriction         // could be removed         require(             !isRegisteredTranscoder(msg.sender),             ""registered transcoders can't delegate towards other addresses""         );         // Changing delegate         // Set start round         del.startRound = currentRound.add(1);         // Update amount to delegate with previous delegation amount         delegationAmount = delegationAmount.add(del.bondedAmount);          decreaseTotalStake(currentDelegate, del.bondedAmount, _oldDelegateNewPosPrev, _oldDelegateNewPosNext);     }      // cannot delegate to someone without having bonded stake     require(delegationAmount &gt; 0, ""delegation amount must be greater than 0"");     // Update delegate     del.delegateAddress = _to;     // Update bonded amount     del.bondedAmount = del.bondedAmount.add(_amount);      increaseTotalStake(_to, delegationAmount, _currDelegateNewPosPrev, _currDelegateNewPosNext);      if (_amount &gt; 0) {         // Transfer the LPT to the Minter         livepeerToken().transferFrom(msg.sender, address(minter()), _amount);     }      emit Bond(_to, currentDelegate, msg.sender, _amount, del.bondedAmount); }  /**  * @notice Unbond an amount of the delegator's bonded stake and updates the transcoder pool using an optional list hint if needed  * @dev If the caller remains in the transcoder pool, the caller can provide an optional hint for its insertion position in the  * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.  * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol details on list hints  * @param _amount Amount of tokens to unbond  * @param _newPosPrev Address of previous transcoder in pool if the caller remains in the pool  * @param _newPosNext Address of next transcoder in pool if the caller remains in the pool  */ function unbondWithHint(     uint256 _amount,     address _newPosPrev,     address _newPosNext ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {     require(delegatorStatus(msg.sender) == DelegatorStatus.Bonded, ""caller must be bonded"");      Delegator storage del = delegators[msg.sender];      require(_amount &gt; 0, ""unbond amount must be greater than 0"");     require(_amount &lt;= del.bondedAmount, ""amount is greater than bonded amount"");      address currentDelegate = del.delegateAddress;     uint256 currentRound = roundsManager().currentRound();     uint256 withdrawRound = currentRound.add(unbondingPeriod);     uint256 unbondingLockId = del.nextUnbondingLockId;      // Create new unbonding lock     del.unbondingLocks[unbondingLockId] = UnbondingLock({ amount: _amount, withdrawRound: withdrawRound });     // Increment ID for next unbonding lock     del.nextUnbondingLockId = unbondingLockId.add(1);     // Decrease delegator's bonded amount     del.bondedAmount = del.bondedAmount.sub(_amount);      if (del.bondedAmount == 0) {         // Delegator no longer delegated to anyone if it does not have a bonded amount         del.delegateAddress = address(0);         // Delegator does not have a start round if it is no longer delegated to anyone         del.startRound = 0;          if (transcoderPoolV2.contains(msg.sender)) {             resignTranscoder(msg.sender);         }     }      // If msg.sender was resigned this statement will only decrease delegators[currentDelegate].delegatedAmount     decreaseTotalStake(currentDelegate, _amount, _newPosPrev, _newPosNext);      emit Unbond(currentDelegate, msg.sender, unbondingLockId, _amount, withdrawRound); }  /**  * @notice Rebond tokens for an unbonding lock to a delegator's current delegate while a delegator is in the Bonded or Pending status and updates  * the transcoder pool using an optional list hint if needed  * @dev If the delegate is in the transcoder pool, the caller can provide an optional hint for the delegate's insertion position in the  * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.  * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol details on list hints  * @param _unbondingLockId ID of unbonding lock to rebond with  * @param _newPosPrev Address of previous transcoder in pool if the delegate is in the pool  * @param _newPosNext Address of next transcoder in pool if the delegate is in the pool  */ function rebondWithHint(     uint256 _unbondingLockId,     address _newPosPrev,     address _newPosNext ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {     require(delegatorStatus(msg.sender) != DelegatorStatus.Unbonded, ""caller must be bonded"");      // Process rebond using unbonding lock     processRebond(msg.sender, _unbondingLockId, _newPosPrev, _newPosNext); }  /**  * @notice Rebond tokens for an unbonding lock to a delegate while a delegator is in the Unbonded status and updates the transcoder pool using  * an optional list hint if needed  * @dev If the delegate joins the transcoder pool, the caller can provide an optional hint for the delegate's insertion position in the  * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.  * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints  * @param _to Address of delegate  * @param _unbondingLockId ID of unbonding lock to rebond with  * @param _newPosPrev Address of previous transcoder in pool if the delegate joins the pool  * @param _newPosNext Address of next transcoder in pool if the delegate joins the pool  */ function rebondFromUnbondedWithHint(     address _to,     uint256 _unbondingLockId,     address _newPosPrev,     address _newPosNext ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {     require(delegatorStatus(msg.sender) == DelegatorStatus.Unbonded, ""caller must be unbonded"");      // Set delegator's start round and transition into Pending state     delegators[msg.sender].startRound = roundsManager().currentRound().add(1);     // Set delegator's delegate     delegators[msg.sender].delegateAddress = _to;     // Process rebond using unbonding lock     processRebond(msg.sender, _unbondingLockId, _newPosPrev, _newPosNext); }  /**  * @notice Mint token rewards for an active transcoder and its delegators and update the transcoder pool using an optional list hint if needed  * @dev If the caller is in the transcoder pool, the caller can provide an optional hint for its insertion position in the  * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.  * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints  * @param _newPosPrev Address of previous transcoder in pool if the caller is in the pool  * @param _newPosNext Address of next transcoder in pool if the caller is in the pool  */ function rewardWithHint(address _newPosPrev, address _newPosNext)     public     whenSystemNotPaused     currentRoundInitialized {     uint256 currentRound = roundsManager().currentRound();      require(isActiveTranscoder(msg.sender), ""caller must be an active transcoder"");     require(         transcoders[msg.sender].lastRewardRound != currentRound,         ""caller has already called reward for the current round""     );      Transcoder storage t = transcoders[msg.sender];     EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[currentRound];      // Set last round that transcoder called reward     earningsPool.setCommission(t.rewardCut, t.feeShare);      // If transcoder didn't receive stake updates during the previous round and hasn't called reward for &gt; 1 round     // the 'totalStake' on its 'EarningsPool' for the current round wouldn't be initialized     // Thus we sync the the transcoder's stake to when it was last updated     // 'updateTrancoderWithRewards()' will set the update round to 'currentRound +1' so this synchronization shouldn't occur frequently     uint256 lastUpdateRound = t.lastActiveStakeUpdateRound;     if (lastUpdateRound &lt; currentRound) {         earningsPool.setStake(t.earningsPoolPerRound[lastUpdateRound].totalStake);     }      // Create reward based on active transcoder's stake relative to the total active stake     // rewardTokens = (current mintable tokens for the round * active transcoder stake) / total active stake     uint256 rewardTokens = minter().createReward(earningsPool.totalStake, currentRoundTotalActiveStake);      updateTranscoderWithRewards(msg.sender, rewardTokens, currentRound, _newPosPrev, _newPosNext);      // Set last round that transcoder called reward     t.lastRewardRound = currentRound;      emit Reward(msg.sender, rewardTokens); }  /**  * @notice Returns pending bonded stake for a delegator from its lastClaimRound through an end round  * @param _delegator Address of delegator  * @param _endRound The last round to compute pending stake from  * @return Pending bonded stake for '_delegator' since last claiming rewards  */ function pendingStake(address _delegator, uint256 _endRound) public view returns (uint256) {     (uint256 stake, ) = pendingStakeAndFees(_delegator, _endRound);     return stake; }  /**  * @notice Returns pending fees for a delegator from its lastClaimRound through an end round  * @param _delegator Address of delegator  * @param _endRound The last round to compute pending fees from  * @return Pending fees for '_delegator' since last claiming fees  */ function pendingFees(address _delegator, uint256 _endRound) public view returns (uint256) {     (, uint256 fees) = pendingStakeAndFees(_delegator, _endRound);     return fees; }  /**  * @notice Returns total bonded stake for a transcoder  * @param _transcoder Address of transcoder  * @return total bonded stake for a delegator  */ function transcoderTotalStake(address _transcoder) public view returns (uint256) {     return delegators[_transcoder].delegatedAmount; }  /**  * @notice Computes transcoder status  * @param _transcoder Address of transcoder  * @return registered or not registered transcoder status  */ function transcoderStatus(address _transcoder) public view returns (TranscoderStatus) {     if (isRegisteredTranscoder(_transcoder)) return TranscoderStatus.Registered;     return TranscoderStatus.NotRegistered; }  /**  * @notice Computes delegator status  * @param _delegator Address of delegator  * @return bonded, unbonded or pending delegator status  */ function delegatorStatus(address _delegator) public view returns (DelegatorStatus) {     Delegator storage del = delegators[_delegator];      if (del.bondedAmount == 0) {         // Delegator unbonded all its tokens         return DelegatorStatus.Unbonded;     } else if (del.startRound &gt; roundsManager().currentRound()) {         // Delegator round start is in the future         return DelegatorStatus.Pending;     } else {         // Delegator round start is now or in the past         // del.startRound != 0 here because if del.startRound = 0 then del.bondedAmount = 0 which         // would trigger the first if clause         return DelegatorStatus.Bonded;     } }  /**  * @notice Return transcoder information  * @param _transcoder Address of transcoder  * @return lastRewardRound Trancoder's last reward round  * @return rewardCut Transcoder's reward cut  * @return feeShare Transcoder's fee share  * @return lastActiveStakeUpdateRound Round in which transcoder's stake was last updated while active  * @return activationRound Round in which transcoder became active  * @return deactivationRound Round in which transcoder will no longer be active  * @return activeCumulativeRewards Transcoder's cumulative rewards that are currently active  * @return cumulativeRewards Transcoder's cumulative rewards (earned via its active staked rewards and its reward cut)  * @return cumulativeFees Transcoder's cumulative fees (earned via its active staked rewards and its fee share)  * @return lastFeeRound Latest round that the transcoder received fees  */ function getTranscoder(address _transcoder)     public     view     returns (         uint256 lastRewardRound,         uint256 rewardCut,         uint256 feeShare,         uint256 lastActiveStakeUpdateRound,         uint256 activationRound,         uint256 deactivationRound,         uint256 activeCumulativeRewards,         uint256 cumulativeRewards,         uint256 cumulativeFees,         uint256 lastFeeRound     ) {     Transcoder storage t = transcoders[_transcoder];      lastRewardRound = t.lastRewardRound;     rewardCut = t.rewardCut;     feeShare = t.feeShare;     lastActiveStakeUpdateRound = t.lastActiveStakeUpdateRound;     activationRound = t.activationRound;     deactivationRound = t.deactivationRound;     activeCumulativeRewards = t.activeCumulativeRewards;     cumulativeRewards = t.cumulativeRewards;     cumulativeFees = t.cumulativeFees;     lastFeeRound = t.lastFeeRound; }  /**  * @notice Return transcoder's earnings pool for a given round  * @param _transcoder Address of transcoder  * @param _round Round number  * @return rewardPool Reward pool for delegators (only used before LIP-36)  * @return feePool Fee pool for delegators (only used before LIP-36)  * @return totalStake Transcoder's total stake in '_round'  * @return claimableStake Remaining stake that can be used to claim from the pool (only used before LIP-36)  * @return transcoderRewardCut Transcoder's reward cut for '_round'  * @return transcoderFeeShare Transcoder's fee share for '_round'  * @return transcoderRewardPool Transcoder's rewards for '_round' (only used before LIP-36)  * @return transcoderFeePool Transcoder's fees for '_round' (only used before LIP-36)  * @return hasTranscoderRewardFeePool True if there is a split reward/fee pool for the transcoder (only used before LIP-36)  * @return cumulativeRewardFactor The cumulative reward factor for delegator rewards calculation (only used after LIP-36)  * @return cumulativeFeeFactor The cumulative fee factor for delegator fees calculation (only used after LIP-36)  */ function getTranscoderEarningsPoolForRound(address _transcoder, uint256 _round)     public     view     returns (         uint256 rewardPool,         uint256 feePool,         uint256 totalStake,         uint256 claimableStake,         uint256 transcoderRewardCut,         uint256 transcoderFeeShare,         uint256 transcoderRewardPool,         uint256 transcoderFeePool,         bool hasTranscoderRewardFeePool,         uint256 cumulativeRewardFactor,         uint256 cumulativeFeeFactor     ) {     EarningsPool.Data storage earningsPool = transcoders[_transcoder].earningsPoolPerRound[_round];      rewardPool = earningsPool.rewardPool;     feePool = earningsPool.feePool;     totalStake = earningsPool.totalStake;     claimableStake = earningsPool.claimableStake;     transcoderRewardCut = earningsPool.transcoderRewardCut;     transcoderFeeShare = earningsPool.transcoderFeeShare;     transcoderRewardPool = earningsPool.transcoderRewardPool;     transcoderFeePool = earningsPool.transcoderFeePool;     hasTranscoderRewardFeePool = earningsPool.hasTranscoderRewardFeePool;     cumulativeRewardFactor = earningsPool.cumulativeRewardFactor;     cumulativeFeeFactor = earningsPool.cumulativeFeeFactor; }  /**  * @notice Return delegator info  * @param _delegator Address of delegator  * @return total amount bonded by '_delegator'  * @return amount of fees collected by '_delegator'  * @return address '_delegator' has bonded to  * @return total amount delegated to '_delegator'  * @return round in which bond for '_delegator' became effective  * @return round for which '_delegator' has last claimed earnings  * @return ID for the next unbonding lock created for '_delegator'  */ function getDelegator(address _delegator)     public     view     returns (         uint256 bondedAmount,         uint256 fees,         address delegateAddress,         uint256 delegatedAmount,         uint256 startRound,         uint256 lastClaimRound,         uint256 nextUnbondingLockId     ) {     Delegator storage del = delegators[_delegator];      bondedAmount = del.bondedAmount;     fees = del.fees;     delegateAddress = del.delegateAddress;     delegatedAmount = del.delegatedAmount;     startRound = del.startRound;     lastClaimRound = del.lastClaimRound;     nextUnbondingLockId = del.nextUnbondingLockId; }  /**  * @notice Return delegator's unbonding lock info  * @param _delegator Address of delegator  * @param _unbondingLockId ID of unbonding lock  * @return amount of stake locked up by unbonding lock  * @return round in which 'amount' becomes available for withdrawal  */ function getDelegatorUnbondingLock(address _delegator, uint256 _unbondingLockId)     public     view     returns (uint256 amount, uint256 withdrawRound) {     UnbondingLock storage lock = delegators[_delegator].unbondingLocks[_unbondingLockId];      return (lock.amount, lock.withdrawRound); }  /**  * @notice Returns max size of transcoder pool  * @return transcoder pool max size  */ function getTranscoderPoolMaxSize() public view returns (uint256) {     return transcoderPoolV2.getMaxSize(); }  /**  * @notice Returns size of transcoder pool  * @return transcoder pool current size  */ function getTranscoderPoolSize() public view returns (uint256) {     return transcoderPoolV2.getSize(); }  /**  * @notice Returns transcoder with most stake in pool  * @return address for transcoder with highest stake in transcoder pool  */ function getFirstTranscoderInPool() public view returns (address) {     return transcoderPoolV2.getFirst(); }  /**  * @notice Returns next transcoder in pool for a given transcoder  * @param _transcoder Address of a transcoder in the pool  * @return address for the transcoder after '_transcoder' in transcoder pool  */ function getNextTranscoderInPool(address _transcoder) public view returns (address) {     return transcoderPoolV2.getNext(_transcoder); }  /**  * @notice Return total bonded tokens  * @return total active stake for the current round  */ function getTotalBonded() public view returns (uint256) {     return currentRoundTotalActiveStake; }  /**  * @notice Return whether a transcoder is active for the current round  * @param _transcoder Transcoder address  * @return true if transcoder is active  */ function isActiveTranscoder(address _transcoder) public view returns (bool) {     Transcoder storage t = transcoders[_transcoder];     uint256 currentRound = roundsManager().currentRound();     return t.activationRound &lt;= currentRound &amp;&amp; currentRound &lt; t.deactivationRound; }  /**  * @notice Return whether a transcoder is registered  * @param _transcoder Transcoder address  * @return true if transcoder is self-bonded  */ function isRegisteredTranscoder(address _transcoder) public view returns (bool) {     Delegator storage d = delegators[_transcoder];     return d.delegateAddress == _transcoder &amp;&amp; d.bondedAmount &gt; 0; }  /**  * @notice Return whether an unbonding lock for a delegator is valid  * @param _delegator Address of delegator  * @param _unbondingLockId ID of unbonding lock  * @return true if unbondingLock for ID has a non-zero withdraw round  */ function isValidUnbondingLock(address _delegator, uint256 _unbondingLockId) public view returns (bool) {     // A unbonding lock is only valid if it has a non-zero withdraw round (the default value is zero)     return delegators[_delegator].unbondingLocks[_unbondingLockId].withdrawRound &gt; 0; }  /**  * @notice Return an EarningsPool.Data struct with the latest cumulative factors for a given round  * @param _transcoder Storage pointer to a transcoder struct  * @param _round The round to fetch the latest cumulative factors for  * @return pool An EarningsPool.Data populated with the latest cumulative factors for _round  */ function latestCumulativeFactorsPool(Transcoder storage _transcoder, uint256 _round)     internal     view     returns (EarningsPool.Data memory pool) {     pool.cumulativeRewardFactor = _transcoder.earningsPoolPerRound[_round].cumulativeRewardFactor;     pool.cumulativeFeeFactor = _transcoder.earningsPoolPerRound[_round].cumulativeFeeFactor;      uint256 lastRewardRound = _transcoder.lastRewardRound;     // Only use the cumulativeRewardFactor for lastRewardRound if lastRewardRound is before _round     if (pool.cumulativeRewardFactor == 0 &amp;&amp; lastRewardRound &lt; _round) {         pool.cumulativeRewardFactor = _transcoder.earningsPoolPerRound[lastRewardRound].cumulativeRewardFactor;     }      uint256 lastFeeRound = _transcoder.lastFeeRound;     // Only use the cumulativeFeeFactor for lastFeeRound if lastFeeRound is before _round     if (pool.cumulativeFeeFactor == 0 &amp;&amp; lastFeeRound &lt; _round) {         pool.cumulativeFeeFactor = _transcoder.earningsPoolPerRound[lastFeeRound].cumulativeFeeFactor;     }      return pool; }  /**  * @notice Return a delegator's cumulative stake and fees using the LIP-36 earnings claiming algorithm  * @param _transcoder Storage pointer to a transcoder struct for a delegator's delegate  * @param _startRound The round for the start cumulative factors  * @param _endRound The round for the end cumulative factors  * @param _stake The delegator's initial stake before including earned rewards  * @param _fees The delegator's initial fees before including earned fees  * @return (cStake, cFees) where cStake is the delegator's cumulative stake including earned rewards and cFees is the delegator's cumulative fees including earned fees  */ function delegatorCumulativeStakeAndFees(     Transcoder storage _transcoder,     uint256 _startRound,     uint256 _endRound,     uint256 _stake,     uint256 _fees ) internal view returns (uint256 cStake, uint256 cFees) {     uint256 baseRewardFactor = MathUtils.percPoints(1, 1);      // Fetch start cumulative factors     EarningsPool.Data memory startPool;     startPool.cumulativeRewardFactor = _transcoder.earningsPoolPerRound[_startRound].cumulativeRewardFactor;     startPool.cumulativeFeeFactor = _transcoder.earningsPoolPerRound[_startRound].cumulativeFeeFactor;      if (startPool.cumulativeRewardFactor == 0) {         startPool.cumulativeRewardFactor = baseRewardFactor;     }      // Fetch end cumulative factors     EarningsPool.Data memory endPool = latestCumulativeFactorsPool(_transcoder, _endRound);      if (endPool.cumulativeRewardFactor == 0) {         endPool.cumulativeRewardFactor = baseRewardFactor;     }      cFees = _fees.add(         MathUtils.percOf(             _stake,             endPool.cumulativeFeeFactor.sub(startPool.cumulativeFeeFactor),             startPool.cumulativeRewardFactor         )     );      cStake = MathUtils.percOf(_stake, endPool.cumulativeRewardFactor, startPool.cumulativeRewardFactor);      return (cStake, cFees); }  /**  * @notice Return the pending stake and fees for a delegator  * @param _delegator Address of a delegator  * @param _endRound The last round to claim earnings for when calculating the pending stake and fees  * @return (stake, fees) where stake is the delegator's pending stake and fees is the delegator's pending fees  */ function pendingStakeAndFees(address _delegator, uint256 _endRound)     internal     view     returns (uint256 stake, uint256 fees) {     Delegator storage del = delegators[_delegator];     Transcoder storage t = transcoders[del.delegateAddress];      fees = del.fees;     stake = del.bondedAmount;      uint256 startRound = del.lastClaimRound.add(1);     address delegateAddr = del.delegateAddress;     bool isTranscoder = _delegator == delegateAddr;      uint256 lip36Round = roundsManager().lipUpgradeRound(36);     while (startRound &lt;= _endRound &amp;&amp; startRound &lt;= lip36Round) {         EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[startRound];          // If earningsPool.hasTranscoderRewardFeePool is not set during lip36Round then the transcoder did not call         // reward during lip36Round before the upgrade. In this case, if the transcoder calls reward in lip36Round         // the delegator can use the LIP-36 earnings claiming algorithm to claim for lip36Round         if (startRound == lip36Round &amp;&amp; !earningsPool.hasTranscoderRewardFeePool) {             break;         }          if (earningsPool.hasClaimableShares()) {             // Calculate and add fee pool share from this round             fees = fees.add(earningsPool.feePoolShare(stake, isTranscoder));             // Calculate new bonded amount with rewards from this round. Updated bonded amount used             // to calculate fee pool share in next round             stake = stake.add(earningsPool.rewardPoolShare(stake, isTranscoder));         }          startRound = startRound.add(1);     }      // If the transcoder called reward during lip36Round the upgrade, then startRound = lip36Round     // Otherwise, startRound = lip36Round + 1      // If the start round is greater than the end round, we've already claimed for the end round so we do not     // need to execute the LIP-36 earnings claiming algorithm. This could be the case if:     // - _endRound &lt; lip36Round i.e. we are not claiming through the lip36Round     // - _endRound == lip36Round AND startRound = lip36Round + 1 i.e we already claimed through the lip36Round     if (startRound &gt; _endRound) {         return (stake, fees);     }      // The LIP-36 earnings claiming algorithm uses the cumulative factors from the delegator's lastClaimRound i.e. startRound - 1     // and from the specified _endRound     (stake, fees) = delegatorCumulativeStakeAndFees(t, startRound.sub(1), _endRound, stake, fees);      if (isTranscoder) {         stake = stake.add(t.cumulativeRewards);         fees = fees.add(t.cumulativeFees);     }      return (stake, fees); }  /**  * @dev Increase the total stake for a delegate and updates its 'lastActiveStakeUpdateRound'  * @param _delegate The delegate to increase the stake for  * @param _amount The amount to increase the stake for '_delegate' by  */ function increaseTotalStake(     address _delegate,     uint256 _amount,     address _newPosPrev,     address _newPosNext ) internal {     if (isRegisteredTranscoder(_delegate)) {         uint256 currStake = transcoderTotalStake(_delegate);         uint256 newStake = currStake.add(_amount);         uint256 currRound = roundsManager().currentRound();         uint256 nextRound = currRound.add(1);          // If the transcoder is already in the active set update its stake and return         if (transcoderPoolV2.contains(_delegate)) {             transcoderPoolV2.updateKey(_delegate, newStake, _newPosPrev, _newPosNext);             nextRoundTotalActiveStake = nextRoundTotalActiveStake.add(_amount);             Transcoder storage t = transcoders[_delegate];              // currStake (the transcoder's delegatedAmount field) will reflect the transcoder's stake from lastActiveStakeUpdateRound             // because it is updated every time lastActiveStakeUpdateRound is updated             // The current active total stake is set to currStake to ensure that the value can be used in updateTranscoderWithRewards()             // and updateTranscoderWithFees() when lastActiveStakeUpdateRound &gt; currentRound             if (t.lastActiveStakeUpdateRound &lt; currRound) {                 t.earningsPoolPerRound[currRound].setStake(currStake);             }              t.earningsPoolPerRound[nextRound].setStake(newStake);             t.lastActiveStakeUpdateRound = nextRound;         } else {             // Check if the transcoder is eligible to join the active set in the update round             tryToJoinActiveSet(_delegate, newStake, nextRound, _newPosPrev, _newPosNext);         }     }      // Increase delegate's delegated amount     delegators[_delegate].delegatedAmount = delegators[_delegate].delegatedAmount.add(_amount); }  /**  * @dev Decrease the total stake for a delegate and updates its 'lastActiveStakeUpdateRound'  * @param _delegate The transcoder to decrease the stake for  * @param _amount The amount to decrease the stake for '_delegate' by  */ function decreaseTotalStake(     address _delegate,     uint256 _amount,     address _newPosPrev,     address _newPosNext ) internal {     if (transcoderPoolV2.contains(_delegate)) {         uint256 currStake = transcoderTotalStake(_delegate);         uint256 newStake = currStake.sub(_amount);         uint256 currRound = roundsManager().currentRound();         uint256 nextRound = currRound.add(1);          transcoderPoolV2.updateKey(_delegate, newStake, _newPosPrev, _newPosNext);         nextRoundTotalActiveStake = nextRoundTotalActiveStake.sub(_amount);         Transcoder storage t = transcoders[_delegate];          // currStake (the transcoder's delegatedAmount field) will reflect the transcoder's stake from lastActiveStakeUpdateRound         // because it is updated every time lastActiveStakeUpdateRound is updated         // The current active total stake is set to currStake to ensure that the value can be used in updateTranscoderWithRewards()         // and updateTranscoderWithFees() when lastActiveStakeUpdateRound &gt; currentRound         if (t.lastActiveStakeUpdateRound &lt; currRound) {             t.earningsPoolPerRound[currRound].setStake(currStake);         }          t.lastActiveStakeUpdateRound = nextRound;         t.earningsPoolPerRound[nextRound].setStake(newStake);     }      // Decrease old delegate's delegated amount     delegators[_delegate].delegatedAmount = delegators[_delegate].delegatedAmount.sub(_amount); }  /**  * @dev Tries to add a transcoder to active transcoder pool, evicts the active transcoder with the lowest stake if the pool is full  * @param _transcoder The transcoder to insert into the transcoder pool  * @param _totalStake The total stake for '_transcoder'  * @param _activationRound The round in which the transcoder should become active  */ function tryToJoinActiveSet(     address _transcoder,     uint256 _totalStake,     uint256 _activationRound,     address _newPosPrev,     address _newPosNext ) internal {     uint256 pendingNextRoundTotalActiveStake = nextRoundTotalActiveStake;      if (transcoderPoolV2.isFull()) {         address lastTranscoder = transcoderPoolV2.getLast();         uint256 lastStake = transcoderTotalStake(lastTranscoder);          // If the pool is full and the transcoder has less stake than the least stake transcoder in the pool         // then the transcoder is unable to join the active set for the next round         if (_totalStake &lt;= lastStake) {             return;         }          // Evict the least stake transcoder from the active set for the next round         // Not zeroing 'Transcoder.lastActiveStakeUpdateRound' saves gas (5k when transcoder is evicted and 20k when transcoder is reinserted)         // There should be no side-effects as long as the value is properly updated on stake updates         // Not zeroing the stake on the current round's 'EarningsPool' saves gas and should have no side effects as long as         // 'EarningsPool.setStake()' is called whenever a transcoder becomes active again.         transcoderPoolV2.remove(lastTranscoder);         transcoders[lastTranscoder].deactivationRound = _activationRound;         pendingNextRoundTotalActiveStake = pendingNextRoundTotalActiveStake.sub(lastStake);          emit TranscoderDeactivated(lastTranscoder, _activationRound);     }      transcoderPoolV2.insert(_transcoder, _totalStake, _newPosPrev, _newPosNext);     pendingNextRoundTotalActiveStake = pendingNextRoundTotalActiveStake.add(_totalStake);     Transcoder storage t = transcoders[_transcoder];     t.lastActiveStakeUpdateRound = _activationRound;     t.activationRound = _activationRound;     t.deactivationRound = MAX_FUTURE_ROUND;     t.earningsPoolPerRound[_activationRound].setStake(_totalStake);     nextRoundTotalActiveStake = pendingNextRoundTotalActiveStake;     emit TranscoderActivated(_transcoder, _activationRound); }  /**  * @dev Remove a transcoder from the pool and deactivate it  */ function resignTranscoder(address _transcoder) internal {     // Not zeroing 'Transcoder.lastActiveStakeUpdateRound' saves gas (5k when transcoder is evicted and 20k when transcoder is reinserted)     // There should be no side-effects as long as the value is properly updated on stake updates     // Not zeroing the stake on the current round's 'EarningsPool' saves gas and should have no side effects as long as     // 'EarningsPool.setStake()' is called whenever a transcoder becomes active again.     transcoderPoolV2.remove(_transcoder);     nextRoundTotalActiveStake = nextRoundTotalActiveStake.sub(transcoderTotalStake(_transcoder));     uint256 deactivationRound = roundsManager().currentRound().add(1);     transcoders[_transcoder].deactivationRound = deactivationRound;     emit TranscoderDeactivated(_transcoder, deactivationRound); }  /**  * @dev Update a transcoder with rewards and update the transcoder pool with an optional list hint if needed.  * See SortedDoublyLL.sol for details on list hints  * @param _transcoder Address of transcoder  * @param _rewards Amount of rewards  * @param _round Round that transcoder is updated  * @param _newPosPrev Address of previous transcoder in pool if the transcoder is in the pool  * @param _newPosNext Address of next transcoder in pool if the transcoder is in the pool  */ function updateTranscoderWithRewards(     address _transcoder,     uint256 _rewards,     uint256 _round,     address _newPosPrev,     address _newPosNext ) internal {     Transcoder storage t = transcoders[_transcoder];     EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[_round];     EarningsPool.Data storage prevEarningsPool = t.earningsPoolPerRound[t.lastRewardRound];      t.activeCumulativeRewards = t.cumulativeRewards;      uint256 transcoderCommissionRewards = MathUtils.percOf(_rewards, earningsPool.transcoderRewardCut);     uint256 delegatorsRewards = _rewards.sub(transcoderCommissionRewards);     // Calculate the rewards earned by the transcoder's earned rewards     uint256 transcoderRewardStakeRewards = MathUtils.percOf(         delegatorsRewards,         t.activeCumulativeRewards,         earningsPool.totalStake     );     // Track rewards earned by the transcoder based on its earned rewards and rewardCut     t.cumulativeRewards = t.cumulativeRewards.add(transcoderRewardStakeRewards).add(transcoderCommissionRewards);     // Update cumulative reward factor with new rewards     // The cumulativeRewardFactor is used to calculate rewards for all delegators including the transcoder (self-delegated)     // Note that delegatorsRewards includes transcoderRewardStakeRewards, but no delegator will claim that amount using     // the earnings claiming algorithm and instead that amount is accounted for in the transcoder's cumulativeRewards field     earningsPool.updateCumulativeRewardFactor(prevEarningsPool, delegatorsRewards);     // Update transcoder's total stake with rewards     increaseTotalStake(_transcoder, _rewards, _newPosPrev, _newPosNext); }  /**  * @dev Update a delegator with token pools shares from its lastClaimRound through a given round  * @param _delegator Delegator address  * @param _endRound The last round for which to update a delegator's stake with earnings pool shares  * @param _lastClaimRound The round for which a delegator has last claimed earnings  */ function updateDelegatorWithEarnings(     address _delegator,     uint256 _endRound,     uint256 _lastClaimRound ) internal {     Delegator storage del = delegators[_delegator];     uint256 startRound = _lastClaimRound.add(1);     uint256 currentBondedAmount = del.bondedAmount;     uint256 currentFees = del.fees;      uint256 lip36Round = roundsManager().lipUpgradeRound(36);      // Only will have earnings to claim if you have a delegate     // If not delegated, skip the earnings claim process     if (del.delegateAddress != address(0)) {         if (startRound &lt;= lip36Round) {             // Cannot claim earnings for more than maxEarningsClaimsRounds before LIP-36             // This is a number to cause transactions to fail early if             // we know they will require too much gas to loop through all the necessary rounds to claim earnings             // The user should instead manually invoke `claimEarnings` to split up the claiming process             // across multiple transactions             uint256 endLoopRound = _endRound &lt;= lip36Round ? _endRound : lip36Round;             require(                 endLoopRound.sub(_lastClaimRound) &lt;= maxEarningsClaimsRounds,                 ""too many rounds to claim through""             );         }          (currentBondedAmount, currentFees) = pendingStakeAndFees(_delegator, _endRound);          // Check whether the endEarningsPool is initialised         // If it is not initialised set it's cumulative factors so that they can be used when a delegator         // next claims earnings as the start cumulative factors (see delegatorCumulativeStakeAndFees())         Transcoder storage t = transcoders[del.delegateAddress];         EarningsPool.Data storage endEarningsPool = t.earningsPoolPerRound[_endRound];         if (endEarningsPool.cumulativeRewardFactor == 0) {             endEarningsPool.cumulativeRewardFactor = t                 .earningsPoolPerRound[t.lastRewardRound]                 .cumulativeRewardFactor;         }         if (endEarningsPool.cumulativeFeeFactor == 0) {             endEarningsPool.cumulativeFeeFactor = t.earningsPoolPerRound[t.lastFeeRound].cumulativeFeeFactor;         }          if (del.delegateAddress == _delegator) {             t.cumulativeFees = 0;             t.cumulativeRewards = 0;             // activeCumulativeRewards is not cleared here because the next reward() call will set it to cumulativeRewards         }     }      emit EarningsClaimed(         del.delegateAddress,         _delegator,         currentBondedAmount.sub(del.bondedAmount),         currentFees.sub(del.fees),         startRound,         _endRound     );      del.lastClaimRound = _endRound;     // Rewards are bonded by default     del.bondedAmount = currentBondedAmount;     del.fees = currentFees; }  /**  * @dev Update the state of a delegator and its delegate by processing a rebond using an unbonding lock and update the transcoder pool with an optional  * list hint if needed. See SortedDoublyLL.sol for details on list hints  * @param _delegator Address of delegator  * @param _unbondingLockId ID of unbonding lock to rebond with  * @param _newPosPrev Address of previous transcoder in pool if the delegate is already in or joins the pool  * @param _newPosNext Address of next transcoder in pool if the delegate is already in or joins the pool  */ function processRebond(     address _delegator,     uint256 _unbondingLockId,     address _newPosPrev,     address _newPosNext ) internal {     Delegator storage del = delegators[_delegator];     UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];      require(isValidUnbondingLock(_delegator, _unbondingLockId), ""invalid unbonding lock ID"");      uint256 amount = lock.amount;     // Increase delegator's bonded amount     del.bondedAmount = del.bondedAmount.add(amount);      // Delete lock     delete del.unbondingLocks[_unbondingLockId];      increaseTotalStake(del.delegateAddress, amount, _newPosPrev, _newPosNext);      emit Rebond(del.delegateAddress, _delegator, _unbondingLockId, amount); }  /**  * @dev Return LivepeerToken interface  * @return Livepeer token contract registered with Controller  */ function livepeerToken() internal view returns (ILivepeerToken) {     return ILivepeerToken(controller.getContract(keccak256(""LivepeerToken""))); }  /**  * @dev Return Minter interface  * @return Minter contract registered with Controller  */ function minter() internal view returns (IMinter) {     return IMinter(controller.getContract(keccak256(""Minter""))); }  /**  * @dev Return RoundsManager interface  * @return RoundsManager contract registered with Controller  */ function roundsManager() internal view returns (IRoundsManager) {     return IRoundsManager(controller.getContract(keccak256(""RoundsManager""))); }  function _onlyTicketBroker() internal view {     require(msg.sender == controller.getContract(keccak256(""TicketBroker"")), ""caller must be TicketBroker""); }  function _onlyRoundsManager() internal view {     require(msg.sender == controller.getContract(keccak256(""RoundsManager"")), ""caller must be RoundsManager""); }  function _onlyVerifier() internal view {     require(msg.sender == controller.getContract(keccak256(""Verifier"")), ""caller must be Verifier""); }  function _currentRoundInitialized() internal view {     require(roundsManager().currentRoundInitialized(), ""current round is not initialized""); }  function _autoClaimEarnings() internal {     uint256 currentRound = roundsManager().currentRound();     uint256 lastClaimRound = delegators[msg.sender].lastClaimRound;     if (lastClaimRound &lt; currentRound) {         updateDelegatorWithEarnings(msg.sender, currentRound, lastClaimRound);     } }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Transactions Order Dependence. Transactions Order Dependence vulnerabilities can result in unintended consequences and create opportunities for malicious actors to exploit transaction sequencing. Please conduct a thorough analysis, considering the following information: 1. Review the contract's code logic to identify any potential areas where the order of transaction execution might have an impact on the contract's behavior.   Examine critical functions, particularly those involving fund transfers or resource allocation, to ensure they are not susceptible to Transactions Order Dependence.   Investigate scenarios in which gas prices can be manipulated to change the order of transaction execution.   If you identify Transactions Order Dependence, respond with: "" Transactions Order Dependence Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades ''' If you don't find any Transactions Order Dependence vulnerabilities, respond only with: "" NO Transactions Order Dependence."" |
| **phase_name** | TODDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': 'pragma solidity 0.5.11;\n\nimport ""../../ManagerProxyTarget.sol"";\nimport ""../IBondingManager.sol"";\nimport ""../../libraries/SortedDoublyLL.sol"";\nimport ""../../libraries/MathUtils.sol"";\nimport ""../libraries/EarningsPool.sol"";\nimport ""../libraries/EarningsPoolLIP36.sol"";\nimport ""../../token/ILivepeerToken.sol"";\nimport ""../../token/IMinter.sol"";\nimport ""../../rounds/IRoundsManager.sol"";\nimport ""../../snapshots/IMerkleSnapshot.sol"";\n\nimport ""openzeppelin-solidity/contracts/math/SafeMath.sol"";\n\n/\n * @title BondingManager\n * @notice Manages bonding, transcoder and rewards/fee accounting related operations of the Livepeer protocol\n */\ncontract BondingManagerZeroStartFactorsBug is ManagerProxyTarget, IBondingManager {\n    using SafeMath for uint256;\n    using SortedDoublyLL for SortedDoublyLL.Data;\n    using EarningsPool for EarningsPool.Data;\n    using EarningsPoolLIP36 for EarningsPool.Data;\n\n    // Constants\n    // Occurances are replaced at compile time\n    // and computed to a single value if possible by the optimizer\n    uint256 constant MAX_FUTURE_ROUND = 2256 - 1;\n\n    // Time between unbonding and possible withdrawl in rounds\n    uint64 public unbondingPeriod;\n    // DEPRECATED - DO NOT USE\n    uint256 public numActiveTranscodersDEPRECATED;\n    // Max number of rounds that a caller can claim earnings for at once\n    uint256 public maxEarningsClaimsRounds;\n\n    // Represents a transcoder\'s current state\n    struct Transcoder {\n        uint256 lastRewardRound; // Last round that the transcoder called reward\n        uint256 rewardCut; // % of reward paid to transcoder by a delegator\n        uint256 feeShare; // % of fees paid to delegators by transcoder\n        uint256 pricePerSegmentDEPRECATED; // DEPRECATED - DO NOT USE\n        uint256 pendingRewardCutDEPRECATED; // DEPRECATED - DO NOT USE\n        uint256 pendingFeeShareDEPRECATED; // DEPRECATED - DO NOT USE\n        uint256 pendingPricePerSegmentDEPRECATED; // DEPRECATED - DO NOT USE\n        mapping(uint256 =&gt; EarningsPool.Data) earningsPoolPerRound; // Mapping of round =&gt; earnings pool for the round\n        uint256 lastActiveStakeUpdateRound; // Round for which the stake was last updated while the transcoder is active\n        uint256 activationRound; // Round in which the transcoder became active - 0 if inactive\n        uint256 deactivationRound; // Round in which the transcoder will become inactive\n        uint256 activeCumulativeRewards; // The transcoder\'s cumulative rewards that are active in the current round\n        uint256 cumulativeRewards; // The transcoder\'s cumulative rewards (earned via the its active staked rewards and its reward cut).\n        uint256 cumulativeFees; // The transcoder\'s cumulative fees (earned via the its active staked rewards and its fee share)\n        uint256 lastFeeRound; // Latest round in which the transcoder received fees\n    }\n\n    // The various states a transcoder can be in\n    enum TranscoderStatus {\n        NotRegistered,\n        Registered\n    }\n\n    // Represents a delegator\'s current state\n    struct Delegator {\n        uint256 bondedAmount; // The amount of bonded tokens\n        uint256 fees; // The amount of fees collected\n        address delegateAddress; // The address delegated to\n        uint256 delegatedAmount; // The amount of tokens delegated to the delegator\n        uint256 startRound; // The round the delegator transitions to bonded phase and is delegated to someone\n        uint256 withdrawRoundDEPRECATED; // DEPRECATED - DO NOT USE\n        uint256 lastClaimRound; // The last round during which the delegator claimed its earnings\n        uint256 nextUnbondingLockId; // ID for the next unbonding lock created\n        mapping(uint256 =&gt; UnbondingLock) unbondingLocks; // Mapping of unbonding lock ID =&gt; unbonding lock\n    }\n\n    // The various states a delegator can be in\n    enum DelegatorStatus {\n        Pending,\n        Bonded,\n        Unbonded\n    }\n\n    // Represents an amount of tokens that are being unbonded\n    struct UnbondingLock {\n        uint256 amount; // Amount of tokens being unbonded\n        uint256 withdrawRound; // Round at which unbonding period is over and tokens can be withdrawn\n    }\n\n    // Keep track of the known transcoders and delegators\n    mapping(address =&gt; Delegator) private delegators;\n    mapping(address =&gt; Transcoder) private transcoders;\n\n    // DEPRECATED - DO NOT USE\n    // The function getTotalBonded() no longer uses this variable\n    // and instead calculates the total bonded value separately\n    uint256 private totalBondedDEPRECATED;\n\n    // DEPRECATED - DO NOT USE\n    SortedDoublyLL.Data private transcoderPoolDEPRECATED;\n\n    // DEPRECATED - DO NOT USE\n    struct ActiveTranscoderSetDEPRECATED {\n        address[] transcoders;\n        mapping(address =&gt; bool) isActive;\n        uint256 totalStake;\n    }\n\n    // DEPRECATED - DO NOT USE\n    mapping(uint256 =&gt; ActiveTranscoderSetDEPRECATED) public activeTranscoderSetDEPRECATED;\n\n    // The total active stake (sum of the stake of active set members) for the current round\n    uint256 public currentRoundTotalActiveStake;\n    // The total active stake (sum of the stake of active set members) for the next round\n    uint256 public nextRoundTotalActiveStake;\n\n    // The transcoder pool is used to keep track of the transcoders that are eligible for activation.\n    // The pool keeps track of the pending active set in round N and the start of round N + 1 transcoders\n    // in the pool are locked into the active set for round N + 1\n    SortedDoublyLL.Data private transcoderPoolV2;\n\n    // Check if sender is TicketBroker\n    modifier onlyTicketBroker() {\n        onlyTicketBroker();\n        ;\n    }\n\n    // Check if sender is RoundsManager\n    modifier onlyRoundsManager() {\n        onlyRoundsManager();\n        ;\n    }\n\n    // Check if sender is Verifier\n    modifier onlyVerifier() {\n        onlyVerifier();\n        ;\n    }\n\n    // Check if current round is initialized\n    modifier currentRoundInitialized() {\n        currentRoundInitialized();\n        ;\n    }\n\n    // Automatically claim earnings from lastClaimRound through the current round\n    modifier autoClaimEarnings() {\n        autoClaimEarnings();\n        ;\n    }\n\n    /\n     * @notice BondingManager constructor. Only invokes constructor of base Manager contract with provided Controller address\n     * @dev This constructor will not initialize any state variables besides controller. The following setter functions\n     * should be used to initialize state variables post-deployment:\n     * - setUnbondingPeriod()\n     * - setNumActiveTranscoders()\n     * - setMaxEarningsClaimsRounds()\n     * @param _controller Address of Controller that this contract will be registered with\n     */\n    constructor(address _controller) public Manager(_controller) {}\n\n    /\n     * @notice Set unbonding period. Only callable by Controller owner\n     * @param _unbondingPeriod Rounds between unbonding and possible withdrawal\n     /\n    function setUnbondingPeriod(uint64 _unbondingPeriod) external onlyControllerOwner {\n        unbondingPeriod = _unbondingPeriod;\n\n        emit ParameterUpdate(""unbondingPeriod"");\n    }\n\n    /\n     * @notice Set maximum number of active transcoders. Only callable by Controller owner\n     * @param _numActiveTranscoders Number of active transcoders\n     /\n    function setNumActiveTranscoders(uint256 _numActiveTranscoders) external onlyControllerOwner {\n        transcoderPoolV2.setMaxSize(_numActiveTranscoders);\n\n        emit ParameterUpdate(""numActiveTranscoders"");\n    }\n\n    /\n     * @notice Set max number of rounds a caller can claim earnings for at once. Only callable by Controller owner\n     * @param _maxEarningsClaimsRounds Max number of rounds a caller can claim earnings for at once\n     */\n    function setMaxEarningsClaimsRounds(uint256 _maxEarningsClaimsRounds) external onlyControllerOwner {\n        maxEarningsClaimsRounds = _maxEarningsClaimsRounds;\n\n        emit ParameterUpdate(""maxEarningsClaimsRounds"");\n    }\n\n    /\n     * @notice Sets commission rates as a transcoder and if the caller is not in the transcoder pool tries to add it\n     * @dev Percentages are represented as numerators of fractions over MathUtils.PERC_DIVISOR\n     * @param _rewardCut % of reward paid to transcoder by a delegator\n     * @param _feeShare % of fees paid to delegators by a transcoder\n     /\n    function transcoder(uint256 _rewardCut, uint256 _feeShare) external {\n        transcoderWithHint(_rewardCut, _feeShare, address(0), address(0));\n    }\n\n    /\n     * @notice Delegate stake towards a specific address\n     * @param _amount The amount of tokens to stake\n     * @param _to The address of the transcoder to stake towards\n     /\n    function bond(uint256 _amount, address _to) external {\n        bondWithHint(_amount, _to, address(0), address(0), address(0), address(0));\n    }\n\n    /\n     * @notice Unbond an amount of the delegator\'s bonded stake\n     * @param _amount Amount of tokens to unbond\n     */\n    function unbond(uint256 _amount) external {\n        unbondWithHint(_amount, address(0), address(0));\n    }\n\n    /\n     * @notice Rebond tokens for an unbonding lock to a delegator\'s current delegate while a delegator is in the Bonded or Pending status\n     * @param _unbondingLockId ID of unbonding lock to rebond with\n     /\n    function rebond(uint256 _unbondingLockId) external {\n        rebondWithHint(_unbondingLockId, address(0), address(0));\n    }\n\n    /\n     * @notice Rebond tokens for an unbonding lock to a delegate while a delegator is in the Unbonded status\n     * @param _to Address of delegate\n     * @param _unbondingLockId ID of unbonding lock to rebond with\n     /\n    function rebondFromUnbonded(address _to, uint256 _unbondingLockId) external {\n        rebondFromUnbondedWithHint(_to, _unbondingLockId, address(0), address(0));\n    }\n\n    /\n     * @notice Withdraws tokens for an unbonding lock that has existed through an unbonding period\n     * @param _unbondingLockId ID of unbonding lock to withdraw with\n     */\n    function withdrawStake(uint256 _unbondingLockId) external whenSystemNotPaused currentRoundInitialized {\n        Delegator storage del = delegators[msg.sender];\n        UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];\n\n        require(isValidUnbondingLock(msg.sender, _unbondingLockId), ""invalid unbonding lock ID"");\n        require(\n            lock.withdrawRound &lt;= roundsManager().currentRound(),\n            ""withdraw round must be before or equal to the current round""\n        );\n\n        uint256 amount = lock.amount;\n        uint256 withdrawRound = lock.withdrawRound;\n        // Delete unbonding lock\n        delete del.unbondingLocks[_unbondingLockId];\n\n        // Tell Minter to transfer stake (LPT) to the delegator\n        minter().trustedTransferTokens(msg.sender, amount);\n\n        emit WithdrawStake(msg.sender, _unbondingLockId, amount, withdrawRound);\n    }\n\n    /\n     * @notice Withdraws fees to the caller\n     /\n    function withdrawFees() external whenSystemNotPaused currentRoundInitialized autoClaimEarnings {\n        uint256 fees = delegators[msg.sender].fees;\n        require(fees &gt; 0, ""no fees to withdraw"");\n        delegators[msg.sender].fees = 0;\n\n        // Tell Minter to transfer fees (ETH) to the delegator\n        minter().trustedWithdrawETH(msg.sender, fees);\n\n        emit WithdrawFees(msg.sender);\n    }\n\n    /\n     * @notice Mint token rewards for an active transcoder and its delegators\n     /\n    function reward() external {\n        rewardWithHint(address(0), address(0));\n    }\n\n    /\n     * @notice Update transcoder\'s fee pool. Only callable by the TicketBroker\n     * @param _transcoder Transcoder address\n     * @param _fees Fees to be added to the fee pool\n     */\n    function updateTranscoderWithFees(\n        address _transcoder,\n        uint256 _fees,\n        uint256 _round\n    ) external whenSystemNotPaused onlyTicketBroker {\n        // Silence unused param compiler warning\n        _round;\n\n        require(isRegisteredTranscoder(_transcoder), ""transcoder must be registered"");\n\n        uint256 currentRound = roundsManager().currentRound();\n\n        Transcoder storage t = transcoders[_transcoder];\n\n        uint256 lastRewardRound = t.lastRewardRound;\n        uint256 activeCumulativeRewards = t.activeCumulativeRewards;\n\n        // LIP-36: Add fees for the current round instead of \'_round\'\n        // https://github.com/livepeer/LIPs/issues/35#issuecomment-673659199\n        EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[currentRound];\n        EarningsPool.Data memory prevEarningsPool = latestCumulativeFactorsPool(t, currentRound.sub(1));\n\n        // if transcoder hasn\'t called \'reward()\' for \'_round\' its \'transcoderFeeShare\', \'transcoderRewardCut\' and \'totalStake\'\n        // on the \'EarningsPool\' for \'_round\' would not be initialized and the fee distribution wouldn\'t happen as expected\n        // for cumulative fee calculation this would result in division by zero.\n        if (currentRound &gt; lastRewardRound) {\n            earningsPool.setCommission(t.rewardCut, t.feeShare);\n\n            uint256 lastUpdateRound = t.lastActiveStakeUpdateRound;\n            if (lastUpdateRound &lt; currentRound) {\n                earningsPool.setStake(t.earningsPoolPerRound[lastUpdateRound].totalStake);\n            }\n\n            // If reward() has not been called yet in the current round, then the transcoder\'s activeCumulativeRewards has not\n            // yet been set in for the round. When the transcoder calls reward() its activeCumulativeRewards will be set to its\n            // current cumulativeRewards. So, we can just use the transcoder\'s cumulativeRewards here because this will become\n            // the transcoder\'s activeCumulativeRewards if it calls reward() later on in the current round\n            activeCumulativeRewards = t.cumulativeRewards;\n        }\n\n        uint256 totalStake = earningsPool.totalStake;\n        if (prevEarningsPool.cumulativeRewardFactor == 0 &amp;&amp; lastRewardRound == currentRound) {\n            // if transcoder called reward for \'currentRound\' but not for \'currentRound - 1\' (missed reward call)\n            // retroactively calculate what its cumulativeRewardFactor would have been for \'currentRound - 1\' (cfr. previous lastRewardRound for transcoder)\n            // based on rewards for currentRound\n            IMinter mtr = minter();\n            uint256 rewards = MathUtils.percOf(\n                mtr.currentMintableTokens().add(mtr.currentMintedTokens()),\n                totalStake,\n                currentRoundTotalActiveStake\n            );\n            uint256 transcoderCommissionRewards = MathUtils.percOf(rewards, earningsPool.transcoderRewardCut);\n            uint256 delegatorsRewards = rewards.sub(transcoderCommissionRewards);\n\n            prevEarningsPool.cumulativeRewardFactor = MathUtils.percOf(\n                earningsPool.cumulativeRewardFactor,\n                totalStake,\n                delegatorsRewards.add(totalStake)\n            );\n        }\n\n        uint256 delegatorsFees = MathUtils.percOf(_fees, earningsPool.transcoderFeeShare);\n        uint256 transcoderCommissionFees = _fees.sub(delegatorsFees);\n        // Calculate the fees earned by the transcoder\'s earned rewards\n        uint256 transcoderRewardStakeFees = MathUtils.percOf(delegatorsFees, activeCumulativeRewards, totalStake);\n        // Track fees earned by the transcoder based on its earned rewards and feeShare\n        t.cumulativeFees = t.cumulativeFees.add(transcoderRewardStakeFees).add(transcoderCommissionFees);\n        // Update cumulative fee factor with new fees\n        // The cumulativeFeeFactor is used to calculate fees for all delegators including the transcoder (self-delegated)\n        // Note that delegatorsFees includes transcoderRewardStakeFees, but no delegator will claim that amount using\n        // the earnings claiming algorithm and instead that amount is accounted for in the transcoder\'s cumulativeFees field\n        earningsPool.updateCumulativeFeeFactor(prevEarningsPool, delegatorsFees);\n\n        t.lastFeeRound = currentRound;\n    }\n\n    /\n     * @notice Slash a transcoder. Only callable by the Verifier\n     * @param _transcoder Transcoder address\n     * @param _finder Finder that proved a transcoder violated a slashing condition. Null address if there is no finder\n     * @param _slashAmount Percentage of transcoder bond to be slashed\n     * @param _finderFee Percentage of penalty awarded to finder. Zero if there is no finder\n     /\n    function slashTranscoder(\n        address _transcoder,\n        address _finder,\n        uint256 _slashAmount,\n        uint256 _finderFee\n    ) external whenSystemNotPaused onlyVerifier {\n        Delegator storage del = delegators[_transcoder];\n\n        if (del.bondedAmount &gt; 0) {\n            uint256 penalty = MathUtils.percOf(delegators[_transcoder].bondedAmount, _slashAmount);\n\n            // If active transcoder, resign it\n            if (transcoderPoolV2.contains(_transcoder)) {\n                resignTranscoder(_transcoder);\n            }\n\n            // Decrease bonded stake\n            del.bondedAmount = del.bondedAmount.sub(penalty);\n\n            // If still bonded decrease delegate\'s delegated amount\n            if (delegatorStatus(_transcoder) == DelegatorStatus.Bonded) {\n                delegators[del.delegateAddress].delegatedAmount = delegators[del.delegateAddress].delegatedAmount.sub(\n                    penalty\n                );\n            }\n\n            // Account for penalty\n            uint256 burnAmount = penalty;\n\n            // Award finder fee if there is a finder address\n            if (_finder != address(0)) {\n                uint256 finderAmount = MathUtils.percOf(penalty, _finderFee);\n                minter().trustedTransferTokens(_finder, finderAmount);\n\n                // Minter burns the slashed funds - finder reward\n                minter().trustedBurnTokens(burnAmount.sub(finderAmount));\n\n                emit TranscoderSlashed(_transcoder, _finder, penalty, finderAmount);\n            } else {\n                // Minter burns the slashed funds\n                minter().trustedBurnTokens(burnAmount);\n\n                emit TranscoderSlashed(_transcoder, address(0), penalty, 0);\n            }\n        } else {\n            emit TranscoderSlashed(_transcoder, _finder, 0, 0);\n        }\n    }\n\n    /\n     * @notice Claim token pools shares for a delegator from its lastClaimRound through the end round\n     * @param _endRound The last round for which to claim token pools shares for a delegator\n     /\n    function claimEarnings(uint256 _endRound) external whenSystemNotPaused currentRoundInitialized {\n        uint256 lastClaimRound = delegators[msg.sender].lastClaimRound;\n        require(lastClaimRound &lt; _endRound, ""end round must be after last claim round"");\n        require(_endRound &lt;= roundsManager().currentRound(), ""end round must be before or equal to current round"");\n\n        updateDelegatorWithEarnings(msg.sender, _endRound, lastClaimRound);\n    }\n\n    /\n     * @notice Claim earnings for a delegator based on the snapshot taken in LIP-52\n     * @dev https://github.com/livepeer/LIPs/blob/master/LIPs/LIP-52.md\n     * @param _pendingStake the amount of pending stake for the delegator (current stake + pending rewards)\n     * @param _pendingFees the amount of pending fees for the delegator (current fees + pending fees)\n     * @param _earningsProof array of keccak256 sibling hashes on the branch of the leaf for the delegator up to the root\n     * @param _data (optional) raw transaction data to be executed on behalf of msg.sender after claiming snapshot earnings\n     */\n    function claimSnapshotEarnings(\n        uint256 _pendingStake,\n        uint256 _pendingFees,\n        bytes32[] calldata _earningsProof,\n        bytes calldata _data\n    ) external whenSystemNotPaused currentRoundInitialized {\n        Delegator storage del = delegators[msg.sender];\n\n        uint256 lip52Round = roundsManager().lipUpgradeRound(52);\n\n        uint256 lastClaimRound = del.lastClaimRound;\n\n        require(lastClaimRound &lt; lip52Round, ""Already claimed for LIP-52"");\n\n        bytes32 leaf = keccak256(abi.encode(msg.sender, _pendingStake, _pendingFees));\n\n        require(\n            IMerkleSnapshot(controller.getContract(keccak256(""MerkleSnapshot""))).verify(\n                keccak256(""LIP-52""),\n                _earningsProof,\n                leaf\n            ),\n            ""Merkle proof is invalid""\n        );\n\n        emit EarningsClaimed(\n            del.delegateAddress,\n            msg.sender,\n            _pendingStake.sub(del.bondedAmount),\n            _pendingFees.sub(del.fees),\n            lastClaimRound.add(1),\n            lip52Round\n        );\n\n        del.lastClaimRound = lip52Round;\n        del.bondedAmount = _pendingStake;\n        del.fees = _pendingFees;\n\n        // allow for execution of subsequent claiming or staking operations\n        if (_data.length &gt; 0) {\n            (bool success, bytes memory returnData) = address(this).delegatecall(_data);\n            require(success, string(returnData));\n        }\n    }\n\n    /\n     * @notice Called during round initialization to set the total active stake for the round. Only callable by the RoundsManager\n     /\n    function setCurrentRoundTotalActiveStake() external onlyRoundsManager {\n        currentRoundTotalActiveStake = nextRoundTotalActiveStake;\n    }\n\n    /\n     * @notice Sets commission rates as a transcoder and if the caller is not in the transcoder pool tries to add it using an optional list hint\n     * @dev Percentages are represented as numerators of fractions over MathUtils.PERC_DIVISOR. If the caller is going to be added to the pool, the\n     * caller can provide an optional hint for the insertion position in the pool via the _newPosPrev and _newPosNext params. A linear search will\n     * be executed starting at the hint to find the correct position - in the best case, the hint is the correct position so no search is executed.\n     * See SortedDoublyLL.sol for details on list hints\n     * @param _rewardCut % of reward paid to transcoder by a delegator\n     * @param _feeShare % of fees paid to delegators by a transcoder\n     * @param _newPosPrev Address of previous transcoder in pool if the caller joins the pool\n     * @param _newPosNext Address of next transcoder in pool if the caller joins the pool\n     /\n    function transcoderWithHint(\n        uint256 _rewardCut,\n        uint256 _feeShare,\n        address _newPosPrev,\n        address _newPosNext\n    ) public whenSystemNotPaused currentRoundInitialized {\n        require(!roundsManager().currentRoundLocked(), ""can\'t update transcoder params, current round is locked"");\n        require(MathUtils.validPerc(_rewardCut), ""invalid rewardCut percentage"");\n        require(MathUtils.validPerc(_feeShare), ""invalid feeShare percentage"");\n        require(isRegisteredTranscoder(msg.sender), ""transcoder must be registered"");\n\n        Transcoder storage t = transcoders[msg.sender];\n        uint256 currentRound = roundsManager().currentRound();\n\n        require(\n            !isActiveTranscoder(msg.sender) || t.lastRewardRound == currentRound,\n            ""caller can\'t be active or must have already called reward for the current round""\n        );\n\n        t.rewardCut = _rewardCut;\n        t.feeShare = _feeShare;\n\n        if (!transcoderPoolV2.contains(msg.sender)) {\n            tryToJoinActiveSet(\n                msg.sender,\n                delegators[msg.sender].delegatedAmount,\n                currentRound.add(1),\n                _newPosPrev,\n                _newPosNext\n            );\n        }\n\n        emit TranscoderUpdate(msg.sender, _rewardCut, _feeShare);\n    }\n\n    /\n     * @notice Delegate stake towards a specific address and updates the transcoder pool using optional list hints if needed\n     * @dev If the caller is decreasing the stake of its old delegate in the transcoder pool, the caller can provide an optional hint\n     * for the insertion position of the old delegate via the _oldDelegateNewPosPrev and _oldDelegateNewPosNext params.\n     * If the caller is delegating to a delegate that is in the transcoder pool, the caller can provide an optional hint for the\n     * insertion position of the delegate via the _currDelegateNewPosPrev and _currDelegateNewPosNext params.\n     * In both cases, a linear search will be executed starting at the hint to find the correct position. In the best case, the hint\n     * is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints\n     * @param _amount The amount of tokens to stake.\n     * @param _to The address of the transcoder to stake towards\n     * @param _oldDelegateNewPosPrev The address of the previous transcoder in the pool for the old delegate\n     * @param _oldDelegateNewPosNext The address of the next transcoder in the pool for the old delegate\n     * @param _currDelegateNewPosPrev The address of the previous transcoder in the pool for the current delegate\n     * @param _currDelegateNewPosNext The address of the next transcoder in the pool for the current delegate\n     */\n    function bondWithHint(\n        uint256 _amount,\n        address _to,\n        address _oldDelegateNewPosPrev,\n        address _oldDelegateNewPosNext,\n        address _currDelegateNewPosPrev,\n        address _currDelegateNewPosNext\n    ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {\n        Delegator storage del = delegators[msg.sender];\n\n        uint256 currentRound = roundsManager().currentRound();\n        // Amount to delegate\n        uint256 delegationAmount = _amount;\n        // Current delegate\n        address currentDelegate = del.delegateAddress;\n\n        if (delegatorStatus(msg.sender) == DelegatorStatus.Unbonded) {\n            // New delegate\n            // Set start round\n            // Don\'t set start round if delegator is in pending state because the start round would not change\n            del.startRound = currentRound.add(1);\n            // Unbonded state = no existing delegate and no bonded stake\n            // Thus, delegation amount = provided amount\n        } else if (currentDelegate != address(0) &amp;&amp; currentDelegate != _to) {\n            // A registered transcoder cannot delegate its bonded stake toward another address\n            // because it can only be delegated toward itself\n            // In the future, if delegation towards another registered transcoder as an already\n            // registered transcoder becomes useful (i.e. for transitive delegation), this restriction\n            // could be removed\n            require(\n                !isRegisteredTranscoder(msg.sender),\n                ""registered transcoders can\'t delegate towards other addresses""\n            );\n            // Changing delegate\n            // Set start round\n            del.startRound = currentRound.add(1);\n            // Update amount to delegate with previous delegation amount\n            delegationAmount = delegationAmount.add(del.bondedAmount);\n\n            decreaseTotalStake(currentDelegate, del.bondedAmount, _oldDelegateNewPosPrev, _oldDelegateNewPosNext);\n        }\n\n        // cannot delegate to someone without having bonded stake\n        require(delegationAmount &gt; 0, ""delegation amount must be greater than 0"");\n        // Update delegate\n        del.delegateAddress = _to;\n        // Update bonded amount\n        del.bondedAmount = del.bondedAmount.add(_amount);\n\n        increaseTotalStake(_to, delegationAmount, _currDelegateNewPosPrev, _currDelegateNewPosNext);\n\n        if (_amount &gt; 0) {\n            // Transfer the LPT to the Minter\n            livepeerToken().transferFrom(msg.sender, address(minter()), _amount);\n        }\n\n        emit Bond(_to, currentDelegate, msg.sender, _amount, del.bondedAmount);\n    }\n\n    /\n     * @notice Unbond an amount of the delegator\'s bonded stake and updates the transcoder pool using an optional list hint if needed\n     * @dev If the caller remains in the transcoder pool, the caller can provide an optional hint for its insertion position in the\n     * pool via the _newPosPrev and _newPosNext params. A linear search will be executed starting at the hint to find the correct position.\n     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol details on list hints\n     * @param _amount Amount of tokens to unbond\n     * @param _newPosPrev Address of previous transcoder in pool if the caller remains in the pool\n     * @param _newPosNext Address of next transcoder in pool if the caller remains in the pool\n     /\n    function unbondWithHint(\n        uint256 _amount,\n        address _newPosPrev,\n        address _newPosNext\n    ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {\n        require(delegatorStatus(msg.sender) == DelegatorStatus.Bonded, ""caller must be bonded"");\n\n        Delegator storage del = delegators[msg.sender];\n\n        require(_amount &gt; 0, ""unbond amount must be greater than 0"");\n        require(_amount &lt;= del.bondedAmount, ""amount is greater than bonded amount"");\n\n        address currentDelegate = del.delegateAddress;\n        uint256 currentRound = roundsManager().currentRound();\n        uint256 withdrawRound = currentRound.add(unbondingPeriod);\n        uint256 unbondingLockId = del.nextUnbondingLockId;\n\n        // Create new unbonding lock\n        del.unbondingLocks[unbondingLockId] = UnbondingLock({ amount: _amount, withdrawRound: withdrawRound });\n        // Increment ID for next unbonding lock\n        del.nextUnbondingLockId = unbondingLockId.add(1);\n        // Decrease delegator\'s bonded amount\n        del.bondedAmount = del.bondedAmount.sub(_amount);\n\n        if (del.bondedAmount == 0) {\n            // Delegator no longer delegated to anyone if it does not have a bonded amount\n            del.delegateAddress = address(0);\n            // Delegator does not have a start round if it is no longer delegated to anyone\n            del.startRound = 0;\n\n            if (transcoderPoolV2.contains(msg.sender)) {\n                resignTranscoder(msg.sender);\n            }\n        }\n\n        // If msg.sender was resigned this statement will only decrease delegators[currentDelegate].delegatedAmount\n        decreaseTotalStake(currentDelegate, _amount, _newPosPrev, _newPosNext);\n\n        emit Unbond(currentDelegate, msg.sender, unbondingLockId, _amount, withdrawRound);\n    }\n\n    /\n     * @notice Rebond tokens for an unbonding lock to a delegator\'s current delegate while a delegator is in the Bonded or Pending status and updates\n     * the transcoder pool using an optional list hint if needed\n     * @dev If the delegate is in the transcoder pool, the caller can provide an optional hint for the delegate\'s insertion position in the\n     * pool via the _newPosPrev and _newPosNext params. A linear search will be executed starting at the hint to find the correct position.\n     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol details on list hints\n     * @param _unbondingLockId ID of unbonding lock to rebond with\n     * @param _newPosPrev Address of previous transcoder in pool if the delegate is in the pool\n     * @param _newPosNext Address of next transcoder in pool if the delegate is in the pool\n     /\n    function rebondWithHint(\n        uint256 _unbondingLockId,\n        address _newPosPrev,\n        address _newPosNext\n    ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {\n        require(delegatorStatus(msg.sender) != DelegatorStatus.Unbonded, ""caller must be bonded"");\n\n        // Process rebond using unbonding lock\n        processRebond(msg.sender, _unbondingLockId, _newPosPrev, _newPosNext);\n    }\n\n    /\n     * @notice Rebond tokens for an unbonding lock to a delegate while a delegator is in the Unbonded status and updates the transcoder pool using\n     * an optional list hint if needed\n     * @dev If the delegate joins the transcoder pool, the caller can provide an optional hint for the delegate\'s insertion position in the\n     * pool via the _newPosPrev and _newPosNext params. A linear search will be executed starting at the hint to find the correct position.\n     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints\n     * @param _to Address of delegate\n     * @param _unbondingLockId ID of unbonding lock to rebond with\n     * @param _newPosPrev Address of previous transcoder in pool if the delegate joins the pool\n     * @param _newPosNext Address of next transcoder in pool if the delegate joins the pool\n     */\n    function rebondFromUnbondedWithHint(\n        address _to,\n        uint256 _unbondingLockId,\n        address _newPosPrev,\n        address _newPosNext\n    ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {\n        require(delegatorStatus(msg.sender) == DelegatorStatus.Unbonded, ""caller must be unbonded"");\n\n        // Set delegator\'s start round and transition into Pending state\n        delegators[msg.sender].startRound = roundsManager().currentRound().add(1);\n        // Set delegator\'s delegate\n        delegators[msg.sender].delegateAddress = _to;\n        // Process rebond using unbonding lock\n        processRebond(msg.sender, _unbondingLockId, _newPosPrev, _newPosNext);\n    }\n\n    /\n     * @notice Mint token rewards for an active transcoder and its delegators and update the transcoder pool using an optional list hint if needed\n     * @dev If the caller is in the transcoder pool, the caller can provide an optional hint for its insertion position in the\n     * pool via the _newPosPrev and _newPosNext params. A linear search will be executed starting at the hint to find the correct position.\n     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints\n     * @param _newPosPrev Address of previous transcoder in pool if the caller is in the pool\n     * @param _newPosNext Address of next transcoder in pool if the caller is in the pool\n     /\n    function rewardWithHint(address _newPosPrev, address _newPosNext)\n        public\n        whenSystemNotPaused\n        currentRoundInitialized\n    {\n        uint256 currentRound = roundsManager().currentRound();\n\n        require(isActiveTranscoder(msg.sender), ""caller must be an active transcoder"");\n        require(\n            transcoders[msg.sender].lastRewardRound != currentRound,\n            ""caller has already called reward for the current round""\n        );\n\n        Transcoder storage t = transcoders[msg.sender];\n        EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[currentRound];\n\n        // Set last round that transcoder called reward\n        earningsPool.setCommission(t.rewardCut, t.feeShare);\n\n        // If transcoder didn\'t receive stake updates during the previous round and hasn\'t called reward for &gt; 1 round\n        // the \'totalStake\' on its \'EarningsPool\' for the current round wouldn\'t be initialized\n        // Thus we sync the the transcoder\'s stake to when it was last updated\n        // \'updateTrancoderWithRewards()\' will set the update round to \'currentRound +1\' so this synchronization shouldn\'t occur frequently\n        uint256 lastUpdateRound = t.lastActiveStakeUpdateRound;\n        if (lastUpdateRound &lt; currentRound) {\n            earningsPool.setStake(t.earningsPoolPerRound[lastUpdateRound].totalStake);\n        }\n\n        // Create reward based on active transcoder\'s stake relative to the total active stake\n        // rewardTokens = (current mintable tokens for the round * active transcoder stake) / total active stake\n        uint256 rewardTokens = minter().createReward(earningsPool.totalStake, currentRoundTotalActiveStake);\n\n        updateTranscoderWithRewards(msg.sender, rewardTokens, currentRound, _newPosPrev, _newPosNext);\n\n        // Set last round that transcoder called reward\n        t.lastRewardRound = currentRound;\n\n        emit Reward(msg.sender, rewardTokens);\n    }\n\n    /\n     * @notice Returns pending bonded stake for a delegator from its lastClaimRound through an end round\n     * @param _delegator Address of delegator\n     * @param _endRound The last round to compute pending stake from\n     * @return Pending bonded stake for \'_delegator\' since last claiming rewards\n     /\n    function pendingStake(address _delegator, uint256 _endRound) public view returns (uint256) {\n        (uint256 stake, ) = pendingStakeAndFees(_delegator, _endRound);\n        return stake;\n    }\n\n    /\n     * @notice Returns pending fees for a delegator from its lastClaimRound through an end round\n     * @param _delegator Address of delegator\n     * @param _endRound The last round to compute pending fees from\n     * @return Pending fees for \'_delegator\' since last claiming fees\n     */\n    function pendingFees(address _delegator, uint256 _endRound) public view returns (uint256) {\n        (, uint256 fees) = pendingStakeAndFees(_delegator, _endRound);\n        return fees;\n    }\n\n    /\n     * @notice Returns total bonded stake for a transcoder\n     * @param _transcoder Address of transcoder\n     * @return total bonded stake for a delegator\n     /\n    function transcoderTotalStake(address _transcoder) public view returns (uint256) {\n        return delegators[_transcoder].delegatedAmount;\n    }\n\n    /\n     * @notice Computes transcoder status\n     * @param _transcoder Address of transcoder\n     * @return registered or not registered transcoder status\n     /\n    function transcoderStatus(address _transcoder) public view returns (TranscoderStatus) {\n        if (isRegisteredTranscoder(_transcoder)) return TranscoderStatus.Registered;\n        return TranscoderStatus.NotRegistered;\n    }\n\n    /\n     * @notice Computes delegator status\n     * @param _delegator Address of delegator\n     * @return bonded, unbonded or pending delegator status\n     */\n    function delegatorStatus(address _delegator) public view returns (DelegatorStatus) {\n        Delegator storage del = delegators[_delegator];\n\n        if (del.bondedAmount == 0) {\n            // Delegator unbonded all its tokens\n            return DelegatorStatus.Unbonded;\n        } else if (del.startRound &gt; roundsManager().currentRound()) {\n            // Delegator round start is in the future\n            return DelegatorStatus.Pending;\n        } else {\n            // Delegator round start is now or in the past\n            // del.startRound != 0 here because if del.startRound = 0 then del.bondedAmount = 0 which\n            // would trigger the first if clause\n            return DelegatorStatus.Bonded;\n        }\n    }\n\n    /\n     * @notice Return transcoder information\n     * @param _transcoder Address of transcoder\n     * @return lastRewardRound Trancoder\'s last reward round\n     * @return rewardCut Transcoder\'s reward cut\n     * @return feeShare Transcoder\'s fee share\n     * @return lastActiveStakeUpdateRound Round in which transcoder\'s stake was last updated while active\n     * @return activationRound Round in which transcoder became active\n     * @return deactivationRound Round in which transcoder will no longer be active\n     * @return activeCumulativeRewards Transcoder\'s cumulative rewards that are currently active\n     * @return cumulativeRewards Transcoder\'s cumulative rewards (earned via its active staked rewards and its reward cut)\n     * @return cumulativeFees Transcoder\'s cumulative fees (earned via its active staked rewards and its fee share)\n     * @return lastFeeRound Latest round that the transcoder received fees\n     /\n    function getTranscoder(address _transcoder)\n        public\n        view\n        returns (\n            uint256 lastRewardRound,\n            uint256 rewardCut,\n            uint256 feeShare,\n            uint256 lastActiveStakeUpdateRound,\n            uint256 activationRound,\n            uint256 deactivationRound,\n            uint256 activeCumulativeRewards,\n            uint256 cumulativeRewards,\n            uint256 cumulativeFees,\n            uint256 lastFeeRound\n        )\n    {\n        Transcoder storage t = transcoders[_transcoder];\n\n        lastRewardRound = t.lastRewardRound;\n        rewardCut = t.rewardCut;\n        feeShare = t.feeShare;\n        lastActiveStakeUpdateRound = t.lastActiveStakeUpdateRound;\n        activationRound = t.activationRound;\n        deactivationRound = t.deactivationRound;\n        activeCumulativeRewards = t.activeCumulativeRewards;\n        cumulativeRewards = t.cumulativeRewards;\n        cumulativeFees = t.cumulativeFees;\n        lastFeeRound = t.lastFeeRound;\n    }\n\n    /\n     * @notice Return transcoder\'s earnings pool for a given round\n     * @param _transcoder Address of transcoder\n     * @param _round Round number\n     * @return rewardPool Reward pool for delegators (only used before LIP-36)\n     * @return feePool Fee pool for delegators (only used before LIP-36)\n     * @return totalStake Transcoder\'s total stake in \'_round\'\n     * @return claimableStake Remaining stake that can be used to claim from the pool (only used before LIP-36)\n     * @return transcoderRewardCut Transcoder\'s reward cut for \'_round\'\n     * @return transcoderFeeShare Transcoder\'s fee share for \'_round\'\n     * @return transcoderRewardPool Transcoder\'s rewards for \'_round\' (only used before LIP-36)\n     * @return transcoderFeePool Transcoder\'s fees for \'_round\' (only used before LIP-36)\n     * @return hasTranscoderRewardFeePool True if there is a split reward/fee pool for the transcoder (only used before LIP-36)\n     * @return cumulativeRewardFactor The cumulative reward factor for delegator rewards calculation (only used after LIP-36)\n     * @return cumulativeFeeFactor The cumulative fee factor for delegator fees calculation (only used after LIP-36)\n     /\n    function getTranscoderEarningsPoolForRound(address _transcoder, uint256 _round)\n        public\n        view\n        returns (\n            uint256 rewardPool,\n            uint256 feePool,\n            uint256 totalStake,\n            uint256 claimableStake,\n            uint256 transcoderRewardCut,\n            uint256 transcoderFeeShare,\n            uint256 transcoderRewardPool,\n            uint256 transcoderFeePool,\n            bool hasTranscoderRewardFeePool,\n            uint256 cumulativeRewardFactor,\n            uint256 cumulativeFeeFactor\n        )\n    {\n        EarningsPool.Data storage earningsPool = transcoders[_transcoder].earningsPoolPerRound[_round];\n\n        rewardPool = earningsPool.rewardPool;\n        feePool = earningsPool.feePool;\n        totalStake = earningsPool.totalStake;\n        claimableStake = earningsPool.claimableStake;\n        transcoderRewardCut = earningsPool.transcoderRewardCut;\n        transcoderFeeShare = earningsPool.transcoderFeeShare;\n        transcoderRewardPool = earningsPool.transcoderRewardPool;\n        transcoderFeePool = earningsPool.transcoderFeePool;\n        hasTranscoderRewardFeePool = earningsPool.hasTranscoderRewardFeePool;\n        cumulativeRewardFactor = earningsPool.cumulativeRewardFactor;\n        cumulativeFeeFactor = earningsPool.cumulativeFeeFactor;\n    }\n\n    /\n     * @notice Return delegator info\n     * @param _delegator Address of delegator\n     * @return total amount bonded by \'_delegator\'\n     * @return amount of fees collected by \'_delegator\'\n     * @return address \'_delegator\' has bonded to\n     * @return total amount delegated to \'_delegator\'\n     * @return round in which bond for \'_delegator\' became effective\n     * @return round for which \'_delegator\' has last claimed earnings\n     * @return ID for the next unbonding lock created for \'_delegator\'\n     */\n    function getDelegator(address _delegator)\n        public\n        view\n        returns (\n            uint256 bondedAmount,\n            uint256 fees,\n            address delegateAddress,\n            uint256 delegatedAmount,\n            uint256 startRound,\n            uint256 lastClaimRound,\n            uint256 nextUnbondingLockId\n        )\n    {\n        Delegator storage del = delegators[_delegator];\n\n        bondedAmount = del.bondedAmount;\n        fees = del.fees;\n        delegateAddress = del.delegateAddress;\n        delegatedAmount = del.delegatedAmount;\n        startRound = del.startRound;\n        lastClaimRound = del.lastClaimRound;\n        nextUnbondingLockId = del.nextUnbondingLockId;\n    }\n\n    /\n     * @notice Return delegator\'s unbonding lock info\n     * @param _delegator Address of delegator\n     * @param _unbondingLockId ID of unbonding lock\n     * @return amount of stake locked up by unbonding lock\n     * @return round in which \'amount\' becomes available for withdrawal\n     /\n    function getDelegatorUnbondingLock(address _delegator, uint256 _unbondingLockId)\n        public\n        view\n        returns (uint256 amount, uint256 withdrawRound)\n    {\n        UnbondingLock storage lock = delegators[_delegator].unbondingLocks[_unbondingLockId];\n\n        return (lock.amount, lock.withdrawRound);\n    }\n\n    /\n     * @notice Returns max size of transcoder pool\n     * @return transcoder pool max size\n     /\n    function getTranscoderPoolMaxSize() public view returns (uint256) {\n        return transcoderPoolV2.getMaxSize();\n    }\n\n    /\n     * @notice Returns size of transcoder pool\n     * @return transcoder pool current size\n     */\n    function getTranscoderPoolSize() public view returns (uint256) {\n        return transcoderPoolV2.getSize();\n    }\n\n    /\n     * @notice Returns transcoder with most stake in pool\n     * @return address for transcoder with highest stake in transcoder pool\n     /\n    function getFirstTranscoderInPool() public view returns (address) {\n        return transcoderPoolV2.getFirst();\n    }\n\n    /\n     * @notice Returns next transcoder in pool for a given transcoder\n     * @param _transcoder Address of a transcoder in the pool\n     * @return address for the transcoder after \'_transcoder\' in transcoder pool\n     /\n    function getNextTranscoderInPool(address _transcoder) public view returns (address) {\n        return transcoderPoolV2.getNext(_transcoder);\n    }\n\n    /\n     * @notice Return total bonded tokens\n     * @return total active stake for the current round\n     */\n    function getTotalBonded() public view returns (uint256) {\n        return currentRoundTotalActiveStake;\n    }\n\n    /\n     * @notice Return whether a transcoder is active for the current round\n     * @param _transcoder Transcoder address\n     * @return true if transcoder is active\n     /\n    function isActiveTranscoder(address _transcoder) public view returns (bool) {\n        Transcoder storage t = transcoders[_transcoder];\n        uint256 currentRound = roundsManager().currentRound();\n        return t.activationRound &lt;= currentRound &amp;&amp; currentRound &lt; t.deactivationRound;\n    }\n\n    /\n     * @notice Return whether a transcoder is registered\n     * @param _transcoder Transcoder address\n     * @return true if transcoder is self-bonded\n     /\n    function isRegisteredTranscoder(address _transcoder) public view returns (bool) {\n        Delegator storage d = delegators[_transcoder];\n        return d.delegateAddress == _transcoder &amp;&amp; d.bondedAmount &gt; 0;\n    }\n\n    /\n     * @notice Return whether an unbonding lock for a delegator is valid\n     * @param _delegator Address of delegator\n     * @param _unbondingLockId ID of unbonding lock\n     * @return true if unbondingLock for ID has a non-zero withdraw round\n     */\n    function isValidUnbondingLock(address _delegator, uint256 _unbondingLockId) public view returns (bool) {\n        // A unbonding lock is only valid if it has a non-zero withdraw round (the default value is zero)\n        return delegators[_delegator].unbondingLocks[_unbondingLockId].withdrawRound &gt; 0;\n    }\n\n    /\n     * @notice Return an EarningsPool.Data struct with the latest cumulative factors for a given round\n     * @param _transcoder Storage pointer to a transcoder struct\n     * @param _round The round to fetch the latest cumulative factors for\n     * @return pool An EarningsPool.Data populated with the latest cumulative factors for _round\n     /\n    function latestCumulativeFactorsPool(Transcoder storage _transcoder, uint256 _round)\n        internal\n        view\n        returns (EarningsPool.Data memory pool)\n    {\n        pool.cumulativeRewardFactor = _transcoder.earningsPoolPerRound[_round].cumulativeRewardFactor;\n        pool.cumulativeFeeFactor = _transcoder.earningsPoolPerRound[_round].cumulativeFeeFactor;\n\n        uint256 lastRewardRound = _transcoder.lastRewardRound;\n        // Only use the cumulativeRewardFactor for lastRewardRound if lastRewardRound is before _round\n        if (pool.cumulativeRewardFactor == 0 &amp;&amp; lastRewardRound &lt; _round) {\n            pool.cumulativeRewardFactor = _transcoder.earningsPoolPerRound[lastRewardRound].cumulativeRewardFactor;\n        }\n\n        uint256 lastFeeRound = _transcoder.lastFeeRound;\n        // Only use the cumulativeFeeFactor for lastFeeRound if lastFeeRound is before _round\n        if (pool.cumulativeFeeFactor == 0 &amp;&amp; lastFeeRound &lt; _round) {\n            pool.cumulativeFeeFactor = _transcoder.earningsPoolPerRound[lastFeeRound].cumulativeFeeFactor;\n        }\n\n        return pool;\n    }\n\n    /\n     * @notice Return a delegator\'s cumulative stake and fees using the LIP-36 earnings claiming algorithm\n     * @param _transcoder Storage pointer to a transcoder struct for a delegator\'s delegate\n     * @param _startRound The round for the start cumulative factors\n     * @param _endRound The round for the end cumulative factors\n     * @param _stake The delegator\'s initial stake before including earned rewards\n     * @param _fees The delegator\'s initial fees before including earned fees\n     * @return (cStake, cFees) where cStake is the delegator\'s cumulative stake including earned rewards and cFees is the delegator\'s cumulative fees including earned fees\n     /\n    function delegatorCumulativeStakeAndFees(\n        Transcoder storage _transcoder,\n        uint256 _startRound,\n        uint256 _endRound,\n        uint256 _stake,\n        uint256 _fees\n    ) internal view returns (uint256 cStake, uint256 cFees) {\n        uint256 baseRewardFactor = MathUtils.percPoints(1, 1);\n\n        // Fetch start cumulative factors\n        EarningsPool.Data memory startPool;\n        startPool.cumulativeRewardFactor = _transcoder.earningsPoolPerRound[_startRound].cumulativeRewardFactor;\n        startPool.cumulativeFeeFactor = _transcoder.earningsPoolPerRound[_startRound].cumulativeFeeFactor;\n\n        if (startPool.cumulativeRewardFactor == 0) {\n            startPool.cumulativeRewardFactor = baseRewardFactor;\n        }\n\n        // Fetch end cumulative factors\n        EarningsPool.Data memory endPool = latestCumulativeFactorsPool(_transcoder, _endRound);\n\n        if (endPool.cumulativeRewardFactor == 0) {\n            endPool.cumulativeRewardFactor = baseRewardFactor;\n        }\n\n        cFees = _fees.add(\n            MathUtils.percOf(\n                _stake,\n                endPool.cumulativeFeeFactor.sub(startPool.cumulativeFeeFactor),\n                startPool.cumulativeRewardFactor\n            )\n        );\n\n        cStake = MathUtils.percOf(_stake, endPool.cumulativeRewardFactor, startPool.cumulativeRewardFactor);\n\n        return (cStake, cFees);\n    }\n\n    /\n     * @notice Return the pending stake and fees for a delegator\n     * @param _delegator Address of a delegator\n     * @param _endRound The last round to claim earnings for when calculating the pending stake and fees\n     * @return (stake, fees) where stake is the delegator\'s pending stake and fees is the delegator\'s pending fees\n     */\n    function pendingStakeAndFees(address _delegator, uint256 _endRound)\n        internal\n        view\n        returns (uint256 stake, uint256 fees)\n    {\n        Delegator storage del = delegators[_delegator];\n        Transcoder storage t = transcoders[del.delegateAddress];\n\n        fees = del.fees;\n        stake = del.bondedAmount;\n\n        uint256 startRound = del.lastClaimRound.add(1);\n        address delegateAddr = del.delegateAddress;\n        bool isTranscoder = _delegator == delegateAddr;\n\n        uint256 lip36Round = roundsManager().lipUpgradeRound(36);\n        while (startRound &lt;= _endRound &amp;&amp; startRound &lt;= lip36Round) {\n            EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[startRound];\n\n            // If earningsPool.hasTranscoderRewardFeePool is not set during lip36Round then the transcoder did not call\n            // reward during lip36Round before the upgrade. In this case, if the transcoder calls reward in lip36Round\n            // the delegator can use the LIP-36 earnings claiming algorithm to claim for lip36Round\n            if (startRound == lip36Round &amp;&amp; !earningsPool.hasTranscoderRewardFeePool) {\n                break;\n            }\n\n            if (earningsPool.hasClaimableShares()) {\n                // Calculate and add fee pool share from this round\n                fees = fees.add(earningsPool.feePoolShare(stake, isTranscoder));\n                // Calculate new bonded amount with rewards from this round. Updated bonded amount used\n                // to calculate fee pool share in next round\n                stake = stake.add(earningsPool.rewardPoolShare(stake, isTranscoder));\n            }\n\n            startRound = startRound.add(1);\n        }\n\n        // If the transcoder called reward during lip36Round the upgrade, then startRound = lip36Round\n        // Otherwise, startRound = lip36Round + 1\n\n        // If the start round is greater than the end round, we\'ve already claimed for the end round so we do not\n        // need to execute the LIP-36 earnings claiming algorithm. This could be the case if:\n        // - _endRound &lt; lip36Round i.e. we are not claiming through the lip36Round\n        // - _endRound == lip36Round AND startRound = lip36Round + 1 i.e we already claimed through the lip36Round\n        if (startRound &gt; _endRound) {\n            return (stake, fees);\n        }\n\n        // The LIP-36 earnings claiming algorithm uses the cumulative factors from the delegator\'s lastClaimRound i.e. startRound - 1\n        // and from the specified _endRound\n        (stake, fees) = delegatorCumulativeStakeAndFees(t, startRound.sub(1), _endRound, stake, fees);\n\n        if (isTranscoder) {\n            stake = stake.add(t.cumulativeRewards);\n            fees = fees.add(t.cumulativeFees);\n        }\n\n        return (stake, fees);\n    }\n\n    /\n     * @dev Increase the total stake for a delegate and updates its \'lastActiveStakeUpdateRound\'\n     * @param _delegate The delegate to increase the stake for\n     * @param _amount The amount to increase the stake for \'_delegate\' by\n     /\n    function increaseTotalStake(\n        address _delegate,\n        uint256 _amount,\n        address _newPosPrev,\n        address _newPosNext\n    ) internal {\n        if (isRegisteredTranscoder(_delegate)) {\n            uint256 currStake = transcoderTotalStake(_delegate);\n            uint256 newStake = currStake.add(_amount);\n            uint256 currRound = roundsManager().currentRound();\n            uint256 nextRound = currRound.add(1);\n\n            // If the transcoder is already in the active set update its stake and return\n            if (transcoderPoolV2.contains(_delegate)) {\n                transcoderPoolV2.updateKey(_delegate, newStake, _newPosPrev, _newPosNext);\n                nextRoundTotalActiveStake = nextRoundTotalActiveStake.add(_amount);\n                Transcoder storage t = transcoders[_delegate];\n\n                // currStake (the transcoder\'s delegatedAmount field) will reflect the transcoder\'s stake from lastActiveStakeUpdateRound\n                // because it is updated every time lastActiveStakeUpdateRound is updated\n                // The current active total stake is set to currStake to ensure that the value can be used in updateTranscoderWithRewards()\n                // and updateTranscoderWithFees() when lastActiveStakeUpdateRound &gt; currentRound\n                if (t.lastActiveStakeUpdateRound &lt; currRound) {\n                    t.earningsPoolPerRound[currRound].setStake(currStake);\n                }\n\n                t.earningsPoolPerRound[nextRound].setStake(newStake);\n                t.lastActiveStakeUpdateRound = nextRound;\n            } else {\n                // Check if the transcoder is eligible to join the active set in the update round\n                tryToJoinActiveSet(_delegate, newStake, nextRound, _newPosPrev, _newPosNext);\n            }\n        }\n\n        // Increase delegate\'s delegated amount\n        delegators[_delegate].delegatedAmount = delegators[_delegate].delegatedAmount.add(_amount);\n    }\n\n    /\n     * @dev Decrease the total stake for a delegate and updates its \'lastActiveStakeUpdateRound\'\n     * @param _delegate The transcoder to decrease the stake for\n     * @param _amount The amount to decrease the stake for \'_delegate\' by\n     /\n    function decreaseTotalStake(\n        address _delegate,\n        uint256 _amount,\n        address _newPosPrev,\n        address _newPosNext\n    ) internal {\n        if (transcoderPoolV2.contains(_delegate)) {\n            uint256 currStake = transcoderTotalStake(_delegate);\n            uint256 newStake = currStake.sub(_amount);\n            uint256 currRound = roundsManager().currentRound();\n            uint256 nextRound = currRound.add(1);\n\n            transcoderPoolV2.updateKey(_delegate, newStake, _newPosPrev, _newPosNext);\n            nextRoundTotalActiveStake = nextRoundTotalActiveStake.sub(_amount);\n            Transcoder storage t = transcoders[_delegate];\n\n            // currStake (the transcoder\'s delegatedAmount field) will reflect the transcoder\'s stake from lastActiveStakeUpdateRound\n            // because it is updated every time lastActiveStakeUpdateRound is updated\n            // The current active total stake is set to currStake to ensure that the value can be used in updateTranscoderWithRewards()\n            // and updateTranscoderWithFees() when lastActiveStakeUpdateRound &gt; currentRound\n            if (t.lastActiveStakeUpdateRound &lt; currRound) {\n                t.earningsPoolPerRound[currRound].setStake(currStake);\n            }\n\n            t.lastActiveStakeUpdateRound = nextRound;\n            t.earningsPoolPerRound[nextRound].setStake(newStake);\n        }\n\n        // Decrease old delegate\'s delegated amount\n        delegators[_delegate].delegatedAmount = delegators[_delegate].delegatedAmount.sub(_amount);\n    }\n\n    /\n     * @dev Tries to add a transcoder to active transcoder pool, evicts the active transcoder with the lowest stake if the pool is full\n     * @param _transcoder The transcoder to insert into the transcoder pool\n     * @param _totalStake The total stake for \'_transcoder\'\n     * @param _activationRound The round in which the transcoder should become active\n     */\n    function tryToJoinActiveSet(\n        address _transcoder,\n        uint256 _totalStake,\n        uint256 _activationRound,\n        address _newPosPrev,\n        address _newPosNext\n    ) internal {\n        uint256 pendingNextRoundTotalActiveStake = nextRoundTotalActiveStake;\n\n        if (transcoderPoolV2.isFull()) {\n            address lastTranscoder = transcoderPoolV2.getLast();\n            uint256 lastStake = transcoderTotalStake(lastTranscoder);\n\n            // If the pool is full and the transcoder has less stake than the least stake transcoder in the pool\n            // then the transcoder is unable to join the active set for the next round\n            if (_totalStake &lt;= lastStake) {\n                return;\n            }\n\n            // Evict the least stake transcoder from the active set for the next round\n            // Not zeroing \'Transcoder.lastActiveStakeUpdateRound\' saves gas (5k when transcoder is evicted and 20k when transcoder is reinserted)\n            // There should be no side-effects as long as the value is properly updated on stake updates\n            // Not zeroing the stake on the current round\'s \'EarningsPool\' saves gas and should have no side effects as long as\n            // \'EarningsPool.setStake()\' is called whenever a transcoder becomes active again.\n            transcoderPoolV2.remove(lastTranscoder);\n            transcoders[lastTranscoder].deactivationRound = _activationRound;\n            pendingNextRoundTotalActiveStake = pendingNextRoundTotalActiveStake.sub(lastStake);\n\n            emit TranscoderDeactivated(lastTranscoder, _activationRound);\n        }\n\n        transcoderPoolV2.insert(_transcoder, _totalStake, _newPosPrev, _newPosNext);\n        pendingNextRoundTotalActiveStake = pendingNextRoundTotalActiveStake.add(_totalStake);\n        Transcoder storage t = transcoders[_transcoder];\n        t.lastActiveStakeUpdateRound = _activationRound;\n        t.activationRound = _activationRound;\n        t.deactivationRound = MAX_FUTURE_ROUND;\n        t.earningsPoolPerRound[_activationRound].setStake(_totalStake);\n        nextRoundTotalActiveStake = pendingNextRoundTotalActiveStake;\n        emit TranscoderActivated(_transcoder, _activationRound);\n    }\n\n    /\n     * @dev Remove a transcoder from the pool and deactivate it\n     /\n    function resignTranscoder(address _transcoder) internal {\n        // Not zeroing \'Transcoder.lastActiveStakeUpdateRound\' saves gas (5k when transcoder is evicted and 20k when transcoder is reinserted)\n        // There should be no side-effects as long as the value is properly updated on stake updates\n        // Not zeroing the stake on the current round\'s \'EarningsPool\' saves gas and should have no side effects as long as\n        // \'EarningsPool.setStake()\' is called whenever a transcoder becomes active again.\n        transcoderPoolV2.remove(_transcoder);\n        nextRoundTotalActiveStake = nextRoundTotalActiveStake.sub(transcoderTotalStake(_transcoder));\n        uint256 deactivationRound = roundsManager().currentRound().add(1);\n        transcoders[_transcoder].deactivationRound = deactivationRound;\n        emit TranscoderDeactivated(_transcoder, deactivationRound);\n    }\n\n    /\n     * @dev Update a transcoder with rewards and update the transcoder pool with an optional list hint if needed.\n     * See SortedDoublyLL.sol for details on list hints\n     * @param _transcoder Address of transcoder\n     * @param _rewards Amount of rewards\n     * @param _round Round that transcoder is updated\n     * @param _newPosPrev Address of previous transcoder in pool if the transcoder is in the pool\n     * @param _newPosNext Address of next transcoder in pool if the transcoder is in the pool\n     /\n    function updateTranscoderWithRewards(\n        address _transcoder,\n        uint256 _rewards,\n        uint256 _round,\n        address _newPosPrev,\n        address _newPosNext\n    ) internal {\n        Transcoder storage t = transcoders[_transcoder];\n        EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[_round];\n        EarningsPool.Data storage prevEarningsPool = t.earningsPoolPerRound[t.lastRewardRound];\n\n        t.activeCumulativeRewards = t.cumulativeRewards;\n\n        uint256 transcoderCommissionRewards = MathUtils.percOf(_rewards, earningsPool.transcoderRewardCut);\n        uint256 delegatorsRewards = _rewards.sub(transcoderCommissionRewards);\n        // Calculate the rewards earned by the transcoder\'s earned rewards\n        uint256 transcoderRewardStakeRewards = MathUtils.percOf(\n            delegatorsRewards,\n            t.activeCumulativeRewards,\n            earningsPool.totalStake\n        );\n        // Track rewards earned by the transcoder based on its earned rewards and rewardCut\n        t.cumulativeRewards = t.cumulativeRewards.add(transcoderRewardStakeRewards).add(transcoderCommissionRewards);\n        // Update cumulative reward factor with new rewards\n        // The cumulativeRewardFactor is used to calculate rewards for all delegators including the transcoder (self-delegated)\n        // Note that delegatorsRewards includes transcoderRewardStakeRewards, but no delegator will claim that amount using\n        // the earnings claiming algorithm and instead that amount is accounted for in the transcoder\'s cumulativeRewards field\n        earningsPool.updateCumulativeRewardFactor(prevEarningsPool, delegatorsRewards);\n        // Update transcoder\'s total stake with rewards\n        increaseTotalStake(_transcoder, _rewards, _newPosPrev, _newPosNext);\n    }\n\n    /\n     * @dev Update a delegator with token pools shares from its lastClaimRound through a given round\n     * @param _delegator Delegator address\n     * @param _endRound The last round for which to update a delegator\'s stake with earnings pool shares\n     * @param _lastClaimRound The round for which a delegator has last claimed earnings\n     */\n    function updateDelegatorWithEarnings(\n        address _delegator,\n        uint256 _endRound,\n        uint256 _lastClaimRound\n    ) internal {\n        Delegator storage del = delegators[_delegator];\n        uint256 startRound = _lastClaimRound.add(1);\n        uint256 currentBondedAmount = del.bondedAmount;\n        uint256 currentFees = del.fees;\n\n        uint256 lip36Round = roundsManager().lipUpgradeRound(36);\n\n        // Only will have earnings to claim if you have a delegate\n        // If not delegated, skip the earnings claim process\n        if (del.delegateAddress != address(0)) {\n            if (startRound &lt;= lip36Round) {\n                // Cannot claim earnings for more than maxEarningsClaimsRounds before LIP-36\n                // This is a number to cause transactions to fail early if\n                // we know they will require too much gas to loop through all the necessary rounds to claim earnings\n                // The user should instead manually invoke claimEarnings to split up the claiming process\n                // across multiple transactions\n                uint256 endLoopRound = _endRound &lt;= lip36Round ? _endRound : lip36Round;\n                require(\n                    endLoopRound.sub(_lastClaimRound) &lt;= maxEarningsClaimsRounds,\n                    ""too many rounds to claim through""\n                );\n            }\n\n            (currentBondedAmount, currentFees) = pendingStakeAndFees(_delegator, _endRound);\n\n            // Check whether the endEarningsPool is initialised\n            // If it is not initialised set it\'s cumulative factors so that they can be used when a delegator\n            // next claims earnings as the start cumulative factors (see delegatorCumulativeStakeAndFees())\n            Transcoder storage t = transcoders[del.delegateAddress];\n            EarningsPool.Data storage endEarningsPool = t.earningsPoolPerRound[_endRound];\n            if (endEarningsPool.cumulativeRewardFactor == 0) {\n                endEarningsPool.cumulativeRewardFactor = t\n                    .earningsPoolPerRound[t.lastRewardRound]\n                    .cumulativeRewardFactor;\n            }\n            if (endEarningsPool.cumulativeFeeFactor == 0) {\n                endEarningsPool.cumulativeFeeFactor = t.earningsPoolPerRound[t.lastFeeRound].cumulativeFeeFactor;\n            }\n\n            if (del.delegateAddress == _delegator) {\n                t.cumulativeFees = 0;\n                t.cumulativeRewards = 0;\n                // activeCumulativeRewards is not cleared here because the next reward() call will set it to cumulativeRewards\n            }\n        }\n\n        emit EarningsClaimed(\n            del.delegateAddress,\n            _delegator,\n            currentBondedAmount.sub(del.bondedAmount),\n            currentFees.sub(del.fees),\n            startRound,\n            _endRound\n        );\n\n        del.lastClaimRound = _endRound;\n        // Rewards are bonded by default\n        del.bondedAmount = currentBondedAmount;\n        del.fees = currentFees;\n    }\n\n    /\n     * @dev Update the state of a delegator and its delegate by processing a rebond using an unbonding lock and update the transcoder pool with an optional\n     * list hint if needed. See SortedDoublyLL.sol for details on list hints\n     * @param _delegator Address of delegator\n     * @param _unbondingLockId ID of unbonding lock to rebond with\n     * @param _newPosPrev Address of previous transcoder in pool if the delegate is already in or joins the pool\n     * @param _newPosNext Address of next transcoder in pool if the delegate is already in or joins the pool\n     /\n    function processRebond(\n        address _delegator,\n        uint256 _unbondingLockId,\n        address _newPosPrev,\n        address _newPosNext\n    ) internal {\n        Delegator storage del = delegators[_delegator];\n        UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];\n\n        require(isValidUnbondingLock(_delegator, _unbondingLockId), ""invalid unbonding lock ID"");\n\n        uint256 amount = lock.amount;\n        // Increase delegator\'s bonded amount\n        del.bondedAmount = del.bondedAmount.add(amount);\n\n        // Delete lock\n        delete del.unbondingLocks[_unbondingLockId];\n\n        increaseTotalStake(del.delegateAddress, amount, _newPosPrev, _newPosNext);\n\n        emit Rebond(del.delegateAddress, _delegator, _unbondingLockId, amount);\n    }\n\n    /\n     * @dev Return LivepeerToken interface\n     * @return Livepeer token contract registered with Controller\n     /\n    function livepeerToken() internal view returns (ILivepeerToken) {\n        return ILivepeerToken(controller.getContract(keccak256(""LivepeerToken"")));\n    }\n\n    /\n     * @dev Return Minter interface\n     * @return Minter contract registered with Controller\n     */\n    function minter() internal view returns (IMinter) {\n        return IMinter(controller.getContract(keccak256(""Minter"")));\n    }\n\n    /\n     * @dev Return RoundsManager interface\n     * @return RoundsManager contract registered with Controller\n     */\n    function roundsManager() internal view returns (IRoundsManager) {\n        return IRoundsManager(controller.getContract(keccak256(""RoundsManager"")));\n    }\n\n    function _onlyTicketBroker() internal view {\n        require(msg.sender == controller.getContract(keccak256(""TicketBroker"")), ""caller must be TicketBroker"");\n    }\n\n    function _onlyRoundsManager() internal view {\n        require(msg.sender == controller.getContract(keccak256(""RoundsManager"")), ""caller must be RoundsManager"");\n    }\n\n    function _onlyVerifier() internal view {\n        require(msg.sender == controller.getContract(keccak256(""Verifier"")), ""caller must be Verifier"");\n    }\n\n    function _currentRoundInitialized() internal view {\n        require(roundsManager().currentRoundInitialized(), ""current round is not initialized"");\n    }\n\n    function _autoClaimEarnings() internal {\n        uint256 currentRound = roundsManager().currentRound();\n        uint256 lastClaimRound = delegators[msg.sender].lastClaimRound;\n        if (lastClaimRound &lt; currentRound) {\n            updateDelegatorWithEarnings(msg.sender, currentRound, lastClaimRound);\n        }\n    }\n}\n', 'ideas': "" Unchecked Low-level Calls Identified.\n\nVULNERABILITY NAME: Unchecked Low-level Call in withdrawStake\n'''\nIn the withdrawStake function, the contract calls minter().trustedTransferTokens(msg.sender, amount); which is a low-level call to transfer tokens to the delegator. This call does not""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-10-08 17:13:42 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | pragma solidity 0.5.11; import ""../../ManagerProxyTarget.sol""; import ""../IBondingManager.sol""; import ""../../libraries/SortedDoublyLL.sol""; import ""../../libraries/MathUtils.sol""; import ""../libraries/EarningsPool.sol""; import ""../libraries/EarningsPoolLIP36.sol""; import ""../../token/ILivepeerToken.sol""; import ""../../token/IMinter.sol""; import ""../../rounds/IRoundsManager.sol""; import ""../../snapshots/IMerkleSnapshot.sol""; import ""openzeppelin-solidity/contracts/math/SafeMath.sol""; /*  * @title BondingManager  * @notice Manages bonding, transcoder and rewards/fee accounting related operations of the Livepeer protocol  / contract BondingManagerZeroStartFactorsBug is ManagerProxyTarget, IBondingManager {     using SafeMath for uint256;     using SortedDoublyLL for SortedDoublyLL.Data;     using EarningsPool for EarningsPool.Data;     using EarningsPoolLIP36 for EarningsPool.Data; // Constants // Occurances are replaced at compile time // and computed to a single value if possible by the optimizer uint256 constant MAX_FUTURE_ROUND = 2**256 - 1;  // Time between unbonding and possible withdrawl in rounds uint64 public unbondingPeriod; // DEPRECATED - DO NOT USE uint256 public numActiveTranscodersDEPRECATED; // Max number of rounds that a caller can claim earnings for at once uint256 public maxEarningsClaimsRounds;  // Represents a transcoder's current state struct Transcoder {     uint256 lastRewardRound; // Last round that the transcoder called reward     uint256 rewardCut; // % of reward paid to transcoder by a delegator     uint256 feeShare; // % of fees paid to delegators by transcoder     uint256 pricePerSegmentDEPRECATED; // DEPRECATED - DO NOT USE     uint256 pendingRewardCutDEPRECATED; // DEPRECATED - DO NOT USE     uint256 pendingFeeShareDEPRECATED; // DEPRECATED - DO NOT USE     uint256 pendingPricePerSegmentDEPRECATED; // DEPRECATED - DO NOT USE     mapping(uint256 =&gt; EarningsPool.Data) earningsPoolPerRound; // Mapping of round =&gt; earnings pool for the round     uint256 lastActiveStakeUpdateRound; // Round for which the stake was last updated while the transcoder is active     uint256 activationRound; // Round in which the transcoder became active - 0 if inactive     uint256 deactivationRound; // Round in which the transcoder will become inactive     uint256 activeCumulativeRewards; // The transcoder's cumulative rewards that are active in the current round     uint256 cumulativeRewards; // The transcoder's cumulative rewards (earned via the its active staked rewards and its reward cut).     uint256 cumulativeFees; // The transcoder's cumulative fees (earned via the its active staked rewards and its fee share)     uint256 lastFeeRound; // Latest round in which the transcoder received fees }  // The various states a transcoder can be in enum TranscoderStatus {     NotRegistered,     Registered }  // Represents a delegator's current state struct Delegator {     uint256 bondedAmount; // The amount of bonded tokens     uint256 fees; // The amount of fees collected     address delegateAddress; // The address delegated to     uint256 delegatedAmount; // The amount of tokens delegated to the delegator     uint256 startRound; // The round the delegator transitions to bonded phase and is delegated to someone     uint256 withdrawRoundDEPRECATED; // DEPRECATED - DO NOT USE     uint256 lastClaimRound; // The last round during which the delegator claimed its earnings     uint256 nextUnbondingLockId; // ID for the next unbonding lock created     mapping(uint256 =&gt; UnbondingLock) unbondingLocks; // Mapping of unbonding lock ID =&gt; unbonding lock }  // The various states a delegator can be in enum DelegatorStatus {     Pending,     Bonded,     Unbonded }  // Represents an amount of tokens that are being unbonded struct UnbondingLock {     uint256 amount; // Amount of tokens being unbonded     uint256 withdrawRound; // Round at which unbonding period is over and tokens can be withdrawn }  // Keep track of the known transcoders and delegators mapping(address =&gt; Delegator) private delegators; mapping(address =&gt; Transcoder) private transcoders;  // DEPRECATED - DO NOT USE // The function getTotalBonded() no longer uses this variable // and instead calculates the total bonded value separately uint256 private totalBondedDEPRECATED;  // DEPRECATED - DO NOT USE SortedDoublyLL.Data private transcoderPoolDEPRECATED;  // DEPRECATED - DO NOT USE struct ActiveTranscoderSetDEPRECATED {     address[] transcoders;     mapping(address =&gt; bool) isActive;     uint256 totalStake; }  // DEPRECATED - DO NOT USE mapping(uint256 =&gt; ActiveTranscoderSetDEPRECATED) public activeTranscoderSetDEPRECATED;  // The total active stake (sum of the stake of active set members) for the current round uint256 public currentRoundTotalActiveStake; // The total active stake (sum of the stake of active set members) for the next round uint256 public nextRoundTotalActiveStake;  // The transcoder pool is used to keep track of the transcoders that are eligible for activation. // The pool keeps track of the pending active set in round N and the start of round N + 1 transcoders // in the pool are locked into the active set for round N + 1 SortedDoublyLL.Data private transcoderPoolV2;  // Check if sender is TicketBroker modifier onlyTicketBroker() {     _onlyTicketBroker();     _; }  // Check if sender is RoundsManager modifier onlyRoundsManager() {     _onlyRoundsManager();     _; }  // Check if sender is Verifier modifier onlyVerifier() {     _onlyVerifier();     _; }  // Check if current round is initialized modifier currentRoundInitialized() {     _currentRoundInitialized();     _; }  // Automatically claim earnings from lastClaimRound through the current round modifier autoClaimEarnings() {     _autoClaimEarnings();     _; }  /**  * @notice BondingManager constructor. Only invokes constructor of base Manager contract with provided Controller address  * @dev This constructor will not initialize any state variables besides `controller`. The following setter functions  * should be used to initialize state variables post-deployment:  * - setUnbondingPeriod()  * - setNumActiveTranscoders()  * - setMaxEarningsClaimsRounds()  * @param _controller Address of Controller that this contract will be registered with  */ constructor(address _controller) public Manager(_controller) {}  /**  * @notice Set unbonding period. Only callable by Controller owner  * @param _unbondingPeriod Rounds between unbonding and possible withdrawal  */ function setUnbondingPeriod(uint64 _unbondingPeriod) external onlyControllerOwner {     unbondingPeriod = _unbondingPeriod;      emit ParameterUpdate(""unbondingPeriod""); }  /**  * @notice Set maximum number of active transcoders. Only callable by Controller owner  * @param _numActiveTranscoders Number of active transcoders  */ function setNumActiveTranscoders(uint256 _numActiveTranscoders) external onlyControllerOwner {     transcoderPoolV2.setMaxSize(_numActiveTranscoders);      emit ParameterUpdate(""numActiveTranscoders""); }  /**  * @notice Set max number of rounds a caller can claim earnings for at once. Only callable by Controller owner  * @param _maxEarningsClaimsRounds Max number of rounds a caller can claim earnings for at once  */ function setMaxEarningsClaimsRounds(uint256 _maxEarningsClaimsRounds) external onlyControllerOwner {     maxEarningsClaimsRounds = _maxEarningsClaimsRounds;      emit ParameterUpdate(""maxEarningsClaimsRounds""); }  /**  * @notice Sets commission rates as a transcoder and if the caller is not in the transcoder pool tries to add it  * @dev Percentages are represented as numerators of fractions over MathUtils.PERC_DIVISOR  * @param _rewardCut % of reward paid to transcoder by a delegator  * @param _feeShare % of fees paid to delegators by a transcoder  */ function transcoder(uint256 _rewardCut, uint256 _feeShare) external {     transcoderWithHint(_rewardCut, _feeShare, address(0), address(0)); }  /**  * @notice Delegate stake towards a specific address  * @param _amount The amount of tokens to stake  * @param _to The address of the transcoder to stake towards  */ function bond(uint256 _amount, address _to) external {     bondWithHint(_amount, _to, address(0), address(0), address(0), address(0)); }  /**  * @notice Unbond an amount of the delegator's bonded stake  * @param _amount Amount of tokens to unbond  */ function unbond(uint256 _amount) external {     unbondWithHint(_amount, address(0), address(0)); }  /**  * @notice Rebond tokens for an unbonding lock to a delegator's current delegate while a delegator is in the Bonded or Pending status  * @param _unbondingLockId ID of unbonding lock to rebond with  */ function rebond(uint256 _unbondingLockId) external {     rebondWithHint(_unbondingLockId, address(0), address(0)); }  /**  * @notice Rebond tokens for an unbonding lock to a delegate while a delegator is in the Unbonded status  * @param _to Address of delegate  * @param _unbondingLockId ID of unbonding lock to rebond with  */ function rebondFromUnbonded(address _to, uint256 _unbondingLockId) external {     rebondFromUnbondedWithHint(_to, _unbondingLockId, address(0), address(0)); }  /**  * @notice Withdraws tokens for an unbonding lock that has existed through an unbonding period  * @param _unbondingLockId ID of unbonding lock to withdraw with  */ function withdrawStake(uint256 _unbondingLockId) external whenSystemNotPaused currentRoundInitialized {     Delegator storage del = delegators[msg.sender];     UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];      require(isValidUnbondingLock(msg.sender, _unbondingLockId), ""invalid unbonding lock ID"");     require(         lock.withdrawRound &lt;= roundsManager().currentRound(),         ""withdraw round must be before or equal to the current round""     );      uint256 amount = lock.amount;     uint256 withdrawRound = lock.withdrawRound;     // Delete unbonding lock     delete del.unbondingLocks[_unbondingLockId];      // Tell Minter to transfer stake (LPT) to the delegator     minter().trustedTransferTokens(msg.sender, amount);      emit WithdrawStake(msg.sender, _unbondingLockId, amount, withdrawRound); }  /**  * @notice Withdraws fees to the caller  */ function withdrawFees() external whenSystemNotPaused currentRoundInitialized autoClaimEarnings {     uint256 fees = delegators[msg.sender].fees;     require(fees &gt; 0, ""no fees to withdraw"");     delegators[msg.sender].fees = 0;      // Tell Minter to transfer fees (ETH) to the delegator     minter().trustedWithdrawETH(msg.sender, fees);      emit WithdrawFees(msg.sender); }  /**  * @notice Mint token rewards for an active transcoder and its delegators  */ function reward() external {     rewardWithHint(address(0), address(0)); }  /**  * @notice Update transcoder's fee pool. Only callable by the TicketBroker  * @param _transcoder Transcoder address  * @param _fees Fees to be added to the fee pool  */ function updateTranscoderWithFees(     address _transcoder,     uint256 _fees,     uint256 _round ) external whenSystemNotPaused onlyTicketBroker {     // Silence unused param compiler warning     _round;      require(isRegisteredTranscoder(_transcoder), ""transcoder must be registered"");      uint256 currentRound = roundsManager().currentRound();      Transcoder storage t = transcoders[_transcoder];      uint256 lastRewardRound = t.lastRewardRound;     uint256 activeCumulativeRewards = t.activeCumulativeRewards;      // LIP-36: Add fees for the current round instead of '_round'     // https://github.com/livepeer/LIPs/issues/35#issuecomment-673659199     EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[currentRound];     EarningsPool.Data memory prevEarningsPool = latestCumulativeFactorsPool(t, currentRound.sub(1));      // if transcoder hasn't called 'reward()' for '_round' its 'transcoderFeeShare', 'transcoderRewardCut' and 'totalStake'     // on the 'EarningsPool' for '_round' would not be initialized and the fee distribution wouldn't happen as expected     // for cumulative fee calculation this would result in division by zero.     if (currentRound &gt; lastRewardRound) {         earningsPool.setCommission(t.rewardCut, t.feeShare);          uint256 lastUpdateRound = t.lastActiveStakeUpdateRound;         if (lastUpdateRound &lt; currentRound) {             earningsPool.setStake(t.earningsPoolPerRound[lastUpdateRound].totalStake);         }          // If reward() has not been called yet in the current round, then the transcoder's activeCumulativeRewards has not         // yet been set in for the round. When the transcoder calls reward() its activeCumulativeRewards will be set to its         // current cumulativeRewards. So, we can just use the transcoder's cumulativeRewards here because this will become         // the transcoder's activeCumulativeRewards if it calls reward() later on in the current round         activeCumulativeRewards = t.cumulativeRewards;     }      uint256 totalStake = earningsPool.totalStake;     if (prevEarningsPool.cumulativeRewardFactor == 0 &amp;&amp; lastRewardRound == currentRound) {         // if transcoder called reward for 'currentRound' but not for 'currentRound - 1' (missed reward call)         // retroactively calculate what its cumulativeRewardFactor would have been for 'currentRound - 1' (cfr. previous lastRewardRound for transcoder)         // based on rewards for currentRound         IMinter mtr = minter();         uint256 rewards = MathUtils.percOf(             mtr.currentMintableTokens().add(mtr.currentMintedTokens()),             totalStake,             currentRoundTotalActiveStake         );         uint256 transcoderCommissionRewards = MathUtils.percOf(rewards, earningsPool.transcoderRewardCut);         uint256 delegatorsRewards = rewards.sub(transcoderCommissionRewards);          prevEarningsPool.cumulativeRewardFactor = MathUtils.percOf(             earningsPool.cumulativeRewardFactor,             totalStake,             delegatorsRewards.add(totalStake)         );     }      uint256 delegatorsFees = MathUtils.percOf(_fees, earningsPool.transcoderFeeShare);     uint256 transcoderCommissionFees = _fees.sub(delegatorsFees);     // Calculate the fees earned by the transcoder's earned rewards     uint256 transcoderRewardStakeFees = MathUtils.percOf(delegatorsFees, activeCumulativeRewards, totalStake);     // Track fees earned by the transcoder based on its earned rewards and feeShare     t.cumulativeFees = t.cumulativeFees.add(transcoderRewardStakeFees).add(transcoderCommissionFees);     // Update cumulative fee factor with new fees     // The cumulativeFeeFactor is used to calculate fees for all delegators including the transcoder (self-delegated)     // Note that delegatorsFees includes transcoderRewardStakeFees, but no delegator will claim that amount using     // the earnings claiming algorithm and instead that amount is accounted for in the transcoder's cumulativeFees field     earningsPool.updateCumulativeFeeFactor(prevEarningsPool, delegatorsFees);      t.lastFeeRound = currentRound; }  /**  * @notice Slash a transcoder. Only callable by the Verifier  * @param _transcoder Transcoder address  * @param _finder Finder that proved a transcoder violated a slashing condition. Null address if there is no finder  * @param _slashAmount Percentage of transcoder bond to be slashed  * @param _finderFee Percentage of penalty awarded to finder. Zero if there is no finder  */ function slashTranscoder(     address _transcoder,     address _finder,     uint256 _slashAmount,     uint256 _finderFee ) external whenSystemNotPaused onlyVerifier {     Delegator storage del = delegators[_transcoder];      if (del.bondedAmount &gt; 0) {         uint256 penalty = MathUtils.percOf(delegators[_transcoder].bondedAmount, _slashAmount);          // If active transcoder, resign it         if (transcoderPoolV2.contains(_transcoder)) {             resignTranscoder(_transcoder);         }          // Decrease bonded stake         del.bondedAmount = del.bondedAmount.sub(penalty);          // If still bonded decrease delegate's delegated amount         if (delegatorStatus(_transcoder) == DelegatorStatus.Bonded) {             delegators[del.delegateAddress].delegatedAmount = delegators[del.delegateAddress].delegatedAmount.sub(                 penalty             );         }          // Account for penalty         uint256 burnAmount = penalty;          // Award finder fee if there is a finder address         if (_finder != address(0)) {             uint256 finderAmount = MathUtils.percOf(penalty, _finderFee);             minter().trustedTransferTokens(_finder, finderAmount);              // Minter burns the slashed funds - finder reward             minter().trustedBurnTokens(burnAmount.sub(finderAmount));              emit TranscoderSlashed(_transcoder, _finder, penalty, finderAmount);         } else {             // Minter burns the slashed funds             minter().trustedBurnTokens(burnAmount);              emit TranscoderSlashed(_transcoder, address(0), penalty, 0);         }     } else {         emit TranscoderSlashed(_transcoder, _finder, 0, 0);     } }  /**  * @notice Claim token pools shares for a delegator from its lastClaimRound through the end round  * @param _endRound The last round for which to claim token pools shares for a delegator  */ function claimEarnings(uint256 _endRound) external whenSystemNotPaused currentRoundInitialized {     uint256 lastClaimRound = delegators[msg.sender].lastClaimRound;     require(lastClaimRound &lt; _endRound, ""end round must be after last claim round"");     require(_endRound &lt;= roundsManager().currentRound(), ""end round must be before or equal to current round"");      updateDelegatorWithEarnings(msg.sender, _endRound, lastClaimRound); }  /**  * @notice Claim earnings for a delegator based on the snapshot taken in LIP-52  * @dev https://github.com/livepeer/LIPs/blob/master/LIPs/LIP-52.md  * @param _pendingStake the amount of pending stake for the delegator (current stake + pending rewards)  * @param _pendingFees the amount of pending fees for the delegator (current fees + pending fees)  * @param _earningsProof array of keccak256 sibling hashes on the branch of the leaf for the delegator up to the root  * @param _data (optional) raw transaction data to be executed on behalf of msg.sender after claiming snapshot earnings  */ function claimSnapshotEarnings(     uint256 _pendingStake,     uint256 _pendingFees,     bytes32[] calldata _earningsProof,     bytes calldata _data ) external whenSystemNotPaused currentRoundInitialized {     Delegator storage del = delegators[msg.sender];      uint256 lip52Round = roundsManager().lipUpgradeRound(52);      uint256 lastClaimRound = del.lastClaimRound;      require(lastClaimRound &lt; lip52Round, ""Already claimed for LIP-52"");      bytes32 leaf = keccak256(abi.encode(msg.sender, _pendingStake, _pendingFees));      require(         IMerkleSnapshot(controller.getContract(keccak256(""MerkleSnapshot""))).verify(             keccak256(""LIP-52""),             _earningsProof,             leaf         ),         ""Merkle proof is invalid""     );      emit EarningsClaimed(         del.delegateAddress,         msg.sender,         _pendingStake.sub(del.bondedAmount),         _pendingFees.sub(del.fees),         lastClaimRound.add(1),         lip52Round     );      del.lastClaimRound = lip52Round;     del.bondedAmount = _pendingStake;     del.fees = _pendingFees;      // allow for execution of subsequent claiming or staking operations     if (_data.length &gt; 0) {         (bool success, bytes memory returnData) = address(this).delegatecall(_data);         require(success, string(returnData));     } }  /**  * @notice Called during round initialization to set the total active stake for the round. Only callable by the RoundsManager  */ function setCurrentRoundTotalActiveStake() external onlyRoundsManager {     currentRoundTotalActiveStake = nextRoundTotalActiveStake; }  /**  * @notice Sets commission rates as a transcoder and if the caller is not in the transcoder pool tries to add it using an optional list hint  * @dev Percentages are represented as numerators of fractions over MathUtils.PERC_DIVISOR. If the caller is going to be added to the pool, the  * caller can provide an optional hint for the insertion position in the pool via the `_newPosPrev` and `_newPosNext` params. A linear search will  * be executed starting at the hint to find the correct position - in the best case, the hint is the correct position so no search is executed.  * See SortedDoublyLL.sol for details on list hints  * @param _rewardCut % of reward paid to transcoder by a delegator  * @param _feeShare % of fees paid to delegators by a transcoder  * @param _newPosPrev Address of previous transcoder in pool if the caller joins the pool  * @param _newPosNext Address of next transcoder in pool if the caller joins the pool  */ function transcoderWithHint(     uint256 _rewardCut,     uint256 _feeShare,     address _newPosPrev,     address _newPosNext ) public whenSystemNotPaused currentRoundInitialized {     require(!roundsManager().currentRoundLocked(), ""can't update transcoder params, current round is locked"");     require(MathUtils.validPerc(_rewardCut), ""invalid rewardCut percentage"");     require(MathUtils.validPerc(_feeShare), ""invalid feeShare percentage"");     require(isRegisteredTranscoder(msg.sender), ""transcoder must be registered"");      Transcoder storage t = transcoders[msg.sender];     uint256 currentRound = roundsManager().currentRound();      require(         !isActiveTranscoder(msg.sender) || t.lastRewardRound == currentRound,         ""caller can't be active or must have already called reward for the current round""     );      t.rewardCut = _rewardCut;     t.feeShare = _feeShare;      if (!transcoderPoolV2.contains(msg.sender)) {         tryToJoinActiveSet(             msg.sender,             delegators[msg.sender].delegatedAmount,             currentRound.add(1),             _newPosPrev,             _newPosNext         );     }      emit TranscoderUpdate(msg.sender, _rewardCut, _feeShare); }  /**  * @notice Delegate stake towards a specific address and updates the transcoder pool using optional list hints if needed  * @dev If the caller is decreasing the stake of its old delegate in the transcoder pool, the caller can provide an optional hint  * for the insertion position of the old delegate via the `_oldDelegateNewPosPrev` and `_oldDelegateNewPosNext` params.  * If the caller is delegating to a delegate that is in the transcoder pool, the caller can provide an optional hint for the  * insertion position of the delegate via the `_currDelegateNewPosPrev` and `_currDelegateNewPosNext` params.  * In both cases, a linear search will be executed starting at the hint to find the correct position. In the best case, the hint  * is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints  * @param _amount The amount of tokens to stake.  * @param _to The address of the transcoder to stake towards  * @param _oldDelegateNewPosPrev The address of the previous transcoder in the pool for the old delegate  * @param _oldDelegateNewPosNext The address of the next transcoder in the pool for the old delegate  * @param _currDelegateNewPosPrev The address of the previous transcoder in the pool for the current delegate  * @param _currDelegateNewPosNext The address of the next transcoder in the pool for the current delegate  */ function bondWithHint(     uint256 _amount,     address _to,     address _oldDelegateNewPosPrev,     address _oldDelegateNewPosNext,     address _currDelegateNewPosPrev,     address _currDelegateNewPosNext ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {     Delegator storage del = delegators[msg.sender];      uint256 currentRound = roundsManager().currentRound();     // Amount to delegate     uint256 delegationAmount = _amount;     // Current delegate     address currentDelegate = del.delegateAddress;      if (delegatorStatus(msg.sender) == DelegatorStatus.Unbonded) {         // New delegate         // Set start round         // Don't set start round if delegator is in pending state because the start round would not change         del.startRound = currentRound.add(1);         // Unbonded state = no existing delegate and no bonded stake         // Thus, delegation amount = provided amount     } else if (currentDelegate != address(0) &amp;&amp; currentDelegate != _to) {         // A registered transcoder cannot delegate its bonded stake toward another address         // because it can only be delegated toward itself         // In the future, if delegation towards another registered transcoder as an already         // registered transcoder becomes useful (i.e. for transitive delegation), this restriction         // could be removed         require(             !isRegisteredTranscoder(msg.sender),             ""registered transcoders can't delegate towards other addresses""         );         // Changing delegate         // Set start round         del.startRound = currentRound.add(1);         // Update amount to delegate with previous delegation amount         delegationAmount = delegationAmount.add(del.bondedAmount);          decreaseTotalStake(currentDelegate, del.bondedAmount, _oldDelegateNewPosPrev, _oldDelegateNewPosNext);     }      // cannot delegate to someone without having bonded stake     require(delegationAmount &gt; 0, ""delegation amount must be greater than 0"");     // Update delegate     del.delegateAddress = _to;     // Update bonded amount     del.bondedAmount = del.bondedAmount.add(_amount);      increaseTotalStake(_to, delegationAmount, _currDelegateNewPosPrev, _currDelegateNewPosNext);      if (_amount &gt; 0) {         // Transfer the LPT to the Minter         livepeerToken().transferFrom(msg.sender, address(minter()), _amount);     }      emit Bond(_to, currentDelegate, msg.sender, _amount, del.bondedAmount); }  /**  * @notice Unbond an amount of the delegator's bonded stake and updates the transcoder pool using an optional list hint if needed  * @dev If the caller remains in the transcoder pool, the caller can provide an optional hint for its insertion position in the  * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.  * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol details on list hints  * @param _amount Amount of tokens to unbond  * @param _newPosPrev Address of previous transcoder in pool if the caller remains in the pool  * @param _newPosNext Address of next transcoder in pool if the caller remains in the pool  */ function unbondWithHint(     uint256 _amount,     address _newPosPrev,     address _newPosNext ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {     require(delegatorStatus(msg.sender) == DelegatorStatus.Bonded, ""caller must be bonded"");      Delegator storage del = delegators[msg.sender];      require(_amount &gt; 0, ""unbond amount must be greater than 0"");     require(_amount &lt;= del.bondedAmount, ""amount is greater than bonded amount"");      address currentDelegate = del.delegateAddress;     uint256 currentRound = roundsManager().currentRound();     uint256 withdrawRound = currentRound.add(unbondingPeriod);     uint256 unbondingLockId = del.nextUnbondingLockId;      // Create new unbonding lock     del.unbondingLocks[unbondingLockId] = UnbondingLock({ amount: _amount, withdrawRound: withdrawRound });     // Increment ID for next unbonding lock     del.nextUnbondingLockId = unbondingLockId.add(1);     // Decrease delegator's bonded amount     del.bondedAmount = del.bondedAmount.sub(_amount);      if (del.bondedAmount == 0) {         // Delegator no longer delegated to anyone if it does not have a bonded amount         del.delegateAddress = address(0);         // Delegator does not have a start round if it is no longer delegated to anyone         del.startRound = 0;          if (transcoderPoolV2.contains(msg.sender)) {             resignTranscoder(msg.sender);         }     }      // If msg.sender was resigned this statement will only decrease delegators[currentDelegate].delegatedAmount     decreaseTotalStake(currentDelegate, _amount, _newPosPrev, _newPosNext);      emit Unbond(currentDelegate, msg.sender, unbondingLockId, _amount, withdrawRound); }  /**  * @notice Rebond tokens for an unbonding lock to a delegator's current delegate while a delegator is in the Bonded or Pending status and updates  * the transcoder pool using an optional list hint if needed  * @dev If the delegate is in the transcoder pool, the caller can provide an optional hint for the delegate's insertion position in the  * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.  * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol details on list hints  * @param _unbondingLockId ID of unbonding lock to rebond with  * @param _newPosPrev Address of previous transcoder in pool if the delegate is in the pool  * @param _newPosNext Address of next transcoder in pool if the delegate is in the pool  */ function rebondWithHint(     uint256 _unbondingLockId,     address _newPosPrev,     address _newPosNext ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {     require(delegatorStatus(msg.sender) != DelegatorStatus.Unbonded, ""caller must be bonded"");      // Process rebond using unbonding lock     processRebond(msg.sender, _unbondingLockId, _newPosPrev, _newPosNext); }  /**  * @notice Rebond tokens for an unbonding lock to a delegate while a delegator is in the Unbonded status and updates the transcoder pool using  * an optional list hint if needed  * @dev If the delegate joins the transcoder pool, the caller can provide an optional hint for the delegate's insertion position in the  * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.  * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints  * @param _to Address of delegate  * @param _unbondingLockId ID of unbonding lock to rebond with  * @param _newPosPrev Address of previous transcoder in pool if the delegate joins the pool  * @param _newPosNext Address of next transcoder in pool if the delegate joins the pool  */ function rebondFromUnbondedWithHint(     address _to,     uint256 _unbondingLockId,     address _newPosPrev,     address _newPosNext ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {     require(delegatorStatus(msg.sender) == DelegatorStatus.Unbonded, ""caller must be unbonded"");      // Set delegator's start round and transition into Pending state     delegators[msg.sender].startRound = roundsManager().currentRound().add(1);     // Set delegator's delegate     delegators[msg.sender].delegateAddress = _to;     // Process rebond using unbonding lock     processRebond(msg.sender, _unbondingLockId, _newPosPrev, _newPosNext); }  /**  * @notice Mint token rewards for an active transcoder and its delegators and update the transcoder pool using an optional list hint if needed  * @dev If the caller is in the transcoder pool, the caller can provide an optional hint for its insertion position in the  * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.  * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints  * @param _newPosPrev Address of previous transcoder in pool if the caller is in the pool  * @param _newPosNext Address of next transcoder in pool if the caller is in the pool  */ function rewardWithHint(address _newPosPrev, address _newPosNext)     public     whenSystemNotPaused     currentRoundInitialized {     uint256 currentRound = roundsManager().currentRound();      require(isActiveTranscoder(msg.sender), ""caller must be an active transcoder"");     require(         transcoders[msg.sender].lastRewardRound != currentRound,         ""caller has already called reward for the current round""     );      Transcoder storage t = transcoders[msg.sender];     EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[currentRound];      // Set last round that transcoder called reward     earningsPool.setCommission(t.rewardCut, t.feeShare);      // If transcoder didn't receive stake updates during the previous round and hasn't called reward for &gt; 1 round     // the 'totalStake' on its 'EarningsPool' for the current round wouldn't be initialized     // Thus we sync the the transcoder's stake to when it was last updated     // 'updateTrancoderWithRewards()' will set the update round to 'currentRound +1' so this synchronization shouldn't occur frequently     uint256 lastUpdateRound = t.lastActiveStakeUpdateRound;     if (lastUpdateRound &lt; currentRound) {         earningsPool.setStake(t.earningsPoolPerRound[lastUpdateRound].totalStake);     }      // Create reward based on active transcoder's stake relative to the total active stake     // rewardTokens = (current mintable tokens for the round * active transcoder stake) / total active stake     uint256 rewardTokens = minter().createReward(earningsPool.totalStake, currentRoundTotalActiveStake);      updateTranscoderWithRewards(msg.sender, rewardTokens, currentRound, _newPosPrev, _newPosNext);      // Set last round that transcoder called reward     t.lastRewardRound = currentRound;      emit Reward(msg.sender, rewardTokens); }  /**  * @notice Returns pending bonded stake for a delegator from its lastClaimRound through an end round  * @param _delegator Address of delegator  * @param _endRound The last round to compute pending stake from  * @return Pending bonded stake for '_delegator' since last claiming rewards  */ function pendingStake(address _delegator, uint256 _endRound) public view returns (uint256) {     (uint256 stake, ) = pendingStakeAndFees(_delegator, _endRound);     return stake; }  /**  * @notice Returns pending fees for a delegator from its lastClaimRound through an end round  * @param _delegator Address of delegator  * @param _endRound The last round to compute pending fees from  * @return Pending fees for '_delegator' since last claiming fees  */ function pendingFees(address _delegator, uint256 _endRound) public view returns (uint256) {     (, uint256 fees) = pendingStakeAndFees(_delegator, _endRound);     return fees; }  /**  * @notice Returns total bonded stake for a transcoder  * @param _transcoder Address of transcoder  * @return total bonded stake for a delegator  */ function transcoderTotalStake(address _transcoder) public view returns (uint256) {     return delegators[_transcoder].delegatedAmount; }  /**  * @notice Computes transcoder status  * @param _transcoder Address of transcoder  * @return registered or not registered transcoder status  */ function transcoderStatus(address _transcoder) public view returns (TranscoderStatus) {     if (isRegisteredTranscoder(_transcoder)) return TranscoderStatus.Registered;     return TranscoderStatus.NotRegistered; }  /**  * @notice Computes delegator status  * @param _delegator Address of delegator  * @return bonded, unbonded or pending delegator status  */ function delegatorStatus(address _delegator) public view returns (DelegatorStatus) {     Delegator storage del = delegators[_delegator];      if (del.bondedAmount == 0) {         // Delegator unbonded all its tokens         return DelegatorStatus.Unbonded;     } else if (del.startRound &gt; roundsManager().currentRound()) {         // Delegator round start is in the future         return DelegatorStatus.Pending;     } else {         // Delegator round start is now or in the past         // del.startRound != 0 here because if del.startRound = 0 then del.bondedAmount = 0 which         // would trigger the first if clause         return DelegatorStatus.Bonded;     } }  /**  * @notice Return transcoder information  * @param _transcoder Address of transcoder  * @return lastRewardRound Trancoder's last reward round  * @return rewardCut Transcoder's reward cut  * @return feeShare Transcoder's fee share  * @return lastActiveStakeUpdateRound Round in which transcoder's stake was last updated while active  * @return activationRound Round in which transcoder became active  * @return deactivationRound Round in which transcoder will no longer be active  * @return activeCumulativeRewards Transcoder's cumulative rewards that are currently active  * @return cumulativeRewards Transcoder's cumulative rewards (earned via its active staked rewards and its reward cut)  * @return cumulativeFees Transcoder's cumulative fees (earned via its active staked rewards and its fee share)  * @return lastFeeRound Latest round that the transcoder received fees  */ function getTranscoder(address _transcoder)     public     view     returns (         uint256 lastRewardRound,         uint256 rewardCut,         uint256 feeShare,         uint256 lastActiveStakeUpdateRound,         uint256 activationRound,         uint256 deactivationRound,         uint256 activeCumulativeRewards,         uint256 cumulativeRewards,         uint256 cumulativeFees,         uint256 lastFeeRound     ) {     Transcoder storage t = transcoders[_transcoder];      lastRewardRound = t.lastRewardRound;     rewardCut = t.rewardCut;     feeShare = t.feeShare;     lastActiveStakeUpdateRound = t.lastActiveStakeUpdateRound;     activationRound = t.activationRound;     deactivationRound = t.deactivationRound;     activeCumulativeRewards = t.activeCumulativeRewards;     cumulativeRewards = t.cumulativeRewards;     cumulativeFees = t.cumulativeFees;     lastFeeRound = t.lastFeeRound; }  /**  * @notice Return transcoder's earnings pool for a given round  * @param _transcoder Address of transcoder  * @param _round Round number  * @return rewardPool Reward pool for delegators (only used before LIP-36)  * @return feePool Fee pool for delegators (only used before LIP-36)  * @return totalStake Transcoder's total stake in '_round'  * @return claimableStake Remaining stake that can be used to claim from the pool (only used before LIP-36)  * @return transcoderRewardCut Transcoder's reward cut for '_round'  * @return transcoderFeeShare Transcoder's fee share for '_round'  * @return transcoderRewardPool Transcoder's rewards for '_round' (only used before LIP-36)  * @return transcoderFeePool Transcoder's fees for '_round' (only used before LIP-36)  * @return hasTranscoderRewardFeePool True if there is a split reward/fee pool for the transcoder (only used before LIP-36)  * @return cumulativeRewardFactor The cumulative reward factor for delegator rewards calculation (only used after LIP-36)  * @return cumulativeFeeFactor The cumulative fee factor for delegator fees calculation (only used after LIP-36)  */ function getTranscoderEarningsPoolForRound(address _transcoder, uint256 _round)     public     view     returns (         uint256 rewardPool,         uint256 feePool,         uint256 totalStake,         uint256 claimableStake,         uint256 transcoderRewardCut,         uint256 transcoderFeeShare,         uint256 transcoderRewardPool,         uint256 transcoderFeePool,         bool hasTranscoderRewardFeePool,         uint256 cumulativeRewardFactor,         uint256 cumulativeFeeFactor     ) {     EarningsPool.Data storage earningsPool = transcoders[_transcoder].earningsPoolPerRound[_round];      rewardPool = earningsPool.rewardPool;     feePool = earningsPool.feePool;     totalStake = earningsPool.totalStake;     claimableStake = earningsPool.claimableStake;     transcoderRewardCut = earningsPool.transcoderRewardCut;     transcoderFeeShare = earningsPool.transcoderFeeShare;     transcoderRewardPool = earningsPool.transcoderRewardPool;     transcoderFeePool = earningsPool.transcoderFeePool;     hasTranscoderRewardFeePool = earningsPool.hasTranscoderRewardFeePool;     cumulativeRewardFactor = earningsPool.cumulativeRewardFactor;     cumulativeFeeFactor = earningsPool.cumulativeFeeFactor; }  /**  * @notice Return delegator info  * @param _delegator Address of delegator  * @return total amount bonded by '_delegator'  * @return amount of fees collected by '_delegator'  * @return address '_delegator' has bonded to  * @return total amount delegated to '_delegator'  * @return round in which bond for '_delegator' became effective  * @return round for which '_delegator' has last claimed earnings  * @return ID for the next unbonding lock created for '_delegator'  */ function getDelegator(address _delegator)     public     view     returns (         uint256 bondedAmount,         uint256 fees,         address delegateAddress,         uint256 delegatedAmount,         uint256 startRound,         uint256 lastClaimRound,         uint256 nextUnbondingLockId     ) {     Delegator storage del = delegators[_delegator];      bondedAmount = del.bondedAmount;     fees = del.fees;     delegateAddress = del.delegateAddress;     delegatedAmount = del.delegatedAmount;     startRound = del.startRound;     lastClaimRound = del.lastClaimRound;     nextUnbondingLockId = del.nextUnbondingLockId; }  /**  * @notice Return delegator's unbonding lock info  * @param _delegator Address of delegator  * @param _unbondingLockId ID of unbonding lock  * @return amount of stake locked up by unbonding lock  * @return round in which 'amount' becomes available for withdrawal  */ function getDelegatorUnbondingLock(address _delegator, uint256 _unbondingLockId)     public     view     returns (uint256 amount, uint256 withdrawRound) {     UnbondingLock storage lock = delegators[_delegator].unbondingLocks[_unbondingLockId];      return (lock.amount, lock.withdrawRound); }  /**  * @notice Returns max size of transcoder pool  * @return transcoder pool max size  */ function getTranscoderPoolMaxSize() public view returns (uint256) {     return transcoderPoolV2.getMaxSize(); }  /**  * @notice Returns size of transcoder pool  * @return transcoder pool current size  */ function getTranscoderPoolSize() public view returns (uint256) {     return transcoderPoolV2.getSize(); }  /**  * @notice Returns transcoder with most stake in pool  * @return address for transcoder with highest stake in transcoder pool  */ function getFirstTranscoderInPool() public view returns (address) {     return transcoderPoolV2.getFirst(); }  /**  * @notice Returns next transcoder in pool for a given transcoder  * @param _transcoder Address of a transcoder in the pool  * @return address for the transcoder after '_transcoder' in transcoder pool  */ function getNextTranscoderInPool(address _transcoder) public view returns (address) {     return transcoderPoolV2.getNext(_transcoder); }  /**  * @notice Return total bonded tokens  * @return total active stake for the current round  */ function getTotalBonded() public view returns (uint256) {     return currentRoundTotalActiveStake; }  /**  * @notice Return whether a transcoder is active for the current round  * @param _transcoder Transcoder address  * @return true if transcoder is active  */ function isActiveTranscoder(address _transcoder) public view returns (bool) {     Transcoder storage t = transcoders[_transcoder];     uint256 currentRound = roundsManager().currentRound();     return t.activationRound &lt;= currentRound &amp;&amp; currentRound &lt; t.deactivationRound; }  /**  * @notice Return whether a transcoder is registered  * @param _transcoder Transcoder address  * @return true if transcoder is self-bonded  */ function isRegisteredTranscoder(address _transcoder) public view returns (bool) {     Delegator storage d = delegators[_transcoder];     return d.delegateAddress == _transcoder &amp;&amp; d.bondedAmount &gt; 0; }  /**  * @notice Return whether an unbonding lock for a delegator is valid  * @param _delegator Address of delegator  * @param _unbondingLockId ID of unbonding lock  * @return true if unbondingLock for ID has a non-zero withdraw round  */ function isValidUnbondingLock(address _delegator, uint256 _unbondingLockId) public view returns (bool) {     // A unbonding lock is only valid if it has a non-zero withdraw round (the default value is zero)     return delegators[_delegator].unbondingLocks[_unbondingLockId].withdrawRound &gt; 0; }  /**  * @notice Return an EarningsPool.Data struct with the latest cumulative factors for a given round  * @param _transcoder Storage pointer to a transcoder struct  * @param _round The round to fetch the latest cumulative factors for  * @return pool An EarningsPool.Data populated with the latest cumulative factors for _round  */ function latestCumulativeFactorsPool(Transcoder storage _transcoder, uint256 _round)     internal     view     returns (EarningsPool.Data memory pool) {     pool.cumulativeRewardFactor = _transcoder.earningsPoolPerRound[_round].cumulativeRewardFactor;     pool.cumulativeFeeFactor = _transcoder.earningsPoolPerRound[_round].cumulativeFeeFactor;      uint256 lastRewardRound = _transcoder.lastRewardRound;     // Only use the cumulativeRewardFactor for lastRewardRound if lastRewardRound is before _round     if (pool.cumulativeRewardFactor == 0 &amp;&amp; lastRewardRound &lt; _round) {         pool.cumulativeRewardFactor = _transcoder.earningsPoolPerRound[lastRewardRound].cumulativeRewardFactor;     }      uint256 lastFeeRound = _transcoder.lastFeeRound;     // Only use the cumulativeFeeFactor for lastFeeRound if lastFeeRound is before _round     if (pool.cumulativeFeeFactor == 0 &amp;&amp; lastFeeRound &lt; _round) {         pool.cumulativeFeeFactor = _transcoder.earningsPoolPerRound[lastFeeRound].cumulativeFeeFactor;     }      return pool; }  /**  * @notice Return a delegator's cumulative stake and fees using the LIP-36 earnings claiming algorithm  * @param _transcoder Storage pointer to a transcoder struct for a delegator's delegate  * @param _startRound The round for the start cumulative factors  * @param _endRound The round for the end cumulative factors  * @param _stake The delegator's initial stake before including earned rewards  * @param _fees The delegator's initial fees before including earned fees  * @return (cStake, cFees) where cStake is the delegator's cumulative stake including earned rewards and cFees is the delegator's cumulative fees including earned fees  */ function delegatorCumulativeStakeAndFees(     Transcoder storage _transcoder,     uint256 _startRound,     uint256 _endRound,     uint256 _stake,     uint256 _fees ) internal view returns (uint256 cStake, uint256 cFees) {     uint256 baseRewardFactor = MathUtils.percPoints(1, 1);      // Fetch start cumulative factors     EarningsPool.Data memory startPool;     startPool.cumulativeRewardFactor = _transcoder.earningsPoolPerRound[_startRound].cumulativeRewardFactor;     startPool.cumulativeFeeFactor = _transcoder.earningsPoolPerRound[_startRound].cumulativeFeeFactor;      if (startPool.cumulativeRewardFactor == 0) {         startPool.cumulativeRewardFactor = baseRewardFactor;     }      // Fetch end cumulative factors     EarningsPool.Data memory endPool = latestCumulativeFactorsPool(_transcoder, _endRound);      if (endPool.cumulativeRewardFactor == 0) {         endPool.cumulativeRewardFactor = baseRewardFactor;     }      cFees = _fees.add(         MathUtils.percOf(             _stake,             endPool.cumulativeFeeFactor.sub(startPool.cumulativeFeeFactor),             startPool.cumulativeRewardFactor         )     );      cStake = MathUtils.percOf(_stake, endPool.cumulativeRewardFactor, startPool.cumulativeRewardFactor);      return (cStake, cFees); }  /**  * @notice Return the pending stake and fees for a delegator  * @param _delegator Address of a delegator  * @param _endRound The last round to claim earnings for when calculating the pending stake and fees  * @return (stake, fees) where stake is the delegator's pending stake and fees is the delegator's pending fees  */ function pendingStakeAndFees(address _delegator, uint256 _endRound)     internal     view     returns (uint256 stake, uint256 fees) {     Delegator storage del = delegators[_delegator];     Transcoder storage t = transcoders[del.delegateAddress];      fees = del.fees;     stake = del.bondedAmount;      uint256 startRound = del.lastClaimRound.add(1);     address delegateAddr = del.delegateAddress;     bool isTranscoder = _delegator == delegateAddr;      uint256 lip36Round = roundsManager().lipUpgradeRound(36);     while (startRound &lt;= _endRound &amp;&amp; startRound &lt;= lip36Round) {         EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[startRound];          // If earningsPool.hasTranscoderRewardFeePool is not set during lip36Round then the transcoder did not call         // reward during lip36Round before the upgrade. In this case, if the transcoder calls reward in lip36Round         // the delegator can use the LIP-36 earnings claiming algorithm to claim for lip36Round         if (startRound == lip36Round &amp;&amp; !earningsPool.hasTranscoderRewardFeePool) {             break;         }          if (earningsPool.hasClaimableShares()) {             // Calculate and add fee pool share from this round             fees = fees.add(earningsPool.feePoolShare(stake, isTranscoder));             // Calculate new bonded amount with rewards from this round. Updated bonded amount used             // to calculate fee pool share in next round             stake = stake.add(earningsPool.rewardPoolShare(stake, isTranscoder));         }          startRound = startRound.add(1);     }      // If the transcoder called reward during lip36Round the upgrade, then startRound = lip36Round     // Otherwise, startRound = lip36Round + 1      // If the start round is greater than the end round, we've already claimed for the end round so we do not     // need to execute the LIP-36 earnings claiming algorithm. This could be the case if:     // - _endRound &lt; lip36Round i.e. we are not claiming through the lip36Round     // - _endRound == lip36Round AND startRound = lip36Round + 1 i.e we already claimed through the lip36Round     if (startRound &gt; _endRound) {         return (stake, fees);     }      // The LIP-36 earnings claiming algorithm uses the cumulative factors from the delegator's lastClaimRound i.e. startRound - 1     // and from the specified _endRound     (stake, fees) = delegatorCumulativeStakeAndFees(t, startRound.sub(1), _endRound, stake, fees);      if (isTranscoder) {         stake = stake.add(t.cumulativeRewards);         fees = fees.add(t.cumulativeFees);     }      return (stake, fees); }  /**  * @dev Increase the total stake for a delegate and updates its 'lastActiveStakeUpdateRound'  * @param _delegate The delegate to increase the stake for  * @param _amount The amount to increase the stake for '_delegate' by  */ function increaseTotalStake(     address _delegate,     uint256 _amount,     address _newPosPrev,     address _newPosNext ) internal {     if (isRegisteredTranscoder(_delegate)) {         uint256 currStake = transcoderTotalStake(_delegate);         uint256 newStake = currStake.add(_amount);         uint256 currRound = roundsManager().currentRound();         uint256 nextRound = currRound.add(1);          // If the transcoder is already in the active set update its stake and return         if (transcoderPoolV2.contains(_delegate)) {             transcoderPoolV2.updateKey(_delegate, newStake, _newPosPrev, _newPosNext);             nextRoundTotalActiveStake = nextRoundTotalActiveStake.add(_amount);             Transcoder storage t = transcoders[_delegate];              // currStake (the transcoder's delegatedAmount field) will reflect the transcoder's stake from lastActiveStakeUpdateRound             // because it is updated every time lastActiveStakeUpdateRound is updated             // The current active total stake is set to currStake to ensure that the value can be used in updateTranscoderWithRewards()             // and updateTranscoderWithFees() when lastActiveStakeUpdateRound &gt; currentRound             if (t.lastActiveStakeUpdateRound &lt; currRound) {                 t.earningsPoolPerRound[currRound].setStake(currStake);             }              t.earningsPoolPerRound[nextRound].setStake(newStake);             t.lastActiveStakeUpdateRound = nextRound;         } else {             // Check if the transcoder is eligible to join the active set in the update round             tryToJoinActiveSet(_delegate, newStake, nextRound, _newPosPrev, _newPosNext);         }     }      // Increase delegate's delegated amount     delegators[_delegate].delegatedAmount = delegators[_delegate].delegatedAmount.add(_amount); }  /**  * @dev Decrease the total stake for a delegate and updates its 'lastActiveStakeUpdateRound'  * @param _delegate The transcoder to decrease the stake for  * @param _amount The amount to decrease the stake for '_delegate' by  */ function decreaseTotalStake(     address _delegate,     uint256 _amount,     address _newPosPrev,     address _newPosNext ) internal {     if (transcoderPoolV2.contains(_delegate)) {         uint256 currStake = transcoderTotalStake(_delegate);         uint256 newStake = currStake.sub(_amount);         uint256 currRound = roundsManager().currentRound();         uint256 nextRound = currRound.add(1);          transcoderPoolV2.updateKey(_delegate, newStake, _newPosPrev, _newPosNext);         nextRoundTotalActiveStake = nextRoundTotalActiveStake.sub(_amount);         Transcoder storage t = transcoders[_delegate];          // currStake (the transcoder's delegatedAmount field) will reflect the transcoder's stake from lastActiveStakeUpdateRound         // because it is updated every time lastActiveStakeUpdateRound is updated         // The current active total stake is set to currStake to ensure that the value can be used in updateTranscoderWithRewards()         // and updateTranscoderWithFees() when lastActiveStakeUpdateRound &gt; currentRound         if (t.lastActiveStakeUpdateRound &lt; currRound) {             t.earningsPoolPerRound[currRound].setStake(currStake);         }          t.lastActiveStakeUpdateRound = nextRound;         t.earningsPoolPerRound[nextRound].setStake(newStake);     }      // Decrease old delegate's delegated amount     delegators[_delegate].delegatedAmount = delegators[_delegate].delegatedAmount.sub(_amount); }  /**  * @dev Tries to add a transcoder to active transcoder pool, evicts the active transcoder with the lowest stake if the pool is full  * @param _transcoder The transcoder to insert into the transcoder pool  * @param _totalStake The total stake for '_transcoder'  * @param _activationRound The round in which the transcoder should become active  */ function tryToJoinActiveSet(     address _transcoder,     uint256 _totalStake,     uint256 _activationRound,     address _newPosPrev,     address _newPosNext ) internal {     uint256 pendingNextRoundTotalActiveStake = nextRoundTotalActiveStake;      if (transcoderPoolV2.isFull()) {         address lastTranscoder = transcoderPoolV2.getLast();         uint256 lastStake = transcoderTotalStake(lastTranscoder);          // If the pool is full and the transcoder has less stake than the least stake transcoder in the pool         // then the transcoder is unable to join the active set for the next round         if (_totalStake &lt;= lastStake) {             return;         }          // Evict the least stake transcoder from the active set for the next round         // Not zeroing 'Transcoder.lastActiveStakeUpdateRound' saves gas (5k when transcoder is evicted and 20k when transcoder is reinserted)         // There should be no side-effects as long as the value is properly updated on stake updates         // Not zeroing the stake on the current round's 'EarningsPool' saves gas and should have no side effects as long as         // 'EarningsPool.setStake()' is called whenever a transcoder becomes active again.         transcoderPoolV2.remove(lastTranscoder);         transcoders[lastTranscoder].deactivationRound = _activationRound;         pendingNextRoundTotalActiveStake = pendingNextRoundTotalActiveStake.sub(lastStake);          emit TranscoderDeactivated(lastTranscoder, _activationRound);     }      transcoderPoolV2.insert(_transcoder, _totalStake, _newPosPrev, _newPosNext);     pendingNextRoundTotalActiveStake = pendingNextRoundTotalActiveStake.add(_totalStake);     Transcoder storage t = transcoders[_transcoder];     t.lastActiveStakeUpdateRound = _activationRound;     t.activationRound = _activationRound;     t.deactivationRound = MAX_FUTURE_ROUND;     t.earningsPoolPerRound[_activationRound].setStake(_totalStake);     nextRoundTotalActiveStake = pendingNextRoundTotalActiveStake;     emit TranscoderActivated(_transcoder, _activationRound); }  /**  * @dev Remove a transcoder from the pool and deactivate it  */ function resignTranscoder(address _transcoder) internal {     // Not zeroing 'Transcoder.lastActiveStakeUpdateRound' saves gas (5k when transcoder is evicted and 20k when transcoder is reinserted)     // There should be no side-effects as long as the value is properly updated on stake updates     // Not zeroing the stake on the current round's 'EarningsPool' saves gas and should have no side effects as long as     // 'EarningsPool.setStake()' is called whenever a transcoder becomes active again.     transcoderPoolV2.remove(_transcoder);     nextRoundTotalActiveStake = nextRoundTotalActiveStake.sub(transcoderTotalStake(_transcoder));     uint256 deactivationRound = roundsManager().currentRound().add(1);     transcoders[_transcoder].deactivationRound = deactivationRound;     emit TranscoderDeactivated(_transcoder, deactivationRound); }  /**  * @dev Update a transcoder with rewards and update the transcoder pool with an optional list hint if needed.  * See SortedDoublyLL.sol for details on list hints  * @param _transcoder Address of transcoder  * @param _rewards Amount of rewards  * @param _round Round that transcoder is updated  * @param _newPosPrev Address of previous transcoder in pool if the transcoder is in the pool  * @param _newPosNext Address of next transcoder in pool if the transcoder is in the pool  */ function updateTranscoderWithRewards(     address _transcoder,     uint256 _rewards,     uint256 _round,     address _newPosPrev,     address _newPosNext ) internal {     Transcoder storage t = transcoders[_transcoder];     EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[_round];     EarningsPool.Data storage prevEarningsPool = t.earningsPoolPerRound[t.lastRewardRound];      t.activeCumulativeRewards = t.cumulativeRewards;      uint256 transcoderCommissionRewards = MathUtils.percOf(_rewards, earningsPool.transcoderRewardCut);     uint256 delegatorsRewards = _rewards.sub(transcoderCommissionRewards);     // Calculate the rewards earned by the transcoder's earned rewards     uint256 transcoderRewardStakeRewards = MathUtils.percOf(         delegatorsRewards,         t.activeCumulativeRewards,         earningsPool.totalStake     );     // Track rewards earned by the transcoder based on its earned rewards and rewardCut     t.cumulativeRewards = t.cumulativeRewards.add(transcoderRewardStakeRewards).add(transcoderCommissionRewards);     // Update cumulative reward factor with new rewards     // The cumulativeRewardFactor is used to calculate rewards for all delegators including the transcoder (self-delegated)     // Note that delegatorsRewards includes transcoderRewardStakeRewards, but no delegator will claim that amount using     // the earnings claiming algorithm and instead that amount is accounted for in the transcoder's cumulativeRewards field     earningsPool.updateCumulativeRewardFactor(prevEarningsPool, delegatorsRewards);     // Update transcoder's total stake with rewards     increaseTotalStake(_transcoder, _rewards, _newPosPrev, _newPosNext); }  /**  * @dev Update a delegator with token pools shares from its lastClaimRound through a given round  * @param _delegator Delegator address  * @param _endRound The last round for which to update a delegator's stake with earnings pool shares  * @param _lastClaimRound The round for which a delegator has last claimed earnings  */ function updateDelegatorWithEarnings(     address _delegator,     uint256 _endRound,     uint256 _lastClaimRound ) internal {     Delegator storage del = delegators[_delegator];     uint256 startRound = _lastClaimRound.add(1);     uint256 currentBondedAmount = del.bondedAmount;     uint256 currentFees = del.fees;      uint256 lip36Round = roundsManager().lipUpgradeRound(36);      // Only will have earnings to claim if you have a delegate     // If not delegated, skip the earnings claim process     if (del.delegateAddress != address(0)) {         if (startRound &lt;= lip36Round) {             // Cannot claim earnings for more than maxEarningsClaimsRounds before LIP-36             // This is a number to cause transactions to fail early if             // we know they will require too much gas to loop through all the necessary rounds to claim earnings             // The user should instead manually invoke `claimEarnings` to split up the claiming process             // across multiple transactions             uint256 endLoopRound = _endRound &lt;= lip36Round ? _endRound : lip36Round;             require(                 endLoopRound.sub(_lastClaimRound) &lt;= maxEarningsClaimsRounds,                 ""too many rounds to claim through""             );         }          (currentBondedAmount, currentFees) = pendingStakeAndFees(_delegator, _endRound);          // Check whether the endEarningsPool is initialised         // If it is not initialised set it's cumulative factors so that they can be used when a delegator         // next claims earnings as the start cumulative factors (see delegatorCumulativeStakeAndFees())         Transcoder storage t = transcoders[del.delegateAddress];         EarningsPool.Data storage endEarningsPool = t.earningsPoolPerRound[_endRound];         if (endEarningsPool.cumulativeRewardFactor == 0) {             endEarningsPool.cumulativeRewardFactor = t                 .earningsPoolPerRound[t.lastRewardRound]                 .cumulativeRewardFactor;         }         if (endEarningsPool.cumulativeFeeFactor == 0) {             endEarningsPool.cumulativeFeeFactor = t.earningsPoolPerRound[t.lastFeeRound].cumulativeFeeFactor;         }          if (del.delegateAddress == _delegator) {             t.cumulativeFees = 0;             t.cumulativeRewards = 0;             // activeCumulativeRewards is not cleared here because the next reward() call will set it to cumulativeRewards         }     }      emit EarningsClaimed(         del.delegateAddress,         _delegator,         currentBondedAmount.sub(del.bondedAmount),         currentFees.sub(del.fees),         startRound,         _endRound     );      del.lastClaimRound = _endRound;     // Rewards are bonded by default     del.bondedAmount = currentBondedAmount;     del.fees = currentFees; }  /**  * @dev Update the state of a delegator and its delegate by processing a rebond using an unbonding lock and update the transcoder pool with an optional  * list hint if needed. See SortedDoublyLL.sol for details on list hints  * @param _delegator Address of delegator  * @param _unbondingLockId ID of unbonding lock to rebond with  * @param _newPosPrev Address of previous transcoder in pool if the delegate is already in or joins the pool  * @param _newPosNext Address of next transcoder in pool if the delegate is already in or joins the pool  */ function processRebond(     address _delegator,     uint256 _unbondingLockId,     address _newPosPrev,     address _newPosNext ) internal {     Delegator storage del = delegators[_delegator];     UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];      require(isValidUnbondingLock(_delegator, _unbondingLockId), ""invalid unbonding lock ID"");      uint256 amount = lock.amount;     // Increase delegator's bonded amount     del.bondedAmount = del.bondedAmount.add(amount);      // Delete lock     delete del.unbondingLocks[_unbondingLockId];      increaseTotalStake(del.delegateAddress, amount, _newPosPrev, _newPosNext);      emit Rebond(del.delegateAddress, _delegator, _unbondingLockId, amount); }  /**  * @dev Return LivepeerToken interface  * @return Livepeer token contract registered with Controller  */ function livepeerToken() internal view returns (ILivepeerToken) {     return ILivepeerToken(controller.getContract(keccak256(""LivepeerToken""))); }  /**  * @dev Return Minter interface  * @return Minter contract registered with Controller  */ function minter() internal view returns (IMinter) {     return IMinter(controller.getContract(keccak256(""Minter""))); }  /**  * @dev Return RoundsManager interface  * @return RoundsManager contract registered with Controller  */ function roundsManager() internal view returns (IRoundsManager) {     return IRoundsManager(controller.getContract(keccak256(""RoundsManager""))); }  function _onlyTicketBroker() internal view {     require(msg.sender == controller.getContract(keccak256(""TicketBroker"")), ""caller must be TicketBroker""); }  function _onlyRoundsManager() internal view {     require(msg.sender == controller.getContract(keccak256(""RoundsManager"")), ""caller must be RoundsManager""); }  function _onlyVerifier() internal view {     require(msg.sender == controller.getContract(keccak256(""Verifier"")), ""caller must be Verifier""); }  function _currentRoundInitialized() internal view {     require(roundsManager().currentRoundInitialized(), ""current round is not initialized""); }  function _autoClaimEarnings() internal {     uint256 currentRound = roundsManager().currentRound();     uint256 lastClaimRound = delegators[msg.sender].lastClaimRound;     if (lastClaimRound &lt; currentRound) {         updateDelegatorWithEarnings(msg.sender, currentRound, lastClaimRound);     } }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-10-08 17:13:42 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: pragma solidity 0.5.11;

import ""../../ManagerProxyTarget.sol"";
import ""../IBondingManager.sol"";
import ""../../libraries/SortedDoublyLL.sol"";
import ""../../libraries/MathUtils.sol"";
import ""../libraries/EarningsPool.sol"";
import ""../libraries/EarningsPoolLIP36.sol"";
import ""../../token/ILivepeerToken.sol"";
import ""../../token/IMinter.sol"";
import ""../../rounds/IRoundsManager.sol"";
import ""../../snapshots/IMerkleSnapshot.sol"";

import ""openzeppelin-solidity/contracts/math/SafeMath.sol"";

/**
 * @title BondingManager
 * @notice Manages bonding, transcoder and rewards/fee accounting related operations of the Livepeer protocol
 */
contract BondingManagerZeroStartFactorsBug is ManagerProxyTarget, IBondingManager {
    using SafeMath for uint256;
    using SortedDoublyLL for SortedDoublyLL.Data;
    using EarningsPool for EarningsPool.Data;
    using EarningsPoolLIP36 for EarningsPool.Data;

    // Constants
    // Occurances are replaced at compile time
    // and computed to a single value if possible by the optimizer
    uint256 constant MAX_FUTURE_ROUND = 2**256 - 1;

    // Time between unbonding and possible withdrawl in rounds
    uint64 public unbondingPeriod;
    // DEPRECATED - DO NOT USE
    uint256 public numActiveTranscodersDEPRECATED;
    // Max number of rounds that a caller can claim earnings for at once
    uint256 public maxEarningsClaimsRounds;

    // Represents a transcoder's current state
    struct Transcoder {
        uint256 lastRewardRound; // Last round that the transcoder called reward
        uint256 rewardCut; // % of reward paid to transcoder by a delegator
        uint256 feeShare; // % of fees paid to delegators by transcoder
        uint256 pricePerSegmentDEPRECATED; // DEPRECATED - DO NOT USE
        uint256 pendingRewardCutDEPRECATED; // DEPRECATED - DO NOT USE
        uint256 pendingFeeShareDEPRECATED; // DEPRECATED - DO NOT USE
        uint256 pendingPricePerSegmentDEPRECATED; // DEPRECATED - DO NOT USE
        mapping(uint256 => EarningsPool.Data) earningsPoolPerRound; // Mapping of round => earnings pool for the round
        uint256 lastActiveStakeUpdateRound; // Round for which the stake was last updated while the transcoder is active
        uint256 activationRound; // Round in which the transcoder became active - 0 if inactive
        uint256 deactivationRound; // Round in which the transcoder will become inactive
        uint256 activeCumulativeRewards; // The transcoder's cumulative rewards that are active in the current round
        uint256 cumulativeRewards; // The transcoder's cumulative rewards (earned via the its active staked rewards and its reward cut).
        uint256 cumulativeFees; // The transcoder's cumulative fees (earned via the its active staked rewards and its fee share)
        uint256 lastFeeRound; // Latest round in which the transcoder received fees
    }

    // The various states a transcoder can be in
    enum TranscoderStatus {
        NotRegistered,
        Registered
    }

    // Represents a delegator's current state
    struct Delegator {
        uint256 bondedAmount; // The amount of bonded tokens
        uint256 fees; // The amount of fees collected
        address delegateAddress; // The address delegated to
        uint256 delegatedAmount; // The amount of tokens delegated to the delegator
        uint256 startRound; // The round the delegator transitions to bonded phase and is delegated to someone
        uint256 withdrawRoundDEPRECATED; // DEPRECATED - DO NOT USE
        uint256 lastClaimRound; // The last round during which the delegator claimed its earnings
        uint256 nextUnbondingLockId; // ID for the next unbonding lock created
        mapping(uint256 => UnbondingLock) unbondingLocks; // Mapping of unbonding lock ID => unbonding lock
    }

    // The various states a delegator can be in
    enum DelegatorStatus {
        Pending,
        Bonded,
        Unbonded
    }

    // Represents an amount of tokens that are being unbonded
    struct UnbondingLock {
        uint256 amount; // Amount of tokens being unbonded
        uint256 withdrawRound; // Round at which unbonding period is over and tokens can be withdrawn
    }

    // Keep track of the known transcoders and delegators
    mapping(address => Delegator) private delegators;
    mapping(address => Transcoder) private transcoders;

    // DEPRECATED - DO NOT USE
    // The function getTotalBonded() no longer uses this variable
    // and instead calculates the total bonded value separately
    uint256 private totalBondedDEPRECATED;

    // DEPRECATED - DO NOT USE
    SortedDoublyLL.Data private transcoderPoolDEPRECATED;

    // DEPRECATED - DO NOT USE
    struct ActiveTranscoderSetDEPRECATED {
        address[] transcoders;
        mapping(address => bool) isActive;
        uint256 totalStake;
    }

    // DEPRECATED - DO NOT USE
    mapping(uint256 => ActiveTranscoderSetDEPRECATED) public activeTranscoderSetDEPRECATED;

    // The total active stake (sum of the stake of active set members) for the current round
    uint256 public currentRoundTotalActiveStake;
    // The total active stake (sum of the stake of active set members) for the next round
    uint256 public nextRoundTotalActiveStake;

    // The transcoder pool is used to keep track of the transcoders that are eligible for activation.
    // The pool keeps track of the pending active set in round N and the start of round N + 1 transcoders
    // in the pool are locked into the active set for round N + 1
    SortedDoublyLL.Data private transcoderPoolV2;

    // Check if sender is TicketBroker
    modifier onlyTicketBroker() {
        _onlyTicketBroker();
        _;
    }

    // Check if sender is RoundsManager
    modifier onlyRoundsManager() {
        _onlyRoundsManager();
        _;
    }

    // Check if sender is Verifier
    modifier onlyVerifier() {
        _onlyVerifier();
        _;
    }

    // Check if current round is initialized
    modifier currentRoundInitialized() {
        _currentRoundInitialized();
        _;
    }

    // Automatically claim earnings from lastClaimRound through the current round
    modifier autoClaimEarnings() {
        _autoClaimEarnings();
        _;
    }

    /**
     * @notice BondingManager constructor. Only invokes constructor of base Manager contract with provided Controller address
     * @dev This constructor will not initialize any state variables besides `controller`. The following setter functions
     * should be used to initialize state variables post-deployment:
     * - setUnbondingPeriod()
     * - setNumActiveTranscoders()
     * - setMaxEarningsClaimsRounds()
     * @param _controller Address of Controller that this contract will be registered with
     */
    constructor(address _controller) public Manager(_controller) {}

    /**
     * @notice Set unbonding period. Only callable by Controller owner
     * @param _unbondingPeriod Rounds between unbonding and possible withdrawal
     */
    function setUnbondingPeriod(uint64 _unbondingPeriod) external onlyControllerOwner {
        unbondingPeriod = _unbondingPeriod;

        emit ParameterUpdate(""unbondingPeriod"");
    }

    /**
     * @notice Set maximum number of active transcoders. Only callable by Controller owner
     * @param _numActiveTranscoders Number of active transcoders
     */
    function setNumActiveTranscoders(uint256 _numActiveTranscoders) external onlyControllerOwner {
        transcoderPoolV2.setMaxSize(_numActiveTranscoders);

        emit ParameterUpdate(""numActiveTranscoders"");
    }

    /**
     * @notice Set max number of rounds a caller can claim earnings for at once. Only callable by Controller owner
     * @param _maxEarningsClaimsRounds Max number of rounds a caller can claim earnings for at once
     */
    function setMaxEarningsClaimsRounds(uint256 _maxEarningsClaimsRounds) external onlyControllerOwner {
        maxEarningsClaimsRounds = _maxEarningsClaimsRounds;

        emit ParameterUpdate(""maxEarningsClaimsRounds"");
    }

    /**
     * @notice Sets commission rates as a transcoder and if the caller is not in the transcoder pool tries to add it
     * @dev Percentages are represented as numerators of fractions over MathUtils.PERC_DIVISOR
     * @param _rewardCut % of reward paid to transcoder by a delegator
     * @param _feeShare % of fees paid to delegators by a transcoder
     */
    function transcoder(uint256 _rewardCut, uint256 _feeShare) external {
        transcoderWithHint(_rewardCut, _feeShare, address(0), address(0));
    }

    /**
     * @notice Delegate stake towards a specific address
     * @param _amount The amount of tokens to stake
     * @param _to The address of the transcoder to stake towards
     */
    function bond(uint256 _amount, address _to) external {
        bondWithHint(_amount, _to, address(0), address(0), address(0), address(0));
    }

    /**
     * @notice Unbond an amount of the delegator's bonded stake
     * @param _amount Amount of tokens to unbond
     */
    function unbond(uint256 _amount) external {
        unbondWithHint(_amount, address(0), address(0));
    }

    /**
     * @notice Rebond tokens for an unbonding lock to a delegator's current delegate while a delegator is in the Bonded or Pending status
     * @param _unbondingLockId ID of unbonding lock to rebond with
     */
    function rebond(uint256 _unbondingLockId) external {
        rebondWithHint(_unbondingLockId, address(0), address(0));
    }

    /**
     * @notice Rebond tokens for an unbonding lock to a delegate while a delegator is in the Unbonded status
     * @param _to Address of delegate
     * @param _unbondingLockId ID of unbonding lock to rebond with
     */
    function rebondFromUnbonded(address _to, uint256 _unbondingLockId) external {
        rebondFromUnbondedWithHint(_to, _unbondingLockId, address(0), address(0));
    }

    /**
     * @notice Withdraws tokens for an unbonding lock that has existed through an unbonding period
     * @param _unbondingLockId ID of unbonding lock to withdraw with
     */
    function withdrawStake(uint256 _unbondingLockId) external whenSystemNotPaused currentRoundInitialized {
        Delegator storage del = delegators[msg.sender];
        UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];

        require(isValidUnbondingLock(msg.sender, _unbondingLockId), ""invalid unbonding lock ID"");
        require(
            lock.withdrawRound <= roundsManager().currentRound(),
            ""withdraw round must be before or equal to the current round""
        );

        uint256 amount = lock.amount;
        uint256 withdrawRound = lock.withdrawRound;
        // Delete unbonding lock
        delete del.unbondingLocks[_unbondingLockId];

        // Tell Minter to transfer stake (LPT) to the delegator
        minter().trustedTransferTokens(msg.sender, amount);

        emit WithdrawStake(msg.sender, _unbondingLockId, amount, withdrawRound);
    }

    /**
     * @notice Withdraws fees to the caller
     */
    function withdrawFees() external whenSystemNotPaused currentRoundInitialized autoClaimEarnings {
        uint256 fees = delegators[msg.sender].fees;
        require(fees > 0, ""no fees to withdraw"");
        delegators[msg.sender].fees = 0;

        // Tell Minter to transfer fees (ETH) to the delegator
        minter().trustedWithdrawETH(msg.sender, fees);

        emit WithdrawFees(msg.sender);
    }

    /**
     * @notice Mint token rewards for an active transcoder and its delegators
     */
    function reward() external {
        rewardWithHint(address(0), address(0));
    }

    /**
     * @notice Update transcoder's fee pool. Only callable by the TicketBroker
     * @param _transcoder Transcoder address
     * @param _fees Fees to be added to the fee pool
     */
    function updateTranscoderWithFees(
        address _transcoder,
        uint256 _fees,
        uint256 _round
    ) external whenSystemNotPaused onlyTicketBroker {
        // Silence unused param compiler warning
        _round;

        require(isRegisteredTranscoder(_transcoder), ""transcoder must be registered"");

        uint256 currentRound = roundsManager().currentRound();

        Transcoder storage t = transcoders[_transcoder];

        uint256 lastRewardRound = t.lastRewardRound;
        uint256 activeCumulativeRewards = t.activeCumulativeRewards;

        // LIP-36: Add fees for the current round instead of '_round'
        // https://github.com/livepeer/LIPs/issues/35#issuecomment-673659199
        EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[currentRound];
        EarningsPool.Data memory prevEarningsPool = latestCumulativeFactorsPool(t, currentRound.sub(1));

        // if transcoder hasn't called 'reward()' for '_round' its 'transcoderFeeShare', 'transcoderRewardCut' and 'totalStake'
        // on the 'EarningsPool' for '_round' would not be initialized and the fee distribution wouldn't happen as expected
        // for cumulative fee calculation this would result in division by zero.
        if (currentRound > lastRewardRound) {
            earningsPool.setCommission(t.rewardCut, t.feeShare);

            uint256 lastUpdateRound = t.lastActiveStakeUpdateRound;
            if (lastUpdateRound < currentRound) {
                earningsPool.setStake(t.earningsPoolPerRound[lastUpdateRound].totalStake);
            }

            // If reward() has not been called yet in the current round, then the transcoder's activeCumulativeRewards has not
            // yet been set in for the round. When the transcoder calls reward() its activeCumulativeRewards will be set to its
            // current cumulativeRewards. So, we can just use the transcoder's cumulativeRewards here because this will become
            // the transcoder's activeCumulativeRewards if it calls reward() later on in the current round
            activeCumulativeRewards = t.cumulativeRewards;
        }

        uint256 totalStake = earningsPool.totalStake;
        if (prevEarningsPool.cumulativeRewardFactor == 0 && lastRewardRound == currentRound) {
            // if transcoder called reward for 'currentRound' but not for 'currentRound - 1' (missed reward call)
            // retroactively calculate what its cumulativeRewardFactor would have been for 'currentRound - 1' (cfr. previous lastRewardRound for transcoder)
            // based on rewards for currentRound
            IMinter mtr = minter();
            uint256 rewards = MathUtils.percOf(
                mtr.currentMintableTokens().add(mtr.currentMintedTokens()),
                totalStake,
                currentRoundTotalActiveStake
            );
            uint256 transcoderCommissionRewards = MathUtils.percOf(rewards, earningsPool.transcoderRewardCut);
            uint256 delegatorsRewards = rewards.sub(transcoderCommissionRewards);

            prevEarningsPool.cumulativeRewardFactor = MathUtils.percOf(
                earningsPool.cumulativeRewardFactor,
                totalStake,
                delegatorsRewards.add(totalStake)
            );
        }

        uint256 delegatorsFees = MathUtils.percOf(_fees, earningsPool.transcoderFeeShare);
        uint256 transcoderCommissionFees = _fees.sub(delegatorsFees);
        // Calculate the fees earned by the transcoder's earned rewards
        uint256 transcoderRewardStakeFees = MathUtils.percOf(delegatorsFees, activeCumulativeRewards, totalStake);
        // Track fees earned by the transcoder based on its earned rewards and feeShare
        t.cumulativeFees = t.cumulativeFees.add(transcoderRewardStakeFees).add(transcoderCommissionFees);
        // Update cumulative fee factor with new fees
        // The cumulativeFeeFactor is used to calculate fees for all delegators including the transcoder (self-delegated)
        // Note that delegatorsFees includes transcoderRewardStakeFees, but no delegator will claim that amount using
        // the earnings claiming algorithm and instead that amount is accounted for in the transcoder's cumulativeFees field
        earningsPool.updateCumulativeFeeFactor(prevEarningsPool, delegatorsFees);

        t.lastFeeRound = currentRound;
    }

    /**
     * @notice Slash a transcoder. Only callable by the Verifier
     * @param _transcoder Transcoder address
     * @param _finder Finder that proved a transcoder violated a slashing condition. Null address if there is no finder
     * @param _slashAmount Percentage of transcoder bond to be slashed
     * @param _finderFee Percentage of penalty awarded to finder. Zero if there is no finder
     */
    function slashTranscoder(
        address _transcoder,
        address _finder,
        uint256 _slashAmount,
        uint256 _finderFee
    ) external whenSystemNotPaused onlyVerifier {
        Delegator storage del = delegators[_transcoder];

        if (del.bondedAmount > 0) {
            uint256 penalty = MathUtils.percOf(delegators[_transcoder].bondedAmount, _slashAmount);

            // If active transcoder, resign it
            if (transcoderPoolV2.contains(_transcoder)) {
                resignTranscoder(_transcoder);
            }

            // Decrease bonded stake
            del.bondedAmount = del.bondedAmount.sub(penalty);

            // If still bonded decrease delegate's delegated amount
            if (delegatorStatus(_transcoder) == DelegatorStatus.Bonded) {
                delegators[del.delegateAddress].delegatedAmount = delegators[del.delegateAddress].delegatedAmount.sub(
                    penalty
                );
            }

            // Account for penalty
            uint256 burnAmount = penalty;

            // Award finder fee if there is a finder address
            if (_finder != address(0)) {
                uint256 finderAmount = MathUtils.percOf(penalty, _finderFee);
                minter().trustedTransferTokens(_finder, finderAmount);

                // Minter burns the slashed funds - finder reward
                minter().trustedBurnTokens(burnAmount.sub(finderAmount));

                emit TranscoderSlashed(_transcoder, _finder, penalty, finderAmount);
            } else {
                // Minter burns the slashed funds
                minter().trustedBurnTokens(burnAmount);

                emit TranscoderSlashed(_transcoder, address(0), penalty, 0);
            }
        } else {
            emit TranscoderSlashed(_transcoder, _finder, 0, 0);
        }
    }

    /**
     * @notice Claim token pools shares for a delegator from its lastClaimRound through the end round
     * @param _endRound The last round for which to claim token pools shares for a delegator
     */
    function claimEarnings(uint256 _endRound) external whenSystemNotPaused currentRoundInitialized {
        uint256 lastClaimRound = delegators[msg.sender].lastClaimRound;
        require(lastClaimRound < _endRound, ""end round must be after last claim round"");
        require(_endRound <= roundsManager().currentRound(), ""end round must be before or equal to current round"");

        updateDelegatorWithEarnings(msg.sender, _endRound, lastClaimRound);
    }

    /**
     * @notice Claim earnings for a delegator based on the snapshot taken in LIP-52
     * @dev https://github.com/livepeer/LIPs/blob/master/LIPs/LIP-52.md
     * @param _pendingStake the amount of pending stake for the delegator (current stake + pending rewards)
     * @param _pendingFees the amount of pending fees for the delegator (current fees + pending fees)
     * @param _earningsProof array of keccak256 sibling hashes on the branch of the leaf for the delegator up to the root
     * @param _data (optional) raw transaction data to be executed on behalf of msg.sender after claiming snapshot earnings
     */
    function claimSnapshotEarnings(
        uint256 _pendingStake,
        uint256 _pendingFees,
        bytes32[] calldata _earningsProof,
        bytes calldata _data
    ) external whenSystemNotPaused currentRoundInitialized {
        Delegator storage del = delegators[msg.sender];

        uint256 lip52Round = roundsManager().lipUpgradeRound(52);

        uint256 lastClaimRound = del.lastClaimRound;

        require(lastClaimRound < lip52Round, ""Already claimed for LIP-52"");

        bytes32 leaf = keccak256(abi.encode(msg.sender, _pendingStake, _pendingFees));

        require(
            IMerkleSnapshot(controller.getContract(keccak256(""MerkleSnapshot""))).verify(
                keccak256(""LIP-52""),
                _earningsProof,
                leaf
            ),
            ""Merkle proof is invalid""
        );

        emit EarningsClaimed(
            del.delegateAddress,
            msg.sender,
            _pendingStake.sub(del.bondedAmount),
            _pendingFees.sub(del.fees),
            lastClaimRound.add(1),
            lip52Round
        );

        del.lastClaimRound = lip52Round;
        del.bondedAmount = _pendingStake;
        del.fees = _pendingFees;

        // allow for execution of subsequent claiming or staking operations
        if (_data.length > 0) {
            (bool success, bytes memory returnData) = address(this).delegatecall(_data);
            require(success, string(returnData));
        }
    }

    /**
     * @notice Called during round initialization to set the total active stake for the round. Only callable by the RoundsManager
     */
    function setCurrentRoundTotalActiveStake() external onlyRoundsManager {
        currentRoundTotalActiveStake = nextRoundTotalActiveStake;
    }

    /**
     * @notice Sets commission rates as a transcoder and if the caller is not in the transcoder pool tries to add it using an optional list hint
     * @dev Percentages are represented as numerators of fractions over MathUtils.PERC_DIVISOR. If the caller is going to be added to the pool, the
     * caller can provide an optional hint for the insertion position in the pool via the `_newPosPrev` and `_newPosNext` params. A linear search will
     * be executed starting at the hint to find the correct position - in the best case, the hint is the correct position so no search is executed.
     * See SortedDoublyLL.sol for details on list hints
     * @param _rewardCut % of reward paid to transcoder by a delegator
     * @param _feeShare % of fees paid to delegators by a transcoder
     * @param _newPosPrev Address of previous transcoder in pool if the caller joins the pool
     * @param _newPosNext Address of next transcoder in pool if the caller joins the pool
     */
    function transcoderWithHint(
        uint256 _rewardCut,
        uint256 _feeShare,
        address _newPosPrev,
        address _newPosNext
    ) public whenSystemNotPaused currentRoundInitialized {
        require(!roundsManager().currentRoundLocked(), ""can't update transcoder params, current round is locked"");
        require(MathUtils.validPerc(_rewardCut), ""invalid rewardCut percentage"");
        require(MathUtils.validPerc(_feeShare), ""invalid feeShare percentage"");
        require(isRegisteredTranscoder(msg.sender), ""transcoder must be registered"");

        Transcoder storage t = transcoders[msg.sender];
        uint256 currentRound = roundsManager().currentRound();

        require(
            !isActiveTranscoder(msg.sender) || t.lastRewardRound == currentRound,
            ""caller can't be active or must have already called reward for the current round""
        );

        t.rewardCut = _rewardCut;
        t.feeShare = _feeShare;

        if (!transcoderPoolV2.contains(msg.sender)) {
            tryToJoinActiveSet(
                msg.sender,
                delegators[msg.sender].delegatedAmount,
                currentRound.add(1),
                _newPosPrev,
                _newPosNext
            );
        }

        emit TranscoderUpdate(msg.sender, _rewardCut, _feeShare);
    }

    /**
     * @notice Delegate stake towards a specific address and updates the transcoder pool using optional list hints if needed
     * @dev If the caller is decreasing the stake of its old delegate in the transcoder pool, the caller can provide an optional hint
     * for the insertion position of the old delegate via the `_oldDelegateNewPosPrev` and `_oldDelegateNewPosNext` params.
     * If the caller is delegating to a delegate that is in the transcoder pool, the caller can provide an optional hint for the
     * insertion position of the delegate via the `_currDelegateNewPosPrev` and `_currDelegateNewPosNext` params.
     * In both cases, a linear search will be executed starting at the hint to find the correct position. In the best case, the hint
     * is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints
     * @param _amount The amount of tokens to stake.
     * @param _to The address of the transcoder to stake towards
     * @param _oldDelegateNewPosPrev The address of the previous transcoder in the pool for the old delegate
     * @param _oldDelegateNewPosNext The address of the next transcoder in the pool for the old delegate
     * @param _currDelegateNewPosPrev The address of the previous transcoder in the pool for the current delegate
     * @param _currDelegateNewPosNext The address of the next transcoder in the pool for the current delegate
     */
    function bondWithHint(
        uint256 _amount,
        address _to,
        address _oldDelegateNewPosPrev,
        address _oldDelegateNewPosNext,
        address _currDelegateNewPosPrev,
        address _currDelegateNewPosNext
    ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {
        Delegator storage del = delegators[msg.sender];

        uint256 currentRound = roundsManager().currentRound();
        // Amount to delegate
        uint256 delegationAmount = _amount;
        // Current delegate
        address currentDelegate = del.delegateAddress;

        if (delegatorStatus(msg.sender) == DelegatorStatus.Unbonded) {
            // New delegate
            // Set start round
            // Don't set start round if delegator is in pending state because the start round would not change
            del.startRound = currentRound.add(1);
            // Unbonded state = no existing delegate and no bonded stake
            // Thus, delegation amount = provided amount
        } else if (currentDelegate != address(0) && currentDelegate != _to) {
            // A registered transcoder cannot delegate its bonded stake toward another address
            // because it can only be delegated toward itself
            // In the future, if delegation towards another registered transcoder as an already
            // registered transcoder becomes useful (i.e. for transitive delegation), this restriction
            // could be removed
            require(
                !isRegisteredTranscoder(msg.sender),
                ""registered transcoders can't delegate towards other addresses""
            );
            // Changing delegate
            // Set start round
            del.startRound = currentRound.add(1);
            // Update amount to delegate with previous delegation amount
            delegationAmount = delegationAmount.add(del.bondedAmount);

            decreaseTotalStake(currentDelegate, del.bondedAmount, _oldDelegateNewPosPrev, _oldDelegateNewPosNext);
        }

        // cannot delegate to someone without having bonded stake
        require(delegationAmount > 0, ""delegation amount must be greater than 0"");
        // Update delegate
        del.delegateAddress = _to;
        // Update bonded amount
        del.bondedAmount = del.bondedAmount.add(_amount);

        increaseTotalStake(_to, delegationAmount, _currDelegateNewPosPrev, _currDelegateNewPosNext);

        if (_amount > 0) {
            // Transfer the LPT to the Minter
            livepeerToken().transferFrom(msg.sender, address(minter()), _amount);
        }

        emit Bond(_to, currentDelegate, msg.sender, _amount, del.bondedAmount);
    }

    /**
     * @notice Unbond an amount of the delegator's bonded stake and updates the transcoder pool using an optional list hint if needed
     * @dev If the caller remains in the transcoder pool, the caller can provide an optional hint for its insertion position in the
     * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.
     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol details on list hints
     * @param _amount Amount of tokens to unbond
     * @param _newPosPrev Address of previous transcoder in pool if the caller remains in the pool
     * @param _newPosNext Address of next transcoder in pool if the caller remains in the pool
     */
    function unbondWithHint(
        uint256 _amount,
        address _newPosPrev,
        address _newPosNext
    ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {
        require(delegatorStatus(msg.sender) == DelegatorStatus.Bonded, ""caller must be bonded"");

        Delegator storage del = delegators[msg.sender];

        require(_amount > 0, ""unbond amount must be greater than 0"");
        require(_amount <= del.bondedAmount, ""amount is greater than bonded amount"");

        address currentDelegate = del.delegateAddress;
        uint256 currentRound = roundsManager().currentRound();
        uint256 withdrawRound = currentRound.add(unbondingPeriod);
        uint256 unbondingLockId = del.nextUnbondingLockId;

        // Create new unbonding lock
        del.unbondingLocks[unbondingLockId] = UnbondingLock({ amount: _amount, withdrawRound: withdrawRound });
        // Increment ID for next unbonding lock
        del.nextUnbondingLockId = unbondingLockId.add(1);
        // Decrease delegator's bonded amount
        del.bondedAmount = del.bondedAmount.sub(_amount);

        if (del.bondedAmount == 0) {
            // Delegator no longer delegated to anyone if it does not have a bonded amount
            del.delegateAddress = address(0);
            // Delegator does not have a start round if it is no longer delegated to anyone
            del.startRound = 0;

            if (transcoderPoolV2.contains(msg.sender)) {
                resignTranscoder(msg.sender);
            }
        }

        // If msg.sender was resigned this statement will only decrease delegators[currentDelegate].delegatedAmount
        decreaseTotalStake(currentDelegate, _amount, _newPosPrev, _newPosNext);

        emit Unbond(currentDelegate, msg.sender, unbondingLockId, _amount, withdrawRound);
    }

    /**
     * @notice Rebond tokens for an unbonding lock to a delegator's current delegate while a delegator is in the Bonded or Pending status and updates
     * the transcoder pool using an optional list hint if needed
     * @dev If the delegate is in the transcoder pool, the caller can provide an optional hint for the delegate's insertion position in the
     * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.
     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol details on list hints
     * @param _unbondingLockId ID of unbonding lock to rebond with
     * @param _newPosPrev Address of previous transcoder in pool if the delegate is in the pool
     * @param _newPosNext Address of next transcoder in pool if the delegate is in the pool
     */
    function rebondWithHint(
        uint256 _unbondingLockId,
        address _newPosPrev,
        address _newPosNext
    ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {
        require(delegatorStatus(msg.sender) != DelegatorStatus.Unbonded, ""caller must be bonded"");

        // Process rebond using unbonding lock
        processRebond(msg.sender, _unbondingLockId, _newPosPrev, _newPosNext);
    }

    /**
     * @notice Rebond tokens for an unbonding lock to a delegate while a delegator is in the Unbonded status and updates the transcoder pool using
     * an optional list hint if needed
     * @dev If the delegate joins the transcoder pool, the caller can provide an optional hint for the delegate's insertion position in the
     * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.
     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints
     * @param _to Address of delegate
     * @param _unbondingLockId ID of unbonding lock to rebond with
     * @param _newPosPrev Address of previous transcoder in pool if the delegate joins the pool
     * @param _newPosNext Address of next transcoder in pool if the delegate joins the pool
     */
    function rebondFromUnbondedWithHint(
        address _to,
        uint256 _unbondingLockId,
        address _newPosPrev,
        address _newPosNext
    ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {
        require(delegatorStatus(msg.sender) == DelegatorStatus.Unbonded, ""caller must be unbonded"");

        // Set delegator's start round and transition into Pending state
        delegators[msg.sender].startRound = roundsManager().currentRound().add(1);
        // Set delegator's delegate
        delegators[msg.sender].delegateAddress = _to;
        // Process rebond using unbonding lock
        processRebond(msg.sender, _unbondingLockId, _newPosPrev, _newPosNext);
    }

    /**
     * @notice Mint token rewards for an active transcoder and its delegators and update the transcoder pool using an optional list hint if needed
     * @dev If the caller is in the transcoder pool, the caller can provide an optional hint for its insertion position in the
     * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.
     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints
     * @param _newPosPrev Address of previous transcoder in pool if the caller is in the pool
     * @param _newPosNext Address of next transcoder in pool if the caller is in the pool
     */
    function rewardWithHint(address _newPosPrev, address _newPosNext)
        public
        whenSystemNotPaused
        currentRoundInitialized
    {
        uint256 currentRound = roundsManager().currentRound();

        require(isActiveTranscoder(msg.sender), ""caller must be an active transcoder"");
        require(
            transcoders[msg.sender].lastRewardRound != currentRound,
            ""caller has already called reward for the current round""
        );

        Transcoder storage t = transcoders[msg.sender];
        EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[currentRound];

        // Set last round that transcoder called reward
        earningsPool.setCommission(t.rewardCut, t.feeShare);

        // If transcoder didn't receive stake updates during the previous round and hasn't called reward for > 1 round
        // the 'totalStake' on its 'EarningsPool' for the current round wouldn't be initialized
        // Thus we sync the the transcoder's stake to when it was last updated
        // 'updateTrancoderWithRewards()' will set the update round to 'currentRound +1' so this synchronization shouldn't occur frequently
        uint256 lastUpdateRound = t.lastActiveStakeUpdateRound;
        if (lastUpdateRound < currentRound) {
            earningsPool.setStake(t.earningsPoolPerRound[lastUpdateRound].totalStake);
        }

        // Create reward based on active transcoder's stake relative to the total active stake
        // rewardTokens = (current mintable tokens for the round * active transcoder stake) / total active stake
        uint256 rewardTokens = minter().createReward(earningsPool.totalStake, currentRoundTotalActiveStake);

        updateTranscoderWithRewards(msg.sender, rewardTokens, currentRound, _newPosPrev, _newPosNext);

        // Set last round that transcoder called reward
        t.lastRewardRound = currentRound;

        emit Reward(msg.sender, rewardTokens);
    }

    /**
     * @notice Returns pending bonded stake for a delegator from its lastClaimRound through an end round
     * @param _delegator Address of delegator
     * @param _endRound The last round to compute pending stake from
     * @return Pending bonded stake for '_delegator' since last claiming rewards
     */
    function pendingStake(address _delegator, uint256 _endRound) public view returns (uint256) {
        (uint256 stake, ) = pendingStakeAndFees(_delegator, _endRound);
        return stake;
    }

    /**
     * @notice Returns pending fees for a delegator from its lastClaimRound through an end round
     * @param _delegator Address of delegator
     * @param _endRound The last round to compute pending fees from
     * @return Pending fees for '_delegator' since last claiming fees
     */
    function pendingFees(address _delegator, uint256 _endRound) public view returns (uint256) {
        (, uint256 fees) = pendingStakeAndFees(_delegator, _endRound);
        return fees;
    }

    /**
     * @notice Returns total bonded stake for a transcoder
     * @param _transcoder Address of transcoder
     * @return total bonded stake for a delegator
     */
    function transcoderTotalStake(address _transcoder) public view returns (uint256) {
        return delegators[_transcoder].delegatedAmount;
    }

    /**
     * @notice Computes transcoder status
     * @param _transcoder Address of transcoder
     * @return registered or not registered transcoder status
     */
    function transcoderStatus(address _transcoder) public view returns (TranscoderStatus) {
        if (isRegisteredTranscoder(_transcoder)) return TranscoderStatus.Registered;
        return TranscoderStatus.NotRegistered;
    }

    /**
     * @notice Computes delegator status
     * @param _delegator Address of delegator
     * @return bonded, unbonded or pending delegator status
     */
    function delegatorStatus(address _delegator) public view returns (DelegatorStatus) {
        Delegator storage del = delegators[_delegator];

        if (del.bondedAmount == 0) {
            // Delegator unbonded all its tokens
            return DelegatorStatus.Unbonded;
        } else if (del.startRound > roundsManager().currentRound()) {
            // Delegator round start is in the future
            return DelegatorStatus.Pending;
        } else {
            // Delegator round start is now or in the past
            // del.startRound != 0 here because if del.startRound = 0 then del.bondedAmount = 0 which
            // would trigger the first if clause
            return DelegatorStatus.Bonded;
        }
    }

    /**
     * @notice Return transcoder information
     * @param _transcoder Address of transcoder
     * @return lastRewardRound Trancoder's last reward round
     * @return rewardCut Transcoder's reward cut
     * @return feeShare Transcoder's fee share
     * @return lastActiveStakeUpdateRound Round in which transcoder's stake was last updated while active
     * @return activationRound Round in which transcoder became active
     * @return deactivationRound Round in which transcoder will no longer be active
     * @return activeCumulativeRewards Transcoder's cumulative rewards that are currently active
     * @return cumulativeRewards Transcoder's cumulative rewards (earned via its active staked rewards and its reward cut)
     * @return cumulativeFees Transcoder's cumulative fees (earned via its active staked rewards and its fee share)
     * @return lastFeeRound Latest round that the transcoder received fees
     */
    function getTranscoder(address _transcoder)
        public
        view
        returns (
            uint256 lastRewardRound,
            uint256 rewardCut,
            uint256 feeShare,
            uint256 lastActiveStakeUpdateRound,
            uint256 activationRound,
            uint256 deactivationRound,
            uint256 activeCumulativeRewards,
            uint256 cumulativeRewards,
            uint256 cumulativeFees,
            uint256 lastFeeRound
        )
    {
        Transcoder storage t = transcoders[_transcoder];

        lastRewardRound = t.lastRewardRound;
        rewardCut = t.rewardCut;
        feeShare = t.feeShare;
        lastActiveStakeUpdateRound = t.lastActiveStakeUpdateRound;
        activationRound = t.activationRound;
        deactivationRound = t.deactivationRound;
        activeCumulativeRewards = t.activeCumulativeRewards;
        cumulativeRewards = t.cumulativeRewards;
        cumulativeFees = t.cumulativeFees;
        lastFeeRound = t.lastFeeRound;
    }

    /**
     * @notice Return transcoder's earnings pool for a given round
     * @param _transcoder Address of transcoder
     * @param _round Round number
     * @return rewardPool Reward pool for delegators (only used before LIP-36)
     * @return feePool Fee pool for delegators (only used before LIP-36)
     * @return totalStake Transcoder's total stake in '_round'
     * @return claimableStake Remaining stake that can be used to claim from the pool (only used before LIP-36)
     * @return transcoderRewardCut Transcoder's reward cut for '_round'
     * @return transcoderFeeShare Transcoder's fee share for '_round'
     * @return transcoderRewardPool Transcoder's rewards for '_round' (only used before LIP-36)
     * @return transcoderFeePool Transcoder's fees for '_round' (only used before LIP-36)
     * @return hasTranscoderRewardFeePool True if there is a split reward/fee pool for the transcoder (only used before LIP-36)
     * @return cumulativeRewardFactor The cumulative reward factor for delegator rewards calculation (only used after LIP-36)
     * @return cumulativeFeeFactor The cumulative fee factor for delegator fees calculation (only used after LIP-36)
     */
    function getTranscoderEarningsPoolForRound(address _transcoder, uint256 _round)
        public
        view
        returns (
            uint256 rewardPool,
            uint256 feePool,
            uint256 totalStake,
            uint256 claimableStake,
            uint256 transcoderRewardCut,
            uint256 transcoderFeeShare,
            uint256 transcoderRewardPool,
            uint256 transcoderFeePool,
            bool hasTranscoderRewardFeePool,
            uint256 cumulativeRewardFactor,
            uint256 cumulativeFeeFactor
        )
    {
        EarningsPool.Data storage earningsPool = transcoders[_transcoder].earningsPoolPerRound[_round];

        rewardPool = earningsPool.rewardPool;
        feePool = earningsPool.feePool;
        totalStake = earningsPool.totalStake;
        claimableStake = earningsPool.claimableStake;
        transcoderRewardCut = earningsPool.transcoderRewardCut;
        transcoderFeeShare = earningsPool.transcoderFeeShare;
        transcoderRewardPool = earningsPool.transcoderRewardPool;
        transcoderFeePool = earningsPool.transcoderFeePool;
        hasTranscoderRewardFeePool = earningsPool.hasTranscoderRewardFeePool;
        cumulativeRewardFactor = earningsPool.cumulativeRewardFactor;
        cumulativeFeeFactor = earningsPool.cumulativeFeeFactor;
    }

    /**
     * @notice Return delegator info
     * @param _delegator Address of delegator
     * @return total amount bonded by '_delegator'
     * @return amount of fees collected by '_delegator'
     * @return address '_delegator' has bonded to
     * @return total amount delegated to '_delegator'
     * @return round in which bond for '_delegator' became effective
     * @return round for which '_delegator' has last claimed earnings
     * @return ID for the next unbonding lock created for '_delegator'
     */
    function getDelegator(address _delegator)
        public
        view
        returns (
            uint256 bondedAmount,
            uint256 fees,
            address delegateAddress,
            uint256 delegatedAmount,
            uint256 startRound,
            uint256 lastClaimRound,
            uint256 nextUnbondingLockId
        )
    {
        Delegator storage del = delegators[_delegator];

        bondedAmount = del.bondedAmount;
        fees = del.fees;
        delegateAddress = del.delegateAddress;
        delegatedAmount = del.delegatedAmount;
        startRound = del.startRound;
        lastClaimRound = del.lastClaimRound;
        nextUnbondingLockId = del.nextUnbondingLockId;
    }

    /**
     * @notice Return delegator's unbonding lock info
     * @param _delegator Address of delegator
     * @param _unbondingLockId ID of unbonding lock
     * @return amount of stake locked up by unbonding lock
     * @return round in which 'amount' becomes available for withdrawal
     */
    function getDelegatorUnbondingLock(address _delegator, uint256 _unbondingLockId)
        public
        view
        returns (uint256 amount, uint256 withdrawRound)
    {
        UnbondingLock storage lock = delegators[_delegator].unbondingLocks[_unbondingLockId];

        return (lock.amount, lock.withdrawRound);
    }

    /**
     * @notice Returns max size of transcoder pool
     * @return transcoder pool max size
     */
    function getTranscoderPoolMaxSize() public view returns (uint256) {
        return transcoderPoolV2.getMaxSize();
    }

    /**
     * @notice Returns size of transcoder pool
     * @return transcoder pool current size
     */
    function getTranscoderPoolSize() public view returns (uint256) {
        return transcoderPoolV2.getSize();
    }

    /**
     * @notice Returns transcoder with most stake in pool
     * @return address for transcoder with highest stake in transcoder pool
     */
    function getFirstTranscoderInPool() public view returns (address) {
        return transcoderPoolV2.getFirst();
    }

    /**
     * @notice Returns next transcoder in pool for a given transcoder
     * @param _transcoder Address of a transcoder in the pool
     * @return address for the transcoder after '_transcoder' in transcoder pool
     */
    function getNextTranscoderInPool(address _transcoder) public view returns (address) {
        return transcoderPoolV2.getNext(_transcoder);
    }

    /**
     * @notice Return total bonded tokens
     * @return total active stake for the current round
     */
    function getTotalBonded() public view returns (uint256) {
        return currentRoundTotalActiveStake;
    }

    /**
     * @notice Return whether a transcoder is active for the current round
     * @param _transcoder Transcoder address
     * @return true if transcoder is active
     */
    function isActiveTranscoder(address _transcoder) public view returns (bool) {
        Transcoder storage t = transcoders[_transcoder];
        uint256 currentRound = roundsManager().currentRound();
        return t.activationRound <= currentRound && currentRound < t.deactivationRound;
    }

    /**
     * @notice Return whether a transcoder is registered
     * @param _transcoder Transcoder address
     * @return true if transcoder is self-bonded
     */
    function isRegisteredTranscoder(address _transcoder) public view returns (bool) {
        Delegator storage d = delegators[_transcoder];
        return d.delegateAddress == _transcoder && d.bondedAmount > 0;
    }

    /**
     * @notice Return whether an unbonding lock for a delegator is valid
     * @param _delegator Address of delegator
     * @param _unbondingLockId ID of unbonding lock
     * @return true if unbondingLock for ID has a non-zero withdraw round
     */
    function isValidUnbondingLock(address _delegator, uint256 _unbondingLockId) public view returns (bool) {
        // A unbonding lock is only valid if it has a non-zero withdraw round (the default value is zero)
        return delegators[_delegator].unbondingLocks[_unbondingLockId].withdrawRound > 0;
    }

    /**
     * @notice Return an EarningsPool.Data struct with the latest cumulative factors for a given round
     * @param _transcoder Storage pointer to a transcoder struct
     * @param _round The round to fetch the latest cumulative factors for
     * @return pool An EarningsPool.Data populated with the latest cumulative factors for _round
     */
    function latestCumulativeFactorsPool(Transcoder storage _transcoder, uint256 _round)
        internal
        view
        returns (EarningsPool.Data memory pool)
    {
        pool.cumulativeRewardFactor = _transcoder.earningsPoolPerRound[_round].cumulativeRewardFactor;
        pool.cumulativeFeeFactor = _transcoder.earningsPoolPerRound[_round].cumulativeFeeFactor;

        uint256 lastRewardRound = _transcoder.lastRewardRound;
        // Only use the cumulativeRewardFactor for lastRewardRound if lastRewardRound is before _round
        if (pool.cumulativeRewardFactor == 0 && lastRewardRound < _round) {
            pool.cumulativeRewardFactor = _transcoder.earningsPoolPerRound[lastRewardRound].cumulativeRewardFactor;
        }

        uint256 lastFeeRound = _transcoder.lastFeeRound;
        // Only use the cumulativeFeeFactor for lastFeeRound if lastFeeRound is before _round
        if (pool.cumulativeFeeFactor == 0 && lastFeeRound < _round) {
            pool.cumulativeFeeFactor = _transcoder.earningsPoolPerRound[lastFeeRound].cumulativeFeeFactor;
        }

        return pool;
    }

    /**
     * @notice Return a delegator's cumulative stake and fees using the LIP-36 earnings claiming algorithm
     * @param _transcoder Storage pointer to a transcoder struct for a delegator's delegate
     * @param _startRound The round for the start cumulative factors
     * @param _endRound The round for the end cumulative factors
     * @param _stake The delegator's initial stake before including earned rewards
     * @param _fees The delegator's initial fees before including earned fees
     * @return (cStake, cFees) where cStake is the delegator's cumulative stake including earned rewards and cFees is the delegator's cumulative fees including earned fees
     */
    function delegatorCumulativeStakeAndFees(
        Transcoder storage _transcoder,
        uint256 _startRound,
        uint256 _endRound,
        uint256 _stake,
        uint256 _fees
    ) internal view returns (uint256 cStake, uint256 cFees) {
        uint256 baseRewardFactor = MathUtils.percPoints(1, 1);

        // Fetch start cumulative factors
        EarningsPool.Data memory startPool;
        startPool.cumulativeRewardFactor = _transcoder.earningsPoolPerRound[_startRound].cumulativeRewardFactor;
        startPool.cumulativeFeeFactor = _transcoder.earningsPoolPerRound[_startRound].cumulativeFeeFactor;

        if (startPool.cumulativeRewardFactor == 0) {
            startPool.cumulativeRewardFactor = baseRewardFactor;
        }

        // Fetch end cumulative factors
        EarningsPool.Data memory endPool = latestCumulativeFactorsPool(_transcoder, _endRound);

        if (endPool.cumulativeRewardFactor == 0) {
            endPool.cumulativeRewardFactor = baseRewardFactor;
        }

        cFees = _fees.add(
            MathUtils.percOf(
                _stake,
                endPool.cumulativeFeeFactor.sub(startPool.cumulativeFeeFactor),
                startPool.cumulativeRewardFactor
            )
        );

        cStake = MathUtils.percOf(_stake, endPool.cumulativeRewardFactor, startPool.cumulativeRewardFactor);

        return (cStake, cFees);
    }

    /**
     * @notice Return the pending stake and fees for a delegator
     * @param _delegator Address of a delegator
     * @param _endRound The last round to claim earnings for when calculating the pending stake and fees
     * @return (stake, fees) where stake is the delegator's pending stake and fees is the delegator's pending fees
     */
    function pendingStakeAndFees(address _delegator, uint256 _endRound)
        internal
        view
        returns (uint256 stake, uint256 fees)
    {
        Delegator storage del = delegators[_delegator];
        Transcoder storage t = transcoders[del.delegateAddress];

        fees = del.fees;
        stake = del.bondedAmount;

        uint256 startRound = del.lastClaimRound.add(1);
        address delegateAddr = del.delegateAddress;
        bool isTranscoder = _delegator == delegateAddr;

        uint256 lip36Round = roundsManager().lipUpgradeRound(36);
        while (startRound <= _endRound && startRound <= lip36Round) {
            EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[startRound];

            // If earningsPool.hasTranscoderRewardFeePool is not set during lip36Round then the transcoder did not call
            // reward during lip36Round before the upgrade. In this case, if the transcoder calls reward in lip36Round
            // the delegator can use the LIP-36 earnings claiming algorithm to claim for lip36Round
            if (startRound == lip36Round && !earningsPool.hasTranscoderRewardFeePool) {
                break;
            }

            if (earningsPool.hasClaimableShares()) {
                // Calculate and add fee pool share from this round
                fees = fees.add(earningsPool.feePoolShare(stake, isTranscoder));
                // Calculate new bonded amount with rewards from this round. Updated bonded amount used
                // to calculate fee pool share in next round
                stake = stake.add(earningsPool.rewardPoolShare(stake, isTranscoder));
            }

            startRound = startRound.add(1);
        }

        // If the transcoder called reward during lip36Round the upgrade, then startRound = lip36Round
        // Otherwise, startRound = lip36Round + 1

        // If the start round is greater than the end round, we've already claimed for the end round so we do not
        // need to execute the LIP-36 earnings claiming algorithm. This could be the case if:
        // - _endRound < lip36Round i.e. we are not claiming through the lip36Round
        // - _endRound == lip36Round AND startRound = lip36Round + 1 i.e we already claimed through the lip36Round
        if (startRound > _endRound) {
            return (stake, fees);
        }

        // The LIP-36 earnings claiming algorithm uses the cumulative factors from the delegator's lastClaimRound i.e. startRound - 1
        // and from the specified _endRound
        (stake, fees) = delegatorCumulativeStakeAndFees(t, startRound.sub(1), _endRound, stake, fees);

        if (isTranscoder) {
            stake = stake.add(t.cumulativeRewards);
            fees = fees.add(t.cumulativeFees);
        }

        return (stake, fees);
    }

    /**
     * @dev Increase the total stake for a delegate and updates its 'lastActiveStakeUpdateRound'
     * @param _delegate The delegate to increase the stake for
     * @param _amount The amount to increase the stake for '_delegate' by
     */
    function increaseTotalStake(
        address _delegate,
        uint256 _amount,
        address _newPosPrev,
        address _newPosNext
    ) internal {
        if (isRegisteredTranscoder(_delegate)) {
            uint256 currStake = transcoderTotalStake(_delegate);
            uint256 newStake = currStake.add(_amount);
            uint256 currRound = roundsManager().currentRound();
            uint256 nextRound = currRound.add(1);

            // If the transcoder is already in the active set update its stake and return
            if (transcoderPoolV2.contains(_delegate)) {
                transcoderPoolV2.updateKey(_delegate, newStake, _newPosPrev, _newPosNext);
                nextRoundTotalActiveStake = nextRoundTotalActiveStake.add(_amount);
                Transcoder storage t = transcoders[_delegate];

                // currStake (the transcoder's delegatedAmount field) will reflect the transcoder's stake from lastActiveStakeUpdateRound
                // because it is updated every time lastActiveStakeUpdateRound is updated
                // The current active total stake is set to currStake to ensure that the value can be used in updateTranscoderWithRewards()
                // and updateTranscoderWithFees() when lastActiveStakeUpdateRound > currentRound
                if (t.lastActiveStakeUpdateRound < currRound) {
                    t.earningsPoolPerRound[currRound].setStake(currStake);
                }

                t.earningsPoolPerRound[nextRound].setStake(newStake);
                t.lastActiveStakeUpdateRound = nextRound;
            } else {
                // Check if the transcoder is eligible to join the active set in the update round
                tryToJoinActiveSet(_delegate, newStake, nextRound, _newPosPrev, _newPosNext);
            }
        }

        // Increase delegate's delegated amount
        delegators[_delegate].delegatedAmount = delegators[_delegate].delegatedAmount.add(_amount);
    }

    /**
     * @dev Decrease the total stake for a delegate and updates its 'lastActiveStakeUpdateRound'
     * @param _delegate The transcoder to decrease the stake for
     * @param _amount The amount to decrease the stake for '_delegate' by
     */
    function decreaseTotalStake(
        address _delegate,
        uint256 _amount,
        address _newPosPrev,
        address _newPosNext
    ) internal {
        if (transcoderPoolV2.contains(_delegate)) {
            uint256 currStake = transcoderTotalStake(_delegate);
            uint256 newStake = currStake.sub(_amount);
            uint256 currRound = roundsManager().currentRound();
            uint256 nextRound = currRound.add(1);

            transcoderPoolV2.updateKey(_delegate, newStake, _newPosPrev, _newPosNext);
            nextRoundTotalActiveStake = nextRoundTotalActiveStake.sub(_amount);
            Transcoder storage t = transcoders[_delegate];

            // currStake (the transcoder's delegatedAmount field) will reflect the transcoder's stake from lastActiveStakeUpdateRound
            // because it is updated every time lastActiveStakeUpdateRound is updated
            // The current active total stake is set to currStake to ensure that the value can be used in updateTranscoderWithRewards()
            // and updateTranscoderWithFees() when lastActiveStakeUpdateRound > currentRound
            if (t.lastActiveStakeUpdateRound < currRound) {
                t.earningsPoolPerRound[currRound].setStake(currStake);
            }

            t.lastActiveStakeUpdateRound = nextRound;
            t.earningsPoolPerRound[nextRound].setStake(newStake);
        }

        // Decrease old delegate's delegated amount
        delegators[_delegate].delegatedAmount = delegators[_delegate].delegatedAmount.sub(_amount);
    }

    /**
     * @dev Tries to add a transcoder to active transcoder pool, evicts the active transcoder with the lowest stake if the pool is full
     * @param _transcoder The transcoder to insert into the transcoder pool
     * @param _totalStake The total stake for '_transcoder'
     * @param _activationRound The round in which the transcoder should become active
     */
    function tryToJoinActiveSet(
        address _transcoder,
        uint256 _totalStake,
        uint256 _activationRound,
        address _newPosPrev,
        address _newPosNext
    ) internal {
        uint256 pendingNextRoundTotalActiveStake = nextRoundTotalActiveStake;

        if (transcoderPoolV2.isFull()) {
            address lastTranscoder = transcoderPoolV2.getLast();
            uint256 lastStake = transcoderTotalStake(lastTranscoder);

            // If the pool is full and the transcoder has less stake than the least stake transcoder in the pool
            // then the transcoder is unable to join the active set for the next round
            if (_totalStake <= lastStake) {
                return;
            }

            // Evict the least stake transcoder from the active set for the next round
            // Not zeroing 'Transcoder.lastActiveStakeUpdateRound' saves gas (5k when transcoder is evicted and 20k when transcoder is reinserted)
            // There should be no side-effects as long as the value is properly updated on stake updates
            // Not zeroing the stake on the current round's 'EarningsPool' saves gas and should have no side effects as long as
            // 'EarningsPool.setStake()' is called whenever a transcoder becomes active again.
            transcoderPoolV2.remove(lastTranscoder);
            transcoders[lastTranscoder].deactivationRound = _activationRound;
            pendingNextRoundTotalActiveStake = pendingNextRoundTotalActiveStake.sub(lastStake);

            emit TranscoderDeactivated(lastTranscoder, _activationRound);
        }

        transcoderPoolV2.insert(_transcoder, _totalStake, _newPosPrev, _newPosNext);
        pendingNextRoundTotalActiveStake = pendingNextRoundTotalActiveStake.add(_totalStake);
        Transcoder storage t = transcoders[_transcoder];
        t.lastActiveStakeUpdateRound = _activationRound;
        t.activationRound = _activationRound;
        t.deactivationRound = MAX_FUTURE_ROUND;
        t.earningsPoolPerRound[_activationRound].setStake(_totalStake);
        nextRoundTotalActiveStake = pendingNextRoundTotalActiveStake;
        emit TranscoderActivated(_transcoder, _activationRound);
    }

    /**
     * @dev Remove a transcoder from the pool and deactivate it
     */
    function resignTranscoder(address _transcoder) internal {
        // Not zeroing 'Transcoder.lastActiveStakeUpdateRound' saves gas (5k when transcoder is evicted and 20k when transcoder is reinserted)
        // There should be no side-effects as long as the value is properly updated on stake updates
        // Not zeroing the stake on the current round's 'EarningsPool' saves gas and should have no side effects as long as
        // 'EarningsPool.setStake()' is called whenever a transcoder becomes active again.
        transcoderPoolV2.remove(_transcoder);
        nextRoundTotalActiveStake = nextRoundTotalActiveStake.sub(transcoderTotalStake(_transcoder));
        uint256 deactivationRound = roundsManager().currentRound().add(1);
        transcoders[_transcoder].deactivationRound = deactivationRound;
        emit TranscoderDeactivated(_transcoder, deactivationRound);
    }

    /**
     * @dev Update a transcoder with rewards and update the transcoder pool with an optional list hint if needed.
     * See SortedDoublyLL.sol for details on list hints
     * @param _transcoder Address of transcoder
     * @param _rewards Amount of rewards
     * @param _round Round that transcoder is updated
     * @param _newPosPrev Address of previous transcoder in pool if the transcoder is in the pool
     * @param _newPosNext Address of next transcoder in pool if the transcoder is in the pool
     */
    function updateTranscoderWithRewards(
        address _transcoder,
        uint256 _rewards,
        uint256 _round,
        address _newPosPrev,
        address _newPosNext
    ) internal {
        Transcoder storage t = transcoders[_transcoder];
        EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[_round];
        EarningsPool.Data storage prevEarningsPool = t.earningsPoolPerRound[t.lastRewardRound];

        t.activeCumulativeRewards = t.cumulativeRewards;

        uint256 transcoderCommissionRewards = MathUtils.percOf(_rewards, earningsPool.transcoderRewardCut);
        uint256 delegatorsRewards = _rewards.sub(transcoderCommissionRewards);
        // Calculate the rewards earned by the transcoder's earned rewards
        uint256 transcoderRewardStakeRewards = MathUtils.percOf(
            delegatorsRewards,
            t.activeCumulativeRewards,
            earningsPool.totalStake
        );
        // Track rewards earned by the transcoder based on its earned rewards and rewardCut
        t.cumulativeRewards = t.cumulativeRewards.add(transcoderRewardStakeRewards).add(transcoderCommissionRewards);
        // Update cumulative reward factor with new rewards
        // The cumulativeRewardFactor is used to calculate rewards for all delegators including the transcoder (self-delegated)
        // Note that delegatorsRewards includes transcoderRewardStakeRewards, but no delegator will claim that amount using
        // the earnings claiming algorithm and instead that amount is accounted for in the transcoder's cumulativeRewards field
        earningsPool.updateCumulativeRewardFactor(prevEarningsPool, delegatorsRewards);
        // Update transcoder's total stake with rewards
        increaseTotalStake(_transcoder, _rewards, _newPosPrev, _newPosNext);
    }

    /**
     * @dev Update a delegator with token pools shares from its lastClaimRound through a given round
     * @param _delegator Delegator address
     * @param _endRound The last round for which to update a delegator's stake with earnings pool shares
     * @param _lastClaimRound The round for which a delegator has last claimed earnings
     */
    function updateDelegatorWithEarnings(
        address _delegator,
        uint256 _endRound,
        uint256 _lastClaimRound
    ) internal {
        Delegator storage del = delegators[_delegator];
        uint256 startRound = _lastClaimRound.add(1);
        uint256 currentBondedAmount = del.bondedAmount;
        uint256 currentFees = del.fees;

        uint256 lip36Round = roundsManager().lipUpgradeRound(36);

        // Only will have earnings to claim if you have a delegate
        // If not delegated, skip the earnings claim process
        if (del.delegateAddress != address(0)) {
            if (startRound <= lip36Round) {
                // Cannot claim earnings for more than maxEarningsClaimsRounds before LIP-36
                // This is a number to cause transactions to fail early if
                // we know they will require too much gas to loop through all the necessary rounds to claim earnings
                // The user should instead manually invoke `claimEarnings` to split up the claiming process
                // across multiple transactions
                uint256 endLoopRound = _endRound <= lip36Round ? _endRound : lip36Round;
                require(
                    endLoopRound.sub(_lastClaimRound) <= maxEarningsClaimsRounds,
                    ""too many rounds to claim through""
                );
            }

            (currentBondedAmount, currentFees) = pendingStakeAndFees(_delegator, _endRound);

            // Check whether the endEarningsPool is initialised
            // If it is not initialised set it's cumulative factors so that they can be used when a delegator
            // next claims earnings as the start cumulative factors (see delegatorCumulativeStakeAndFees())
            Transcoder storage t = transcoders[del.delegateAddress];
            EarningsPool.Data storage endEarningsPool = t.earningsPoolPerRound[_endRound];
            if (endEarningsPool.cumulativeRewardFactor == 0) {
                endEarningsPool.cumulativeRewardFactor = t
                    .earningsPoolPerRound[t.lastRewardRound]
                    .cumulativeRewardFactor;
            }
            if (endEarningsPool.cumulativeFeeFactor == 0) {
                endEarningsPool.cumulativeFeeFactor = t.earningsPoolPerRound[t.lastFeeRound].cumulativeFeeFactor;
            }

            if (del.delegateAddress == _delegator) {
                t.cumulativeFees = 0;
                t.cumulativeRewards = 0;
                // activeCumulativeRewards is not cleared here because the next reward() call will set it to cumulativeRewards
            }
        }

        emit EarningsClaimed(
            del.delegateAddress,
            _delegator,
            currentBondedAmount.sub(del.bondedAmount),
            currentFees.sub(del.fees),
            startRound,
            _endRound
        );

        del.lastClaimRound = _endRound;
        // Rewards are bonded by default
        del.bondedAmount = currentBondedAmount;
        del.fees = currentFees;
    }

    /**
     * @dev Update the state of a delegator and its delegate by processing a rebond using an unbonding lock and update the transcoder pool with an optional
     * list hint if needed. See SortedDoublyLL.sol for details on list hints
     * @param _delegator Address of delegator
     * @param _unbondingLockId ID of unbonding lock to rebond with
     * @param _newPosPrev Address of previous transcoder in pool if the delegate is already in or joins the pool
     * @param _newPosNext Address of next transcoder in pool if the delegate is already in or joins the pool
     */
    function processRebond(
        address _delegator,
        uint256 _unbondingLockId,
        address _newPosPrev,
        address _newPosNext
    ) internal {
        Delegator storage del = delegators[_delegator];
        UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];

        require(isValidUnbondingLock(_delegator, _unbondingLockId), ""invalid unbonding lock ID"");

        uint256 amount = lock.amount;
        // Increase delegator's bonded amount
        del.bondedAmount = del.bondedAmount.add(amount);

        // Delete lock
        delete del.unbondingLocks[_unbondingLockId];

        increaseTotalStake(del.delegateAddress, amount, _newPosPrev, _newPosNext);

        emit Rebond(del.delegateAddress, _delegator, _unbondingLockId, amount);
    }

    /**
     * @dev Return LivepeerToken interface
     * @return Livepeer token contract registered with Controller
     */
    function livepeerToken() internal view returns (ILivepeerToken) {
        return ILivepeerToken(controller.getContract(keccak256(""LivepeerToken"")));
    }

    /**
     * @dev Return Minter interface
     * @return Minter contract registered with Controller
     */
    function minter() internal view returns (IMinter) {
        return IMinter(controller.getContract(keccak256(""Minter"")));
    }

    /**
     * @dev Return RoundsManager interface
     * @return RoundsManager contract registered with Controller
     */
    function roundsManager() internal view returns (IRoundsManager) {
        return IRoundsManager(controller.getContract(keccak256(""RoundsManager"")));
    }

    function _onlyTicketBroker() internal view {
        require(msg.sender == controller.getContract(keccak256(""TicketBroker"")), ""caller must be TicketBroker"");
    }

    function _onlyRoundsManager() internal view {
        require(msg.sender == controller.getContract(keccak256(""RoundsManager"")), ""caller must be RoundsManager"");
    }

    function _onlyVerifier() internal view {
        require(msg.sender == controller.getContract(keccak256(""Verifier"")), ""caller must be Verifier"");
    }

    function _currentRoundInitialized() internal view {
        require(roundsManager().currentRoundInitialized(), ""current round is not initialized"");
    }

    function _autoClaimEarnings() internal {
        uint256 currentRound = roundsManager().currentRound();
        uint256 lastClaimRound = delegators[msg.sender].lastClaimRound;
        if (lastClaimRound < currentRound) {
            updateDelegatorWithEarnings(msg.sender, currentRound, lastClaimRound);
        }
    }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""pragma solidity 0.5.11;

import ""../../ManagerProxyTarget.sol"";
import ""../IBondingManager.sol"";
import ""../../libraries/SortedDoublyLL.sol"";
import ""../../libraries/MathUtils.sol"";
import ""../libraries/EarningsPool.sol"";
import ""../libraries/EarningsPoolLIP36.sol"";
import ""../../token/ILivepeerToken.sol"";
import ""../../token/IMinter.sol"";
import ""../../rounds/IRoundsManager.sol"";
import ""../../snapshots/IMerkleSnapshot.sol"";

import ""openzeppelin-solidity/contracts/math/SafeMath.sol"";

/**
 * @title BondingManager
 * @notice Manages bonding, transcoder and rewards/fee accounting related operations of the Livepeer protocol
 */
contract BondingManagerZeroStartFactorsBug is ManagerProxyTarget, IBondingManager {
    using SafeMath for uint256;
    using SortedDoublyLL for SortedDoublyLL.Data;
    using EarningsPool for EarningsPool.Data;
    using EarningsPoolLIP36 for EarningsPool.Data;

    // Constants
    // Occurances are replaced at compile time
    // and computed to a single value if possible by the optimizer
    uint256 constant MAX_FUTURE_ROUND = 2**256 - 1;

    // Time between unbonding and possible withdrawl in rounds
    uint64 public unbondingPeriod;
    // DEPRECATED - DO NOT USE
    uint256 public numActiveTranscodersDEPRECATED;
    // Max number of rounds that a caller can claim earnings for at once
    uint256 public maxEarningsClaimsRounds;

    // Represents a transcoder's current state
    struct Transcoder {
        uint256 lastRewardRound; // Last round that the transcoder called reward
        uint256 rewardCut; // % of reward paid to transcoder by a delegator
        uint256 feeShare; // % of fees paid to delegators by transcoder
        uint256 pricePerSegmentDEPRECATED; // DEPRECATED - DO NOT USE
        uint256 pendingRewardCutDEPRECATED; // DEPRECATED - DO NOT USE
        uint256 pendingFeeShareDEPRECATED; // DEPRECATED - DO NOT USE
        uint256 pendingPricePerSegmentDEPRECATED; // DEPRECATED - DO NOT USE
        mapping(uint256 => EarningsPool.Data) earningsPoolPerRound; // Mapping of round => earnings pool for the round
        uint256 lastActiveStakeUpdateRound; // Round for which the stake was last updated while the transcoder is active
        uint256 activationRound; // Round in which the transcoder became active - 0 if inactive
        uint256 deactivationRound; // Round in which the transcoder will become inactive
        uint256 activeCumulativeRewards; // The transcoder's cumulative rewards that are active in the current round
        uint256 cumulativeRewards; // The transcoder's cumulative rewards (earned via the its active staked rewards and its reward cut).
        uint256 cumulativeFees; // The transcoder's cumulative fees (earned via the its active staked rewards and its fee share)
        uint256 lastFeeRound; // Latest round in which the transcoder received fees
    }

    // The various states a transcoder can be in
    enum TranscoderStatus {
        NotRegistered,
        Registered
    }

    // Represents a delegator's current state
    struct Delegator {
        uint256 bondedAmount; // The amount of bonded tokens
        uint256 fees; // The amount of fees collected
        address delegateAddress; // The address delegated to
        uint256 delegatedAmount; // The amount of tokens delegated to the delegator
        uint256 startRound; // The round the delegator transitions to bonded phase and is delegated to someone
        uint256 withdrawRoundDEPRECATED; // DEPRECATED - DO NOT USE
        uint256 lastClaimRound; // The last round during which the delegator claimed its earnings
        uint256 nextUnbondingLockId; // ID for the next unbonding lock created
        mapping(uint256 => UnbondingLock) unbondingLocks; // Mapping of unbonding lock ID => unbonding lock
    }

    // The various states a delegator can be in
    enum DelegatorStatus {
        Pending,
        Bonded,
        Unbonded
    }

    // Represents an amount of tokens that are being unbonded
    struct UnbondingLock {
        uint256 amount; // Amount of tokens being unbonded
        uint256 withdrawRound; // Round at which unbonding period is over and tokens can be withdrawn
    }

    // Keep track of the known transcoders and delegators
    mapping(address => Delegator) private delegators;
    mapping(address => Transcoder) private transcoders;

    // DEPRECATED - DO NOT USE
    // The function getTotalBonded() no longer uses this variable
    // and instead calculates the total bonded value separately
    uint256 private totalBondedDEPRECATED;

    // DEPRECATED - DO NOT USE
    SortedDoublyLL.Data private transcoderPoolDEPRECATED;

    // DEPRECATED - DO NOT USE
    struct ActiveTranscoderSetDEPRECATED {
        address[] transcoders;
        mapping(address => bool) isActive;
        uint256 totalStake;
    }

    // DEPRECATED - DO NOT USE
    mapping(uint256 => ActiveTranscoderSetDEPRECATED) public activeTranscoderSetDEPRECATED;

    // The total active stake (sum of the stake of active set members) for the current round
    uint256 public currentRoundTotalActiveStake;
    // The total active stake (sum of the stake of active set members) for the next round
    uint256 public nextRoundTotalActiveStake;

    // The transcoder pool is used to keep track of the transcoders that are eligible for activation.
    // The pool keeps track of the pending active set in round N and the start of round N + 1 transcoders
    // in the pool are locked into the active set for round N + 1
    SortedDoublyLL.Data private transcoderPoolV2;

    // Check if sender is TicketBroker
    modifier onlyTicketBroker() {
        _onlyTicketBroker();
        _;
    }

    // Check if sender is RoundsManager
    modifier onlyRoundsManager() {
        _onlyRoundsManager();
        _;
    }

    // Check if sender is Verifier
    modifier onlyVerifier() {
        _onlyVerifier();
        _;
    }

    // Check if current round is initialized
    modifier currentRoundInitialized() {
        _currentRoundInitialized();
        _;
    }

    // Automatically claim earnings from lastClaimRound through the current round
    modifier autoClaimEarnings() {
        _autoClaimEarnings();
        _;
    }

    /**
     * @notice BondingManager constructor. Only invokes constructor of base Manager contract with provided Controller address
     * @dev This constructor will not initialize any state variables besides `controller`. The following setter functions
     * should be used to initialize state variables post-deployment:
     * - setUnbondingPeriod()
     * - setNumActiveTranscoders()
     * - setMaxEarningsClaimsRounds()
     * @param _controller Address of Controller that this contract will be registered with
     */
    constructor(address _controller) public Manager(_controller) {}

    /**
     * @notice Set unbonding period. Only callable by Controller owner
     * @param _unbondingPeriod Rounds between unbonding and possible withdrawal
     */
    function setUnbondingPeriod(uint64 _unbondingPeriod) external onlyControllerOwner {
        unbondingPeriod = _unbondingPeriod;

        emit ParameterUpdate(""unbondingPeriod"");
    }

    /**
     * @notice Set maximum number of active transcoders. Only callable by Controller owner
     * @param _numActiveTranscoders Number of active transcoders
     */
    function setNumActiveTranscoders(uint256 _numActiveTranscoders) external onlyControllerOwner {
        transcoderPoolV2.setMaxSize(_numActiveTranscoders);

        emit ParameterUpdate(""numActiveTranscoders"");
    }

    /**
     * @notice Set max number of rounds a caller can claim earnings for at once. Only callable by Controller owner
     * @param _maxEarningsClaimsRounds Max number of rounds a caller can claim earnings for at once
     */
    function setMaxEarningsClaimsRounds(uint256 _maxEarningsClaimsRounds) external onlyControllerOwner {
        maxEarningsClaimsRounds = _maxEarningsClaimsRounds;

        emit ParameterUpdate(""maxEarningsClaimsRounds"");
    }

    /**
     * @notice Sets commission rates as a transcoder and if the caller is not in the transcoder pool tries to add it
     * @dev Percentages are represented as numerators of fractions over MathUtils.PERC_DIVISOR
     * @param _rewardCut % of reward paid to transcoder by a delegator
     * @param _feeShare % of fees paid to delegators by a transcoder
     */
    function transcoder(uint256 _rewardCut, uint256 _feeShare) external {
        transcoderWithHint(_rewardCut, _feeShare, address(0), address(0));
    }

    /**
     * @notice Delegate stake towards a specific address
     * @param _amount The amount of tokens to stake
     * @param _to The address of the transcoder to stake towards
     */
    function bond(uint256 _amount, address _to) external {
        bondWithHint(_amount, _to, address(0), address(0), address(0), address(0));
    }

    /**
     * @notice Unbond an amount of the delegator's bonded stake
     * @param _amount Amount of tokens to unbond
     */
    function unbond(uint256 _amount) external {
        unbondWithHint(_amount, address(0), address(0));
    }

    /**
     * @notice Rebond tokens for an unbonding lock to a delegator's current delegate while a delegator is in the Bonded or Pending status
     * @param _unbondingLockId ID of unbonding lock to rebond with
     */
    function rebond(uint256 _unbondingLockId) external {
        rebondWithHint(_unbondingLockId, address(0), address(0));
    }

    /**
     * @notice Rebond tokens for an unbonding lock to a delegate while a delegator is in the Unbonded status
     * @param _to Address of delegate
     * @param _unbondingLockId ID of unbonding lock to rebond with
     */
    function rebondFromUnbonded(address _to, uint256 _unbondingLockId) external {
        rebondFromUnbondedWithHint(_to, _unbondingLockId, address(0), address(0));
    }

    /**
     * @notice Withdraws tokens for an unbonding lock that has existed through an unbonding period
     * @param _unbondingLockId ID of unbonding lock to withdraw with
     */
    function withdrawStake(uint256 _unbondingLockId) external whenSystemNotPaused currentRoundInitialized {
        Delegator storage del = delegators[msg.sender];
        UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];

        require(isValidUnbondingLock(msg.sender, _unbondingLockId), ""invalid unbonding lock ID"");
        require(
            lock.withdrawRound <= roundsManager().currentRound(),
            ""withdraw round must be before or equal to the current round""
        );

        uint256 amount = lock.amount;
        uint256 withdrawRound = lock.withdrawRound;
        // Delete unbonding lock
        delete del.unbondingLocks[_unbondingLockId];

        // Tell Minter to transfer stake (LPT) to the delegator
        minter().trustedTransferTokens(msg.sender, amount);

        emit WithdrawStake(msg.sender, _unbondingLockId, amount, withdrawRound);
    }

    /**
     * @notice Withdraws fees to the caller
     */
    function withdrawFees() external whenSystemNotPaused currentRoundInitialized autoClaimEarnings {
        uint256 fees = delegators[msg.sender].fees;
        require(fees > 0, ""no fees to withdraw"");
        delegators[msg.sender].fees = 0;

        // Tell Minter to transfer fees (ETH) to the delegator
        minter().trustedWithdrawETH(msg.sender, fees);

        emit WithdrawFees(msg.sender);
    }

    /**
     * @notice Mint token rewards for an active transcoder and its delegators
     */
    function reward() external {
        rewardWithHint(address(0), address(0));
    }

    /**
     * @notice Update transcoder's fee pool. Only callable by the TicketBroker
     * @param _transcoder Transcoder address
     * @param _fees Fees to be added to the fee pool
     */
    function updateTranscoderWithFees(
        address _transcoder,
        uint256 _fees,
        uint256 _round
    ) external whenSystemNotPaused onlyTicketBroker {
        // Silence unused param compiler warning
        _round;

        require(isRegisteredTranscoder(_transcoder), ""transcoder must be registered"");

        uint256 currentRound = roundsManager().currentRound();

        Transcoder storage t = transcoders[_transcoder];

        uint256 lastRewardRound = t.lastRewardRound;
        uint256 activeCumulativeRewards = t.activeCumulativeRewards;

        // LIP-36: Add fees for the current round instead of '_round'
        // https://github.com/livepeer/LIPs/issues/35#issuecomment-673659199
        EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[currentRound];
        EarningsPool.Data memory prevEarningsPool = latestCumulativeFactorsPool(t, currentRound.sub(1));

        // if transcoder hasn't called 'reward()' for '_round' its 'transcoderFeeShare', 'transcoderRewardCut' and 'totalStake'
        // on the 'EarningsPool' for '_round' would not be initialized and the fee distribution wouldn't happen as expected
        // for cumulative fee calculation this would result in division by zero.
        if (currentRound > lastRewardRound) {
            earningsPool.setCommission(t.rewardCut, t.feeShare);

            uint256 lastUpdateRound = t.lastActiveStakeUpdateRound;
            if (lastUpdateRound < currentRound) {
                earningsPool.setStake(t.earningsPoolPerRound[lastUpdateRound].totalStake);
            }

            // If reward() has not been called yet in the current round, then the transcoder's activeCumulativeRewards has not
            // yet been set in for the round. When the transcoder calls reward() its activeCumulativeRewards will be set to its
            // current cumulativeRewards. So, we can just use the transcoder's cumulativeRewards here because this will become
            // the transcoder's activeCumulativeRewards if it calls reward() later on in the current round
            activeCumulativeRewards = t.cumulativeRewards;
        }

        uint256 totalStake = earningsPool.totalStake;
        if (prevEarningsPool.cumulativeRewardFactor == 0 && lastRewardRound == currentRound) {
            // if transcoder called reward for 'currentRound' but not for 'currentRound - 1' (missed reward call)
            // retroactively calculate what its cumulativeRewardFactor would have been for 'currentRound - 1' (cfr. previous lastRewardRound for transcoder)
            // based on rewards for currentRound
            IMinter mtr = minter();
            uint256 rewards = MathUtils.percOf(
                mtr.currentMintableTokens().add(mtr.currentMintedTokens()),
                totalStake,
                currentRoundTotalActiveStake
            );
            uint256 transcoderCommissionRewards = MathUtils.percOf(rewards, earningsPool.transcoderRewardCut);
            uint256 delegatorsRewards = rewards.sub(transcoderCommissionRewards);

            prevEarningsPool.cumulativeRewardFactor = MathUtils.percOf(
                earningsPool.cumulativeRewardFactor,
                totalStake,
                delegatorsRewards.add(totalStake)
            );
        }

        uint256 delegatorsFees = MathUtils.percOf(_fees, earningsPool.transcoderFeeShare);
        uint256 transcoderCommissionFees = _fees.sub(delegatorsFees);
        // Calculate the fees earned by the transcoder's earned rewards
        uint256 transcoderRewardStakeFees = MathUtils.percOf(delegatorsFees, activeCumulativeRewards, totalStake);
        // Track fees earned by the transcoder based on its earned rewards and feeShare
        t.cumulativeFees = t.cumulativeFees.add(transcoderRewardStakeFees).add(transcoderCommissionFees);
        // Update cumulative fee factor with new fees
        // The cumulativeFeeFactor is used to calculate fees for all delegators including the transcoder (self-delegated)
        // Note that delegatorsFees includes transcoderRewardStakeFees, but no delegator will claim that amount using
        // the earnings claiming algorithm and instead that amount is accounted for in the transcoder's cumulativeFees field
        earningsPool.updateCumulativeFeeFactor(prevEarningsPool, delegatorsFees);

        t.lastFeeRound = currentRound;
    }

    /**
     * @notice Slash a transcoder. Only callable by the Verifier
     * @param _transcoder Transcoder address
     * @param _finder Finder that proved a transcoder violated a slashing condition. Null address if there is no finder
     * @param _slashAmount Percentage of transcoder bond to be slashed
     * @param _finderFee Percentage of penalty awarded to finder. Zero if there is no finder
     */
    function slashTranscoder(
        address _transcoder,
        address _finder,
        uint256 _slashAmount,
        uint256 _finderFee
    ) external whenSystemNotPaused onlyVerifier {
        Delegator storage del = delegators[_transcoder];

        if (del.bondedAmount > 0) {
            uint256 penalty = MathUtils.percOf(delegators[_transcoder].bondedAmount, _slashAmount);

            // If active transcoder, resign it
            if (transcoderPoolV2.contains(_transcoder)) {
                resignTranscoder(_transcoder);
            }

            // Decrease bonded stake
            del.bondedAmount = del.bondedAmount.sub(penalty);

            // If still bonded decrease delegate's delegated amount
            if (delegatorStatus(_transcoder) == DelegatorStatus.Bonded) {
                delegators[del.delegateAddress].delegatedAmount = delegators[del.delegateAddress].delegatedAmount.sub(
                    penalty
                );
            }

            // Account for penalty
            uint256 burnAmount = penalty;

            // Award finder fee if there is a finder address
            if (_finder != address(0)) {
                uint256 finderAmount = MathUtils.percOf(penalty, _finderFee);
                minter().trustedTransferTokens(_finder, finderAmount);

                // Minter burns the slashed funds - finder reward
                minter().trustedBurnTokens(burnAmount.sub(finderAmount));

                emit TranscoderSlashed(_transcoder, _finder, penalty, finderAmount);
            } else {
                // Minter burns the slashed funds
                minter().trustedBurnTokens(burnAmount);

                emit TranscoderSlashed(_transcoder, address(0), penalty, 0);
            }
        } else {
            emit TranscoderSlashed(_transcoder, _finder, 0, 0);
        }
    }

    /**
     * @notice Claim token pools shares for a delegator from its lastClaimRound through the end round
     * @param _endRound The last round for which to claim token pools shares for a delegator
     */
    function claimEarnings(uint256 _endRound) external whenSystemNotPaused currentRoundInitialized {
        uint256 lastClaimRound = delegators[msg.sender].lastClaimRound;
        require(lastClaimRound < _endRound, ""end round must be after last claim round"");
        require(_endRound <= roundsManager().currentRound(), ""end round must be before or equal to current round"");

        updateDelegatorWithEarnings(msg.sender, _endRound, lastClaimRound);
    }

    /**
     * @notice Claim earnings for a delegator based on the snapshot taken in LIP-52
     * @dev https://github.com/livepeer/LIPs/blob/master/LIPs/LIP-52.md
     * @param _pendingStake the amount of pending stake for the delegator (current stake + pending rewards)
     * @param _pendingFees the amount of pending fees for the delegator (current fees + pending fees)
     * @param _earningsProof array of keccak256 sibling hashes on the branch of the leaf for the delegator up to the root
     * @param _data (optional) raw transaction data to be executed on behalf of msg.sender after claiming snapshot earnings
     */
    function claimSnapshotEarnings(
        uint256 _pendingStake,
        uint256 _pendingFees,
        bytes32[] calldata _earningsProof,
        bytes calldata _data
    ) external whenSystemNotPaused currentRoundInitialized {
        Delegator storage del = delegators[msg.sender];

        uint256 lip52Round = roundsManager().lipUpgradeRound(52);

        uint256 lastClaimRound = del.lastClaimRound;

        require(lastClaimRound < lip52Round, ""Already claimed for LIP-52"");

        bytes32 leaf = keccak256(abi.encode(msg.sender, _pendingStake, _pendingFees));

        require(
            IMerkleSnapshot(controller.getContract(keccak256(""MerkleSnapshot""))).verify(
                keccak256(""LIP-52""),
                _earningsProof,
                leaf
            ),
            ""Merkle proof is invalid""
        );

        emit EarningsClaimed(
            del.delegateAddress,
            msg.sender,
            _pendingStake.sub(del.bondedAmount),
            _pendingFees.sub(del.fees),
            lastClaimRound.add(1),
            lip52Round
        );

        del.lastClaimRound = lip52Round;
        del.bondedAmount = _pendingStake;
        del.fees = _pendingFees;

        // allow for execution of subsequent claiming or staking operations
        if (_data.length > 0) {
            (bool success, bytes memory returnData) = address(this).delegatecall(_data);
            require(success, string(returnData));
        }
    }

    /**
     * @notice Called during round initialization to set the total active stake for the round. Only callable by the RoundsManager
     */
    function setCurrentRoundTotalActiveStake() external onlyRoundsManager {
        currentRoundTotalActiveStake = nextRoundTotalActiveStake;
    }

    /**
     * @notice Sets commission rates as a transcoder and if the caller is not in the transcoder pool tries to add it using an optional list hint
     * @dev Percentages are represented as numerators of fractions over MathUtils.PERC_DIVISOR. If the caller is going to be added to the pool, the
     * caller can provide an optional hint for the insertion position in the pool via the `_newPosPrev` and `_newPosNext` params. A linear search will
     * be executed starting at the hint to find the correct position - in the best case, the hint is the correct position so no search is executed.
     * See SortedDoublyLL.sol for details on list hints
     * @param _rewardCut % of reward paid to transcoder by a delegator
     * @param _feeShare % of fees paid to delegators by a transcoder
     * @param _newPosPrev Address of previous transcoder in pool if the caller joins the pool
     * @param _newPosNext Address of next transcoder in pool if the caller joins the pool
     */
    function transcoderWithHint(
        uint256 _rewardCut,
        uint256 _feeShare,
        address _newPosPrev,
        address _newPosNext
    ) public whenSystemNotPaused currentRoundInitialized {
        require(!roundsManager().currentRoundLocked(), ""can't update transcoder params, current round is locked"");
        require(MathUtils.validPerc(_rewardCut), ""invalid rewardCut percentage"");
        require(MathUtils.validPerc(_feeShare), ""invalid feeShare percentage"");
        require(isRegisteredTranscoder(msg.sender), ""transcoder must be registered"");

        Transcoder storage t = transcoders[msg.sender];
        uint256 currentRound = roundsManager().currentRound();

        require(
            !isActiveTranscoder(msg.sender) || t.lastRewardRound == currentRound,
            ""caller can't be active or must have already called reward for the current round""
        );

        t.rewardCut = _rewardCut;
        t.feeShare = _feeShare;

        if (!transcoderPoolV2.contains(msg.sender)) {
            tryToJoinActiveSet(
                msg.sender,
                delegators[msg.sender].delegatedAmount,
                currentRound.add(1),
                _newPosPrev,
                _newPosNext
            );
        }

        emit TranscoderUpdate(msg.sender, _rewardCut, _feeShare);
    }

    /**
     * @notice Delegate stake towards a specific address and updates the transcoder pool using optional list hints if needed
     * @dev If the caller is decreasing the stake of its old delegate in the transcoder pool, the caller can provide an optional hint
     * for the insertion position of the old delegate via the `_oldDelegateNewPosPrev` and `_oldDelegateNewPosNext` params.
     * If the caller is delegating to a delegate that is in the transcoder pool, the caller can provide an optional hint for the
     * insertion position of the delegate via the `_currDelegateNewPosPrev` and `_currDelegateNewPosNext` params.
     * In both cases, a linear search will be executed starting at the hint to find the correct position. In the best case, the hint
     * is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints
     * @param _amount The amount of tokens to stake.
     * @param _to The address of the transcoder to stake towards
     * @param _oldDelegateNewPosPrev The address of the previous transcoder in the pool for the old delegate
     * @param _oldDelegateNewPosNext The address of the next transcoder in the pool for the old delegate
     * @param _currDelegateNewPosPrev The address of the previous transcoder in the pool for the current delegate
     * @param _currDelegateNewPosNext The address of the next transcoder in the pool for the current delegate
     */
    function bondWithHint(
        uint256 _amount,
        address _to,
        address _oldDelegateNewPosPrev,
        address _oldDelegateNewPosNext,
        address _currDelegateNewPosPrev,
        address _currDelegateNewPosNext
    ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {
        Delegator storage del = delegators[msg.sender];

        uint256 currentRound = roundsManager().currentRound();
        // Amount to delegate
        uint256 delegationAmount = _amount;
        // Current delegate
        address currentDelegate = del.delegateAddress;

        if (delegatorStatus(msg.sender) == DelegatorStatus.Unbonded) {
            // New delegate
            // Set start round
            // Don't set start round if delegator is in pending state because the start round would not change
            del.startRound = currentRound.add(1);
            // Unbonded state = no existing delegate and no bonded stake
            // Thus, delegation amount = provided amount
        } else if (currentDelegate != address(0) && currentDelegate != _to) {
            // A registered transcoder cannot delegate its bonded stake toward another address
            // because it can only be delegated toward itself
            // In the future, if delegation towards another registered transcoder as an already
            // registered transcoder becomes useful (i.e. for transitive delegation), this restriction
            // could be removed
            require(
                !isRegisteredTranscoder(msg.sender),
                ""registered transcoders can't delegate towards other addresses""
            );
            // Changing delegate
            // Set start round
            del.startRound = currentRound.add(1);
            // Update amount to delegate with previous delegation amount
            delegationAmount = delegationAmount.add(del.bondedAmount);

            decreaseTotalStake(currentDelegate, del.bondedAmount, _oldDelegateNewPosPrev, _oldDelegateNewPosNext);
        }

        // cannot delegate to someone without having bonded stake
        require(delegationAmount > 0, ""delegation amount must be greater than 0"");
        // Update delegate
        del.delegateAddress = _to;
        // Update bonded amount
        del.bondedAmount = del.bondedAmount.add(_amount);

        increaseTotalStake(_to, delegationAmount, _currDelegateNewPosPrev, _currDelegateNewPosNext);

        if (_amount > 0) {
            // Transfer the LPT to the Minter
            livepeerToken().transferFrom(msg.sender, address(minter()), _amount);
        }

        emit Bond(_to, currentDelegate, msg.sender, _amount, del.bondedAmount);
    }

    /**
     * @notice Unbond an amount of the delegator's bonded stake and updates the transcoder pool using an optional list hint if needed
     * @dev If the caller remains in the transcoder pool, the caller can provide an optional hint for its insertion position in the
     * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.
     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol details on list hints
     * @param _amount Amount of tokens to unbond
     * @param _newPosPrev Address of previous transcoder in pool if the caller remains in the pool
     * @param _newPosNext Address of next transcoder in pool if the caller remains in the pool
     */
    function unbondWithHint(
        uint256 _amount,
        address _newPosPrev,
        address _newPosNext
    ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {
        require(delegatorStatus(msg.sender) == DelegatorStatus.Bonded, ""caller must be bonded"");

        Delegator storage del = delegators[msg.sender];

        require(_amount > 0, ""unbond amount must be greater than 0"");
        require(_amount <= del.bondedAmount, ""amount is greater than bonded amount"");

        address currentDelegate = del.delegateAddress;
        uint256 currentRound = roundsManager().currentRound();
        uint256 withdrawRound = currentRound.add(unbondingPeriod);
        uint256 unbondingLockId = del.nextUnbondingLockId;

        // Create new unbonding lock
        del.unbondingLocks[unbondingLockId] = UnbondingLock({ amount: _amount, withdrawRound: withdrawRound });
        // Increment ID for next unbonding lock
        del.nextUnbondingLockId = unbondingLockId.add(1);
        // Decrease delegator's bonded amount
        del.bondedAmount = del.bondedAmount.sub(_amount);

        if (del.bondedAmount == 0) {
            // Delegator no longer delegated to anyone if it does not have a bonded amount
            del.delegateAddress = address(0);
            // Delegator does not have a start round if it is no longer delegated to anyone
            del.startRound = 0;

            if (transcoderPoolV2.contains(msg.sender)) {
                resignTranscoder(msg.sender);
            }
        }

        // If msg.sender was resigned this statement will only decrease delegators[currentDelegate].delegatedAmount
        decreaseTotalStake(currentDelegate, _amount, _newPosPrev, _newPosNext);

        emit Unbond(currentDelegate, msg.sender, unbondingLockId, _amount, withdrawRound);
    }

    /**
     * @notice Rebond tokens for an unbonding lock to a delegator's current delegate while a delegator is in the Bonded or Pending status and updates
     * the transcoder pool using an optional list hint if needed
     * @dev If the delegate is in the transcoder pool, the caller can provide an optional hint for the delegate's insertion position in the
     * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.
     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol details on list hints
     * @param _unbondingLockId ID of unbonding lock to rebond with
     * @param _newPosPrev Address of previous transcoder in pool if the delegate is in the pool
     * @param _newPosNext Address of next transcoder in pool if the delegate is in the pool
     */
    function rebondWithHint(
        uint256 _unbondingLockId,
        address _newPosPrev,
        address _newPosNext
    ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {
        require(delegatorStatus(msg.sender) != DelegatorStatus.Unbonded, ""caller must be bonded"");

        // Process rebond using unbonding lock
        processRebond(msg.sender, _unbondingLockId, _newPosPrev, _newPosNext);
    }

    /**
     * @notice Rebond tokens for an unbonding lock to a delegate while a delegator is in the Unbonded status and updates the transcoder pool using
     * an optional list hint if needed
     * @dev If the delegate joins the transcoder pool, the caller can provide an optional hint for the delegate's insertion position in the
     * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.
     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints
     * @param _to Address of delegate
     * @param _unbondingLockId ID of unbonding lock to rebond with
     * @param _newPosPrev Address of previous transcoder in pool if the delegate joins the pool
     * @param _newPosNext Address of next transcoder in pool if the delegate joins the pool
     */
    function rebondFromUnbondedWithHint(
        address _to,
        uint256 _unbondingLockId,
        address _newPosPrev,
        address _newPosNext
    ) public whenSystemNotPaused currentRoundInitialized autoClaimEarnings {
        require(delegatorStatus(msg.sender) == DelegatorStatus.Unbonded, ""caller must be unbonded"");

        // Set delegator's start round and transition into Pending state
        delegators[msg.sender].startRound = roundsManager().currentRound().add(1);
        // Set delegator's delegate
        delegators[msg.sender].delegateAddress = _to;
        // Process rebond using unbonding lock
        processRebond(msg.sender, _unbondingLockId, _newPosPrev, _newPosNext);
    }

    /**
     * @notice Mint token rewards for an active transcoder and its delegators and update the transcoder pool using an optional list hint if needed
     * @dev If the caller is in the transcoder pool, the caller can provide an optional hint for its insertion position in the
     * pool via the `_newPosPrev` and `_newPosNext` params. A linear search will be executed starting at the hint to find the correct position.
     * In the best case, the hint is the correct position so no search is executed. See SortedDoublyLL.sol for details on list hints
     * @param _newPosPrev Address of previous transcoder in pool if the caller is in the pool
     * @param _newPosNext Address of next transcoder in pool if the caller is in the pool
     */
    function rewardWithHint(address _newPosPrev, address _newPosNext)
        public
        whenSystemNotPaused
        currentRoundInitialized
    {
        uint256 currentRound = roundsManager().currentRound();

        require(isActiveTranscoder(msg.sender), ""caller must be an active transcoder"");
        require(
            transcoders[msg.sender].lastRewardRound != currentRound,
            ""caller has already called reward for the current round""
        );

        Transcoder storage t = transcoders[msg.sender];
        EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[currentRound];

        // Set last round that transcoder called reward
        earningsPool.setCommission(t.rewardCut, t.feeShare);

        // If transcoder didn't receive stake updates during the previous round and hasn't called reward for > 1 round
        // the 'totalStake' on its 'EarningsPool' for the current round wouldn't be initialized
        // Thus we sync the the transcoder's stake to when it was last updated
        // 'updateTrancoderWithRewards()' will set the update round to 'currentRound +1' so this synchronization shouldn't occur frequently
        uint256 lastUpdateRound = t.lastActiveStakeUpdateRound;
        if (lastUpdateRound < currentRound) {
            earningsPool.setStake(t.earningsPoolPerRound[lastUpdateRound].totalStake);
        }

        // Create reward based on active transcoder's stake relative to the total active stake
        // rewardTokens = (current mintable tokens for the round * active transcoder stake) / total active stake
        uint256 rewardTokens = minter().createReward(earningsPool.totalStake, currentRoundTotalActiveStake);

        updateTranscoderWithRewards(msg.sender, rewardTokens, currentRound, _newPosPrev, _newPosNext);

        // Set last round that transcoder called reward
        t.lastRewardRound = currentRound;

        emit Reward(msg.sender, rewardTokens);
    }

    /**
     * @notice Returns pending bonded stake for a delegator from its lastClaimRound through an end round
     * @param _delegator Address of delegator
     * @param _endRound The last round to compute pending stake from
     * @return Pending bonded stake for '_delegator' since last claiming rewards
     */
    function pendingStake(address _delegator, uint256 _endRound) public view returns (uint256) {
        (uint256 stake, ) = pendingStakeAndFees(_delegator, _endRound);
        return stake;
    }

    /**
     * @notice Returns pending fees for a delegator from its lastClaimRound through an end round
     * @param _delegator Address of delegator
     * @param _endRound The last round to compute pending fees from
     * @return Pending fees for '_delegator' since last claiming fees
     */
    function pendingFees(address _delegator, uint256 _endRound) public view returns (uint256) {
        (, uint256 fees) = pendingStakeAndFees(_delegator, _endRound);
        return fees;
    }

    /**
     * @notice Returns total bonded stake for a transcoder
     * @param _transcoder Address of transcoder
     * @return total bonded stake for a delegator
     */
    function transcoderTotalStake(address _transcoder) public view returns (uint256) {
        return delegators[_transcoder].delegatedAmount;
    }

    /**
     * @notice Computes transcoder status
     * @param _transcoder Address of transcoder
     * @return registered or not registered transcoder status
     */
    function transcoderStatus(address _transcoder) public view returns (TranscoderStatus) {
        if (isRegisteredTranscoder(_transcoder)) return TranscoderStatus.Registered;
        return TranscoderStatus.NotRegistered;
    }

    /**
     * @notice Computes delegator status
     * @param _delegator Address of delegator
     * @return bonded, unbonded or pending delegator status
     */
    function delegatorStatus(address _delegator) public view returns (DelegatorStatus) {
        Delegator storage del = delegators[_delegator];

        if (del.bondedAmount == 0) {
            // Delegator unbonded all its tokens
            return DelegatorStatus.Unbonded;
        } else if (del.startRound > roundsManager().currentRound()) {
            // Delegator round start is in the future
            return DelegatorStatus.Pending;
        } else {
            // Delegator round start is now or in the past
            // del.startRound != 0 here because if del.startRound = 0 then del.bondedAmount = 0 which
            // would trigger the first if clause
            return DelegatorStatus.Bonded;
        }
    }

    /**
     * @notice Return transcoder information
     * @param _transcoder Address of transcoder
     * @return lastRewardRound Trancoder's last reward round
     * @return rewardCut Transcoder's reward cut
     * @return feeShare Transcoder's fee share
     * @return lastActiveStakeUpdateRound Round in which transcoder's stake was last updated while active
     * @return activationRound Round in which transcoder became active
     * @return deactivationRound Round in which transcoder will no longer be active
     * @return activeCumulativeRewards Transcoder's cumulative rewards that are currently active
     * @return cumulativeRewards Transcoder's cumulative rewards (earned via its active staked rewards and its reward cut)
     * @return cumulativeFees Transcoder's cumulative fees (earned via its active staked rewards and its fee share)
     * @return lastFeeRound Latest round that the transcoder received fees
     */
    function getTranscoder(address _transcoder)
        public
        view
        returns (
            uint256 lastRewardRound,
            uint256 rewardCut,
            uint256 feeShare,
            uint256 lastActiveStakeUpdateRound,
            uint256 activationRound,
            uint256 deactivationRound,
            uint256 activeCumulativeRewards,
            uint256 cumulativeRewards,
            uint256 cumulativeFees,
            uint256 lastFeeRound
        )
    {
        Transcoder storage t = transcoders[_transcoder];

        lastRewardRound = t.lastRewardRound;
        rewardCut = t.rewardCut;
        feeShare = t.feeShare;
        lastActiveStakeUpdateRound = t.lastActiveStakeUpdateRound;
        activationRound = t.activationRound;
        deactivationRound = t.deactivationRound;
        activeCumulativeRewards = t.activeCumulativeRewards;
        cumulativeRewards = t.cumulativeRewards;
        cumulativeFees = t.cumulativeFees;
        lastFeeRound = t.lastFeeRound;
    }

    /**
     * @notice Return transcoder's earnings pool for a given round
     * @param _transcoder Address of transcoder
     * @param _round Round number
     * @return rewardPool Reward pool for delegators (only used before LIP-36)
     * @return feePool Fee pool for delegators (only used before LIP-36)
     * @return totalStake Transcoder's total stake in '_round'
     * @return claimableStake Remaining stake that can be used to claim from the pool (only used before LIP-36)
     * @return transcoderRewardCut Transcoder's reward cut for '_round'
     * @return transcoderFeeShare Transcoder's fee share for '_round'
     * @return transcoderRewardPool Transcoder's rewards for '_round' (only used before LIP-36)
     * @return transcoderFeePool Transcoder's fees for '_round' (only used before LIP-36)
     * @return hasTranscoderRewardFeePool True if there is a split reward/fee pool for the transcoder (only used before LIP-36)
     * @return cumulativeRewardFactor The cumulative reward factor for delegator rewards calculation (only used after LIP-36)
     * @return cumulativeFeeFactor The cumulative fee factor for delegator fees calculation (only used after LIP-36)
     */
    function getTranscoderEarningsPoolForRound(address _transcoder, uint256 _round)
        public
        view
        returns (
            uint256 rewardPool,
            uint256 feePool,
            uint256 totalStake,
            uint256 claimableStake,
            uint256 transcoderRewardCut,
            uint256 transcoderFeeShare,
            uint256 transcoderRewardPool,
            uint256 transcoderFeePool,
            bool hasTranscoderRewardFeePool,
            uint256 cumulativeRewardFactor,
            uint256 cumulativeFeeFactor
        )
    {
        EarningsPool.Data storage earningsPool = transcoders[_transcoder].earningsPoolPerRound[_round];

        rewardPool = earningsPool.rewardPool;
        feePool = earningsPool.feePool;
        totalStake = earningsPool.totalStake;
        claimableStake = earningsPool.claimableStake;
        transcoderRewardCut = earningsPool.transcoderRewardCut;
        transcoderFeeShare = earningsPool.transcoderFeeShare;
        transcoderRewardPool = earningsPool.transcoderRewardPool;
        transcoderFeePool = earningsPool.transcoderFeePool;
        hasTranscoderRewardFeePool = earningsPool.hasTranscoderRewardFeePool;
        cumulativeRewardFactor = earningsPool.cumulativeRewardFactor;
        cumulativeFeeFactor = earningsPool.cumulativeFeeFactor;
    }

    /**
     * @notice Return delegator info
     * @param _delegator Address of delegator
     * @return total amount bonded by '_delegator'
     * @return amount of fees collected by '_delegator'
     * @return address '_delegator' has bonded to
     * @return total amount delegated to '_delegator'
     * @return round in which bond for '_delegator' became effective
     * @return round for which '_delegator' has last claimed earnings
     * @return ID for the next unbonding lock created for '_delegator'
     */
    function getDelegator(address _delegator)
        public
        view
        returns (
            uint256 bondedAmount,
            uint256 fees,
            address delegateAddress,
            uint256 delegatedAmount,
            uint256 startRound,
            uint256 lastClaimRound,
            uint256 nextUnbondingLockId
        )
    {
        Delegator storage del = delegators[_delegator];

        bondedAmount = del.bondedAmount;
        fees = del.fees;
        delegateAddress = del.delegateAddress;
        delegatedAmount = del.delegatedAmount;
        startRound = del.startRound;
        lastClaimRound = del.lastClaimRound;
        nextUnbondingLockId = del.nextUnbondingLockId;
    }

    /**
     * @notice Return delegator's unbonding lock info
     * @param _delegator Address of delegator
     * @param _unbondingLockId ID of unbonding lock
     * @return amount of stake locked up by unbonding lock
     * @return round in which 'amount' becomes available for withdrawal
     */
    function getDelegatorUnbondingLock(address _delegator, uint256 _unbondingLockId)
        public
        view
        returns (uint256 amount, uint256 withdrawRound)
    {
        UnbondingLock storage lock = delegators[_delegator].unbondingLocks[_unbondingLockId];

        return (lock.amount, lock.withdrawRound);
    }

    /**
     * @notice Returns max size of transcoder pool
     * @return transcoder pool max size
     */
    function getTranscoderPoolMaxSize() public view returns (uint256) {
        return transcoderPoolV2.getMaxSize();
    }

    /**
     * @notice Returns size of transcoder pool
     * @return transcoder pool current size
     */
    function getTranscoderPoolSize() public view returns (uint256) {
        return transcoderPoolV2.getSize();
    }

    /**
     * @notice Returns transcoder with most stake in pool
     * @return address for transcoder with highest stake in transcoder pool
     */
    function getFirstTranscoderInPool() public view returns (address) {
        return transcoderPoolV2.getFirst();
    }

    /**
     * @notice Returns next transcoder in pool for a given transcoder
     * @param _transcoder Address of a transcoder in the pool
     * @return address for the transcoder after '_transcoder' in transcoder pool
     */
    function getNextTranscoderInPool(address _transcoder) public view returns (address) {
        return transcoderPoolV2.getNext(_transcoder);
    }

    /**
     * @notice Return total bonded tokens
     * @return total active stake for the current round
     */
    function getTotalBonded() public view returns (uint256) {
        return currentRoundTotalActiveStake;
    }

    /**
     * @notice Return whether a transcoder is active for the current round
     * @param _transcoder Transcoder address
     * @return true if transcoder is active
     */
    function isActiveTranscoder(address _transcoder) public view returns (bool) {
        Transcoder storage t = transcoders[_transcoder];
        uint256 currentRound = roundsManager().currentRound();
        return t.activationRound <= currentRound && currentRound < t.deactivationRound;
    }

    /**
     * @notice Return whether a transcoder is registered
     * @param _transcoder Transcoder address
     * @return true if transcoder is self-bonded
     */
    function isRegisteredTranscoder(address _transcoder) public view returns (bool) {
        Delegator storage d = delegators[_transcoder];
        return d.delegateAddress == _transcoder && d.bondedAmount > 0;
    }

    /**
     * @notice Return whether an unbonding lock for a delegator is valid
     * @param _delegator Address of delegator
     * @param _unbondingLockId ID of unbonding lock
     * @return true if unbondingLock for ID has a non-zero withdraw round
     */
    function isValidUnbondingLock(address _delegator, uint256 _unbondingLockId) public view returns (bool) {
        // A unbonding lock is only valid if it has a non-zero withdraw round (the default value is zero)
        return delegators[_delegator].unbondingLocks[_unbondingLockId].withdrawRound > 0;
    }

    /**
     * @notice Return an EarningsPool.Data struct with the latest cumulative factors for a given round
     * @param _transcoder Storage pointer to a transcoder struct
     * @param _round The round to fetch the latest cumulative factors for
     * @return pool An EarningsPool.Data populated with the latest cumulative factors for _round
     */
    function latestCumulativeFactorsPool(Transcoder storage _transcoder, uint256 _round)
        internal
        view
        returns (EarningsPool.Data memory pool)
    {
        pool.cumulativeRewardFactor = _transcoder.earningsPoolPerRound[_round].cumulativeRewardFactor;
        pool.cumulativeFeeFactor = _transcoder.earningsPoolPerRound[_round].cumulativeFeeFactor;

        uint256 lastRewardRound = _transcoder.lastRewardRound;
        // Only use the cumulativeRewardFactor for lastRewardRound if lastRewardRound is before _round
        if (pool.cumulativeRewardFactor == 0 && lastRewardRound < _round) {
            pool.cumulativeRewardFactor = _transcoder.earningsPoolPerRound[lastRewardRound].cumulativeRewardFactor;
        }

        uint256 lastFeeRound = _transcoder.lastFeeRound;
        // Only use the cumulativeFeeFactor for lastFeeRound if lastFeeRound is before _round
        if (pool.cumulativeFeeFactor == 0 && lastFeeRound < _round) {
            pool.cumulativeFeeFactor = _transcoder.earningsPoolPerRound[lastFeeRound].cumulativeFeeFactor;
        }

        return pool;
    }

    /**
     * @notice Return a delegator's cumulative stake and fees using the LIP-36 earnings claiming algorithm
     * @param _transcoder Storage pointer to a transcoder struct for a delegator's delegate
     * @param _startRound The round for the start cumulative factors
     * @param _endRound The round for the end cumulative factors
     * @param _stake The delegator's initial stake before including earned rewards
     * @param _fees The delegator's initial fees before including earned fees
     * @return (cStake, cFees) where cStake is the delegator's cumulative stake including earned rewards and cFees is the delegator's cumulative fees including earned fees
     */
    function delegatorCumulativeStakeAndFees(
        Transcoder storage _transcoder,
        uint256 _startRound,
        uint256 _endRound,
        uint256 _stake,
        uint256 _fees
    ) internal view returns (uint256 cStake, uint256 cFees) {
        uint256 baseRewardFactor = MathUtils.percPoints(1, 1);

        // Fetch start cumulative factors
        EarningsPool.Data memory startPool;
        startPool.cumulativeRewardFactor = _transcoder.earningsPoolPerRound[_startRound].cumulativeRewardFactor;
        startPool.cumulativeFeeFactor = _transcoder.earningsPoolPerRound[_startRound].cumulativeFeeFactor;

        if (startPool.cumulativeRewardFactor == 0) {
            startPool.cumulativeRewardFactor = baseRewardFactor;
        }

        // Fetch end cumulative factors
        EarningsPool.Data memory endPool = latestCumulativeFactorsPool(_transcoder, _endRound);

        if (endPool.cumulativeRewardFactor == 0) {
            endPool.cumulativeRewardFactor = baseRewardFactor;
        }

        cFees = _fees.add(
            MathUtils.percOf(
                _stake,
                endPool.cumulativeFeeFactor.sub(startPool.cumulativeFeeFactor),
                startPool.cumulativeRewardFactor
            )
        );

        cStake = MathUtils.percOf(_stake, endPool.cumulativeRewardFactor, startPool.cumulativeRewardFactor);

        return (cStake, cFees);
    }

    /**
     * @notice Return the pending stake and fees for a delegator
     * @param _delegator Address of a delegator
     * @param _endRound The last round to claim earnings for when calculating the pending stake and fees
     * @return (stake, fees) where stake is the delegator's pending stake and fees is the delegator's pending fees
     */
    function pendingStakeAndFees(address _delegator, uint256 _endRound)
        internal
        view
        returns (uint256 stake, uint256 fees)
    {
        Delegator storage del = delegators[_delegator];
        Transcoder storage t = transcoders[del.delegateAddress];

        fees = del.fees;
        stake = del.bondedAmount;

        uint256 startRound = del.lastClaimRound.add(1);
        address delegateAddr = del.delegateAddress;
        bool isTranscoder = _delegator == delegateAddr;

        uint256 lip36Round = roundsManager().lipUpgradeRound(36);
        while (startRound <= _endRound && startRound <= lip36Round) {
            EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[startRound];

            // If earningsPool.hasTranscoderRewardFeePool is not set during lip36Round then the transcoder did not call
            // reward during lip36Round before the upgrade. In this case, if the transcoder calls reward in lip36Round
            // the delegator can use the LIP-36 earnings claiming algorithm to claim for lip36Round
            if (startRound == lip36Round && !earningsPool.hasTranscoderRewardFeePool) {
                break;
            }

            if (earningsPool.hasClaimableShares()) {
                // Calculate and add fee pool share from this round
                fees = fees.add(earningsPool.feePoolShare(stake, isTranscoder));
                // Calculate new bonded amount with rewards from this round. Updated bonded amount used
                // to calculate fee pool share in next round
                stake = stake.add(earningsPool.rewardPoolShare(stake, isTranscoder));
            }

            startRound = startRound.add(1);
        }

        // If the transcoder called reward during lip36Round the upgrade, then startRound = lip36Round
        // Otherwise, startRound = lip36Round + 1

        // If the start round is greater than the end round, we've already claimed for the end round so we do not
        // need to execute the LIP-36 earnings claiming algorithm. This could be the case if:
        // - _endRound < lip36Round i.e. we are not claiming through the lip36Round
        // - _endRound == lip36Round AND startRound = lip36Round + 1 i.e we already claimed through the lip36Round
        if (startRound > _endRound) {
            return (stake, fees);
        }

        // The LIP-36 earnings claiming algorithm uses the cumulative factors from the delegator's lastClaimRound i.e. startRound - 1
        // and from the specified _endRound
        (stake, fees) = delegatorCumulativeStakeAndFees(t, startRound.sub(1), _endRound, stake, fees);

        if (isTranscoder) {
            stake = stake.add(t.cumulativeRewards);
            fees = fees.add(t.cumulativeFees);
        }

        return (stake, fees);
    }

    /**
     * @dev Increase the total stake for a delegate and updates its 'lastActiveStakeUpdateRound'
     * @param _delegate The delegate to increase the stake for
     * @param _amount The amount to increase the stake for '_delegate' by
     */
    function increaseTotalStake(
        address _delegate,
        uint256 _amount,
        address _newPosPrev,
        address _newPosNext
    ) internal {
        if (isRegisteredTranscoder(_delegate)) {
            uint256 currStake = transcoderTotalStake(_delegate);
            uint256 newStake = currStake.add(_amount);
            uint256 currRound = roundsManager().currentRound();
            uint256 nextRound = currRound.add(1);

            // If the transcoder is already in the active set update its stake and return
            if (transcoderPoolV2.contains(_delegate)) {
                transcoderPoolV2.updateKey(_delegate, newStake, _newPosPrev, _newPosNext);
                nextRoundTotalActiveStake = nextRoundTotalActiveStake.add(_amount);
                Transcoder storage t = transcoders[_delegate];

                // currStake (the transcoder's delegatedAmount field) will reflect the transcoder's stake from lastActiveStakeUpdateRound
                // because it is updated every time lastActiveStakeUpdateRound is updated
                // The current active total stake is set to currStake to ensure that the value can be used in updateTranscoderWithRewards()
                // and updateTranscoderWithFees() when lastActiveStakeUpdateRound > currentRound
                if (t.lastActiveStakeUpdateRound < currRound) {
                    t.earningsPoolPerRound[currRound].setStake(currStake);
                }

                t.earningsPoolPerRound[nextRound].setStake(newStake);
                t.lastActiveStakeUpdateRound = nextRound;
            } else {
                // Check if the transcoder is eligible to join the active set in the update round
                tryToJoinActiveSet(_delegate, newStake, nextRound, _newPosPrev, _newPosNext);
            }
        }

        // Increase delegate's delegated amount
        delegators[_delegate].delegatedAmount = delegators[_delegate].delegatedAmount.add(_amount);
    }

    /**
     * @dev Decrease the total stake for a delegate and updates its 'lastActiveStakeUpdateRound'
     * @param _delegate The transcoder to decrease the stake for
     * @param _amount The amount to decrease the stake for '_delegate' by
     */
    function decreaseTotalStake(
        address _delegate,
        uint256 _amount,
        address _newPosPrev,
        address _newPosNext
    ) internal {
        if (transcoderPoolV2.contains(_delegate)) {
            uint256 currStake = transcoderTotalStake(_delegate);
            uint256 newStake = currStake.sub(_amount);
            uint256 currRound = roundsManager().currentRound();
            uint256 nextRound = currRound.add(1);

            transcoderPoolV2.updateKey(_delegate, newStake, _newPosPrev, _newPosNext);
            nextRoundTotalActiveStake = nextRoundTotalActiveStake.sub(_amount);
            Transcoder storage t = transcoders[_delegate];

            // currStake (the transcoder's delegatedAmount field) will reflect the transcoder's stake from lastActiveStakeUpdateRound
            // because it is updated every time lastActiveStakeUpdateRound is updated
            // The current active total stake is set to currStake to ensure that the value can be used in updateTranscoderWithRewards()
            // and updateTranscoderWithFees() when lastActiveStakeUpdateRound > currentRound
            if (t.lastActiveStakeUpdateRound < currRound) {
                t.earningsPoolPerRound[currRound].setStake(currStake);
            }

            t.lastActiveStakeUpdateRound = nextRound;
            t.earningsPoolPerRound[nextRound].setStake(newStake);
        }

        // Decrease old delegate's delegated amount
        delegators[_delegate].delegatedAmount = delegators[_delegate].delegatedAmount.sub(_amount);
    }

    /**
     * @dev Tries to add a transcoder to active transcoder pool, evicts the active transcoder with the lowest stake if the pool is full
     * @param _transcoder The transcoder to insert into the transcoder pool
     * @param _totalStake The total stake for '_transcoder'
     * @param _activationRound The round in which the transcoder should become active
     */
    function tryToJoinActiveSet(
        address _transcoder,
        uint256 _totalStake,
        uint256 _activationRound,
        address _newPosPrev,
        address _newPosNext
    ) internal {
        uint256 pendingNextRoundTotalActiveStake = nextRoundTotalActiveStake;

        if (transcoderPoolV2.isFull()) {
            address lastTranscoder = transcoderPoolV2.getLast();
            uint256 lastStake = transcoderTotalStake(lastTranscoder);

            // If the pool is full and the transcoder has less stake than the least stake transcoder in the pool
            // then the transcoder is unable to join the active set for the next round
            if (_totalStake <= lastStake) {
                return;
            }

            // Evict the least stake transcoder from the active set for the next round
            // Not zeroing 'Transcoder.lastActiveStakeUpdateRound' saves gas (5k when transcoder is evicted and 20k when transcoder is reinserted)
            // There should be no side-effects as long as the value is properly updated on stake updates
            // Not zeroing the stake on the current round's 'EarningsPool' saves gas and should have no side effects as long as
            // 'EarningsPool.setStake()' is called whenever a transcoder becomes active again.
            transcoderPoolV2.remove(lastTranscoder);
            transcoders[lastTranscoder].deactivationRound = _activationRound;
            pendingNextRoundTotalActiveStake = pendingNextRoundTotalActiveStake.sub(lastStake);

            emit TranscoderDeactivated(lastTranscoder, _activationRound);
        }

        transcoderPoolV2.insert(_transcoder, _totalStake, _newPosPrev, _newPosNext);
        pendingNextRoundTotalActiveStake = pendingNextRoundTotalActiveStake.add(_totalStake);
        Transcoder storage t = transcoders[_transcoder];
        t.lastActiveStakeUpdateRound = _activationRound;
        t.activationRound = _activationRound;
        t.deactivationRound = MAX_FUTURE_ROUND;
        t.earningsPoolPerRound[_activationRound].setStake(_totalStake);
        nextRoundTotalActiveStake = pendingNextRoundTotalActiveStake;
        emit TranscoderActivated(_transcoder, _activationRound);
    }

    /**
     * @dev Remove a transcoder from the pool and deactivate it
     */
    function resignTranscoder(address _transcoder) internal {
        // Not zeroing 'Transcoder.lastActiveStakeUpdateRound' saves gas (5k when transcoder is evicted and 20k when transcoder is reinserted)
        // There should be no side-effects as long as the value is properly updated on stake updates
        // Not zeroing the stake on the current round's 'EarningsPool' saves gas and should have no side effects as long as
        // 'EarningsPool.setStake()' is called whenever a transcoder becomes active again.
        transcoderPoolV2.remove(_transcoder);
        nextRoundTotalActiveStake = nextRoundTotalActiveStake.sub(transcoderTotalStake(_transcoder));
        uint256 deactivationRound = roundsManager().currentRound().add(1);
        transcoders[_transcoder].deactivationRound = deactivationRound;
        emit TranscoderDeactivated(_transcoder, deactivationRound);
    }

    /**
     * @dev Update a transcoder with rewards and update the transcoder pool with an optional list hint if needed.
     * See SortedDoublyLL.sol for details on list hints
     * @param _transcoder Address of transcoder
     * @param _rewards Amount of rewards
     * @param _round Round that transcoder is updated
     * @param _newPosPrev Address of previous transcoder in pool if the transcoder is in the pool
     * @param _newPosNext Address of next transcoder in pool if the transcoder is in the pool
     */
    function updateTranscoderWithRewards(
        address _transcoder,
        uint256 _rewards,
        uint256 _round,
        address _newPosPrev,
        address _newPosNext
    ) internal {
        Transcoder storage t = transcoders[_transcoder];
        EarningsPool.Data storage earningsPool = t.earningsPoolPerRound[_round];
        EarningsPool.Data storage prevEarningsPool = t.earningsPoolPerRound[t.lastRewardRound];

        t.activeCumulativeRewards = t.cumulativeRewards;

        uint256 transcoderCommissionRewards = MathUtils.percOf(_rewards, earningsPool.transcoderRewardCut);
        uint256 delegatorsRewards = _rewards.sub(transcoderCommissionRewards);
        // Calculate the rewards earned by the transcoder's earned rewards
        uint256 transcoderRewardStakeRewards = MathUtils.percOf(
            delegatorsRewards,
            t.activeCumulativeRewards,
            earningsPool.totalStake
        );
        // Track rewards earned by the transcoder based on its earned rewards and rewardCut
        t.cumulativeRewards = t.cumulativeRewards.add(transcoderRewardStakeRewards).add(transcoderCommissionRewards);
        // Update cumulative reward factor with new rewards
        // The cumulativeRewardFactor is used to calculate rewards for all delegators including the transcoder (self-delegated)
        // Note that delegatorsRewards includes transcoderRewardStakeRewards, but no delegator will claim that amount using
        // the earnings claiming algorithm and instead that amount is accounted for in the transcoder's cumulativeRewards field
        earningsPool.updateCumulativeRewardFactor(prevEarningsPool, delegatorsRewards);
        // Update transcoder's total stake with rewards
        increaseTotalStake(_transcoder, _rewards, _newPosPrev, _newPosNext);
    }

    /**
     * @dev Update a delegator with token pools shares from its lastClaimRound through a given round
     * @param _delegator Delegator address
     * @param _endRound The last round for which to update a delegator's stake with earnings pool shares
     * @param _lastClaimRound The round for which a delegator has last claimed earnings
     */
    function updateDelegatorWithEarnings(
        address _delegator,
        uint256 _endRound,
        uint256 _lastClaimRound
    ) internal {
        Delegator storage del = delegators[_delegator];
        uint256 startRound = _lastClaimRound.add(1);
        uint256 currentBondedAmount = del.bondedAmount;
        uint256 currentFees = del.fees;

        uint256 lip36Round = roundsManager().lipUpgradeRound(36);

        // Only will have earnings to claim if you have a delegate
        // If not delegated, skip the earnings claim process
        if (del.delegateAddress != address(0)) {
            if (startRound <= lip36Round) {
                // Cannot claim earnings for more than maxEarningsClaimsRounds before LIP-36
                // This is a number to cause transactions to fail early if
                // we know they will require too much gas to loop through all the necessary rounds to claim earnings
                // The user should instead manually invoke `claimEarnings` to split up the claiming process
                // across multiple transactions
                uint256 endLoopRound = _endRound <= lip36Round ? _endRound : lip36Round;
                require(
                    endLoopRound.sub(_lastClaimRound) <= maxEarningsClaimsRounds,
                    ""too many rounds to claim through""
                );
            }

            (currentBondedAmount, currentFees) = pendingStakeAndFees(_delegator, _endRound);

            // Check whether the endEarningsPool is initialised
            // If it is not initialised set it's cumulative factors so that they can be used when a delegator
            // next claims earnings as the start cumulative factors (see delegatorCumulativeStakeAndFees())
            Transcoder storage t = transcoders[del.delegateAddress];
            EarningsPool.Data storage endEarningsPool = t.earningsPoolPerRound[_endRound];
            if (endEarningsPool.cumulativeRewardFactor == 0) {
                endEarningsPool.cumulativeRewardFactor = t
                    .earningsPoolPerRound[t.lastRewardRound]
                    .cumulativeRewardFactor;
            }
            if (endEarningsPool.cumulativeFeeFactor == 0) {
                endEarningsPool.cumulativeFeeFactor = t.earningsPoolPerRound[t.lastFeeRound].cumulativeFeeFactor;
            }

            if (del.delegateAddress == _delegator) {
                t.cumulativeFees = 0;
                t.cumulativeRewards = 0;
                // activeCumulativeRewards is not cleared here because the next reward() call will set it to cumulativeRewards
            }
        }

        emit EarningsClaimed(
            del.delegateAddress,
            _delegator,
            currentBondedAmount.sub(del.bondedAmount),
            currentFees.sub(del.fees),
            startRound,
            _endRound
        );

        del.lastClaimRound = _endRound;
        // Rewards are bonded by default
        del.bondedAmount = currentBondedAmount;
        del.fees = currentFees;
    }

    /**
     * @dev Update the state of a delegator and its delegate by processing a rebond using an unbonding lock and update the transcoder pool with an optional
     * list hint if needed. See SortedDoublyLL.sol for details on list hints
     * @param _delegator Address of delegator
     * @param _unbondingLockId ID of unbonding lock to rebond with
     * @param _newPosPrev Address of previous transcoder in pool if the delegate is already in or joins the pool
     * @param _newPosNext Address of next transcoder in pool if the delegate is already in or joins the pool
     */
    function processRebond(
        address _delegator,
        uint256 _unbondingLockId,
        address _newPosPrev,
        address _newPosNext
    ) internal {
        Delegator storage del = delegators[_delegator];
        UnbondingLock storage lock = del.unbondingLocks[_unbondingLockId];

        require(isValidUnbondingLock(_delegator, _unbondingLockId), ""invalid unbonding lock ID"");

        uint256 amount = lock.amount;
        // Increase delegator's bonded amount
        del.bondedAmount = del.bondedAmount.add(amount);

        // Delete lock
        delete del.unbondingLocks[_unbondingLockId];

        increaseTotalStake(del.delegateAddress, amount, _newPosPrev, _newPosNext);

        emit Rebond(del.delegateAddress, _delegator, _unbondingLockId, amount);
    }

    /**
     * @dev Return LivepeerToken interface
     * @return Livepeer token contract registered with Controller
     */
    function livepeerToken() internal view returns (ILivepeerToken) {
        return ILivepeerToken(controller.getContract(keccak256(""LivepeerToken"")));
    }

    /**
     * @dev Return Minter interface
     * @return Minter contract registered with Controller
     */
    function minter() internal view returns (IMinter) {
        return IMinter(controller.getContract(keccak256(""Minter"")));
    }

    /**
     * @dev Return RoundsManager interface
     * @return RoundsManager contract registered with Controller
     */
    function roundsManager() internal view returns (IRoundsManager) {
        return IRoundsManager(controller.getContract(keccak256(""RoundsManager"")));
    }

    function _onlyTicketBroker() internal view {
        require(msg.sender == controller.getContract(keccak256(""TicketBroker"")), ""caller must be TicketBroker"");
    }

    function _onlyRoundsManager() internal view {
        require(msg.sender == controller.getContract(keccak256(""RoundsManager"")), ""caller must be RoundsManager"");
    }

    function _onlyVerifier() internal view {
        require(msg.sender == controller.getContract(keccak256(""Verifier"")), ""caller must be Verifier"");
    }

    function _currentRoundInitialized() internal view {
        require(roundsManager().currentRoundInitialized(), ""current round is not initialized"");
    }

    function _autoClaimEarnings() internal {
        uint256 currentRound = roundsManager().currentRound();
        uint256 lastClaimRound = delegators[msg.sender].lastClaimRound;
        if (lastClaimRound < currentRound) {
            updateDelegatorWithEarnings(msg.sender, currentRound, lastClaimRound);
        }
    }
}
"".
Ideas: "" Unchecked Low-level Calls Identified.

VULNERABILITY NAME: Unchecked Low-level Call in `withdrawStake`
'''
In the `withdrawStake` function, the contract calls `minter().trustedTransferTokens(msg.sender, amount);` which is a low-level call to transfer tokens to the delegator. This call does not"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Transactions Order Dependence. Transactions Order Dependence vulnerabilities can result in unintended consequences and create opportunities for malicious actors to exploit transaction sequencing.
Please conduct a thorough analysis, considering the following information:
1. Review the contract's code logic to identify any potential areas where the order of transaction execution might have an impact on the contract's behavior.

2. Examine critical functions, particularly those involving fund transfers or resource allocation, to ensure they are not susceptible to Transactions Order Dependence.

3. Investigate scenarios in which gas prices can be manipulated to change the order of transaction execution.

If you identify Transactions Order Dependence, respond with: """,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
