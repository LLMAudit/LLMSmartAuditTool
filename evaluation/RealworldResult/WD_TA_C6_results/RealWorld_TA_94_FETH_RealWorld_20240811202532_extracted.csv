Integer Overflow/Underflow Identified,Reentrancy Identified,Unchecked External Calls Identified,Unchecked Low-level Calls Identified,Transactions Order Dependence Identified,Timestamp Manipulation Identified,Predictable Randomness Identified,Unsafe `tx.origin` Identified,Unsafe Suicide Identified,Gas Limit Identified,Price Manipulation Identified,Assumption of Fixed-Length Array Identified,Lack of Withdrawal Function Identified,Lack of Authorization Identified,Potential Data Inconsistency Identified,Hash Collision Identified,Uninitialized Return Variable Identified,Misdeclared Constructor Identified,Missing 'onlyOwner' Modifier Identified,Misuse of `msg.value` within a Loop Identified,Precision Loss Identified,Redundant Conditional Check Identified,External Oracle Dependency Identified,Ownership Hijacking Identified,Centralization Risk Identified,Incorrect Funding Rate Calculation Identified,Flash Loan Fee Manipulation Identified,Misuse of Mapping Getter Identified,Lack of Getter Function Implementation Identified,Unnecessary Comparison Identified,Inconsistent Initialization Identified,Potential Inconsistency in Yield Source Swapping Identified,Incorrect Signer Verification Identified,Order of Inheritance Initialization Identified,Impracticality of Exact Match Identified,Inconsistent Base Tokens Identified,Handling Partial Withdrawals Identified,Fallback Function Identified,Unlimited Token Approval Identified,Lack of Input Validation Identified,DoS Vulnerability Identified
"<INFO> Integer Overflow/Underflow Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Reentrancy Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unchecked External Calls Identified."".
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unchecked Low-level Calls Identified."".
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Transactions Order Dependence Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades
'''
```
If you don't find any Transactions Order Dependence vulnerabilities, respond only with: ""","<INFO> Timestamp Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Predictable Randomness Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unsafe `tx.origin` Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unsafe Suicide Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Lack of Restriction on `selfdestruct` is found, respond only with: ""","<INFO> Gas Limit Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Price Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Assumption of Fixed-Length Array Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Withdrawal Function Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If a secure withdrawal function is found and no issues are identified, respond only with: ""","<INFO> Lack of Authorization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Lack of Authorization vulnerabilities are found, respond only with: ""","<INFO> Potential Data Inconsistency Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Potential Data Inconsistency vulnerabilities are found, respond only with: ""","<INFO> Hash Collision Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Hash Collision vulnerabilities are found, respond only with: ""","<INFO> Uninitialized Return Variable Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Uninitialized Return Variable vulnerabilities are found, respond only with: ""","<INFO> Misdeclared Constructor Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Misdeclared Constructor vulnerabilities are found, respond only with: ""","<INFO> Missing 'onlyOwner' Modifier Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Misuse of `msg.value` within a Loop Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Precision Loss Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Redundant Conditional Check Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> External Oracle Dependency Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: """,,"<INFO> Centralization Risk Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Incorrect Funding Rate Calculation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Flash Loan Fee Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Misuse of Mapping Getter Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Getter Function Implementation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unnecessary Comparison Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Inconsistent Initialization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Potential Inconsistency in Yield Source Swapping Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Incorrect Signer Verification Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Order of Inheritance Initialization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Impracticality of Exact Match Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Inconsistent Base Tokens Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Handling Partial Withdrawals Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Fallback Function Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unlimited Token Approval Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Input Validation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> DoS Vulnerability Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades.
'''
```
If you don't find any vulnerabilities, respond only with: """
,,"<INFO> Unchecked External Calls Identified.

```
REENTRANCY VULNERABILITY
'''
The contract contains several external calls to transfer Ether using `payable(msg.sender).sendValue(amount);` and `to.sendValue(amount);` after state changes have been made. This can lead to reentrancy attacks, as the external call can invoke a fallback function in the recipient contract, allowing it to call back into the original contract before the state changes are finalized.

For example, in the `marketWithdrawFrom` and `marketWithdrawLocked` functions, the contract first updates the state by deducting the balance and then makes an external call to transfer Ether. If the recipient contract is malicious and re-enters the original contract during this process, it could manipulate the state in an unintended manner.

To mitigate this vulnerability, the contract should implement the Checks-Effects-Interactions pattern. This involves:
1. Performing all necessary checks (e.g., ensuring sufficient balance).
2. Updating the state variables (e.g., deducting balances).
3. Making external calls (e.g., transferring Ether).

Alternatively, using a ReentrancyGuard modifier can help prevent reentrant calls by blocking any function that has already been called until it completes execution.
'''
```

[2024-11-08 20:26:00 INFO] **[Seminar Conclusion]**:

 ","<INFO> Unchecked Low-level Calls Identified.

```
UNCHECKED LOW-LEVEL CALL VULNERABILITY
'''
The contract uses the `sendValue` function from the `AddressUpgradeable` library, which is a low-level call to transfer ETH. This function does not check for the success of the call, meaning if the transfer fails (for example, if the recipient is a contract that reverts on receiving ETH), the transaction will not revert, and the state of the contract may become inconsistent. This can lead to a loss of funds or unexpected behavior.

Recommended Mitigation/Fix:
Instead of using `sendValue`, use a pattern that checks for the success of the call. For example, you can use the following pattern to ensure that the transfer succeeds:

```solidity
(bool success, ) = to.call{value: amount}("""");
require(success, ""Transfer failed"");
```
This ensures that if the transfer fails, the transaction will revert, maintaining the integrity of the contract's state.
'''
```

```
UNCHECKED LOW-LEVEL CALL VULNERABILITY
'''
The contract also uses the `sendValue` function in the `marketWithdrawFrom` and `marketWithdrawLocked` functions. Similar to the previous case, these calls do not check if the ETH transfer was successful. If the recipient contract reverts during the transfer, it could lead to a loss of funds or inconsistent state.

Recommended Mitigation/Fix:
Implement a check for the success of the ETH transfer as shown below:

```solidity
(bool success, ) = msg.sender.call{value: amount}("""");
require(success, ""Transfer failed"");
```
This will ensure that the transaction reverts if the ETH transfer fails, preventing any potential loss of funds.
'''
```

[2024-11-08 20:26:05 INFO] **[Seminar Conclusion]**:

 ","<INFO> Transactions Order Dependence Identified.

VULNERABILITY NAME: Transactions Order Dependence
'''
The contract has several critical functions that involve fund transfers and resource allocation, particularly in the `marketWithdrawFrom` and `marketWithdrawLocked` functions. These functions allow the Foundation market to withdraw funds from users' accounts. If multiple transactions are sent in quick succession, a malicious actor could exploit the order of these transactions to manipulate the state of the contract.

For instance, if a user has a balance that is close to being exhausted and a malicious actor sends a transaction to withdraw funds just before the user sends a transaction to deposit more funds, the malicious actor could potentially withdraw funds that the user intended to use. This could lead to a situation where the user is unable to access their funds due to the order of transactions being manipulated.

Recommended Mitigation/Fix:
To mitigate this risk, implement a mechanism that locks the user's account during critical operations such as withdrawals or deposits. This could be achieved by introducing a state variable that indicates whether a transaction is in progress for a user. If a transaction is in progress, any subsequent transactions from that user should be rejected until the first transaction is completed. This ensures that the order of transactions cannot be exploited by malicious actors.
'''

[2024-11-08 20:26:10 INFO] **[Seminar Conclusion]**:

 ","<INFO> Timestamp Manipulation Identified.
```
VULNERABILITY NAME: Timestamp Manipulation
'''
The contract relies on block timestamps in several critical functions, particularly in the `_marketLockupFor` function where it calculates the expiration of lockup periods using `block.timestamp`. This reliance on block timestamps can be exploited by miners, who can manipulate the timestamp of the block they mine to influence the outcome of time-based conditions. For example, if a miner knows that a lockup period is about to expire, they could manipulate the timestamp to extend the lockup period or to create an advantage in a time-sensitive transaction.

Recommended Mitigation/Fix:
To mitigate this risk, avoid using `block.timestamp` for critical decisions. Instead, consider using block numbers or implementing a more robust mechanism that includes a time oracle or a decentralized time source. Additionally, implement checks to ensure that the timestamp used is within a reasonable range of the current block time to prevent manipulation.
'''
```

[2024-11-08 20:26:14 INFO] **[Seminar Conclusion]**:

 ",,,,"<INFO> Gas Limit Identified.

**Lack of Gas Limit Considerations**
'''
The function `_freeFromEscrow` contains a while loop that iterates through the escrow buckets until it finds an expired bucket or an empty bucket. If there are many buckets (up to 25 as per the contract's design), and if the first bucket is not expired, the loop could potentially iterate many times, leading to out-of-gas errors if the gas limit is exceeded. This could result in failed transactions for users trying to free their funds from escrow.

To mitigate this, consider implementing a maximum iteration limit within the loop to prevent excessive gas consumption. For example, you could introduce a counter that breaks the loop after a certain number of iterations, ensuring that the function does not run indefinitely.

Additionally, consider using a more gas-efficient data structure or approach to manage the escrow buckets, such as maintaining a pointer to the first expired bucket instead of iterating through all buckets.
'''

**Potential Denial-of-Service (DoS) Vulnerability**
'''
The same function `_freeFromEscrow` could be exploited by a malicious actor who fills up the escrow buckets without allowing them to expire. This could lead to a situation where legitimate users cannot free their funds, effectively causing a denial-of-service for those users. 

To mitigate this risk, implement a mechanism to limit the number of active escrow buckets or enforce a time-based expiration policy that automatically clears expired buckets. This could be done by periodically checking and removing expired buckets during transactions or by implementing a function that can be called to clean up expired buckets.
'''

[2024-11-08 20:26:28 INFO] **[Seminar Conclusion]**:

 ",,"<INFO> Assumption of Fixed-Length Array Identified.

VULNERABILITY NAME: Assumption of Fixed-Length Array in `getLockups`
'''
The `getLockups` function assumes that the number of lockup buckets for an account will not exceed a certain limit (256 bits) and allocates arrays `expiries` and `amounts` based on the count of lockups found. However, if the number of lockups exceeds the expected count, this could lead to incorrect data being processed or even out-of-bounds errors when accessing the arrays. The function does not have a safeguard to ensure that the number of lockups does not exceed the allocated array size.

Recommended Mitigation:
1. Implement a check to ensure that the number of lockups does not exceed the maximum size of the arrays before allocating them.
2. Consider using a dynamic array (e.g., `memory` array) to handle varying lengths, or use a more robust data structure that can accommodate the number of lockups without risking overflow or out-of-bounds access.
'''

VULNERABILITY NAME: Assumption of Fixed-Length Array in `totalBalanceOf`
'''
The `totalBalanceOf` function also assumes that the number of lockup buckets will not exceed a certain limit when summing the total balance. Similar to `getLockups`, if the number of lockups exceeds the expected count, it could lead to incorrect calculations or out-of-bounds errors.

Recommended Mitigation:
1. Implement a check to ensure that the number of lockups does not exceed the maximum size of the expected buckets.
2. Use a dynamic array or a loop that can handle varying lengths without risking overflow or incorrect data processing.
'''

[2024-11-08 20:26:38 INFO] **[Seminar Conclusion]**:

 ",,,"<INFO> Potential Data Inconsistency Identified.
```
POTENTIAL DATA INCONSISTENCY
'''
The contract contains several areas where data is manipulated, particularly in the handling of locked balances and account information. One notable area is in the `_freeFromEscrow` function, where the `accountInfo.lockups.del(escrowIndex)` operation is performed to delete a lockup entry. If the deletion of the lockup does not correctly update the `lockupStartIndex`, it may lead to inconsistencies in the data being accessed in subsequent calls. This could result in the contract referencing outdated or incorrect lockup data.

Additionally, in the `_marketLockupFor` function, the logic for adding to locked escrow relies on the assumption that the `escrowIndex` will always point to a valid entry. If the index is not managed correctly, it could lead to accessing uninitialized or incorrect data.

To mitigate this, it is recommended to implement checks after modifying the `lockupStartIndex` to ensure that it points to a valid entry. Also, consider adding assertions or require statements to validate the state of the data before performing operations that depend on it.
'''
```

[2024-11-08 20:26:53 INFO] **[Seminar Conclusion]**:

 ",,,,,,"<INFO> Precision Loss Identified.

VULNERABILITY NAME: Loss of Precision in Arithmetic Operations
'''
The contract performs arithmetic operations using unsigned integers, particularly in the `_marketLockupFor` function where it calculates the expiration timestamp using the `ceilDiv` method. This method can lead to precision loss when dealing with fractional values, especially if the `lockupInterval` is not a perfect divisor of the `lockupDuration`. The result of such operations can lead to incorrect expiration timestamps, which may affect the lockup functionality and user experience.

To mitigate this issue, ensure that all arithmetic operations that could result in fractional values are handled with appropriate scaling. For example, consider using a fixed-point arithmetic library or scaling values before performing division to maintain precision. Additionally, validate that the `lockupInterval` is set correctly to avoid potential precision loss in calculations.
'''

[2024-11-08 20:27:12 INFO] **[Seminar Conclusion]**:

 ","<INFO> Redundant Conditional Check Identified.

VULNERABILITY NAME: Redundant Conditional Checks
'''
In the `depositFor` function, there is a check for `msg.value == 0` which reverts with `FETH_Must_Deposit_Non_Zero_Amount()`. This check is redundant because the `deposit` function, which calls `depositFor`, already ensures that `msg.value` is non-zero when it is called. Therefore, the check in `depositFor` is unnecessary and adds additional gas costs without providing any additional safety.

To mitigate this issue, you can remove the check for `msg.value == 0` in the `depositFor` function, as it is already guaranteed by the calling function.
'''

VULNERABILITY NAME: Redundant Conditional Checks
'''
In the `_marketLockupFor` function, there is a check for `msg.value < amount` followed by a check for `msg.value != amount`. If `msg.value` is less than `amount`, it is already implied that `msg.value` cannot equal `amount`. Therefore, the second check is redundant and can be removed.

To mitigate this issue, you can simplify the logic by keeping only the check for `msg.value < amount` and removing the `msg.value != amount` check.
'''

[2024-11-08 20:27:17 INFO] **[Seminar Conclusion]**:

 ",,,"<INFO> Centralization Risk Identified.

```
Centralized Control via Single Address
'''
The contract has a modifier `onlyFoundationMarket` that restricts access to certain functions (e.g., `marketChangeLockup`, `marketLockupFor`, `marketUnlockFor`, `marketWithdrawFrom`, and `marketWithdrawLocked`) to a single address, `foundationMarket`. This centralizes control over critical operations related to managing lockups and withdrawals of funds. If the `foundationMarket` address is compromised, an attacker could potentially manipulate the lockup and withdrawal processes, leading to unauthorized access to user funds.

Recommended Mitigation:
1. Implement a multi-signature wallet for the `foundationMarket` address. This would require multiple parties to approve any critical operations, reducing the risk of a single point of failure.
2. Consider introducing a governance mechanism where stakeholders can vote on changes to critical parameters or the address of the `foundationMarket`, ensuring that control is distributed among multiple parties rather than centralized in one address.
'''
```

```
Lack of Decentralized Governance
'''
The contract lacks any form of decentralized governance or community involvement in decision-making processes. All critical functions are controlled by the `foundationMarket` address, which may not represent the interests of all stakeholders. This could lead to decisions that favor the controlling entity at the expense of users.

Recommended Mitigation:
1. Introduce a governance token that allows users to participate in decision-making processes, such as changing the `foundationMarket` address or modifying critical parameters of the contract.
2. Implement a voting mechanism where stakeholders can propose and vote on changes, ensuring that the contract evolves in a way that reflects the interests of its users.
'''
```

[2024-11-08 20:27:29 INFO] **[Seminar Conclusion]**:

 ",,,,,,,,,,,,,,,"<INFO> Lack of Input Validation Identified.

**VULNERABILITY NAME or TYPE**
'''
1. **Zero Address Validation**
   The function `_marketLockupFor` does not properly validate the `account` parameter. If the `account` is set to the zero address (address(0)), it will revert with a specific error, but this check should be more robust to prevent any unintended behavior before the function proceeds with further logic. The zero address should not be allowed to be passed as a valid account for locking up tokens.

   **Recommended Mitigation/Fix:**
   Ensure that the zero address check is performed at the beginning of the function to avoid any further processing if an invalid address is provided. This is already implemented, but it should be emphasized that all functions that accept addresses should include this validation.

2. **Lockup Amount Validation**
   In the `_marketLockupFor` function, while there is a check for `amount == 0`, it is crucial to ensure that the amount being locked up does not exceed the user's available balance. If a user attempts to lock up an amount greater than their available balance, it will revert, but this could lead to confusion or unexpected behavior if not handled gracefully.

   **Recommended Mitigation/Fix:**
   Before proceeding with the lockup logic, explicitly check that the `amount` is less than or equal to the user's available balance. This will provide clearer feedback to the user and prevent unnecessary state changes.

3. **Allowance Validation**
   In the `_deductAllowanceFrom` function, while there is a check for the allowance being less than the required amount, it allows for unlimited approval (using `type(uint256).max`). This can lead to potential abuse if a malicious contract is approved to spend tokens without proper checks.

   **Recommended Mitigation/Fix:**
   Implement a mechanism to limit the maximum allowance that can be set, or require explicit checks on the allowance before allowing transfers. This will prevent scenarios where a malicious actor could exploit unlimited approvals.

4. **Escrow Expiration Validation**
   In the `_removeFromLockedBalance` function, while there is a check for the expiration of the escrow, there is no validation to ensure that the `amount` being removed does not exceed the total amount locked in that escrow bucket. This could lead to unexpected behavior if the wrong amount is specified.

   **Recommended Mitigation/Fix:**
   Before attempting to remove an amount from the locked balance, validate that the `amount` is less than or equal to the `totalAmount` in the escrow bucket. This will prevent attempts to unlock more tokens than are actually locked.

5. **General Input Validation**
   Several functions, such as `withdrawFrom`, do not validate that the `to` address is not the zero address before proceeding with the transfer. This could lead to tokens being sent to an invalid address.

   **Recommended Mitigation/Fix:**
   Implement checks at the beginning of functions that involve transfers to ensure that the `to` address is not the zero address and is a valid address. This will help prevent accidental loss of tokens.
'''

[2024-11-08 20:28:18 INFO] **[Seminar Conclusion]**:

 ",
,,"<INFO> Unchecked External Calls Identified.

```
REENTRANCY VULNERABILITY
'''
The contract contains several external calls to transfer Ether using `payable(msg.sender).sendValue(amount);` and `to.sendValue(amount);` after state changes have been made. This can lead to reentrancy attacks, as the external call can invoke a fallback function in the recipient contract, allowing it to call back into the original contract before the state changes are finalized.

For example, in the `marketWithdrawFrom` and `marketWithdrawLocked` functions, the contract first updates the state by deducting the balance and then makes an external call to transfer Ether. If the recipient contract is malicious and re-enters the original contract during this process, it could manipulate the state in an unintended manner.

To mitigate this vulnerability, the contract should implement the Checks-Effects-Interactions pattern. This involves:
1. Performing all necessary checks (e.g., ensuring sufficient balance).
2. Updating the state variables (e.g., deducting balances).
3. Making external calls (e.g., transferring Ether).

Alternatively, using a ReentrancyGuard modifier can help prevent reentrant calls by blocking any function that has already been called until it completes execution.
'''
```

[2024-11-08 20:26:00 INFO] **[Execute Detail]**

execute SimplePhase:[UncheckedLowLevelCallDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-11-08 20:26:00 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol""; import ""@openzeppelin/contracts/utils/math/Math.sol""; import ""./libraries/LockedBalance.sol""; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = ""Foundation Wrapped Ether"";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = ""FETH""; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""Identify all Unchecked Low-level Call vulnerabilities in the provided Solidity contract."". Ideas: ""Look for instances where low-level calls (such as call, delegatecall, send) are made without proper error handling or checks to ensure the calls succeed."". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Unchecked Low-level Calls. There are three cases, the contract may have Unchecked Low-level Calls: 1. When low-level calls (such as call, delegatecall, send) are not adequately checked, the calling contract may execute code in the external contract without ensuring the external contract's behavior is as expected. 2. When the external contract's code is not trusted or its behavior is unpredictable, it can compromise the overall security and stability of the calling contract. 3. When the execution of low-level function calls fails, the contract does not handle errors. The contract does not provide any mechanism to handle or revert the transaction, potentially resulting in a loss of funds. If you identify Unchecked Low-level Calls, please respond with: "" Unchecked Low-level Calls Identified."". For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If you don't find any vulnerabilities, respond only with: "" NO Unchecked Low-level Calls."" |
| **phase_name** | UncheckedLowLevelCallDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '/\n  ･\n   \u3000★\n      ･ ｡\n        \u3000･\u3000ﾟ☆ ｡\n  \u3000\u3000\u3000 \u3000★ ﾟ･｡ *  ｡\n          \u3000\u3000 ☆ ｡･ﾟ.｡\n      \u3000\u3000\u3000ﾟ .｡☆｡★\u3000･\n\u200b\n                      .-:::::-.              -::---...```\n-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy\n-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo\n                                              ``\n   *\u3000\n      ･ ｡\n\u3000\u3000\u3000\u3000･\u3000\u3000ﾟ☆ ｡\n  \u3000\u3000\u3000 *\u3000★ ﾟ･｡ *  ｡\n          \u3000\u3000* ☆ ｡･ﾟ*.｡\n      \u3000\u3000\u3000ﾟ *.｡☆｡★\u3000･\n    *\u3000\u3000ﾟ｡·*･｡ ﾟ*\n  \u3000\u3000\u3000☆ﾟ･｡°*. ﾟ\n\u3000 ･ ﾟ*｡･ﾟ★｡\n\u3000\u3000･ *ﾟ｡\u3000\u3000 *\n\u3000･ﾟ*｡★･\n ☆∴｡\u3000*\n･ ｡\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";\nimport ""@openzeppelin/contracts/utils/math/Math.sol"";\n\nimport ""./libraries/LockedBalance.sol"";\n\nerror FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\nerror FETH_Escrow_Expired();\nerror FETH_Escrow_Not_Found();\nerror FETH_Expiration_Too_Far_In_Future();\n/// @param amount The current allowed amount the spender is authorized to transact for this account.\nerror FETH_Insufficient_Allowance(uint256 amount);\n/// @param amount The current available (unlocked) token count of this account.\nerror FETH_Insufficient_Available_Funds(uint256 amount);\n/// @param amount The current number of tokens this account has for the given lockup expiry bucket.\nerror FETH_Insufficient_Escrow(uint256 amount);\nerror FETH_Invalid_Lockup_Duration();\nerror FETH_Market_Must_Be_A_Contract();\nerror FETH_Must_Deposit_Non_Zero_Amount();\nerror FETH_Must_Lockup_Non_Zero_Amount();\nerror FETH_No_Funds_To_Withdraw();\nerror FETH_Only_FND_Market_Allowed();\nerror FETH_Too_Much_ETH_Provided();\nerror FETH_Transfer_To_Burn_Not_Allowed();\nerror FETH_Transfer_To_FETH_Not_Allowed();\n\n/**\n * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.\n * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after\n * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).\n * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be\n * transferred or withdrawn, except by our market contract which requested the lockup in the first place.\n * @dev Locked balances are rounded up to the next hour.\n * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".\n * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.\n */\ncontract FETH {\n  using AddressUpgradeable for address payable;\n  using LockedBalance for LockedBalance.Lockups;\n  using Math for uint256;\n\n  /// @notice Tracks an account\'s info.\n  struct AccountInfo {\n    /// @notice The number of tokens which have been unlocked already.\n    uint96 freedBalance;\n    /// @notice The first applicable lockup bucket for this account.\n    uint32 lockupStartIndex;\n    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.\n    LockedBalance.Lockups lockups;\n    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.\n    mapping(address =&gt; uint256) allowance;\n  }\n\n  /// @notice Stores per-account details.\n  mapping(address =&gt; AccountInfo) private accountToInfo;\n\n  // Lockup configuration\n  /// @notice The minimum lockup period in seconds.\n  uint256 private immutable lockupDuration;\n  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.\n  uint256 private immutable lockupInterval;\n\n  /// @notice The Foundation market contract with permissions to manage lockups.\n  address payable private immutable foundationMarket;\n\n  // ERC-20 metadata fields\n  /**\n   * @notice The number of decimals the token uses.\n   * @dev This method can be used to improve usability when displaying token amounts, but all interactions\n   * with this contract use whole amounts not considering decimals.\n   * @return 18\n   */\n  uint8 public constant decimals = 18;\n  /**\n   * @notice The name of the token.\n   * @return Foundation Wrapped Ether\n   */\n  string public constant name = ""Foundation Wrapped Ether"";\n  /**\n   * @notice The symbol of the token.\n   * @return FETH\n   */\n  string public constant symbol = ""FETH"";\n\n  // ERC-20 events\n  /**\n   * @notice Emitted when the allowance for a spender account is updated.\n   * @param from The account the spender is authorized to transact for.\n   * @param spender The account with permissions to manage FETH tokens for the `from` account.\n   * @param amount The max amount of tokens which can be spent by the `spender` account.\n   */\n  event Approval(address indexed from, address indexed spender, uint256 amount);\n  /**\n   * @notice Emitted when a transfer of FETH tokens is made from one account to another.\n   * @param from The account which is sending FETH tokens.\n   * @param to The account which is receiving FETH tokens.\n   * @param amount The number of FETH tokens which were sent.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  // Custom events\n  /**\n   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours\n   * and may include newly deposited ETH which is added to the account\'s total FETH balance.\n   * @param account The account which has access to the FETH after the `expiration`.\n   * @param expiration The time at which the `from` account will have access to the locked FETH.\n   * @param amount The number of FETH tokens which where locked up.\n   * @param valueDeposited The amount of ETH added to their account\'s total FETH balance,\n   * this may be lower than `amount` if available FETH was leveraged.\n   */\n  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);\n  /**\n   * @notice Emitted when FETH tokens are unlocked by the Foundation market.\n   * @dev This event will not be emitted when lockups expire,\n   * it\'s only for tokens which are unlocked before their expiry.\n   * @param account The account which had locked FETH freed before expiration.\n   * @param expiration The time this balance was originally scheduled to be unlocked.\n   * @param amount The number of FETH tokens which were unlocked.\n   */\n  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);\n  /**\n   * @notice Emitted when ETH is withdrawn from a user\'s account.\n   * @dev This may be triggered by the user, an approved operator, or the Foundation market.\n   * @param from The account from which FETH was deducted in order to send the ETH.\n   * @param to The address the ETH was sent to.\n   * @param amount The number of tokens which were deducted from the user\'s FETH balance and transferred as ETH.\n   */\n  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);\n\n  /// @dev Allows the Foundation market permission to manage lockups for a user.\n  modifier onlyFoundationMarket() {\n    if (msg.sender != foundationMarket) {\n      revert FETH_Only_FND_Market_Allowed();\n    }\n    _;\n  }\n\n  /**\n   * @notice Initializes variables which may differ on testnet.\n   * @param _foundationMarket The address of the Foundation NFT marketplace.\n   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.\n   */\n  constructor(address payable _foundationMarket, uint256 _lockupDuration) {\n    if (!_foundationMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    foundationMarket = _foundationMarket;\n    lockupDuration = _lockupDuration;\n    lockupInterval = _lockupDuration / 24;\n    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {\n      revert FETH_Invalid_Lockup_Duration();\n    }\n  }\n\n  /**\n   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user\'s account.\n   */\n  receive() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Approves a `spender` as an operator with permissions to transfer from your account.\n   * @param spender The address of the operator account that has approval to spend funds\n   * from the `msg.sender`\'s account.\n   * @param amount The max number of FETH tokens from `msg.sender`\'s account that this spender is\n   * allowed to transact with.\n   * @return success Always true.\n   */\n  function approve(address spender, uint256 amount) external returns (bool success) {\n    accountToInfo[msg.sender].allowance[spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   */\n  function deposit() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   * @dev This may be used by the Foundation market to credit a user\'s account with FETH tokens.\n   * @param account The account to credit with FETH tokens.\n   */\n  function depositFor(address account) public payable {\n    if (msg.value == 0) {\n      revert FETH_Must_Deposit_Non_Zero_Amount();\n    }\n    AccountInfo storage accountInfo = accountToInfo[account];\n    // ETH value cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(msg.value);\n    }\n    emit Transfer(address(0), account, msg.value);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account\'s lockup and then create a new lockup, potentially for a different account.\n   * @dev Used by the market when an offer for an NFT is increased.\n   * This may be for a single account (increasing their offer)\n   * or two different accounts (outbidding someone elses offer).\n   * @param unlockFrom The account whose lockup is to be removed.\n   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`\'s account.\n   * This will revert if the tokens were previously unlocked.\n   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`\'s account.\n   * `msg.value` must be &lt;= `lockupAmount` and any delta will be taken from the account\'s available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketChangeLockup(\n    address unlockFrom,\n    uint256 unlockExpiration,\n    uint256 unlockAmount,\n    address lockupFor,\n    uint256 lockupAmount\n  ) external payable onlyFoundationMarket returns (uint256 expiration) {\n    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);\n    return _marketLockupFor(lockupFor, lockupAmount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Lockup an account\'s FETH tokens for 24-25 hours.\n   * @dev Used by the market when a new offer for an NFT is made.\n   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param amount The number of tokens to be locked up for the `lockupFor`\'s account.\n   * `msg.value` must be &lt;= `amount` and any delta will be taken from the account\'s available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketLockupFor(address account, uint256 amount)\n    external\n    payable\n    onlyFoundationMarket\n    returns (uint256 expiration)\n  {\n    return _marketLockupFor(account, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account\'s lockup, making the FETH tokens available for transfer or withdrawal.\n   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT\n   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.\n   * @param account The account whose lockup is to be unlocked.\n   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked from `account`.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _marketUnlockFor(account, expiration, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes tokens from the user\'s available balance and returns ETH to the caller.\n   * @dev Used by the market when a user\'s available FETH balance is used to make a purchase\n   * including accepting a buy price or a private sale, or placing a bid in an auction.\n   * @param from The account whose available balance is to be withdrawn from.\n   * @param amount The number of tokens to be deducted from `unlockFrom`\'s available balance and transferred as ETH.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(from, msg.sender, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes a lockup from the user\'s account and then returns ETH to the caller.\n   * @dev Used by the market to extract unexpired funds as ETH to distribute for\n   * a sale when the user\'s offer is accepted.\n   * @param account The account whose lockup is to be removed.\n   * @param expiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked and withdrawn as ETH.\n   */\n  function marketWithdrawLocked(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _removeFromLockedBalance(account, expiration, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(account, msg.sender, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from your account.\n   * @param to The address of the account which the tokens are transferred from.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds).\n   */\n  function transfer(address to, uint256 amount) external returns (bool success) {\n    return transferFrom(msg.sender, to, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.\n   * @param from The address from which the available tokens are transferred from.\n   * @param to The address to which the tokens are to be transferred.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds or not approved).\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public returns (bool success) {\n    if (to == address(0)) {\n      revert FETH_Transfer_To_Burn_Not_Allowed();\n    } else if (to == address(this)) {\n      revert FETH_Transfer_To_FETH_Not_Allowed();\n    }\n    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(fromAccountInfo, amount);\n    }\n    _deductBalanceFrom(fromAccountInfo, amount);\n    AccountInfo storage toAccountInfo = accountToInfo[to];\n\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      toAccountInfo.freedBalance += uint96(amount);\n    }\n\n    emit Transfer(from, to, amount);\n\n    return true;\n  }\n\n  /**\n   * @notice Withdraw all tokens available in your account and receive ETH.\n   */\n  function withdrawAvailableBalance() external {\n    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);\n    uint256 amount = accountInfo.freedBalance;\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    delete accountInfo.freedBalance;\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(msg.sender, msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw the specified number of tokens from the `from` accounts available balance\n   * and send ETH to the destination address, if the `msg.sender` has approval.\n   * @param from The address from which the available funds are to be withdrawn.\n   * @param to The destination address for the ETH to be transferred to.\n   * @param amount The number of tokens to be withdrawn and transferred as ETH.\n   */\n  function withdrawFrom(\n    address from,\n    address payable to,\n    uint256 amount\n  ) external {\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(accountInfo, amount);\n    }\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    to.sendValue(amount);\n\n    emit ETHWithdrawn(from, to, amount);\n  }\n\n  /**\n   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.\n   */\n  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    if (accountInfo.allowance[msg.sender] != type(uint256).max) {\n      if (accountInfo.allowance[msg.sender] &lt; amount) {\n        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);\n      }\n      // The check above ensures allowance cannot underflow.\n      unchecked {\n        accountInfo.allowance[msg.sender] -= amount;\n      }\n    }\n  }\n\n  /**\n   * @dev Removes an amount from the account\'s available FETH balance.\n   */\n  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    // Free from escrow in order to consider any expired escrow balance\n    if (accountInfo.freedBalance &lt; amount) {\n      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\n    }\n    // The check above ensures balance cannot underflow.\n    unchecked {\n      accountInfo.freedBalance -= uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Moves expired escrow to the available balance.\n   */\n  function _freeFromEscrow(address account) private returns (AccountInfo storage) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required\n    if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {\n      return accountInfo;\n    }\n\n    while (true) {\n      // Total ETH cannot realistically overflow 96 bits.\n      unchecked {\n        accountInfo.freedBalance += escrow.totalAmount;\n        accountInfo.lockups.del(escrowIndex);\n        // Escrow index cannot overflow 32 bits.\n        escrow = accountInfo.lockups.get(escrowIndex + 1);\n      }\n\n      // If the next bucket is empty, the start index is set to the previous bucket\n      if (escrow.expiration == 0) {\n        break;\n      }\n\n      // Escrow index cannot overflow 32 bits.\n      unchecked {\n        // Increment the escrow start index if the next bucket is not empty\n        ++escrowIndex;\n      }\n\n      // If the next bucket is expired, that\'s the new start index\n      if (escrow.expiration &gt;= block.timestamp) {\n        break;\n      }\n    }\n\n    // Escrow index cannot overflow 32 bits.\n    unchecked {\n      accountInfo.lockupStartIndex = uint32(escrowIndex);\n    }\n    return accountInfo;\n  }\n\n  /**\n   * @notice Lockup an account\'s FETH tokens for 24-25 hours.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {\n    if (account == address(0)) {\n      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\n    }\n    if (amount == 0) {\n      revert FETH_Must_Lockup_Non_Zero_Amount();\n    }\n\n    // Block timestamp in seconds is small enough to never overflow\n    unchecked {\n      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours\n      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;\n    }\n\n    // Update available escrow\n    // Always free from escrow to ensure the max bucket count is &lt;= 25\n    AccountInfo storage accountInfo = _freeFromEscrow(account);\n    if (msg.value &lt; amount) {\n      // The check above prevents underflow with delta.\n      unchecked {\n        uint256 delta = amount - msg.value;\n        if (accountInfo.freedBalance &lt; delta) {\n          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\n        }\n        // The check above prevents underflow of freed balance.\n        accountInfo.freedBalance -= uint96(delta);\n      }\n    } else if (msg.value != amount) {\n      // There\'s no reason to send msg.value more than the amount being locked up\n      revert FETH_Too_Much_ETH_Provided();\n    }\n\n    // Add to locked escrow\n    unchecked {\n      // The number of buckets is always &lt; 256 bits.\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          if (expiration &gt; type(uint32).max) {\n            revert FETH_Expiration_Too_Far_In_Future();\n          }\n          // Amount (ETH) will always be &lt; 96 bits.\n          accountInfo.lockups.set(escrowIndex, expiration, amount);\n          break;\n        }\n        if (escrow.expiration == expiration) {\n          // Total ETH will always be &lt; 96 bits.\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);\n          break;\n        }\n      }\n    }\n\n    emit BalanceLocked(account, expiration, amount, msg.value);\n  }\n\n  /**\n   * @notice Remove an account\'s lockup, making the FETH tokens available for transfer or withdrawal.\n   */\n  function _marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private {\n    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Removes the specified amount from locked escrow, potentially before its expiration.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _removeFromLockedBalance(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private returns (AccountInfo storage) {\n    if (expiration &lt; block.timestamp) {\n      revert FETH_Escrow_Expired();\n    }\n\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    if (escrow.expiration == expiration) {\n      // If removing from the first bucket, we may be able to delete it\n      if (escrow.totalAmount == amount) {\n        accountInfo.lockups.del(escrowIndex);\n\n        // Bump the escrow start index unless it\'s the last one\n        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {\n          // The number of escrow buckets will never overflow 32 bits.\n          unchecked {\n            ++accountInfo.lockupStartIndex;\n          }\n        }\n      } else {\n        if (escrow.totalAmount &lt; amount) {\n          revert FETH_Insufficient_Escrow(escrow.totalAmount);\n        }\n        // The require above ensures balance will not underflow.\n        unchecked {\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n        }\n      }\n    } else {\n      // Removing from the 2nd+ bucket\n      while (true) {\n        // The number of escrow buckets will never overflow 32 bits.\n        unchecked {\n          ++escrowIndex;\n        }\n        escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == expiration) {\n          if (amount &gt; escrow.totalAmount) {\n            revert FETH_Insufficient_Escrow(escrow.totalAmount);\n          }\n          // The require above ensures balance will not underflow.\n          unchecked {\n            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n          }\n          // We may have an entry with 0 totalAmount but expiration will be set\n          break;\n        }\n        if (escrow.expiration == 0) {\n          revert FETH_Escrow_Not_Found();\n        }\n      }\n    }\n\n    emit BalanceUnlocked(account, expiration, amount);\n    return accountInfo;\n  }\n\n  /**\n   * @notice Returns the amount which a spender is still allowed to transact from the `account`\'s balance.\n   * @param account The owner of the funds.\n   * @param operator The address with approval to spend from the `account`\'s balance.\n   * @return amount The number of tokens the `operator` is still allowed to transact with.\n   */\n  function allowance(address account, address operator) external view returns (uint256 amount) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    return accountInfo.allowance[operator];\n  }\n\n  /**\n   * @notice Returns the balance of an account which is available to transfer or withdraw.\n   * @dev This will automatically increase as soon as locked tokens reach their expiry date.\n   * @param account The account to query the available balance of.\n   * @return balance The available balance of the account.\n   */\n  function balanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits.\n    unchecked {\n      // Add expired lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Gets the Foundation market address which has permissions to manage lockups.\n   * @return market The Foundation market contract address.\n   */\n  function getFoundationMarket() external view returns (address market) {\n    return foundationMarket;\n  }\n\n  /**\n   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.\n   * @dev `expires.length` == `amounts.length`\n   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.\n   * The results returned are sorted by expiry, with the earliest expiry date first.\n   * @param account The account to query the locked balance of.\n   * @return expiries The time at which each outstanding lockup bucket expires.\n   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.\n   */\n  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n\n    // Count lockups\n    uint256 lockedCount;\n    // The number of buckets is always &lt; 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {\n          // Lockup count will never overflow 256 bits.\n          ++lockedCount;\n        }\n      }\n    }\n\n    // Allocate arrays\n    expiries = new uint256[](lockedCount);\n    amounts = new uint256[](lockedCount);\n\n    // Populate results\n    uint256 i;\n    // The number of buckets is always &lt; 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {\n          expiries[i] = escrow.expiration;\n          amounts[i] = escrow.totalAmount;\n          ++i;\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total balance of an account, including locked FETH tokens.\n   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.\n   * @param account The account to query the total balance of.\n   * @return balance The total FETH balance tracked for this account.\n   */\n  function totalBalanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits.\n    unchecked {\n      // Add all lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total amount of ETH locked in this contract.\n   * @return supply The total amount of ETH locked in this contract.\n   */\n  function totalSupply() external view returns (uint256 supply) {\n    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct\n       but this is on-par with the WETH implementation and done for gas savings. */\n    return address(this).balance;\n  }\n}\n', 'ideas': "" Unchecked External Calls Identified.\n\n\nREENTRANCY VULNERABILITY\n'''\nThe contract contains several external calls to transfer Ether using payable(msg.sender).sendValue(amount); and to.sendValue(amount); after state changes have been made. This can lead to reentrancy attacks, as the external call can invoke a fallback function in the recipient contract, allowing it to call back into the original contract before the state changes are finalized.\n\nFor example, in the marketWithdrawFrom and marketWithdrawLocked functions, the contract first updates the state by deducting the balance and then makes an external call to transfer Ether. If the recipient contract is malicious and re-enters the original contract during this process, it could manipulate the state in an unintended manner.\n\nTo mitigate this vulnerability, the contract should implement the Checks-Effects-Interactions pattern. This involves:\n1. Performing all necessary checks (e.g., ensuring sufficient balance).\n2. Updating the state variables (e.g., deducting balances).\n3. Making external calls (e.g., transferring Ether).\n\nAlternatively, using a ReentrancyGuard modifier can help prevent reentrant calls by blocking any function that has already been called until it completes execution.\n'''\n```""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-11-08 20:26:00 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol""; import ""@openzeppelin/contracts/utils/math/Math.sol""; import ""./libraries/LockedBalance.sol""; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = ""Foundation Wrapped Ether"";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = ""FETH""; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-11-08 20:26:00 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts/utils/math/Math.sol"";

import ""./libraries/LockedBalance.sol"";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = ""Foundation Wrapped Ether"";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = ""FETH"";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""Identify all Unchecked Low-level Call vulnerabilities in the provided Solidity contract."".
Ideas: ""Look for instances where low-level calls (such as `call`, `delegatecall`, `send`) are made without proper error handling or checks to ensure the calls succeed."".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Unchecked Low-level Calls. There are three cases, the contract may have Unchecked Low-level Calls:
1. When low-level calls (such as `call`, `delegatecall`, `send`) are not adequately checked, the calling contract may execute code in the external contract without ensuring the external contract's behavior is as expected.
2. When the external contract's code is not trusted or its behavior is unpredictable, it can compromise the overall security and stability of the calling contract.
3. When the execution of low-level function calls fails, the contract does not handle errors. The contract does not provide any mechanism to handle or revert the transaction, potentially resulting in a loss of funds.
If you identify Unchecked Low-level Calls, please respond with: ""","<INFO> Unchecked Low-level Calls Identified.

```
UNCHECKED LOW-LEVEL CALL VULNERABILITY
'''
The contract uses the `sendValue` function from the `AddressUpgradeable` library, which is a low-level call to transfer ETH. This function does not check for the success of the call, meaning if the transfer fails (for example, if the recipient is a contract that reverts on receiving ETH), the transaction will not revert, and the state of the contract may become inconsistent. This can lead to a loss of funds or unexpected behavior.

Recommended Mitigation/Fix:
Instead of using `sendValue`, use a pattern that checks for the success of the call. For example, you can use the following pattern to ensure that the transfer succeeds:

```solidity
(bool success, ) = to.call{value: amount}("""");
require(success, ""Transfer failed"");
```
This ensures that if the transfer fails, the transaction will revert, maintaining the integrity of the contract's state.
'''
```

```
UNCHECKED LOW-LEVEL CALL VULNERABILITY
'''
The contract also uses the `sendValue` function in the `marketWithdrawFrom` and `marketWithdrawLocked` functions. Similar to the previous case, these calls do not check if the ETH transfer was successful. If the recipient contract reverts during the transfer, it could lead to a loss of funds or inconsistent state.

Recommended Mitigation/Fix:
Implement a check for the success of the ETH transfer as shown below:

```solidity
(bool success, ) = msg.sender.call{value: amount}("""");
require(success, ""Transfer failed"");
```
This will ensure that the transaction reverts if the ETH transfer fails, preventing any potential loss of funds.
'''
```

[2024-11-08 20:26:05 INFO] **[Execute Detail]**

execute SimplePhase:[TODDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-11-08 20:26:05 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol""; import ""@openzeppelin/contracts/utils/math/Math.sol""; import ""./libraries/LockedBalance.sol""; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = ""Foundation Wrapped Ether"";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = ""FETH""; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Transactions Order Dependence. Transactions Order Dependence vulnerabilities can result in unintended consequences and create opportunities for malicious actors to exploit transaction sequencing. Please conduct a thorough analysis, considering the following information: 1. Review the contract's code logic to identify any potential areas where the order of transaction execution might have an impact on the contract's behavior.   Examine critical functions, particularly those involving fund transfers or resource allocation, to ensure they are not susceptible to Transactions Order Dependence.   Investigate scenarios in which gas prices can be manipulated to change the order of transaction execution.   If you identify Transactions Order Dependence, respond with: "" Transactions Order Dependence Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades ''' If you don't find any Transactions Order Dependence vulnerabilities, respond only with: "" NO Transactions Order Dependence."" |
| **phase_name** | TODDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '/\n  ･\n   \u3000★\n      ･ ｡\n        \u3000･\u3000ﾟ☆ ｡\n  \u3000\u3000\u3000 \u3000★ ﾟ･｡ *  ｡\n          \u3000\u3000 ☆ ｡･ﾟ.｡\n      \u3000\u3000\u3000ﾟ .｡☆｡★\u3000･\n\u200b\n                      .-:::::-.              -::---...```\n-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy\n-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo\n                                              ``\n   *\u3000\n      ･ ｡\n\u3000\u3000\u3000\u3000･\u3000\u3000ﾟ☆ ｡\n  \u3000\u3000\u3000 *\u3000★ ﾟ･｡ *  ｡\n          \u3000\u3000* ☆ ｡･ﾟ*.｡\n      \u3000\u3000\u3000ﾟ *.｡☆｡★\u3000･\n    *\u3000\u3000ﾟ｡·*･｡ ﾟ*\n  \u3000\u3000\u3000☆ﾟ･｡°*. ﾟ\n\u3000 ･ ﾟ*｡･ﾟ★｡\n\u3000\u3000･ *ﾟ｡\u3000\u3000 *\n\u3000･ﾟ*｡★･\n ☆∴｡\u3000*\n･ ｡\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";\nimport ""@openzeppelin/contracts/utils/math/Math.sol"";\n\nimport ""./libraries/LockedBalance.sol"";\n\nerror FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\nerror FETH_Escrow_Expired();\nerror FETH_Escrow_Not_Found();\nerror FETH_Expiration_Too_Far_In_Future();\n/// @param amount The current allowed amount the spender is authorized to transact for this account.\nerror FETH_Insufficient_Allowance(uint256 amount);\n/// @param amount The current available (unlocked) token count of this account.\nerror FETH_Insufficient_Available_Funds(uint256 amount);\n/// @param amount The current number of tokens this account has for the given lockup expiry bucket.\nerror FETH_Insufficient_Escrow(uint256 amount);\nerror FETH_Invalid_Lockup_Duration();\nerror FETH_Market_Must_Be_A_Contract();\nerror FETH_Must_Deposit_Non_Zero_Amount();\nerror FETH_Must_Lockup_Non_Zero_Amount();\nerror FETH_No_Funds_To_Withdraw();\nerror FETH_Only_FND_Market_Allowed();\nerror FETH_Too_Much_ETH_Provided();\nerror FETH_Transfer_To_Burn_Not_Allowed();\nerror FETH_Transfer_To_FETH_Not_Allowed();\n\n/**\n * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.\n * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after\n * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).\n * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be\n * transferred or withdrawn, except by our market contract which requested the lockup in the first place.\n * @dev Locked balances are rounded up to the next hour.\n * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".\n * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.\n */\ncontract FETH {\n  using AddressUpgradeable for address payable;\n  using LockedBalance for LockedBalance.Lockups;\n  using Math for uint256;\n\n  /// @notice Tracks an account\'s info.\n  struct AccountInfo {\n    /// @notice The number of tokens which have been unlocked already.\n    uint96 freedBalance;\n    /// @notice The first applicable lockup bucket for this account.\n    uint32 lockupStartIndex;\n    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.\n    LockedBalance.Lockups lockups;\n    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.\n    mapping(address =&gt; uint256) allowance;\n  }\n\n  /// @notice Stores per-account details.\n  mapping(address =&gt; AccountInfo) private accountToInfo;\n\n  // Lockup configuration\n  /// @notice The minimum lockup period in seconds.\n  uint256 private immutable lockupDuration;\n  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.\n  uint256 private immutable lockupInterval;\n\n  /// @notice The Foundation market contract with permissions to manage lockups.\n  address payable private immutable foundationMarket;\n\n  // ERC-20 metadata fields\n  /**\n   * @notice The number of decimals the token uses.\n   * @dev This method can be used to improve usability when displaying token amounts, but all interactions\n   * with this contract use whole amounts not considering decimals.\n   * @return 18\n   */\n  uint8 public constant decimals = 18;\n  /**\n   * @notice The name of the token.\n   * @return Foundation Wrapped Ether\n   */\n  string public constant name = ""Foundation Wrapped Ether"";\n  /**\n   * @notice The symbol of the token.\n   * @return FETH\n   */\n  string public constant symbol = ""FETH"";\n\n  // ERC-20 events\n  /**\n   * @notice Emitted when the allowance for a spender account is updated.\n   * @param from The account the spender is authorized to transact for.\n   * @param spender The account with permissions to manage FETH tokens for the `from` account.\n   * @param amount The max amount of tokens which can be spent by the `spender` account.\n   */\n  event Approval(address indexed from, address indexed spender, uint256 amount);\n  /**\n   * @notice Emitted when a transfer of FETH tokens is made from one account to another.\n   * @param from The account which is sending FETH tokens.\n   * @param to The account which is receiving FETH tokens.\n   * @param amount The number of FETH tokens which were sent.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  // Custom events\n  /**\n   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours\n   * and may include newly deposited ETH which is added to the account\'s total FETH balance.\n   * @param account The account which has access to the FETH after the `expiration`.\n   * @param expiration The time at which the `from` account will have access to the locked FETH.\n   * @param amount The number of FETH tokens which where locked up.\n   * @param valueDeposited The amount of ETH added to their account\'s total FETH balance,\n   * this may be lower than `amount` if available FETH was leveraged.\n   */\n  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);\n  /**\n   * @notice Emitted when FETH tokens are unlocked by the Foundation market.\n   * @dev This event will not be emitted when lockups expire,\n   * it\'s only for tokens which are unlocked before their expiry.\n   * @param account The account which had locked FETH freed before expiration.\n   * @param expiration The time this balance was originally scheduled to be unlocked.\n   * @param amount The number of FETH tokens which were unlocked.\n   */\n  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);\n  /**\n   * @notice Emitted when ETH is withdrawn from a user\'s account.\n   * @dev This may be triggered by the user, an approved operator, or the Foundation market.\n   * @param from The account from which FETH was deducted in order to send the ETH.\n   * @param to The address the ETH was sent to.\n   * @param amount The number of tokens which were deducted from the user\'s FETH balance and transferred as ETH.\n   */\n  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);\n\n  /// @dev Allows the Foundation market permission to manage lockups for a user.\n  modifier onlyFoundationMarket() {\n    if (msg.sender != foundationMarket) {\n      revert FETH_Only_FND_Market_Allowed();\n    }\n    _;\n  }\n\n  /**\n   * @notice Initializes variables which may differ on testnet.\n   * @param _foundationMarket The address of the Foundation NFT marketplace.\n   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.\n   */\n  constructor(address payable _foundationMarket, uint256 _lockupDuration) {\n    if (!_foundationMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    foundationMarket = _foundationMarket;\n    lockupDuration = _lockupDuration;\n    lockupInterval = _lockupDuration / 24;\n    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {\n      revert FETH_Invalid_Lockup_Duration();\n    }\n  }\n\n  /**\n   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user\'s account.\n   */\n  receive() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Approves a `spender` as an operator with permissions to transfer from your account.\n   * @param spender The address of the operator account that has approval to spend funds\n   * from the `msg.sender`\'s account.\n   * @param amount The max number of FETH tokens from `msg.sender`\'s account that this spender is\n   * allowed to transact with.\n   * @return success Always true.\n   */\n  function approve(address spender, uint256 amount) external returns (bool success) {\n    accountToInfo[msg.sender].allowance[spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   */\n  function deposit() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   * @dev This may be used by the Foundation market to credit a user\'s account with FETH tokens.\n   * @param account The account to credit with FETH tokens.\n   */\n  function depositFor(address account) public payable {\n    if (msg.value == 0) {\n      revert FETH_Must_Deposit_Non_Zero_Amount();\n    }\n    AccountInfo storage accountInfo = accountToInfo[account];\n    // ETH value cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(msg.value);\n    }\n    emit Transfer(address(0), account, msg.value);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account\'s lockup and then create a new lockup, potentially for a different account.\n   * @dev Used by the market when an offer for an NFT is increased.\n   * This may be for a single account (increasing their offer)\n   * or two different accounts (outbidding someone elses offer).\n   * @param unlockFrom The account whose lockup is to be removed.\n   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`\'s account.\n   * This will revert if the tokens were previously unlocked.\n   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`\'s account.\n   * `msg.value` must be &lt;= `lockupAmount` and any delta will be taken from the account\'s available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketChangeLockup(\n    address unlockFrom,\n    uint256 unlockExpiration,\n    uint256 unlockAmount,\n    address lockupFor,\n    uint256 lockupAmount\n  ) external payable onlyFoundationMarket returns (uint256 expiration) {\n    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);\n    return _marketLockupFor(lockupFor, lockupAmount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Lockup an account\'s FETH tokens for 24-25 hours.\n   * @dev Used by the market when a new offer for an NFT is made.\n   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param amount The number of tokens to be locked up for the `lockupFor`\'s account.\n   * `msg.value` must be &lt;= `amount` and any delta will be taken from the account\'s available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketLockupFor(address account, uint256 amount)\n    external\n    payable\n    onlyFoundationMarket\n    returns (uint256 expiration)\n  {\n    return _marketLockupFor(account, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account\'s lockup, making the FETH tokens available for transfer or withdrawal.\n   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT\n   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.\n   * @param account The account whose lockup is to be unlocked.\n   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked from `account`.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _marketUnlockFor(account, expiration, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes tokens from the user\'s available balance and returns ETH to the caller.\n   * @dev Used by the market when a user\'s available FETH balance is used to make a purchase\n   * including accepting a buy price or a private sale, or placing a bid in an auction.\n   * @param from The account whose available balance is to be withdrawn from.\n   * @param amount The number of tokens to be deducted from `unlockFrom`\'s available balance and transferred as ETH.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(from, msg.sender, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes a lockup from the user\'s account and then returns ETH to the caller.\n   * @dev Used by the market to extract unexpired funds as ETH to distribute for\n   * a sale when the user\'s offer is accepted.\n   * @param account The account whose lockup is to be removed.\n   * @param expiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked and withdrawn as ETH.\n   */\n  function marketWithdrawLocked(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _removeFromLockedBalance(account, expiration, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(account, msg.sender, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from your account.\n   * @param to The address of the account which the tokens are transferred from.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds).\n   */\n  function transfer(address to, uint256 amount) external returns (bool success) {\n    return transferFrom(msg.sender, to, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.\n   * @param from The address from which the available tokens are transferred from.\n   * @param to The address to which the tokens are to be transferred.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds or not approved).\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public returns (bool success) {\n    if (to == address(0)) {\n      revert FETH_Transfer_To_Burn_Not_Allowed();\n    } else if (to == address(this)) {\n      revert FETH_Transfer_To_FETH_Not_Allowed();\n    }\n    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(fromAccountInfo, amount);\n    }\n    _deductBalanceFrom(fromAccountInfo, amount);\n    AccountInfo storage toAccountInfo = accountToInfo[to];\n\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      toAccountInfo.freedBalance += uint96(amount);\n    }\n\n    emit Transfer(from, to, amount);\n\n    return true;\n  }\n\n  /**\n   * @notice Withdraw all tokens available in your account and receive ETH.\n   */\n  function withdrawAvailableBalance() external {\n    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);\n    uint256 amount = accountInfo.freedBalance;\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    delete accountInfo.freedBalance;\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(msg.sender, msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw the specified number of tokens from the `from` accounts available balance\n   * and send ETH to the destination address, if the `msg.sender` has approval.\n   * @param from The address from which the available funds are to be withdrawn.\n   * @param to The destination address for the ETH to be transferred to.\n   * @param amount The number of tokens to be withdrawn and transferred as ETH.\n   */\n  function withdrawFrom(\n    address from,\n    address payable to,\n    uint256 amount\n  ) external {\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(accountInfo, amount);\n    }\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    to.sendValue(amount);\n\n    emit ETHWithdrawn(from, to, amount);\n  }\n\n  /**\n   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.\n   */\n  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    if (accountInfo.allowance[msg.sender] != type(uint256).max) {\n      if (accountInfo.allowance[msg.sender] &lt; amount) {\n        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);\n      }\n      // The check above ensures allowance cannot underflow.\n      unchecked {\n        accountInfo.allowance[msg.sender] -= amount;\n      }\n    }\n  }\n\n  /**\n   * @dev Removes an amount from the account\'s available FETH balance.\n   */\n  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    // Free from escrow in order to consider any expired escrow balance\n    if (accountInfo.freedBalance &lt; amount) {\n      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\n    }\n    // The check above ensures balance cannot underflow.\n    unchecked {\n      accountInfo.freedBalance -= uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Moves expired escrow to the available balance.\n   */\n  function _freeFromEscrow(address account) private returns (AccountInfo storage) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required\n    if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {\n      return accountInfo;\n    }\n\n    while (true) {\n      // Total ETH cannot realistically overflow 96 bits.\n      unchecked {\n        accountInfo.freedBalance += escrow.totalAmount;\n        accountInfo.lockups.del(escrowIndex);\n        // Escrow index cannot overflow 32 bits.\n        escrow = accountInfo.lockups.get(escrowIndex + 1);\n      }\n\n      // If the next bucket is empty, the start index is set to the previous bucket\n      if (escrow.expiration == 0) {\n        break;\n      }\n\n      // Escrow index cannot overflow 32 bits.\n      unchecked {\n        // Increment the escrow start index if the next bucket is not empty\n        ++escrowIndex;\n      }\n\n      // If the next bucket is expired, that\'s the new start index\n      if (escrow.expiration &gt;= block.timestamp) {\n        break;\n      }\n    }\n\n    // Escrow index cannot overflow 32 bits.\n    unchecked {\n      accountInfo.lockupStartIndex = uint32(escrowIndex);\n    }\n    return accountInfo;\n  }\n\n  /**\n   * @notice Lockup an account\'s FETH tokens for 24-25 hours.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {\n    if (account == address(0)) {\n      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\n    }\n    if (amount == 0) {\n      revert FETH_Must_Lockup_Non_Zero_Amount();\n    }\n\n    // Block timestamp in seconds is small enough to never overflow\n    unchecked {\n      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours\n      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;\n    }\n\n    // Update available escrow\n    // Always free from escrow to ensure the max bucket count is &lt;= 25\n    AccountInfo storage accountInfo = _freeFromEscrow(account);\n    if (msg.value &lt; amount) {\n      // The check above prevents underflow with delta.\n      unchecked {\n        uint256 delta = amount - msg.value;\n        if (accountInfo.freedBalance &lt; delta) {\n          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\n        }\n        // The check above prevents underflow of freed balance.\n        accountInfo.freedBalance -= uint96(delta);\n      }\n    } else if (msg.value != amount) {\n      // There\'s no reason to send msg.value more than the amount being locked up\n      revert FETH_Too_Much_ETH_Provided();\n    }\n\n    // Add to locked escrow\n    unchecked {\n      // The number of buckets is always &lt; 256 bits.\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          if (expiration &gt; type(uint32).max) {\n            revert FETH_Expiration_Too_Far_In_Future();\n          }\n          // Amount (ETH) will always be &lt; 96 bits.\n          accountInfo.lockups.set(escrowIndex, expiration, amount);\n          break;\n        }\n        if (escrow.expiration == expiration) {\n          // Total ETH will always be &lt; 96 bits.\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);\n          break;\n        }\n      }\n    }\n\n    emit BalanceLocked(account, expiration, amount, msg.value);\n  }\n\n  /**\n   * @notice Remove an account\'s lockup, making the FETH tokens available for transfer or withdrawal.\n   */\n  function _marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private {\n    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Removes the specified amount from locked escrow, potentially before its expiration.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _removeFromLockedBalance(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private returns (AccountInfo storage) {\n    if (expiration &lt; block.timestamp) {\n      revert FETH_Escrow_Expired();\n    }\n\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    if (escrow.expiration == expiration) {\n      // If removing from the first bucket, we may be able to delete it\n      if (escrow.totalAmount == amount) {\n        accountInfo.lockups.del(escrowIndex);\n\n        // Bump the escrow start index unless it\'s the last one\n        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {\n          // The number of escrow buckets will never overflow 32 bits.\n          unchecked {\n            ++accountInfo.lockupStartIndex;\n          }\n        }\n      } else {\n        if (escrow.totalAmount &lt; amount) {\n          revert FETH_Insufficient_Escrow(escrow.totalAmount);\n        }\n        // The require above ensures balance will not underflow.\n        unchecked {\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n        }\n      }\n    } else {\n      // Removing from the 2nd+ bucket\n      while (true) {\n        // The number of escrow buckets will never overflow 32 bits.\n        unchecked {\n          ++escrowIndex;\n        }\n        escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == expiration) {\n          if (amount &gt; escrow.totalAmount) {\n            revert FETH_Insufficient_Escrow(escrow.totalAmount);\n          }\n          // The require above ensures balance will not underflow.\n          unchecked {\n            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n          }\n          // We may have an entry with 0 totalAmount but expiration will be set\n          break;\n        }\n        if (escrow.expiration == 0) {\n          revert FETH_Escrow_Not_Found();\n        }\n      }\n    }\n\n    emit BalanceUnlocked(account, expiration, amount);\n    return accountInfo;\n  }\n\n  /**\n   * @notice Returns the amount which a spender is still allowed to transact from the `account`\'s balance.\n   * @param account The owner of the funds.\n   * @param operator The address with approval to spend from the `account`\'s balance.\n   * @return amount The number of tokens the `operator` is still allowed to transact with.\n   */\n  function allowance(address account, address operator) external view returns (uint256 amount) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    return accountInfo.allowance[operator];\n  }\n\n  /**\n   * @notice Returns the balance of an account which is available to transfer or withdraw.\n   * @dev This will automatically increase as soon as locked tokens reach their expiry date.\n   * @param account The account to query the available balance of.\n   * @return balance The available balance of the account.\n   */\n  function balanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits.\n    unchecked {\n      // Add expired lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Gets the Foundation market address which has permissions to manage lockups.\n   * @return market The Foundation market contract address.\n   */\n  function getFoundationMarket() external view returns (address market) {\n    return foundationMarket;\n  }\n\n  /**\n   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.\n   * @dev `expires.length` == `amounts.length`\n   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.\n   * The results returned are sorted by expiry, with the earliest expiry date first.\n   * @param account The account to query the locked balance of.\n   * @return expiries The time at which each outstanding lockup bucket expires.\n   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.\n   */\n  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n\n    // Count lockups\n    uint256 lockedCount;\n    // The number of buckets is always &lt; 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {\n          // Lockup count will never overflow 256 bits.\n          ++lockedCount;\n        }\n      }\n    }\n\n    // Allocate arrays\n    expiries = new uint256[](lockedCount);\n    amounts = new uint256[](lockedCount);\n\n    // Populate results\n    uint256 i;\n    // The number of buckets is always &lt; 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {\n          expiries[i] = escrow.expiration;\n          amounts[i] = escrow.totalAmount;\n          ++i;\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total balance of an account, including locked FETH tokens.\n   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.\n   * @param account The account to query the total balance of.\n   * @return balance The total FETH balance tracked for this account.\n   */\n  function totalBalanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits.\n    unchecked {\n      // Add all lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total amount of ETH locked in this contract.\n   * @return supply The total amount of ETH locked in this contract.\n   */\n  function totalSupply() external view returns (uint256 supply) {\n    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct\n       but this is on-par with the WETH implementation and done for gas savings. */\n    return address(this).balance;\n  }\n}\n', 'ideas': ' Unchecked Low-level Calls Identified.\n\n\nUNCHECKED LOW-LEVEL CALL VULNERABILITY\n\'\'\'\nThe contract uses the sendValue function from the AddressUpgradeable library, which is a low-level call to transfer ETH. This function does not check for the success of the call, meaning if the transfer fails (for example, if the recipient is a contract that reverts on receiving ETH), the transaction will not revert, and the state of the contract may become inconsistent. This can lead to a loss of funds or unexpected behavior.\n\nRecommended Mitigation/Fix:\nInstead of using sendValue, use a pattern that checks for the success of the call. For example, you can use the following pattern to ensure that the transfer succeeds:\n\nsolidity\n(bool success, ) = to.call{value: amount}("""");\nrequire(success, ""Transfer failed"");\n\nThis ensures that if the transfer fails, the transaction will revert, maintaining the integrity of the contract\'s state.\n\'\'\'\n\n\n\nUNCHECKED LOW-LEVEL CALL VULNERABILITY\n\'\'\'\nThe contract also uses the sendValue function in the marketWithdrawFrom and marketWithdrawLocked functions. Similar to the previous case, these calls do not check if the ETH transfer was successful. If the recipient contract reverts during the transfer, it could lead to a loss of funds or inconsistent state.\n\nRecommended Mitigation/Fix:\nImplement a check for the success of the ETH transfer as shown below:\n\nsolidity\n(bool success, ) = msg.sender.call{value: amount}("""");\nrequire(success, ""Transfer failed"");\n\nThis will ensure that the transaction reverts if the ETH transfer fails, preventing any potential loss of funds.\n\'\'\'\n```'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-11-08 20:26:05 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol""; import ""@openzeppelin/contracts/utils/math/Math.sol""; import ""./libraries/LockedBalance.sol""; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = ""Foundation Wrapped Ether"";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = ""FETH""; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-11-08 20:26:05 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts/utils/math/Math.sol"";

import ""./libraries/LockedBalance.sol"";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = ""Foundation Wrapped Ether"";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = ""FETH"";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""/*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts/utils/math/Math.sol"";

import ""./libraries/LockedBalance.sol"";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = ""Foundation Wrapped Ether"";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = ""FETH"";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
"".
Ideas: "" Unchecked Low-level Calls Identified.

```
UNCHECKED LOW-LEVEL CALL VULNERABILITY
'''
The contract uses the `sendValue` function from the `AddressUpgradeable` library, which is a low-level call to transfer ETH. This function does not check for the success of the call, meaning if the transfer fails (for example, if the recipient is a contract that reverts on receiving ETH), the transaction will not revert, and the state of the contract may become inconsistent. This can lead to a loss of funds or unexpected behavior.

Recommended Mitigation/Fix:
Instead of using `sendValue`, use a pattern that checks for the success of the call. For example, you can use the following pattern to ensure that the transfer succeeds:

```solidity
(bool success, ) = to.call{value: amount}("""");
require(success, ""Transfer failed"");
```
This ensures that if the transfer fails, the transaction will revert, maintaining the integrity of the contract's state.
'''
```

```
UNCHECKED LOW-LEVEL CALL VULNERABILITY
'''
The contract also uses the `sendValue` function in the `marketWithdrawFrom` and `marketWithdrawLocked` functions. Similar to the previous case, these calls do not check if the ETH transfer was successful. If the recipient contract reverts during the transfer, it could lead to a loss of funds or inconsistent state.

Recommended Mitigation/Fix:
Implement a check for the success of the ETH transfer as shown below:

```solidity
(bool success, ) = msg.sender.call{value: amount}("""");
require(success, ""Transfer failed"");
```
This will ensure that the transaction reverts if the ETH transfer fails, preventing any potential loss of funds.
'''
```"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Transactions Order Dependence. Transactions Order Dependence vulnerabilities can result in unintended consequences and create opportunities for malicious actors to exploit transaction sequencing.
Please conduct a thorough analysis, considering the following information:
1. Review the contract's code logic to identify any potential areas where the order of transaction execution might have an impact on the contract's behavior.

2. Examine critical functions, particularly those involving fund transfers or resource allocation, to ensure they are not susceptible to Transactions Order Dependence.

3. Investigate scenarios in which gas prices can be manipulated to change the order of transaction execution.

If you identify Transactions Order Dependence, respond with: ""","<INFO> Transactions Order Dependence Identified.

VULNERABILITY NAME: Transactions Order Dependence
'''
The contract has several critical functions that involve fund transfers and resource allocation, particularly in the `marketWithdrawFrom` and `marketWithdrawLocked` functions. These functions allow the Foundation market to withdraw funds from users' accounts. If multiple transactions are sent in quick succession, a malicious actor could exploit the order of these transactions to manipulate the state of the contract.

For instance, if a user has a balance that is close to being exhausted and a malicious actor sends a transaction to withdraw funds just before the user sends a transaction to deposit more funds, the malicious actor could potentially withdraw funds that the user intended to use. This could lead to a situation where the user is unable to access their funds due to the order of transactions being manipulated.

Recommended Mitigation/Fix:
To mitigate this risk, implement a mechanism that locks the user's account during critical operations such as withdrawals or deposits. This could be achieved by introducing a state variable that indicates whether a transaction is in progress for a user. If a transaction is in progress, any subsequent transactions from that user should be rejected until the first transaction is completed. This ensures that the order of transactions cannot be exploited by malicious actors.
'''

[2024-11-08 20:26:10 INFO] **[Execute Detail]**

execute SimplePhase:[TimeStampManipulationDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-11-08 20:26:10 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol""; import ""@openzeppelin/contracts/utils/math/Math.sol""; import ""./libraries/LockedBalance.sol""; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = ""Foundation Wrapped Ether"";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = ""FETH""; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to conduct a comprehensive inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Timestamp Manipulation. Timestamp Manipulation vulnerabilities can occur in the following cases: 1. When the contract relies on block timestamps (e.g., block.timestamp, now) for critical decisions, such as generating randomness or enforcing time-based conditions. 2. When the contract uses block timestamps to determine the outcome of random number generation, which can be manipulated by miners. 3. When the contract's logic depends on exact timestamps for time-based conditions like auction timing or lockup periods, allowing miners to manipulate the outcome. Please conduct a thorough analysis, considering the following information: 1. Review the contract's code logic to identify any potential areas where block timestamps are used for critical decisions.   Examine critical functions, particularly those involving randomness generation, timed conditions, and state changes based on timestamps, to ensure they have proper checks in place.   Verify that the contract minimizes reliance on block timestamps and uses alternative methods where possible to prevent manipulation.   If you identify Timestamp Manipulation, respond with: "" Timestamp Manipulation Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If you don't find any vulnerabilities, respond only with: "" NO Timestamp Manipulation."" |
| **phase_name** | TimeStampManipulationDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '/\n  ･\n   \u3000★\n      ･ ｡\n        \u3000･\u3000ﾟ☆ ｡\n  \u3000\u3000\u3000 \u3000★ ﾟ･｡ *  ｡\n          \u3000\u3000 ☆ ｡･ﾟ.｡\n      \u3000\u3000\u3000ﾟ .｡☆｡★\u3000･\n\u200b\n                      .-:::::-.              -::---...```\n-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy\n-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo\n                                              ````\n   *\u3000\n      ･ ｡\n\u3000\u3000\u3000\u3000･\u3000\u3000ﾟ☆ ｡\n  \u3000\u3000\u3000 *\u3000★ ﾟ･｡ *  ｡\n          \u3000\u3000* ☆ ｡･ﾟ*.｡\n      \u3000\u3000\u3000ﾟ *.｡☆｡★\u3000･\n    *\u3000\u3000ﾟ｡·*･｡ ﾟ*\n  \u3000\u3000\u3000☆ﾟ･｡°*. ﾟ\n\u3000 ･ ﾟ*｡･ﾟ★｡\n\u3000\u3000･ *ﾟ｡\u3000\u3000 *\n\u3000･ﾟ*｡★･\n ☆∴｡\u3000*\n･ ｡\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";\nimport ""@openzeppelin/contracts/utils/math/Math.sol"";\n\nimport ""./libraries/LockedBalance.sol"";\n\nerror FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\nerror FETH_Escrow_Expired();\nerror FETH_Escrow_Not_Found();\nerror FETH_Expiration_Too_Far_In_Future();\n/// @param amount The current allowed amount the spender is authorized to transact for this account.\nerror FETH_Insufficient_Allowance(uint256 amount);\n/// @param amount The current available (unlocked) token count of this account.\nerror FETH_Insufficient_Available_Funds(uint256 amount);\n/// @param amount The current number of tokens this account has for the given lockup expiry bucket.\nerror FETH_Insufficient_Escrow(uint256 amount);\nerror FETH_Invalid_Lockup_Duration();\nerror FETH_Market_Must_Be_A_Contract();\nerror FETH_Must_Deposit_Non_Zero_Amount();\nerror FETH_Must_Lockup_Non_Zero_Amount();\nerror FETH_No_Funds_To_Withdraw();\nerror FETH_Only_FND_Market_Allowed();\nerror FETH_Too_Much_ETH_Provided();\nerror FETH_Transfer_To_Burn_Not_Allowed();\nerror FETH_Transfer_To_FETH_Not_Allowed();\n\n/**\n * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.\n * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after\n * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).\n * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be\n * transferred or withdrawn, except by our market contract which requested the lockup in the first place.\n * @dev Locked balances are rounded up to the next hour.\n * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".\n * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.\n */\ncontract FETH {\n  using AddressUpgradeable for address payable;\n  using LockedBalance for LockedBalance.Lockups;\n  using Math for uint256;\n\n  /// @notice Tracks an account\'s info.\n  struct AccountInfo {\n    /// @notice The number of tokens which have been unlocked already.\n    uint96 freedBalance;\n    /// @notice The first applicable lockup bucket for this account.\n    uint32 lockupStartIndex;\n    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.\n    LockedBalance.Lockups lockups;\n    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.\n    mapping(address =&gt; uint256) allowance;\n  }\n\n  /// @notice Stores per-account details.\n  mapping(address =&gt; AccountInfo) private accountToInfo;\n\n  // Lockup configuration\n  /// @notice The minimum lockup period in seconds.\n  uint256 private immutable lockupDuration;\n  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.\n  uint256 private immutable lockupInterval;\n\n  /// @notice The Foundation market contract with permissions to manage lockups.\n  address payable private immutable foundationMarket;\n\n  // ERC-20 metadata fields\n  /**\n   * @notice The number of decimals the token uses.\n   * @dev This method can be used to improve usability when displaying token amounts, but all interactions\n   * with this contract use whole amounts not considering decimals.\n   * @return 18\n   */\n  uint8 public constant decimals = 18;\n  /**\n   * @notice The name of the token.\n   * @return Foundation Wrapped Ether\n   */\n  string public constant name = ""Foundation Wrapped Ether"";\n  /**\n   * @notice The symbol of the token.\n   * @return FETH\n   */\n  string public constant symbol = ""FETH"";\n\n  // ERC-20 events\n  /**\n   * @notice Emitted when the allowance for a spender account is updated.\n   * @param from The account the spender is authorized to transact for.\n   * @param spender The account with permissions to manage FETH tokens for thefromaccount.\n   * @param amount The max amount of tokens which can be spent by thespenderaccount.\n   */\n  event Approval(address indexed from, address indexed spender, uint256 amount);\n  /**\n   * @notice Emitted when a transfer of FETH tokens is made from one account to another.\n   * @param from The account which is sending FETH tokens.\n   * @param to The account which is receiving FETH tokens.\n   * @param amount The number of FETH tokens which were sent.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  // Custom events\n  /**\n   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours\n   * and may include newly deposited ETH which is added to the account\'s total FETH balance.\n   * @param account The account which has access to the FETH after theexpiration.\n   * @param expiration The time at which thefromaccount will have access to the locked FETH.\n   * @param amount The number of FETH tokens which where locked up.\n   * @param valueDeposited The amount of ETH added to their account\'s total FETH balance,\n   * this may be lower thanamountif available FETH was leveraged.\n   */\n  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);\n  /**\n   * @notice Emitted when FETH tokens are unlocked by the Foundation market.\n   * @dev This event will not be emitted when lockups expire,\n   * it\'s only for tokens which are unlocked before their expiry.\n   * @param account The account which had locked FETH freed before expiration.\n   * @param expiration The time this balance was originally scheduled to be unlocked.\n   * @param amount The number of FETH tokens which were unlocked.\n   */\n  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);\n  /**\n   * @notice Emitted when ETH is withdrawn from a user\'s account.\n   * @dev This may be triggered by the user, an approved operator, or the Foundation market.\n   * @param from The account from which FETH was deducted in order to send the ETH.\n   * @param to The address the ETH was sent to.\n   * @param amount The number of tokens which were deducted from the user\'s FETH balance and transferred as ETH.\n   */\n  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);\n\n  /// @dev Allows the Foundation market permission to manage lockups for a user.\n  modifier onlyFoundationMarket() {\n    if (msg.sender != foundationMarket) {\n      revert FETH_Only_FND_Market_Allowed();\n    }\n    _;\n  }\n\n  /**\n   * @notice Initializes variables which may differ on testnet.\n   * @param _foundationMarket The address of the Foundation NFT marketplace.\n   * @param _lockupDuration The minimum length of time to lockup tokens for whenBalanceLocked, in seconds.\n   */\n  constructor(address payable _foundationMarket, uint256 _lockupDuration) {\n    if (!_foundationMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    foundationMarket = _foundationMarket;\n    lockupDuration = _lockupDuration;\n    lockupInterval = _lockupDuration / 24;\n    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {\n      revert FETH_Invalid_Lockup_Duration();\n    }\n  }\n\n  /**\n   * @notice Transferring ETH (viamsg.value) to the contract performs adepositinto the user\'s account.\n   */\n  receive() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Approves aspenderas an operator with permissions to transfer from your account.\n   * @param spender The address of the operator account that has approval to spend funds\n   * from themsg.sender\'s account.\n   * @param amount The max number of FETH tokens frommsg.sender\'s account that this spender is\n   * allowed to transact with.\n   * @return success Always true.\n   */\n  function approve(address spender, uint256 amount) external returns (bool success) {\n    accountToInfo[msg.sender].allowance[spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Deposit ETH (viamsg.value) and receive the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   */\n  function deposit() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Deposit ETH (viamsg.value) and credit theaccountprovided with the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   * @dev This may be used by the Foundation market to credit a user\'s account with FETH tokens.\n   * @param account The account to credit with FETH tokens.\n   */\n  function depositFor(address account) public payable {\n    if (msg.value == 0) {\n      revert FETH_Must_Deposit_Non_Zero_Amount();\n    }\n    AccountInfo storage accountInfo = accountToInfo[account];\n    // ETH value cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(msg.value);\n    }\n    emit Transfer(address(0), account, msg.value);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account\'s lockup and then create a new lockup, potentially for a different account.\n   * @dev Used by the market when an offer for an NFT is increased.\n   * This may be for a single account (increasing their offer)\n   * or two different accounts (outbidding someone elses offer).\n   * @param unlockFrom The account whose lockup is to be removed.\n   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param unlockAmount The number of tokens to be unlocked fromunlockFrom\'s account.\n   * This will revert if the tokens were previously unlocked.\n   * @param lockupFor The account to which the funds are to be deposited for (via themsg.value) and tokens locked up.\n   * @param lockupAmount The number of tokens to be locked up for thelockupFor\'s account.\n   *msg.valuemust be &lt;=lockupAmountand any delta will be taken from the account\'s available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketChangeLockup(\n    address unlockFrom,\n    uint256 unlockExpiration,\n    uint256 unlockAmount,\n    address lockupFor,\n    uint256 lockupAmount\n  ) external payable onlyFoundationMarket returns (uint256 expiration) {\n    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);\n    return _marketLockupFor(lockupFor, lockupAmount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Lockup an account\'s FETH tokens for 24-25 hours.\n   * @dev Used by the market when a new offer for an NFT is made.\n   * @param account The account to which the funds are to be deposited for (via themsg.value) and tokens locked up.\n   * @param amount The number of tokens to be locked up for thelockupFor\'s account.\n   *msg.valuemust be &lt;=amountand any delta will be taken from the account\'s available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketLockupFor(address account, uint256 amount)\n    external\n    payable\n    onlyFoundationMarket\n    returns (uint256 expiration)\n  {\n    return _marketLockupFor(account, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account\'s lockup, making the FETH tokens available for transfer or withdrawal.\n   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT\n   * receives its first bid or the buyer purchased the NFT another way, such as withbuy.\n   * @param account The account whose lockup is to be unlocked.\n   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked fromaccount.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _marketUnlockFor(account, expiration, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes tokens from the user\'s available balance and returns ETH to the caller.\n   * @dev Used by the market when a user\'s available FETH balance is used to make a purchase\n   * including accepting a buy price or a private sale, or placing a bid in an auction.\n   * @param from The account whose available balance is to be withdrawn from.\n   * @param amount The number of tokens to be deducted fromunlockFrom\'s available balance and transferred as ETH.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(from, msg.sender, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes a lockup from the user\'s account and then returns ETH to the caller.\n   * @dev Used by the market to extract unexpired funds as ETH to distribute for\n   * a sale when the user\'s offer is accepted.\n   * @param account The account whose lockup is to be removed.\n   * @param expiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked and withdrawn as ETH.\n   */\n  function marketWithdrawLocked(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _removeFromLockedBalance(account, expiration, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(account, msg.sender, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from your account.\n   * @param to The address of the account which the tokens are transferred from.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds).\n   */\n  function transfer(address to, uint256 amount) external returns (bool success) {\n    return transferFrom(msg.sender, to, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from the account specified if themsg.senderhas approval.\n   * @param from The address from which the available tokens are transferred from.\n   * @param to The address to which the tokens are to be transferred.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds or not approved).\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public returns (bool success) {\n    if (to == address(0)) {\n      revert FETH_Transfer_To_Burn_Not_Allowed();\n    } else if (to == address(this)) {\n      revert FETH_Transfer_To_FETH_Not_Allowed();\n    }\n    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(fromAccountInfo, amount);\n    }\n    _deductBalanceFrom(fromAccountInfo, amount);\n    AccountInfo storage toAccountInfo = accountToInfo[to];\n\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      toAccountInfo.freedBalance += uint96(amount);\n    }\n\n    emit Transfer(from, to, amount);\n\n    return true;\n  }\n\n  /**\n   * @notice Withdraw all tokens available in your account and receive ETH.\n   */\n  function withdrawAvailableBalance() external {\n    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);\n    uint256 amount = accountInfo.freedBalance;\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    delete accountInfo.freedBalance;\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(msg.sender, msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw the specified number of tokens from thefromaccounts available balance\n   * and send ETH to the destination address, if themsg.senderhas approval.\n   * @param from The address from which the available funds are to be withdrawn.\n   * @param to The destination address for the ETH to be transferred to.\n   * @param amount The number of tokens to be withdrawn and transferred as ETH.\n   */\n  function withdrawFrom(\n    address from,\n    address payable to,\n    uint256 amount\n  ) external {\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(accountInfo, amount);\n    }\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    to.sendValue(amount);\n\n    emit ETHWithdrawn(from, to, amount);\n  }\n\n  /**\n   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.\n   */\n  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    if (accountInfo.allowance[msg.sender] != type(uint256).max) {\n      if (accountInfo.allowance[msg.sender] &lt; amount) {\n        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);\n      }\n      // The check above ensures allowance cannot underflow.\n      unchecked {\n        accountInfo.allowance[msg.sender] -= amount;\n      }\n    }\n  }\n\n  /**\n   * @dev Removes an amount from the account\'s available FETH balance.\n   */\n  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    // Free from escrow in order to consider any expired escrow balance\n    if (accountInfo.freedBalance &lt; amount) {\n      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\n    }\n    // The check above ensures balance cannot underflow.\n    unchecked {\n      accountInfo.freedBalance -= uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Moves expired escrow to the available balance.\n   */\n  function _freeFromEscrow(address account) private returns (AccountInfo storage) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required\n    if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {\n      return accountInfo;\n    }\n\n    while (true) {\n      // Total ETH cannot realistically overflow 96 bits.\n      unchecked {\n        accountInfo.freedBalance += escrow.totalAmount;\n        accountInfo.lockups.del(escrowIndex);\n        // Escrow index cannot overflow 32 bits.\n        escrow = accountInfo.lockups.get(escrowIndex + 1);\n      }\n\n      // If the next bucket is empty, the start index is set to the previous bucket\n      if (escrow.expiration == 0) {\n        break;\n      }\n\n      // Escrow index cannot overflow 32 bits.\n      unchecked {\n        // Increment the escrow start index if the next bucket is not empty\n        ++escrowIndex;\n      }\n\n      // If the next bucket is expired, that\'s the new start index\n      if (escrow.expiration &gt;= block.timestamp) {\n        break;\n      }\n    }\n\n    // Escrow index cannot overflow 32 bits.\n    unchecked {\n      accountInfo.lockupStartIndex = uint32(escrowIndex);\n    }\n    return accountInfo;\n  }\n\n  /**\n   * @notice Lockup an account\'s FETH tokens for 24-25 hours.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {\n    if (account == address(0)) {\n      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\n    }\n    if (amount == 0) {\n      revert FETH_Must_Lockup_Non_Zero_Amount();\n    }\n\n    // Block timestamp in seconds is small enough to never overflow\n    unchecked {\n      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours\n      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;\n    }\n\n    // Update available escrow\n    // Always free from escrow to ensure the max bucket count is &lt;= 25\n    AccountInfo storage accountInfo = _freeFromEscrow(account);\n    if (msg.value &lt; amount) {\n      // The check above prevents underflow with delta.\n      unchecked {\n        uint256 delta = amount - msg.value;\n        if (accountInfo.freedBalance &lt; delta) {\n          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\n        }\n        // The check above prevents underflow of freed balance.\n        accountInfo.freedBalance -= uint96(delta);\n      }\n    } else if (msg.value != amount) {\n      // There\'s no reason to send msg.value more than the amount being locked up\n      revert FETH_Too_Much_ETH_Provided();\n    }\n\n    // Add to locked escrow\n    unchecked {\n      // The number of buckets is always &lt; 256 bits.\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          if (expiration &gt; type(uint32).max) {\n            revert FETH_Expiration_Too_Far_In_Future();\n          }\n          // Amount (ETH) will always be &lt; 96 bits.\n          accountInfo.lockups.set(escrowIndex, expiration, amount);\n          break;\n        }\n        if (escrow.expiration == expiration) {\n          // Total ETH will always be &lt; 96 bits.\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);\n          break;\n        }\n      }\n    }\n\n    emit BalanceLocked(account, expiration, amount, msg.value);\n  }\n\n  /**\n   * @notice Remove an account\'s lockup, making the FETH tokens available for transfer or withdrawal.\n   */\n  function _marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private {\n    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Removes the specified amount from locked escrow, potentially before its expiration.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _removeFromLockedBalance(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private returns (AccountInfo storage) {\n    if (expiration &lt; block.timestamp) {\n      revert FETH_Escrow_Expired();\n    }\n\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    if (escrow.expiration == expiration) {\n      // If removing from the first bucket, we may be able to delete it\n      if (escrow.totalAmount == amount) {\n        accountInfo.lockups.del(escrowIndex);\n\n        // Bump the escrow start index unless it\'s the last one\n        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {\n          // The number of escrow buckets will never overflow 32 bits.\n          unchecked {\n            ++accountInfo.lockupStartIndex;\n          }\n        }\n      } else {\n        if (escrow.totalAmount &lt; amount) {\n          revert FETH_Insufficient_Escrow(escrow.totalAmount);\n        }\n        // The require above ensures balance will not underflow.\n        unchecked {\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n        }\n      }\n    } else {\n      // Removing from the 2nd+ bucket\n      while (true) {\n        // The number of escrow buckets will never overflow 32 bits.\n        unchecked {\n          ++escrowIndex;\n        }\n        escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == expiration) {\n          if (amount &gt; escrow.totalAmount) {\n            revert FETH_Insufficient_Escrow(escrow.totalAmount);\n          }\n          // The require above ensures balance will not underflow.\n          unchecked {\n            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n          }\n          // We may have an entry with 0 totalAmount but expiration will be set\n          break;\n        }\n        if (escrow.expiration == 0) {\n          revert FETH_Escrow_Not_Found();\n        }\n      }\n    }\n\n    emit BalanceUnlocked(account, expiration, amount);\n    return accountInfo;\n  }\n\n  /**\n   * @notice Returns the amount which a spender is still allowed to transact from theaccount\'s balance.\n   * @param account The owner of the funds.\n   * @param operator The address with approval to spend from theaccount\'s balance.\n   * @return amount The number of tokens theoperatoris still allowed to transact with.\n   */\n  function allowance(address account, address operator) external view returns (uint256 amount) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    return accountInfo.allowance[operator];\n  }\n\n  /**\n   * @notice Returns the balance of an account which is available to transfer or withdraw.\n   * @dev This will automatically increase as soon as locked tokens reach their expiry date.\n   * @param account The account to query the available balance of.\n   * @return balance The available balance of the account.\n   */\n  function balanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits.\n    unchecked {\n      // Add expired lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Gets the Foundation market address which has permissions to manage lockups.\n   * @return market The Foundation market contract address.\n   */\n  function getFoundationMarket() external view returns (address market) {\n    return foundationMarket;\n  }\n\n  /**\n   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.\n   * @devexpires.length==amounts.length\n   * andamounts[i]is the number of tokens which will expire atexpires[i].\n   * The results returned are sorted by expiry, with the earliest expiry date first.\n   * @param account The account to query the locked balance of.\n   * @return expiries The time at which each outstanding lockup bucket expires.\n   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.\n   */\n  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n\n    // Count lockups\n    uint256 lockedCount;\n    // The number of buckets is always &lt; 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {\n          // Lockup count will never overflow 256 bits.\n          ++lockedCount;\n        }\n      }\n    }\n\n    // Allocate arrays\n    expiries = new uint256[](lockedCount);\n    amounts = new uint256[](lockedCount);\n\n    // Populate results\n    uint256 i;\n    // The number of buckets is always &lt; 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {\n          expiries[i] = escrow.expiration;\n          amounts[i] = escrow.totalAmount;\n          ++i;\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total balance of an account, including locked FETH tokens.\n   * @dev UsebalanceOfto get the number of tokens available for transfer or withdrawal.\n   * @param account The account to query the total balance of.\n   * @return balance The total FETH balance tracked for this account.\n   */\n  function totalBalanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits.\n    unchecked {\n      // Add all lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total amount of ETH locked in this contract.\n   * @return supply The total amount of ETH locked in this contract.\n   */\n  function totalSupply() external view returns (uint256 supply) {\n    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct\n       but this is on-par with the WETH implementation and done for gas savings. */\n    return address(this).balance;\n  }\n}\n', 'ideas': "" Transactions Order Dependence Identified.\n\nVULNERABILITY NAME: Transactions Order Dependence\n'''\nThe contract has several critical functions that involve fund transfers and resource allocation, particularly in themarketWithdrawFromandmarketWithdrawLocked` functions. These functions allow the Foundation market to withdraw funds from users' accounts. If multiple transactions are sent in quick succession, a malicious actor could exploit the order of these transactions to manipulate the state of the contract.\n\nFor instance, if a user has a balance that is close to being exhausted and a malicious actor sends a transaction to withdraw funds just before the user sends a transaction to deposit more funds, the malicious actor could potentially withdraw funds that the user intended to use. This could lead to a situation where the user is unable to access their funds due to the order of transactions being manipulated.\n\nRecommended Mitigation/Fix:\nTo mitigate this risk, implement a mechanism that locks the user's account during critical operations such as withdrawals or deposits. This could be achieved by introducing a state variable that indicates whether a transaction is in progress for a user. If a transaction is in progress, any subsequent transactions from that user should be rejected until the first transaction is completed. This ensures that the order of transactions cannot be exploited by malicious actors.\n'''""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-11-08 20:26:10 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol""; import ""@openzeppelin/contracts/utils/math/Math.sol""; import ""./libraries/LockedBalance.sol""; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = ""Foundation Wrapped Ether"";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = ""FETH""; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-11-08 20:26:10 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts/utils/math/Math.sol"";

import ""./libraries/LockedBalance.sol"";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = ""Foundation Wrapped Ether"";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = ""FETH"";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""/*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts/utils/math/Math.sol"";

import ""./libraries/LockedBalance.sol"";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = ""Foundation Wrapped Ether"";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = ""FETH"";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
"".
Ideas: "" Transactions Order Dependence Identified.

VULNERABILITY NAME: Transactions Order Dependence
'''
The contract has several critical functions that involve fund transfers and resource allocation, particularly in the `marketWithdrawFrom` and `marketWithdrawLocked` functions. These functions allow the Foundation market to withdraw funds from users' accounts. If multiple transactions are sent in quick succession, a malicious actor could exploit the order of these transactions to manipulate the state of the contract.

For instance, if a user has a balance that is close to being exhausted and a malicious actor sends a transaction to withdraw funds just before the user sends a transaction to deposit more funds, the malicious actor could potentially withdraw funds that the user intended to use. This could lead to a situation where the user is unable to access their funds due to the order of transactions being manipulated.

Recommended Mitigation/Fix:
To mitigate this risk, implement a mechanism that locks the user's account during critical operations such as withdrawals or deposits. This could be achieved by introducing a state variable that indicates whether a transaction is in progress for a user. If a transaction is in progress, any subsequent transactions from that user should be rejected until the first transaction is completed. This ensures that the order of transactions cannot be exploited by malicious actors.
'''"".
As the Security Analyst, your primary objective is to conduct a comprehensive inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Timestamp Manipulation. Timestamp Manipulation vulnerabilities can occur in the following cases:
1. When the contract relies on block timestamps (e.g., block.timestamp, now) for critical decisions, such as generating randomness or enforcing time-based conditions.
2. When the contract uses block timestamps to determine the outcome of random number generation, which can be manipulated by miners.
3. When the contract's logic depends on exact timestamps for time-based conditions like auction timing or lockup periods, allowing miners to manipulate the outcome.
Please conduct a thorough analysis, considering the following information:
1. Review the contract's code logic to identify any potential areas where block timestamps are used for critical decisions.

2. Examine critical functions, particularly those involving randomness generation, timed conditions, and state changes based on timestamps, to ensure they have proper checks in place.

3. Verify that the contract minimizes reliance on block timestamps and uses alternative methods where possible to prevent manipulation.

If you identify Timestamp Manipulation, respond with: ""","<INFO> Timestamp Manipulation Identified.
```
VULNERABILITY NAME: Timestamp Manipulation
'''
The contract relies on block timestamps in several critical functions, particularly in the `_marketLockupFor` function where it calculates the expiration of lockup periods using `block.timestamp`. This reliance on block timestamps can be exploited by miners, who can manipulate the timestamp of the block they mine to influence the outcome of time-based conditions. For example, if a miner knows that a lockup period is about to expire, they could manipulate the timestamp to extend the lockup period or to create an advantage in a time-sensitive transaction.

Recommended Mitigation/Fix:
To mitigate this risk, avoid using `block.timestamp` for critical decisions. Instead, consider using block numbers or implementing a more robust mechanism that includes a time oracle or a decentralized time source. Additionally, implement checks to ensure that the timestamp used is within a reasonable range of the current block time to prevent manipulation.
'''
```

[2024-11-08 20:26:14 INFO] **[Execute Detail]**

execute SimplePhase:[PredictableRandDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-11-08 20:26:14 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol""; import ""@openzeppelin/contracts/utils/math/Math.sol""; import ""./libraries/LockedBalance.sol""; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = ""Foundation Wrapped Ether"";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = ""FETH""; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Predictable Randomness. There are two cases, the code may have Predictable Randomness vulnerabilities: 1. Reliance on blockhash for randomness, which pertains to the flawed generation of random numbers within smart contracts. Random numbers often influence the decisions or outcomes of contract functionalities. If the process of random number generation is compromised, adversaries may predict the contract outcome, leading to potential exploitation. 2. Reliance on blocknumber for randomness, which will be used by attacker if he control the number of blocks mined in a given time frame. If the process of random number generation is compromised, adversaries may predict the contract outcome, leading to potential If you identify Reliance on blockhash for randomness, respond with: "" Predictable Randomness Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If you don't find any vulnerabilities, respond only with: "" NO Predictable Randomness."" |
| **phase_name** | PredictableRandDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '/\n  ･\n   \u3000★\n      ･ ｡\n        \u3000･\u3000ﾟ☆ ｡\n  \u3000\u3000\u3000 \u3000★ ﾟ･｡ *  ｡\n          \u3000\u3000 ☆ ｡･ﾟ.｡\n      \u3000\u3000\u3000ﾟ .｡☆｡★\u3000･\n\u200b\n                      .-:::::-.              -::---...```\n-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy\n-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo\n                                              ``\n   *\u3000\n      ･ ｡\n\u3000\u3000\u3000\u3000･\u3000\u3000ﾟ☆ ｡\n  \u3000\u3000\u3000 *\u3000★ ﾟ･｡ *  ｡\n          \u3000\u3000* ☆ ｡･ﾟ*.｡\n      \u3000\u3000\u3000ﾟ *.｡☆｡★\u3000･\n    *\u3000\u3000ﾟ｡·*･｡ ﾟ*\n  \u3000\u3000\u3000☆ﾟ･｡°*. ﾟ\n\u3000 ･ ﾟ*｡･ﾟ★｡\n\u3000\u3000･ *ﾟ｡\u3000\u3000 *\n\u3000･ﾟ*｡★･\n ☆∴｡\u3000*\n･ ｡\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";\nimport ""@openzeppelin/contracts/utils/math/Math.sol"";\n\nimport ""./libraries/LockedBalance.sol"";\n\nerror FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\nerror FETH_Escrow_Expired();\nerror FETH_Escrow_Not_Found();\nerror FETH_Expiration_Too_Far_In_Future();\n/// @param amount The current allowed amount the spender is authorized to transact for this account.\nerror FETH_Insufficient_Allowance(uint256 amount);\n/// @param amount The current available (unlocked) token count of this account.\nerror FETH_Insufficient_Available_Funds(uint256 amount);\n/// @param amount The current number of tokens this account has for the given lockup expiry bucket.\nerror FETH_Insufficient_Escrow(uint256 amount);\nerror FETH_Invalid_Lockup_Duration();\nerror FETH_Market_Must_Be_A_Contract();\nerror FETH_Must_Deposit_Non_Zero_Amount();\nerror FETH_Must_Lockup_Non_Zero_Amount();\nerror FETH_No_Funds_To_Withdraw();\nerror FETH_Only_FND_Market_Allowed();\nerror FETH_Too_Much_ETH_Provided();\nerror FETH_Transfer_To_Burn_Not_Allowed();\nerror FETH_Transfer_To_FETH_Not_Allowed();\n\n/**\n * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.\n * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after\n * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).\n * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be\n * transferred or withdrawn, except by our market contract which requested the lockup in the first place.\n * @dev Locked balances are rounded up to the next hour.\n * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".\n * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.\n */\ncontract FETH {\n  using AddressUpgradeable for address payable;\n  using LockedBalance for LockedBalance.Lockups;\n  using Math for uint256;\n\n  /// @notice Tracks an account\'s info.\n  struct AccountInfo {\n    /// @notice The number of tokens which have been unlocked already.\n    uint96 freedBalance;\n    /// @notice The first applicable lockup bucket for this account.\n    uint32 lockupStartIndex;\n    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.\n    LockedBalance.Lockups lockups;\n    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.\n    mapping(address =&gt; uint256) allowance;\n  }\n\n  /// @notice Stores per-account details.\n  mapping(address =&gt; AccountInfo) private accountToInfo;\n\n  // Lockup configuration\n  /// @notice The minimum lockup period in seconds.\n  uint256 private immutable lockupDuration;\n  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.\n  uint256 private immutable lockupInterval;\n\n  /// @notice The Foundation market contract with permissions to manage lockups.\n  address payable private immutable foundationMarket;\n\n  // ERC-20 metadata fields\n  /**\n   * @notice The number of decimals the token uses.\n   * @dev This method can be used to improve usability when displaying token amounts, but all interactions\n   * with this contract use whole amounts not considering decimals.\n   * @return 18\n   */\n  uint8 public constant decimals = 18;\n  /**\n   * @notice The name of the token.\n   * @return Foundation Wrapped Ether\n   */\n  string public constant name = ""Foundation Wrapped Ether"";\n  /**\n   * @notice The symbol of the token.\n   * @return FETH\n   */\n  string public constant symbol = ""FETH"";\n\n  // ERC-20 events\n  /**\n   * @notice Emitted when the allowance for a spender account is updated.\n   * @param from The account the spender is authorized to transact for.\n   * @param spender The account with permissions to manage FETH tokens for the `from` account.\n   * @param amount The max amount of tokens which can be spent by the `spender` account.\n   */\n  event Approval(address indexed from, address indexed spender, uint256 amount);\n  /**\n   * @notice Emitted when a transfer of FETH tokens is made from one account to another.\n   * @param from The account which is sending FETH tokens.\n   * @param to The account which is receiving FETH tokens.\n   * @param amount The number of FETH tokens which were sent.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  // Custom events\n  /**\n   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours\n   * and may include newly deposited ETH which is added to the account\'s total FETH balance.\n   * @param account The account which has access to the FETH after the `expiration`.\n   * @param expiration The time at which the `from` account will have access to the locked FETH.\n   * @param amount The number of FETH tokens which where locked up.\n   * @param valueDeposited The amount of ETH added to their account\'s total FETH balance,\n   * this may be lower than `amount` if available FETH was leveraged.\n   */\n  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);\n  /**\n   * @notice Emitted when FETH tokens are unlocked by the Foundation market.\n   * @dev This event will not be emitted when lockups expire,\n   * it\'s only for tokens which are unlocked before their expiry.\n   * @param account The account which had locked FETH freed before expiration.\n   * @param expiration The time this balance was originally scheduled to be unlocked.\n   * @param amount The number of FETH tokens which were unlocked.\n   */\n  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);\n  /**\n   * @notice Emitted when ETH is withdrawn from a user\'s account.\n   * @dev This may be triggered by the user, an approved operator, or the Foundation market.\n   * @param from The account from which FETH was deducted in order to send the ETH.\n   * @param to The address the ETH was sent to.\n   * @param amount The number of tokens which were deducted from the user\'s FETH balance and transferred as ETH.\n   */\n  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);\n\n  /// @dev Allows the Foundation market permission to manage lockups for a user.\n  modifier onlyFoundationMarket() {\n    if (msg.sender != foundationMarket) {\n      revert FETH_Only_FND_Market_Allowed();\n    }\n    _;\n  }\n\n  /**\n   * @notice Initializes variables which may differ on testnet.\n   * @param _foundationMarket The address of the Foundation NFT marketplace.\n   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.\n   */\n  constructor(address payable _foundationMarket, uint256 _lockupDuration) {\n    if (!_foundationMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    foundationMarket = _foundationMarket;\n    lockupDuration = _lockupDuration;\n    lockupInterval = _lockupDuration / 24;\n    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {\n      revert FETH_Invalid_Lockup_Duration();\n    }\n  }\n\n  /**\n   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user\'s account.\n   */\n  receive() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Approves a `spender` as an operator with permissions to transfer from your account.\n   * @param spender The address of the operator account that has approval to spend funds\n   * from the `msg.sender`\'s account.\n   * @param amount The max number of FETH tokens from `msg.sender`\'s account that this spender is\n   * allowed to transact with.\n   * @return success Always true.\n   */\n  function approve(address spender, uint256 amount) external returns (bool success) {\n    accountToInfo[msg.sender].allowance[spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   */\n  function deposit() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   * @dev This may be used by the Foundation market to credit a user\'s account with FETH tokens.\n   * @param account The account to credit with FETH tokens.\n   */\n  function depositFor(address account) public payable {\n    if (msg.value == 0) {\n      revert FETH_Must_Deposit_Non_Zero_Amount();\n    }\n    AccountInfo storage accountInfo = accountToInfo[account];\n    // ETH value cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(msg.value);\n    }\n    emit Transfer(address(0), account, msg.value);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account\'s lockup and then create a new lockup, potentially for a different account.\n   * @dev Used by the market when an offer for an NFT is increased.\n   * This may be for a single account (increasing their offer)\n   * or two different accounts (outbidding someone elses offer).\n   * @param unlockFrom The account whose lockup is to be removed.\n   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`\'s account.\n   * This will revert if the tokens were previously unlocked.\n   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`\'s account.\n   * `msg.value` must be &lt;= `lockupAmount` and any delta will be taken from the account\'s available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketChangeLockup(\n    address unlockFrom,\n    uint256 unlockExpiration,\n    uint256 unlockAmount,\n    address lockupFor,\n    uint256 lockupAmount\n  ) external payable onlyFoundationMarket returns (uint256 expiration) {\n    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);\n    return _marketLockupFor(lockupFor, lockupAmount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Lockup an account\'s FETH tokens for 24-25 hours.\n   * @dev Used by the market when a new offer for an NFT is made.\n   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param amount The number of tokens to be locked up for the `lockupFor`\'s account.\n   * `msg.value` must be &lt;= `amount` and any delta will be taken from the account\'s available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketLockupFor(address account, uint256 amount)\n    external\n    payable\n    onlyFoundationMarket\n    returns (uint256 expiration)\n  {\n    return _marketLockupFor(account, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account\'s lockup, making the FETH tokens available for transfer or withdrawal.\n   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT\n   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.\n   * @param account The account whose lockup is to be unlocked.\n   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked from `account`.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _marketUnlockFor(account, expiration, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes tokens from the user\'s available balance and returns ETH to the caller.\n   * @dev Used by the market when a user\'s available FETH balance is used to make a purchase\n   * including accepting a buy price or a private sale, or placing a bid in an auction.\n   * @param from The account whose available balance is to be withdrawn from.\n   * @param amount The number of tokens to be deducted from `unlockFrom`\'s available balance and transferred as ETH.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(from, msg.sender, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes a lockup from the user\'s account and then returns ETH to the caller.\n   * @dev Used by the market to extract unexpired funds as ETH to distribute for\n   * a sale when the user\'s offer is accepted.\n   * @param account The account whose lockup is to be removed.\n   * @param expiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked and withdrawn as ETH.\n   */\n  function marketWithdrawLocked(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _removeFromLockedBalance(account, expiration, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(account, msg.sender, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from your account.\n   * @param to The address of the account which the tokens are transferred from.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds).\n   */\n  function transfer(address to, uint256 amount) external returns (bool success) {\n    return transferFrom(msg.sender, to, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.\n   * @param from The address from which the available tokens are transferred from.\n   * @param to The address to which the tokens are to be transferred.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds or not approved).\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public returns (bool success) {\n    if (to == address(0)) {\n      revert FETH_Transfer_To_Burn_Not_Allowed();\n    } else if (to == address(this)) {\n      revert FETH_Transfer_To_FETH_Not_Allowed();\n    }\n    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(fromAccountInfo, amount);\n    }\n    _deductBalanceFrom(fromAccountInfo, amount);\n    AccountInfo storage toAccountInfo = accountToInfo[to];\n\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      toAccountInfo.freedBalance += uint96(amount);\n    }\n\n    emit Transfer(from, to, amount);\n\n    return true;\n  }\n\n  /**\n   * @notice Withdraw all tokens available in your account and receive ETH.\n   */\n  function withdrawAvailableBalance() external {\n    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);\n    uint256 amount = accountInfo.freedBalance;\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    delete accountInfo.freedBalance;\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(msg.sender, msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw the specified number of tokens from the `from` accounts available balance\n   * and send ETH to the destination address, if the `msg.sender` has approval.\n   * @param from The address from which the available funds are to be withdrawn.\n   * @param to The destination address for the ETH to be transferred to.\n   * @param amount The number of tokens to be withdrawn and transferred as ETH.\n   */\n  function withdrawFrom(\n    address from,\n    address payable to,\n    uint256 amount\n  ) external {\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(accountInfo, amount);\n    }\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    to.sendValue(amount);\n\n    emit ETHWithdrawn(from, to, amount);\n  }\n\n  /**\n   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.\n   */\n  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    if (accountInfo.allowance[msg.sender] != type(uint256).max) {\n      if (accountInfo.allowance[msg.sender] &lt; amount) {\n        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);\n      }\n      // The check above ensures allowance cannot underflow.\n      unchecked {\n        accountInfo.allowance[msg.sender] -= amount;\n      }\n    }\n  }\n\n  /**\n   * @dev Removes an amount from the account\'s available FETH balance.\n   */\n  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    // Free from escrow in order to consider any expired escrow balance\n    if (accountInfo.freedBalance &lt; amount) {\n      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\n    }\n    // The check above ensures balance cannot underflow.\n    unchecked {\n      accountInfo.freedBalance -= uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Moves expired escrow to the available balance.\n   */\n  function _freeFromEscrow(address account) private returns (AccountInfo storage) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required\n    if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {\n      return accountInfo;\n    }\n\n    while (true) {\n      // Total ETH cannot realistically overflow 96 bits.\n      unchecked {\n        accountInfo.freedBalance += escrow.totalAmount;\n        accountInfo.lockups.del(escrowIndex);\n        // Escrow index cannot overflow 32 bits.\n        escrow = accountInfo.lockups.get(escrowIndex + 1);\n      }\n\n      // If the next bucket is empty, the start index is set to the previous bucket\n      if (escrow.expiration == 0) {\n        break;\n      }\n\n      // Escrow index cannot overflow 32 bits.\n      unchecked {\n        // Increment the escrow start index if the next bucket is not empty\n        ++escrowIndex;\n      }\n\n      // If the next bucket is expired, that\'s the new start index\n      if (escrow.expiration &gt;= block.timestamp) {\n        break;\n      }\n    }\n\n    // Escrow index cannot overflow 32 bits.\n    unchecked {\n      accountInfo.lockupStartIndex = uint32(escrowIndex);\n    }\n    return accountInfo;\n  }\n\n  /**\n   * @notice Lockup an account\'s FETH tokens for 24-25 hours.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {\n    if (account == address(0)) {\n      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\n    }\n    if (amount == 0) {\n      revert FETH_Must_Lockup_Non_Zero_Amount();\n    }\n\n    // Block timestamp in seconds is small enough to never overflow\n    unchecked {\n      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours\n      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;\n    }\n\n    // Update available escrow\n    // Always free from escrow to ensure the max bucket count is &lt;= 25\n    AccountInfo storage accountInfo = _freeFromEscrow(account);\n    if (msg.value &lt; amount) {\n      // The check above prevents underflow with delta.\n      unchecked {\n        uint256 delta = amount - msg.value;\n        if (accountInfo.freedBalance &lt; delta) {\n          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\n        }\n        // The check above prevents underflow of freed balance.\n        accountInfo.freedBalance -= uint96(delta);\n      }\n    } else if (msg.value != amount) {\n      // There\'s no reason to send msg.value more than the amount being locked up\n      revert FETH_Too_Much_ETH_Provided();\n    }\n\n    // Add to locked escrow\n    unchecked {\n      // The number of buckets is always &lt; 256 bits.\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          if (expiration &gt; type(uint32).max) {\n            revert FETH_Expiration_Too_Far_In_Future();\n          }\n          // Amount (ETH) will always be &lt; 96 bits.\n          accountInfo.lockups.set(escrowIndex, expiration, amount);\n          break;\n        }\n        if (escrow.expiration == expiration) {\n          // Total ETH will always be &lt; 96 bits.\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);\n          break;\n        }\n      }\n    }\n\n    emit BalanceLocked(account, expiration, amount, msg.value);\n  }\n\n  /**\n   * @notice Remove an account\'s lockup, making the FETH tokens available for transfer or withdrawal.\n   */\n  function _marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private {\n    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Removes the specified amount from locked escrow, potentially before its expiration.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _removeFromLockedBalance(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private returns (AccountInfo storage) {\n    if (expiration &lt; block.timestamp) {\n      revert FETH_Escrow_Expired();\n    }\n\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    if (escrow.expiration == expiration) {\n      // If removing from the first bucket, we may be able to delete it\n      if (escrow.totalAmount == amount) {\n        accountInfo.lockups.del(escrowIndex);\n\n        // Bump the escrow start index unless it\'s the last one\n        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {\n          // The number of escrow buckets will never overflow 32 bits.\n          unchecked {\n            ++accountInfo.lockupStartIndex;\n          }\n        }\n      } else {\n        if (escrow.totalAmount &lt; amount) {\n          revert FETH_Insufficient_Escrow(escrow.totalAmount);\n        }\n        // The require above ensures balance will not underflow.\n        unchecked {\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n        }\n      }\n    } else {\n      // Removing from the 2nd+ bucket\n      while (true) {\n        // The number of escrow buckets will never overflow 32 bits.\n        unchecked {\n          ++escrowIndex;\n        }\n        escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == expiration) {\n          if (amount &gt; escrow.totalAmount) {\n            revert FETH_Insufficient_Escrow(escrow.totalAmount);\n          }\n          // The require above ensures balance will not underflow.\n          unchecked {\n            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n          }\n          // We may have an entry with 0 totalAmount but expiration will be set\n          break;\n        }\n        if (escrow.expiration == 0) {\n          revert FETH_Escrow_Not_Found();\n        }\n      }\n    }\n\n    emit BalanceUnlocked(account, expiration, amount);\n    return accountInfo;\n  }\n\n  /**\n   * @notice Returns the amount which a spender is still allowed to transact from the `account`\'s balance.\n   * @param account The owner of the funds.\n   * @param operator The address with approval to spend from the `account`\'s balance.\n   * @return amount The number of tokens the `operator` is still allowed to transact with.\n   */\n  function allowance(address account, address operator) external view returns (uint256 amount) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    return accountInfo.allowance[operator];\n  }\n\n  /**\n   * @notice Returns the balance of an account which is available to transfer or withdraw.\n   * @dev This will automatically increase as soon as locked tokens reach their expiry date.\n   * @param account The account to query the available balance of.\n   * @return balance The available balance of the account.\n   */\n  function balanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits.\n    unchecked {\n      // Add expired lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Gets the Foundation market address which has permissions to manage lockups.\n   * @return market The Foundation market contract address.\n   */\n  function getFoundationMarket() external view returns (address market) {\n    return foundationMarket;\n  }\n\n  /**\n   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.\n   * @dev `expires.length` == `amounts.length`\n   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.\n   * The results returned are sorted by expiry, with the earliest expiry date first.\n   * @param account The account to query the locked balance of.\n   * @return expiries The time at which each outstanding lockup bucket expires.\n   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.\n   */\n  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n\n    // Count lockups\n    uint256 lockedCount;\n    // The number of buckets is always &lt; 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {\n          // Lockup count will never overflow 256 bits.\n          ++lockedCount;\n        }\n      }\n    }\n\n    // Allocate arrays\n    expiries = new uint256[](lockedCount);\n    amounts = new uint256[](lockedCount);\n\n    // Populate results\n    uint256 i;\n    // The number of buckets is always &lt; 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {\n          expiries[i] = escrow.expiration;\n          amounts[i] = escrow.totalAmount;\n          ++i;\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total balance of an account, including locked FETH tokens.\n   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.\n   * @param account The account to query the total balance of.\n   * @return balance The total FETH balance tracked for this account.\n   */\n  function totalBalanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits.\n    unchecked {\n      // Add all lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total amount of ETH locked in this contract.\n   * @return supply The total amount of ETH locked in this contract.\n   */\n  function totalSupply() external view returns (uint256 supply) {\n    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct\n       but this is on-par with the WETH implementation and done for gas savings. */\n    return address(this).balance;\n  }\n}\n', 'ideas': "" Timestamp Manipulation Identified.\n\nVULNERABILITY NAME: Timestamp Manipulation\n'''\nThe contract relies on block timestamps in several critical functions, particularly in the _marketLockupFor function where it calculates the expiration of lockup periods using block.timestamp. This reliance on block timestamps can be exploited by miners, who can manipulate the timestamp of the block they mine to influence the outcome of time-based conditions. For example, if a miner knows that a lockup period is about to expire, they could manipulate the timestamp to extend the lockup period or to create an advantage in a time-sensitive transaction.\n\nRecommended Mitigation/Fix:\nTo mitigate this risk, avoid using block.timestamp for critical decisions. Instead, consider using block numbers or implementing a more robust mechanism that includes a time oracle or a decentralized time source. Additionally, implement checks to ensure that the timestamp used is within a reasonable range of the current block time to prevent manipulation.\n'''\n```""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-11-08 20:26:14 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol""; import ""@openzeppelin/contracts/utils/math/Math.sol""; import ""./libraries/LockedBalance.sol""; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = ""Foundation Wrapped Ether"";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = ""FETH""; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-11-08 20:26:14 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts/utils/math/Math.sol"";

import ""./libraries/LockedBalance.sol"";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = ""Foundation Wrapped Ether"";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = ""FETH"";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""/*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts/utils/math/Math.sol"";

import ""./libraries/LockedBalance.sol"";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = ""Foundation Wrapped Ether"";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = ""FETH"";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
"".
Ideas: "" Timestamp Manipulation Identified.
```
VULNERABILITY NAME: Timestamp Manipulation
'''
The contract relies on block timestamps in several critical functions, particularly in the `_marketLockupFor` function where it calculates the expiration of lockup periods using `block.timestamp`. This reliance on block timestamps can be exploited by miners, who can manipulate the timestamp of the block they mine to influence the outcome of time-based conditions. For example, if a miner knows that a lockup period is about to expire, they could manipulate the timestamp to extend the lockup period or to create an advantage in a time-sensitive transaction.

Recommended Mitigation/Fix:
To mitigate this risk, avoid using `block.timestamp` for critical decisions. Instead, consider using block numbers or implementing a more robust mechanism that includes a time oracle or a decentralized time source. Additionally, implement checks to ensure that the timestamp used is within a reasonable range of the current block time to prevent manipulation.
'''
```"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Predictable Randomness. There are two cases, the code may have Predictable Randomness vulnerabilities:
1. Reliance on blockhash for randomness, which pertains to the flawed generation of random numbers within smart contracts. Random numbers often influence the decisions or outcomes of contract functionalities. If the process of random number generation is compromised, adversaries may predict the contract outcome, leading to potential exploitation.
2. Reliance on blocknumber for randomness, which will be used by attacker if he control the number of blocks mined in a given time frame. If the process of random number generation is compromised, adversaries may predict the contract outcome, leading to potential
If you identify Reliance on blockhash for randomness, respond with: """,,,,"<INFO> Gas Limit Identified.

**Lack of Gas Limit Considerations**
'''
The function `_freeFromEscrow` contains a while loop that iterates through the escrow buckets until it finds an expired bucket or an empty bucket. If there are many buckets (up to 25 as per the contract's design), and if the first bucket is not expired, the loop could potentially iterate many times, leading to out-of-gas errors if the gas limit is exceeded. This could result in failed transactions for users trying to free their funds from escrow.

To mitigate this, consider implementing a maximum iteration limit within the loop to prevent excessive gas consumption. For example, you could introduce a counter that breaks the loop after a certain number of iterations, ensuring that the function does not run indefinitely.

Additionally, consider using a more gas-efficient data structure or approach to manage the escrow buckets, such as maintaining a pointer to the first expired bucket instead of iterating through all buckets.
'''

**Potential Denial-of-Service (DoS) Vulnerability**
'''
The same function `_freeFromEscrow` could be exploited by a malicious actor who fills up the escrow buckets without allowing them to expire. This could lead to a situation where legitimate users cannot free their funds, effectively causing a denial-of-service for those users. 

To mitigate this risk, implement a mechanism to limit the number of active escrow buckets or enforce a time-based expiration policy that automatically clears expired buckets. This could be done by periodically checking and removing expired buckets during transactions or by implementing a function that can be called to clean up expired buckets.
'''

[2024-11-08 20:26:28 INFO] **[Execute Detail]**

execute SimplePhase:[PriceManipulationDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-11-08 20:26:28 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol""; import ""@openzeppelin/contracts/utils/math/Math.sol""; import ""./libraries/LockedBalance.sol""; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = ""Foundation Wrapped Ether"";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = ""FETH""; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to conduct a comprehensive inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Price Manipulation. There are two cases where the contract may have Price Manipulation vulnerabilities: 1. When the contract allows arbitrary adjustment of token prices by a centralized authority without any checks or balances, potentially leading to unfair trades. 2. When the contract does not utilize decentralized or transparent mechanisms for determining token prices, allowing for potential exploitation by the controlling entity. If you identify all Price Manipulation vulnerabilities, respond with: "" Price Manipulation Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code. ''' If you don't find any vulnerabilities, respond only with: "" No Price Manipulation."" |
| **phase_name** | PriceManipulationDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '/\n  ･\n   \u3000★\n      ･ ｡\n        \u3000･\u3000ﾟ☆ ｡\n  \u3000\u3000\u3000 \u3000★ ﾟ･｡ *  ｡\n          \u3000\u3000 ☆ ｡･ﾟ.｡\n      \u3000\u3000\u3000ﾟ .｡☆｡★\u3000･\n\u200b\n                      .-:::::-.              -::---...```\n-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy\n-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo\n                                              ````\n   *\u3000\n      ･ ｡\n\u3000\u3000\u3000\u3000･\u3000\u3000ﾟ☆ ｡\n  \u3000\u3000\u3000 *\u3000★ ﾟ･｡ *  ｡\n          \u3000\u3000* ☆ ｡･ﾟ*.｡\n      \u3000\u3000\u3000ﾟ *.｡☆｡★\u3000･\n    *\u3000\u3000ﾟ｡·*･｡ ﾟ*\n  \u3000\u3000\u3000☆ﾟ･｡°*. ﾟ\n\u3000 ･ ﾟ*｡･ﾟ★｡\n\u3000\u3000･ *ﾟ｡\u3000\u3000 *\n\u3000･ﾟ*｡★･\n ☆∴｡\u3000*\n･ ｡\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";\nimport ""@openzeppelin/contracts/utils/math/Math.sol"";\n\nimport ""./libraries/LockedBalance.sol"";\n\nerror FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\nerror FETH_Escrow_Expired();\nerror FETH_Escrow_Not_Found();\nerror FETH_Expiration_Too_Far_In_Future();\n/// @param amount The current allowed amount the spender is authorized to transact for this account.\nerror FETH_Insufficient_Allowance(uint256 amount);\n/// @param amount The current available (unlocked) token count of this account.\nerror FETH_Insufficient_Available_Funds(uint256 amount);\n/// @param amount The current number of tokens this account has for the given lockup expiry bucket.\nerror FETH_Insufficient_Escrow(uint256 amount);\nerror FETH_Invalid_Lockup_Duration();\nerror FETH_Market_Must_Be_A_Contract();\nerror FETH_Must_Deposit_Non_Zero_Amount();\nerror FETH_Must_Lockup_Non_Zero_Amount();\nerror FETH_No_Funds_To_Withdraw();\nerror FETH_Only_FND_Market_Allowed();\nerror FETH_Too_Much_ETH_Provided();\nerror FETH_Transfer_To_Burn_Not_Allowed();\nerror FETH_Transfer_To_FETH_Not_Allowed();\n\n/**\n * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.\n * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after\n * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).\n * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be\n * transferred or withdrawn, except by our market contract which requested the lockup in the first place.\n * @dev Locked balances are rounded up to the next hour.\n * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".\n * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.\n */\ncontract FETH {\n  using AddressUpgradeable for address payable;\n  using LockedBalance for LockedBalance.Lockups;\n  using Math for uint256;\n\n  /// @notice Tracks an account\'s info.\n  struct AccountInfo {\n    /// @notice The number of tokens which have been unlocked already.\n    uint96 freedBalance;\n    /// @notice The first applicable lockup bucket for this account.\n    uint32 lockupStartIndex;\n    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.\n    LockedBalance.Lockups lockups;\n    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.\n    mapping(address =&gt; uint256) allowance;\n  }\n\n  /// @notice Stores per-account details.\n  mapping(address =&gt; AccountInfo) private accountToInfo;\n\n  // Lockup configuration\n  /// @notice The minimum lockup period in seconds.\n  uint256 private immutable lockupDuration;\n  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.\n  uint256 private immutable lockupInterval;\n\n  /// @notice The Foundation market contract with permissions to manage lockups.\n  address payable private immutable foundationMarket;\n\n  // ERC-20 metadata fields\n  /**\n   * @notice The number of decimals the token uses.\n   * @dev This method can be used to improve usability when displaying token amounts, but all interactions\n   * with this contract use whole amounts not considering decimals.\n   * @return 18\n   */\n  uint8 public constant decimals = 18;\n  /**\n   * @notice The name of the token.\n   * @return Foundation Wrapped Ether\n   */\n  string public constant name = ""Foundation Wrapped Ether"";\n  /**\n   * @notice The symbol of the token.\n   * @return FETH\n   */\n  string public constant symbol = ""FETH"";\n\n  // ERC-20 events\n  /**\n   * @notice Emitted when the allowance for a spender account is updated.\n   * @param from The account the spender is authorized to transact for.\n   * @param spender The account with permissions to manage FETH tokens for thefromaccount.\n   * @param amount The max amount of tokens which can be spent by thespenderaccount.\n   */\n  event Approval(address indexed from, address indexed spender, uint256 amount);\n  /**\n   * @notice Emitted when a transfer of FETH tokens is made from one account to another.\n   * @param from The account which is sending FETH tokens.\n   * @param to The account which is receiving FETH tokens.\n   * @param amount The number of FETH tokens which were sent.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  // Custom events\n  /**\n   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours\n   * and may include newly deposited ETH which is added to the account\'s total FETH balance.\n   * @param account The account which has access to the FETH after theexpiration.\n   * @param expiration The time at which thefromaccount will have access to the locked FETH.\n   * @param amount The number of FETH tokens which where locked up.\n   * @param valueDeposited The amount of ETH added to their account\'s total FETH balance,\n   * this may be lower thanamountif available FETH was leveraged.\n   */\n  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);\n  /**\n   * @notice Emitted when FETH tokens are unlocked by the Foundation market.\n   * @dev This event will not be emitted when lockups expire,\n   * it\'s only for tokens which are unlocked before their expiry.\n   * @param account The account which had locked FETH freed before expiration.\n   * @param expiration The time this balance was originally scheduled to be unlocked.\n   * @param amount The number of FETH tokens which were unlocked.\n   */\n  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);\n  /**\n   * @notice Emitted when ETH is withdrawn from a user\'s account.\n   * @dev This may be triggered by the user, an approved operator, or the Foundation market.\n   * @param from The account from which FETH was deducted in order to send the ETH.\n   * @param to The address the ETH was sent to.\n   * @param amount The number of tokens which were deducted from the user\'s FETH balance and transferred as ETH.\n   */\n  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);\n\n  /// @dev Allows the Foundation market permission to manage lockups for a user.\n  modifier onlyFoundationMarket() {\n    if (msg.sender != foundationMarket) {\n      revert FETH_Only_FND_Market_Allowed();\n    }\n    _;\n  }\n\n  /**\n   * @notice Initializes variables which may differ on testnet.\n   * @param _foundationMarket The address of the Foundation NFT marketplace.\n   * @param _lockupDuration The minimum length of time to lockup tokens for whenBalanceLocked, in seconds.\n   */\n  constructor(address payable _foundationMarket, uint256 _lockupDuration) {\n    if (!_foundationMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    foundationMarket = _foundationMarket;\n    lockupDuration = _lockupDuration;\n    lockupInterval = _lockupDuration / 24;\n    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {\n      revert FETH_Invalid_Lockup_Duration();\n    }\n  }\n\n  /**\n   * @notice Transferring ETH (viamsg.value) to the contract performs adepositinto the user\'s account.\n   */\n  receive() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Approves aspenderas an operator with permissions to transfer from your account.\n   * @param spender The address of the operator account that has approval to spend funds\n   * from themsg.sender\'s account.\n   * @param amount The max number of FETH tokens frommsg.sender\'s account that this spender is\n   * allowed to transact with.\n   * @return success Always true.\n   */\n  function approve(address spender, uint256 amount) external returns (bool success) {\n    accountToInfo[msg.sender].allowance[spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Deposit ETH (viamsg.value) and receive the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   */\n  function deposit() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Deposit ETH (viamsg.value) and credit theaccountprovided with the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   * @dev This may be used by the Foundation market to credit a user\'s account with FETH tokens.\n   * @param account The account to credit with FETH tokens.\n   */\n  function depositFor(address account) public payable {\n    if (msg.value == 0) {\n      revert FETH_Must_Deposit_Non_Zero_Amount();\n    }\n    AccountInfo storage accountInfo = accountToInfo[account];\n    // ETH value cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(msg.value);\n    }\n    emit Transfer(address(0), account, msg.value);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account\'s lockup and then create a new lockup, potentially for a different account.\n   * @dev Used by the market when an offer for an NFT is increased.\n   * This may be for a single account (increasing their offer)\n   * or two different accounts (outbidding someone elses offer).\n   * @param unlockFrom The account whose lockup is to be removed.\n   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param unlockAmount The number of tokens to be unlocked fromunlockFrom\'s account.\n   * This will revert if the tokens were previously unlocked.\n   * @param lockupFor The account to which the funds are to be deposited for (via themsg.value) and tokens locked up.\n   * @param lockupAmount The number of tokens to be locked up for thelockupFor\'s account.\n   *msg.valuemust be &lt;=lockupAmountand any delta will be taken from the account\'s available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketChangeLockup(\n    address unlockFrom,\n    uint256 unlockExpiration,\n    uint256 unlockAmount,\n    address lockupFor,\n    uint256 lockupAmount\n  ) external payable onlyFoundationMarket returns (uint256 expiration) {\n    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);\n    return _marketLockupFor(lockupFor, lockupAmount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Lockup an account\'s FETH tokens for 24-25 hours.\n   * @dev Used by the market when a new offer for an NFT is made.\n   * @param account The account to which the funds are to be deposited for (via themsg.value) and tokens locked up.\n   * @param amount The number of tokens to be locked up for thelockupFor\'s account.\n   *msg.valuemust be &lt;=amountand any delta will be taken from the account\'s available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketLockupFor(address account, uint256 amount)\n    external\n    payable\n    onlyFoundationMarket\n    returns (uint256 expiration)\n  {\n    return _marketLockupFor(account, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account\'s lockup, making the FETH tokens available for transfer or withdrawal.\n   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT\n   * receives its first bid or the buyer purchased the NFT another way, such as withbuy.\n   * @param account The account whose lockup is to be unlocked.\n   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked fromaccount.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _marketUnlockFor(account, expiration, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes tokens from the user\'s available balance and returns ETH to the caller.\n   * @dev Used by the market when a user\'s available FETH balance is used to make a purchase\n   * including accepting a buy price or a private sale, or placing a bid in an auction.\n   * @param from The account whose available balance is to be withdrawn from.\n   * @param amount The number of tokens to be deducted fromunlockFrom\'s available balance and transferred as ETH.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(from, msg.sender, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes a lockup from the user\'s account and then returns ETH to the caller.\n   * @dev Used by the market to extract unexpired funds as ETH to distribute for\n   * a sale when the user\'s offer is accepted.\n   * @param account The account whose lockup is to be removed.\n   * @param expiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked and withdrawn as ETH.\n   */\n  function marketWithdrawLocked(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _removeFromLockedBalance(account, expiration, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(account, msg.sender, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from your account.\n   * @param to The address of the account which the tokens are transferred from.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds).\n   */\n  function transfer(address to, uint256 amount) external returns (bool success) {\n    return transferFrom(msg.sender, to, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from the account specified if themsg.senderhas approval.\n   * @param from The address from which the available tokens are transferred from.\n   * @param to The address to which the tokens are to be transferred.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds or not approved).\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public returns (bool success) {\n    if (to == address(0)) {\n      revert FETH_Transfer_To_Burn_Not_Allowed();\n    } else if (to == address(this)) {\n      revert FETH_Transfer_To_FETH_Not_Allowed();\n    }\n    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(fromAccountInfo, amount);\n    }\n    _deductBalanceFrom(fromAccountInfo, amount);\n    AccountInfo storage toAccountInfo = accountToInfo[to];\n\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      toAccountInfo.freedBalance += uint96(amount);\n    }\n\n    emit Transfer(from, to, amount);\n\n    return true;\n  }\n\n  /**\n   * @notice Withdraw all tokens available in your account and receive ETH.\n   */\n  function withdrawAvailableBalance() external {\n    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);\n    uint256 amount = accountInfo.freedBalance;\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    delete accountInfo.freedBalance;\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(msg.sender, msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw the specified number of tokens from thefromaccounts available balance\n   * and send ETH to the destination address, if themsg.senderhas approval.\n   * @param from The address from which the available funds are to be withdrawn.\n   * @param to The destination address for the ETH to be transferred to.\n   * @param amount The number of tokens to be withdrawn and transferred as ETH.\n   */\n  function withdrawFrom(\n    address from,\n    address payable to,\n    uint256 amount\n  ) external {\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(accountInfo, amount);\n    }\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    to.sendValue(amount);\n\n    emit ETHWithdrawn(from, to, amount);\n  }\n\n  /**\n   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.\n   */\n  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    if (accountInfo.allowance[msg.sender] != type(uint256).max) {\n      if (accountInfo.allowance[msg.sender] &lt; amount) {\n        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);\n      }\n      // The check above ensures allowance cannot underflow.\n      unchecked {\n        accountInfo.allowance[msg.sender] -= amount;\n      }\n    }\n  }\n\n  /**\n   * @dev Removes an amount from the account\'s available FETH balance.\n   */\n  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    // Free from escrow in order to consider any expired escrow balance\n    if (accountInfo.freedBalance &lt; amount) {\n      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\n    }\n    // The check above ensures balance cannot underflow.\n    unchecked {\n      accountInfo.freedBalance -= uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Moves expired escrow to the available balance.\n   */\n  function _freeFromEscrow(address account) private returns (AccountInfo storage) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required\n    if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {\n      return accountInfo;\n    }\n\n    while (true) {\n      // Total ETH cannot realistically overflow 96 bits.\n      unchecked {\n        accountInfo.freedBalance += escrow.totalAmount;\n        accountInfo.lockups.del(escrowIndex);\n        // Escrow index cannot overflow 32 bits.\n        escrow = accountInfo.lockups.get(escrowIndex + 1);\n      }\n\n      // If the next bucket is empty, the start index is set to the previous bucket\n      if (escrow.expiration == 0) {\n        break;\n      }\n\n      // Escrow index cannot overflow 32 bits.\n      unchecked {\n        // Increment the escrow start index if the next bucket is not empty\n        ++escrowIndex;\n      }\n\n      // If the next bucket is expired, that\'s the new start index\n      if (escrow.expiration &gt;= block.timestamp) {\n        break;\n      }\n    }\n\n    // Escrow index cannot overflow 32 bits.\n    unchecked {\n      accountInfo.lockupStartIndex = uint32(escrowIndex);\n    }\n    return accountInfo;\n  }\n\n  /**\n   * @notice Lockup an account\'s FETH tokens for 24-25 hours.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {\n    if (account == address(0)) {\n      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\n    }\n    if (amount == 0) {\n      revert FETH_Must_Lockup_Non_Zero_Amount();\n    }\n\n    // Block timestamp in seconds is small enough to never overflow\n    unchecked {\n      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours\n      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;\n    }\n\n    // Update available escrow\n    // Always free from escrow to ensure the max bucket count is &lt;= 25\n    AccountInfo storage accountInfo = _freeFromEscrow(account);\n    if (msg.value &lt; amount) {\n      // The check above prevents underflow with delta.\n      unchecked {\n        uint256 delta = amount - msg.value;\n        if (accountInfo.freedBalance &lt; delta) {\n          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\n        }\n        // The check above prevents underflow of freed balance.\n        accountInfo.freedBalance -= uint96(delta);\n      }\n    } else if (msg.value != amount) {\n      // There\'s no reason to send msg.value more than the amount being locked up\n      revert FETH_Too_Much_ETH_Provided();\n    }\n\n    // Add to locked escrow\n    unchecked {\n      // The number of buckets is always &lt; 256 bits.\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          if (expiration &gt; type(uint32).max) {\n            revert FETH_Expiration_Too_Far_In_Future();\n          }\n          // Amount (ETH) will always be &lt; 96 bits.\n          accountInfo.lockups.set(escrowIndex, expiration, amount);\n          break;\n        }\n        if (escrow.expiration == expiration) {\n          // Total ETH will always be &lt; 96 bits.\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);\n          break;\n        }\n      }\n    }\n\n    emit BalanceLocked(account, expiration, amount, msg.value);\n  }\n\n  /**\n   * @notice Remove an account\'s lockup, making the FETH tokens available for transfer or withdrawal.\n   */\n  function _marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private {\n    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Removes the specified amount from locked escrow, potentially before its expiration.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _removeFromLockedBalance(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private returns (AccountInfo storage) {\n    if (expiration &lt; block.timestamp) {\n      revert FETH_Escrow_Expired();\n    }\n\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    if (escrow.expiration == expiration) {\n      // If removing from the first bucket, we may be able to delete it\n      if (escrow.totalAmount == amount) {\n        accountInfo.lockups.del(escrowIndex);\n\n        // Bump the escrow start index unless it\'s the last one\n        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {\n          // The number of escrow buckets will never overflow 32 bits.\n          unchecked {\n            ++accountInfo.lockupStartIndex;\n          }\n        }\n      } else {\n        if (escrow.totalAmount &lt; amount) {\n          revert FETH_Insufficient_Escrow(escrow.totalAmount);\n        }\n        // The require above ensures balance will not underflow.\n        unchecked {\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n        }\n      }\n    } else {\n      // Removing from the 2nd+ bucket\n      while (true) {\n        // The number of escrow buckets will never overflow 32 bits.\n        unchecked {\n          ++escrowIndex;\n        }\n        escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == expiration) {\n          if (amount &gt; escrow.totalAmount) {\n            revert FETH_Insufficient_Escrow(escrow.totalAmount);\n          }\n          // The require above ensures balance will not underflow.\n          unchecked {\n            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n          }\n          // We may have an entry with 0 totalAmount but expiration will be set\n          break;\n        }\n        if (escrow.expiration == 0) {\n          revert FETH_Escrow_Not_Found();\n        }\n      }\n    }\n\n    emit BalanceUnlocked(account, expiration, amount);\n    return accountInfo;\n  }\n\n  /**\n   * @notice Returns the amount which a spender is still allowed to transact from theaccount\'s balance.\n   * @param account The owner of the funds.\n   * @param operator The address with approval to spend from theaccount\'s balance.\n   * @return amount The number of tokens theoperatoris still allowed to transact with.\n   */\n  function allowance(address account, address operator) external view returns (uint256 amount) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    return accountInfo.allowance[operator];\n  }\n\n  /**\n   * @notice Returns the balance of an account which is available to transfer or withdraw.\n   * @dev This will automatically increase as soon as locked tokens reach their expiry date.\n   * @param account The account to query the available balance of.\n   * @return balance The available balance of the account.\n   */\n  function balanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits.\n    unchecked {\n      // Add expired lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Gets the Foundation market address which has permissions to manage lockups.\n   * @return market The Foundation market contract address.\n   */\n  function getFoundationMarket() external view returns (address market) {\n    return foundationMarket;\n  }\n\n  /**\n   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.\n   * @devexpires.length==amounts.length\n   * andamounts[i]is the number of tokens which will expire atexpires[i].\n   * The results returned are sorted by expiry, with the earliest expiry date first.\n   * @param account The account to query the locked balance of.\n   * @return expiries The time at which each outstanding lockup bucket expires.\n   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.\n   */\n  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n\n    // Count lockups\n    uint256 lockedCount;\n    // The number of buckets is always &lt; 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {\n          // Lockup count will never overflow 256 bits.\n          ++lockedCount;\n        }\n      }\n    }\n\n    // Allocate arrays\n    expiries = new uint256[](lockedCount);\n    amounts = new uint256[](lockedCount);\n\n    // Populate results\n    uint256 i;\n    // The number of buckets is always &lt; 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {\n          expiries[i] = escrow.expiration;\n          amounts[i] = escrow.totalAmount;\n          ++i;\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total balance of an account, including locked FETH tokens.\n   * @dev UsebalanceOfto get the number of tokens available for transfer or withdrawal.\n   * @param account The account to query the total balance of.\n   * @return balance The total FETH balance tracked for this account.\n   */\n  function totalBalanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits.\n    unchecked {\n      // Add all lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total amount of ETH locked in this contract.\n   * @return supply The total amount of ETH locked in this contract.\n   */\n  function totalSupply() external view returns (uint256 supply) {\n    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct\n       but this is on-par with the WETH implementation and done for gas savings. */\n    return address(this).balance;\n  }\n}\n', 'ideas': "" Gas Limit Identified.\n\n**Lack of Gas Limit Considerations**\n'''\nThe function_freeFromEscrowcontains a while loop that iterates through the escrow buckets until it finds an expired bucket or an empty bucket. If there are many buckets (up to 25 as per the contract's design), and if the first bucket is not expired, the loop could potentially iterate many times, leading to out-of-gas errors if the gas limit is exceeded. This could result in failed transactions for users trying to free their funds from escrow.\n\nTo mitigate this, consider implementing a maximum iteration limit within the loop to prevent excessive gas consumption. For example, you could introduce a counter that breaks the loop after a certain number of iterations, ensuring that the function does not run indefinitely.\n\nAdditionally, consider using a more gas-efficient data structure or approach to manage the escrow buckets, such as maintaining a pointer to the first expired bucket instead of iterating through all buckets.\n'''\n\n**Potential Denial-of-Service (DoS) Vulnerability**\n'''\nThe same function_freeFromEscrow` could be exploited by a malicious actor who fills up the escrow buckets without allowing them to expire. This could lead to a situation where legitimate users cannot free their funds, effectively causing a denial-of-service for those users. \n\nTo mitigate this risk, implement a mechanism to limit the number of active escrow buckets or enforce a time-based expiration policy that automatically clears expired buckets. This could be done by periodically checking and removing expired buckets during transactions or by implementing a function that can be called to clean up expired buckets.\n'''""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-11-08 20:26:28 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol""; import ""@openzeppelin/contracts/utils/math/Math.sol""; import ""./libraries/LockedBalance.sol""; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = ""Foundation Wrapped Ether"";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = ""FETH""; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-11-08 20:26:28 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts/utils/math/Math.sol"";

import ""./libraries/LockedBalance.sol"";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = ""Foundation Wrapped Ether"";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = ""FETH"";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""/*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts/utils/math/Math.sol"";

import ""./libraries/LockedBalance.sol"";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = ""Foundation Wrapped Ether"";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = ""FETH"";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
"".
Ideas: "" Gas Limit Identified.

**Lack of Gas Limit Considerations**
'''
The function `_freeFromEscrow` contains a while loop that iterates through the escrow buckets until it finds an expired bucket or an empty bucket. If there are many buckets (up to 25 as per the contract's design), and if the first bucket is not expired, the loop could potentially iterate many times, leading to out-of-gas errors if the gas limit is exceeded. This could result in failed transactions for users trying to free their funds from escrow.

To mitigate this, consider implementing a maximum iteration limit within the loop to prevent excessive gas consumption. For example, you could introduce a counter that breaks the loop after a certain number of iterations, ensuring that the function does not run indefinitely.

Additionally, consider using a more gas-efficient data structure or approach to manage the escrow buckets, such as maintaining a pointer to the first expired bucket instead of iterating through all buckets.
'''

**Potential Denial-of-Service (DoS) Vulnerability**
'''
The same function `_freeFromEscrow` could be exploited by a malicious actor who fills up the escrow buckets without allowing them to expire. This could lead to a situation where legitimate users cannot free their funds, effectively causing a denial-of-service for those users. 

To mitigate this risk, implement a mechanism to limit the number of active escrow buckets or enforce a time-based expiration policy that automatically clears expired buckets. This could be done by periodically checking and removing expired buckets during transactions or by implementing a function that can be called to clean up expired buckets.
'''"".
As the Security Analyst, your primary objective is to conduct a comprehensive inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Price Manipulation. There are two cases where the contract may have Price Manipulation vulnerabilities:
1. When the contract allows arbitrary adjustment of token prices by a centralized authority without any checks or balances, potentially leading to unfair trades.
2. When the contract does not utilize decentralized or transparent mechanisms for determining token prices, allowing for potential exploitation by the controlling entity.
If you identify all Price Manipulation vulnerabilities, respond with: """,,"<INFO> Assumption of Fixed-Length Array Identified.

VULNERABILITY NAME: Assumption of Fixed-Length Array in `getLockups`
'''
The `getLockups` function assumes that the number of lockup buckets for an account will not exceed a certain limit (256 bits) and allocates arrays `expiries` and `amounts` based on the count of lockups found. However, if the number of lockups exceeds the expected count, this could lead to incorrect data being processed or even out-of-bounds errors when accessing the arrays. The function does not have a safeguard to ensure that the number of lockups does not exceed the allocated array size.

Recommended Mitigation:
1. Implement a check to ensure that the number of lockups does not exceed the maximum size of the arrays before allocating them.
2. Consider using a dynamic array (e.g., `memory` array) to handle varying lengths, or use a more robust data structure that can accommodate the number of lockups without risking overflow or out-of-bounds access.
'''

VULNERABILITY NAME: Assumption of Fixed-Length Array in `totalBalanceOf`
'''
The `totalBalanceOf` function also assumes that the number of lockup buckets will not exceed a certain limit when summing the total balance. Similar to `getLockups`, if the number of lockups exceeds the expected count, it could lead to incorrect calculations or out-of-bounds errors.

Recommended Mitigation:
1. Implement a check to ensure that the number of lockups does not exceed the maximum size of the expected buckets.
2. Use a dynamic array or a loop that can handle varying lengths without risking overflow or incorrect data processing.
'''

[2024-11-08 20:26:38 INFO] **[Execute Detail]**

execute SimplePhase:[WithdrawalFunctionDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-11-08 20:26:38 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol""; import ""@openzeppelin/contracts/utils/math/Math.sol""; import ""./libraries/LockedBalance.sol""; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = ""Foundation Wrapped Ether"";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = ""FETH""; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to the Lack of Withdrawal Function. Your analysis should determine if the contract provides a secure method for users to withdraw their funds. Proceed with the following steps in your analysis: 1. Scrutinize the contract's code to determine if there is a function that allows users to withdraw their deposited funds. 2. Scan the contract for any functions related to withdrawing Ether or other assets. Document each instance and investigate the logic to ensure it is implemented securely. 3. Evaluate whether the withdrawal function, if present, follows best practices to prevent common vulnerabilities such as reentrancy attacks. Ensure it uses the Checks-Effects-Interactions pattern. 4. If no withdrawal function is found, assess the impact on users who have deposited funds into the contract. Highlight the importance of having a secure withdrawal mechanism. If you discover a lack of a withdrawal function, respond with: "" Lack of Withdrawal Function Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If a secure withdrawal function is found and no issues are identified, respond only with: "" Withdrawal Function Present and Secure."" |
| **phase_name** | WithdrawalFunctionDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '/\n  ･\n   \u3000★\n      ･ ｡\n        \u3000･\u3000ﾟ☆ ｡\n  \u3000\u3000\u3000 \u3000★ ﾟ･｡ *  ｡\n          \u3000\u3000 ☆ ｡･ﾟ.｡\n      \u3000\u3000\u3000ﾟ .｡☆｡★\u3000･\n\u200b\n                      .-:::::-.              -::---...```\n-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy\n-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo\n                                              ````\n   *\u3000\n      ･ ｡\n\u3000\u3000\u3000\u3000･\u3000\u3000ﾟ☆ ｡\n  \u3000\u3000\u3000 *\u3000★ ﾟ･｡ *  ｡\n          \u3000\u3000* ☆ ｡･ﾟ*.｡\n      \u3000\u3000\u3000ﾟ *.｡☆｡★\u3000･\n    *\u3000\u3000ﾟ｡·*･｡ ﾟ*\n  \u3000\u3000\u3000☆ﾟ･｡°*. ﾟ\n\u3000 ･ ﾟ*｡･ﾟ★｡\n\u3000\u3000･ *ﾟ｡\u3000\u3000 *\n\u3000･ﾟ*｡★･\n ☆∴｡\u3000*\n･ ｡\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";\nimport ""@openzeppelin/contracts/utils/math/Math.sol"";\n\nimport ""./libraries/LockedBalance.sol"";\n\nerror FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\nerror FETH_Escrow_Expired();\nerror FETH_Escrow_Not_Found();\nerror FETH_Expiration_Too_Far_In_Future();\n/// @param amount The current allowed amount the spender is authorized to transact for this account.\nerror FETH_Insufficient_Allowance(uint256 amount);\n/// @param amount The current available (unlocked) token count of this account.\nerror FETH_Insufficient_Available_Funds(uint256 amount);\n/// @param amount The current number of tokens this account has for the given lockup expiry bucket.\nerror FETH_Insufficient_Escrow(uint256 amount);\nerror FETH_Invalid_Lockup_Duration();\nerror FETH_Market_Must_Be_A_Contract();\nerror FETH_Must_Deposit_Non_Zero_Amount();\nerror FETH_Must_Lockup_Non_Zero_Amount();\nerror FETH_No_Funds_To_Withdraw();\nerror FETH_Only_FND_Market_Allowed();\nerror FETH_Too_Much_ETH_Provided();\nerror FETH_Transfer_To_Burn_Not_Allowed();\nerror FETH_Transfer_To_FETH_Not_Allowed();\n\n/**\n * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.\n * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after\n * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).\n * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be\n * transferred or withdrawn, except by our market contract which requested the lockup in the first place.\n * @dev Locked balances are rounded up to the next hour.\n * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".\n * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.\n */\ncontract FETH {\n  using AddressUpgradeable for address payable;\n  using LockedBalance for LockedBalance.Lockups;\n  using Math for uint256;\n\n  /// @notice Tracks an account\'s info.\n  struct AccountInfo {\n    /// @notice The number of tokens which have been unlocked already.\n    uint96 freedBalance;\n    /// @notice The first applicable lockup bucket for this account.\n    uint32 lockupStartIndex;\n    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.\n    LockedBalance.Lockups lockups;\n    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.\n    mapping(address =&gt; uint256) allowance;\n  }\n\n  /// @notice Stores per-account details.\n  mapping(address =&gt; AccountInfo) private accountToInfo;\n\n  // Lockup configuration\n  /// @notice The minimum lockup period in seconds.\n  uint256 private immutable lockupDuration;\n  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.\n  uint256 private immutable lockupInterval;\n\n  /// @notice The Foundation market contract with permissions to manage lockups.\n  address payable private immutable foundationMarket;\n\n  // ERC-20 metadata fields\n  /**\n   * @notice The number of decimals the token uses.\n   * @dev This method can be used to improve usability when displaying token amounts, but all interactions\n   * with this contract use whole amounts not considering decimals.\n   * @return 18\n   */\n  uint8 public constant decimals = 18;\n  /**\n   * @notice The name of the token.\n   * @return Foundation Wrapped Ether\n   */\n  string public constant name = ""Foundation Wrapped Ether"";\n  /**\n   * @notice The symbol of the token.\n   * @return FETH\n   */\n  string public constant symbol = ""FETH"";\n\n  // ERC-20 events\n  /**\n   * @notice Emitted when the allowance for a spender account is updated.\n   * @param from The account the spender is authorized to transact for.\n   * @param spender The account with permissions to manage FETH tokens for thefromaccount.\n   * @param amount The max amount of tokens which can be spent by thespenderaccount.\n   */\n  event Approval(address indexed from, address indexed spender, uint256 amount);\n  /**\n   * @notice Emitted when a transfer of FETH tokens is made from one account to another.\n   * @param from The account which is sending FETH tokens.\n   * @param to The account which is receiving FETH tokens.\n   * @param amount The number of FETH tokens which were sent.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  // Custom events\n  /**\n   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours\n   * and may include newly deposited ETH which is added to the account\'s total FETH balance.\n   * @param account The account which has access to the FETH after theexpiration.\n   * @param expiration The time at which thefromaccount will have access to the locked FETH.\n   * @param amount The number of FETH tokens which where locked up.\n   * @param valueDeposited The amount of ETH added to their account\'s total FETH balance,\n   * this may be lower thanamountif available FETH was leveraged.\n   */\n  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);\n  /**\n   * @notice Emitted when FETH tokens are unlocked by the Foundation market.\n   * @dev This event will not be emitted when lockups expire,\n   * it\'s only for tokens which are unlocked before their expiry.\n   * @param account The account which had locked FETH freed before expiration.\n   * @param expiration The time this balance was originally scheduled to be unlocked.\n   * @param amount The number of FETH tokens which were unlocked.\n   */\n  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);\n  /**\n   * @notice Emitted when ETH is withdrawn from a user\'s account.\n   * @dev This may be triggered by the user, an approved operator, or the Foundation market.\n   * @param from The account from which FETH was deducted in order to send the ETH.\n   * @param to The address the ETH was sent to.\n   * @param amount The number of tokens which were deducted from the user\'s FETH balance and transferred as ETH.\n   */\n  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);\n\n  /// @dev Allows the Foundation market permission to manage lockups for a user.\n  modifier onlyFoundationMarket() {\n    if (msg.sender != foundationMarket) {\n      revert FETH_Only_FND_Market_Allowed();\n    }\n    _;\n  }\n\n  /**\n   * @notice Initializes variables which may differ on testnet.\n   * @param _foundationMarket The address of the Foundation NFT marketplace.\n   * @param _lockupDuration The minimum length of time to lockup tokens for whenBalanceLocked, in seconds.\n   */\n  constructor(address payable _foundationMarket, uint256 _lockupDuration) {\n    if (!_foundationMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    foundationMarket = _foundationMarket;\n    lockupDuration = _lockupDuration;\n    lockupInterval = _lockupDuration / 24;\n    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {\n      revert FETH_Invalid_Lockup_Duration();\n    }\n  }\n\n  /**\n   * @notice Transferring ETH (viamsg.value) to the contract performs adepositinto the user\'s account.\n   */\n  receive() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Approves aspenderas an operator with permissions to transfer from your account.\n   * @param spender The address of the operator account that has approval to spend funds\n   * from themsg.sender\'s account.\n   * @param amount The max number of FETH tokens frommsg.sender\'s account that this spender is\n   * allowed to transact with.\n   * @return success Always true.\n   */\n  function approve(address spender, uint256 amount) external returns (bool success) {\n    accountToInfo[msg.sender].allowance[spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Deposit ETH (viamsg.value) and receive the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   */\n  function deposit() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Deposit ETH (viamsg.value) and credit theaccountprovided with the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   * @dev This may be used by the Foundation market to credit a user\'s account with FETH tokens.\n   * @param account The account to credit with FETH tokens.\n   */\n  function depositFor(address account) public payable {\n    if (msg.value == 0) {\n      revert FETH_Must_Deposit_Non_Zero_Amount();\n    }\n    AccountInfo storage accountInfo = accountToInfo[account];\n    // ETH value cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(msg.value);\n    }\n    emit Transfer(address(0), account, msg.value);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account\'s lockup and then create a new lockup, potentially for a different account.\n   * @dev Used by the market when an offer for an NFT is increased.\n   * This may be for a single account (increasing their offer)\n   * or two different accounts (outbidding someone elses offer).\n   * @param unlockFrom The account whose lockup is to be removed.\n   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param unlockAmount The number of tokens to be unlocked fromunlockFrom\'s account.\n   * This will revert if the tokens were previously unlocked.\n   * @param lockupFor The account to which the funds are to be deposited for (via themsg.value) and tokens locked up.\n   * @param lockupAmount The number of tokens to be locked up for thelockupFor\'s account.\n   *msg.valuemust be &lt;=lockupAmountand any delta will be taken from the account\'s available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketChangeLockup(\n    address unlockFrom,\n    uint256 unlockExpiration,\n    uint256 unlockAmount,\n    address lockupFor,\n    uint256 lockupAmount\n  ) external payable onlyFoundationMarket returns (uint256 expiration) {\n    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);\n    return _marketLockupFor(lockupFor, lockupAmount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Lockup an account\'s FETH tokens for 24-25 hours.\n   * @dev Used by the market when a new offer for an NFT is made.\n   * @param account The account to which the funds are to be deposited for (via themsg.value) and tokens locked up.\n   * @param amount The number of tokens to be locked up for thelockupFor\'s account.\n   *msg.valuemust be &lt;=amountand any delta will be taken from the account\'s available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketLockupFor(address account, uint256 amount)\n    external\n    payable\n    onlyFoundationMarket\n    returns (uint256 expiration)\n  {\n    return _marketLockupFor(account, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account\'s lockup, making the FETH tokens available for transfer or withdrawal.\n   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT\n   * receives its first bid or the buyer purchased the NFT another way, such as withbuy.\n   * @param account The account whose lockup is to be unlocked.\n   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked fromaccount.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _marketUnlockFor(account, expiration, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes tokens from the user\'s available balance and returns ETH to the caller.\n   * @dev Used by the market when a user\'s available FETH balance is used to make a purchase\n   * including accepting a buy price or a private sale, or placing a bid in an auction.\n   * @param from The account whose available balance is to be withdrawn from.\n   * @param amount The number of tokens to be deducted fromunlockFrom\'s available balance and transferred as ETH.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(from, msg.sender, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes a lockup from the user\'s account and then returns ETH to the caller.\n   * @dev Used by the market to extract unexpired funds as ETH to distribute for\n   * a sale when the user\'s offer is accepted.\n   * @param account The account whose lockup is to be removed.\n   * @param expiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked and withdrawn as ETH.\n   */\n  function marketWithdrawLocked(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _removeFromLockedBalance(account, expiration, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(account, msg.sender, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from your account.\n   * @param to The address of the account which the tokens are transferred from.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds).\n   */\n  function transfer(address to, uint256 amount) external returns (bool success) {\n    return transferFrom(msg.sender, to, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from the account specified if themsg.senderhas approval.\n   * @param from The address from which the available tokens are transferred from.\n   * @param to The address to which the tokens are to be transferred.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds or not approved).\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public returns (bool success) {\n    if (to == address(0)) {\n      revert FETH_Transfer_To_Burn_Not_Allowed();\n    } else if (to == address(this)) {\n      revert FETH_Transfer_To_FETH_Not_Allowed();\n    }\n    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(fromAccountInfo, amount);\n    }\n    _deductBalanceFrom(fromAccountInfo, amount);\n    AccountInfo storage toAccountInfo = accountToInfo[to];\n\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      toAccountInfo.freedBalance += uint96(amount);\n    }\n\n    emit Transfer(from, to, amount);\n\n    return true;\n  }\n\n  /**\n   * @notice Withdraw all tokens available in your account and receive ETH.\n   */\n  function withdrawAvailableBalance() external {\n    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);\n    uint256 amount = accountInfo.freedBalance;\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    delete accountInfo.freedBalance;\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(msg.sender, msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw the specified number of tokens from thefromaccounts available balance\n   * and send ETH to the destination address, if themsg.senderhas approval.\n   * @param from The address from which the available funds are to be withdrawn.\n   * @param to The destination address for the ETH to be transferred to.\n   * @param amount The number of tokens to be withdrawn and transferred as ETH.\n   */\n  function withdrawFrom(\n    address from,\n    address payable to,\n    uint256 amount\n  ) external {\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(accountInfo, amount);\n    }\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    to.sendValue(amount);\n\n    emit ETHWithdrawn(from, to, amount);\n  }\n\n  /**\n   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.\n   */\n  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    if (accountInfo.allowance[msg.sender] != type(uint256).max) {\n      if (accountInfo.allowance[msg.sender] &lt; amount) {\n        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);\n      }\n      // The check above ensures allowance cannot underflow.\n      unchecked {\n        accountInfo.allowance[msg.sender] -= amount;\n      }\n    }\n  }\n\n  /**\n   * @dev Removes an amount from the account\'s available FETH balance.\n   */\n  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    // Free from escrow in order to consider any expired escrow balance\n    if (accountInfo.freedBalance &lt; amount) {\n      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\n    }\n    // The check above ensures balance cannot underflow.\n    unchecked {\n      accountInfo.freedBalance -= uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Moves expired escrow to the available balance.\n   */\n  function _freeFromEscrow(address account) private returns (AccountInfo storage) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required\n    if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {\n      return accountInfo;\n    }\n\n    while (true) {\n      // Total ETH cannot realistically overflow 96 bits.\n      unchecked {\n        accountInfo.freedBalance += escrow.totalAmount;\n        accountInfo.lockups.del(escrowIndex);\n        // Escrow index cannot overflow 32 bits.\n        escrow = accountInfo.lockups.get(escrowIndex + 1);\n      }\n\n      // If the next bucket is empty, the start index is set to the previous bucket\n      if (escrow.expiration == 0) {\n        break;\n      }\n\n      // Escrow index cannot overflow 32 bits.\n      unchecked {\n        // Increment the escrow start index if the next bucket is not empty\n        ++escrowIndex;\n      }\n\n      // If the next bucket is expired, that\'s the new start index\n      if (escrow.expiration &gt;= block.timestamp) {\n        break;\n      }\n    }\n\n    // Escrow index cannot overflow 32 bits.\n    unchecked {\n      accountInfo.lockupStartIndex = uint32(escrowIndex);\n    }\n    return accountInfo;\n  }\n\n  /**\n   * @notice Lockup an account\'s FETH tokens for 24-25 hours.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {\n    if (account == address(0)) {\n      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\n    }\n    if (amount == 0) {\n      revert FETH_Must_Lockup_Non_Zero_Amount();\n    }\n\n    // Block timestamp in seconds is small enough to never overflow\n    unchecked {\n      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours\n      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;\n    }\n\n    // Update available escrow\n    // Always free from escrow to ensure the max bucket count is &lt;= 25\n    AccountInfo storage accountInfo = _freeFromEscrow(account);\n    if (msg.value &lt; amount) {\n      // The check above prevents underflow with delta.\n      unchecked {\n        uint256 delta = amount - msg.value;\n        if (accountInfo.freedBalance &lt; delta) {\n          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\n        }\n        // The check above prevents underflow of freed balance.\n        accountInfo.freedBalance -= uint96(delta);\n      }\n    } else if (msg.value != amount) {\n      // There\'s no reason to send msg.value more than the amount being locked up\n      revert FETH_Too_Much_ETH_Provided();\n    }\n\n    // Add to locked escrow\n    unchecked {\n      // The number of buckets is always &lt; 256 bits.\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          if (expiration &gt; type(uint32).max) {\n            revert FETH_Expiration_Too_Far_In_Future();\n          }\n          // Amount (ETH) will always be &lt; 96 bits.\n          accountInfo.lockups.set(escrowIndex, expiration, amount);\n          break;\n        }\n        if (escrow.expiration == expiration) {\n          // Total ETH will always be &lt; 96 bits.\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);\n          break;\n        }\n      }\n    }\n\n    emit BalanceLocked(account, expiration, amount, msg.value);\n  }\n\n  /**\n   * @notice Remove an account\'s lockup, making the FETH tokens available for transfer or withdrawal.\n   */\n  function _marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private {\n    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Removes the specified amount from locked escrow, potentially before its expiration.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _removeFromLockedBalance(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private returns (AccountInfo storage) {\n    if (expiration &lt; block.timestamp) {\n      revert FETH_Escrow_Expired();\n    }\n\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    if (escrow.expiration == expiration) {\n      // If removing from the first bucket, we may be able to delete it\n      if (escrow.totalAmount == amount) {\n        accountInfo.lockups.del(escrowIndex);\n\n        // Bump the escrow start index unless it\'s the last one\n        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {\n          // The number of escrow buckets will never overflow 32 bits.\n          unchecked {\n            ++accountInfo.lockupStartIndex;\n          }\n        }\n      } else {\n        if (escrow.totalAmount &lt; amount) {\n          revert FETH_Insufficient_Escrow(escrow.totalAmount);\n        }\n        // The require above ensures balance will not underflow.\n        unchecked {\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n        }\n      }\n    } else {\n      // Removing from the 2nd+ bucket\n      while (true) {\n        // The number of escrow buckets will never overflow 32 bits.\n        unchecked {\n          ++escrowIndex;\n        }\n        escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == expiration) {\n          if (amount &gt; escrow.totalAmount) {\n            revert FETH_Insufficient_Escrow(escrow.totalAmount);\n          }\n          // The require above ensures balance will not underflow.\n          unchecked {\n            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n          }\n          // We may have an entry with 0 totalAmount but expiration will be set\n          break;\n        }\n        if (escrow.expiration == 0) {\n          revert FETH_Escrow_Not_Found();\n        }\n      }\n    }\n\n    emit BalanceUnlocked(account, expiration, amount);\n    return accountInfo;\n  }\n\n  /**\n   * @notice Returns the amount which a spender is still allowed to transact from theaccount\'s balance.\n   * @param account The owner of the funds.\n   * @param operator The address with approval to spend from theaccount\'s balance.\n   * @return amount The number of tokens theoperatoris still allowed to transact with.\n   */\n  function allowance(address account, address operator) external view returns (uint256 amount) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    return accountInfo.allowance[operator];\n  }\n\n  /**\n   * @notice Returns the balance of an account which is available to transfer or withdraw.\n   * @dev This will automatically increase as soon as locked tokens reach their expiry date.\n   * @param account The account to query the available balance of.\n   * @return balance The available balance of the account.\n   */\n  function balanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits.\n    unchecked {\n      // Add expired lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Gets the Foundation market address which has permissions to manage lockups.\n   * @return market The Foundation market contract address.\n   */\n  function getFoundationMarket() external view returns (address market) {\n    return foundationMarket;\n  }\n\n  /**\n   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.\n   * @devexpires.length==amounts.length\n   * andamounts[i]is the number of tokens which will expire atexpires[i].\n   * The results returned are sorted by expiry, with the earliest expiry date first.\n   * @param account The account to query the locked balance of.\n   * @return expiries The time at which each outstanding lockup bucket expires.\n   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.\n   */\n  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n\n    // Count lockups\n    uint256 lockedCount;\n    // The number of buckets is always &lt; 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {\n          // Lockup count will never overflow 256 bits.\n          ++lockedCount;\n        }\n      }\n    }\n\n    // Allocate arrays\n    expiries = new uint256[](lockedCount);\n    amounts = new uint256[](lockedCount);\n\n    // Populate results\n    uint256 i;\n    // The number of buckets is always &lt; 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {\n          expiries[i] = escrow.expiration;\n          amounts[i] = escrow.totalAmount;\n          ++i;\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total balance of an account, including locked FETH tokens.\n   * @dev UsebalanceOfto get the number of tokens available for transfer or withdrawal.\n   * @param account The account to query the total balance of.\n   * @return balance The total FETH balance tracked for this account.\n   */\n  function totalBalanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits.\n    unchecked {\n      // Add all lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total amount of ETH locked in this contract.\n   * @return supply The total amount of ETH locked in this contract.\n   */\n  function totalSupply() external view returns (uint256 supply) {\n    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct\n       but this is on-par with the WETH implementation and done for gas savings. */\n    return address(this).balance;\n  }\n}\n', 'ideas': "" Assumption of Fixed-Length Array Identified.\n\nVULNERABILITY NAME: Assumption of Fixed-Length Array ingetLockups\n'''\nThegetLockupsfunction assumes that the number of lockup buckets for an account will not exceed a certain limit (256 bits) and allocates arraysexpiriesandamountsbased on the count of lockups found. However, if the number of lockups exceeds the expected count, this could lead to incorrect data being processed or even out-of-bounds errors when accessing the arrays. The function does not have a safeguard to ensure that the number of lockups does not exceed the allocated array size.\n\nRecommended Mitigation:\n1. Implement a check to ensure that the number of lockups does not exceed the maximum size of the arrays before allocating them.\n2. Consider using a dynamic array (e.g.,memoryarray) to handle varying lengths, or use a more robust data structure that can accommodate the number of lockups without risking overflow or out-of-bounds access.\n'''\n\nVULNERABILITY NAME: Assumption of Fixed-Length Array intotalBalanceOf\n'''\nThetotalBalanceOffunction also assumes that the number of lockup buckets will not exceed a certain limit when summing the total balance. Similar togetLockups`, if the number of lockups exceeds the expected count, it could lead to incorrect calculations or out-of-bounds errors.\n\nRecommended Mitigation:\n1. Implement a check to ensure that the number of lockups does not exceed the maximum size of the expected buckets.\n2. Use a dynamic array or a loop that can handle varying lengths without risking overflow or incorrect data processing.\n'''""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-11-08 20:26:38 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol""; import ""@openzeppelin/contracts/utils/math/Math.sol""; import ""./libraries/LockedBalance.sol""; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = ""Foundation Wrapped Ether"";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = ""FETH""; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-11-08 20:26:38 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts/utils/math/Math.sol"";

import ""./libraries/LockedBalance.sol"";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = ""Foundation Wrapped Ether"";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = ""FETH"";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""/*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts/utils/math/Math.sol"";

import ""./libraries/LockedBalance.sol"";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = ""Foundation Wrapped Ether"";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = ""FETH"";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
"".
Ideas: "" Assumption of Fixed-Length Array Identified.

VULNERABILITY NAME: Assumption of Fixed-Length Array in `getLockups`
'''
The `getLockups` function assumes that the number of lockup buckets for an account will not exceed a certain limit (256 bits) and allocates arrays `expiries` and `amounts` based on the count of lockups found. However, if the number of lockups exceeds the expected count, this could lead to incorrect data being processed or even out-of-bounds errors when accessing the arrays. The function does not have a safeguard to ensure that the number of lockups does not exceed the allocated array size.

Recommended Mitigation:
1. Implement a check to ensure that the number of lockups does not exceed the maximum size of the arrays before allocating them.
2. Consider using a dynamic array (e.g., `memory` array) to handle varying lengths, or use a more robust data structure that can accommodate the number of lockups without risking overflow or out-of-bounds access.
'''

VULNERABILITY NAME: Assumption of Fixed-Length Array in `totalBalanceOf`
'''
The `totalBalanceOf` function also assumes that the number of lockup buckets will not exceed a certain limit when summing the total balance. Similar to `getLockups`, if the number of lockups exceeds the expected count, it could lead to incorrect calculations or out-of-bounds errors.

Recommended Mitigation:
1. Implement a check to ensure that the number of lockups does not exceed the maximum size of the expected buckets.
2. Use a dynamic array or a loop that can handle varying lengths without risking overflow or incorrect data processing.
'''"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to the Lack of Withdrawal Function. Your analysis should determine if the contract provides a secure method for users to withdraw their funds.
Proceed with the following steps in your analysis:
1. Scrutinize the contract's code to determine if there is a function that allows users to withdraw their deposited funds.
2. Scan the contract for any functions related to withdrawing Ether or other assets. Document each instance and investigate the logic to ensure it is implemented securely.
3. Evaluate whether the withdrawal function, if present, follows best practices to prevent common vulnerabilities such as reentrancy attacks. Ensure it uses the Checks-Effects-Interactions pattern.
4. If no withdrawal function is found, assess the impact on users who have deposited funds into the contract. Highlight the importance of having a secure withdrawal mechanism.
If you discover a lack of a withdrawal function, respond with: """,,,"<INFO> Potential Data Inconsistency Identified.
```
POTENTIAL DATA INCONSISTENCY
'''
The contract contains several areas where data is manipulated, particularly in the handling of locked balances and account information. One notable area is in the `_freeFromEscrow` function, where the `accountInfo.lockups.del(escrowIndex)` operation is performed to delete a lockup entry. If the deletion of the lockup does not correctly update the `lockupStartIndex`, it may lead to inconsistencies in the data being accessed in subsequent calls. This could result in the contract referencing outdated or incorrect lockup data.

Additionally, in the `_marketLockupFor` function, the logic for adding to locked escrow relies on the assumption that the `escrowIndex` will always point to a valid entry. If the index is not managed correctly, it could lead to accessing uninitialized or incorrect data.

To mitigate this, it is recommended to implement checks after modifying the `lockupStartIndex` to ensure that it points to a valid entry. Also, consider adding assertions or require statements to validate the state of the data before performing operations that depend on it.
'''
```

[2024-11-08 20:26:53 INFO] **[Execute Detail]**

execute SimplePhase:[HashCollisionDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-11-08 20:26:53 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol""; import ""@openzeppelin/contracts/utils/math/Math.sol""; import ""./libraries/LockedBalance.sol""; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = ""Foundation Wrapped Ether"";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = ""FETH""; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Hash Collision. This type of vulnerability occurs when different inputs produce the same hash due to improper handling of concatenated values, leading to potential security issues. Proceed with the following steps in your analysis: 1. Scrutinize the contract's code to identify any functions that generate hashes from input values. 2. Look for patterns where multiple input values are concatenated without clear delimiters before hashing. Pay special attention to the use of abi.encodePacked for concatenation. 3. Determine if the concatenated inputs can produce the same hash for different combinations of input values, leading to potential hash collisions. 4. Evaluate the logic for generating and handling hashes within the contract to ensure that the potential for hash collisions is minimized. If you discover any Hash Collision vulnerabilities, respond with: "" Hash Collision Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If NO Hash Collision vulnerabilities are found, respond only with: "" NO Hash Collision."" |
| **phase_name** | HashCollisionDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '/\n  ･\n   \u3000★\n      ･ ｡\n        \u3000･\u3000ﾟ☆ ｡\n  \u3000\u3000\u3000 \u3000★ ﾟ･｡ *  ｡\n          \u3000\u3000 ☆ ｡･ﾟ.｡\n      \u3000\u3000\u3000ﾟ .｡☆｡★\u3000･\n\u200b\n                      .-:::::-.              -::---...```\n-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy\n-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo\n                                              ``\n   *\u3000\n      ･ ｡\n\u3000\u3000\u3000\u3000･\u3000\u3000ﾟ☆ ｡\n  \u3000\u3000\u3000 *\u3000★ ﾟ･｡ *  ｡\n          \u3000\u3000* ☆ ｡･ﾟ*.｡\n      \u3000\u3000\u3000ﾟ *.｡☆｡★\u3000･\n    *\u3000\u3000ﾟ｡·*･｡ ﾟ*\n  \u3000\u3000\u3000☆ﾟ･｡°*. ﾟ\n\u3000 ･ ﾟ*｡･ﾟ★｡\n\u3000\u3000･ *ﾟ｡\u3000\u3000 *\n\u3000･ﾟ*｡★･\n ☆∴｡\u3000*\n･ ｡\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";\nimport ""@openzeppelin/contracts/utils/math/Math.sol"";\n\nimport ""./libraries/LockedBalance.sol"";\n\nerror FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\nerror FETH_Escrow_Expired();\nerror FETH_Escrow_Not_Found();\nerror FETH_Expiration_Too_Far_In_Future();\n/// @param amount The current allowed amount the spender is authorized to transact for this account.\nerror FETH_Insufficient_Allowance(uint256 amount);\n/// @param amount The current available (unlocked) token count of this account.\nerror FETH_Insufficient_Available_Funds(uint256 amount);\n/// @param amount The current number of tokens this account has for the given lockup expiry bucket.\nerror FETH_Insufficient_Escrow(uint256 amount);\nerror FETH_Invalid_Lockup_Duration();\nerror FETH_Market_Must_Be_A_Contract();\nerror FETH_Must_Deposit_Non_Zero_Amount();\nerror FETH_Must_Lockup_Non_Zero_Amount();\nerror FETH_No_Funds_To_Withdraw();\nerror FETH_Only_FND_Market_Allowed();\nerror FETH_Too_Much_ETH_Provided();\nerror FETH_Transfer_To_Burn_Not_Allowed();\nerror FETH_Transfer_To_FETH_Not_Allowed();\n\n/**\n * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.\n * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after\n * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).\n * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be\n * transferred or withdrawn, except by our market contract which requested the lockup in the first place.\n * @dev Locked balances are rounded up to the next hour.\n * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".\n * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.\n */\ncontract FETH {\n  using AddressUpgradeable for address payable;\n  using LockedBalance for LockedBalance.Lockups;\n  using Math for uint256;\n\n  /// @notice Tracks an account\'s info.\n  struct AccountInfo {\n    /// @notice The number of tokens which have been unlocked already.\n    uint96 freedBalance;\n    /// @notice The first applicable lockup bucket for this account.\n    uint32 lockupStartIndex;\n    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.\n    LockedBalance.Lockups lockups;\n    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.\n    mapping(address =&gt; uint256) allowance;\n  }\n\n  /// @notice Stores per-account details.\n  mapping(address =&gt; AccountInfo) private accountToInfo;\n\n  // Lockup configuration\n  /// @notice The minimum lockup period in seconds.\n  uint256 private immutable lockupDuration;\n  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.\n  uint256 private immutable lockupInterval;\n\n  /// @notice The Foundation market contract with permissions to manage lockups.\n  address payable private immutable foundationMarket;\n\n  // ERC-20 metadata fields\n  /**\n   * @notice The number of decimals the token uses.\n   * @dev This method can be used to improve usability when displaying token amounts, but all interactions\n   * with this contract use whole amounts not considering decimals.\n   * @return 18\n   */\n  uint8 public constant decimals = 18;\n  /**\n   * @notice The name of the token.\n   * @return Foundation Wrapped Ether\n   */\n  string public constant name = ""Foundation Wrapped Ether"";\n  /**\n   * @notice The symbol of the token.\n   * @return FETH\n   */\n  string public constant symbol = ""FETH"";\n\n  // ERC-20 events\n  /**\n   * @notice Emitted when the allowance for a spender account is updated.\n   * @param from The account the spender is authorized to transact for.\n   * @param spender The account with permissions to manage FETH tokens for the `from` account.\n   * @param amount The max amount of tokens which can be spent by the `spender` account.\n   */\n  event Approval(address indexed from, address indexed spender, uint256 amount);\n  /**\n   * @notice Emitted when a transfer of FETH tokens is made from one account to another.\n   * @param from The account which is sending FETH tokens.\n   * @param to The account which is receiving FETH tokens.\n   * @param amount The number of FETH tokens which were sent.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  // Custom events\n  /**\n   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours\n   * and may include newly deposited ETH which is added to the account\'s total FETH balance.\n   * @param account The account which has access to the FETH after the `expiration`.\n   * @param expiration The time at which the `from` account will have access to the locked FETH.\n   * @param amount The number of FETH tokens which where locked up.\n   * @param valueDeposited The amount of ETH added to their account\'s total FETH balance,\n   * this may be lower than `amount` if available FETH was leveraged.\n   */\n  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);\n  /**\n   * @notice Emitted when FETH tokens are unlocked by the Foundation market.\n   * @dev This event will not be emitted when lockups expire,\n   * it\'s only for tokens which are unlocked before their expiry.\n   * @param account The account which had locked FETH freed before expiration.\n   * @param expiration The time this balance was originally scheduled to be unlocked.\n   * @param amount The number of FETH tokens which were unlocked.\n   */\n  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);\n  /**\n   * @notice Emitted when ETH is withdrawn from a user\'s account.\n   * @dev This may be triggered by the user, an approved operator, or the Foundation market.\n   * @param from The account from which FETH was deducted in order to send the ETH.\n   * @param to The address the ETH was sent to.\n   * @param amount The number of tokens which were deducted from the user\'s FETH balance and transferred as ETH.\n   */\n  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);\n\n  /// @dev Allows the Foundation market permission to manage lockups for a user.\n  modifier onlyFoundationMarket() {\n    if (msg.sender != foundationMarket) {\n      revert FETH_Only_FND_Market_Allowed();\n    }\n    _;\n  }\n\n  /**\n   * @notice Initializes variables which may differ on testnet.\n   * @param _foundationMarket The address of the Foundation NFT marketplace.\n   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.\n   */\n  constructor(address payable _foundationMarket, uint256 _lockupDuration) {\n    if (!_foundationMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    foundationMarket = _foundationMarket;\n    lockupDuration = _lockupDuration;\n    lockupInterval = _lockupDuration / 24;\n    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {\n      revert FETH_Invalid_Lockup_Duration();\n    }\n  }\n\n  /**\n   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user\'s account.\n   */\n  receive() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Approves a `spender` as an operator with permissions to transfer from your account.\n   * @param spender The address of the operator account that has approval to spend funds\n   * from the `msg.sender`\'s account.\n   * @param amount The max number of FETH tokens from `msg.sender`\'s account that this spender is\n   * allowed to transact with.\n   * @return success Always true.\n   */\n  function approve(address spender, uint256 amount) external returns (bool success) {\n    accountToInfo[msg.sender].allowance[spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   */\n  function deposit() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   * @dev This may be used by the Foundation market to credit a user\'s account with FETH tokens.\n   * @param account The account to credit with FETH tokens.\n   */\n  function depositFor(address account) public payable {\n    if (msg.value == 0) {\n      revert FETH_Must_Deposit_Non_Zero_Amount();\n    }\n    AccountInfo storage accountInfo = accountToInfo[account];\n    // ETH value cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(msg.value);\n    }\n    emit Transfer(address(0), account, msg.value);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account\'s lockup and then create a new lockup, potentially for a different account.\n   * @dev Used by the market when an offer for an NFT is increased.\n   * This may be for a single account (increasing their offer)\n   * or two different accounts (outbidding someone elses offer).\n   * @param unlockFrom The account whose lockup is to be removed.\n   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`\'s account.\n   * This will revert if the tokens were previously unlocked.\n   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`\'s account.\n   * `msg.value` must be &lt;= `lockupAmount` and any delta will be taken from the account\'s available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketChangeLockup(\n    address unlockFrom,\n    uint256 unlockExpiration,\n    uint256 unlockAmount,\n    address lockupFor,\n    uint256 lockupAmount\n  ) external payable onlyFoundationMarket returns (uint256 expiration) {\n    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);\n    return _marketLockupFor(lockupFor, lockupAmount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Lockup an account\'s FETH tokens for 24-25 hours.\n   * @dev Used by the market when a new offer for an NFT is made.\n   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param amount The number of tokens to be locked up for the `lockupFor`\'s account.\n   * `msg.value` must be &lt;= `amount` and any delta will be taken from the account\'s available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketLockupFor(address account, uint256 amount)\n    external\n    payable\n    onlyFoundationMarket\n    returns (uint256 expiration)\n  {\n    return _marketLockupFor(account, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account\'s lockup, making the FETH tokens available for transfer or withdrawal.\n   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT\n   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.\n   * @param account The account whose lockup is to be unlocked.\n   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked from `account`.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _marketUnlockFor(account, expiration, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes tokens from the user\'s available balance and returns ETH to the caller.\n   * @dev Used by the market when a user\'s available FETH balance is used to make a purchase\n   * including accepting a buy price or a private sale, or placing a bid in an auction.\n   * @param from The account whose available balance is to be withdrawn from.\n   * @param amount The number of tokens to be deducted from `unlockFrom`\'s available balance and transferred as ETH.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(from, msg.sender, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes a lockup from the user\'s account and then returns ETH to the caller.\n   * @dev Used by the market to extract unexpired funds as ETH to distribute for\n   * a sale when the user\'s offer is accepted.\n   * @param account The account whose lockup is to be removed.\n   * @param expiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked and withdrawn as ETH.\n   */\n  function marketWithdrawLocked(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _removeFromLockedBalance(account, expiration, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(account, msg.sender, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from your account.\n   * @param to The address of the account which the tokens are transferred from.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds).\n   */\n  function transfer(address to, uint256 amount) external returns (bool success) {\n    return transferFrom(msg.sender, to, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.\n   * @param from The address from which the available tokens are transferred from.\n   * @param to The address to which the tokens are to be transferred.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds or not approved).\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public returns (bool success) {\n    if (to == address(0)) {\n      revert FETH_Transfer_To_Burn_Not_Allowed();\n    } else if (to == address(this)) {\n      revert FETH_Transfer_To_FETH_Not_Allowed();\n    }\n    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(fromAccountInfo, amount);\n    }\n    _deductBalanceFrom(fromAccountInfo, amount);\n    AccountInfo storage toAccountInfo = accountToInfo[to];\n\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      toAccountInfo.freedBalance += uint96(amount);\n    }\n\n    emit Transfer(from, to, amount);\n\n    return true;\n  }\n\n  /**\n   * @notice Withdraw all tokens available in your account and receive ETH.\n   */\n  function withdrawAvailableBalance() external {\n    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);\n    uint256 amount = accountInfo.freedBalance;\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    delete accountInfo.freedBalance;\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(msg.sender, msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw the specified number of tokens from the `from` accounts available balance\n   * and send ETH to the destination address, if the `msg.sender` has approval.\n   * @param from The address from which the available funds are to be withdrawn.\n   * @param to The destination address for the ETH to be transferred to.\n   * @param amount The number of tokens to be withdrawn and transferred as ETH.\n   */\n  function withdrawFrom(\n    address from,\n    address payable to,\n    uint256 amount\n  ) external {\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(accountInfo, amount);\n    }\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    to.sendValue(amount);\n\n    emit ETHWithdrawn(from, to, amount);\n  }\n\n  /**\n   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.\n   */\n  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    if (accountInfo.allowance[msg.sender] != type(uint256).max) {\n      if (accountInfo.allowance[msg.sender] &lt; amount) {\n        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);\n      }\n      // The check above ensures allowance cannot underflow.\n      unchecked {\n        accountInfo.allowance[msg.sender] -= amount;\n      }\n    }\n  }\n\n  /**\n   * @dev Removes an amount from the account\'s available FETH balance.\n   */\n  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    // Free from escrow in order to consider any expired escrow balance\n    if (accountInfo.freedBalance &lt; amount) {\n      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\n    }\n    // The check above ensures balance cannot underflow.\n    unchecked {\n      accountInfo.freedBalance -= uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Moves expired escrow to the available balance.\n   */\n  function _freeFromEscrow(address account) private returns (AccountInfo storage) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required\n    if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {\n      return accountInfo;\n    }\n\n    while (true) {\n      // Total ETH cannot realistically overflow 96 bits.\n      unchecked {\n        accountInfo.freedBalance += escrow.totalAmount;\n        accountInfo.lockups.del(escrowIndex);\n        // Escrow index cannot overflow 32 bits.\n        escrow = accountInfo.lockups.get(escrowIndex + 1);\n      }\n\n      // If the next bucket is empty, the start index is set to the previous bucket\n      if (escrow.expiration == 0) {\n        break;\n      }\n\n      // Escrow index cannot overflow 32 bits.\n      unchecked {\n        // Increment the escrow start index if the next bucket is not empty\n        ++escrowIndex;\n      }\n\n      // If the next bucket is expired, that\'s the new start index\n      if (escrow.expiration &gt;= block.timestamp) {\n        break;\n      }\n    }\n\n    // Escrow index cannot overflow 32 bits.\n    unchecked {\n      accountInfo.lockupStartIndex = uint32(escrowIndex);\n    }\n    return accountInfo;\n  }\n\n  /**\n   * @notice Lockup an account\'s FETH tokens for 24-25 hours.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {\n    if (account == address(0)) {\n      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\n    }\n    if (amount == 0) {\n      revert FETH_Must_Lockup_Non_Zero_Amount();\n    }\n\n    // Block timestamp in seconds is small enough to never overflow\n    unchecked {\n      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours\n      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;\n    }\n\n    // Update available escrow\n    // Always free from escrow to ensure the max bucket count is &lt;= 25\n    AccountInfo storage accountInfo = _freeFromEscrow(account);\n    if (msg.value &lt; amount) {\n      // The check above prevents underflow with delta.\n      unchecked {\n        uint256 delta = amount - msg.value;\n        if (accountInfo.freedBalance &lt; delta) {\n          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\n        }\n        // The check above prevents underflow of freed balance.\n        accountInfo.freedBalance -= uint96(delta);\n      }\n    } else if (msg.value != amount) {\n      // There\'s no reason to send msg.value more than the amount being locked up\n      revert FETH_Too_Much_ETH_Provided();\n    }\n\n    // Add to locked escrow\n    unchecked {\n      // The number of buckets is always &lt; 256 bits.\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          if (expiration &gt; type(uint32).max) {\n            revert FETH_Expiration_Too_Far_In_Future();\n          }\n          // Amount (ETH) will always be &lt; 96 bits.\n          accountInfo.lockups.set(escrowIndex, expiration, amount);\n          break;\n        }\n        if (escrow.expiration == expiration) {\n          // Total ETH will always be &lt; 96 bits.\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);\n          break;\n        }\n      }\n    }\n\n    emit BalanceLocked(account, expiration, amount, msg.value);\n  }\n\n  /**\n   * @notice Remove an account\'s lockup, making the FETH tokens available for transfer or withdrawal.\n   */\n  function _marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private {\n    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Removes the specified amount from locked escrow, potentially before its expiration.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _removeFromLockedBalance(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private returns (AccountInfo storage) {\n    if (expiration &lt; block.timestamp) {\n      revert FETH_Escrow_Expired();\n    }\n\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    if (escrow.expiration == expiration) {\n      // If removing from the first bucket, we may be able to delete it\n      if (escrow.totalAmount == amount) {\n        accountInfo.lockups.del(escrowIndex);\n\n        // Bump the escrow start index unless it\'s the last one\n        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {\n          // The number of escrow buckets will never overflow 32 bits.\n          unchecked {\n            ++accountInfo.lockupStartIndex;\n          }\n        }\n      } else {\n        if (escrow.totalAmount &lt; amount) {\n          revert FETH_Insufficient_Escrow(escrow.totalAmount);\n        }\n        // The require above ensures balance will not underflow.\n        unchecked {\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n        }\n      }\n    } else {\n      // Removing from the 2nd+ bucket\n      while (true) {\n        // The number of escrow buckets will never overflow 32 bits.\n        unchecked {\n          ++escrowIndex;\n        }\n        escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == expiration) {\n          if (amount &gt; escrow.totalAmount) {\n            revert FETH_Insufficient_Escrow(escrow.totalAmount);\n          }\n          // The require above ensures balance will not underflow.\n          unchecked {\n            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n          }\n          // We may have an entry with 0 totalAmount but expiration will be set\n          break;\n        }\n        if (escrow.expiration == 0) {\n          revert FETH_Escrow_Not_Found();\n        }\n      }\n    }\n\n    emit BalanceUnlocked(account, expiration, amount);\n    return accountInfo;\n  }\n\n  /**\n   * @notice Returns the amount which a spender is still allowed to transact from the `account`\'s balance.\n   * @param account The owner of the funds.\n   * @param operator The address with approval to spend from the `account`\'s balance.\n   * @return amount The number of tokens the `operator` is still allowed to transact with.\n   */\n  function allowance(address account, address operator) external view returns (uint256 amount) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    return accountInfo.allowance[operator];\n  }\n\n  /**\n   * @notice Returns the balance of an account which is available to transfer or withdraw.\n   * @dev This will automatically increase as soon as locked tokens reach their expiry date.\n   * @param account The account to query the available balance of.\n   * @return balance The available balance of the account.\n   */\n  function balanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits.\n    unchecked {\n      // Add expired lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Gets the Foundation market address which has permissions to manage lockups.\n   * @return market The Foundation market contract address.\n   */\n  function getFoundationMarket() external view returns (address market) {\n    return foundationMarket;\n  }\n\n  /**\n   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.\n   * @dev `expires.length` == `amounts.length`\n   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.\n   * The results returned are sorted by expiry, with the earliest expiry date first.\n   * @param account The account to query the locked balance of.\n   * @return expiries The time at which each outstanding lockup bucket expires.\n   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.\n   */\n  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n\n    // Count lockups\n    uint256 lockedCount;\n    // The number of buckets is always &lt; 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {\n          // Lockup count will never overflow 256 bits.\n          ++lockedCount;\n        }\n      }\n    }\n\n    // Allocate arrays\n    expiries = new uint256[](lockedCount);\n    amounts = new uint256[](lockedCount);\n\n    // Populate results\n    uint256 i;\n    // The number of buckets is always &lt; 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {\n          expiries[i] = escrow.expiration;\n          amounts[i] = escrow.totalAmount;\n          ++i;\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total balance of an account, including locked FETH tokens.\n   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.\n   * @param account The account to query the total balance of.\n   * @return balance The total FETH balance tracked for this account.\n   */\n  function totalBalanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits.\n    unchecked {\n      // Add all lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total amount of ETH locked in this contract.\n   * @return supply The total amount of ETH locked in this contract.\n   */\n  function totalSupply() external view returns (uint256 supply) {\n    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct\n       but this is on-par with the WETH implementation and done for gas savings. */\n    return address(this).balance;\n  }\n}\n', 'ideas': "" Potential Data Inconsistency Identified.\n\nPOTENTIAL DATA INCONSISTENCY\n'''\nThe contract contains several areas where data is manipulated, particularly in the handling of locked balances and account information. One notable area is in the _freeFromEscrow function, where the accountInfo.lockups.del(escrowIndex) operation is performed to delete a lockup entry. If the deletion of the lockup does not correctly update the lockupStartIndex, it may lead to inconsistencies in the data being accessed in subsequent calls. This could result in the contract referencing outdated or incorrect lockup data.\n\nAdditionally, in the _marketLockupFor function, the logic for adding to locked escrow relies on the assumption that the escrowIndex will always point to a valid entry. If the index is not managed correctly, it could lead to accessing uninitialized or incorrect data.\n\nTo mitigate this, it is recommended to implement checks after modifying the lockupStartIndex to ensure that it points to a valid entry. Also, consider adding assertions or require statements to validate the state of the data before performing operations that depend on it.\n'''\n```""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-11-08 20:26:53 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol""; import ""@openzeppelin/contracts/utils/math/Math.sol""; import ""./libraries/LockedBalance.sol""; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = ""Foundation Wrapped Ether"";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = ""FETH""; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-11-08 20:26:53 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts/utils/math/Math.sol"";

import ""./libraries/LockedBalance.sol"";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = ""Foundation Wrapped Ether"";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = ""FETH"";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""/*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts/utils/math/Math.sol"";

import ""./libraries/LockedBalance.sol"";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = ""Foundation Wrapped Ether"";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = ""FETH"";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
"".
Ideas: "" Potential Data Inconsistency Identified.
```
POTENTIAL DATA INCONSISTENCY
'''
The contract contains several areas where data is manipulated, particularly in the handling of locked balances and account information. One notable area is in the `_freeFromEscrow` function, where the `accountInfo.lockups.del(escrowIndex)` operation is performed to delete a lockup entry. If the deletion of the lockup does not correctly update the `lockupStartIndex`, it may lead to inconsistencies in the data being accessed in subsequent calls. This could result in the contract referencing outdated or incorrect lockup data.

Additionally, in the `_marketLockupFor` function, the logic for adding to locked escrow relies on the assumption that the `escrowIndex` will always point to a valid entry. If the index is not managed correctly, it could lead to accessing uninitialized or incorrect data.

To mitigate this, it is recommended to implement checks after modifying the `lockupStartIndex` to ensure that it points to a valid entry. Also, consider adding assertions or require statements to validate the state of the data before performing operations that depend on it.
'''
```"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Hash Collision. This type of vulnerability occurs when different inputs produce the same hash due to improper handling of concatenated values, leading to potential security issues.
Proceed with the following steps in your analysis:
1. Scrutinize the contract's code to identify any functions that generate hashes from input values.
2. Look for patterns where multiple input values are concatenated without clear delimiters before hashing. Pay special attention to the use of `abi.encodePacked` for concatenation.
3. Determine if the concatenated inputs can produce the same hash for different combinations of input values, leading to potential hash collisions.
4. Evaluate the logic for generating and handling hashes within the contract to ensure that the potential for hash collisions is minimized.
If you discover any Hash Collision vulnerabilities, respond with: """,,,,,,"<INFO> Precision Loss Identified.

VULNERABILITY NAME: Loss of Precision in Arithmetic Operations
'''
The contract performs arithmetic operations using unsigned integers, particularly in the `_marketLockupFor` function where it calculates the expiration timestamp using the `ceilDiv` method. This method can lead to precision loss when dealing with fractional values, especially if the `lockupInterval` is not a perfect divisor of the `lockupDuration`. The result of such operations can lead to incorrect expiration timestamps, which may affect the lockup functionality and user experience.

To mitigate this issue, ensure that all arithmetic operations that could result in fractional values are handled with appropriate scaling. For example, consider using a fixed-point arithmetic library or scaling values before performing division to maintain precision. Additionally, validate that the `lockupInterval` is set correctly to avoid potential precision loss in calculations.
'''

[2024-11-08 20:27:12 INFO] **[Execute Detail]**

execute SimplePhase:[RedundantConditionalDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-11-08 20:27:12 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol""; import ""@openzeppelin/contracts/utils/math/Math.sol""; import ""./libraries/LockedBalance.sol""; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = ""Foundation Wrapped Ether"";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = ""FETH""; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Redundant Conditional Checks. There are specific cases where the code may have Redundant Conditional Check vulnerabilities: 1. Conditional checks that always evaluate to true or false, which add unnecessary complexity and gas costs to the code. 2. Conditions that duplicate checks already performed earlier in the code, leading to redundant operations and inefficient execution. If you identify any redundant conditional checks, respond with: "" Redundant Conditional Check Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If you don't find any vulnerabilities, respond only with: "" NO Redundant Conditional Checks."" |
| **phase_name** | RedundantConditionalDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '/\n  ･\n   \u3000★\n      ･ ｡\n        \u3000･\u3000ﾟ☆ ｡\n  \u3000\u3000\u3000 \u3000★ ﾟ･｡ *  ｡\n          \u3000\u3000 ☆ ｡･ﾟ.｡\n      \u3000\u3000\u3000ﾟ .｡☆｡★\u3000･\n\u200b\n                      .-:::::-.              -::---...```\n-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy\n-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo\n                                              ````\n   *\u3000\n      ･ ｡\n\u3000\u3000\u3000\u3000･\u3000\u3000ﾟ☆ ｡\n  \u3000\u3000\u3000 *\u3000★ ﾟ･｡ *  ｡\n          \u3000\u3000* ☆ ｡･ﾟ*.｡\n      \u3000\u3000\u3000ﾟ *.｡☆｡★\u3000･\n    *\u3000\u3000ﾟ｡·*･｡ ﾟ*\n  \u3000\u3000\u3000☆ﾟ･｡°*. ﾟ\n\u3000 ･ ﾟ*｡･ﾟ★｡\n\u3000\u3000･ *ﾟ｡\u3000\u3000 *\n\u3000･ﾟ*｡★･\n ☆∴｡\u3000*\n･ ｡\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";\nimport ""@openzeppelin/contracts/utils/math/Math.sol"";\n\nimport ""./libraries/LockedBalance.sol"";\n\nerror FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\nerror FETH_Escrow_Expired();\nerror FETH_Escrow_Not_Found();\nerror FETH_Expiration_Too_Far_In_Future();\n/// @param amount The current allowed amount the spender is authorized to transact for this account.\nerror FETH_Insufficient_Allowance(uint256 amount);\n/// @param amount The current available (unlocked) token count of this account.\nerror FETH_Insufficient_Available_Funds(uint256 amount);\n/// @param amount The current number of tokens this account has for the given lockup expiry bucket.\nerror FETH_Insufficient_Escrow(uint256 amount);\nerror FETH_Invalid_Lockup_Duration();\nerror FETH_Market_Must_Be_A_Contract();\nerror FETH_Must_Deposit_Non_Zero_Amount();\nerror FETH_Must_Lockup_Non_Zero_Amount();\nerror FETH_No_Funds_To_Withdraw();\nerror FETH_Only_FND_Market_Allowed();\nerror FETH_Too_Much_ETH_Provided();\nerror FETH_Transfer_To_Burn_Not_Allowed();\nerror FETH_Transfer_To_FETH_Not_Allowed();\n\n/**\n * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.\n * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after\n * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).\n * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be\n * transferred or withdrawn, except by our market contract which requested the lockup in the first place.\n * @dev Locked balances are rounded up to the next hour.\n * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".\n * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.\n */\ncontract FETH {\n  using AddressUpgradeable for address payable;\n  using LockedBalance for LockedBalance.Lockups;\n  using Math for uint256;\n\n  /// @notice Tracks an account\'s info.\n  struct AccountInfo {\n    /// @notice The number of tokens which have been unlocked already.\n    uint96 freedBalance;\n    /// @notice The first applicable lockup bucket for this account.\n    uint32 lockupStartIndex;\n    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.\n    LockedBalance.Lockups lockups;\n    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.\n    mapping(address =&gt; uint256) allowance;\n  }\n\n  /// @notice Stores per-account details.\n  mapping(address =&gt; AccountInfo) private accountToInfo;\n\n  // Lockup configuration\n  /// @notice The minimum lockup period in seconds.\n  uint256 private immutable lockupDuration;\n  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.\n  uint256 private immutable lockupInterval;\n\n  /// @notice The Foundation market contract with permissions to manage lockups.\n  address payable private immutable foundationMarket;\n\n  // ERC-20 metadata fields\n  /**\n   * @notice The number of decimals the token uses.\n   * @dev This method can be used to improve usability when displaying token amounts, but all interactions\n   * with this contract use whole amounts not considering decimals.\n   * @return 18\n   */\n  uint8 public constant decimals = 18;\n  /**\n   * @notice The name of the token.\n   * @return Foundation Wrapped Ether\n   */\n  string public constant name = ""Foundation Wrapped Ether"";\n  /**\n   * @notice The symbol of the token.\n   * @return FETH\n   */\n  string public constant symbol = ""FETH"";\n\n  // ERC-20 events\n  /**\n   * @notice Emitted when the allowance for a spender account is updated.\n   * @param from The account the spender is authorized to transact for.\n   * @param spender The account with permissions to manage FETH tokens for thefromaccount.\n   * @param amount The max amount of tokens which can be spent by thespenderaccount.\n   */\n  event Approval(address indexed from, address indexed spender, uint256 amount);\n  /**\n   * @notice Emitted when a transfer of FETH tokens is made from one account to another.\n   * @param from The account which is sending FETH tokens.\n   * @param to The account which is receiving FETH tokens.\n   * @param amount The number of FETH tokens which were sent.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  // Custom events\n  /**\n   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours\n   * and may include newly deposited ETH which is added to the account\'s total FETH balance.\n   * @param account The account which has access to the FETH after theexpiration.\n   * @param expiration The time at which thefromaccount will have access to the locked FETH.\n   * @param amount The number of FETH tokens which where locked up.\n   * @param valueDeposited The amount of ETH added to their account\'s total FETH balance,\n   * this may be lower thanamountif available FETH was leveraged.\n   */\n  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);\n  /**\n   * @notice Emitted when FETH tokens are unlocked by the Foundation market.\n   * @dev This event will not be emitted when lockups expire,\n   * it\'s only for tokens which are unlocked before their expiry.\n   * @param account The account which had locked FETH freed before expiration.\n   * @param expiration The time this balance was originally scheduled to be unlocked.\n   * @param amount The number of FETH tokens which were unlocked.\n   */\n  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);\n  /**\n   * @notice Emitted when ETH is withdrawn from a user\'s account.\n   * @dev This may be triggered by the user, an approved operator, or the Foundation market.\n   * @param from The account from which FETH was deducted in order to send the ETH.\n   * @param to The address the ETH was sent to.\n   * @param amount The number of tokens which were deducted from the user\'s FETH balance and transferred as ETH.\n   */\n  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);\n\n  /// @dev Allows the Foundation market permission to manage lockups for a user.\n  modifier onlyFoundationMarket() {\n    if (msg.sender != foundationMarket) {\n      revert FETH_Only_FND_Market_Allowed();\n    }\n    _;\n  }\n\n  /**\n   * @notice Initializes variables which may differ on testnet.\n   * @param _foundationMarket The address of the Foundation NFT marketplace.\n   * @param _lockupDuration The minimum length of time to lockup tokens for whenBalanceLocked, in seconds.\n   */\n  constructor(address payable _foundationMarket, uint256 _lockupDuration) {\n    if (!_foundationMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    foundationMarket = _foundationMarket;\n    lockupDuration = _lockupDuration;\n    lockupInterval = _lockupDuration / 24;\n    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {\n      revert FETH_Invalid_Lockup_Duration();\n    }\n  }\n\n  /**\n   * @notice Transferring ETH (viamsg.value) to the contract performs adepositinto the user\'s account.\n   */\n  receive() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Approves aspenderas an operator with permissions to transfer from your account.\n   * @param spender The address of the operator account that has approval to spend funds\n   * from themsg.sender\'s account.\n   * @param amount The max number of FETH tokens frommsg.sender\'s account that this spender is\n   * allowed to transact with.\n   * @return success Always true.\n   */\n  function approve(address spender, uint256 amount) external returns (bool success) {\n    accountToInfo[msg.sender].allowance[spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Deposit ETH (viamsg.value) and receive the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   */\n  function deposit() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Deposit ETH (viamsg.value) and credit theaccountprovided with the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   * @dev This may be used by the Foundation market to credit a user\'s account with FETH tokens.\n   * @param account The account to credit with FETH tokens.\n   */\n  function depositFor(address account) public payable {\n    if (msg.value == 0) {\n      revert FETH_Must_Deposit_Non_Zero_Amount();\n    }\n    AccountInfo storage accountInfo = accountToInfo[account];\n    // ETH value cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(msg.value);\n    }\n    emit Transfer(address(0), account, msg.value);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account\'s lockup and then create a new lockup, potentially for a different account.\n   * @dev Used by the market when an offer for an NFT is increased.\n   * This may be for a single account (increasing their offer)\n   * or two different accounts (outbidding someone elses offer).\n   * @param unlockFrom The account whose lockup is to be removed.\n   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param unlockAmount The number of tokens to be unlocked fromunlockFrom\'s account.\n   * This will revert if the tokens were previously unlocked.\n   * @param lockupFor The account to which the funds are to be deposited for (via themsg.value) and tokens locked up.\n   * @param lockupAmount The number of tokens to be locked up for thelockupFor\'s account.\n   *msg.valuemust be &lt;=lockupAmountand any delta will be taken from the account\'s available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketChangeLockup(\n    address unlockFrom,\n    uint256 unlockExpiration,\n    uint256 unlockAmount,\n    address lockupFor,\n    uint256 lockupAmount\n  ) external payable onlyFoundationMarket returns (uint256 expiration) {\n    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);\n    return _marketLockupFor(lockupFor, lockupAmount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Lockup an account\'s FETH tokens for 24-25 hours.\n   * @dev Used by the market when a new offer for an NFT is made.\n   * @param account The account to which the funds are to be deposited for (via themsg.value) and tokens locked up.\n   * @param amount The number of tokens to be locked up for thelockupFor\'s account.\n   *msg.valuemust be &lt;=amountand any delta will be taken from the account\'s available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketLockupFor(address account, uint256 amount)\n    external\n    payable\n    onlyFoundationMarket\n    returns (uint256 expiration)\n  {\n    return _marketLockupFor(account, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account\'s lockup, making the FETH tokens available for transfer or withdrawal.\n   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT\n   * receives its first bid or the buyer purchased the NFT another way, such as withbuy.\n   * @param account The account whose lockup is to be unlocked.\n   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked fromaccount.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _marketUnlockFor(account, expiration, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes tokens from the user\'s available balance and returns ETH to the caller.\n   * @dev Used by the market when a user\'s available FETH balance is used to make a purchase\n   * including accepting a buy price or a private sale, or placing a bid in an auction.\n   * @param from The account whose available balance is to be withdrawn from.\n   * @param amount The number of tokens to be deducted fromunlockFrom\'s available balance and transferred as ETH.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(from, msg.sender, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes a lockup from the user\'s account and then returns ETH to the caller.\n   * @dev Used by the market to extract unexpired funds as ETH to distribute for\n   * a sale when the user\'s offer is accepted.\n   * @param account The account whose lockup is to be removed.\n   * @param expiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked and withdrawn as ETH.\n   */\n  function marketWithdrawLocked(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _removeFromLockedBalance(account, expiration, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(account, msg.sender, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from your account.\n   * @param to The address of the account which the tokens are transferred from.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds).\n   */\n  function transfer(address to, uint256 amount) external returns (bool success) {\n    return transferFrom(msg.sender, to, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from the account specified if themsg.senderhas approval.\n   * @param from The address from which the available tokens are transferred from.\n   * @param to The address to which the tokens are to be transferred.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds or not approved).\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public returns (bool success) {\n    if (to == address(0)) {\n      revert FETH_Transfer_To_Burn_Not_Allowed();\n    } else if (to == address(this)) {\n      revert FETH_Transfer_To_FETH_Not_Allowed();\n    }\n    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(fromAccountInfo, amount);\n    }\n    _deductBalanceFrom(fromAccountInfo, amount);\n    AccountInfo storage toAccountInfo = accountToInfo[to];\n\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      toAccountInfo.freedBalance += uint96(amount);\n    }\n\n    emit Transfer(from, to, amount);\n\n    return true;\n  }\n\n  /**\n   * @notice Withdraw all tokens available in your account and receive ETH.\n   */\n  function withdrawAvailableBalance() external {\n    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);\n    uint256 amount = accountInfo.freedBalance;\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    delete accountInfo.freedBalance;\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(msg.sender, msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw the specified number of tokens from thefromaccounts available balance\n   * and send ETH to the destination address, if themsg.senderhas approval.\n   * @param from The address from which the available funds are to be withdrawn.\n   * @param to The destination address for the ETH to be transferred to.\n   * @param amount The number of tokens to be withdrawn and transferred as ETH.\n   */\n  function withdrawFrom(\n    address from,\n    address payable to,\n    uint256 amount\n  ) external {\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(accountInfo, amount);\n    }\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    to.sendValue(amount);\n\n    emit ETHWithdrawn(from, to, amount);\n  }\n\n  /**\n   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.\n   */\n  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    if (accountInfo.allowance[msg.sender] != type(uint256).max) {\n      if (accountInfo.allowance[msg.sender] &lt; amount) {\n        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);\n      }\n      // The check above ensures allowance cannot underflow.\n      unchecked {\n        accountInfo.allowance[msg.sender] -= amount;\n      }\n    }\n  }\n\n  /**\n   * @dev Removes an amount from the account\'s available FETH balance.\n   */\n  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    // Free from escrow in order to consider any expired escrow balance\n    if (accountInfo.freedBalance &lt; amount) {\n      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\n    }\n    // The check above ensures balance cannot underflow.\n    unchecked {\n      accountInfo.freedBalance -= uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Moves expired escrow to the available balance.\n   */\n  function _freeFromEscrow(address account) private returns (AccountInfo storage) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required\n    if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {\n      return accountInfo;\n    }\n\n    while (true) {\n      // Total ETH cannot realistically overflow 96 bits.\n      unchecked {\n        accountInfo.freedBalance += escrow.totalAmount;\n        accountInfo.lockups.del(escrowIndex);\n        // Escrow index cannot overflow 32 bits.\n        escrow = accountInfo.lockups.get(escrowIndex + 1);\n      }\n\n      // If the next bucket is empty, the start index is set to the previous bucket\n      if (escrow.expiration == 0) {\n        break;\n      }\n\n      // Escrow index cannot overflow 32 bits.\n      unchecked {\n        // Increment the escrow start index if the next bucket is not empty\n        ++escrowIndex;\n      }\n\n      // If the next bucket is expired, that\'s the new start index\n      if (escrow.expiration &gt;= block.timestamp) {\n        break;\n      }\n    }\n\n    // Escrow index cannot overflow 32 bits.\n    unchecked {\n      accountInfo.lockupStartIndex = uint32(escrowIndex);\n    }\n    return accountInfo;\n  }\n\n  /**\n   * @notice Lockup an account\'s FETH tokens for 24-25 hours.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {\n    if (account == address(0)) {\n      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\n    }\n    if (amount == 0) {\n      revert FETH_Must_Lockup_Non_Zero_Amount();\n    }\n\n    // Block timestamp in seconds is small enough to never overflow\n    unchecked {\n      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours\n      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;\n    }\n\n    // Update available escrow\n    // Always free from escrow to ensure the max bucket count is &lt;= 25\n    AccountInfo storage accountInfo = _freeFromEscrow(account);\n    if (msg.value &lt; amount) {\n      // The check above prevents underflow with delta.\n      unchecked {\n        uint256 delta = amount - msg.value;\n        if (accountInfo.freedBalance &lt; delta) {\n          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\n        }\n        // The check above prevents underflow of freed balance.\n        accountInfo.freedBalance -= uint96(delta);\n      }\n    } else if (msg.value != amount) {\n      // There\'s no reason to send msg.value more than the amount being locked up\n      revert FETH_Too_Much_ETH_Provided();\n    }\n\n    // Add to locked escrow\n    unchecked {\n      // The number of buckets is always &lt; 256 bits.\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          if (expiration &gt; type(uint32).max) {\n            revert FETH_Expiration_Too_Far_In_Future();\n          }\n          // Amount (ETH) will always be &lt; 96 bits.\n          accountInfo.lockups.set(escrowIndex, expiration, amount);\n          break;\n        }\n        if (escrow.expiration == expiration) {\n          // Total ETH will always be &lt; 96 bits.\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);\n          break;\n        }\n      }\n    }\n\n    emit BalanceLocked(account, expiration, amount, msg.value);\n  }\n\n  /**\n   * @notice Remove an account\'s lockup, making the FETH tokens available for transfer or withdrawal.\n   */\n  function _marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private {\n    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Removes the specified amount from locked escrow, potentially before its expiration.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _removeFromLockedBalance(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private returns (AccountInfo storage) {\n    if (expiration &lt; block.timestamp) {\n      revert FETH_Escrow_Expired();\n    }\n\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    if (escrow.expiration == expiration) {\n      // If removing from the first bucket, we may be able to delete it\n      if (escrow.totalAmount == amount) {\n        accountInfo.lockups.del(escrowIndex);\n\n        // Bump the escrow start index unless it\'s the last one\n        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {\n          // The number of escrow buckets will never overflow 32 bits.\n          unchecked {\n            ++accountInfo.lockupStartIndex;\n          }\n        }\n      } else {\n        if (escrow.totalAmount &lt; amount) {\n          revert FETH_Insufficient_Escrow(escrow.totalAmount);\n        }\n        // The require above ensures balance will not underflow.\n        unchecked {\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n        }\n      }\n    } else {\n      // Removing from the 2nd+ bucket\n      while (true) {\n        // The number of escrow buckets will never overflow 32 bits.\n        unchecked {\n          ++escrowIndex;\n        }\n        escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == expiration) {\n          if (amount &gt; escrow.totalAmount) {\n            revert FETH_Insufficient_Escrow(escrow.totalAmount);\n          }\n          // The require above ensures balance will not underflow.\n          unchecked {\n            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n          }\n          // We may have an entry with 0 totalAmount but expiration will be set\n          break;\n        }\n        if (escrow.expiration == 0) {\n          revert FETH_Escrow_Not_Found();\n        }\n      }\n    }\n\n    emit BalanceUnlocked(account, expiration, amount);\n    return accountInfo;\n  }\n\n  /**\n   * @notice Returns the amount which a spender is still allowed to transact from theaccount\'s balance.\n   * @param account The owner of the funds.\n   * @param operator The address with approval to spend from theaccount\'s balance.\n   * @return amount The number of tokens theoperatoris still allowed to transact with.\n   */\n  function allowance(address account, address operator) external view returns (uint256 amount) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    return accountInfo.allowance[operator];\n  }\n\n  /**\n   * @notice Returns the balance of an account which is available to transfer or withdraw.\n   * @dev This will automatically increase as soon as locked tokens reach their expiry date.\n   * @param account The account to query the available balance of.\n   * @return balance The available balance of the account.\n   */\n  function balanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits.\n    unchecked {\n      // Add expired lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Gets the Foundation market address which has permissions to manage lockups.\n   * @return market The Foundation market contract address.\n   */\n  function getFoundationMarket() external view returns (address market) {\n    return foundationMarket;\n  }\n\n  /**\n   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.\n   * @devexpires.length==amounts.length\n   * andamounts[i]is the number of tokens which will expire atexpires[i].\n   * The results returned are sorted by expiry, with the earliest expiry date first.\n   * @param account The account to query the locked balance of.\n   * @return expiries The time at which each outstanding lockup bucket expires.\n   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.\n   */\n  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n\n    // Count lockups\n    uint256 lockedCount;\n    // The number of buckets is always &lt; 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {\n          // Lockup count will never overflow 256 bits.\n          ++lockedCount;\n        }\n      }\n    }\n\n    // Allocate arrays\n    expiries = new uint256[](lockedCount);\n    amounts = new uint256[](lockedCount);\n\n    // Populate results\n    uint256 i;\n    // The number of buckets is always &lt; 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {\n          expiries[i] = escrow.expiration;\n          amounts[i] = escrow.totalAmount;\n          ++i;\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total balance of an account, including locked FETH tokens.\n   * @dev UsebalanceOfto get the number of tokens available for transfer or withdrawal.\n   * @param account The account to query the total balance of.\n   * @return balance The total FETH balance tracked for this account.\n   */\n  function totalBalanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits.\n    unchecked {\n      // Add all lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total amount of ETH locked in this contract.\n   * @return supply The total amount of ETH locked in this contract.\n   */\n  function totalSupply() external view returns (uint256 supply) {\n    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct\n       but this is on-par with the WETH implementation and done for gas savings. */\n    return address(this).balance;\n  }\n}\n', 'ideas': "" Precision Loss Identified.\n\nVULNERABILITY NAME: Loss of Precision in Arithmetic Operations\n'''\nThe contract performs arithmetic operations using unsigned integers, particularly in the_marketLockupForfunction where it calculates the expiration timestamp using theceilDivmethod. This method can lead to precision loss when dealing with fractional values, especially if thelockupIntervalis not a perfect divisor of thelockupDuration. The result of such operations can lead to incorrect expiration timestamps, which may affect the lockup functionality and user experience.\n\nTo mitigate this issue, ensure that all arithmetic operations that could result in fractional values are handled with appropriate scaling. For example, consider using a fixed-point arithmetic library or scaling values before performing division to maintain precision. Additionally, validate that thelockupInterval` is set correctly to avoid potential precision loss in calculations.\n'''""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-11-08 20:27:12 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol""; import ""@openzeppelin/contracts/utils/math/Math.sol""; import ""./libraries/LockedBalance.sol""; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = ""Foundation Wrapped Ether"";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = ""FETH""; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-11-08 20:27:12 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts/utils/math/Math.sol"";

import ""./libraries/LockedBalance.sol"";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = ""Foundation Wrapped Ether"";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = ""FETH"";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""/*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts/utils/math/Math.sol"";

import ""./libraries/LockedBalance.sol"";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = ""Foundation Wrapped Ether"";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = ""FETH"";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
"".
Ideas: "" Precision Loss Identified.

VULNERABILITY NAME: Loss of Precision in Arithmetic Operations
'''
The contract performs arithmetic operations using unsigned integers, particularly in the `_marketLockupFor` function where it calculates the expiration timestamp using the `ceilDiv` method. This method can lead to precision loss when dealing with fractional values, especially if the `lockupInterval` is not a perfect divisor of the `lockupDuration`. The result of such operations can lead to incorrect expiration timestamps, which may affect the lockup functionality and user experience.

To mitigate this issue, ensure that all arithmetic operations that could result in fractional values are handled with appropriate scaling. For example, consider using a fixed-point arithmetic library or scaling values before performing division to maintain precision. Additionally, validate that the `lockupInterval` is set correctly to avoid potential precision loss in calculations.
'''"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Redundant Conditional Checks. There are specific cases where the code may have Redundant Conditional Check vulnerabilities:
1. Conditional checks that always evaluate to true or false, which add unnecessary complexity and gas costs to the code.
2. Conditions that duplicate checks already performed earlier in the code, leading to redundant operations and inefficient execution.
If you identify any redundant conditional checks, respond with: ""","<INFO> Redundant Conditional Check Identified.

VULNERABILITY NAME: Redundant Conditional Checks
'''
In the `depositFor` function, there is a check for `msg.value == 0` which reverts with `FETH_Must_Deposit_Non_Zero_Amount()`. This check is redundant because the `deposit` function, which calls `depositFor`, already ensures that `msg.value` is non-zero when it is called. Therefore, the check in `depositFor` is unnecessary and adds additional gas costs without providing any additional safety.

To mitigate this issue, you can remove the check for `msg.value == 0` in the `depositFor` function, as it is already guaranteed by the calling function.
'''

VULNERABILITY NAME: Redundant Conditional Checks
'''
In the `_marketLockupFor` function, there is a check for `msg.value < amount` followed by a check for `msg.value != amount`. If `msg.value` is less than `amount`, it is already implied that `msg.value` cannot equal `amount`. Therefore, the second check is redundant and can be removed.

To mitigate this issue, you can simplify the logic by keeping only the check for `msg.value < amount` and removing the `msg.value != amount` check.
'''

[2024-11-08 20:27:17 INFO] **[Execute Detail]**

execute SimplePhase:[OracleDependencyDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-11-08 20:27:18 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol""; import ""@openzeppelin/contracts/utils/math/Math.sol""; import ""./libraries/LockedBalance.sol""; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = ""Foundation Wrapped Ether"";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = ""FETH""; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to External Oracle Dependency. There are two main concerns related to External Oracle Dependency vulnerabilities: 1. Dependence on a single external oracle for critical data, which pertains to the reliability of the data source. If the oracle is compromised, provides incorrect data, or becomes unavailable, the contract's functionalities could be adversely affected. 2. Lack of fallback mechanisms, which can lead to the contract failing if the external oracle call fails or returns invalid data. This could be exploited by adversaries to disrupt the contract's operations. If you identify reliance on a single external oracle for critical data, respond with: "" External Oracle Dependency Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If you don't find any vulnerabilities, respond only with: "" NO External Oracle Dependency."" |
| **phase_name** | OracleDependencyDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '/\n  ･\n   \u3000★\n      ･ ｡\n        \u3000･\u3000ﾟ☆ ｡\n  \u3000\u3000\u3000 \u3000★ ﾟ･｡ *  ｡\n          \u3000\u3000 ☆ ｡･ﾟ.｡\n      \u3000\u3000\u3000ﾟ .｡☆｡★\u3000･\n\u200b\n                      .-:::::-.              -::---...```\n-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy\n-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo\n                                              ````\n   *\u3000\n      ･ ｡\n\u3000\u3000\u3000\u3000･\u3000\u3000ﾟ☆ ｡\n  \u3000\u3000\u3000 *\u3000★ ﾟ･｡ *  ｡\n          \u3000\u3000* ☆ ｡･ﾟ*.｡\n      \u3000\u3000\u3000ﾟ *.｡☆｡★\u3000･\n    *\u3000\u3000ﾟ｡·*･｡ ﾟ*\n  \u3000\u3000\u3000☆ﾟ･｡°*. ﾟ\n\u3000 ･ ﾟ*｡･ﾟ★｡\n\u3000\u3000･ *ﾟ｡\u3000\u3000 *\n\u3000･ﾟ*｡★･\n ☆∴｡\u3000*\n･ ｡\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";\nimport ""@openzeppelin/contracts/utils/math/Math.sol"";\n\nimport ""./libraries/LockedBalance.sol"";\n\nerror FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\nerror FETH_Escrow_Expired();\nerror FETH_Escrow_Not_Found();\nerror FETH_Expiration_Too_Far_In_Future();\n/// @param amount The current allowed amount the spender is authorized to transact for this account.\nerror FETH_Insufficient_Allowance(uint256 amount);\n/// @param amount The current available (unlocked) token count of this account.\nerror FETH_Insufficient_Available_Funds(uint256 amount);\n/// @param amount The current number of tokens this account has for the given lockup expiry bucket.\nerror FETH_Insufficient_Escrow(uint256 amount);\nerror FETH_Invalid_Lockup_Duration();\nerror FETH_Market_Must_Be_A_Contract();\nerror FETH_Must_Deposit_Non_Zero_Amount();\nerror FETH_Must_Lockup_Non_Zero_Amount();\nerror FETH_No_Funds_To_Withdraw();\nerror FETH_Only_FND_Market_Allowed();\nerror FETH_Too_Much_ETH_Provided();\nerror FETH_Transfer_To_Burn_Not_Allowed();\nerror FETH_Transfer_To_FETH_Not_Allowed();\n\n/**\n * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.\n * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after\n * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).\n * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be\n * transferred or withdrawn, except by our market contract which requested the lockup in the first place.\n * @dev Locked balances are rounded up to the next hour.\n * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".\n * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.\n */\ncontract FETH {\n  using AddressUpgradeable for address payable;\n  using LockedBalance for LockedBalance.Lockups;\n  using Math for uint256;\n\n  /// @notice Tracks an account\'s info.\n  struct AccountInfo {\n    /// @notice The number of tokens which have been unlocked already.\n    uint96 freedBalance;\n    /// @notice The first applicable lockup bucket for this account.\n    uint32 lockupStartIndex;\n    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.\n    LockedBalance.Lockups lockups;\n    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.\n    mapping(address =&gt; uint256) allowance;\n  }\n\n  /// @notice Stores per-account details.\n  mapping(address =&gt; AccountInfo) private accountToInfo;\n\n  // Lockup configuration\n  /// @notice The minimum lockup period in seconds.\n  uint256 private immutable lockupDuration;\n  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.\n  uint256 private immutable lockupInterval;\n\n  /// @notice The Foundation market contract with permissions to manage lockups.\n  address payable private immutable foundationMarket;\n\n  // ERC-20 metadata fields\n  /**\n   * @notice The number of decimals the token uses.\n   * @dev This method can be used to improve usability when displaying token amounts, but all interactions\n   * with this contract use whole amounts not considering decimals.\n   * @return 18\n   */\n  uint8 public constant decimals = 18;\n  /**\n   * @notice The name of the token.\n   * @return Foundation Wrapped Ether\n   */\n  string public constant name = ""Foundation Wrapped Ether"";\n  /**\n   * @notice The symbol of the token.\n   * @return FETH\n   */\n  string public constant symbol = ""FETH"";\n\n  // ERC-20 events\n  /**\n   * @notice Emitted when the allowance for a spender account is updated.\n   * @param from The account the spender is authorized to transact for.\n   * @param spender The account with permissions to manage FETH tokens for thefromaccount.\n   * @param amount The max amount of tokens which can be spent by thespenderaccount.\n   */\n  event Approval(address indexed from, address indexed spender, uint256 amount);\n  /**\n   * @notice Emitted when a transfer of FETH tokens is made from one account to another.\n   * @param from The account which is sending FETH tokens.\n   * @param to The account which is receiving FETH tokens.\n   * @param amount The number of FETH tokens which were sent.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  // Custom events\n  /**\n   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours\n   * and may include newly deposited ETH which is added to the account\'s total FETH balance.\n   * @param account The account which has access to the FETH after theexpiration.\n   * @param expiration The time at which thefromaccount will have access to the locked FETH.\n   * @param amount The number of FETH tokens which where locked up.\n   * @param valueDeposited The amount of ETH added to their account\'s total FETH balance,\n   * this may be lower thanamountif available FETH was leveraged.\n   */\n  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);\n  /**\n   * @notice Emitted when FETH tokens are unlocked by the Foundation market.\n   * @dev This event will not be emitted when lockups expire,\n   * it\'s only for tokens which are unlocked before their expiry.\n   * @param account The account which had locked FETH freed before expiration.\n   * @param expiration The time this balance was originally scheduled to be unlocked.\n   * @param amount The number of FETH tokens which were unlocked.\n   */\n  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);\n  /**\n   * @notice Emitted when ETH is withdrawn from a user\'s account.\n   * @dev This may be triggered by the user, an approved operator, or the Foundation market.\n   * @param from The account from which FETH was deducted in order to send the ETH.\n   * @param to The address the ETH was sent to.\n   * @param amount The number of tokens which were deducted from the user\'s FETH balance and transferred as ETH.\n   */\n  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);\n\n  /// @dev Allows the Foundation market permission to manage lockups for a user.\n  modifier onlyFoundationMarket() {\n    if (msg.sender != foundationMarket) {\n      revert FETH_Only_FND_Market_Allowed();\n    }\n    _;\n  }\n\n  /**\n   * @notice Initializes variables which may differ on testnet.\n   * @param _foundationMarket The address of the Foundation NFT marketplace.\n   * @param _lockupDuration The minimum length of time to lockup tokens for whenBalanceLocked, in seconds.\n   */\n  constructor(address payable _foundationMarket, uint256 _lockupDuration) {\n    if (!_foundationMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    foundationMarket = _foundationMarket;\n    lockupDuration = _lockupDuration;\n    lockupInterval = _lockupDuration / 24;\n    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {\n      revert FETH_Invalid_Lockup_Duration();\n    }\n  }\n\n  /**\n   * @notice Transferring ETH (viamsg.value) to the contract performs adepositinto the user\'s account.\n   */\n  receive() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Approves aspenderas an operator with permissions to transfer from your account.\n   * @param spender The address of the operator account that has approval to spend funds\n   * from themsg.sender\'s account.\n   * @param amount The max number of FETH tokens frommsg.sender\'s account that this spender is\n   * allowed to transact with.\n   * @return success Always true.\n   */\n  function approve(address spender, uint256 amount) external returns (bool success) {\n    accountToInfo[msg.sender].allowance[spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Deposit ETH (viamsg.value) and receive the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   */\n  function deposit() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Deposit ETH (viamsg.value) and credit theaccountprovided with the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   * @dev This may be used by the Foundation market to credit a user\'s account with FETH tokens.\n   * @param account The account to credit with FETH tokens.\n   */\n  function depositFor(address account) public payable {\n    if (msg.value == 0) {\n      revert FETH_Must_Deposit_Non_Zero_Amount();\n    }\n    AccountInfo storage accountInfo = accountToInfo[account];\n    // ETH value cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(msg.value);\n    }\n    emit Transfer(address(0), account, msg.value);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account\'s lockup and then create a new lockup, potentially for a different account.\n   * @dev Used by the market when an offer for an NFT is increased.\n   * This may be for a single account (increasing their offer)\n   * or two different accounts (outbidding someone elses offer).\n   * @param unlockFrom The account whose lockup is to be removed.\n   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param unlockAmount The number of tokens to be unlocked fromunlockFrom\'s account.\n   * This will revert if the tokens were previously unlocked.\n   * @param lockupFor The account to which the funds are to be deposited for (via themsg.value) and tokens locked up.\n   * @param lockupAmount The number of tokens to be locked up for thelockupFor\'s account.\n   *msg.valuemust be &lt;=lockupAmountand any delta will be taken from the account\'s available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketChangeLockup(\n    address unlockFrom,\n    uint256 unlockExpiration,\n    uint256 unlockAmount,\n    address lockupFor,\n    uint256 lockupAmount\n  ) external payable onlyFoundationMarket returns (uint256 expiration) {\n    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);\n    return _marketLockupFor(lockupFor, lockupAmount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Lockup an account\'s FETH tokens for 24-25 hours.\n   * @dev Used by the market when a new offer for an NFT is made.\n   * @param account The account to which the funds are to be deposited for (via themsg.value) and tokens locked up.\n   * @param amount The number of tokens to be locked up for thelockupFor\'s account.\n   *msg.valuemust be &lt;=amountand any delta will be taken from the account\'s available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketLockupFor(address account, uint256 amount)\n    external\n    payable\n    onlyFoundationMarket\n    returns (uint256 expiration)\n  {\n    return _marketLockupFor(account, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account\'s lockup, making the FETH tokens available for transfer or withdrawal.\n   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT\n   * receives its first bid or the buyer purchased the NFT another way, such as withbuy.\n   * @param account The account whose lockup is to be unlocked.\n   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked fromaccount.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _marketUnlockFor(account, expiration, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes tokens from the user\'s available balance and returns ETH to the caller.\n   * @dev Used by the market when a user\'s available FETH balance is used to make a purchase\n   * including accepting a buy price or a private sale, or placing a bid in an auction.\n   * @param from The account whose available balance is to be withdrawn from.\n   * @param amount The number of tokens to be deducted fromunlockFrom\'s available balance and transferred as ETH.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(from, msg.sender, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes a lockup from the user\'s account and then returns ETH to the caller.\n   * @dev Used by the market to extract unexpired funds as ETH to distribute for\n   * a sale when the user\'s offer is accepted.\n   * @param account The account whose lockup is to be removed.\n   * @param expiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked and withdrawn as ETH.\n   */\n  function marketWithdrawLocked(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _removeFromLockedBalance(account, expiration, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(account, msg.sender, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from your account.\n   * @param to The address of the account which the tokens are transferred from.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds).\n   */\n  function transfer(address to, uint256 amount) external returns (bool success) {\n    return transferFrom(msg.sender, to, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from the account specified if themsg.senderhas approval.\n   * @param from The address from which the available tokens are transferred from.\n   * @param to The address to which the tokens are to be transferred.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds or not approved).\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public returns (bool success) {\n    if (to == address(0)) {\n      revert FETH_Transfer_To_Burn_Not_Allowed();\n    } else if (to == address(this)) {\n      revert FETH_Transfer_To_FETH_Not_Allowed();\n    }\n    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(fromAccountInfo, amount);\n    }\n    _deductBalanceFrom(fromAccountInfo, amount);\n    AccountInfo storage toAccountInfo = accountToInfo[to];\n\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      toAccountInfo.freedBalance += uint96(amount);\n    }\n\n    emit Transfer(from, to, amount);\n\n    return true;\n  }\n\n  /**\n   * @notice Withdraw all tokens available in your account and receive ETH.\n   */\n  function withdrawAvailableBalance() external {\n    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);\n    uint256 amount = accountInfo.freedBalance;\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    delete accountInfo.freedBalance;\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(msg.sender, msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw the specified number of tokens from thefromaccounts available balance\n   * and send ETH to the destination address, if themsg.senderhas approval.\n   * @param from The address from which the available funds are to be withdrawn.\n   * @param to The destination address for the ETH to be transferred to.\n   * @param amount The number of tokens to be withdrawn and transferred as ETH.\n   */\n  function withdrawFrom(\n    address from,\n    address payable to,\n    uint256 amount\n  ) external {\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(accountInfo, amount);\n    }\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    to.sendValue(amount);\n\n    emit ETHWithdrawn(from, to, amount);\n  }\n\n  /**\n   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.\n   */\n  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    if (accountInfo.allowance[msg.sender] != type(uint256).max) {\n      if (accountInfo.allowance[msg.sender] &lt; amount) {\n        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);\n      }\n      // The check above ensures allowance cannot underflow.\n      unchecked {\n        accountInfo.allowance[msg.sender] -= amount;\n      }\n    }\n  }\n\n  /**\n   * @dev Removes an amount from the account\'s available FETH balance.\n   */\n  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    // Free from escrow in order to consider any expired escrow balance\n    if (accountInfo.freedBalance &lt; amount) {\n      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\n    }\n    // The check above ensures balance cannot underflow.\n    unchecked {\n      accountInfo.freedBalance -= uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Moves expired escrow to the available balance.\n   */\n  function _freeFromEscrow(address account) private returns (AccountInfo storage) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required\n    if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {\n      return accountInfo;\n    }\n\n    while (true) {\n      // Total ETH cannot realistically overflow 96 bits.\n      unchecked {\n        accountInfo.freedBalance += escrow.totalAmount;\n        accountInfo.lockups.del(escrowIndex);\n        // Escrow index cannot overflow 32 bits.\n        escrow = accountInfo.lockups.get(escrowIndex + 1);\n      }\n\n      // If the next bucket is empty, the start index is set to the previous bucket\n      if (escrow.expiration == 0) {\n        break;\n      }\n\n      // Escrow index cannot overflow 32 bits.\n      unchecked {\n        // Increment the escrow start index if the next bucket is not empty\n        ++escrowIndex;\n      }\n\n      // If the next bucket is expired, that\'s the new start index\n      if (escrow.expiration &gt;= block.timestamp) {\n        break;\n      }\n    }\n\n    // Escrow index cannot overflow 32 bits.\n    unchecked {\n      accountInfo.lockupStartIndex = uint32(escrowIndex);\n    }\n    return accountInfo;\n  }\n\n  /**\n   * @notice Lockup an account\'s FETH tokens for 24-25 hours.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {\n    if (account == address(0)) {\n      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\n    }\n    if (amount == 0) {\n      revert FETH_Must_Lockup_Non_Zero_Amount();\n    }\n\n    // Block timestamp in seconds is small enough to never overflow\n    unchecked {\n      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours\n      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;\n    }\n\n    // Update available escrow\n    // Always free from escrow to ensure the max bucket count is &lt;= 25\n    AccountInfo storage accountInfo = _freeFromEscrow(account);\n    if (msg.value &lt; amount) {\n      // The check above prevents underflow with delta.\n      unchecked {\n        uint256 delta = amount - msg.value;\n        if (accountInfo.freedBalance &lt; delta) {\n          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\n        }\n        // The check above prevents underflow of freed balance.\n        accountInfo.freedBalance -= uint96(delta);\n      }\n    } else if (msg.value != amount) {\n      // There\'s no reason to send msg.value more than the amount being locked up\n      revert FETH_Too_Much_ETH_Provided();\n    }\n\n    // Add to locked escrow\n    unchecked {\n      // The number of buckets is always &lt; 256 bits.\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          if (expiration &gt; type(uint32).max) {\n            revert FETH_Expiration_Too_Far_In_Future();\n          }\n          // Amount (ETH) will always be &lt; 96 bits.\n          accountInfo.lockups.set(escrowIndex, expiration, amount);\n          break;\n        }\n        if (escrow.expiration == expiration) {\n          // Total ETH will always be &lt; 96 bits.\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);\n          break;\n        }\n      }\n    }\n\n    emit BalanceLocked(account, expiration, amount, msg.value);\n  }\n\n  /**\n   * @notice Remove an account\'s lockup, making the FETH tokens available for transfer or withdrawal.\n   */\n  function _marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private {\n    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Removes the specified amount from locked escrow, potentially before its expiration.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _removeFromLockedBalance(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private returns (AccountInfo storage) {\n    if (expiration &lt; block.timestamp) {\n      revert FETH_Escrow_Expired();\n    }\n\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    if (escrow.expiration == expiration) {\n      // If removing from the first bucket, we may be able to delete it\n      if (escrow.totalAmount == amount) {\n        accountInfo.lockups.del(escrowIndex);\n\n        // Bump the escrow start index unless it\'s the last one\n        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {\n          // The number of escrow buckets will never overflow 32 bits.\n          unchecked {\n            ++accountInfo.lockupStartIndex;\n          }\n        }\n      } else {\n        if (escrow.totalAmount &lt; amount) {\n          revert FETH_Insufficient_Escrow(escrow.totalAmount);\n        }\n        // The require above ensures balance will not underflow.\n        unchecked {\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n        }\n      }\n    } else {\n      // Removing from the 2nd+ bucket\n      while (true) {\n        // The number of escrow buckets will never overflow 32 bits.\n        unchecked {\n          ++escrowIndex;\n        }\n        escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == expiration) {\n          if (amount &gt; escrow.totalAmount) {\n            revert FETH_Insufficient_Escrow(escrow.totalAmount);\n          }\n          // The require above ensures balance will not underflow.\n          unchecked {\n            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n          }\n          // We may have an entry with 0 totalAmount but expiration will be set\n          break;\n        }\n        if (escrow.expiration == 0) {\n          revert FETH_Escrow_Not_Found();\n        }\n      }\n    }\n\n    emit BalanceUnlocked(account, expiration, amount);\n    return accountInfo;\n  }\n\n  /**\n   * @notice Returns the amount which a spender is still allowed to transact from theaccount\'s balance.\n   * @param account The owner of the funds.\n   * @param operator The address with approval to spend from theaccount\'s balance.\n   * @return amount The number of tokens theoperatoris still allowed to transact with.\n   */\n  function allowance(address account, address operator) external view returns (uint256 amount) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    return accountInfo.allowance[operator];\n  }\n\n  /**\n   * @notice Returns the balance of an account which is available to transfer or withdraw.\n   * @dev This will automatically increase as soon as locked tokens reach their expiry date.\n   * @param account The account to query the available balance of.\n   * @return balance The available balance of the account.\n   */\n  function balanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits.\n    unchecked {\n      // Add expired lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Gets the Foundation market address which has permissions to manage lockups.\n   * @return market The Foundation market contract address.\n   */\n  function getFoundationMarket() external view returns (address market) {\n    return foundationMarket;\n  }\n\n  /**\n   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.\n   * @devexpires.length==amounts.length\n   * andamounts[i]is the number of tokens which will expire atexpires[i].\n   * The results returned are sorted by expiry, with the earliest expiry date first.\n   * @param account The account to query the locked balance of.\n   * @return expiries The time at which each outstanding lockup bucket expires.\n   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.\n   */\n  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n\n    // Count lockups\n    uint256 lockedCount;\n    // The number of buckets is always &lt; 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {\n          // Lockup count will never overflow 256 bits.\n          ++lockedCount;\n        }\n      }\n    }\n\n    // Allocate arrays\n    expiries = new uint256[](lockedCount);\n    amounts = new uint256[](lockedCount);\n\n    // Populate results\n    uint256 i;\n    // The number of buckets is always &lt; 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {\n          expiries[i] = escrow.expiration;\n          amounts[i] = escrow.totalAmount;\n          ++i;\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total balance of an account, including locked FETH tokens.\n   * @dev UsebalanceOfto get the number of tokens available for transfer or withdrawal.\n   * @param account The account to query the total balance of.\n   * @return balance The total FETH balance tracked for this account.\n   */\n  function totalBalanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits.\n    unchecked {\n      // Add all lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total amount of ETH locked in this contract.\n   * @return supply The total amount of ETH locked in this contract.\n   */\n  function totalSupply() external view returns (uint256 supply) {\n    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct\n       but this is on-par with the WETH implementation and done for gas savings. */\n    return address(this).balance;\n  }\n}\n', 'ideas': "" Redundant Conditional Check Identified.\n\nVULNERABILITY NAME: Redundant Conditional Checks\n'''\nIn thedepositForfunction, there is a check formsg.value == 0which reverts withFETH_Must_Deposit_Non_Zero_Amount(). This check is redundant because thedepositfunction, which callsdepositFor, already ensures thatmsg.valueis non-zero when it is called. Therefore, the check indepositForis unnecessary and adds additional gas costs without providing any additional safety.\n\nTo mitigate this issue, you can remove the check formsg.value == 0in thedepositForfunction, as it is already guaranteed by the calling function.\n'''\n\nVULNERABILITY NAME: Redundant Conditional Checks\n'''\nIn the_marketLockupForfunction, there is a check formsg.value &lt; amountfollowed by a check formsg.value != amount. Ifmsg.valueis less thanamount, it is already implied thatmsg.valuecannot equalamount. Therefore, the second check is redundant and can be removed.\n\nTo mitigate this issue, you can simplify the logic by keeping only the check formsg.value &lt; amountand removing themsg.value != amount` check.\n'''""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-11-08 20:27:18 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol""; import ""@openzeppelin/contracts/utils/math/Math.sol""; import ""./libraries/LockedBalance.sol""; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = ""Foundation Wrapped Ether"";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = ""FETH""; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-11-08 20:27:18 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts/utils/math/Math.sol"";

import ""./libraries/LockedBalance.sol"";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = ""Foundation Wrapped Ether"";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = ""FETH"";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""/*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts/utils/math/Math.sol"";

import ""./libraries/LockedBalance.sol"";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = ""Foundation Wrapped Ether"";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = ""FETH"";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
"".
Ideas: "" Redundant Conditional Check Identified.

VULNERABILITY NAME: Redundant Conditional Checks
'''
In the `depositFor` function, there is a check for `msg.value == 0` which reverts with `FETH_Must_Deposit_Non_Zero_Amount()`. This check is redundant because the `deposit` function, which calls `depositFor`, already ensures that `msg.value` is non-zero when it is called. Therefore, the check in `depositFor` is unnecessary and adds additional gas costs without providing any additional safety.

To mitigate this issue, you can remove the check for `msg.value == 0` in the `depositFor` function, as it is already guaranteed by the calling function.
'''

VULNERABILITY NAME: Redundant Conditional Checks
'''
In the `_marketLockupFor` function, there is a check for `msg.value < amount` followed by a check for `msg.value != amount`. If `msg.value` is less than `amount`, it is already implied that `msg.value` cannot equal `amount`. Therefore, the second check is redundant and can be removed.

To mitigate this issue, you can simplify the logic by keeping only the check for `msg.value < amount` and removing the `msg.value != amount` check.
'''"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to External Oracle Dependency. There are two main concerns related to External Oracle Dependency vulnerabilities:
1. Dependence on a single external oracle for critical data, which pertains to the reliability of the data source. If the oracle is compromised, provides incorrect data, or becomes unavailable, the contract's functionalities could be adversely affected.
2. Lack of fallback mechanisms, which can lead to the contract failing if the external oracle call fails or returns invalid data. This could be exploited by adversaries to disrupt the contract's operations.
If you identify reliance on a single external oracle for critical data, respond with: """,,,"<INFO> Centralization Risk Identified.

```
Centralized Control via Single Address
'''
The contract has a modifier `onlyFoundationMarket` that restricts access to certain functions (e.g., `marketChangeLockup`, `marketLockupFor`, `marketUnlockFor`, `marketWithdrawFrom`, and `marketWithdrawLocked`) to a single address, `foundationMarket`. This centralizes control over critical operations related to managing lockups and withdrawals of funds. If the `foundationMarket` address is compromised, an attacker could potentially manipulate the lockup and withdrawal processes, leading to unauthorized access to user funds.

Recommended Mitigation:
1. Implement a multi-signature wallet for the `foundationMarket` address. This would require multiple parties to approve any critical operations, reducing the risk of a single point of failure.
2. Consider introducing a governance mechanism where stakeholders can vote on changes to critical parameters or the address of the `foundationMarket`, ensuring that control is distributed among multiple parties rather than centralized in one address.
'''
```

```
Lack of Decentralized Governance
'''
The contract lacks any form of decentralized governance or community involvement in decision-making processes. All critical functions are controlled by the `foundationMarket` address, which may not represent the interests of all stakeholders. This could lead to decisions that favor the controlling entity at the expense of users.

Recommended Mitigation:
1. Introduce a governance token that allows users to participate in decision-making processes, such as changing the `foundationMarket` address or modifying critical parameters of the contract.
2. Implement a voting mechanism where stakeholders can propose and vote on changes, ensuring that the contract evolves in a way that reflects the interests of its users.
'''
```

[2024-11-08 20:27:29 INFO] **[Execute Detail]**

execute SimplePhase:[FundingCalculationDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-11-08 20:27:29 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol""; import ""@openzeppelin/contracts/utils/math/Math.sol""; import ""./libraries/LockedBalance.sol""; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = ""Foundation Wrapped Ether"";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = ""FETH""; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Funding Rate Calculation Precision. There are two cases where the code may have Funding Rate Calculation Precision vulnerabilities: 1. Simplistic funding rate calculation that does not consider all necessary factors. This can lead to incorrect funding rates, which can be manipulated by providing incorrect input values. A robust funding rate calculation should account for various factors and validations to prevent exploitation. 2. Lack of input validation for critical parameters (e.g., spotPrice, markPrice) used in the funding rate calculation. Malicious actors could potentially manipulate these parameters to influence the funding rate calculation. If you identify a Simplistic funding rate calculation or Lack of input validation, respond with: "" Incorrect Funding Rate Calculation Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If you don't find any vulnerabilities, respond only with: "" NO Incorrect Funding Rate Calculation."" |
| **phase_name** | FundingCalculationDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '/\n  ･\n   \u3000★\n      ･ ｡\n        \u3000･\u3000ﾟ☆ ｡\n  \u3000\u3000\u3000 \u3000★ ﾟ･｡ *  ｡\n          \u3000\u3000 ☆ ｡･ﾟ.｡\n      \u3000\u3000\u3000ﾟ .｡☆｡★\u3000･\n\u200b\n                      .-:::::-.              -::---...```\n-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy\n-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo\n                                              ``\n   *\u3000\n      ･ ｡\n\u3000\u3000\u3000\u3000･\u3000\u3000ﾟ☆ ｡\n  \u3000\u3000\u3000 *\u3000★ ﾟ･｡ *  ｡\n          \u3000\u3000* ☆ ｡･ﾟ*.｡\n      \u3000\u3000\u3000ﾟ *.｡☆｡★\u3000･\n    *\u3000\u3000ﾟ｡·*･｡ ﾟ*\n  \u3000\u3000\u3000☆ﾟ･｡°*. ﾟ\n\u3000 ･ ﾟ*｡･ﾟ★｡\n\u3000\u3000･ *ﾟ｡\u3000\u3000 *\n\u3000･ﾟ*｡★･\n ☆∴｡\u3000*\n･ ｡\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";\nimport ""@openzeppelin/contracts/utils/math/Math.sol"";\n\nimport ""./libraries/LockedBalance.sol"";\n\nerror FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\nerror FETH_Escrow_Expired();\nerror FETH_Escrow_Not_Found();\nerror FETH_Expiration_Too_Far_In_Future();\n/// @param amount The current allowed amount the spender is authorized to transact for this account.\nerror FETH_Insufficient_Allowance(uint256 amount);\n/// @param amount The current available (unlocked) token count of this account.\nerror FETH_Insufficient_Available_Funds(uint256 amount);\n/// @param amount The current number of tokens this account has for the given lockup expiry bucket.\nerror FETH_Insufficient_Escrow(uint256 amount);\nerror FETH_Invalid_Lockup_Duration();\nerror FETH_Market_Must_Be_A_Contract();\nerror FETH_Must_Deposit_Non_Zero_Amount();\nerror FETH_Must_Lockup_Non_Zero_Amount();\nerror FETH_No_Funds_To_Withdraw();\nerror FETH_Only_FND_Market_Allowed();\nerror FETH_Too_Much_ETH_Provided();\nerror FETH_Transfer_To_Burn_Not_Allowed();\nerror FETH_Transfer_To_FETH_Not_Allowed();\n\n/**\n * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.\n * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after\n * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).\n * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be\n * transferred or withdrawn, except by our market contract which requested the lockup in the first place.\n * @dev Locked balances are rounded up to the next hour.\n * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".\n * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.\n */\ncontract FETH {\n  using AddressUpgradeable for address payable;\n  using LockedBalance for LockedBalance.Lockups;\n  using Math for uint256;\n\n  /// @notice Tracks an account\'s info.\n  struct AccountInfo {\n    /// @notice The number of tokens which have been unlocked already.\n    uint96 freedBalance;\n    /// @notice The first applicable lockup bucket for this account.\n    uint32 lockupStartIndex;\n    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.\n    LockedBalance.Lockups lockups;\n    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.\n    mapping(address =&gt; uint256) allowance;\n  }\n\n  /// @notice Stores per-account details.\n  mapping(address =&gt; AccountInfo) private accountToInfo;\n\n  // Lockup configuration\n  /// @notice The minimum lockup period in seconds.\n  uint256 private immutable lockupDuration;\n  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.\n  uint256 private immutable lockupInterval;\n\n  /// @notice The Foundation market contract with permissions to manage lockups.\n  address payable private immutable foundationMarket;\n\n  // ERC-20 metadata fields\n  /**\n   * @notice The number of decimals the token uses.\n   * @dev This method can be used to improve usability when displaying token amounts, but all interactions\n   * with this contract use whole amounts not considering decimals.\n   * @return 18\n   */\n  uint8 public constant decimals = 18;\n  /**\n   * @notice The name of the token.\n   * @return Foundation Wrapped Ether\n   */\n  string public constant name = ""Foundation Wrapped Ether"";\n  /**\n   * @notice The symbol of the token.\n   * @return FETH\n   */\n  string public constant symbol = ""FETH"";\n\n  // ERC-20 events\n  /**\n   * @notice Emitted when the allowance for a spender account is updated.\n   * @param from The account the spender is authorized to transact for.\n   * @param spender The account with permissions to manage FETH tokens for the `from` account.\n   * @param amount The max amount of tokens which can be spent by the `spender` account.\n   */\n  event Approval(address indexed from, address indexed spender, uint256 amount);\n  /**\n   * @notice Emitted when a transfer of FETH tokens is made from one account to another.\n   * @param from The account which is sending FETH tokens.\n   * @param to The account which is receiving FETH tokens.\n   * @param amount The number of FETH tokens which were sent.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  // Custom events\n  /**\n   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours\n   * and may include newly deposited ETH which is added to the account\'s total FETH balance.\n   * @param account The account which has access to the FETH after the `expiration`.\n   * @param expiration The time at which the `from` account will have access to the locked FETH.\n   * @param amount The number of FETH tokens which where locked up.\n   * @param valueDeposited The amount of ETH added to their account\'s total FETH balance,\n   * this may be lower than `amount` if available FETH was leveraged.\n   */\n  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);\n  /**\n   * @notice Emitted when FETH tokens are unlocked by the Foundation market.\n   * @dev This event will not be emitted when lockups expire,\n   * it\'s only for tokens which are unlocked before their expiry.\n   * @param account The account which had locked FETH freed before expiration.\n   * @param expiration The time this balance was originally scheduled to be unlocked.\n   * @param amount The number of FETH tokens which were unlocked.\n   */\n  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);\n  /**\n   * @notice Emitted when ETH is withdrawn from a user\'s account.\n   * @dev This may be triggered by the user, an approved operator, or the Foundation market.\n   * @param from The account from which FETH was deducted in order to send the ETH.\n   * @param to The address the ETH was sent to.\n   * @param amount The number of tokens which were deducted from the user\'s FETH balance and transferred as ETH.\n   */\n  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);\n\n  /// @dev Allows the Foundation market permission to manage lockups for a user.\n  modifier onlyFoundationMarket() {\n    if (msg.sender != foundationMarket) {\n      revert FETH_Only_FND_Market_Allowed();\n    }\n    _;\n  }\n\n  /**\n   * @notice Initializes variables which may differ on testnet.\n   * @param _foundationMarket The address of the Foundation NFT marketplace.\n   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.\n   */\n  constructor(address payable _foundationMarket, uint256 _lockupDuration) {\n    if (!_foundationMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    foundationMarket = _foundationMarket;\n    lockupDuration = _lockupDuration;\n    lockupInterval = _lockupDuration / 24;\n    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {\n      revert FETH_Invalid_Lockup_Duration();\n    }\n  }\n\n  /**\n   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user\'s account.\n   */\n  receive() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Approves a `spender` as an operator with permissions to transfer from your account.\n   * @param spender The address of the operator account that has approval to spend funds\n   * from the `msg.sender`\'s account.\n   * @param amount The max number of FETH tokens from `msg.sender`\'s account that this spender is\n   * allowed to transact with.\n   * @return success Always true.\n   */\n  function approve(address spender, uint256 amount) external returns (bool success) {\n    accountToInfo[msg.sender].allowance[spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   */\n  function deposit() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   * @dev This may be used by the Foundation market to credit a user\'s account with FETH tokens.\n   * @param account The account to credit with FETH tokens.\n   */\n  function depositFor(address account) public payable {\n    if (msg.value == 0) {\n      revert FETH_Must_Deposit_Non_Zero_Amount();\n    }\n    AccountInfo storage accountInfo = accountToInfo[account];\n    // ETH value cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(msg.value);\n    }\n    emit Transfer(address(0), account, msg.value);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account\'s lockup and then create a new lockup, potentially for a different account.\n   * @dev Used by the market when an offer for an NFT is increased.\n   * This may be for a single account (increasing their offer)\n   * or two different accounts (outbidding someone elses offer).\n   * @param unlockFrom The account whose lockup is to be removed.\n   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`\'s account.\n   * This will revert if the tokens were previously unlocked.\n   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`\'s account.\n   * `msg.value` must be &lt;= `lockupAmount` and any delta will be taken from the account\'s available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketChangeLockup(\n    address unlockFrom,\n    uint256 unlockExpiration,\n    uint256 unlockAmount,\n    address lockupFor,\n    uint256 lockupAmount\n  ) external payable onlyFoundationMarket returns (uint256 expiration) {\n    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);\n    return _marketLockupFor(lockupFor, lockupAmount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Lockup an account\'s FETH tokens for 24-25 hours.\n   * @dev Used by the market when a new offer for an NFT is made.\n   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\n   * @param amount The number of tokens to be locked up for the `lockupFor`\'s account.\n   * `msg.value` must be &lt;= `amount` and any delta will be taken from the account\'s available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketLockupFor(address account, uint256 amount)\n    external\n    payable\n    onlyFoundationMarket\n    returns (uint256 expiration)\n  {\n    return _marketLockupFor(account, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account\'s lockup, making the FETH tokens available for transfer or withdrawal.\n   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT\n   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.\n   * @param account The account whose lockup is to be unlocked.\n   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked from `account`.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _marketUnlockFor(account, expiration, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes tokens from the user\'s available balance and returns ETH to the caller.\n   * @dev Used by the market when a user\'s available FETH balance is used to make a purchase\n   * including accepting a buy price or a private sale, or placing a bid in an auction.\n   * @param from The account whose available balance is to be withdrawn from.\n   * @param amount The number of tokens to be deducted from `unlockFrom`\'s available balance and transferred as ETH.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(from, msg.sender, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes a lockup from the user\'s account and then returns ETH to the caller.\n   * @dev Used by the market to extract unexpired funds as ETH to distribute for\n   * a sale when the user\'s offer is accepted.\n   * @param account The account whose lockup is to be removed.\n   * @param expiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked and withdrawn as ETH.\n   */\n  function marketWithdrawLocked(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _removeFromLockedBalance(account, expiration, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(account, msg.sender, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from your account.\n   * @param to The address of the account which the tokens are transferred from.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds).\n   */\n  function transfer(address to, uint256 amount) external returns (bool success) {\n    return transferFrom(msg.sender, to, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.\n   * @param from The address from which the available tokens are transferred from.\n   * @param to The address to which the tokens are to be transferred.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds or not approved).\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public returns (bool success) {\n    if (to == address(0)) {\n      revert FETH_Transfer_To_Burn_Not_Allowed();\n    } else if (to == address(this)) {\n      revert FETH_Transfer_To_FETH_Not_Allowed();\n    }\n    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(fromAccountInfo, amount);\n    }\n    _deductBalanceFrom(fromAccountInfo, amount);\n    AccountInfo storage toAccountInfo = accountToInfo[to];\n\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      toAccountInfo.freedBalance += uint96(amount);\n    }\n\n    emit Transfer(from, to, amount);\n\n    return true;\n  }\n\n  /**\n   * @notice Withdraw all tokens available in your account and receive ETH.\n   */\n  function withdrawAvailableBalance() external {\n    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);\n    uint256 amount = accountInfo.freedBalance;\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    delete accountInfo.freedBalance;\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(msg.sender, msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw the specified number of tokens from the `from` accounts available balance\n   * and send ETH to the destination address, if the `msg.sender` has approval.\n   * @param from The address from which the available funds are to be withdrawn.\n   * @param to The destination address for the ETH to be transferred to.\n   * @param amount The number of tokens to be withdrawn and transferred as ETH.\n   */\n  function withdrawFrom(\n    address from,\n    address payable to,\n    uint256 amount\n  ) external {\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(accountInfo, amount);\n    }\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    to.sendValue(amount);\n\n    emit ETHWithdrawn(from, to, amount);\n  }\n\n  /**\n   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.\n   */\n  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    if (accountInfo.allowance[msg.sender] != type(uint256).max) {\n      if (accountInfo.allowance[msg.sender] &lt; amount) {\n        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);\n      }\n      // The check above ensures allowance cannot underflow.\n      unchecked {\n        accountInfo.allowance[msg.sender] -= amount;\n      }\n    }\n  }\n\n  /**\n   * @dev Removes an amount from the account\'s available FETH balance.\n   */\n  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    // Free from escrow in order to consider any expired escrow balance\n    if (accountInfo.freedBalance &lt; amount) {\n      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\n    }\n    // The check above ensures balance cannot underflow.\n    unchecked {\n      accountInfo.freedBalance -= uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Moves expired escrow to the available balance.\n   */\n  function _freeFromEscrow(address account) private returns (AccountInfo storage) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required\n    if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {\n      return accountInfo;\n    }\n\n    while (true) {\n      // Total ETH cannot realistically overflow 96 bits.\n      unchecked {\n        accountInfo.freedBalance += escrow.totalAmount;\n        accountInfo.lockups.del(escrowIndex);\n        // Escrow index cannot overflow 32 bits.\n        escrow = accountInfo.lockups.get(escrowIndex + 1);\n      }\n\n      // If the next bucket is empty, the start index is set to the previous bucket\n      if (escrow.expiration == 0) {\n        break;\n      }\n\n      // Escrow index cannot overflow 32 bits.\n      unchecked {\n        // Increment the escrow start index if the next bucket is not empty\n        ++escrowIndex;\n      }\n\n      // If the next bucket is expired, that\'s the new start index\n      if (escrow.expiration &gt;= block.timestamp) {\n        break;\n      }\n    }\n\n    // Escrow index cannot overflow 32 bits.\n    unchecked {\n      accountInfo.lockupStartIndex = uint32(escrowIndex);\n    }\n    return accountInfo;\n  }\n\n  /**\n   * @notice Lockup an account\'s FETH tokens for 24-25 hours.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {\n    if (account == address(0)) {\n      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\n    }\n    if (amount == 0) {\n      revert FETH_Must_Lockup_Non_Zero_Amount();\n    }\n\n    // Block timestamp in seconds is small enough to never overflow\n    unchecked {\n      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours\n      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;\n    }\n\n    // Update available escrow\n    // Always free from escrow to ensure the max bucket count is &lt;= 25\n    AccountInfo storage accountInfo = _freeFromEscrow(account);\n    if (msg.value &lt; amount) {\n      // The check above prevents underflow with delta.\n      unchecked {\n        uint256 delta = amount - msg.value;\n        if (accountInfo.freedBalance &lt; delta) {\n          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\n        }\n        // The check above prevents underflow of freed balance.\n        accountInfo.freedBalance -= uint96(delta);\n      }\n    } else if (msg.value != amount) {\n      // There\'s no reason to send msg.value more than the amount being locked up\n      revert FETH_Too_Much_ETH_Provided();\n    }\n\n    // Add to locked escrow\n    unchecked {\n      // The number of buckets is always &lt; 256 bits.\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          if (expiration &gt; type(uint32).max) {\n            revert FETH_Expiration_Too_Far_In_Future();\n          }\n          // Amount (ETH) will always be &lt; 96 bits.\n          accountInfo.lockups.set(escrowIndex, expiration, amount);\n          break;\n        }\n        if (escrow.expiration == expiration) {\n          // Total ETH will always be &lt; 96 bits.\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);\n          break;\n        }\n      }\n    }\n\n    emit BalanceLocked(account, expiration, amount, msg.value);\n  }\n\n  /**\n   * @notice Remove an account\'s lockup, making the FETH tokens available for transfer or withdrawal.\n   */\n  function _marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private {\n    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Removes the specified amount from locked escrow, potentially before its expiration.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _removeFromLockedBalance(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private returns (AccountInfo storage) {\n    if (expiration &lt; block.timestamp) {\n      revert FETH_Escrow_Expired();\n    }\n\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    if (escrow.expiration == expiration) {\n      // If removing from the first bucket, we may be able to delete it\n      if (escrow.totalAmount == amount) {\n        accountInfo.lockups.del(escrowIndex);\n\n        // Bump the escrow start index unless it\'s the last one\n        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {\n          // The number of escrow buckets will never overflow 32 bits.\n          unchecked {\n            ++accountInfo.lockupStartIndex;\n          }\n        }\n      } else {\n        if (escrow.totalAmount &lt; amount) {\n          revert FETH_Insufficient_Escrow(escrow.totalAmount);\n        }\n        // The require above ensures balance will not underflow.\n        unchecked {\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n        }\n      }\n    } else {\n      // Removing from the 2nd+ bucket\n      while (true) {\n        // The number of escrow buckets will never overflow 32 bits.\n        unchecked {\n          ++escrowIndex;\n        }\n        escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == expiration) {\n          if (amount &gt; escrow.totalAmount) {\n            revert FETH_Insufficient_Escrow(escrow.totalAmount);\n          }\n          // The require above ensures balance will not underflow.\n          unchecked {\n            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n          }\n          // We may have an entry with 0 totalAmount but expiration will be set\n          break;\n        }\n        if (escrow.expiration == 0) {\n          revert FETH_Escrow_Not_Found();\n        }\n      }\n    }\n\n    emit BalanceUnlocked(account, expiration, amount);\n    return accountInfo;\n  }\n\n  /**\n   * @notice Returns the amount which a spender is still allowed to transact from the `account`\'s balance.\n   * @param account The owner of the funds.\n   * @param operator The address with approval to spend from the `account`\'s balance.\n   * @return amount The number of tokens the `operator` is still allowed to transact with.\n   */\n  function allowance(address account, address operator) external view returns (uint256 amount) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    return accountInfo.allowance[operator];\n  }\n\n  /**\n   * @notice Returns the balance of an account which is available to transfer or withdraw.\n   * @dev This will automatically increase as soon as locked tokens reach their expiry date.\n   * @param account The account to query the available balance of.\n   * @return balance The available balance of the account.\n   */\n  function balanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits.\n    unchecked {\n      // Add expired lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Gets the Foundation market address which has permissions to manage lockups.\n   * @return market The Foundation market contract address.\n   */\n  function getFoundationMarket() external view returns (address market) {\n    return foundationMarket;\n  }\n\n  /**\n   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.\n   * @dev `expires.length` == `amounts.length`\n   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.\n   * The results returned are sorted by expiry, with the earliest expiry date first.\n   * @param account The account to query the locked balance of.\n   * @return expiries The time at which each outstanding lockup bucket expires.\n   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.\n   */\n  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n\n    // Count lockups\n    uint256 lockedCount;\n    // The number of buckets is always &lt; 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {\n          // Lockup count will never overflow 256 bits.\n          ++lockedCount;\n        }\n      }\n    }\n\n    // Allocate arrays\n    expiries = new uint256[](lockedCount);\n    amounts = new uint256[](lockedCount);\n\n    // Populate results\n    uint256 i;\n    // The number of buckets is always &lt; 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {\n          expiries[i] = escrow.expiration;\n          amounts[i] = escrow.totalAmount;\n          ++i;\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total balance of an account, including locked FETH tokens.\n   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.\n   * @param account The account to query the total balance of.\n   * @return balance The total FETH balance tracked for this account.\n   */\n  function totalBalanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits.\n    unchecked {\n      // Add all lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total amount of ETH locked in this contract.\n   * @return supply The total amount of ETH locked in this contract.\n   */\n  function totalSupply() external view returns (uint256 supply) {\n    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct\n       but this is on-par with the WETH implementation and done for gas savings. */\n    return address(this).balance;\n  }\n}\n', 'ideas': "" Centralization Risk Identified.\n\n\nCentralized Control via Single Address\n'''\nThe contract has a modifier onlyFoundationMarket that restricts access to certain functions (e.g., marketChangeLockup, marketLockupFor, marketUnlockFor, marketWithdrawFrom, and marketWithdrawLocked) to a single address, foundationMarket. This centralizes control over critical operations related to managing lockups and withdrawals of funds. If the foundationMarket address is compromised, an attacker could potentially manipulate the lockup and withdrawal processes, leading to unauthorized access to user funds.\n\nRecommended Mitigation:\n1. Implement a multi-signature wallet for the foundationMarket address. This would require multiple parties to approve any critical operations, reducing the risk of a single point of failure.\n2. Consider introducing a governance mechanism where stakeholders can vote on changes to critical parameters or the address of the foundationMarket, ensuring that control is distributed among multiple parties rather than centralized in one address.\n'''\n\n\n\nLack of Decentralized Governance\n'''\nThe contract lacks any form of decentralized governance or community involvement in decision-making processes. All critical functions are controlled by the foundationMarket address, which may not represent the interests of all stakeholders. This could lead to decisions that favor the controlling entity at the expense of users.\n\nRecommended Mitigation:\n1. Introduce a governance token that allows users to participate in decision-making processes, such as changing the foundationMarket address or modifying critical parameters of the contract.\n2. Implement a voting mechanism where stakeholders can propose and vote on changes, ensuring that the contract evolves in a way that reflects the interests of its users.\n'''\n```""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-11-08 20:27:29 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol""; import ""@openzeppelin/contracts/utils/math/Math.sol""; import ""./libraries/LockedBalance.sol""; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = ""Foundation Wrapped Ether"";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = ""FETH""; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-11-08 20:27:29 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts/utils/math/Math.sol"";

import ""./libraries/LockedBalance.sol"";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = ""Foundation Wrapped Ether"";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = ""FETH"";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""/*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts/utils/math/Math.sol"";

import ""./libraries/LockedBalance.sol"";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = ""Foundation Wrapped Ether"";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = ""FETH"";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
"".
Ideas: "" Centralization Risk Identified.

```
Centralized Control via Single Address
'''
The contract has a modifier `onlyFoundationMarket` that restricts access to certain functions (e.g., `marketChangeLockup`, `marketLockupFor`, `marketUnlockFor`, `marketWithdrawFrom`, and `marketWithdrawLocked`) to a single address, `foundationMarket`. This centralizes control over critical operations related to managing lockups and withdrawals of funds. If the `foundationMarket` address is compromised, an attacker could potentially manipulate the lockup and withdrawal processes, leading to unauthorized access to user funds.

Recommended Mitigation:
1. Implement a multi-signature wallet for the `foundationMarket` address. This would require multiple parties to approve any critical operations, reducing the risk of a single point of failure.
2. Consider introducing a governance mechanism where stakeholders can vote on changes to critical parameters or the address of the `foundationMarket`, ensuring that control is distributed among multiple parties rather than centralized in one address.
'''
```

```
Lack of Decentralized Governance
'''
The contract lacks any form of decentralized governance or community involvement in decision-making processes. All critical functions are controlled by the `foundationMarket` address, which may not represent the interests of all stakeholders. This could lead to decisions that favor the controlling entity at the expense of users.

Recommended Mitigation:
1. Introduce a governance token that allows users to participate in decision-making processes, such as changing the `foundationMarket` address or modifying critical parameters of the contract.
2. Implement a voting mechanism where stakeholders can propose and vote on changes, ensuring that the contract evolves in a way that reflects the interests of its users.
'''
```"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Funding Rate Calculation Precision. There are two cases where the code may have Funding Rate Calculation Precision vulnerabilities:
1. Simplistic funding rate calculation that does not consider all necessary factors. This can lead to incorrect funding rates, which can be manipulated by providing incorrect input values. A robust funding rate calculation should account for various factors and validations to prevent exploitation.
2. Lack of input validation for critical parameters (e.g., spotPrice, markPrice) used in the funding rate calculation. Malicious actors could potentially manipulate these parameters to influence the funding rate calculation.
If you identify a Simplistic funding rate calculation or Lack of input validation, respond with: """,,,,,,,,,,,,,,,"<INFO> Lack of Input Validation Identified.

**VULNERABILITY NAME or TYPE**
'''
1. **Zero Address Validation**
   The function `_marketLockupFor` does not properly validate the `account` parameter. If the `account` is set to the zero address (address(0)), it will revert with a specific error, but this check should be more robust to prevent any unintended behavior before the function proceeds with further logic. The zero address should not be allowed to be passed as a valid account for locking up tokens.

   **Recommended Mitigation/Fix:**
   Ensure that the zero address check is performed at the beginning of the function to avoid any further processing if an invalid address is provided. This is already implemented, but it should be emphasized that all functions that accept addresses should include this validation.

2. **Lockup Amount Validation**
   In the `_marketLockupFor` function, while there is a check for `amount == 0`, it is crucial to ensure that the amount being locked up does not exceed the user's available balance. If a user attempts to lock up an amount greater than their available balance, it will revert, but this could lead to confusion or unexpected behavior if not handled gracefully.

   **Recommended Mitigation/Fix:**
   Before proceeding with the lockup logic, explicitly check that the `amount` is less than or equal to the user's available balance. This will provide clearer feedback to the user and prevent unnecessary state changes.

3. **Allowance Validation**
   In the `_deductAllowanceFrom` function, while there is a check for the allowance being less than the required amount, it allows for unlimited approval (using `type(uint256).max`). This can lead to potential abuse if a malicious contract is approved to spend tokens without proper checks.

   **Recommended Mitigation/Fix:**
   Implement a mechanism to limit the maximum allowance that can be set, or require explicit checks on the allowance before allowing transfers. This will prevent scenarios where a malicious actor could exploit unlimited approvals.

4. **Escrow Expiration Validation**
   In the `_removeFromLockedBalance` function, while there is a check for the expiration of the escrow, there is no validation to ensure that the `amount` being removed does not exceed the total amount locked in that escrow bucket. This could lead to unexpected behavior if the wrong amount is specified.

   **Recommended Mitigation/Fix:**
   Before attempting to remove an amount from the locked balance, validate that the `amount` is less than or equal to the `totalAmount` in the escrow bucket. This will prevent attempts to unlock more tokens than are actually locked.

5. **General Input Validation**
   Several functions, such as `withdrawFrom`, do not validate that the `to` address is not the zero address before proceeding with the transfer. This could lead to tokens being sent to an invalid address.

   **Recommended Mitigation/Fix:**
   Implement checks at the beginning of functions that involve transfers to ensure that the `to` address is not the zero address and is a valid address. This will help prevent accidental loss of tokens.
'''

[2024-11-08 20:28:18 INFO] **[Execute Detail]**

execute SimplePhase:[DoSDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-11-08 20:28:18 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol""; import ""@openzeppelin/contracts/utils/math/Math.sol""; import ""./libraries/LockedBalance.sol""; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = ""Foundation Wrapped Ether"";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = ""FETH""; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""Identify all potential DoS (Denial of Service) vulnerabilities in the provided Solidity smart contract."". Ideas: ""DoS vulnerabilities can manifest in various forms in Solidity contracts, such as Gas Limit DoS, External Call DoS, Block Gas Limit DoS, and State Dependency DoS."". As the {assistant_role}, your primary objective is to conduct a comprehensive inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Denial of Service (DoS). DoS vulnerabilities can occur in the following cases: 1. When loops have an unbounded iteration count, leading to potential gas exhaustion. 2. When the contract makes external calls that can fail or consume excessive gas. 3. When the contract depends on certain state conditions that can be manipulated by an attacker to cause failures. 4. When an attacker can send high-gas transactions to consume most of the block's gas limit, making it difficult for other transactions to be included in the block. Please conduct a thorough analysis, considering the following information: 1. Review the contract's code logic to identify any potential areas where unbounded loops might cause gas exhaustion. 2. Examine external calls in the contract and ensure they are handled properly to avoid excessive gas consumption or failures. 3. Analyze state-dependent logic to identify any potential manipulations that could cause DoS. 4. Consider the overall design of the contract to ensure it is resilient against high-gas transactions and other DoS tactics. If you identify any DoS vulnerabilities, respond with: "" DoS Vulnerability Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades. ''' If you don't find any vulnerabilities, respond only with: "" No DoS Vulnerabilities."" |
| **phase_name** | DoSDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '/\n  ･\n   \u3000★\n      ･ ｡\n        \u3000･\u3000ﾟ☆ ｡\n  \u3000\u3000\u3000 \u3000★ ﾟ･｡ *  ｡\n          \u3000\u3000 ☆ ｡･ﾟ.｡\n      \u3000\u3000\u3000ﾟ .｡☆｡★\u3000･\n\u200b\n                      .-:::::-.              -::---...```\n-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:\n                    .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy\n-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\n------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo\n                                              ````\n   *\u3000\n      ･ ｡\n\u3000\u3000\u3000\u3000･\u3000\u3000ﾟ☆ ｡\n  \u3000\u3000\u3000 *\u3000★ ﾟ･｡ *  ｡\n          \u3000\u3000* ☆ ｡･ﾟ*.｡\n      \u3000\u3000\u3000ﾟ *.｡☆｡★\u3000･\n    *\u3000\u3000ﾟ｡·*･｡ ﾟ*\n  \u3000\u3000\u3000☆ﾟ･｡°*. ﾟ\n\u3000 ･ ﾟ*｡･ﾟ★｡\n\u3000\u3000･ *ﾟ｡\u3000\u3000 *\n\u3000･ﾟ*｡★･\n ☆∴｡\u3000*\n･ ｡\n*/\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";\nimport ""@openzeppelin/contracts/utils/math/Math.sol"";\n\nimport ""./libraries/LockedBalance.sol"";\n\nerror FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\nerror FETH_Escrow_Expired();\nerror FETH_Escrow_Not_Found();\nerror FETH_Expiration_Too_Far_In_Future();\n/// @param amount The current allowed amount the spender is authorized to transact for this account.\nerror FETH_Insufficient_Allowance(uint256 amount);\n/// @param amount The current available (unlocked) token count of this account.\nerror FETH_Insufficient_Available_Funds(uint256 amount);\n/// @param amount The current number of tokens this account has for the given lockup expiry bucket.\nerror FETH_Insufficient_Escrow(uint256 amount);\nerror FETH_Invalid_Lockup_Duration();\nerror FETH_Market_Must_Be_A_Contract();\nerror FETH_Must_Deposit_Non_Zero_Amount();\nerror FETH_Must_Lockup_Non_Zero_Amount();\nerror FETH_No_Funds_To_Withdraw();\nerror FETH_Only_FND_Market_Allowed();\nerror FETH_Too_Much_ETH_Provided();\nerror FETH_Transfer_To_Burn_Not_Allowed();\nerror FETH_Transfer_To_FETH_Not_Allowed();\n\n/**\n * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.\n * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after\n * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).\n * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be\n * transferred or withdrawn, except by our market contract which requested the lockup in the first place.\n * @dev Locked balances are rounded up to the next hour.\n * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".\n * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.\n */\ncontract FETH {\n  using AddressUpgradeable for address payable;\n  using LockedBalance for LockedBalance.Lockups;\n  using Math for uint256;\n\n  /// @notice Tracks an account\'s info.\n  struct AccountInfo {\n    /// @notice The number of tokens which have been unlocked already.\n    uint96 freedBalance;\n    /// @notice The first applicable lockup bucket for this account.\n    uint32 lockupStartIndex;\n    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.\n    LockedBalance.Lockups lockups;\n    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.\n    mapping(address =&gt; uint256) allowance;\n  }\n\n  /// @notice Stores per-account details.\n  mapping(address =&gt; AccountInfo) private accountToInfo;\n\n  // Lockup configuration\n  /// @notice The minimum lockup period in seconds.\n  uint256 private immutable lockupDuration;\n  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.\n  uint256 private immutable lockupInterval;\n\n  /// @notice The Foundation market contract with permissions to manage lockups.\n  address payable private immutable foundationMarket;\n\n  // ERC-20 metadata fields\n  /**\n   * @notice The number of decimals the token uses.\n   * @dev This method can be used to improve usability when displaying token amounts, but all interactions\n   * with this contract use whole amounts not considering decimals.\n   * @return 18\n   */\n  uint8 public constant decimals = 18;\n  /**\n   * @notice The name of the token.\n   * @return Foundation Wrapped Ether\n   */\n  string public constant name = ""Foundation Wrapped Ether"";\n  /**\n   * @notice The symbol of the token.\n   * @return FETH\n   */\n  string public constant symbol = ""FETH"";\n\n  // ERC-20 events\n  /**\n   * @notice Emitted when the allowance for a spender account is updated.\n   * @param from The account the spender is authorized to transact for.\n   * @param spender The account with permissions to manage FETH tokens for thefromaccount.\n   * @param amount The max amount of tokens which can be spent by thespenderaccount.\n   */\n  event Approval(address indexed from, address indexed spender, uint256 amount);\n  /**\n   * @notice Emitted when a transfer of FETH tokens is made from one account to another.\n   * @param from The account which is sending FETH tokens.\n   * @param to The account which is receiving FETH tokens.\n   * @param amount The number of FETH tokens which were sent.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  // Custom events\n  /**\n   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours\n   * and may include newly deposited ETH which is added to the account\'s total FETH balance.\n   * @param account The account which has access to the FETH after theexpiration.\n   * @param expiration The time at which thefromaccount will have access to the locked FETH.\n   * @param amount The number of FETH tokens which where locked up.\n   * @param valueDeposited The amount of ETH added to their account\'s total FETH balance,\n   * this may be lower thanamountif available FETH was leveraged.\n   */\n  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);\n  /**\n   * @notice Emitted when FETH tokens are unlocked by the Foundation market.\n   * @dev This event will not be emitted when lockups expire,\n   * it\'s only for tokens which are unlocked before their expiry.\n   * @param account The account which had locked FETH freed before expiration.\n   * @param expiration The time this balance was originally scheduled to be unlocked.\n   * @param amount The number of FETH tokens which were unlocked.\n   */\n  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);\n  /**\n   * @notice Emitted when ETH is withdrawn from a user\'s account.\n   * @dev This may be triggered by the user, an approved operator, or the Foundation market.\n   * @param from The account from which FETH was deducted in order to send the ETH.\n   * @param to The address the ETH was sent to.\n   * @param amount The number of tokens which were deducted from the user\'s FETH balance and transferred as ETH.\n   */\n  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);\n\n  /// @dev Allows the Foundation market permission to manage lockups for a user.\n  modifier onlyFoundationMarket() {\n    if (msg.sender != foundationMarket) {\n      revert FETH_Only_FND_Market_Allowed();\n    }\n    _;\n  }\n\n  /**\n   * @notice Initializes variables which may differ on testnet.\n   * @param _foundationMarket The address of the Foundation NFT marketplace.\n   * @param _lockupDuration The minimum length of time to lockup tokens for whenBalanceLocked, in seconds.\n   */\n  constructor(address payable _foundationMarket, uint256 _lockupDuration) {\n    if (!_foundationMarket.isContract()) {\n      revert FETH_Market_Must_Be_A_Contract();\n    }\n    foundationMarket = _foundationMarket;\n    lockupDuration = _lockupDuration;\n    lockupInterval = _lockupDuration / 24;\n    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {\n      revert FETH_Invalid_Lockup_Duration();\n    }\n  }\n\n  /**\n   * @notice Transferring ETH (viamsg.value) to the contract performs adepositinto the user\'s account.\n   */\n  receive() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Approves aspenderas an operator with permissions to transfer from your account.\n   * @param spender The address of the operator account that has approval to spend funds\n   * from themsg.sender\'s account.\n   * @param amount The max number of FETH tokens frommsg.sender\'s account that this spender is\n   * allowed to transact with.\n   * @return success Always true.\n   */\n  function approve(address spender, uint256 amount) external returns (bool success) {\n    accountToInfo[msg.sender].allowance[spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Deposit ETH (viamsg.value) and receive the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   */\n  function deposit() external payable {\n    depositFor(msg.sender);\n  }\n\n  /**\n   * @notice Deposit ETH (viamsg.value) and credit theaccountprovided with the equivalent amount in FETH tokens.\n   * These tokens are not subject to any lockup period.\n   * @dev This may be used by the Foundation market to credit a user\'s account with FETH tokens.\n   * @param account The account to credit with FETH tokens.\n   */\n  function depositFor(address account) public payable {\n    if (msg.value == 0) {\n      revert FETH_Must_Deposit_Non_Zero_Amount();\n    }\n    AccountInfo storage accountInfo = accountToInfo[account];\n    // ETH value cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(msg.value);\n    }\n    emit Transfer(address(0), account, msg.value);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account\'s lockup and then create a new lockup, potentially for a different account.\n   * @dev Used by the market when an offer for an NFT is increased.\n   * This may be for a single account (increasing their offer)\n   * or two different accounts (outbidding someone elses offer).\n   * @param unlockFrom The account whose lockup is to be removed.\n   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param unlockAmount The number of tokens to be unlocked fromunlockFrom\'s account.\n   * This will revert if the tokens were previously unlocked.\n   * @param lockupFor The account to which the funds are to be deposited for (via themsg.value) and tokens locked up.\n   * @param lockupAmount The number of tokens to be locked up for thelockupFor\'s account.\n   *msg.valuemust be &lt;=lockupAmountand any delta will be taken from the account\'s available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketChangeLockup(\n    address unlockFrom,\n    uint256 unlockExpiration,\n    uint256 unlockAmount,\n    address lockupFor,\n    uint256 lockupAmount\n  ) external payable onlyFoundationMarket returns (uint256 expiration) {\n    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);\n    return _marketLockupFor(lockupFor, lockupAmount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Lockup an account\'s FETH tokens for 24-25 hours.\n   * @dev Used by the market when a new offer for an NFT is made.\n   * @param account The account to which the funds are to be deposited for (via themsg.value) and tokens locked up.\n   * @param amount The number of tokens to be locked up for thelockupFor\'s account.\n   *msg.valuemust be &lt;=amountand any delta will be taken from the account\'s available FETH balance.\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\n   */\n  function marketLockupFor(address account, uint256 amount)\n    external\n    payable\n    onlyFoundationMarket\n    returns (uint256 expiration)\n  {\n    return _marketLockupFor(account, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Remove an account\'s lockup, making the FETH tokens available for transfer or withdrawal.\n   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT\n   * receives its first bid or the buyer purchased the NFT another way, such as withbuy.\n   * @param account The account whose lockup is to be unlocked.\n   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked fromaccount.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _marketUnlockFor(account, expiration, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes tokens from the user\'s available balance and returns ETH to the caller.\n   * @dev Used by the market when a user\'s available FETH balance is used to make a purchase\n   * including accepting a buy price or a private sale, or placing a bid in an auction.\n   * @param from The account whose available balance is to be withdrawn from.\n   * @param amount The number of tokens to be deducted fromunlockFrom\'s available balance and transferred as ETH.\n   * This will revert if the tokens were previously unlocked.\n   */\n  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(from, msg.sender, amount);\n  }\n\n  /**\n   * @notice Used by the market contract only:\n   * Removes a lockup from the user\'s account and then returns ETH to the caller.\n   * @dev Used by the market to extract unexpired funds as ETH to distribute for\n   * a sale when the user\'s offer is accepted.\n   * @param account The account whose lockup is to be removed.\n   * @param expiration The original lockup expiration for the tokens to be unlocked.\n   * This will revert if the lockup has already expired.\n   * @param amount The number of tokens to be unlocked and withdrawn as ETH.\n   */\n  function marketWithdrawLocked(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) external onlyFoundationMarket {\n    _removeFromLockedBalance(account, expiration, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(account, msg.sender, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from your account.\n   * @param to The address of the account which the tokens are transferred from.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds).\n   */\n  function transfer(address to, uint256 amount) external returns (bool success) {\n    return transferFrom(msg.sender, to, amount);\n  }\n\n  /**\n   * @notice Transfers an amount from the account specified if themsg.senderhas approval.\n   * @param from The address from which the available tokens are transferred from.\n   * @param to The address to which the tokens are to be transferred.\n   * @param amount The number of FETH tokens to be transferred.\n   * @return success Always true (reverts if insufficient funds or not approved).\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public returns (bool success) {\n    if (to == address(0)) {\n      revert FETH_Transfer_To_Burn_Not_Allowed();\n    } else if (to == address(this)) {\n      revert FETH_Transfer_To_FETH_Not_Allowed();\n    }\n    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(fromAccountInfo, amount);\n    }\n    _deductBalanceFrom(fromAccountInfo, amount);\n    AccountInfo storage toAccountInfo = accountToInfo[to];\n\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      toAccountInfo.freedBalance += uint96(amount);\n    }\n\n    emit Transfer(from, to, amount);\n\n    return true;\n  }\n\n  /**\n   * @notice Withdraw all tokens available in your account and receive ETH.\n   */\n  function withdrawAvailableBalance() external {\n    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);\n    uint256 amount = accountInfo.freedBalance;\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    delete accountInfo.freedBalance;\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    payable(msg.sender).sendValue(amount);\n\n    emit ETHWithdrawn(msg.sender, msg.sender, amount);\n  }\n\n  /**\n   * @notice Withdraw the specified number of tokens from thefromaccounts available balance\n   * and send ETH to the destination address, if themsg.senderhas approval.\n   * @param from The address from which the available funds are to be withdrawn.\n   * @param to The destination address for the ETH to be transferred to.\n   * @param amount The number of tokens to be withdrawn and transferred as ETH.\n   */\n  function withdrawFrom(\n    address from,\n    address payable to,\n    uint256 amount\n  ) external {\n    if (amount == 0) {\n      revert FETH_No_Funds_To_Withdraw();\n    }\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\n    if (from != msg.sender) {\n      _deductAllowanceFrom(accountInfo, amount);\n    }\n    _deductBalanceFrom(accountInfo, amount);\n\n    // With the external call after state changes, we do not need a nonReentrant guard\n    to.sendValue(amount);\n\n    emit ETHWithdrawn(from, to, amount);\n  }\n\n  /**\n   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.\n   */\n  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    if (accountInfo.allowance[msg.sender] != type(uint256).max) {\n      if (accountInfo.allowance[msg.sender] &lt; amount) {\n        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);\n      }\n      // The check above ensures allowance cannot underflow.\n      unchecked {\n        accountInfo.allowance[msg.sender] -= amount;\n      }\n    }\n  }\n\n  /**\n   * @dev Removes an amount from the account\'s available FETH balance.\n   */\n  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\n    // Free from escrow in order to consider any expired escrow balance\n    if (accountInfo.freedBalance &lt; amount) {\n      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\n    }\n    // The check above ensures balance cannot underflow.\n    unchecked {\n      accountInfo.freedBalance -= uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Moves expired escrow to the available balance.\n   */\n  function _freeFromEscrow(address account) private returns (AccountInfo storage) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required\n    if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {\n      return accountInfo;\n    }\n\n    while (true) {\n      // Total ETH cannot realistically overflow 96 bits.\n      unchecked {\n        accountInfo.freedBalance += escrow.totalAmount;\n        accountInfo.lockups.del(escrowIndex);\n        // Escrow index cannot overflow 32 bits.\n        escrow = accountInfo.lockups.get(escrowIndex + 1);\n      }\n\n      // If the next bucket is empty, the start index is set to the previous bucket\n      if (escrow.expiration == 0) {\n        break;\n      }\n\n      // Escrow index cannot overflow 32 bits.\n      unchecked {\n        // Increment the escrow start index if the next bucket is not empty\n        ++escrowIndex;\n      }\n\n      // If the next bucket is expired, that\'s the new start index\n      if (escrow.expiration &gt;= block.timestamp) {\n        break;\n      }\n    }\n\n    // Escrow index cannot overflow 32 bits.\n    unchecked {\n      accountInfo.lockupStartIndex = uint32(escrowIndex);\n    }\n    return accountInfo;\n  }\n\n  /**\n   * @notice Lockup an account\'s FETH tokens for 24-25 hours.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {\n    if (account == address(0)) {\n      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\n    }\n    if (amount == 0) {\n      revert FETH_Must_Lockup_Non_Zero_Amount();\n    }\n\n    // Block timestamp in seconds is small enough to never overflow\n    unchecked {\n      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours\n      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;\n    }\n\n    // Update available escrow\n    // Always free from escrow to ensure the max bucket count is &lt;= 25\n    AccountInfo storage accountInfo = _freeFromEscrow(account);\n    if (msg.value &lt; amount) {\n      // The check above prevents underflow with delta.\n      unchecked {\n        uint256 delta = amount - msg.value;\n        if (accountInfo.freedBalance &lt; delta) {\n          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\n        }\n        // The check above prevents underflow of freed balance.\n        accountInfo.freedBalance -= uint96(delta);\n      }\n    } else if (msg.value != amount) {\n      // There\'s no reason to send msg.value more than the amount being locked up\n      revert FETH_Too_Much_ETH_Provided();\n    }\n\n    // Add to locked escrow\n    unchecked {\n      // The number of buckets is always &lt; 256 bits.\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          if (expiration &gt; type(uint32).max) {\n            revert FETH_Expiration_Too_Far_In_Future();\n          }\n          // Amount (ETH) will always be &lt; 96 bits.\n          accountInfo.lockups.set(escrowIndex, expiration, amount);\n          break;\n        }\n        if (escrow.expiration == expiration) {\n          // Total ETH will always be &lt; 96 bits.\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);\n          break;\n        }\n      }\n    }\n\n    emit BalanceLocked(account, expiration, amount, msg.value);\n  }\n\n  /**\n   * @notice Remove an account\'s lockup, making the FETH tokens available for transfer or withdrawal.\n   */\n  function _marketUnlockFor(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private {\n    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);\n    // Total ETH cannot realistically overflow 96 bits.\n    unchecked {\n      accountInfo.freedBalance += uint96(amount);\n    }\n  }\n\n  /**\n   * @dev Removes the specified amount from locked escrow, potentially before its expiration.\n   */\n  /* solhint-disable-next-line code-complexity */\n  function _removeFromLockedBalance(\n    address account,\n    uint256 expiration,\n    uint256 amount\n  ) private returns (AccountInfo storage) {\n    if (expiration &lt; block.timestamp) {\n      revert FETH_Escrow_Expired();\n    }\n\n    AccountInfo storage accountInfo = accountToInfo[account];\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n\n    if (escrow.expiration == expiration) {\n      // If removing from the first bucket, we may be able to delete it\n      if (escrow.totalAmount == amount) {\n        accountInfo.lockups.del(escrowIndex);\n\n        // Bump the escrow start index unless it\'s the last one\n        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {\n          // The number of escrow buckets will never overflow 32 bits.\n          unchecked {\n            ++accountInfo.lockupStartIndex;\n          }\n        }\n      } else {\n        if (escrow.totalAmount &lt; amount) {\n          revert FETH_Insufficient_Escrow(escrow.totalAmount);\n        }\n        // The require above ensures balance will not underflow.\n        unchecked {\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n        }\n      }\n    } else {\n      // Removing from the 2nd+ bucket\n      while (true) {\n        // The number of escrow buckets will never overflow 32 bits.\n        unchecked {\n          ++escrowIndex;\n        }\n        escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == expiration) {\n          if (amount &gt; escrow.totalAmount) {\n            revert FETH_Insufficient_Escrow(escrow.totalAmount);\n          }\n          // The require above ensures balance will not underflow.\n          unchecked {\n            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\n          }\n          // We may have an entry with 0 totalAmount but expiration will be set\n          break;\n        }\n        if (escrow.expiration == 0) {\n          revert FETH_Escrow_Not_Found();\n        }\n      }\n    }\n\n    emit BalanceUnlocked(account, expiration, amount);\n    return accountInfo;\n  }\n\n  /**\n   * @notice Returns the amount which a spender is still allowed to transact from theaccount\'s balance.\n   * @param account The owner of the funds.\n   * @param operator The address with approval to spend from theaccount\'s balance.\n   * @return amount The number of tokens theoperatoris still allowed to transact with.\n   */\n  function allowance(address account, address operator) external view returns (uint256 amount) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    return accountInfo.allowance[operator];\n  }\n\n  /**\n   * @notice Returns the balance of an account which is available to transfer or withdraw.\n   * @dev This will automatically increase as soon as locked tokens reach their expiry date.\n   * @param account The account to query the available balance of.\n   * @return balance The available balance of the account.\n   */\n  function balanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits.\n    unchecked {\n      // Add expired lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Gets the Foundation market address which has permissions to manage lockups.\n   * @return market The Foundation market contract address.\n   */\n  function getFoundationMarket() external view returns (address market) {\n    return foundationMarket;\n  }\n\n  /**\n   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.\n   * @devexpires.length==amounts.length\n   * andamounts[i]is the number of tokens which will expire atexpires[i].\n   * The results returned are sorted by expiry, with the earliest expiry date first.\n   * @param account The account to query the locked balance of.\n   * @return expiries The time at which each outstanding lockup bucket expires.\n   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.\n   */\n  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n\n    // Count lockups\n    uint256 lockedCount;\n    // The number of buckets is always &lt; 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {\n          // Lockup count will never overflow 256 bits.\n          ++lockedCount;\n        }\n      }\n    }\n\n    // Allocate arrays\n    expiries = new uint256[](lockedCount);\n    amounts = new uint256[](lockedCount);\n\n    // Populate results\n    uint256 i;\n    // The number of buckets is always &lt; 256 bits.\n    unchecked {\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {\n          expiries[i] = escrow.expiration;\n          amounts[i] = escrow.totalAmount;\n          ++i;\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total balance of an account, including locked FETH tokens.\n   * @dev UsebalanceOfto get the number of tokens available for transfer or withdrawal.\n   * @param account The account to query the total balance of.\n   * @return balance The total FETH balance tracked for this account.\n   */\n  function totalBalanceOf(address account) external view returns (uint256 balance) {\n    AccountInfo storage accountInfo = accountToInfo[account];\n    balance = accountInfo.freedBalance;\n\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits.\n    unchecked {\n      // Add all lockups\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\n        if (escrow.expiration == 0) {\n          break;\n        }\n        balance += escrow.totalAmount;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the total amount of ETH locked in this contract.\n   * @return supply The total amount of ETH locked in this contract.\n   */\n  function totalSupply() external view returns (uint256 supply) {\n    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct\n       but this is on-par with the WETH implementation and done for gas savings. */\n    return address(this).balance;\n  }\n}\n', 'ideas': "" Lack of Input Validation Identified.\n\n**VULNERABILITY NAME or TYPE**\n'''\n1. **Zero Address Validation**\n   The function_marketLockupFordoes not properly validate theaccountparameter. If theaccountis set to the zero address (address(0)), it will revert with a specific error, but this check should be more robust to prevent any unintended behavior before the function proceeds with further logic. The zero address should not be allowed to be passed as a valid account for locking up tokens.\n\n   **Recommended Mitigation/Fix:**\n   Ensure that the zero address check is performed at the beginning of the function to avoid any further processing if an invalid address is provided. This is already implemented, but it should be emphasized that all functions that accept addresses should include this validation.\n\n2. **Lockup Amount Validation**\n   In the_marketLockupForfunction, while there is a check foramount == 0, it is crucial to ensure that the amount being locked up does not exceed the user's available balance. If a user attempts to lock up an amount greater than their available balance, it will revert, but this could lead to confusion or unexpected behavior if not handled gracefully.\n\n   **Recommended Mitigation/Fix:**\n   Before proceeding with the lockup logic, explicitly check that theamountis less than or equal to the user's available balance. This will provide clearer feedback to the user and prevent unnecessary state changes.\n\n3. **Allowance Validation**\n   In the_deductAllowanceFromfunction, while there is a check for the allowance being less than the required amount, it allows for unlimited approval (usingtype(uint256).max). This can lead to potential abuse if a malicious contract is approved to spend tokens without proper checks.\n\n   **Recommended Mitigation/Fix:**\n   Implement a mechanism to limit the maximum allowance that can be set, or require explicit checks on the allowance before allowing transfers. This will prevent scenarios where a malicious actor could exploit unlimited approvals.\n\n4. **Escrow Expiration Validation**\n   In the_removeFromLockedBalancefunction, while there is a check for the expiration of the escrow, there is no validation to ensure that theamountbeing removed does not exceed the total amount locked in that escrow bucket. This could lead to unexpected behavior if the wrong amount is specified.\n\n   **Recommended Mitigation/Fix:**\n   Before attempting to remove an amount from the locked balance, validate that theamountis less than or equal to thetotalAmountin the escrow bucket. This will prevent attempts to unlock more tokens than are actually locked.\n\n5. **General Input Validation**\n   Several functions, such aswithdrawFrom, do not validate that thetoaddress is not the zero address before proceeding with the transfer. This could lead to tokens being sent to an invalid address.\n\n   **Recommended Mitigation/Fix:**\n   Implement checks at the beginning of functions that involve transfers to ensure that theto` address is not the zero address and is a valid address. This will help prevent accidental loss of tokens.\n'''""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-11-08 20:28:18 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | /   ･    *　★       ･ ｡         　･　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･ ​                       .-:::::-.              -::---...```-:.:+ssssoooo++//:.       .-/+shhhhhhhhhhhhhyyyssooo:                     .--::.            .+ossso+/////++/:://-.////+shhhhhhhhhhhhhhhhhhhhhy-----::.         /+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy------:::-//-..-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy                 .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy               `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy              .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy             .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy           `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy          .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo      .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...hhhhyo                                               `````    *　       ･ ｡ 　　　　･　　ﾟ☆ ｡   　　　 *　★ ﾟ･｡ *  ｡           　　* ☆ ｡･ﾟ.｡       　　　ﾟ .｡☆｡★　･     *　　ﾟ｡·･｡ ﾟ   　　　☆ﾟ･｡°. ﾟ 　 ･ ﾟ｡･ﾟ★｡ 　　･ ﾟ｡　　 * 　･ﾟ｡★･  ☆∴｡　* ･ ｡ / // SPDX-License-Identifier: MIT OR Apache-2.0 pragma solidity ^0.8.0; import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol""; import ""@openzeppelin/contracts/utils/math/Math.sol""; import ""./libraries/LockedBalance.sol""; error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero(); error FETH_Escrow_Expired(); error FETH_Escrow_Not_Found(); error FETH_Expiration_Too_Far_In_Future(); /// @param amount The current allowed amount the spender is authorized to transact for this account. error FETH_Insufficient_Allowance(uint256 amount); /// @param amount The current available (unlocked) token count of this account. error FETH_Insufficient_Available_Funds(uint256 amount); /// @param amount The current number of tokens this account has for the given lockup expiry bucket. error FETH_Insufficient_Escrow(uint256 amount); error FETH_Invalid_Lockup_Duration(); error FETH_Market_Must_Be_A_Contract(); error FETH_Must_Deposit_Non_Zero_Amount(); error FETH_Must_Lockup_Non_Zero_Amount(); error FETH_No_Funds_To_Withdraw(); error FETH_Only_FND_Market_Allowed(); error FETH_Too_Much_ETH_Provided(); error FETH_Transfer_To_Burn_Not_Allowed(); error FETH_Transfer_To_FETH_Not_Allowed(); /*  * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.  * @notice FETH is an ERC-20 token modeled after  * WETH9.  * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be  * transferred or withdrawn, except by our market contract which requested the lockup in the first place.  * @dev Locked balances are rounded up to the next hour.  * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".  * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.  / contract FETH {   using AddressUpgradeable for address payable;   using LockedBalance for LockedBalance.Lockups;   using Math for uint256; /// @notice Tracks an account's info.   struct AccountInfo {     /// @notice The number of tokens which have been unlocked already.     uint96 freedBalance;     /// @notice The first applicable lockup bucket for this account.     uint32 lockupStartIndex;     /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.     LockedBalance.Lockups lockups;     /// @notice Returns the amount which a spender is still allowed to withdraw from this account.     mapping(address =&gt; uint256) allowance;   } /// @notice Stores per-account details.   mapping(address =&gt; AccountInfo) private accountToInfo; // Lockup configuration   /// @notice The minimum lockup period in seconds.   uint256 private immutable lockupDuration;   /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.   uint256 private immutable lockupInterval; /// @notice The Foundation market contract with permissions to manage lockups.   address payable private immutable foundationMarket; // ERC-20 metadata fields   /    * @notice The number of decimals the token uses.    * @dev This method can be used to improve usability when displaying token amounts, but all interactions    * with this contract use whole amounts not considering decimals.    * @return 18    */   uint8 public constant decimals = 18;   /    * @notice The name of the token.    * @return Foundation Wrapped Ether    /   string public constant name = ""Foundation Wrapped Ether"";   /    * @notice The symbol of the token.    * @return FETH    /   string public constant symbol = ""FETH""; // ERC-20 events   /    * @notice Emitted when the allowance for a spender account is updated.    * @param from The account the spender is authorized to transact for.    * @param spender The account with permissions to manage FETH tokens for the from account.    * @param amount The max amount of tokens which can be spent by the spender account.    */   event Approval(address indexed from, address indexed spender, uint256 amount);   /    * @notice Emitted when a transfer of FETH tokens is made from one account to another.    * @param from The account which is sending FETH tokens.    * @param to The account which is receiving FETH tokens.    * @param amount The number of FETH tokens which were sent.    */   event Transfer(address indexed from, address indexed to, uint256 amount); // Custom events   /    * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours    * and may include newly deposited ETH which is added to the account's total FETH balance.    * @param account The account which has access to the FETH after the expiration.    * @param expiration The time at which the from account will have access to the locked FETH.    * @param amount The number of FETH tokens which where locked up.    * @param valueDeposited The amount of ETH added to their account's total FETH balance,    * this may be lower than amount if available FETH was leveraged.    */   event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);   /    * @notice Emitted when FETH tokens are unlocked by the Foundation market.    * @dev This event will not be emitted when lockups expire,    * it's only for tokens which are unlocked before their expiry.    * @param account The account which had locked FETH freed before expiration.    * @param expiration The time this balance was originally scheduled to be unlocked.    * @param amount The number of FETH tokens which were unlocked.    /   event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);   /    * @notice Emitted when ETH is withdrawn from a user's account.    * @dev This may be triggered by the user, an approved operator, or the Foundation market.    * @param from The account from which FETH was deducted in order to send the ETH.    * @param to The address the ETH was sent to.    * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.    /   event ETHWithdrawn(address indexed from, address indexed to, uint256 amount); /// @dev Allows the Foundation market permission to manage lockups for a user.   modifier onlyFoundationMarket() {     if (msg.sender != foundationMarket) {       revert FETH_Only_FND_Market_Allowed();     }     _;   } /*    * @notice Initializes variables which may differ on testnet.    * @param _foundationMarket The address of the Foundation NFT marketplace.    * @param _lockupDuration The minimum length of time to lockup tokens for when BalanceLocked, in seconds.    /   constructor(address payable _foundationMarket, uint256 _lockupDuration) {     if (!_foundationMarket.isContract()) {       revert FETH_Market_Must_Be_A_Contract();     }     foundationMarket = _foundationMarket;     lockupDuration = _lockupDuration;     lockupInterval = _lockupDuration / 24;     if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {       revert FETH_Invalid_Lockup_Duration();     }   } /*    * @notice Transferring ETH (via msg.value) to the contract performs a deposit into the user's account.    /   receive() external payable {     depositFor(msg.sender);   } /*    * @notice Approves a spender as an operator with permissions to transfer from your account.    * @param spender The address of the operator account that has approval to spend funds    * from the msg.sender's account.    * @param amount The max number of FETH tokens from msg.sender's account that this spender is    * allowed to transact with.    * @return success Always true.    /   function approve(address spender, uint256 amount) external returns (bool success) {     accountToInfo[msg.sender].allowance[spender] = amount;     emit Approval(msg.sender, spender, amount);     return true;   } /*    * @notice Deposit ETH (via msg.value) and receive the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    /   function deposit() external payable {     depositFor(msg.sender);   } /*    * @notice Deposit ETH (via msg.value) and credit the account provided with the equivalent amount in FETH tokens.    * These tokens are not subject to any lockup period.    * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.    * @param account The account to credit with FETH tokens.    /   function depositFor(address account) public payable {     if (msg.value == 0) {       revert FETH_Must_Deposit_Non_Zero_Amount();     }     AccountInfo storage accountInfo = accountToInfo[account];     // ETH value cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(msg.value);     }     emit Transfer(address(0), account, msg.value);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup and then create a new lockup, potentially for a different account.    * @dev Used by the market when an offer for an NFT is increased.    * This may be for a single account (increasing their offer)    * or two different accounts (outbidding someone elses offer).    * @param unlockFrom The account whose lockup is to be removed.    * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param unlockAmount The number of tokens to be unlocked from unlockFrom's account.    * This will revert if the tokens were previously unlocked.    * @param lockupFor The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param lockupAmount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= lockupAmount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketChangeLockup(     address unlockFrom,     uint256 unlockExpiration,     uint256 unlockAmount,     address lockupFor,     uint256 lockupAmount   ) external payable onlyFoundationMarket returns (uint256 expiration) {     _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);     return _marketLockupFor(lockupFor, lockupAmount);   } /*    * @notice Used by the market contract only:    * Lockup an account's FETH tokens for 24-25 hours.    * @dev Used by the market when a new offer for an NFT is made.    * @param account The account to which the funds are to be deposited for (via the msg.value) and tokens locked up.    * @param amount The number of tokens to be locked up for the lockupFor's account.    * msg.value must be &lt;= amount and any delta will be taken from the account's available FETH balance.    * @return expiration The expiration timestamp for the FETH tokens that were locked.    /   function marketLockupFor(address account, uint256 amount)     external     payable     onlyFoundationMarket     returns (uint256 expiration)   {     return _marketLockupFor(account, amount);   } /*    * @notice Used by the market contract only:    * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT    * receives its first bid or the buyer purchased the NFT another way, such as with buy.    * @param account The account whose lockup is to be unlocked.    * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked from account.    * This will revert if the tokens were previously unlocked.    /   function marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _marketUnlockFor(account, expiration, amount);   } /*    * @notice Used by the market contract only:    * Removes tokens from the user's available balance and returns ETH to the caller.    * @dev Used by the market when a user's available FETH balance is used to make a purchase    * including accepting a buy price or a private sale, or placing a bid in an auction.    * @param from The account whose available balance is to be withdrawn from.    * @param amount The number of tokens to be deducted from unlockFrom's available balance and transferred as ETH.    * This will revert if the tokens were previously unlocked.    /   function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {     AccountInfo storage accountInfo = _freeFromEscrow(from);     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(from, msg.sender, amount);  } /*    * @notice Used by the market contract only:    * Removes a lockup from the user's account and then returns ETH to the caller.    * @dev Used by the market to extract unexpired funds as ETH to distribute for    * a sale when the user's offer is accepted.    * @param account The account whose lockup is to be removed.    * @param expiration The original lockup expiration for the tokens to be unlocked.    * This will revert if the lockup has already expired.    * @param amount The number of tokens to be unlocked and withdrawn as ETH.    /   function marketWithdrawLocked(     address account,     uint256 expiration,     uint256 amount   ) external onlyFoundationMarket {     _removeFromLockedBalance(account, expiration, amount); // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(account, msg.sender, amount);  } /*    * @notice Transfers an amount from your account.    * @param to The address of the account which the tokens are transferred from.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds).    /   function transfer(address to, uint256 amount) external returns (bool success) {     return transferFrom(msg.sender, to, amount);   } /*    * @notice Transfers an amount from the account specified if the msg.sender has approval.    * @param from The address from which the available tokens are transferred from.    * @param to The address to which the tokens are to be transferred.    * @param amount The number of FETH tokens to be transferred.    * @return success Always true (reverts if insufficient funds or not approved).    /   function transferFrom(     address from,     address to,     uint256 amount   ) public returns (bool success) {     if (to == address(0)) {       revert FETH_Transfer_To_Burn_Not_Allowed();     } else if (to == address(this)) {       revert FETH_Transfer_To_FETH_Not_Allowed();     }     AccountInfo storage fromAccountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(fromAccountInfo, amount);     }     _deductBalanceFrom(fromAccountInfo, amount);     AccountInfo storage toAccountInfo = accountToInfo[to]; // Total ETH cannot realistically overflow 96 bits. unchecked {   toAccountInfo.freedBalance += uint96(amount); }  emit Transfer(from, to, amount);  return true;  } /*    * @notice Withdraw all tokens available in your account and receive ETH.    /   function withdrawAvailableBalance() external {     AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);     uint256 amount = accountInfo.freedBalance;     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     delete accountInfo.freedBalance; // With the external call after state changes, we do not need a nonReentrant guard payable(msg.sender).sendValue(amount);  emit ETHWithdrawn(msg.sender, msg.sender, amount);  } /*    * @notice Withdraw the specified number of tokens from the from accounts available balance    * and send ETH to the destination address, if the msg.sender has approval.    * @param from The address from which the available funds are to be withdrawn.    * @param to The destination address for the ETH to be transferred to.    * @param amount The number of tokens to be withdrawn and transferred as ETH.    /   function withdrawFrom(     address from,     address payable to,     uint256 amount   ) external {     if (amount == 0) {       revert FETH_No_Funds_To_Withdraw();     }     AccountInfo storage accountInfo = _freeFromEscrow(from);     if (from != msg.sender) {       _deductAllowanceFrom(accountInfo, amount);     }     _deductBalanceFrom(accountInfo, amount); // With the external call after state changes, we do not need a nonReentrant guard to.sendValue(amount);  emit ETHWithdrawn(from, to, amount);  } /*    * @dev Require msg.sender has been approved and deducts the amount from the available allowance.    /   function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     if (accountInfo.allowance[msg.sender] != type(uint256).max) {       if (accountInfo.allowance[msg.sender] &lt; amount) {         revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);       }       // The check above ensures allowance cannot underflow.       unchecked {         accountInfo.allowance[msg.sender] -= amount;       }     }   } /*    * @dev Removes an amount from the account's available FETH balance.    /   function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {     // Free from escrow in order to consider any expired escrow balance     if (accountInfo.freedBalance &lt; amount) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above ensures balance cannot underflow.     unchecked {       accountInfo.freedBalance -= uint96(amount);     }   } /*    * @dev Moves expired escrow to the available balance.    /   function _freeFromEscrow(address account) private returns (AccountInfo storage) {     AccountInfo storage accountInfo = accountToInfo[account];     uint256 escrowIndex = accountInfo.lockupStartIndex;     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex); // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {   return accountInfo; }  while (true) {   // Total ETH cannot realistically overflow 96 bits.   unchecked {     accountInfo.freedBalance += escrow.totalAmount;     accountInfo.lockups.del(escrowIndex);     // Escrow index cannot overflow 32 bits.     escrow = accountInfo.lockups.get(escrowIndex + 1);   }    // If the next bucket is empty, the start index is set to the previous bucket   if (escrow.expiration == 0) {     break;   }    // Escrow index cannot overflow 32 bits.   unchecked {     // Increment the escrow start index if the next bucket is not empty     ++escrowIndex;   }    // If the next bucket is expired, that's the new start index   if (escrow.expiration &gt;= block.timestamp) {     break;   } }  // Escrow index cannot overflow 32 bits. unchecked {   accountInfo.lockupStartIndex = uint32(escrowIndex); } return accountInfo;  } /    * @notice Lockup an account's FETH tokens for 24-25 hours.    /   / solhint-disable-next-line code-complexity */   function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {     if (account == address(0)) {       revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();     }     if (amount == 0) {       revert FETH_Must_Lockup_Non_Zero_Amount();     } // Block timestamp in seconds is small enough to never overflow unchecked {   // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours   expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval; }  // Update available escrow // Always free from escrow to ensure the max bucket count is &lt;= 25 AccountInfo storage accountInfo = _freeFromEscrow(account); if (msg.value &lt; amount) {   // The check above prevents underflow with delta.   unchecked {     uint256 delta = amount - msg.value;     if (accountInfo.freedBalance &lt; delta) {       revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);     }     // The check above prevents underflow of freed balance.     accountInfo.freedBalance -= uint96(delta);   } } else if (msg.value != amount) {   // There's no reason to send msg.value more than the amount being locked up   revert FETH_Too_Much_ETH_Provided(); }  // Add to locked escrow unchecked {   // The number of buckets is always &lt; 256 bits.   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       if (expiration &gt; type(uint32).max) {         revert FETH_Expiration_Too_Far_In_Future();       }       // Amount (ETH) will always be &lt; 96 bits.       accountInfo.lockups.set(escrowIndex, expiration, amount);       break;     }     if (escrow.expiration == expiration) {       // Total ETH will always be &lt; 96 bits.       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);       break;     }   } }  emit BalanceLocked(account, expiration, amount, msg.value);  } /*    * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.    /   function _marketUnlockFor(     address account,     uint256 expiration,     uint256 amount   ) private {     AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);     // Total ETH cannot realistically overflow 96 bits.     unchecked {       accountInfo.freedBalance += uint96(amount);     }   } /    * @dev Removes the specified amount from locked escrow, potentially before its expiration.    /   / solhint-disable-next-line code-complexity */   function _removeFromLockedBalance(     address account,     uint256 expiration,     uint256 amount   ) private returns (AccountInfo storage) {     if (expiration &lt; block.timestamp) {       revert FETH_Escrow_Expired();     } AccountInfo storage accountInfo = accountToInfo[account]; uint256 escrowIndex = accountInfo.lockupStartIndex; LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);  if (escrow.expiration == expiration) {   // If removing from the first bucket, we may be able to delete it   if (escrow.totalAmount == amount) {     accountInfo.lockups.del(escrowIndex);      // Bump the escrow start index unless it's the last one     if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {       // The number of escrow buckets will never overflow 32 bits.       unchecked {         ++accountInfo.lockupStartIndex;       }     }   } else {     if (escrow.totalAmount &lt; amount) {       revert FETH_Insufficient_Escrow(escrow.totalAmount);     }     // The require above ensures balance will not underflow.     unchecked {       accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);     }   } } else {   // Removing from the 2nd+ bucket   while (true) {     // The number of escrow buckets will never overflow 32 bits.     unchecked {       ++escrowIndex;     }     escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == expiration) {       if (amount &gt; escrow.totalAmount) {         revert FETH_Insufficient_Escrow(escrow.totalAmount);       }       // The require above ensures balance will not underflow.       unchecked {         accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);       }       // We may have an entry with 0 totalAmount but expiration will be set       break;     }     if (escrow.expiration == 0) {       revert FETH_Escrow_Not_Found();     }   } }  emit BalanceUnlocked(account, expiration, amount); return accountInfo;  } /*    * @notice Returns the amount which a spender is still allowed to transact from the account's balance.    * @param account The owner of the funds.    * @param operator The address with approval to spend from the account's balance.    * @return amount The number of tokens the operator is still allowed to transact with.    /   function allowance(address account, address operator) external view returns (uint256 amount) {     AccountInfo storage accountInfo = accountToInfo[account];     return accountInfo.allowance[operator];   } /*    * @notice Returns the balance of an account which is available to transfer or withdraw.    * @dev This will automatically increase as soon as locked tokens reach their expiry date.    * @param account The account to query the available balance of.    * @return balance The available balance of the account.    /   function balanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add expired lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0 || escrow.expiration &gt;= block.timestamp) {       break;     }     balance += escrow.totalAmount;   } }  } /*    * @notice Gets the Foundation market address which has permissions to manage lockups.    * @return market The Foundation market contract address.    /   function getFoundationMarket() external view returns (address market) {     return foundationMarket;   } /*    * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.    * @dev expires.length == amounts.length    * and amounts[i] is the number of tokens which will expire at expires[i].    * The results returned are sorted by expiry, with the earliest expiry date first.    * @param account The account to query the locked balance of.    * @return expiries The time at which each outstanding lockup bucket expires.    * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.    /   function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {     AccountInfo storage accountInfo = accountToInfo[account]; // Count lockups uint256 lockedCount; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       // Lockup count will never overflow 256 bits.       ++lockedCount;     }   } }  // Allocate arrays expiries = new uint256[](lockedCount); amounts = new uint256[](lockedCount);  // Populate results uint256 i; // The number of buckets is always &lt; 256 bits. unchecked {   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     if (escrow.expiration &gt;= block.timestamp &amp;&amp; escrow.totalAmount &gt; 0) {       expiries[i] = escrow.expiration;       amounts[i] = escrow.totalAmount;       ++i;     }   } }  } /*    * @notice Returns the total balance of an account, including locked FETH tokens.    * @dev Use balanceOf to get the number of tokens available for transfer or withdrawal.    * @param account The account to query the total balance of.    * @return balance The total FETH balance tracked for this account.    /   function totalBalanceOf(address account) external view returns (uint256 balance) {     AccountInfo storage accountInfo = accountToInfo[account];     balance = accountInfo.freedBalance; // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be &lt; 256 bits. unchecked {   // Add all lockups   for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {     LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);     if (escrow.expiration == 0) {       break;     }     balance += escrow.totalAmount;   } }  } /    * @notice Returns the total amount of ETH locked in this contract.    * @return supply The total amount of ETH locked in this contract.    /   function totalSupply() external view returns (uint256 supply) {     / It is possible for this to diverge from the total token count by transferring ETH on self destruct        but this is on-par with the WETH implementation and done for gas savings. */     return address(this).balance;   } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-11-08 20:28:18 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: /*
  ･
   *　★
      ･ ｡
        　･　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
​
                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *　
      ･ ｡
　　　　･　　ﾟ☆ ｡
  　　　 *　★ ﾟ･｡ *  ｡
          　　* ☆ ｡･ﾟ*.｡
      　　　ﾟ *.｡☆｡★　･
    *　　ﾟ｡·*･｡ ﾟ*
  　　　☆ﾟ･｡°*. ﾟ
　 ･ ﾟ*｡･ﾟ★｡
　　･ *ﾟ｡　　 *
　･ﾟ*｡★･
 ☆∴｡　*
･ ｡
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts/utils/math/Math.sol"";

import ""./libraries/LockedBalance.sol"";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = ""Foundation Wrapped Ether"";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = ""FETH"";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""Identify all potential DoS (Denial of Service) vulnerabilities in the provided Solidity smart contract."".
Ideas: ""DoS vulnerabilities can manifest in various forms in Solidity contracts, such as Gas Limit DoS, External Call DoS, Block Gas Limit DoS, and State Dependency DoS."".
As the Security Analyst, your primary objective is to conduct a comprehensive inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Denial of Service (DoS). DoS vulnerabilities can occur in the following cases:
1. When loops have an unbounded iteration count, leading to potential gas exhaustion.
2. When the contract makes external calls that can fail or consume excessive gas.
3. When the contract depends on certain state conditions that can be manipulated by an attacker to cause failures.
4. When an attacker can send high-gas transactions to consume most of the block's gas limit, making it difficult for other transactions to be included in the block.
Please conduct a thorough analysis, considering the following information:
1. Review the contract's code logic to identify any potential areas where unbounded loops might cause gas exhaustion.
2. Examine external calls in the contract and ensure they are handled properly to avoid excessive gas consumption or failures.
3. Analyze state-dependent logic to identify any potential manipulations that could cause DoS.
4. Consider the overall design of the contract to ensure it is resilient against high-gas transactions and other DoS tactics.
If you identify any DoS vulnerabilities, respond with: """,
